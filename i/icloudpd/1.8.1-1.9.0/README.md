# Comparing `tmp/icloudpd-1.8.1-py2.py3-none-any.whl.zip` & `tmp/icloudpd-1.9.0-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,48 +1,48 @@
-Zip file size: 56076 bytes, number of entries: 46
--rw-r--r--  2.0 unx        0 b- defN 23-Feb-03 19:07 icloudpd/__init__.py
--rw-r--r--  2.0 unx     3404 b- defN 23-Feb-03 19:07 icloudpd/authentication.py
--rw-r--r--  2.0 unx     1069 b- defN 23-Feb-03 19:07 icloudpd/autodelete.py
--rw-r--r--  2.0 unx    21745 b- defN 23-Feb-03 19:07 icloudpd/base.py
--rw-r--r--  2.0 unx      102 b- defN 23-Feb-03 19:07 icloudpd/constants.py
--rw-r--r--  2.0 unx      509 b- defN 23-Feb-03 19:07 icloudpd/counter.py
--rw-r--r--  2.0 unx     3855 b- defN 23-Feb-03 19:07 icloudpd/download.py
--rw-r--r--  2.0 unx     1478 b- defN 23-Feb-03 19:07 icloudpd/email_notifications.py
--rw-r--r--  2.0 unx     1022 b- defN 23-Feb-03 19:07 icloudpd/exif_datetime.py
--rw-r--r--  2.0 unx     1660 b- defN 23-Feb-03 19:07 icloudpd/logger.py
--rw-r--r--  2.0 unx      604 b- defN 23-Feb-03 19:07 icloudpd/paths.py
--rw-r--r--  2.0 unx      516 b- defN 23-Feb-03 19:07 icloudpd/string_helpers.py
--rw-r--r--  2.0 unx      124 b- defN 23-Feb-03 19:07 pyicloud_ipd/__init__.py
--rw-r--r--  2.0 unx    11468 b- defN 23-Feb-03 19:07 pyicloud_ipd/base.py
--rw-r--r--  2.0 unx    11004 b- defN 23-Feb-03 19:07 pyicloud_ipd/cmdline.py
--rw-r--r--  2.0 unx      875 b- defN 23-Feb-03 19:07 pyicloud_ipd/exceptions.py
--rw-r--r--  2.0 unx     1666 b- defN 23-Feb-03 19:07 pyicloud_ipd/utils.py
--rw-r--r--  2.0 unx      424 b- defN 23-Feb-03 19:07 pyicloud_ipd/services/__init__.py
--rw-r--r--  2.0 unx     1589 b- defN 23-Feb-03 19:07 pyicloud_ipd/services/account.py
--rw-r--r--  2.0 unx     2312 b- defN 23-Feb-03 19:07 pyicloud_ipd/services/calendar.py
--rw-r--r--  2.0 unx     1714 b- defN 23-Feb-03 19:07 pyicloud_ipd/services/contacts.py
--rw-r--r--  2.0 unx     6362 b- defN 23-Feb-03 19:07 pyicloud_ipd/services/findmyiphone.py
--rw-r--r--  2.0 unx    21928 b- defN 23-Feb-03 19:07 pyicloud_ipd/services/photos.py
--rw-r--r--  2.0 unx     3946 b- defN 23-Feb-03 19:07 pyicloud_ipd/services/reminders.py
--rw-r--r--  2.0 unx     2991 b- defN 23-Feb-03 19:07 pyicloud_ipd/services/ubiquity.py
--rw-r--r--  2.0 unx        0 b- defN 23-Feb-03 19:07 tests/__init__.py
--rw-r--r--  2.0 unx     3406 b- defN 23-Feb-03 19:07 tests/test_authentication.py
--rw-r--r--  2.0 unx     4099 b- defN 23-Feb-03 19:07 tests/test_autodelete_photos.py
--rw-r--r--  2.0 unx     6092 b- defN 23-Feb-03 19:07 tests/test_cli.py
--rw-r--r--  2.0 unx     9489 b- defN 23-Feb-03 19:07 tests/test_download_live_photos.py
--rw-r--r--  2.0 unx    68755 b- defN 23-Feb-03 19:07 tests/test_download_photos.py
--rw-r--r--  2.0 unx     5796 b- defN 23-Feb-03 19:07 tests/test_email_notifications.py
--rw-r--r--  2.0 unx     5891 b- defN 23-Feb-03 19:07 tests/test_folder_structure.py
--rw-r--r--  2.0 unx     1684 b- defN 23-Feb-03 19:07 tests/test_listing_albums.py
--rw-r--r--  2.0 unx    11036 b- defN 23-Feb-03 19:07 tests/test_listing_recent_photos.py
--rw-r--r--  2.0 unx     2155 b- defN 23-Feb-03 19:07 tests/test_logger.py
--rw-r--r--  2.0 unx      943 b- defN 23-Feb-03 19:07 tests/test_string_helpers.py
--rw-r--r--  2.0 unx     7848 b- defN 23-Feb-03 19:07 tests/test_two_step_auth.py
--rw-r--r--  2.0 unx        0 b- defN 23-Feb-03 19:07 tests/helpers/__init__.py
--rw-r--r--  2.0 unx      301 b- defN 23-Feb-03 19:07 tests/helpers/print_result_exception.py
--rw-r--r--  2.0 unx     1083 b- defN 23-Feb-03 19:07 icloudpd-1.8.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     1063 b- defN 23-Feb-03 19:07 icloudpd-1.8.1.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 23-Feb-03 19:07 icloudpd-1.8.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       48 b- defN 23-Feb-03 19:07 icloudpd-1.8.1.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       28 b- defN 23-Feb-03 19:07 icloudpd-1.8.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3818 b- defN 23-Feb-03 19:07 icloudpd-1.8.1.dist-info/RECORD
-46 files, 236012 bytes uncompressed, 50024 bytes compressed:  78.8%
+Zip file size: 56843 bytes, number of entries: 46
+-rw-r--r--  2.0 unx        0 b- defN 23-Feb-10 15:27 icloudpd/__init__.py
+-rw-r--r--  2.0 unx     3595 b- defN 23-Feb-10 15:27 icloudpd/authentication.py
+-rw-r--r--  2.0 unx     1069 b- defN 23-Feb-10 15:27 icloudpd/autodelete.py
+-rw-r--r--  2.0 unx    21948 b- defN 23-Feb-10 15:27 icloudpd/base.py
+-rw-r--r--  2.0 unx      102 b- defN 23-Feb-10 15:27 icloudpd/constants.py
+-rw-r--r--  2.0 unx      509 b- defN 23-Feb-10 15:27 icloudpd/counter.py
+-rw-r--r--  2.0 unx     3855 b- defN 23-Feb-10 15:27 icloudpd/download.py
+-rw-r--r--  2.0 unx     1478 b- defN 23-Feb-10 15:27 icloudpd/email_notifications.py
+-rw-r--r--  2.0 unx     1022 b- defN 23-Feb-10 15:27 icloudpd/exif_datetime.py
+-rw-r--r--  2.0 unx     1660 b- defN 23-Feb-10 15:27 icloudpd/logger.py
+-rw-r--r--  2.0 unx      856 b- defN 23-Feb-10 15:27 icloudpd/paths.py
+-rw-r--r--  2.0 unx      516 b- defN 23-Feb-10 15:27 icloudpd/string_helpers.py
+-rw-r--r--  2.0 unx      124 b- defN 23-Feb-10 15:27 pyicloud_ipd/__init__.py
+-rw-r--r--  2.0 unx    12284 b- defN 23-Feb-10 15:27 pyicloud_ipd/base.py
+-rw-r--r--  2.0 unx    11247 b- defN 23-Feb-10 15:27 pyicloud_ipd/cmdline.py
+-rw-r--r--  2.0 unx      939 b- defN 23-Feb-10 15:27 pyicloud_ipd/exceptions.py
+-rw-r--r--  2.0 unx     1666 b- defN 23-Feb-10 15:27 pyicloud_ipd/utils.py
+-rw-r--r--  2.0 unx      424 b- defN 23-Feb-10 15:27 pyicloud_ipd/services/__init__.py
+-rw-r--r--  2.0 unx     1589 b- defN 23-Feb-10 15:27 pyicloud_ipd/services/account.py
+-rw-r--r--  2.0 unx     2312 b- defN 23-Feb-10 15:27 pyicloud_ipd/services/calendar.py
+-rw-r--r--  2.0 unx     1714 b- defN 23-Feb-10 15:27 pyicloud_ipd/services/contacts.py
+-rw-r--r--  2.0 unx     6362 b- defN 23-Feb-10 15:27 pyicloud_ipd/services/findmyiphone.py
+-rw-r--r--  2.0 unx    21928 b- defN 23-Feb-10 15:27 pyicloud_ipd/services/photos.py
+-rw-r--r--  2.0 unx     3946 b- defN 23-Feb-10 15:27 pyicloud_ipd/services/reminders.py
+-rw-r--r--  2.0 unx     2991 b- defN 23-Feb-10 15:27 pyicloud_ipd/services/ubiquity.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Feb-10 15:27 tests/__init__.py
+-rw-r--r--  2.0 unx     3470 b- defN 23-Feb-10 15:27 tests/test_authentication.py
+-rw-r--r--  2.0 unx     4099 b- defN 23-Feb-10 15:27 tests/test_autodelete_photos.py
+-rw-r--r--  2.0 unx     6092 b- defN 23-Feb-10 15:27 tests/test_cli.py
+-rw-r--r--  2.0 unx     9489 b- defN 23-Feb-10 15:27 tests/test_download_live_photos.py
+-rw-r--r--  2.0 unx    70958 b- defN 23-Feb-10 15:27 tests/test_download_photos.py
+-rw-r--r--  2.0 unx     5796 b- defN 23-Feb-10 15:27 tests/test_email_notifications.py
+-rw-r--r--  2.0 unx     5891 b- defN 23-Feb-10 15:27 tests/test_folder_structure.py
+-rw-r--r--  2.0 unx     1684 b- defN 23-Feb-10 15:27 tests/test_listing_albums.py
+-rw-r--r--  2.0 unx    11036 b- defN 23-Feb-10 15:27 tests/test_listing_recent_photos.py
+-rw-r--r--  2.0 unx     2155 b- defN 23-Feb-10 15:27 tests/test_logger.py
+-rw-r--r--  2.0 unx      943 b- defN 23-Feb-10 15:27 tests/test_string_helpers.py
+-rw-r--r--  2.0 unx     7848 b- defN 23-Feb-10 15:27 tests/test_two_step_auth.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Feb-10 15:27 tests/helpers/__init__.py
+-rw-r--r--  2.0 unx      301 b- defN 23-Feb-10 15:27 tests/helpers/print_result_exception.py
+-rw-r--r--  2.0 unx     1083 b- defN 23-Feb-10 15:27 icloudpd-1.9.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1092 b- defN 23-Feb-10 15:27 icloudpd-1.9.0.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Feb-10 15:27 icloudpd-1.9.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       48 b- defN 23-Feb-10 15:27 icloudpd-1.9.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       28 b- defN 23-Feb-10 15:27 icloudpd-1.9.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3818 b- defN 23-Feb-10 15:27 icloudpd-1.9.0.dist-info/RECORD
+46 files, 240077 bytes uncompressed, 50791 bytes compressed:  78.8%
```

## zipnote {}

```diff
@@ -114,26 +114,26 @@
 
 Filename: tests/helpers/__init__.py
 Comment: 
 
 Filename: tests/helpers/print_result_exception.py
 Comment: 
 
-Filename: icloudpd-1.8.1.dist-info/LICENSE
+Filename: icloudpd-1.9.0.dist-info/LICENSE
 Comment: 
 
-Filename: icloudpd-1.8.1.dist-info/METADATA
+Filename: icloudpd-1.9.0.dist-info/METADATA
 Comment: 
 
-Filename: icloudpd-1.8.1.dist-info/WHEEL
+Filename: icloudpd-1.9.0.dist-info/WHEEL
 Comment: 
 
-Filename: icloudpd-1.8.1.dist-info/entry_points.txt
+Filename: icloudpd-1.9.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: icloudpd-1.8.1.dist-info/top_level.txt
+Filename: icloudpd-1.9.0.dist-info/top_level.txt
 Comment: 
 
-Filename: icloudpd-1.8.1.dist-info/RECORD
+Filename: icloudpd-1.9.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## icloudpd/authentication.py

```diff
@@ -8,48 +8,50 @@
 
 class TwoStepAuthRequiredError(Exception):
     """
     Raised when 2SA is required. base.py catches this exception
     and sends an email notification.
     """
 
-
-def authenticate(
-        username,
-        password,
-        cookie_directory=None,
-        raise_error_on_2sa=False,
-        client_id=None
-):
-    """Authenticate with iCloud username and password"""
-    logger = setup_logger()
-    logger.debug("Authenticating...")
-    try:
-        # If password not provided on command line variable will be set to None
-        # and PyiCloud will attempt to retrieve from its keyring
-        icloud = pyicloud_ipd.PyiCloudService(
-            username, password,
-            cookie_directory=cookie_directory,
-            client_id=client_id)
-    except pyicloud_ipd.exceptions.NoStoredPasswordAvailable:
-        # Prompt for password if not stored in PyiCloud's keyring
-        password = click.prompt("iCloud Password", hide_input=True)
-        icloud = pyicloud_ipd.PyiCloudService(
-            username, password,
-            cookie_directory=cookie_directory,
-            client_id=client_id)
-
-    if icloud.requires_2sa:
-        if raise_error_on_2sa:
-            raise TwoStepAuthRequiredError(
-                "Two-step/two-factor authentication is required!"
-            )
-        logger.info("Two-step/two-factor authentication is required!")
-        request_2sa(icloud, logger)
-    return icloud
+def authenticator(domain):
+    """Wraping authentication with domain context"""
+    def authenticate_(
+            username,
+            password,
+            cookie_directory=None,
+            raise_error_on_2sa=False,
+            client_id=None,
+    ):
+        """Authenticate with iCloud username and password"""
+        logger = setup_logger()
+        logger.debug("Authenticating...")
+        while True:
+            try:
+                # If password not provided on command line variable will be set to None
+                # and PyiCloud will attempt to retrieve from its keyring
+                icloud = pyicloud_ipd.PyiCloudService(
+                    domain,
+                    username, password,
+                    cookie_directory=cookie_directory,
+                    client_id=client_id,
+                    )
+                break
+            except pyicloud_ipd.exceptions.NoStoredPasswordAvailable:
+                # Prompt for password if not stored in PyiCloud's keyring
+                password = click.prompt("iCloud Password", hide_input=True)
+
+        if icloud.requires_2sa:
+            if raise_error_on_2sa:
+                raise TwoStepAuthRequiredError(
+                    "Two-step/two-factor authentication is required!"
+                )
+            logger.info("Two-step/two-factor authentication is required!")
+            request_2sa(icloud, logger)
+        return icloud
+    return authenticate_
 
 
 def request_2sa(icloud, logger):
     """Request two-step authentication. Prompts for SMS or device"""
     devices = icloud.trusted_devices
     devices_count = len(devices)
     device_index = 0
```

## icloudpd/base.py

```diff
@@ -14,20 +14,20 @@
 
 from tqdm import tqdm
 from tzlocal import get_localzone
 
 from pyicloud_ipd.exceptions import PyiCloudAPIResponseError
 
 from icloudpd.logger import setup_logger
-from icloudpd.authentication import authenticate, TwoStepAuthRequiredError
+from icloudpd.authentication import authenticator, TwoStepAuthRequiredError
 from icloudpd import download
 from icloudpd.email_notifications import send_2sa_notification
 from icloudpd.string_helpers import truncate_middle
 from icloudpd.autodelete import autodelete_photos
-from icloudpd.paths import local_download_path
+from icloudpd.paths import clean_filename, local_download_path
 from icloudpd import exif_datetime
 # Must import the constants object so that we can mock values in tests.
 from icloudpd import constants
 from icloudpd.counter import Counter
 
 CONTEXT_SETTINGS = {"help_option_names": ["-h", "--help"]}
 
@@ -197,14 +197,20 @@
 @click.option(
     "--delete-after-download",
     help='Delete the photo/video after download it.'
     + ' The deleted items will be appear in the "Recently Deleted".'
     + ' Therefore, should not combine with --auto-delete option.',
     is_flag=True,
 )
+@click.option(
+    "--domain",
+    help="What iCloud root domain to use. Use 'cn' for mainland China (default: 'com')",
+    type=click.Choice(["com", "cn"]),
+    default="com",
+)
 @click.version_option()
 # pylint: disable-msg=too-many-arguments,too-many-statements
 # pylint: disable-msg=too-many-branches,too-many-locals
 def main(
         directory,
         username,
         password,
@@ -228,15 +234,16 @@
         smtp_port,
         smtp_no_tls,
         notification_email,
         log_level,
         no_progress_bar,
         notification_script,
         threads_num,    # pylint: disable=W0613
-        delete_after_download
+        delete_after_download,
+        domain
 ):
     """Download all iCloud photos to a local directory"""
 
     logger = setup_logger()
     if only_print_filenames:
         logger.disabled = True
     else:
@@ -261,15 +268,15 @@
 
     raise_error_on_2sa = (
         smtp_username is not None
         or notification_email is not None
         or notification_script is not None
     )
     try:
-        icloud = authenticate(
+        icloud = authenticator(domain)(
             username,
             password,
             cookie_directory,
             raise_error_on_2sa,
             client_id=os.environ.get("CLIENT_ID"),
         )
     except TwoStepAuthRequiredError:
@@ -374,22 +381,23 @@
         logger.set_tqdm(None)
     else:
         photos_enumerator = tqdm(photos, **tqdm_kwargs)
         logger.set_tqdm(photos_enumerator)
 
     def download_photo(counter, photo):
         """internal function for actually downloading the photos"""
+        filename = clean_filename(photo.filename)
         if skip_videos and photo.item_type != "image":
             logger.set_tqdm_description(
-                f"Skipping {photo.filename}, only downloading photos."
+                f"Skipping {filename}, only downloading photos."
             )
             return
         if photo.item_type not in ("image", "movie"):
             logger.set_tqdm_description(
-                f"Skipping {photo.filename}, only downloading photos and videos. "
+                f"Skipping {filename}, only downloading photos and videos. "
                 f"(Item type was: {photo.item_type})"
             )
             return
         try:
             created_date = photo.created.astimezone(get_localzone())
         except (ValueError, OSError):
             logger.set_tqdm_description(
@@ -438,16 +446,14 @@
             print(
                 "Include a link to the Gist in your issue, so that we can "
                 "see what went wrong.\n")
             return
 
         if size not in versions and size != "original":
             if force_size:
-                filename = photo.filename.encode(
-                    "utf-8").decode("ascii", "ignore")
                 logger.set_tqdm_description(
                     f"{size} size does not exist for {filename}. Skipping...", logging.ERROR, )
                 return
             download_size = "original"
 
         download_path = local_download_path(
             photo, download_size, download_dir)
@@ -461,15 +467,16 @@
             original_download_path = (f"-{size}.").join(
                 download_path.rsplit(".", 1)
             )
             file_exists = os.path.isfile(original_download_path)
 
         if file_exists:
             # for later: this crashes if download-size medium is specified
-            file_size = os.stat(original_download_path or download_path).st_size
+            file_size = os.stat(
+                original_download_path or download_path).st_size
             version = photo.versions[download_size]
             photo_size = version["size"]
             if file_size != photo_size:
                 download_path = (f"-{photo_size}.").join(
                     download_path.rsplit(".", 1)
                 )
                 logger.set_tqdm_description(
@@ -493,15 +500,15 @@
                 )
 
                 download_result = download.download_media(
                     icloud, photo, download_path, download_size
                 )
 
                 if download_result:
-                    if set_exif_datetime and photo.filename.lower().endswith(
+                    if set_exif_datetime and clean_filename(photo.filename).lower().endswith(
                             (".jpg", ".jpeg")) and not exif_datetime.get_photo_exif(download_path):
                         # %Y:%m:%d looks wrong, but it's the correct format
                         date_str = created_date.strftime(
                             "%Y-%m-%d %H:%M:%S%z")
                         logger.debug(
                             "Setting EXIF timestamp for %s: %s",
                             download_path,
@@ -553,15 +560,15 @@
                             f"Downloading {truncated_path}")
                         download.download_media(
                             icloud, photo, lp_download_path, lp_size
                         )
 
     def delete_photo(photo):
         """Delete a photo from the iCloud account."""
-        logger.info("Deleting %s", photo.filename)
+        logger.info("Deleting %s", clean_filename(photo.filename))
         # pylint: disable=W0212
         url = f"{icloud.photos._service_endpoint}/records/modify?"\
             f"{urllib.parse.urlencode(icloud.photos.params)}"
         post_data = json.dumps(
             {
                 "atomic": True,
                 "desiredKeys": ["isDeleted"],
```

## icloudpd/paths.py

```diff
@@ -1,18 +1,30 @@
 """Path functions"""
 import os
 
 
+def clean_filename(filename):
+    """Replaces invalid chars in filenames with '_'"""
+    result = filename.encode(
+        "utf-8").decode("ascii", "ignore")
+    invalid = '<>:"/\\|?* \0'
+
+    for char in invalid:
+        result = result.replace(char, '_')
+
+    return result
+
+
 def local_download_path(media, size, download_dir):
     """Returns the full download path, including size"""
     filename = filename_with_size(media, size)
     download_path = os.path.join(download_dir, filename)
     return download_path
 
 
 def filename_with_size(media, size):
     """Returns the filename with size, e.g. IMG1234.jpg, IMG1234-small.jpg"""
     # Strip any non-ascii characters.
-    filename = media.filename.encode("utf-8").decode("ascii", "ignore")
+    filename = clean_filename(media.filename)
     if size == 'original':
         return filename
     return (f"-{size}.").join(filename.rsplit(".", 1))
```

## pyicloud_ipd/base.py

```diff
@@ -5,16 +5,18 @@
 import json
 import logging
 import requests
 import sys
 import tempfile
 import os
 from re import match
+import urllib3
 
 from pyicloud_ipd.exceptions import (
+    PyiCloudConnectionException,
     PyiCloudFailedLoginException,
     PyiCloudAPIResponseError,
     PyiCloud2SARequiredError,
     PyiCloudServiceNotActivatedErrror
 )
 from pyicloud_ipd.services import (
     FindMyiPhoneServiceManager,
@@ -61,15 +63,18 @@
         module = inspect.getmodule(callee[0])
         logger = logging.getLogger(module.__name__).getChild('http')
         if self.service._password_filter not in logger.filters:
             logger.addFilter(self.service._password_filter)
 
         logger.debug("%s %s %s", args[0], args[1], kwargs.get('data', ''))
 
-        response = super(PyiCloudSession, self).request(*args, **kwargs)
+        try:
+            response = super(PyiCloudSession, self).request(*args, **kwargs)
+        except requests.exceptions.SSLError:
+            raise PyiCloudConnectionException("Error establishing secure connection. Try --domain parameter")
 
         content_type = response.headers.get('Content-Type', '').split(';')[0]
         json_mimetypes = ['application/json', 'text/json']
 
         if not response.ok and content_type not in json_mimetypes:
             self._raise_error(response.status_code, response.reason)
 
@@ -130,29 +135,35 @@
     Usage:
         from pyicloud_ipd import PyiCloudService
         pyicloud = PyiCloudService('username@apple.com', 'password')
         pyicloud_ipd.iphone.location()
     """
 
     def __init__(
-        self, apple_id, password=None, cookie_directory=None, verify=True,
+        self, domain, apple_id, password=None, cookie_directory=None, verify=True,
         client_id=None
     ):
         if password is None:
             password = get_password_from_keyring(apple_id)
 
         self.data = {}
         self.client_id = client_id or str(uuid.uuid1()).upper()
         self.user = {'apple_id': apple_id, 'password': password}
 
         self._password_filter = PyiCloudPasswordFilter(password)
         logger.addFilter(self._password_filter)
 
-        self._home_endpoint = 'https://www.icloud.com'
-        self._setup_endpoint = 'https://setup.icloud.com/setup/ws/1'
+        if (domain == 'com'):
+            self._home_endpoint = 'https://www.icloud.com'
+            self._setup_endpoint = 'https://setup.icloud.com/setup/ws/1'
+        elif (domain == 'cn'):
+            self._home_endpoint = 'https://www.icloud.com.cn'
+            self._setup_endpoint = 'https://setup.icloud.com.cn/setup/ws/1'
+        else:
+            raise NotImplementedError(f"Domain '{domain}' is not supported yet")
 
         self._base_login_url = '%s/login' % self._setup_endpoint
 
         if cookie_directory:
             self._cookie_directory = os.path.expanduser(
                 os.path.normpath(cookie_directory)
             )
@@ -207,19 +218,25 @@
 
         try:
             req = self.session.post(
                 self._base_login_url,
                 params=self.params,
                 data=json.dumps(data)
             )
+            resp = req.json()
         except PyiCloudAPIResponseError as error:
             msg = 'Invalid email/password combination.'
             raise PyiCloudFailedLoginException(msg, error)
 
-        resp = req.json()
+        # {'domainToUse': 'iCloud.com'}
+        domain_to_use = resp.get('domainToUse')
+        if domain_to_use != None:
+            msg = f'Apple insists on using {domain_to_use} for your request. Please use --domain parameter'
+            raise PyiCloudConnectionException(msg)
+
         self.params.update({'dsid': resp['dsInfo']['dsid']})
 
         if not os.path.exists(self._cookie_directory):
             os.mkdir(self._cookie_directory)
         self.session.cookies.save()
         logger.debug("Cookies saved to %s", self._get_cookiejar_path())
```

## pyicloud_ipd/cmdline.py

```diff
@@ -168,18 +168,27 @@
         "--outputfile",
         action="store_true",
         dest="output_to_file",
         default="",
         help="Save device data to a file in the current directory.",
     )
 
+    parser.add_argument(
+        "--domain",
+        action="store",
+        dest="domain",
+        default="com",
+        help="Root Domain for requests to iCloud. com or cn",
+    )
+
     command_line = parser.parse_args(args)
 
     username = command_line.username
     password = command_line.password
+    domain   = command_line.domain
 
     if username and command_line.delete_from_keyring:
         utils.delete_password_in_keyring(username)
 
     failure_count = 0
     while True:
         # Which password we use is determined by your username, so we
@@ -194,14 +203,15 @@
             )
 
         if not password:
             parser.error('No password supplied')
 
         try:
             api = pyicloud_ipd.PyiCloudService(
+                domain,
                 username.strip(),
                 password.strip()
             )
             if (
                 not utils.password_exists_in_keyring(username) and
                 command_line.interactive and
                 confirm("Save password in keyring? ")
```

## pyicloud_ipd/exceptions.py

```diff
@@ -1,12 +1,15 @@
 
 class PyiCloudException(Exception):
     pass
 
 
+class PyiCloudConnectionException(PyiCloudException):
+    pass
+
 class PyiCloudNoDevicesException(PyiCloudException):
     pass
 
 
 class PyiCloudAPIResponseError(PyiCloudException):
     def __init__(self, reason, code):
         self.reason = reason
```

## tests/test_authentication.py

```diff
@@ -1,15 +1,15 @@
 from unittest import TestCase
 import os
 from vcr import VCR
 import pytest
 from click.testing import CliRunner
 import pyicloud_ipd
 from icloudpd.base import main
-from icloudpd.authentication import authenticate, TwoStepAuthRequiredError
+from icloudpd.authentication import authenticator, TwoStepAuthRequiredError
 import inspect
 import shutil
 import glob
 
 vcr = VCR(decode_compressed_response=True)
 
 
@@ -19,51 +19,53 @@
         self._caplog = caplog
 
     def test_failed_auth(self):
         with vcr.use_cassette("tests/vcr_cassettes/failed_auth.yml"):
             with self.assertRaises(
                 pyicloud_ipd.exceptions.PyiCloudFailedLoginException
             ) as context:
-                authenticate(
+                authenticator("com")(
                     "bad_username",
                     "bad_password",
                     client_id="EC5646DE-9423-11E8-BF21-14109FE0B321",
                 )
 
-        self.assertTrue("Invalid email/password combination." in str(context.exception))
+        self.assertTrue(
+            "Invalid email/password combination." in str(context.exception))
 
     def test_2sa_required(self):
         with vcr.use_cassette("tests/vcr_cassettes/auth_requires_2sa.yml"):
             with self.assertRaises(TwoStepAuthRequiredError) as context:
                 # To re-record this HTTP request,
                 # delete ./tests/vcr_cassettes/auth_requires_2sa.yml,
                 # put your actual credentials in here, run the test,
                 # and then replace with dummy credentials.
-                authenticate(
+                authenticator("com")(
                     "jdoe@gmail.com",
                     "password1",
                     raise_error_on_2sa=True,
                     client_id="EC5646DE-9423-11E8-BF21-14109FE0B321",
                 )
 
             self.assertTrue(
                 "Two-step/two-factor authentication is required!"
                 in str(context.exception)
             )
 
     def test_successful_auth(self):
         with vcr.use_cassette("tests/vcr_cassettes/successful_auth.yml"):
-            authenticate(
+            authenticator("com")(
                 "jdoe@gmail.com",
                 "password1",
                 client_id="EC5646DE-9423-11E8-BF21-14109FE0B321",
             )
 
     def test_password_prompt(self):
-        base_dir = os.path.normpath(f"tests/fixtures/Photos/{inspect.stack()[0][3]}")
+        base_dir = os.path.normpath(
+            f"tests/fixtures/Photos/{inspect.stack()[0][3]}")
         if os.path.exists(base_dir):
             shutil.rmtree(base_dir)
         os.makedirs(base_dir)
 
         with vcr.use_cassette("tests/vcr_cassettes/listing_photos.yml"):
             runner = CliRunner(env={
                 "CLIENT_ID": "DE309E26-942E-11E8-92F5-14109FE0B321"
@@ -87,10 +89,11 @@
                 self._caplog.text
             )
             self.assertIn(
                 "INFO     All photos have been downloaded!", self._caplog.text
             )
             assert result.exit_code == 0
 
-        files_in_result = glob.glob(os.path.join(base_dir, "**/*.*"), recursive=True)
+        files_in_result = glob.glob(os.path.join(
+            base_dir, "**/*.*"), recursive=True)
 
         assert sum(1 for _ in files_in_result) == 0
```

## tests/test_download_photos.py

```diff
@@ -1599,7 +1599,65 @@
 
         files_in_result = glob.glob(os.path.join(base_dir, "**/*.*"), recursive=True)
 
         assert sum(1 for _ in files_in_result) == len(files_to_download) + len(files_to_create)
 
         for file_name in files_to_download + ([file_name for (file_name, _) in files_to_create]):
             assert os.path.exists(os.path.join(base_dir, os.path.normpath(file_name))), f"File {file_name} expected, but does not exist"
+
+    def test_download_normalized_names(self):
+        base_dir = os.path.normpath(f"tests/fixtures/Photos/{inspect.stack()[0][3]}")
+        if os.path.exists(base_dir):
+            shutil.rmtree(base_dir)
+        os.makedirs(base_dir)
+
+        files_to_create = [
+            ("2018/07/30/IMG_7408.JPG", 1151066),
+            ("2018/07/30/IMG_7407.JPG", 656257),
+        ]
+
+        files_to_download = [
+            # <>:"/\|?*  -- windows
+            # / & \0x00 -- linux
+            '2018/07/31/i_n_v_a_l_i_d_p_a_t_h_.JPG' #SU1HXzc0MDkuSlBH -> i/n v:a\0l*i?d\p<a>t"h|.JPG -> aS9uIHY6YQBsKmk/ZFxwPGE+dCJofC5KUEc=
+        ]
+
+        os.makedirs(os.path.join(base_dir, "2018/07/30/"))
+        for (file_name, file_size) in files_to_create:
+            with open(os.path.join(base_dir, file_name), "a") as f:
+                f.truncate(file_size)
+
+        with vcr.use_cassette("tests/vcr_cassettes/listing_photos_bad_filename.yml"):
+            # Pass fixed client ID via environment variable
+            runner = CliRunner(env={
+                "CLIENT_ID": "DE309E26-942E-11E8-92F5-14109FE0B321"
+            })
+            result = runner.invoke(
+                main,
+                [
+                    "--username",
+                    "jdoe@gmail.com",
+                    "--password",
+                    "password1",
+                    "--recent",
+                    "5",
+                    "--skip-videos",
+                    "--skip-live-photos",
+                    "--set-exif-datetime",
+                    "--no-progress-bar",
+                    "--threads-num",
+                    1,
+                    "-d",
+                    base_dir,
+                ],
+            )
+            print_result_exception(result)
+
+            assert result.exit_code == 0
+
+        files_in_result = glob.glob(os.path.join(base_dir, "**/*.*"), recursive=True)
+
+        assert sum(1 for _ in files_in_result) == len(files_to_create) + len(files_to_download)
+
+        for file_name in files_to_download + ([file_name for (file_name, _) in files_to_create]):
+            assert os.path.exists(os.path.join(base_dir, os.path.normpath(file_name))), f"File {file_name} expected, but does not exist"
+
```

## Comparing `icloudpd-1.8.1.dist-info/LICENSE` & `icloudpd-1.9.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `icloudpd-1.8.1.dist-info/METADATA` & `icloudpd-1.9.0.dist-info/METADATA`

 * *Files 5% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 Metadata-Version: 2.1
 Name: icloudpd
-Version: 1.8.1
+Version: 1.9.0
 Summary: icloudpd is a command-line tool to download photos and videos from iCloud.
 Home-page: https://github.com/icloud-photos-downloader/icloud_photos_downloader
 Maintainer: The iCloud Authors
 Maintainer-email: 
 License: MIT
 Classifier: Intended Audience :: Developers
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
+Requires-Python: >=3.7,<3.12
 License-File: LICENSE
 Requires-Dist: requests (<3,>=2.28.2)
 Requires-Dist: schema (<0.8,>=0.7.5)
 Requires-Dist: click (<9,>=8.1.3)
 Requires-Dist: python-dateutil (<3,>=2.8.2)
 Requires-Dist: tqdm (<5,>=4.64.1)
 Requires-Dist: piexif (<2,>=1.1.3)
```

## Comparing `icloudpd-1.8.1.dist-info/RECORD` & `icloudpd-1.9.0.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,46 +1,46 @@
 icloudpd/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-icloudpd/authentication.py,sha256=hrJ-b5OepmVNqNlMaPOiu7n8F3_D79M9E1aovI62mF4,3404
+icloudpd/authentication.py,sha256=mJB62rBkcqbXas0jSGZxfjpTPNzvK2JRsC-o-smVG84,3595
 icloudpd/autodelete.py,sha256=STgeS78Gpq4Os4F8tWg0UyH_fOdzPqYdQHyTDke-ajc,1069
-icloudpd/base.py,sha256=B7zCByrlxq7DNwzGYA9I-IQXuQdP3GBiPDcho-6bEcI,21745
+icloudpd/base.py,sha256=SiC_LShmW5gl_RnpHRd2nV_cSGWzE6LhCo6NUqYkdMA,21948
 icloudpd/constants.py,sha256=bZ2o3VukW0g-A9USOFcdguXqJaJNqKUu3oMQdz_TD2k,102
 icloudpd/counter.py,sha256=n_KD_Pph9hb2JcjnLdt8SFwpsraKEmKl1MQFGQWlSu0,509
 icloudpd/download.py,sha256=LZI8ZNmGGXJF0Pdk4Y6J8QOqWJnQtEPLrCRJzMhmdj8,3855
 icloudpd/email_notifications.py,sha256=2Io_6FDEdZkUvTQBCnJgBYek7_pzaZsi3jor1DEf64M,1478
 icloudpd/exif_datetime.py,sha256=oNyHWFnYNF23k_bhLGu8SK9E8HL0mttJTW0Uq2KBG1w,1022
 icloudpd/logger.py,sha256=AIJJB-m8kmc710lNbVDcmm7O3GILTkQLW2EWUF3HD38,1660
-icloudpd/paths.py,sha256=Xz0nykjhNE7RN0kHZBWYgsHgq_YHAZ6XhnXpziRF40A,604
+icloudpd/paths.py,sha256=lGRqZPbktlMv7Hw00hBPY1R056Q4M1nEdIiVkAHLjec,856
 icloudpd/string_helpers.py,sha256=Hswk_MKKeJMF393eU3K2NSe-5BGbfRafu0ZaV5Sl1No,516
 pyicloud_ipd/__init__.py,sha256=aTi9TCx7w7ehlVn_FnBTwSPsBVSZs5dSTBzp1_rc920,124
-pyicloud_ipd/base.py,sha256=ihjw6Npri2twLC3K4Tdpxot5A5pcKYUTLGYIhGTtRoY,11468
-pyicloud_ipd/cmdline.py,sha256=YkR5m7jW9HiDROBPr3uDkJFdMz4SFFaKVoKXLyW_bHg,11004
-pyicloud_ipd/exceptions.py,sha256=yclMDqJ91bZaGiBzZjShm0cLHCuanrV9B4RzNnarKmY,875
+pyicloud_ipd/base.py,sha256=df7oVACpqKgg4JSySotlRDvLkPFeBm9mqpPmCNkyoPo,12284
+pyicloud_ipd/cmdline.py,sha256=MoIRKLh3Om6Cfl_pn5kHLCHPORmO9D1t23Q8qfZRWm4,11247
+pyicloud_ipd/exceptions.py,sha256=eCAmZkHNahxoq6xDjO4ATFZMJ5Cin00fuuV_xA5wumU,939
 pyicloud_ipd/utils.py,sha256=d2s1_yfWQ8nAot59SytLgfapXmMqUTNinlFiy_QOozM,1666
 pyicloud_ipd/services/__init__.py,sha256=MgjKJSea-1wiPloj1Xxc5vvOXiXQFfeARexzszso8mM,424
 pyicloud_ipd/services/account.py,sha256=VbioZ1Y7m6HILdnTXSxYxWPJTcTOej9PMK9HaOKDd64,1589
 pyicloud_ipd/services/calendar.py,sha256=l2oY_kE0n1v0IUniFLNT9NgstUaC-qvERKchh3c5rjQ,2312
 pyicloud_ipd/services/contacts.py,sha256=OxbyU4s3F7dFfStqpaHhfZnvMNNwMpQlOm6fuLMG_6o,1714
 pyicloud_ipd/services/findmyiphone.py,sha256=YBFo2ZP-nkfA3IMEaXHiCsKa8VhK0t1IBI9DDMM7TYg,6362
 pyicloud_ipd/services/photos.py,sha256=bY0pKkRBGAlsNtKPCxcSeGexKCsqHl-LHkXnm913_ys,21928
 pyicloud_ipd/services/reminders.py,sha256=NHPsY7Q4QwuXJTevY9euSSdC5mTQzf4P_2GK4CKEDaA,3946
 pyicloud_ipd/services/ubiquity.py,sha256=AyJ7twbwTQtdT3z-IeX-sPIjdkUmhDnfR8RqluEtVXA,2991
 tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/test_authentication.py,sha256=CB3Wyb3XvWYbrV2Cmp8pmlgTug8Km7qV4FVEpxw3dAI,3406
+tests/test_authentication.py,sha256=nvlL36ahAzwWI_BsK3nVY97Ve6ck8yV1oGsJ_w_NYVg,3470
 tests/test_autodelete_photos.py,sha256=ez2ZkWe2tT9MLNVh9zW5AEi-pYf2RM5UB42S90vV0t8,4099
 tests/test_cli.py,sha256=u1RmgcZeByWc1Sk2oBNwyLaAdpvTrAe38yxTaIcdoag,6092
 tests/test_download_live_photos.py,sha256=A-UKHfl1TYjMHpuhaifwiZDYJc4fm8YiMGjAyJhs8NY,9489
-tests/test_download_photos.py,sha256=7fsiVrdrzpZIIokCquSAFQaIWpMnEHrQ71giUgRVi_U,68755
+tests/test_download_photos.py,sha256=jCaDcdvCIf7ht_V8KN1AJM_0HW6AQ1FppVvLJp8X07o,70958
 tests/test_email_notifications.py,sha256=_7nxjlE_pLDYEtVy4sazfOeSVQ-gYsrG8cEO4FxSNRk,5796
 tests/test_folder_structure.py,sha256=ijoNVYWuEsTYpxgqKniYUvw6pUjbk0DPQeS9wJpnHwY,5891
 tests/test_listing_albums.py,sha256=_30tU_seLgb3jdZ8tWVmjiBHvE5HrILutbwJNgAXGkw,1684
 tests/test_listing_recent_photos.py,sha256=-OxE9AkSfzrrD1t-C_Cu28612Dg3VjMvceqyJZ36GLg,11036
 tests/test_logger.py,sha256=la3d9XN_BJrh-Q74nAbb1NCIeKrphPjd9rF6nCsh5cM,2155
 tests/test_string_helpers.py,sha256=YI0aBwPVNhdXwo3DvRSSXzZexHs00JqSvvCBV4rInY8,943
 tests/test_two_step_auth.py,sha256=hui-1z-Pfwj95Xy3gBHKKa2_81Otuq8MVbagKU2bECw,7848
 tests/helpers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/helpers/print_result_exception.py,sha256=REqyuxnNaqTBHfFO6StpXicfxg3HF03ogrzx3cPE-nc,301
-icloudpd-1.8.1.dist-info/LICENSE,sha256=uwT2rbVc8xLz9f78VZvzMryPsr1oDjCQQUScGGRK44U,1083
-icloudpd-1.8.1.dist-info/METADATA,sha256=RwsU12CHaEXQ2usPtxulYeiYiSFw4vuQR5Tazx0IZu4,1063
-icloudpd-1.8.1.dist-info/WHEEL,sha256=bb2Ot9scclHKMOLDEHY6B2sicWOgugjFKaJsT7vwMQo,110
-icloudpd-1.8.1.dist-info/entry_points.txt,sha256=2LN9wzyxOujHbb9AqxR0L41Ft2h4Z_1839jkncDR_9k,48
-icloudpd-1.8.1.dist-info/top_level.txt,sha256=QkanIl0mnpWbI7r5bT29a9_3jcGPswia9Dbp-tuLOdM,28
-icloudpd-1.8.1.dist-info/RECORD,,
+icloudpd-1.9.0.dist-info/LICENSE,sha256=uwT2rbVc8xLz9f78VZvzMryPsr1oDjCQQUScGGRK44U,1083
+icloudpd-1.9.0.dist-info/METADATA,sha256=qZeVK-UyyzZdWBycQh6akCHgvuThRMbKbIDhJlkED7Q,1092
+icloudpd-1.9.0.dist-info/WHEEL,sha256=bb2Ot9scclHKMOLDEHY6B2sicWOgugjFKaJsT7vwMQo,110
+icloudpd-1.9.0.dist-info/entry_points.txt,sha256=2LN9wzyxOujHbb9AqxR0L41Ft2h4Z_1839jkncDR_9k,48
+icloudpd-1.9.0.dist-info/top_level.txt,sha256=QkanIl0mnpWbI7r5bT29a9_3jcGPswia9Dbp-tuLOdM,28
+icloudpd-1.9.0.dist-info/RECORD,,
```

