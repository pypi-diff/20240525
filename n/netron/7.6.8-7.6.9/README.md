# Comparing `tmp/netron-7.6.8-py3-none-any.whl.zip` & `tmp/netron-7.6.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,154 +1,154 @@
-Zip file size: 1699062 bytes, number of entries: 152
--rw-r--r--  2.0 unx     1526 b- defN 24-May-18 02:17 netron/__init__.py
--rw-r--r--  2.0 unx    57928 b- defN 24-May-18 02:17 netron/acuity-metadata.json
--rw-r--r--  2.0 unx    22154 b- defN 24-May-18 02:17 netron/acuity.js
--rw-r--r--  2.0 unx    11404 b- defN 24-May-18 02:17 netron/armnn-metadata.json
--rw-r--r--  2.0 unx    99904 b- defN 24-May-18 02:17 netron/armnn-schema.js
--rw-r--r--  2.0 unx    12186 b- defN 24-May-18 02:17 netron/armnn.js
--rwxr-xr-x  2.0 unx    15640 b- defN 24-May-18 02:17 netron/barracuda.js
--rw-r--r--  2.0 unx    26395 b- defN 24-May-18 02:17 netron/base.js
--rw-r--r--  2.0 unx     2017 b- defN 24-May-18 02:17 netron/bigdl-metadata.json
--rw-r--r--  2.0 unx    23686 b- defN 24-May-18 02:17 netron/bigdl-proto.js
--rw-r--r--  2.0 unx    11051 b- defN 24-May-18 02:17 netron/bigdl.js
--rw-r--r--  2.0 unx    32794 b- defN 24-May-18 02:17 netron/browser.js
--rw-r--r--  2.0 unx     9505 b- defN 24-May-18 02:17 netron/caffe-metadata.json
--rw-r--r--  2.0 unx   182571 b- defN 24-May-18 02:17 netron/caffe-proto.js
--rw-r--r--  2.0 unx    25175 b- defN 24-May-18 02:17 netron/caffe.js
--rw-r--r--  2.0 unx   863689 b- defN 24-May-18 02:17 netron/caffe2-metadata.json
--rw-r--r--  2.0 unx    59284 b- defN 24-May-18 02:17 netron/caffe2-proto.js
--rw-r--r--  2.0 unx    20638 b- defN 24-May-18 02:17 netron/caffe2.js
--rw-r--r--  2.0 unx      791 b- defN 24-May-18 02:17 netron/cambricon.js
--rw-r--r--  2.0 unx      890 b- defN 24-May-18 02:17 netron/catboost.js
--rw-r--r--  2.0 unx    36814 b- defN 24-May-18 02:17 netron/circle-metadata.json
--rw-r--r--  2.0 unx   121498 b- defN 24-May-18 02:17 netron/circle-schema.js
--rw-r--r--  2.0 unx    23748 b- defN 24-May-18 02:17 netron/circle.js
--rw-r--r--  2.0 unx    14193 b- defN 24-May-18 02:17 netron/cntk-metadata.json
--rw-r--r--  2.0 unx    11085 b- defN 24-May-18 02:17 netron/cntk-proto.js
--rw-r--r--  2.0 unx    42286 b- defN 24-May-18 02:17 netron/cntk.js
--rw-r--r--  2.0 unx    16093 b- defN 24-May-18 02:17 netron/coreml-metadata.json
--rw-r--r--  2.0 unx   673516 b- defN 24-May-18 02:17 netron/coreml-proto.js
--rw-r--r--  2.0 unx    68689 b- defN 24-May-18 02:17 netron/coreml.js
--rw-r--r--  2.0 unx    96165 b- defN 24-May-18 02:17 netron/dagre.js
--rw-r--r--  2.0 unx    20570 b- defN 24-May-18 02:17 netron/darknet-metadata.json
--rw-r--r--  2.0 unx    55349 b- defN 24-May-18 02:17 netron/darknet.js
--rw-r--r--  2.0 unx     1417 b- defN 24-May-18 02:17 netron/dl4j-metadata.json
--rw-r--r--  2.0 unx    15309 b- defN 24-May-18 02:17 netron/dl4j.js
--rw-r--r--  2.0 unx     2309 b- defN 24-May-18 02:17 netron/dlc-metadata.json
--rw-r--r--  2.0 unx     8427 b- defN 24-May-18 02:17 netron/dlc-schema.js
--rw-r--r--  2.0 unx    25980 b- defN 24-May-18 02:17 netron/dlc.js
--rw-r--r--  2.0 unx     1777 b- defN 24-May-18 02:17 netron/dnn-metadata.json
--rw-r--r--  2.0 unx    10997 b- defN 24-May-18 02:17 netron/dnn-proto.js
--rw-r--r--  2.0 unx     9189 b- defN 24-May-18 02:17 netron/dnn.js
--rw-r--r--  2.0 unx    34494 b- defN 24-May-18 02:17 netron/favicon.ico
--rw-r--r--  2.0 unx    16331 b- defN 24-May-18 02:17 netron/flatbuffers.js
--rw-r--r--  2.0 unx     6287 b- defN 24-May-18 02:17 netron/flax.js
--rw-r--r--  2.0 unx     7479 b- defN 24-May-18 02:17 netron/flexbuffers.js
--rw-r--r--  2.0 unx        3 b- defN 24-May-18 02:17 netron/flux-metadata.json
--rw-r--r--  2.0 unx     2210 b- defN 24-May-18 02:17 netron/flux.js
--rw-r--r--  2.0 unx    14767 b- defN 24-May-18 02:17 netron/gguf.js
--rw-r--r--  2.0 unx     6275 b- defN 24-May-18 02:17 netron/grapher.css
--rw-r--r--  2.0 unx    32108 b- defN 24-May-18 02:17 netron/grapher.js
--rw-r--r--  2.0 unx    29515 b- defN 24-May-18 02:17 netron/hailo-metadata.json
--rw-r--r--  2.0 unx    13692 b- defN 24-May-18 02:17 netron/hailo.js
--rwxr-xr-x  2.0 unx    58492 b- defN 24-May-18 02:17 netron/hdf5.js
--rw-r--r--  2.0 unx     5068 b- defN 24-May-18 02:17 netron/hickle.js
--rw-r--r--  2.0 unx    58106 b- defN 24-May-18 02:17 netron/icon.png
--rw-r--r--  2.0 unx     1308 b- defN 24-May-18 02:17 netron/imgdnn.js
--rw-r--r--  2.0 unx    47289 b- defN 24-May-18 02:19 netron/index.html
--rw-r--r--  2.0 unx     4491 b- defN 24-May-18 02:17 netron/index.js
--rwxr-xr-x  2.0 unx    18560 b- defN 24-May-18 02:17 netron/json.js
--rw-r--r--  2.0 unx   242543 b- defN 24-May-18 02:17 netron/keras-metadata.json
--rw-r--r--  2.0 unx     6112 b- defN 24-May-18 02:17 netron/keras-proto.js
--rw-r--r--  2.0 unx    72448 b- defN 24-May-18 02:17 netron/keras.js
--rw-r--r--  2.0 unx    61683 b- defN 24-May-18 02:17 netron/kmodel.js
--rw-r--r--  2.0 unx      244 b- defN 24-May-18 02:17 netron/lasagne-metadata.json
--rw-r--r--  2.0 unx     6565 b- defN 24-May-18 02:17 netron/lasagne.js
--rw-r--r--  2.0 unx     5305 b- defN 24-May-18 02:17 netron/lightgbm.js
--rw-r--r--  2.0 unx    10332 b- defN 24-May-18 02:17 netron/mediapipe.js
--rw-r--r--  2.0 unx    92025 b- defN 24-May-18 02:17 netron/megengine-metadata.json
--rw-r--r--  2.0 unx    79468 b- defN 24-May-18 02:17 netron/megengine-schema.js
--rw-r--r--  2.0 unx    30357 b- defN 24-May-18 02:17 netron/megengine.js
--rw-r--r--  2.0 unx    42241 b- defN 24-May-18 02:17 netron/mlir.js
--rw-r--r--  2.0 unx     3423 b- defN 24-May-18 02:17 netron/mlnet-metadata.json
--rw-r--r--  2.0 unx    75764 b- defN 24-May-18 02:17 netron/mlnet.js
--rw-r--r--  2.0 unx    10268 b- defN 24-May-18 02:17 netron/mnn-metadata.json
--rw-r--r--  2.0 unx    60632 b- defN 24-May-18 02:17 netron/mnn-schema.js
--rw-r--r--  2.0 unx    15187 b- defN 24-May-18 02:17 netron/mnn.js
--rw-r--r--  2.0 unx     3163 b- defN 24-May-18 02:17 netron/modular.js
--rw-r--r--  2.0 unx    85645 b- defN 24-May-18 02:17 netron/mslite-metadata.json
--rw-r--r--  2.0 unx   164705 b- defN 24-May-18 02:17 netron/mslite-schema.js
--rw-r--r--  2.0 unx    12405 b- defN 24-May-18 02:17 netron/mslite.js
--rw-r--r--  2.0 unx    11884 b- defN 24-May-18 02:17 netron/mxnet-metadata.json
--rw-r--r--  2.0 unx    38395 b- defN 24-May-18 02:17 netron/mxnet.js
--rw-r--r--  2.0 unx    30967 b- defN 24-May-18 02:17 netron/ncnn-metadata.json
--rw-r--r--  2.0 unx    36876 b- defN 24-May-18 02:17 netron/ncnn.js
--rw-r--r--  2.0 unx   296983 b- defN 24-May-18 02:17 netron/nnabla-metadata.json
--rw-r--r--  2.0 unx   427254 b- defN 24-May-18 02:17 netron/nnabla-proto.js
--rw-r--r--  2.0 unx    12563 b- defN 24-May-18 02:17 netron/nnabla.js
--rw-r--r--  2.0 unx      678 b- defN 24-May-18 02:17 netron/nnc.js
--rw-r--r--  2.0 unx     2316 b- defN 24-May-18 02:17 netron/nnef.js
--rw-r--r--  2.0 unx    13434 b- defN 24-May-18 02:17 netron/numpy.js
--rw-r--r--  2.0 unx    53484 b- defN 24-May-18 02:17 netron/om-metadata.json
--rw-r--r--  2.0 unx    35979 b- defN 24-May-18 02:17 netron/om-proto.js
--rw-r--r--  2.0 unx    32645 b- defN 24-May-18 02:17 netron/om.js
--rw-r--r--  2.0 unx     6818 b- defN 24-May-18 02:17 netron/onednn-metadata.json
--rw-r--r--  2.0 unx    11926 b- defN 24-May-18 02:17 netron/onednn.js
--rw-r--r--  2.0 unx  3895258 b- defN 24-May-18 02:17 netron/onnx-metadata.json
--rw-r--r--  2.0 unx    60553 b- defN 24-May-18 02:17 netron/onnx-proto.js
--rw-r--r--  2.0 unx    14697 b- defN 24-May-18 02:17 netron/onnx-schema.js
--rw-r--r--  2.0 unx   107063 b- defN 24-May-18 02:17 netron/onnx.js
--rw-r--r--  2.0 unx     9053 b- defN 24-May-18 02:17 netron/onnx.py
--rw-r--r--  2.0 unx    87071 b- defN 24-May-18 02:17 netron/openvino-metadata.json
--rw-r--r--  2.0 unx    37370 b- defN 24-May-18 02:17 netron/openvino.js
--rw-r--r--  2.0 unx     2894 b- defN 24-May-18 02:17 netron/paddle-metadata.json
--rw-r--r--  2.0 unx    57979 b- defN 24-May-18 02:17 netron/paddle-proto.js
--rw-r--r--  2.0 unx    17792 b- defN 24-May-18 02:17 netron/paddle-schema.js
--rw-r--r--  2.0 unx    37036 b- defN 24-May-18 02:17 netron/paddle.js
--rw-r--r--  2.0 unx     8813 b- defN 24-May-18 02:17 netron/pickle.js
--rw-r--r--  2.0 unx    43012 b- defN 24-May-18 02:17 netron/protobuf.js
--rw-r--r--  2.0 unx   382216 b- defN 24-May-18 02:17 netron/python.js
--rwxr-xr-x  2.0 unx   427041 b- defN 24-May-18 02:17 netron/pytorch-metadata.json
--rw-r--r--  2.0 unx    25351 b- defN 24-May-18 02:17 netron/pytorch-schema.js
--rw-r--r--  2.0 unx   191197 b- defN 24-May-18 02:17 netron/pytorch.js
--rw-r--r--  2.0 unx    24259 b- defN 24-May-18 02:17 netron/pytorch.py
--rw-r--r--  2.0 unx     6464 b- defN 24-May-18 02:17 netron/rknn-metadata.json
--rw-r--r--  2.0 unx     3957 b- defN 24-May-18 02:17 netron/rknn-schema.js
--rw-r--r--  2.0 unx    24930 b- defN 24-May-18 02:17 netron/rknn.js
--rw-r--r--  2.0 unx     7507 b- defN 24-May-18 02:17 netron/safetensors.js
--rw-r--r--  2.0 unx    25450 b- defN 24-May-18 02:17 netron/sentencepiece-proto.js
--rw-r--r--  2.0 unx     3083 b- defN 24-May-18 02:17 netron/sentencepiece.js
--rw-r--r--  2.0 unx     5799 b- defN 24-May-18 02:17 netron/server.js
--rw-r--r--  2.0 unx    11894 b- defN 24-May-18 02:19 netron/server.py
--rw-r--r--  2.0 unx   162764 b- defN 24-May-18 02:17 netron/sklearn-metadata.json
--rw-r--r--  2.0 unx    14143 b- defN 24-May-18 02:17 netron/sklearn.js
--rw-r--r--  2.0 unx     4821 b- defN 24-May-18 02:17 netron/tar.js
--rwxr-xr-x  2.0 unx    27914 b- defN 24-May-18 02:17 netron/tengine-metadata.json
--rwxr-xr-x  2.0 unx    25771 b- defN 24-May-18 02:17 netron/tengine.js
--rw-r--r--  2.0 unx     6125 b- defN 24-May-18 02:17 netron/tensorrt.js
--rw-r--r--  2.0 unx    11033 b- defN 24-May-18 02:17 netron/text.js
--rw-r--r--  2.0 unx  2285490 b- defN 24-May-18 02:17 netron/tf-metadata.json
--rw-r--r--  2.0 unx   354531 b- defN 24-May-18 02:17 netron/tf-proto.js
--rw-r--r--  2.0 unx   104036 b- defN 24-May-18 02:17 netron/tf.js
--rw-r--r--  2.0 unx    37054 b- defN 24-May-18 02:17 netron/tflite-metadata.json
--rw-r--r--  2.0 unx   136338 b- defN 24-May-18 02:17 netron/tflite-schema.js
--rw-r--r--  2.0 unx    24205 b- defN 24-May-18 02:17 netron/tflite.js
--rw-r--r--  2.0 unx    20444 b- defN 24-May-18 02:17 netron/tnn-metadata.json
--rw-r--r--  2.0 unx    24994 b- defN 24-May-18 02:17 netron/tnn.js
--rw-r--r--  2.0 unx    12510 b- defN 24-May-18 02:17 netron/torch-metadata.json
--rw-r--r--  2.0 unx    39029 b- defN 24-May-18 02:17 netron/torch.js
--rw-r--r--  2.0 unx     2333 b- defN 24-May-18 02:17 netron/uff-metadata.json
--rw-r--r--  2.0 unx    29834 b- defN 24-May-18 02:17 netron/uff-proto.js
--rw-r--r--  2.0 unx    11034 b- defN 24-May-18 02:17 netron/uff.js
--rw-r--r--  2.0 unx   261808 b- defN 24-May-18 02:17 netron/view.js
--rw-r--r--  2.0 unx     7839 b- defN 24-May-18 02:17 netron/weka.js
--rw-r--r--  2.0 unx      782 b- defN 24-May-18 02:17 netron/worker.js
--rw-r--r--  2.0 unx    63818 b- defN 24-May-18 02:17 netron/xml.js
--rw-r--r--  2.0 unx    54312 b- defN 24-May-18 02:17 netron/xmodel-proto.js
--rw-r--r--  2.0 unx    13664 b- defN 24-May-18 02:17 netron/xmodel.js
--rw-r--r--  2.0 unx    32712 b- defN 24-May-18 02:17 netron/zip.js
--rw-r--r--  2.0 unx     1447 b- defN 24-May-18 02:20 netron-7.6.8.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-May-18 02:20 netron-7.6.8.dist-info/WHEEL
--rw-r--r--  2.0 unx       39 b- defN 24-May-18 02:20 netron-7.6.8.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        7 b- defN 24-May-18 02:20 netron-7.6.8.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    11737 b- defN 24-May-18 02:20 netron-7.6.8.dist-info/RECORD
-152 files, 14484230 bytes uncompressed, 1681460 bytes compressed:  88.4%
+Zip file size: 1698240 bytes, number of entries: 152
+-rw-r--r--  2.0 unx     1526 b- defN 24-May-25 02:48 netron/__init__.py
+-rw-r--r--  2.0 unx    57928 b- defN 24-May-25 02:48 netron/acuity-metadata.json
+-rw-r--r--  2.0 unx    22154 b- defN 24-May-25 02:48 netron/acuity.js
+-rw-r--r--  2.0 unx    11404 b- defN 24-May-25 02:48 netron/armnn-metadata.json
+-rw-r--r--  2.0 unx    99904 b- defN 24-May-25 02:48 netron/armnn-schema.js
+-rw-r--r--  2.0 unx    12154 b- defN 24-May-25 02:48 netron/armnn.js
+-rwxr-xr-x  2.0 unx    15386 b- defN 24-May-25 02:48 netron/barracuda.js
+-rw-r--r--  2.0 unx    26395 b- defN 24-May-25 02:48 netron/base.js
+-rw-r--r--  2.0 unx     2017 b- defN 24-May-25 02:48 netron/bigdl-metadata.json
+-rw-r--r--  2.0 unx    23686 b- defN 24-May-25 02:48 netron/bigdl-proto.js
+-rw-r--r--  2.0 unx    11237 b- defN 24-May-25 02:48 netron/bigdl.js
+-rw-r--r--  2.0 unx    32794 b- defN 24-May-25 02:48 netron/browser.js
+-rw-r--r--  2.0 unx     9505 b- defN 24-May-25 02:48 netron/caffe-metadata.json
+-rw-r--r--  2.0 unx   182571 b- defN 24-May-25 02:48 netron/caffe-proto.js
+-rw-r--r--  2.0 unx    23542 b- defN 24-May-25 02:48 netron/caffe.js
+-rw-r--r--  2.0 unx   863689 b- defN 24-May-25 02:48 netron/caffe2-metadata.json
+-rw-r--r--  2.0 unx    59284 b- defN 24-May-25 02:48 netron/caffe2-proto.js
+-rw-r--r--  2.0 unx    20687 b- defN 24-May-25 02:48 netron/caffe2.js
+-rw-r--r--  2.0 unx      791 b- defN 24-May-25 02:48 netron/cambricon.js
+-rw-r--r--  2.0 unx      890 b- defN 24-May-25 02:48 netron/catboost.js
+-rw-r--r--  2.0 unx    36814 b- defN 24-May-25 02:48 netron/circle-metadata.json
+-rw-r--r--  2.0 unx   121498 b- defN 24-May-25 02:48 netron/circle-schema.js
+-rw-r--r--  2.0 unx    23082 b- defN 24-May-25 02:48 netron/circle.js
+-rw-r--r--  2.0 unx    14193 b- defN 24-May-25 02:48 netron/cntk-metadata.json
+-rw-r--r--  2.0 unx    11085 b- defN 24-May-25 02:48 netron/cntk-proto.js
+-rw-r--r--  2.0 unx    42418 b- defN 24-May-25 02:48 netron/cntk.js
+-rw-r--r--  2.0 unx    16093 b- defN 24-May-25 02:48 netron/coreml-metadata.json
+-rw-r--r--  2.0 unx   673516 b- defN 24-May-25 02:48 netron/coreml-proto.js
+-rw-r--r--  2.0 unx    68675 b- defN 24-May-25 02:48 netron/coreml.js
+-rw-r--r--  2.0 unx    96272 b- defN 24-May-25 02:48 netron/dagre.js
+-rw-r--r--  2.0 unx    20570 b- defN 24-May-25 02:48 netron/darknet-metadata.json
+-rw-r--r--  2.0 unx    53700 b- defN 24-May-25 02:48 netron/darknet.js
+-rw-r--r--  2.0 unx     1417 b- defN 24-May-25 02:48 netron/dl4j-metadata.json
+-rw-r--r--  2.0 unx    15309 b- defN 24-May-25 02:48 netron/dl4j.js
+-rw-r--r--  2.0 unx     2309 b- defN 24-May-25 02:48 netron/dlc-metadata.json
+-rw-r--r--  2.0 unx     8427 b- defN 24-May-25 02:48 netron/dlc-schema.js
+-rw-r--r--  2.0 unx    25940 b- defN 24-May-25 02:48 netron/dlc.js
+-rw-r--r--  2.0 unx     1777 b- defN 24-May-25 02:48 netron/dnn-metadata.json
+-rw-r--r--  2.0 unx    10997 b- defN 24-May-25 02:48 netron/dnn-proto.js
+-rw-r--r--  2.0 unx     9030 b- defN 24-May-25 02:48 netron/dnn.js
+-rw-r--r--  2.0 unx    34494 b- defN 24-May-25 02:48 netron/favicon.ico
+-rw-r--r--  2.0 unx    16331 b- defN 24-May-25 02:48 netron/flatbuffers.js
+-rw-r--r--  2.0 unx     6164 b- defN 24-May-25 02:48 netron/flax.js
+-rw-r--r--  2.0 unx     7479 b- defN 24-May-25 02:48 netron/flexbuffers.js
+-rw-r--r--  2.0 unx        3 b- defN 24-May-25 02:48 netron/flux-metadata.json
+-rw-r--r--  2.0 unx     2098 b- defN 24-May-25 02:48 netron/flux.js
+-rw-r--r--  2.0 unx    14645 b- defN 24-May-25 02:48 netron/gguf.js
+-rw-r--r--  2.0 unx     6275 b- defN 24-May-25 02:48 netron/grapher.css
+-rw-r--r--  2.0 unx    32108 b- defN 24-May-25 02:48 netron/grapher.js
+-rw-r--r--  2.0 unx    29515 b- defN 24-May-25 02:48 netron/hailo-metadata.json
+-rw-r--r--  2.0 unx    13722 b- defN 24-May-25 02:48 netron/hailo.js
+-rwxr-xr-x  2.0 unx    58492 b- defN 24-May-25 02:48 netron/hdf5.js
+-rw-r--r--  2.0 unx     5068 b- defN 24-May-25 02:48 netron/hickle.js
+-rw-r--r--  2.0 unx    58106 b- defN 24-May-25 02:48 netron/icon.png
+-rw-r--r--  2.0 unx     1028 b- defN 24-May-25 02:48 netron/imgdnn.js
+-rw-r--r--  2.0 unx    47289 b- defN 24-May-25 02:50 netron/index.html
+-rw-r--r--  2.0 unx     4557 b- defN 24-May-25 02:48 netron/index.js
+-rwxr-xr-x  2.0 unx    18560 b- defN 24-May-25 02:48 netron/json.js
+-rw-r--r--  2.0 unx   242543 b- defN 24-May-25 02:48 netron/keras-metadata.json
+-rw-r--r--  2.0 unx     6112 b- defN 24-May-25 02:48 netron/keras-proto.js
+-rw-r--r--  2.0 unx    70960 b- defN 24-May-25 02:48 netron/keras.js
+-rw-r--r--  2.0 unx    61561 b- defN 24-May-25 02:48 netron/kmodel.js
+-rw-r--r--  2.0 unx      244 b- defN 24-May-25 02:48 netron/lasagne-metadata.json
+-rw-r--r--  2.0 unx     6455 b- defN 24-May-25 02:48 netron/lasagne.js
+-rw-r--r--  2.0 unx     5179 b- defN 24-May-25 02:48 netron/lightgbm.js
+-rw-r--r--  2.0 unx    10332 b- defN 24-May-25 02:48 netron/mediapipe.js
+-rw-r--r--  2.0 unx    92025 b- defN 24-May-25 02:48 netron/megengine-metadata.json
+-rw-r--r--  2.0 unx    79468 b- defN 24-May-25 02:48 netron/megengine-schema.js
+-rw-r--r--  2.0 unx    30571 b- defN 24-May-25 02:48 netron/megengine.js
+-rw-r--r--  2.0 unx    42106 b- defN 24-May-25 02:48 netron/mlir.js
+-rw-r--r--  2.0 unx     3423 b- defN 24-May-25 02:48 netron/mlnet-metadata.json
+-rw-r--r--  2.0 unx    75760 b- defN 24-May-25 02:48 netron/mlnet.js
+-rw-r--r--  2.0 unx    10268 b- defN 24-May-25 02:48 netron/mnn-metadata.json
+-rw-r--r--  2.0 unx    60632 b- defN 24-May-25 02:48 netron/mnn-schema.js
+-rw-r--r--  2.0 unx    15255 b- defN 24-May-25 02:48 netron/mnn.js
+-rw-r--r--  2.0 unx     2247 b- defN 24-May-25 02:48 netron/modular.js
+-rw-r--r--  2.0 unx    85645 b- defN 24-May-25 02:48 netron/mslite-metadata.json
+-rw-r--r--  2.0 unx   164705 b- defN 24-May-25 02:48 netron/mslite-schema.js
+-rw-r--r--  2.0 unx    12464 b- defN 24-May-25 02:48 netron/mslite.js
+-rw-r--r--  2.0 unx    11884 b- defN 24-May-25 02:48 netron/mxnet-metadata.json
+-rw-r--r--  2.0 unx    37333 b- defN 24-May-25 02:48 netron/mxnet.js
+-rw-r--r--  2.0 unx    30967 b- defN 24-May-25 02:48 netron/ncnn-metadata.json
+-rw-r--r--  2.0 unx    36876 b- defN 24-May-25 02:48 netron/ncnn.js
+-rw-r--r--  2.0 unx   296983 b- defN 24-May-25 02:48 netron/nnabla-metadata.json
+-rw-r--r--  2.0 unx   427254 b- defN 24-May-25 02:48 netron/nnabla-proto.js
+-rw-r--r--  2.0 unx    12186 b- defN 24-May-25 02:48 netron/nnabla.js
+-rw-r--r--  2.0 unx      678 b- defN 24-May-25 02:48 netron/nnc.js
+-rw-r--r--  2.0 unx     2316 b- defN 24-May-25 02:48 netron/nnef.js
+-rw-r--r--  2.0 unx    13235 b- defN 24-May-25 02:48 netron/numpy.js
+-rw-r--r--  2.0 unx    53484 b- defN 24-May-25 02:48 netron/om-metadata.json
+-rw-r--r--  2.0 unx    35979 b- defN 24-May-25 02:48 netron/om-proto.js
+-rw-r--r--  2.0 unx    32676 b- defN 24-May-25 02:48 netron/om.js
+-rw-r--r--  2.0 unx     6818 b- defN 24-May-25 02:48 netron/onednn-metadata.json
+-rw-r--r--  2.0 unx    10709 b- defN 24-May-25 02:48 netron/onednn.js
+-rw-r--r--  2.0 unx  3895258 b- defN 24-May-25 02:48 netron/onnx-metadata.json
+-rw-r--r--  2.0 unx    60553 b- defN 24-May-25 02:48 netron/onnx-proto.js
+-rw-r--r--  2.0 unx    14697 b- defN 24-May-25 02:48 netron/onnx-schema.js
+-rw-r--r--  2.0 unx   107195 b- defN 24-May-25 02:48 netron/onnx.js
+-rw-r--r--  2.0 unx     9053 b- defN 24-May-25 02:48 netron/onnx.py
+-rw-r--r--  2.0 unx    87071 b- defN 24-May-25 02:48 netron/openvino-metadata.json
+-rw-r--r--  2.0 unx    38357 b- defN 24-May-25 02:48 netron/openvino.js
+-rw-r--r--  2.0 unx     2894 b- defN 24-May-25 02:48 netron/paddle-metadata.json
+-rw-r--r--  2.0 unx    57979 b- defN 24-May-25 02:48 netron/paddle-proto.js
+-rw-r--r--  2.0 unx    17792 b- defN 24-May-25 02:48 netron/paddle-schema.js
+-rw-r--r--  2.0 unx    37036 b- defN 24-May-25 02:48 netron/paddle.js
+-rw-r--r--  2.0 unx     8813 b- defN 24-May-25 02:48 netron/pickle.js
+-rw-r--r--  2.0 unx    43012 b- defN 24-May-25 02:48 netron/protobuf.js
+-rw-r--r--  2.0 unx   385110 b- defN 24-May-25 02:48 netron/python.js
+-rwxr-xr-x  2.0 unx   427262 b- defN 24-May-25 02:48 netron/pytorch-metadata.json
+-rw-r--r--  2.0 unx    25351 b- defN 24-May-25 02:48 netron/pytorch-schema.js
+-rw-r--r--  2.0 unx   191193 b- defN 24-May-25 02:48 netron/pytorch.js
+-rw-r--r--  2.0 unx    24259 b- defN 24-May-25 02:48 netron/pytorch.py
+-rw-r--r--  2.0 unx     6464 b- defN 24-May-25 02:48 netron/rknn-metadata.json
+-rw-r--r--  2.0 unx     3957 b- defN 24-May-25 02:48 netron/rknn-schema.js
+-rw-r--r--  2.0 unx    23478 b- defN 24-May-25 02:48 netron/rknn.js
+-rw-r--r--  2.0 unx     7477 b- defN 24-May-25 02:48 netron/safetensors.js
+-rw-r--r--  2.0 unx    25450 b- defN 24-May-25 02:48 netron/sentencepiece-proto.js
+-rw-r--r--  2.0 unx     3083 b- defN 24-May-25 02:48 netron/sentencepiece.js
+-rw-r--r--  2.0 unx     4270 b- defN 24-May-25 02:48 netron/server.js
+-rw-r--r--  2.0 unx    11894 b- defN 24-May-25 02:50 netron/server.py
+-rw-r--r--  2.0 unx   162764 b- defN 24-May-25 02:48 netron/sklearn-metadata.json
+-rw-r--r--  2.0 unx    13899 b- defN 24-May-25 02:48 netron/sklearn.js
+-rw-r--r--  2.0 unx     4821 b- defN 24-May-25 02:48 netron/tar.js
+-rwxr-xr-x  2.0 unx    27914 b- defN 24-May-25 02:48 netron/tengine-metadata.json
+-rwxr-xr-x  2.0 unx    25435 b- defN 24-May-25 02:48 netron/tengine.js
+-rw-r--r--  2.0 unx     5842 b- defN 24-May-25 02:48 netron/tensorrt.js
+-rw-r--r--  2.0 unx    11033 b- defN 24-May-25 02:48 netron/text.js
+-rw-r--r--  2.0 unx  2285490 b- defN 24-May-25 02:48 netron/tf-metadata.json
+-rw-r--r--  2.0 unx   354531 b- defN 24-May-25 02:48 netron/tf-proto.js
+-rw-r--r--  2.0 unx   104922 b- defN 24-May-25 02:48 netron/tf.js
+-rw-r--r--  2.0 unx    37054 b- defN 24-May-25 02:48 netron/tflite-metadata.json
+-rw-r--r--  2.0 unx   136338 b- defN 24-May-25 02:48 netron/tflite-schema.js
+-rw-r--r--  2.0 unx    23539 b- defN 24-May-25 02:48 netron/tflite.js
+-rw-r--r--  2.0 unx    20444 b- defN 24-May-25 02:48 netron/tnn-metadata.json
+-rw-r--r--  2.0 unx    24817 b- defN 24-May-25 02:48 netron/tnn.js
+-rw-r--r--  2.0 unx    12510 b- defN 24-May-25 02:48 netron/torch-metadata.json
+-rw-r--r--  2.0 unx    38994 b- defN 24-May-25 02:48 netron/torch.js
+-rw-r--r--  2.0 unx     2333 b- defN 24-May-25 02:48 netron/uff-metadata.json
+-rw-r--r--  2.0 unx    29834 b- defN 24-May-25 02:48 netron/uff-proto.js
+-rw-r--r--  2.0 unx    11034 b- defN 24-May-25 02:48 netron/uff.js
+-rw-r--r--  2.0 unx   261842 b- defN 24-May-25 02:48 netron/view.js
+-rw-r--r--  2.0 unx     7839 b- defN 24-May-25 02:48 netron/weka.js
+-rw-r--r--  2.0 unx      782 b- defN 24-May-25 02:48 netron/worker.js
+-rw-r--r--  2.0 unx    63818 b- defN 24-May-25 02:48 netron/xml.js
+-rw-r--r--  2.0 unx    54312 b- defN 24-May-25 02:48 netron/xmodel-proto.js
+-rw-r--r--  2.0 unx    13420 b- defN 24-May-25 02:48 netron/xmodel.js
+-rw-r--r--  2.0 unx    32712 b- defN 24-May-25 02:48 netron/zip.js
+-rw-r--r--  2.0 unx     1447 b- defN 24-May-25 02:50 netron-7.6.9.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-25 02:50 netron-7.6.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx       39 b- defN 24-May-25 02:50 netron-7.6.9.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        7 b- defN 24-May-25 02:50 netron-7.6.9.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    11737 b- defN 24-May-25 02:50 netron-7.6.9.dist-info/RECORD
+152 files, 14474486 bytes uncompressed, 1680638 bytes compressed:  88.4%
```

## zipnote {}

```diff
@@ -435,23 +435,23 @@
 
 Filename: netron/xmodel.js
 Comment: 
 
 Filename: netron/zip.js
 Comment: 
 
-Filename: netron-7.6.8.dist-info/METADATA
+Filename: netron-7.6.9.dist-info/METADATA
 Comment: 
 
-Filename: netron-7.6.8.dist-info/WHEEL
+Filename: netron-7.6.9.dist-info/WHEEL
 Comment: 
 
-Filename: netron-7.6.8.dist-info/entry_points.txt
+Filename: netron-7.6.9.dist-info/entry_points.txt
 Comment: 
 
-Filename: netron-7.6.8.dist-info/top_level.txt
+Filename: netron-7.6.9.dist-info/top_level.txt
 Comment: 
 
-Filename: netron-7.6.8.dist-info/RECORD
+Filename: netron-7.6.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## netron/armnn.js

### js-beautify {}

```diff
@@ -161,38 +161,44 @@
             name: 'output'
         }];
         const base = armnn.Node.getBase(layer);
         if (base) {
             this.name = base.layerName;
             const inputs = [...base.inputSlots];
             while (inputs.length > 0) {
-                const inputSchema = inputSchemas.length > 0 ? inputSchemas.shift() : {
+                const schema = inputSchemas.length > 0 ? inputSchemas.shift() : {
                     name: '?'
                 };
-                const count = inputSchema.list ? inputs.length : 1;
-                const argument = new armnn.Argument(inputSchema.name, inputs.splice(0, count).map((inputSlot) => {
+                const count = schema.list ? inputs.length : 1;
+                const argument = new armnn.Argument(schema.name, inputs.splice(0, count).map((inputSlot) => {
                     return value(inputSlot.connection.sourceLayerIndex, inputSlot.connection.outputSlotIndex);
                 }));
                 this.inputs.push(argument);
             }
             const outputs = [...base.outputSlots];
             while (outputs.length > 0) {
-                const outputSchema = outputSchemas.length > 0 ? outputSchemas.shift() : {
+                const schema = outputSchemas.length > 0 ? outputSchemas.shift() : {
                     name: '?'
                 };
-                const count = outputSchema.list ? outputs.length : 1;
-                this.outputs.push(new armnn.Argument(outputSchema.name, outputs.splice(0, count).map((outputSlot) => {
+                const count = schema.list ? outputs.length : 1;
+                this.outputs.push(new armnn.Argument(schema.name, outputs.splice(0, count).map((outputSlot) => {
                     return value(base.index, outputSlot.index);
                 })));
             }
         }
         if (layer.layer) {
             if (layer.layer.descriptor && this.type.attributes) {
-                for (const [name, value] of Object.entries(layer.layer.descriptor)) {
-                    const attribute = new armnn.Attribute(metadata.attribute(type, name), name, value);
+                for (const [key, obj] of Object.entries(layer.layer.descriptor)) {
+                    const schema = metadata.attribute(name, key);
+                    const type = schema ? schema.type : null;
+                    let value = ArrayBuffer.isView(obj) ? Array.from(obj) : obj;
+                    if (armnn.schema[type]) {
+                        value = armnn.Utility.enum(type, value);
+                    }
+                    const attribute = new armnn.Argument(key, value, type);
                     this.attributes.push(attribute);
                 }
             }
             for (const [name, tensor] of Object.entries(layer.layer).filter(([, value]) => value instanceof armnn.schema.ConstTensor)) {
                 const value = new armnn.Value('', tensor.info, new armnn.Tensor(tensor));
                 const argument = new armnn.Argument(name, [value]);
                 this.inputs.push(argument);
@@ -205,31 +211,20 @@
     }
 
     static makeKey(layer_id, index) {
         return `${layer_id}_${index}`;
     }
 };
 
-armnn.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this.name = name;
-        this.type = metadata ? metadata.type : null;
-        this.value = ArrayBuffer.isView(value) ? Array.from(value) : value;
-        if (armnn.schema[this.type]) {
-            this.value = armnn.Utility.enum(this.type, this.value);
-        }
-    }
-};
-
 armnn.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
     }
 };
 
 armnn.Value = class {
 
     constructor(name, tensorInfo, initializer) {
         if (typeof name !== 'string') {
```

## netron/barracuda.js

### js-beautify {}

```diff
@@ -73,17 +73,18 @@
             this.nodes.push(node);
         }
     }
 };
 
 barracuda.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
     }
 };
 
 barracuda.Value = class {
 
     constructor(name, type, initializer) {
         this.name = name;
@@ -132,45 +133,33 @@
             }
             const node = new barracuda.Node(metadata, {}, {
                 name: type,
                 category: 'Activation'
             }, values);
             this.chain = [node];
         }
-        const attribute = (name, type, value, defaultValue) => {
-            if (value === undefined) {
-                return;
-            }
-            if (Array.isArray(defaultValue) && Array.isArray(value) && value.length === defaultValue.length && value.every((v, i) => v === defaultValue[i])) {
-                return;
-            }
-            if (typeof defaultValue === 'function' && defaultValue(value)) {
-                return;
+        const attributes = [
+            ['strides', 'int32[]', []],
+            ['pads', 'int32[]', (value) => Array.isArray(value) && (value.every((v) => v === 0) || value.every((v) => v === -1))],
+            ['pool_size', 'int32[]', []],
+            ['alpha', 'float32', 1],
+            ['beta', 'float32', 0],
+            ['axis', 'int32', -1]
+        ];
+        for (const [name, type, defaultValue] of attributes) {
+            const value = layer[name];
+            if ((value === undefined) ||
+                (Array.isArray(defaultValue) && Array.isArray(value) && value.length === defaultValue.length && value.every((v, i) => v === defaultValue[i])) ||
+                (typeof defaultValue === 'function' && defaultValue(value)) ||
+                (defaultValue === value)) {
+                continue;
             }
-            if (defaultValue === value) {
-                return;
-            }
-            const attribute = new barracuda.Attribute(name, type, value);
+            const attribute = new barracuda.Argument(name, value, type);
             this.attributes.push(attribute);
-        };
-        attribute('strides', 'int32[]', layer.strides, []);
-        attribute('pads', 'int32[]', layer.pads, (value) => Array.isArray(value) && (value.every((v) => v === 0) || value.every((v) => v === -1)));
-        attribute('size', 'int32[]', layer.pool_size, []);
-        attribute('alpha', 'float32', layer.alpha, 1);
-        attribute('beta', 'float32', layer.beta, 0);
-        attribute('axis', 'int32', layer.axis, -1);
-    }
-};
-
-barracuda.Attribute = class {
-
-    constructor(name, type, value) {
-        this.name = name;
-        this.type = type;
-        this.value = value;
+        }
     }
 };
 
 barracuda.Tensor = class {
 
     constructor(tensor) {
         this.type = new barracuda.TensorType(tensor.itemsize, new barracuda.TensorShape(tensor.shape));
```

## netron/bigdl.js

### js-beautify {}

```diff
@@ -76,17 +76,18 @@
         };
         loadModule(metadata, module, tensors);
     }
 };
 
 bigdl.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
     }
 };
 
 bigdl.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
@@ -129,120 +130,116 @@
                 const input = inputs.shift();
                 const inputName = input ? input.name : this.inputs.length.toString();
                 this.inputs.push(new bigdl.Argument(inputName, [
                     new bigdl.Value('', null, new bigdl.Tensor(parameter, tensors))
                 ]));
             }
         }
-        for (const [key, value] of Object.entries(module.attr)) {
+        for (const [key, obj] of Object.entries(module.attr)) {
             if (key === 'module_numerics' || key === 'module_tags') {
                 continue;
             }
-            if (value.dataType === bigdl.proto.DataType.TENSOR) {
-                if (value.value) {
-                    this.inputs.push(new bigdl.Argument(key, [new bigdl.Value('', null, new bigdl.Tensor(value.tensorValue, tensors))]));
+            if (obj.dataType === bigdl.proto.DataType.TENSOR) {
+                if (obj.value) {
+                    this.inputs.push(new bigdl.Argument(key, [new bigdl.Value('', null, new bigdl.Tensor(obj.tensorValue, tensors))]));
                 }
                 continue;
             }
-            if (value.dataType === bigdl.proto.DataType.REGULARIZER && value.value === undefined) {
+            if (obj.dataType === bigdl.proto.DataType.REGULARIZER && obj.value === undefined) {
                 continue;
             }
-            if (value.dataType === bigdl.proto.DataType.ARRAY_VALUE && value.arrayValue.datatype === bigdl.proto.DataType.TENSOR) {
-                this.inputs.push(new bigdl.Argument(key, value.arrayValue.tensor.map((tensor) => new bigdl.Value('', null, new bigdl.Tensor(tensor, tensors)))));
+            if (obj.dataType === bigdl.proto.DataType.ARRAY_VALUE && obj.arrayValue.datatype === bigdl.proto.DataType.TENSOR) {
+                this.inputs.push(new bigdl.Argument(key, obj.arrayValue.tensor.map((tensor) => new bigdl.Value('', null, new bigdl.Tensor(tensor, tensors)))));
                 continue;
             }
-            this.attributes.push(new bigdl.Attribute(key, value));
-        }
-        const output = this.name || this.type + module.namePostfix;
-        this.outputs.push(new bigdl.Argument('output', [values.map(output)]));
-    }
-};
-
-bigdl.Attribute = class {
-
-    constructor(name, value) {
-        this.name = name;
-        switch (value.dataType) {
-            case bigdl.proto.DataType.INT32: {
-                this.type = 'int32';
-                this.value = value.int32Value;
-                break;
-            }
-            case bigdl.proto.DataType.FLOAT: {
-                this.type = 'float32';
-                this.value = value.floatValue;
-                break;
-            }
-            case bigdl.proto.DataType.DOUBLE: {
-                this.type = 'float64';
-                this.value = value.doubleValue;
-                break;
-            }
-            case bigdl.proto.DataType.BOOL: {
-                this.type = 'boolean';
-                this.value = value.boolValue;
-                break;
-            }
-            case bigdl.proto.DataType.REGULARIZER: {
-                this.value = value.value;
-                break;
-            }
-            case bigdl.proto.DataType.MODULE: {
-                this.value = value.bigDLModule;
-                break;
-            }
-            case bigdl.proto.DataType.NAME_ATTR_LIST: {
-                this.value = value.nameAttrListValue;
-                break;
-            }
-            case bigdl.proto.DataType.ARRAY_VALUE: {
-                switch (value.arrayValue.datatype) {
-                    case bigdl.proto.DataType.INT32: {
-                        this.type = 'int32[]';
-                        this.value = value.arrayValue.i32;
-                        break;
-                    }
-                    case bigdl.proto.DataType.FLOAT: {
-                        this.type = 'float32[]';
-                        this.value = value.arrayValue.flt;
-                        break;
-                    }
-                    case bigdl.proto.DataType.STRING: {
-                        this.type = 'string[]';
-                        this.value = value.arrayValue.str;
-                        break;
-                    }
-                    case bigdl.proto.DataType.TENSOR: {
-                        this.type = 'tensor[]';
-                        this.value = value.arrayValue.tensor;
-                        break;
+            let type = null;
+            let value = null;
+            switch (obj.dataType) {
+                case bigdl.proto.DataType.INT32: {
+                    type = 'int32';
+                    value = obj.int32Value;
+                    break;
+                }
+                case bigdl.proto.DataType.FLOAT: {
+                    type = 'float32';
+                    value = obj.floatValue;
+                    break;
+                }
+                case bigdl.proto.DataType.DOUBLE: {
+                    type = 'float64';
+                    value = obj.doubleValue;
+                    break;
+                }
+                case bigdl.proto.DataType.BOOL: {
+                    type = 'boolean';
+                    value = obj.boolValue;
+                    break;
+                }
+                case bigdl.proto.DataType.REGULARIZER: {
+                    value = obj.value;
+                    break;
+                }
+                case bigdl.proto.DataType.MODULE: {
+                    value = obj.bigDLModule;
+                    break;
+                }
+                case bigdl.proto.DataType.NAME_ATTR_LIST: {
+                    value = value.nameAttrListValue;
+                    break;
+                }
+                case bigdl.proto.DataType.ARRAY_VALUE: {
+                    switch (obj.arrayValue.datatype) {
+                        case bigdl.proto.DataType.INT32: {
+                            type = 'int32[]';
+                            value = obj.arrayValue.i32;
+                            break;
+                        }
+                        case bigdl.proto.DataType.FLOAT: {
+                            type = 'float32[]';
+                            value = obj.arrayValue.flt;
+                            break;
+                        }
+                        case bigdl.proto.DataType.STRING: {
+                            type = 'string[]';
+                            value = obj.arrayValue.str;
+                            break;
+                        }
+                        case bigdl.proto.DataType.TENSOR: {
+                            type = 'tensor[]';
+                            value = obj.arrayValue.tensor;
+                            break;
+                        }
+                        default: {
+                            throw new bigdl.Error(`Unsupported attribute array data type '${obj.arrayValue.datatype}'.`);
+                        }
                     }
-                    default: {
-                        throw new bigdl.Error(`Unsupported attribute array data type '${value.arrayValue.datatype}'.`);
+                    break;
+                }
+                case bigdl.proto.DataType.DATA_FORMAT: {
+                    switch (obj.dataFormatValue) {
+                        case 0:
+                            value = 'NCHW';
+                            break;
+                        case 1:
+                            value = 'NHWC';
+                            break;
+                        default:
+                            throw new bigdl.Error(`Unsupported data format '${obj.dataFormatValue}'.`);
                     }
+                    break;
                 }
-                break;
-            }
-            case bigdl.proto.DataType.DATA_FORMAT: {
-                switch (value.dataFormatValue) {
-                    case 0:
-                        this.value = 'NCHW';
-                        break;
-                    case 1:
-                        this.value = 'NHWC';
-                        break;
-                    default:
-                        throw new bigdl.Error(`Unsupported data format '${value.dataFormatValue}'.`);
+                default: {
+                    throw new bigdl.Error(`Unsupported attribute data type '${obj.dataType}'.`);
                 }
-                break;
-            }
-            default: {
-                throw new bigdl.Error(`Unsupported attribute data type '${value.dataType}'.`);
             }
+            const argument = new bigdl.Argument(key, value, type);
+            this.attributes.push(argument);
         }
+        const output = this.name || this.type + module.namePostfix;
+        this.outputs.push(new bigdl.Argument('output', [values.map(output)]));
     }
 };
 
 bigdl.Tensor = class {
 
     constructor(tensor /*, tensors */ ) {
         this.type = new bigdl.TensorType(tensor.datatype, new bigdl.TensorShape(tensor.size));
```

## netron/caffe.js

### js-beautify {}

```diff
@@ -145,77 +145,68 @@
         return message;
     }
 };
 
 caffe.Model = class {
 
     constructor(metadata, net) {
-
-        this._name = net.name;
-
+        this.name = net.name;
+        let version = -1;
+        this.format = 'Caffe';
         if (net.layers && net.layers.length > 0) {
             if (net.layers.every((layer) => Object.prototype.hasOwnProperty.call(layer, 'layer'))) {
-                this._version = 0;
+                version = 0;
                 net.layer = net.layers;
             } else {
-                this._version = 1;
+                version = 1;
                 net.layer = net.layers;
             }
         } else if (net.layer && net.layer.length > 0) {
-            this._version = 2;
+            version = 2;
         }
-
+        this.format = `Caffe v${version}`;
         const phases = new Set();
         for (const layer of net.layer) {
             for (const include of layer.include) {
                 if (include.phase !== undefined) {
                     phases.add(include.phase);
                 }
             }
         }
         if (phases.size === 0) {
             phases.add(-1);
         }
-
-        this._graphs = [];
+        this.graphs = [];
         for (const phase of phases) {
-            const graph = new caffe.Graph(metadata, phase, net, this._version);
-            this._graphs.push(graph);
+            const graph = new caffe.Graph(metadata, phase, net, version);
+            this.graphs.push(graph);
         }
     }
-
-    get format() {
-        return `Caffe${this._version ? ` v${this._version}` : ''}`;
-    }
-
-    get graphs() {
-        return this._graphs;
-    }
 };
 
 caffe.Graph = class {
 
     constructor(metadata, phase, net, version) {
         switch (phase) {
             case 0:
-                this._phase = 'TRAIN';
+                this.name = 'TRAIN';
                 break;
             case 1:
-                this._phase = 'TEST';
+                this.name = 'TEST';
                 break;
             case -1:
-                this._phase = '';
+                this.name = '';
                 break;
             default:
-                this._phase = phase.toString();
+                this.name = phase.toString();
                 break;
         }
-        this._nodes = [];
-        this._inputs = [];
-        this._outputs = [];
+        this.nodes = [];
+        this.inputs = [];
+        this.outputs = [];
         for (const layer of net.layer) {
             layer.input = layer.bottom.slice(0);
             layer.output = layer.top.slice(0);
             layer.chain = [];
         }
         const layers = [];
         for (const layer of net.layer) {
@@ -272,15 +263,15 @@
             } else {
                 if (layer.type === 'Input' || layer.type === 'Data') {
                     if (layer.input.length === 0 && layer.output.length === 1 &&
                         layer.input_param && layer.input_param.shape &&
                         layer.input_param.shape.length === 1 && layer.input_param.shape[0].dim) {
                         const shape = new caffe.TensorShape(layer.input_param.shape[0].dim.map((dim) => dim.toNumber()));
                         const type = new caffe.TensorType(null, shape);
-                        this._inputs.push(new caffe.Argument(layer.output[0], [value(layer.output[0], type)]));
+                        this.inputs.push(new caffe.Argument(layer.output[0], [value(layer.output[0], type)]));
                         layer = null;
                     }
                 }
                 if (layer) {
                     nodes.push(layer);
                     lastLayer = null;
                     lastTop = null;
@@ -290,15 +281,15 @@
                     }
                 }
             }
         }
         if (net.input) {
             for (let i = 0; i < net.input.length; i++) {
                 const input = net.input[i];
-                if (this._inputs.some((item) => item.name === input)) {
+                if (this.inputs.some((item) => item.name === input)) {
                     continue;
                 }
                 let inputType = null;
                 if (net.input_shape && i < net.input_shape.length) {
                     const blobShape = net.input_shape[i];
                     if (blobShape && blobShape.dim) {
                         const shape = new caffe.TensorShape(blobShape.dim.map((dim) => dim.toNumber()));
@@ -306,132 +297,94 @@
                     }
                 }
                 const dim = i * 4;
                 if (!inputType && net.input_dim && net.input_dim.length >= dim) {
                     const shape = new caffe.TensorShape(net.input_dim.slice(dim, dim + 4));
                     inputType = new caffe.TensorType(null, shape);
                 }
-                this._inputs.push(new caffe.Argument(input, [value(input, inputType, null)]));
+                this.inputs.push(new caffe.Argument(input, [value(input, inputType, null)]));
             }
         }
 
         for (const layer of nodes) {
             const node = new caffe.Node(metadata, layer, version, value);
             if (layer.chain && layer.chain.length > 0) {
                 for (const chain of layer.chain) {
                     node.chain.push(new caffe.Node(metadata, chain, version, value));
                 }
             }
-            this._nodes.push(node);
+            this.nodes.push(node);
         }
 
-        if (this._inputs.length === 0 && unusedInputs.length === 1) {
-            this._inputs.push(new caffe.Argument(unusedInputs[0], [value(unusedInputs[0], null)]));
+        if (this.inputs.length === 0 && unusedInputs.length === 1) {
+            this.inputs.push(new caffe.Argument(unusedInputs[0], [value(unusedInputs[0], null)]));
         }
     }
-
-    get name() {
-        return this._phase;
-    }
-
-    get type() {
-        return '';
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
 };
 
 caffe.Argument = class {
 
-    constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+    constructor(name, value, type, visible) {
+        this.name = name;
+        this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 caffe.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
             throw new caffe.Error(`Invalid value identifier '${JSON.stringify(name)}'.`);
         }
-        this._name = name;
-        this._type = type || null;
-        this._initializer = initializer || null;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get initializer() {
-        return this._initializer;
+        this.name = name;
+        this.type = type || null;
+        this.initializer = initializer || null;
     }
 };
 
 caffe.Node = class {
 
     constructor(metadata, layer, version, value) {
-        this._chain = [];
-        this._attributes = [];
+        this.attributes = [];
+        this.chain = [];
         let type = '';
         switch (version) {
             case 0: {
-                this._name = layer.layer.name;
+                this.name = layer.layer.name;
                 type = layer.layer.type;
                 break;
             }
             case 1: {
-                this._name = layer.name;
+                this.name = layer.name;
                 type = caffe.Utility.layerType(layer.type);
                 break;
             }
             case 2: {
-                this._name = layer.name;
+                this.name = layer.name;
                 type = layer.type;
                 break;
             }
             default: {
                 throw new new caffe.Error(`Unsupported Caffe version '${version}'.`);
             }
         }
-        this._type = metadata.type(type) || {
+        this.type = metadata.type(type) || {
             name: type
         };
-
         let initializers = [];
+        const attributes = [];
         switch (version) {
             case 0: {
                 for (const name of Object.keys(layer.layer)) {
                     if (name !== 'type' && name !== 'name' && name !== 'blobs' && name !== 'blobs_lr') {
                         const value = layer.layer[name];
-                        const attribute = new caffe.Attribute(metadata.attribute(type, name), name, value);
-                        this._attributes.push(attribute);
+                        const schema = metadata.attribute(type, name);
+                        attributes.push([schema, name, value]);
                     }
                 }
                 initializers = layer.layer.blobs.map((blob) => new caffe.Tensor(blob));
                 break;
             }
             case 1:
             case 2: {
@@ -441,153 +394,104 @@
                         if (type === 'Deconvolution') {
                             type = 'Convolution';
                         }
                         const prototype = Object.getPrototypeOf(param);
                         for (const name of Object.keys(param)) {
                             const defaultValue = prototype[name];
                             const value = param[name];
-                            const attribute = new caffe.Attribute(metadata.attribute(type, name), name, value, defaultValue);
-                            this._attributes.push(attribute);
+                            const schema = metadata.attribute(type, name);
+                            attributes.push([schema, name, value, defaultValue]);
                         }
                     }
                 }
                 if (layer.include && layer.include.length > 0) {
-                    const attribute = new caffe.Attribute(metadata.attribute(type, 'include'), 'include', layer.include);
-                    this._attributes.push(attribute);
+                    const schema = metadata.attribute(type, 'include');
+                    attributes.push([schema, 'include', layer.include]);
                 }
                 if (layer.exclude && layer.exclude.length > 0) {
-                    const attribute = new caffe.Attribute(metadata.attribute(type, 'exclude'), 'exclude', layer.exclude);
-                    this._attributes.push(attribute);
+                    const schema = metadata.attribute(type, 'exclude');
+                    attributes.push([schema, 'exclude', layer.exclude]);
                 }
-                if (this._type === 'Data' && layer.input_param && layer.input_param.shape) {
-                    const attribute = new caffe.Attribute(metadata.attribute(type, 'shape'), 'shape', layer.input_param.shape);
-                    this._attributes.push(attribute);
+                if (this.type === 'Data' && layer.input_param && layer.input_param.shape) {
+                    const schema = metadata.attribute(type, 'shape');
+                    attributes.push([schema, 'shape', layer.input_param.shape]);
                 }
                 initializers = layer.blobs.map((blob) => new caffe.Tensor(blob));
                 break;
             }
             default: {
                 throw new caffe.Error(`Unsupported Caffe version '${version}'.`);
             }
         }
-        this._inputs = [];
+        this.inputs = [];
         const inputs = layer.input.concat(initializers);
         let inputIndex = 0;
-        if (this._type && this._type.inputs) {
-            for (const inputDef of this._type.inputs) {
+        if (this.type && this.type.inputs) {
+            for (const inputDef of this.type.inputs) {
                 if (inputIndex < inputs.length || inputDef.option !== 'optional') {
                     const count = inputDef.option === 'variadic' ? inputs.length - inputIndex : 1;
                     const values = inputs.slice(inputIndex, inputIndex + count).filter((input) => input !== '' || inputDef.option !== 'optional').map((input) => {
                         return input instanceof caffe.Tensor ? new caffe.Value('', input.type, input) : value(input, null, null);
                     });
                     const argument = new caffe.Argument(inputDef.name, values);
-                    this._inputs.push(argument);
+                    this.inputs.push(argument);
                     inputIndex += count;
                 }
             }
         }
-        this._inputs.push(...inputs.slice(inputIndex).map((input) => {
+        this.inputs.push(...inputs.slice(inputIndex).map((input) => {
             return new caffe.Argument(inputIndex.toString(), [
                 input instanceof caffe.Tensor ? new caffe.Value('', input.type, input) : value(input, null, null)
             ]);
         }));
 
-        this._outputs = [];
+        this.outputs = [];
         const outputs = layer.output;
         let outputIndex = 0;
-        if (this._type && this._type.outputs) {
-            for (const outputDef of this._type.outputs) {
+        if (this.type && this.type.outputs) {
+            for (const outputDef of this.type.outputs) {
                 if (outputIndex < outputs.length) {
                     const count = (outputDef.option === 'variadic') ? (outputs.length - outputIndex) : 1;
                     const values = outputs.slice(outputIndex, outputIndex + count).map((output) => value(output, null, null));
                     const argument = new caffe.Argument(outputDef.name, values);
-                    this._outputs.push(argument);
+                    this.outputs.push(argument);
                     outputIndex += count;
                 }
             }
         }
-        this._outputs.push(...outputs.slice(outputIndex).map((output, index) => {
+        this.outputs.push(...outputs.slice(outputIndex).map((output, index) => {
             return new caffe.Argument((outputIndex + index).toString(), [value(output, null, null)]);
         }));
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-
-    get chain() {
-        return this._chain;
-    }
-};
-
-caffe.Attribute = class {
-
-    constructor(metadata, name, value, defaultValue) {
-        this._name = name;
-        this._value = value;
-        if (metadata && metadata.type) {
-            this._type = metadata.type;
-        }
-        if (value instanceof caffe.proto.BlobShape) {
-            this._value = new caffe.TensorShape(value.dim.map((dim) => Number(dim)));
-            this._type = 'shape';
-        }
-        if (metadata && metadata.visible === false) {
-            this._visible = false;
-        }
-        if (metadata && Object.prototype.hasOwnProperty.call(metadata, 'default')) {
-            defaultValue = metadata.default;
-        }
-        if (defaultValue !== undefined) {
-            if (this._value === defaultValue) {
-                this._visible = false;
-            } else if (Array.isArray(this._value) && Array.isArray(defaultValue)) {
-                if (this._value.length === defaultValue.length &&
-                    this._value.every((item, index) => {
-                        return item === defaultValue[index];
-                    })) {
-                    this._visible = false;
+        this.attributes = attributes.map(([metadata, name, value, defaultValue]) => {
+            let visible = true;
+            if (metadata && metadata.type) {
+                type = metadata.type;
+            }
+            if (value instanceof caffe.proto.BlobShape) {
+                value = new caffe.TensorShape(value.dim.map((dim) => Number(dim)));
+                type = 'shape';
+            }
+            if (metadata && metadata.visible === false) {
+                visible = false;
+            }
+            if (metadata && metadata.default !== undefined) {
+                defaultValue = metadata.default;
+            }
+            if (defaultValue !== undefined) {
+                if (value === defaultValue) {
+                    visible = false;
+                } else if (Array.isArray(value) && Array.isArray(defaultValue)) {
+                    if (value.length === defaultValue.length && value.every((item, index) => item === defaultValue[index])) {
+                        visible = false;
+                    }
                 }
             }
-        }
-        if (this._type) {
-            this._value = caffe.Utility.enum(this._type, this._value);
-        }
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
-    }
-
-    get visible() {
-        return this._visible !== false;
+            value = type ? caffe.Utility.enum(type, value) : value;
+            return new caffe.Argument(name, value, type, visible);
+        });
     }
 };
 
 caffe.Tensor = class {
 
     constructor(blob) {
         let shape = [];
@@ -606,76 +510,48 @@
             }
             if (blob.width !== 1) {
                 shape.push(blob.width);
             }
         } else if (Object.prototype.hasOwnProperty.call(blob, 'shape')) {
             shape = blob.shape.dim.map((dim) => Number(dim));
         }
-
         let dataType = '?';
         if (blob.data.length > 0) {
             dataType = 'float32';
-            this._values = blob.data;
+            this.values = blob.data;
         } else if (blob.double_data.length > 0) {
             dataType = 'float64';
-            this._values = blob.double_data;
+            this.values = blob.double_data;
         }
-
-        this._type = new caffe.TensorType(dataType, new caffe.TensorShape(shape));
-    }
-
-    get category() {
-        return 'Blob';
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get encoding() {
-        return '|';
-    }
-
-    get values() {
-        return this._values;
+        this.category = 'Blob';
+        this.encoding = '|';
+        this.type = new caffe.TensorType(dataType, new caffe.TensorShape(shape));
     }
 };
 
 caffe.TensorType = class {
 
     constructor(dataType, shape) {
-        this._dataType = dataType;
-        this._shape = shape;
-    }
-
-    get dataType() {
-        return this._dataType;
-    }
-
-    get shape() {
-        return this._shape;
+        this.dataType = dataType;
+        this.shape = shape;
     }
 
     toString() {
-        return (this.dataType || '?') + this._shape.toString();
+        return (this.dataType || '?') + this.shape.toString();
     }
 };
 
 caffe.TensorShape = class {
 
     constructor(dimensions) {
-        this._dimensions = dimensions;
-    }
-
-    get dimensions() {
-        return this._dimensions;
+        this.dimensions = dimensions;
     }
 
     toString() {
-        return this._dimensions ? (`[${this._dimensions.map((dimension) => dimension.toString()).join(',')}]`) : '';
+        return this.dimensions ? (`[${this.dimensions.map((dimension) => dimension.toString()).join(',')}]`) : '';
     }
 };
 
 caffe.Utility = class {
 
     static layerType(type) {
         type = type || 0;
```

## netron/caffe2.js

### js-beautify {}

```diff
@@ -335,17 +335,19 @@
             this.outputs.push(argument);
         }
     }
 };
 
 caffe2.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 caffe2.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
@@ -362,15 +364,48 @@
 
     constructor(metadata, op, values) {
         this.name = op.name || '';
         this.device = op.engine || '';
         this.metadata = metadata;
         this.chain = [];
         this.type = metadata.type(op.type);
-        this.attributes = op.arg.map((arg) => new caffe2.Attribute(metadata, this.type.name, arg));
+        this.attributes = op.arg.map((arg) => {
+            const schema = metadata.attribute(op.type, arg.name);
+            const name = arg.name;
+            let value = null;
+            let type = null;
+            let visible = true;
+            if (arg.floats && arg.floats.length > 0) {
+                value = arg.floats;
+            } else if (arg.ints && arg.ints.length > 0) {
+                value = arg.ints;
+            } else if (arg.nets && arg.nets.length > 0) {
+                value = arg.nets.map((net) => new caffe2.Graph(metadata, net, null));
+                type = 'graph[]';
+            } else if (arg.n) {
+                value = new caffe2.Graph(metadata, arg.n, null);
+                type = 'graph';
+            } else {
+                value = arg.i;
+            }
+            if (schema) {
+                type = !type && schema.type ? schema.type : type;
+                if (type === 'boolean') {
+                    value = value !== 0 && value.toString() !== '0' ? true : false;
+                }
+                if (schema.visible === false) {
+                    visible = false;
+                } else if (schema.default !== undefined) {
+                    if (value === metadata.default || (value && value.toString() === schema.default.toString())) {
+                        visible = false;
+                    }
+                }
+            }
+            return new caffe2.Argument(name, value, type, visible);
+        });
         const inputs = op.input;
         const outputs = op.output;
         this.inputs = [];
         let inputIndex = 0;
         if (this.type && this.type.inputs) {
             for (const inputDef of this.type.inputs) {
                 if (inputIndex < inputs.length || inputDef.option !== 'optional') {
@@ -402,53 +437,14 @@
                 const outputName = ((outputIndex + index) === 0) ? 'output' : (outputIndex + index).toString();
                 return new caffe2.Argument(outputName, [values.map(output)]);
             }));
         }
     }
 };
 
-caffe2.Attribute = class {
-
-    constructor(metadata, type, arg) {
-        this.name = arg.name;
-        if (arg.floats && arg.floats.length > 0) {
-            this.value = arg.floats;
-        } else if (arg.ints && arg.ints.length > 0) {
-            this.value = arg.ints;
-        } else if (arg.nets && arg.nets.length > 0) {
-            this.value = arg.nets.map((net) => new caffe2.Graph(metadata, net, null));
-            this.type = 'graph[]';
-        } else if (arg.n) {
-            this.value = new caffe2.Graph(metadata, arg.n, null);
-            this.type = 'graph';
-        } else {
-            this.value = arg.i;
-        }
-        metadata = metadata.attribute(type, arg.name);
-        if (metadata) {
-            if (Object.prototype.hasOwnProperty.call(metadata, 'type')) {
-                this.type = metadata.type;
-                if (this.type === 'boolean') {
-                    this.value = this.value !== 0 && this.value.toString() !== '0' ? true : false;
-                }
-            }
-        }
-
-        if (metadata) {
-            if (metadata.visible === false) {
-                this.visible = false;
-            } else if (metadata.default !== undefined) {
-                if (this.value === metadata.default || (this.value && this.value.toString() === metadata.default.toString())) {
-                    this.visible = false;
-                }
-            }
-        }
-    }
-};
-
 caffe2.Tensor = class {
 
     constructor(name, tensor) {
         this.name = name;
         const shape = tensor.shape && tensor.shape.ints ? tensor.shape.ints : null;
         this.type = new caffe2.TensorType(tensor.dataType, new caffe2.TensorShape(shape));
         this.values = null;
```

## netron/circle.js

### js-beautify {}

```diff
@@ -116,15 +116,15 @@
                         if (modelMetadata.name) {
                             this.name = modelMetadata.name;
                         }
                         if (modelMetadata.version) {
                             this.version = modelMetadata.version;
                         }
                         if (modelMetadata.description) {
-                            this.description = this._description ? [this._description, modelMetadata.description].join(' ') : modelMetadata.description;
+                            this.description = this.description ? [this.description, modelMetadata.description].join(' ') : modelMetadata.description;
                         }
                         if (modelMetadata.author) {
                             this.metadata.push(new circle.Argument('author', modelMetadata.author));
                         }
                         if (modelMetadata.license) {
                             this.metadata.push(new circle.Argument('license', modelMetadata.license));
                         }
@@ -272,31 +272,33 @@
             return new circle.Argument(output.name, values);
         });
     }
 };
 
 circle.Node = class {
 
-    constructor(metadata, node, type, location, tensors) {
-        this._location = location;
-        this._type = type.custom ? {
+    constructor(metadata, node, type, identifier, tensors) {
+        this.name = '';
+        this.identifier = identifier;
+        this.type = type.custom ? {
             name: type.name
         } : metadata.type(type.name);
-        this._inputs = [];
-        this._outputs = [];
-        this._attributes = [];
+        this.inputs = [];
+        this.outputs = [];
+        this.attributes = [];
         if (node) {
+            const attributes = [];
             const inputs = Array.from(node.inputs || new Int32Array(0));
             for (let i = 0; i < inputs.length;) {
                 let count = 1;
                 let name = null;
                 let visible = true;
                 const values = [];
-                if (this._type && this._type.inputs && i < this._type.inputs.length) {
-                    const input = this._type.inputs[i];
+                if (this.type && this.type.inputs && i < this.type.inputs.length) {
+                    const input = this.type.inputs[i];
                     name = input.name;
                     if (input.list) {
                         count = inputs.length - i;
                     }
                     if (input.visible === false) {
                         visible = false;
                     }
@@ -305,172 +307,121 @@
                     const value = tensors.map(index);
                     if (value) {
                         values.push(value);
                     }
                 }
                 name = name ? name : (i + 1).toString();
                 i += count;
-                const argument = new circle.Argument(name, values, visible);
-                this._inputs.push(argument);
+                const argument = new circle.Argument(name, values, null, visible);
+                this.inputs.push(argument);
             }
             const outputs = Array.from(node.outputs || new Int32Array(0));
             for (let i = 0; i < outputs.length; i++) {
                 const index = outputs[i];
                 const value = tensors.map(index);
                 const values = value ? [value] : [];
                 let name = (i + 1).toString();
-                if (this._type && this._type.outputs && i < this._type.outputs.length) {
-                    const output = this._type.outputs[i];
+                if (this.type && this.type.outputs && i < this.type.outputs.length) {
+                    const output = this.type.outputs[i];
                     if (output && output.name) {
                         name = output.name;
                     }
                 }
                 const argument = new circle.Argument(name, values);
-                this._outputs.push(argument);
+                this.outputs.push(argument);
             }
             if (type.custom && node.custom_options && node.custom_options.length > 0) {
                 let decoded = false;
                 if (node.custom_options_format === circle.schema.CustomOptionsFormat.FLEXBUFFERS) {
                     try {
                         const reader = flexbuffers.BinaryReader.open(node.custom_options);
                         if (reader) {
                             const custom_options = reader.read();
                             if (Array.isArray(custom_options)) {
-                                const attribute = new circle.Attribute(null, 'custom_options', custom_options);
-                                this._attributes.push(attribute);
+                                attributes.push([null, 'custom_options', custom_options]);
                                 decoded = true;
                             } else if (custom_options) {
                                 for (const [key, value] of Object.entries(custom_options)) {
                                     const schema = metadata.attribute(type.name, key);
-                                    const attribute = new circle.Attribute(schema, key, value);
-                                    this._attributes.push(attribute);
+                                    attributes.push([schema, key, value]);
                                 }
                                 decoded = true;
                             }
                         }
                     } catch {
                         // continue regardless of error
                     }
                 }
                 if (!decoded) {
                     const schema = metadata.attribute(type.name, 'custom');
-                    const attribute = new circle.Attribute(schema, 'custom', Array.from(node.custom_options));
-                    this._attributes.push(attribute);
+                    attributes.push([schema, 'custom', Array.from(node.custom_options)]);
                 }
             }
             const options = node.builtin_options;
             if (options) {
                 for (const [name, value] of Object.entries(options)) {
                     if (name === 'fused_activation_function' && value) {
                         if (value < 1 || value > 5) {
                             throw new circle.Error(`Unsupported activation funtion index '${value}'.`);
                         }
                         const list = ['Unknown', 'Relu', 'ReluN1To1', 'Relu6', 'Tanh', 'SignBit'];
                         const type = list[value];
                         const node = new circle.Node(metadata, null, {
                             name: type
                         }, null, []);
-                        this._chain = [node];
+                        this.chain = [node];
                     }
                     const schema = metadata.attribute(type.name, name);
-                    const attribute = new circle.Attribute(schema, name, value);
-                    this._attributes.push(attribute);
+                    this.attributes.push([schema, name, value]);
                 }
             }
-        }
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return '';
-    }
-
-    get location() {
-        return this._location;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get chain() {
-        return this._chain;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-};
-
-circle.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this._name = name;
-        this._value = ArrayBuffer.isView(value) ? Array.from(value) : value;
-        this._type = metadata && metadata.type ? metadata.type : null;
-        if (this._name === 'fused_activation_function') {
-            this._visible = false;
-        }
-        if (this._type) {
-            this._value = circle.Utility.enum(this._type, this._value);
-        }
-        if (metadata) {
-            if (metadata.visible === false) {
-                this._visible = false;
-            } else if (metadata.default !== undefined) {
-                value = this._value;
-                if (typeof value === 'function') {
-                    value = value();
+            this.attributes = attributes.map(([metadata, name, value]) => {
+                const type = metadata && metadata.type ? metadata.type : null;
+                value = ArrayBuffer.isView(value) ? Array.from(value) : value;
+                let visible = true;
+                if (name === 'fused_activation_function') {
+                    visible = false;
                 }
-                if (value === metadata.default) {
-                    this._visible = false;
+                if (type) {
+                    value = circle.Utility.enum(type, value);
                 }
-            }
+                if (metadata) {
+                    if (metadata.visible === false) {
+                        visible = false;
+                    } else if (metadata.default !== undefined) {
+                        if (typeof value === 'function') {
+                            value = value();
+                        }
+                        if (value === metadata.default) {
+                            visible = false;
+                        }
+                    }
+                }
+                return new circle.Argument(name, value, type, visible);
+            });
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get value() {
-        return this._value;
-    }
-
-    get visible() {
-        return this._visible !== false;
-    }
 };
 
 circle.Argument = class {
 
-    constructor(name, value, visible) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
         this.visible = visible !== false;
     }
 };
 
 circle.Value = class {
 
     constructor(index, tensor, initializer, description, denotation) {
         const name = tensor.name || '';
         this.name = `${name}\n${index}`;
-        this.location = index.toString();
+        this.identifier = index.toString();
         this.type = tensor.type !== undefined && tensor.shape !== undefined ? new circle.TensorType(tensor, denotation) : null;
         this.initializer = initializer;
         this.description = description;
         const quantization = tensor.quantization;
         if (quantization && (quantization.scale.length > 0 || quantization.zero_point.length > 0 || quantization.min.length > 0 || quantization.max.length)) {
             this.quantization = {
                 type: 'linear',
@@ -483,15 +434,15 @@
         }
     }
 };
 
 circle.Tensor = class {
 
     constructor(index, tensor, buffer, stream, is_variable) {
-        this.location = index.toString();
+        this.identifier = index.toString();
         this.name = tensor.name;
         this.type = new circle.TensorType(tensor);
         this.category = is_variable ? 'Variable' : '';
         this.encoding = this.type.dataType === 'string' ? '|' : '<';
         if (buffer && buffer.data && buffer.data.length > 0) {
             this._data = buffer.data.slice(0);
         } else if (buffer && buffer.offset !== 0n && buffer.size !== 0n) {
```

## netron/cntk.js

### js-beautify {}

```diff
@@ -232,17 +232,19 @@
             }
         }
     }
 };
 
 cntk.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 cntk.Value = class {
 
     constructor(version, obj) {
         switch (version) {
@@ -288,25 +290,26 @@
 
     constructor(metadata, version, obj, values) {
         this.attributes = [];
         this.inputs = [];
         this.outputs = [];
         let inputs = [];
         let outputs = [];
+        const attributes = [];
         switch (version) {
             case 1: {
                 const type = obj.__type__;
                 this.type = metadata.type(type) || {
                     name: type
                 };
                 this.name = obj.name;
                 for (const [name, value] of Object.entries(obj)) {
                     if (name !== '__type__' && name !== 'name' && name !== 'inputs' && name !== 'precision') {
-                        const attribute = new cntk.Attribute(metadata.attribute(type, name), name, value);
-                        this.attributes.push(attribute);
+                        const schema = metadata.attribute(type, name);
+                        attributes.push([schema, name, value]);
                     }
                 }
                 inputs = obj.inputs.map((input) => values.map(input, version));
                 outputs = [values.map(this.name, version)];
                 break;
             }
             case 2: {
@@ -323,23 +326,23 @@
                 } else {
                     const type = obj.type;
                     this.type = metadata.type(type) || {
                         name: type
                     };
                     if (obj.user_defined_state) {
                         for (const [name, value] of Object.entries(obj.user_defined_state)) {
-                            const attribute = new cntk.Attribute(metadata.attribute(type, name), name, value);
-                            this.attributes.push(attribute);
+                            const schema = metadata.attribute(type, name);
+                            attributes.push([schema, name, value]);
                         }
                     }
                 }
                 if (obj.attributes) {
                     for (const [name, value] of Object.entries(obj.attributes)) {
-                        const attribute = new cntk.Attribute(metadata.attribute(this.type, name), name, value);
-                        this.attributes.push(attribute);
+                        const schema = metadata.attribute(this.type, name);
+                        attributes.push([schema, name, value]);
                     }
                 }
                 inputs = obj.inputs.map((input) => values.map(input, version));
                 outputs.push(values.map(`${output}_Output_0`, version));
                 break;
             }
             default: {
@@ -375,75 +378,71 @@
                     outputIndex += outputCount;
                 }
             }
         }
         this.outputs.push(...outputs.slice(outputIndex).map((argument) => {
             return new cntk.Argument(outputIndex.toString(), [argument]);
         }));
-    }
-};
 
-cntk.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this.name = name;
-        this.value = value;
-        this.type = null;
-        if (this.value && this.value.__type__ === 'shape') {
-            this.value = new cntk.TensorShape(1, value);
-            this.type = 'shape';
-        }
-        if (cntk.proto && this.value instanceof cntk.proto.NDShape) {
-            this.value = new cntk.TensorShape(2, value);
-            this.type = 'shape';
-        }
-        if (cntk.proto && this.value instanceof cntk.proto.Axis) {
-            const axis = {
-                __type__: 'Axis'
-            };
-            for (const key of Object.keys(value).filter((key) => key !== 'name')) {
-                axis[key] = value[key];
+        this.attributes = attributes.map(([metadata, name, value]) => {
+            let type = null;
+            let visible = true;
+            if (value && value.__type__ === 'shape') {
+                value = new cntk.TensorShape(1, value);
+                type = 'shape';
+            }
+            if (cntk.proto && value instanceof cntk.proto.NDShape) {
+                value = new cntk.TensorShape(2, value);
+                type = 'shape';
+            }
+            if (cntk.proto && value instanceof cntk.proto.Axis) {
+                const axis = {
+                    __type__: 'Axis'
+                };
+                for (const key of Object.keys(value).filter((key) => key !== 'name')) {
+                    axis[key] = value[key];
+                }
+                value = axis;
             }
-            this.value = axis;
-        }
-        if (metadata) {
-            if (metadata.type) {
-                this.type = metadata.type;
-                const type = cntk[this.type] || cntk.proto[this.type];
-                if (type && type[this.value]) {
-                    this.value = type[this.value];
-                }
-            }
-            if (metadata.visible === false) {
-                this.visible = false;
-            } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
-                let defaultValue = metadata.default;
-                value = this.value;
-                if (typeof value === 'function') {
-                    value = value();
-                }
-                if (this.type === 'shape') {
-                    value = value.dimensions;
-                }
-                if (value === defaultValue) {
-                    this.visible = false;
-                } else if (Array.isArray(value) && Array.isArray(defaultValue)) {
-                    defaultValue = defaultValue.slice(0, defaultValue.length);
-                    if (defaultValue.length > 1 && defaultValue[defaultValue.length - 1] === null) {
-                        defaultValue.pop();
-                        while (defaultValue.length < value.length) {
-                            defaultValue.push(defaultValue[defaultValue.length - 1]);
+            if (metadata) {
+                if (metadata.type) {
+                    type = metadata.type;
+                    const table = cntk[type] || cntk.proto[type];
+                    if (table && table[value]) {
+                        value = table[value];
+                    }
+                }
+                if (metadata.visible === false) {
+                    visible = false;
+                } else if (metadata.default !== undefined) {
+                    let defaultValue = metadata.default;
+                    if (typeof value === 'function') {
+                        value = value();
+                    }
+                    if (type === 'shape') {
+                        value = value.dimensions;
+                    }
+                    if (value === defaultValue) {
+                        visible = false;
+                    } else if (Array.isArray(value) && Array.isArray(defaultValue)) {
+                        defaultValue = defaultValue.slice(0, defaultValue.length);
+                        if (defaultValue.length > 1 && defaultValue[defaultValue.length - 1] === null) {
+                            defaultValue.pop();
+                            while (defaultValue.length < value.length) {
+                                defaultValue.push(defaultValue[defaultValue.length - 1]);
+                            }
+                        }
+                        if (value.every((item, index) => item === defaultValue[index])) {
+                            visible = false;
                         }
-                    }
-                    if (value.every((item, index) => item === defaultValue[index])) {
-                        this.visible = false;
                     }
                 }
             }
-        }
+            return new cntk.Argument(name, value, type, visible);
+        });
     }
 };
 
 cntk.Tensor = class {
 
     constructor(version, tensor) {
         this.encoding = '|';
```

## netron/coreml.js

### js-beautify {}

```diff
@@ -251,19 +251,19 @@
             const initializer = value.initializer;
             if (!value.obj) {
                 value.obj = new coreml.Value(name, type, description, initializer);
             }
         }
         this.inputs = context.inputs.map((argument) => {
             const values = argument.value.map((value) => value.obj);
-            return new coreml.Argument(argument.name, values, argument.visible);
+            return new coreml.Argument(argument.name, values, null, argument.visible);
         });
         this.outputs = context.outputs.map((argument) => {
             const values = argument.value.map((value) => value.obj);
-            return new coreml.Argument(argument.name, values, argument.visible);
+            return new coreml.Argument(argument.name, values, null, argument.visible);
         });
         for (const obj of context.nodes) {
             const attributes = obj.attributes;
             switch (obj.type) {
                 case 'loop':
                     attributes.conditionNetwork = new coreml.Graph(attributes.conditionNetwork);
                     attributes.bodyNetwork = new coreml.Graph(attributes.bodyNetwork);
@@ -278,17 +278,18 @@
         }
         this.nodes = context.nodes.map((obj) => new coreml.Node(context, obj));
     }
 };
 
 coreml.Argument = class {
 
-    constructor(name, value, visible) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
         this.visible = visible !== false;
     }
 };
 
 coreml.Value = class {
 
     constructor(name, type, description, initializer) {
@@ -319,59 +320,51 @@
             name: obj.type
         };
         this.type.name = obj.type.split(':').pop();
         this.name = obj.name || '';
         this.description = obj.description || '';
         this.inputs = (obj.inputs || []).map((argument) => {
             const values = argument.value.map((value) => value.obj);
-            return new coreml.Argument(argument.name, values, argument.visible);
+            return new coreml.Argument(argument.name, values, null, argument.visible);
         });
         this.outputs = (obj.outputs || []).map((argument) => {
             const values = argument.value.map((value) => value.obj);
-            return new coreml.Argument(argument.name, values, argument.visible);
+            return new coreml.Argument(argument.name, values, null, argument.visible);
         });
         this.attributes = Object.entries(obj.attributes).map(([name, value]) => {
             const metadata = context.metadata.attribute(obj.type, name);
-            return new coreml.Attribute(metadata, name, value);
-        });
-    }
-};
-
-coreml.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this.name = name;
-        this.value = value;
-        if (this.value instanceof coreml.Tensor) {
-            this.type = 'tensor';
-        }
-        if (metadata) {
-            if (metadata.type) {
-                this.type = metadata.type;
+            let type = null;
+            let visible = true;
+            if (value instanceof coreml.Tensor) {
+                type = 'tensor';
             }
-            if (this.type && coreml.proto) {
-                this.value = coreml.Utility.enum(this.type, this.value);
+            if (value instanceof coreml.Graph) {
+                type = 'graph';
             }
-            if (metadata.visible === false) {
-                this.visible = false;
-            } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
-                if (Array.isArray(value)) {
-                    value = value.map((item) => Number(item));
-                }
-                if (typeof value === 'bigint') {
-                    value = Number(value);
+            if (metadata) {
+                type = metadata.type ? metadata.type : type;
+                if (type && coreml.proto) {
+                    value = coreml.Utility.enum(type, value);
                 }
-                if (JSON.stringify(metadata.default) === JSON.stringify(value)) {
-                    this.visible = false;
+                if (metadata.visible === false) {
+                    visible = false;
+                } else if (metadata.default !== undefined) {
+                    if (Array.isArray(value)) {
+                        value = value.map((item) => Number(item));
+                    }
+                    if (typeof value === 'bigint') {
+                        value = Number(value);
+                    }
+                    if (JSON.stringify(metadata.default) === JSON.stringify(value)) {
+                        visible = false;
+                    }
                 }
             }
-        }
-        if (this.value instanceof coreml.Graph) {
-            this.type = 'graph';
-        }
+            return new coreml.Argument(name, value, type, visible);
+        });
     }
 };
 
 coreml.Tensor = class {
 
     constructor(type, values, quantization, category) {
         this.type = type;
```

## netron/dagre.js

### js-beautify {}

```diff
@@ -1727,14 +1727,17 @@
                     const v = stack.pop();
                     if (visited.has(v)) {
                         let min = Number.POSITIVE_INFINITY;
                         for (const e of blockG.node(v).out) {
                             min = Math.min(min, xs[e.w] - e.label);
                         }
                         const label = g.node(v).label;
+                        if (label.dummy) {
+                            continue;
+                        }
                         if (min !== Number.POSITIVE_INFINITY && label.borderType !== borderType) {
                             xs[v] = Math.max(xs[v], min);
                         }
                     } else {
                         visited.add(v);
                         stack.push(v);
                         for (const w of blockG.successors(v)) {
```

## netron/darknet.js

### js-beautify {}

```diff
@@ -63,32 +63,25 @@
         }
     }
 };
 
 darknet.Model = class {
 
     constructor(metadata, reader, weights) {
-        this._graphs = [new darknet.Graph(metadata, reader, weights)];
-    }
-
-    get format() {
-        return 'Darknet';
-    }
-
-    get graphs() {
-        return this._graphs;
+        this.format = 'Darknet';
+        this.graphs = [new darknet.Graph(metadata, reader, weights)];
     }
 };
 
 darknet.Graph = class {
 
     constructor(metadata, reader, weights) {
-        this._inputs = [];
-        this._outputs = [];
-        this._nodes = [];
+        this.inputs = [];
+        this.outputs = [];
+        this.nodes = [];
         const params = {};
         const sections = reader.read();
         const globals = new Map();
         const net = sections.shift();
         const option_find_int = (options, key, defaultValue) => {
             let value = options[key];
             if (typeof value === 'string' && value.startsWith('$')) {
@@ -115,15 +108,15 @@
             return new darknet.TensorShape(dimensions);
         };
         const load_weights = (name, shape, visible) => {
             const data = weights ? weights.read(4 * shape.reduce((a, b) => a * b, 1)) : null;
             const type = new darknet.TensorType('float32', make_shape(shape, 'load_weights'));
             const initializer = new darknet.Tensor(type, data);
             const value = new darknet.Value('', null, initializer);
-            return new darknet.Argument(name, visible !== false, [value]);
+            return new darknet.Argument(name, [value], null, visible !== false);
         };
         const load_batch_normalize_weights = (layer, prefix, size) => {
             layer.weights.push(load_weights(`${prefix}scale`, [size], prefix === ''));
             layer.weights.push(load_weights(`${prefix}mean`, [size], prefix === ''));
             layer.weights.push(load_weights(`${prefix}variance`, [size], prefix === ''));
         };
         const make_convolutional_layer = (layer, prefix, w, h, c, n, groups, size, stride_x, stride_y, padding, batch_normalize) => {
@@ -192,15 +185,15 @@
             }
         }
         const inputType = params.w && params.h && params.c ?
             new darknet.TensorType('float32', make_shape([params.w, params.h, params.c], 'params-if')) :
             new darknet.TensorType('float32', make_shape([params.inputs], 'params-else'));
         const inputName = 'input';
         params.value = [new darknet.Value(inputName, inputType, null)];
-        this._inputs.push(new darknet.Argument(inputName, true, params.value));
+        this.inputs.push(new darknet.Argument(inputName, params.value));
         for (let i = 0; i < sections.length; i++) {
             const section = sections[i];
             section.name = i.toString();
             section.layer = {
                 inputs: [],
                 weights: [],
                 outputs: [new darknet.Value(section.name, null, null)],
@@ -880,278 +873,157 @@
                 params.inputs = layer.out;
                 params.last = section;
             }
             params.value = layer.outputs;
         }
 
         for (let i = 0; i < sections.length; i++) {
-            this._nodes.push(new darknet.Node(metadata, net, sections[i]));
+            this.nodes.push(new darknet.Node(metadata, net, sections[i]));
         }
 
         if (weights) {
             weights.validate();
         }
     }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
 };
 
 darknet.Argument = class {
 
-    constructor(name, visible, value) {
-        this._name = name;
-        this._visible = visible;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get visible() {
-        return this._visible;
-    }
+    constructor(name, value, type, visible) {
+        this.name = name;
+        this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
 
-    get value() {
-        return this._value;
     }
 };
 
 darknet.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
             throw new darknet.Error(`Invalid value identifier '${JSON.stringify(name)}'.`);
         }
-        this._name = name;
-        this._type = type;
-        this._initializer = initializer;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        if (this._initializer) {
-            return this._initializer.type;
-        }
-        return this._type;
-    }
-
-    set type(value) {
-        if (this._type) {
-            throw new darknet.Error('Invalid argument type set operation.');
-        }
-        this._type = value;
-    }
-
-    get initializer() {
-        return this._initializer;
+        this.name = name;
+        this.type = initializer && initializer.type ? initializer.type : type;
+        this.initializer = initializer;
     }
 };
 
 darknet.Node = class {
 
     constructor(metadata, net, section) {
-        this._name = section.name || '';
-        this._location = section.line === undefined ? undefined : section.line.toString();
-        this._attributes = [];
-        this._inputs = [];
-        this._outputs = [];
-        this._chain = [];
+        this.name = section.name || '';
+        this.identifier = section.line === undefined ? undefined : section.line.toString();
+        this.attributes = [];
+        this.inputs = [];
+        this.outputs = [];
+        this.chain = [];
         const type = section.type;
-        this._type = metadata.type(type) || {
+        this.type = metadata.type(type) || {
             name: type
         };
         const layer = section.layer;
         if (layer && layer.inputs && layer.inputs.length > 0) {
-            this._inputs.push(new darknet.Argument(layer.inputs.length <= 1 ? 'input' : 'inputs', true, layer.inputs));
+            this.inputs.push(new darknet.Argument(layer.inputs.length <= 1 ? 'input' : 'inputs', layer.inputs));
         }
         if (layer && layer.weights && layer.weights.length > 0) {
-            this._inputs = this._inputs.concat(layer.weights);
+            this.inputs = this.inputs.concat(layer.weights);
         }
         if (layer && layer.outputs && layer.outputs.length > 0) {
-            this._outputs.push(new darknet.Argument(layer.outputs.length <= 1 ? 'output' : 'outputs', true, layer.outputs));
+            this.outputs.push(new darknet.Argument(layer.outputs.length <= 1 ? 'output' : 'outputs', layer.outputs));
         }
         if (layer && layer.chain) {
             for (const chain of layer.chain) {
-                this._chain.push(new darknet.Node(metadata, net, chain, ''));
+                this.chain.push(new darknet.Node(metadata, net, chain, ''));
             }
         }
         const options = section.options;
         if (options) {
-            for (const key of Object.keys(options)) {
-                this._attributes.push(new darknet.Attribute(metadata.attribute(type, key), key, options[key]));
-            }
-        }
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get location() {
-        return this._location;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get chain() {
-        return this._chain;
-    }
-};
-
-darknet.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this._name = name;
-        this._value = value;
-        if (metadata) {
-            this._type = metadata.type || '';
-            switch (this._type) {
-                case '':
-                case 'string': {
-                    break;
-                }
-                case 'int32': {
-                    const number = parseInt(this._value, 10);
-                    if (Number.isInteger(number)) {
-                        this._value = number;
-                    }
-                    break;
-                }
-                case 'float32': {
-                    const number = parseFloat(this._value);
-                    if (!isNaN(number)) {
-                        this._value = number;
-                    }
-                    break;
-                }
-                case 'int32[]': {
-                    const numbers = this._value.split(',').map((item) => parseInt(item.trim(), 10));
-                    if (numbers.every((number) => Number.isInteger(number))) {
-                        this._value = numbers;
+            for (const [name, obj] of Object.entries(options)) {
+                const schema = metadata.attribute(section.type, name);
+                let type = null;
+                let value = obj;
+                let visible = true;
+                if (schema) {
+                    type = schema.type || '';
+                    switch (type) {
+                        case '':
+                        case 'string': {
+                            break;
+                        }
+                        case 'int32': {
+                            const number = parseInt(value, 10);
+                            if (Number.isInteger(number)) {
+                                value = number;
+                            }
+                            break;
+                        }
+                        case 'float32': {
+                            const number = parseFloat(value);
+                            if (!isNaN(number)) {
+                                value = number;
+                            }
+                            break;
+                        }
+                        case 'int32[]': {
+                            const numbers = value.split(',').map((item) => parseInt(item.trim(), 10));
+                            if (numbers.every((number) => Number.isInteger(number))) {
+                                value = numbers;
+                            }
+                            break;
+                        }
+                        default: {
+                            throw new darknet.Error(`Unsupported attribute type '${type}'.`);
+                        }
                     }
-                    break;
-                }
-                default: {
-                    throw new darknet.Error(`Unsupported attribute type '${this._type}'.`);
-                }
-            }
-            if (metadata && metadata.visible === false) {
-                this._visible = false;
-            } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
-                if (this._value === metadata.default) {
-                    this._visible = false;
+                    visible = (schema.visible === false || value === schema.default);
                 }
+                const attribute = new darknet.Argument(name, value, type, visible);
+                this.attributes.push(attribute);
             }
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get value() {
-        return this._value;
-    }
-
-    get visible() {
-        return this._visible !== false;
-    }
 };
 
 darknet.Tensor = class {
 
     constructor(type, data) {
-        this._type = type;
-        this._values = data;
-    }
-
-    get name() {
-        return '';
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get values() {
-        return this._values;
+        this.type = type;
+        this.values = data;
     }
 };
 
 darknet.TensorType = class {
 
     constructor(dataType, shape) {
-        this._dataType = dataType;
-        this._shape = shape;
-    }
-
-    get dataType() {
-        return this._dataType;
-    }
-
-    get shape() {
-        return this._shape;
+        this.dataType = dataType;
+        this.shape = shape;
     }
 
     toString() {
-        return (this._dataType || '?') + this._shape.toString();
+        return (this.dataType || '?') + this.shape.toString();
     }
 };
 
 darknet.TensorShape = class {
 
     constructor(dimensions) {
         if (dimensions.some((dimension) => dimension === 0 || dimension === undefined || isNaN(dimension))) {
             throw new darknet.Error(`Invalid tensor shape '${JSON.stringify(dimensions)}'.`);
         }
-        this._dimensions = dimensions;
-    }
-
-    get dimensions() {
-        return this._dimensions;
+        this.dimensions = dimensions;
     }
 
     toString() {
-        if (this._dimensions) {
-            if (this._dimensions.length === 0) {
+        if (this.dimensions) {
+            if (this.dimensions.length === 0) {
                 return '';
             }
-            return `[${this._dimensions.map((dimension) => dimension.toString()).join(',')}]`;
+            return `[${this.dimensions.map((dimension) => dimension.toString()).join(',')}]`;
         }
         return '';
     }
 };
 
 darknet.Reader = class {
```

## netron/dlc.js

### js-beautify {}

```diff
@@ -116,17 +116,18 @@
             this.nodes.push(new dlc.Node(metadata, version, node, value));
         }
     }
 };
 
 dlc.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
     }
 };
 
 dlc.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
@@ -171,52 +172,44 @@
             this.outputs.push(argument);
         }
         if (node.attributes) {
             for (const attr of node.attributes) {
                 if (attr.name === 'OutputDims') {
                     continue;
                 }
-                const attribute = new dlc.Attribute(metadata.attribute(type, attr.name), version, attr);
+                const schema = metadata.attribute(node.type, attr.name);
+                let type = attr.type;
+                switch (type) {
+                    case 'tensor': {
+                        const type = new dlc.TensorType(attr.data.dtype, attr.data.shape);
+                        value = new dlc.Tensor(type, attr.data.data);
+                        break;
+                    }
+                    default: {
+                        value = attr.data;
+                    }
+                }
+                if (schema && schema.type) {
+                    type = schema.type;
+                    value = dlc.Utility.enum(version, type, value);
+                }
+                const attribute = new dlc.Argument(attr.name, value, type);
                 this.attributes.push(attribute);
             }
         }
         if (node.weights) {
             for (const tensor of node.weights) {
                 const type = new dlc.TensorType(tensor.data.dtype, tensor.shape);
                 const value = new dlc.Value('', type, new dlc.Tensor(type, tensor.data));
                 this.inputs.push(new dlc.Argument(tensor.name, [value]));
             }
         }
     }
 };
 
-dlc.Attribute = class {
-
-    constructor(metadata, version, attribute) {
-        this.name = attribute.name;
-        this.type = attribute.type;
-        switch (this.type) {
-            case 'tensor': {
-                const tensor = attribute.data;
-                const type = new dlc.TensorType(tensor.dtype, tensor.shape);
-                const data = tensor.data;
-                this.value = new dlc.Tensor(type, data);
-                break;
-            }
-            default: {
-                this.value = attribute.data;
-            }
-        }
-        if (metadata && metadata.type) {
-            this.type = metadata.type;
-            this.value = dlc.Utility.enum(version, this.type, this.value);
-        }
-    }
-};
-
 dlc.TensorType = class {
 
     constructor(dataType, shape) {
         this.dataType = dataType || '?';
         this.shape = new dlc.TensorShape(shape);
     }
```

## netron/dnn.js

### js-beautify {}

```diff
@@ -168,53 +168,45 @@
         }
         if (outputs.length > 0) {
             this.outputs = outputs.map((output, index) => {
                 const inputName = (index === 0) ? 'output' : index.toString();
                 return new dnn.Argument(inputName, [output]);
             });
         }
-        for (const key of Object.keys(layer)) {
+        for (const [key, obj] of Object.entries(layer)) {
             switch (key) {
                 case 'name':
                 case 'type':
                 case 'weight':
                 case 'is_quantized':
                 case 'quantization':
                     break;
                 default: {
-                    const attribute = new dnn.Attribute(metadata.attribute(type, key), key, layer[key]);
+                    const attribute = new dnn.Argument(key, obj);
                     this.attributes.push(attribute);
                     break;
                 }
             }
         }
     }
 };
 
-dnn.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this.name = name;
-        this.value = value;
-    }
-};
-
 dnn.Tensor = class {
 
     constructor(weight, quantization) {
         const shape = new dnn.TensorShape([weight.dim0, weight.dim1, weight.dim2, weight.dim3]);
         this.values = quantization ? weight.quantized_data : weight.data;
         const size = shape.dimensions.reduce((a, b) => a * b, 1);
-        const itemSize = Math.floor(this.values.length / size);
-        const remainder = this.values.length - (itemSize * size);
-        if (remainder < 0 || remainder > itemSize) {
+        const itemsize = Math.floor(this.values.length / size);
+        const remainder = this.values.length - (itemsize * size);
+        if (remainder < 0 || remainder > itemsize) {
             throw new dnn.Error('Invalid tensor data size.');
         }
         let dataType = '?';
-        switch (itemSize) {
+        switch (itemsize) {
             case 1:
                 dataType = 'int8';
                 break;
             case 2:
                 dataType = 'float16';
                 break;
             case 4:
```

## netron/flax.js

### js-beautify {}

```diff
@@ -117,32 +117,24 @@
         this.outputs = [];
         for (const [name, value] of Object.entries(layer)) {
             if (flax.Utility.isTensor(value)) {
                 const tensor = new flax.Tensor(value);
                 const argument = new flax.Argument(name, [new flax.Value('', tensor)]);
                 this.inputs.push(argument);
             } else if (Array.isArray(value)) {
-                const attribute = new flax.Attribute(name, value);
+                const attribute = new flax.Argument(name, value);
                 this.attributes.push(attribute);
             } else {
-                const attribute = new flax.Attribute(name, value);
+                const attribute = new flax.Argument(name, value);
                 this.attributes.push(attribute);
             }
         }
     }
 };
 
-flax.Attribute = class {
-
-    constructor(name, value) {
-        this.name = name;
-        this.value = value;
-    }
-};
-
 flax.TensorType = class {
 
     constructor(dataType, shape) {
         this.dataType = dataType || '?';
         this.shape = shape;
     }
```

## netron/flux.js

### js-beautify {}

```diff
@@ -51,24 +51,16 @@
         throw new flux.Error("File contains unsupported Flux data.");
     }
 };
 
 flux.Model = class {
 
     constructor( /* root */ ) {
-        this._format = 'Flux';
-        this._graphs = [];
-    }
-
-    get format() {
-        return this._format;
-    }
-
-    get graphs() {
-        return this._graphs;
+        this.format = 'Flux';
+        this.graphs = [];
     }
 };
 
 flux.Error = class extends Error {
 
     constructor(message) {
         super(message);
```

## netron/gguf.js

### js-beautify {}

```diff
@@ -150,29 +150,21 @@
                 const value = new gguf.Value(weight.name, tensor);
                 const argument = new gguf.Argument(name, [value]);
                 this.inputs.push(argument);
             }
         }
         if (layer.metadata) {
             for (const [name, value] of layer.metadata) {
-                const attribute = new gguf.Attribute(name, value);
+                const attribute = new gguf.Argument(name, value);
                 this.attributes.push(attribute);
             }
         }
     }
 };
 
-gguf.Attribute = class {
-
-    constructor(name, value) {
-        this.name = name;
-        this.value = value;
-    }
-};
-
 gguf.TensorType = class {
 
     constructor(dataType, shape) {
         this.dataType = dataType;
         this.shape = shape;
     }
```

## netron/hailo.js

### js-beautify {}

```diff
@@ -101,17 +101,19 @@
             }
         }
     }
 };
 
 hailo.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 hailo.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
@@ -162,47 +164,39 @@
         this.inputs = this.inputs.concat(params_list).concat(params_from_npz);
         this.outputs = (layer.output || []).map((name, index) => {
             const shape = layer.output_shapes ? layer.output_shapes[index] : null;
             const type = shape ? new hailo.TensorType('?', new hailo.TensorShape(shape)) : null;
             name = `${layer.name}\n${name}`;
             return new hailo.Argument("output", [values.map(name, type, null)]);
         });
+        this.attributes = [];
         const attrs = Object.assign(layer.params || {}, {
             original_names: layer.original_names || []
         });
-        this.attributes = Object.entries(attrs).map(([name, value]) => new hailo.Attribute(metadata.attribute(layer.type, name), name, value));
+        for (const [name, value] of Object.entries(attrs)) {
+            const schema = metadata.attribute(layer.type, name);
+            const type = schema && schema.type ? schema.type : '';
+            const visible = name === 'original_names' || (schema && schema.visible === false) ? false : true;
+            const attribute = new hailo.Argument(name, value, type, visible);
+            this.attributes.push(attribute);
+        }
         this.chain = [];
         if (layer && layer.params && layer.params.activation && layer.params.activation !== 'linear' && layer.type !== 'activation') {
             const activation = {
                 type: layer.params.activation,
                 name: layer.params.activation,
                 input: [],
                 output: []
             };
             const node = new hailo.Node(metadata, activation, values.map);
             this.chain.push(node);
         }
     }
 };
 
-hailo.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this.name = name;
-        this.value = value;
-        this.type = metadata && metadata.type ? metadata.type : '';
-        if (metadata && metadata.visible === false) {
-            this.visible = false;
-        }
-        if (name === 'original_names') {
-            this.visible = false;
-        }
-    }
-};
-
 hailo.Tensor = class {
 
     constructor(array, shape) {
         const dataType = array && array.dtype ? array.dtype.__name__ : '?';
         shape = array && array.shape ? array.shape : shape;
         this.type = new hailo.TensorType(dataType, new hailo.TensorShape(shape));
         if (array) {
```

## netron/imgdnn.js

### js-beautify {}

```diff
@@ -15,45 +15,25 @@
         throw new imgdnn.Error('Invalid file content. File contains undocumented IMGDNN data.');
     }
 };
 
 imgdnn.Model = class {
 
     constructor(metadata, model) {
-        this._format = 'IMGDNN';
-        this._graphs = [new imgdnn.Graph(metadata, model)];
-    }
-
-    get format() {
-        return this._format;
-    }
-
-    get graphs() {
-        return this._graphs;
+        this.format = 'IMGDNN';
+        this.graphs = [new imgdnn.Graph(metadata, model)];
     }
 };
 
 imgdnn.Graph = class {
 
     constructor( /* metadata, model */ ) {
-        this._inputs = [];
-        this._outputs = [];
-        this._nodes = [];
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
+        this.inputs = [];
+        this.outputs = [];
+        this.nodes = [];
     }
 };
 
 imgdnn.Error = class extends Error {
 
     constructor(message) {
         super(message);
```

## netron/index.html

```diff
@@ -1,16 +1,16 @@
 <!DOCTYPE html>
 <html lang="en">
 <head>
 <meta charset="utf-8">
 <meta name="description" content="Visualizer for neural network, deep learning and machine learning models." />
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
 <meta http-equiv="Content-Security-Policy" content="script-src 'self'">
-<meta name="version" content="7.6.8">
-<meta name="date" content="2024-05-18 02:16:49">
+<meta name="version" content="7.6.9">
+<meta name="date" content="2024-05-25 02:48:13">
 <title>Netron</title>
 <link rel="stylesheet" type="text/css" href="grapher.css">
 <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
 <link rel="icon" type="image/png" href="icon.png">
 <link rel="apple-touch-icon" type="image/png" href="icon.png">
 <link rel="apple-touch-icon-precomposed" type="image/png" href="icon.png">
 <link rel="fluid-icon" type="image/png" href="icon.png">
```

## netron/index.js

### js-beautify {}

```diff
@@ -45,29 +45,29 @@
         ['view'],
         ['json', 'xml', 'protobuf', 'hdf5', 'grapher', 'browser'],
         ['base', 'text', 'flatbuffers', 'flexbuffers', 'zip', 'tar', 'python', 'dagre']
     ];
     var next = function() {
         if (modules.length === 0) {
             callback();
-            return;
-        }
-        var ids = modules.pop();
-        var resolved = ids.length;
-        for (var i = 0; i < ids.length; i++) {
-            window.exports.require(ids[i], function(module, error) {
-                if (error) {
-                    callback(null, error);
-                    return;
-                }
-                resolved--;
-                if (resolved === 0) {
-                    next();
-                }
-            }, true);
+        } else {
+            var ids = modules.pop();
+            var resolved = ids.length;
+            for (var i = 0; i < ids.length; i++) {
+                window.exports.require(ids[i], function(module, error) {
+                    if (error) {
+                        callback(null, error);
+                    } else {
+                        resolved--;
+                        if (resolved === 0) {
+                            next();
+                        }
+                    }
+                }, true);
+            }
         }
     };
     next();
 };
 
 window.exports.terminate = function(message) {
     document.getElementById('message-text').innerText = message;
@@ -94,15 +94,15 @@
 window.addEventListener('load', function() {
     if (typeof Symbol !== 'function' || typeof Symbol.asyncIterator !== 'symbol' ||
         typeof BigInt !== 'function' || typeof BigInt.asIntN !== 'function' || typeof BigInt.asUintN !== 'function' || typeof DataView.prototype.getBigInt64 !== 'function') {
         throw new Error('Please update your browser to use this application.');
     }
     var ua = window.navigator.userAgent;
     var chrome = ua.match(/Chrom(e|ium)\/([0-9]+)\./);
-    if (Array.isArray(chrome) && parseInt(chrome[1], 10) < 80) {
+    if (Array.isArray(chrome) && parseInt(chrome[2], 10) < 80) {
         throw new Error('Please update your browser to use this application.');
     }
     var safari = ua.match(/Version\/(\d+).*Safari/);
     if (Array.isArray(safari) && parseInt(safari[1], 10) < 15) {
         throw new Error('Please update your browser to use this application.');
     }
     window.exports.preload(function(value, error) {
```

## netron/keras.js

### js-beautify {}

```diff
@@ -520,45 +520,28 @@
         }
     }
 };
 
 keras.Model = class {
 
     constructor(metadata, format, producer, backend, config, weights) {
-        this._format = format;
-        this._backend = backend;
-        this._producer = producer;
+        this.format = format;
+        this.runtime = backend;
+        this.producer = producer;
         metadata = new keras.GraphMetadata(metadata);
-        this._graphs = [new keras.Graph(metadata, config, weights)];
-    }
-
-    get format() {
-        return this._format;
-    }
-
-    get producer() {
-        return this._producer;
-    }
-
-    get runtime() {
-        return this._backend;
-    }
-
-    get graphs() {
-        return this._graphs;
+        this.graphs = [new keras.Graph(metadata, config, weights)];
     }
 };
 
 keras.Graph = class {
 
     constructor(metadata, config, weights, group) {
-        this._metadata = metadata;
-        this._inputs = [];
-        this._outputs = [];
-        this._nodes = [];
+        this.inputs = [];
+        this.outputs = [];
+        this.nodes = [];
         group = group || '';
         const values = new Map();
         values.map = (name, type, tensor) => {
             if (tensor) {
                 return new keras.Value(name, type || null, tensor);
             }
             if (!values.has(name)) {
@@ -587,15 +570,15 @@
                         shape = config.batch_input_shape.items.map((s) => s === null ? '?' : s);
                         delete config.batch_input_shape;
                     }
                     return new keras.TensorType(dataType, new keras.TensorShape(shape));
                 }
                 return null;
             };
-            this._name = config.name || (config.config && config.config.name ? config.config.name : '');
+            this.name = config.name || (config.config && config.config.name ? config.config.name : '');
             switch (config.class_name) {
                 case 'AllCNN':
                 case 'Sequential': {
                     config = config.config;
                     const outputs = null;
                     let name = 'input';
                     let index = -1;
@@ -608,16 +591,16 @@
                             const type = getInputType(layer);
                             let remove = false;
                             if (layer.class_name === 'InputLayer' && layer.config && layer.config.name) {
                                 name = layer.config.name;
                                 remove = true;
                             }
                             const value = values.map(name, type);
-                            const argument = new keras.Argument(name, true, [value]);
-                            this._inputs.push(argument);
+                            const argument = new keras.Argument(name, [value]);
+                            this.inputs.push(argument);
                             if (remove) {
                                 continue;
                             }
                         }
                         const nodeInputs = [{
                             name
                         }];
@@ -630,21 +613,21 @@
                             if (outputs && outputs.length > 0) {
                                 nodeOutputs = [outputs[0]];
                                 name = null;
                             }
                         }
                         layer.inputs = nodeInputs;
                         layer.outputs = nodeOutputs;
-                        const node = new keras.Node(this._metadata, layer, group, weights, values);
+                        const node = new keras.Node(metadata, layer, group, weights, values);
                         this.nodes.push(node);
                     }
                     if (name) {
                         const value = values.map(name);
-                        const argument = new keras.Argument(name, true, [value]);
-                        this._outputs.push(argument);
+                        const argument = new keras.Argument(name, [value]);
+                        this.outputs.push(argument);
                     }
                     break;
                 }
                 case 'YOLOV8Backbone':
                 case 'YOLOV8Detector':
                 case '__Function__':
                 case 'Functional':
@@ -819,15 +802,15 @@
                                             }];
                                             delete config.config.layers[0].inbound_nodes;
                                             delete config.config.layers[0].input_layers;
                                             delete config.config.layers[0].output_layers;
                                             break;
                                         }
                                     }
-                                    const type = new keras.Graph(this._metadata, config, weights, '');
+                                    const type = new keras.Graph(metadata, config, weights, '');
                                     for (let i = 0; i < layer.inbound_nodes.length; i++) {
                                         const index = i + first_index;
                                         const key = `${layer.name}[${index}]`;
                                         const node = {};
                                         node.name = key;
                                         node.class_name = '__Function__';
                                         node.config = {};
@@ -856,40 +839,40 @@
                                     let type = null;
                                     if (node && node.class_name === 'InputLayer') {
                                         type = getInputType(node);
                                         nodes.delete(name);
                                         nodes.delete(inbound_node_key);
                                     }
                                     const value = values.map(name, type);
-                                    const argument = new keras.Argument(node_name, true, [value]);
-                                    this._inputs.push(argument);
+                                    const argument = new keras.Argument(node_name, [value]);
+                                    this.inputs.push(argument);
                                 }
                             }
                             if (Array.isArray(config.output_layers)) {
                                 for (let i = 0; i < config.output_layers.length; i++) {
                                     const output_data = config.output_layers[i];
                                     const [name] = output_data;
                                     const key = read_connection(output_data);
                                     const value = values.map(key);
-                                    const argument = new keras.Argument(name, true, [value]);
-                                    this._outputs.push(argument);
+                                    const argument = new keras.Argument(name, [value]);
+                                    this.outputs.push(argument);
                                 }
                             }
                         } else {
                             for (const layer of config.layers) {
                                 layer.inputs = [];
                                 layer.outputs = [];
                                 layer.args = {};
                                 nodes.set(`${layer.name}[0]`, layer);
                             }
                         }
                     }
                     for (const entry of nodes) {
-                        const node = new keras.Node(this._metadata, entry[1], group, weights, values);
-                        this._nodes.push(node);
+                        const node = new keras.Node(metadata, entry[1], group, weights, values);
+                        this.nodes.push(node);
                     }
                     break;
                 }
                 default: {
                     throw new keras.Error(`'${config.class_name}' is not supported.`);
                 }
             }
@@ -899,55 +882,28 @@
                     const layer = {
                         class_name: 'Weights',
                         config: {
                             name
                         }
                     };
                     const node = new keras.Node(metadata, layer, '', weights, values);
-                    this._nodes.push(node);
+                    this.nodes.push(node);
                 }
             }
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
 };
 
 keras.Argument = class {
 
-    constructor(name, visible, value) {
-        this._name = name;
-        this._visible = visible;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get visible() {
-        return this._visible;
-    }
-
-    get value() {
-        return this._value;
+    constructor(name, value, type, visible) {
+        this.name = name;
+        this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 keras.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
@@ -964,90 +920,90 @@
 
     constructor(metadata, layer, group, weights, values) {
         const config = layer.config || {};
         const args = layer.args || {};
         let inputs = layer.inputs || [];
         let outputs = layer.outputs || [];
         const name = config && config.name ? config.name : '';
-        this._group = group || '';
-        this._name = (this._group ? `${this._group}/` : '') + name;
-        this._inputs = [];
-        this._outputs = [];
-        this._attributes = [];
-        this._chain = [];
+        this.group = group || '';
+        this.name = (this.group ? `${this.group}/` : '') + name;
+        this.inputs = [];
+        this.outputs = [];
+        this.attributes = [];
+        this.chain = [];
         let names = [name];
         let class_name = layer.class_name;
         let model = false;
         switch (class_name) {
             case '__Function__': {
-                this._type = layer.__type__;
+                this.type = layer.__type__;
                 model = true;
                 break;
             }
             case 'Model':
             case 'Functional':
             case 'Sequential': {
                 const name = layer.name || (layer.config ? layer.config.name : '');
-                this._type = new keras.Graph(metadata, layer, weights, (group ? `${group}/` : '') + name);
+                this.type = new keras.Graph(metadata, layer, weights, (group ? `${group}/` : '') + name);
                 model = true;
                 if (config) {
                     delete config.layers;
                     delete config.input_layers;
                     delete config.output_layers;
                 }
-                this._inputs = [new keras.Argument('inputs', true, inputs.map((input) => values.map(input.name)))];
-                this._outputs = [new keras.Argument('outputs', true, outputs.map((name) => values.map(name)))];
+                this.inputs = [new keras.Argument('inputs', inputs.map((input) => values.map(input.name)))];
+                this.outputs = [new keras.Argument('outputs', outputs.map((name) => values.map(name)))];
                 inputs = [];
                 outputs = [];
                 break;
             }
             case 'Wrapper':
             case 'Bidirectional':
             case 'TimeDistributed': {
                 if (config && config.layer) {
                     const inner = config.layer;
                     delete config.layer;
-                    this._inner = new keras.Node(metadata, inner, null, null, values);
+                    this.inner = new keras.Node(metadata, inner, null, null, values);
                     if (class_name === 'Bidirectional' && inner.config.name) {
                         names = [`${name}/forward_${inner.config.name}`, `${name}/backward_${inner.config.name}`];
                         if (!group) {
                             group = name;
                         }
                     }
                 }
-                this._type = metadata.type(class_name) || {
+                this.type = metadata.type(class_name) || {
                     name: class_name
                 };
                 break;
             }
             case 'TFOpLambda': {
                 if (config && config.function) {
                     class_name = config.function;
                     delete config.function;
                 }
-                this._type = metadata.type(class_name) || {
+                this.type = metadata.type(class_name) || {
                     name: class_name
                 };
                 break;
             }
             default: {
-                this._type = metadata.type(class_name) || {
+                this.type = metadata.type(class_name) || {
                     name: class_name
                 };
                 break;
             }
         }
 
         if (layer._trainable_variables) {
-            if (inputs.length === 0 && Array.isArray(this._type.inputs) && this._type.inputs.length > 0) {
+            if (inputs.length === 0 && Array.isArray(this.type.inputs) && this.type.inputs.length > 0) {
                 // weights-only, remove 'input' from type metadata
-                this._type = {
-                    ...this._type
+                this.type = {
+                    ...this.type
                 };
-                this._type.inputs = this._type.inputs.slice(1);
+                this.type.inputs = this.type.inputs.slice(1);
             }
             for (const variable of layer._trainable_variables) {
                 inputs.push({
                     name: '',
                     initializer: variable
                 });
             }
@@ -1069,14 +1025,33 @@
                             initializer
                         });
                     }
                 }
             }
         }
 
+        const attributes = [];
+
+        const convertAttributeValue = (value) => {
+            if (Array.isArray(value) || value !== Object(value)) {
+                return value;
+            }
+            const obj = {};
+            if (value.class_name) {
+                obj.__type__ = value.class_name;
+            }
+            if (value.config) {
+                const config = value.config;
+                for (const [key, value] of Object.entries(config)) {
+                    obj[key] = convertAttributeValue(value);
+                }
+            }
+            return obj;
+        };
+
         if (config && !Array.isArray(config)) {
             for (const [name, value] of Object.entries(config)) {
                 if (class_name !== 'Activation' && name === 'activation' && value !== 'linear') {
                     if (typeof value === 'string') {
                         const config = {
                             activation: value
                         };
@@ -1094,37 +1069,37 @@
                             });
                         }
                         const node = new keras.Node(metadata, value, null, null, value);
                         this.chain.push(node);
                     }
                 }
                 if (name !== 'name' && name !== 'batch_input_shape') {
-                    const attribute = new keras.Attribute(metadata.attribute(class_name, name), name, value);
-                    this._attributes.push(attribute);
+                    const schema = metadata.attribute(class_name, name);
+                    attributes.push([schema, name, value]);
                 }
             }
         }
 
         const innerType = this.inner ? this.inner.type : null;
         const innerMetadata = innerType ? metadata.type(innerType) : null;
         let inputIndex = 0;
         while (inputs.length > 0) {
             let list = false;
             let name = null;
             let visible = true;
             if (!innerMetadata || inputIndex === 0) {
-                if (this._type && this._type.inputs && inputIndex < this._type.inputs.length) {
-                    const input = this._type.inputs[inputIndex];
+                if (this.type && this.type.inputs && inputIndex < this.type.inputs.length) {
+                    const input = this.type.inputs[inputIndex];
                     name = input.name;
                     if (class_name === 'BatchNormalization' && name === 'gamma' && config.scale === false) {
                         inputIndex++;
                         continue;
                     }
                     visible = input.visible !== false;
-                    if (this._type.inputs[inputIndex].list) {
+                    if (this.type.inputs[inputIndex].list) {
                         list = true;
                     }
                 }
             } else {
                 switch (class_name) {
                     case 'Bidirectional': {
                         let innerIndex = inputIndex;
@@ -1171,163 +1146,99 @@
                     const parts = inputArguments[0].initializer.name.split('/').pop().split(':').shift().split('_');
                     const inputName1 = parts.pop();
                     const inputName2 = parts.length > 0 ? [parts.pop(), inputName1].join('_') : '';
                     const inputNames = new Set(['recurrent_kernel', 'running_mean', 'running_std', 'moving_mean', 'moving_variance', 'depthwise_filter', 'pointwise_filter']);
                     name = inputNames.has(inputName2) ? inputName2 : inputName1;
                 }
             }
-            const argument = new keras.Argument(name || inputIndex.toString(), visible, inputArguments);
-            this._inputs.push(argument);
+            const argument = new keras.Argument(name || inputIndex.toString(), inputArguments, null, visible);
+            this.inputs.push(argument);
             inputIndex++;
         }
 
         for (let i = 0; i < outputs.length; i++) {
             const output = outputs[i];
-            const name = this._type && this._type.outputs && i < this._type.outputs.length && this._type.outputs[i] && this._type.outputs[i].name ? this._type.outputs[i].name : i.toString();
-            const argument = new keras.Argument(name, true, output === undefined || output.length === 0 ? [] : [values.map(output)]);
-            this._outputs.push(argument);
+            const name = this.type && this.type.outputs && i < this.type.outputs.length && this.type.outputs[i] && this.type.outputs[i].name ? this.type.outputs[i].name : i.toString();
+            const argument = new keras.Argument(name, output === undefined || output.length === 0 ? [] : [values.map(output)]);
+            this.outputs.push(argument);
         }
 
-        const inputTypes = new Map((this._type.inputs || []).map((input) => [input.name, input.type]));
+        const inputTypes = new Map((this.type.inputs || []).map((input) => [input.name, input.type]));
         for (const [name, arg] of Object.entries(args)) {
             if (name !== 'name') {
                 if ((arg && arg.name) || (inputTypes.has(name) && inputTypes.get(name) === 'Tensor' && arg)) {
                     if (arg.name) {
                         const value = values.map(arg.name);
-                        const argument = new keras.Argument(name, true, [value]);
-                        this._inputs.push(argument);
+                        const argument = new keras.Argument(name, [value]);
+                        this.inputs.push(argument);
                     } else {
                         const tensor = new keras.Tensor('', arg.shape, config.dtype || '?', null, null, '|', arg.value);
                         const value = values.map('', null, tensor);
-                        const argument = new keras.Argument(name, true, [value]);
-                        this._inputs.push(argument);
+                        const argument = new keras.Argument(name, [value]);
+                        this.inputs.push(argument);
                     }
                 } else {
-                    const attribute = new keras.Attribute(metadata.attribute(class_name, name), name, arg);
-                    this._attributes.push(attribute);
+                    const schema = metadata.attribute(class_name, name);
+                    this.attributes.push([schema, name, arg]);
                 }
             }
         }
 
-        if (typeof this.type.name !== 'string' || !this.type.name.split) { // #416
-            throw new keras.Error(`Unsupported node type '${JSON.stringify(this.type.name)}'.`);
-        }
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-
-    get chain() {
-        return this._chain;
-    }
-
-    get inner() {
-        return this._inner;
-    }
-};
-
-keras.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this._name = name;
-        this._value = value;
-        if (value && typeof value === 'object' && value.class_name && value.config) {
-            this._value = keras.Attribute._convert(value);
-        }
-        switch (name) {
-            case 'trainable':
-                this._type = 'boolean';
-                this._visible = false;
-                break;
-            case 'dtype':
-                this._visible = false;
-                break;
-            default: {
-                if (metadata) {
-                    if (metadata.type) {
-                        this._type = metadata.type;
-                    }
-                    if (metadata.visible === false) {
-                        this._visible = false;
-                    } else if (metadata.default !== undefined) {
-                        if (Array.isArray(value)) {
-                            if (Array.isArray(metadata.default)) {
-                                this._visible = value.length !== metadata.default || !this.value.every((item, index) => item === metadata.default[index]);
+        this.attributes = attributes.map(([metadata, name, value]) => {
+            let type = null;
+            let visible = true;
+            if (value && typeof value === 'object' && value.class_name && value.config) {
+                value = convertAttributeValue(value);
+            }
+            switch (name) {
+                case 'trainable':
+                    type = 'boolean';
+                    visible = false;
+                    break;
+                case 'dtype':
+                    visible = false;
+                    break;
+                default: {
+                    if (metadata) {
+                        type = metadata.type ? metadata.type : type;
+                        if (metadata.visible === false) {
+                            visible = false;
+                        } else if (metadata.default !== undefined) {
+                            if (Array.isArray(value)) {
+                                if (Array.isArray(metadata.default)) {
+                                    visible = value.length !== metadata.default || !value.every((item, index) => item === metadata.default[index]);
+                                } else {
+                                    visible = !value.every((item) => item === metadata.default);
+                                }
                             } else {
-                                this._visible = !this.value.every((item) => item === metadata.default);
+                                visible = value !== metadata.default;
                             }
-                        } else {
-                            this._visible = this.value !== metadata.default;
                         }
                     }
+                    break;
                 }
-                break;
             }
-        }
-    }
-
-    get name() {
-        return this._name;
-    }
+            return new keras.Argument(name, value, type, visible);
+        });
 
-    get type() {
-        return this._type;
-    }
-
-    get value() {
-        return this._value;
-    }
-
-    get visible() {
-        return this._visible !== false;
-    }
-
-    static _convert(value) {
-        if (Array.isArray(value) || value !== Object(value)) {
-            return value;
-        }
-        const obj = {};
-        if (value.class_name) {
-            obj.__type__ = value.class_name;
-        }
-        if (value.config) {
-            const config = value.config;
-            for (const [key, value] of Object.entries(config)) {
-                obj[key] = keras.Attribute._convert(value);
-            }
+        if (typeof this.type.name !== 'string' || !this.type.name.split) { // #416
+            throw new keras.Error(`Unsupported node type '${JSON.stringify(this.type.name)}'.`);
         }
-        return obj;
     }
 };
 
 keras.Tensor = class {
 
-    constructor(name, shape, type, stride, quantization, encoding, data) {
+    constructor(name, shape, type, stride, quantization, encoding, data, location) {
         this.name = name;
         this.type = new keras.TensorType(type, new keras.TensorShape(shape));
         this.stride = stride;
         this.encoding = encoding;
         this._data = data;
+        this.location = location;
         if (quantization && (quantization.scale !== 0 || quantization.min !== 0)) {
             this.quantization = {
                 type: 'linear',
                 scale: [quantization.scale],
                 min: [quantization.min]
             };
         }
@@ -1343,43 +1254,31 @@
         return this._data instanceof Uint8Array ? this._data : this._data.peek();
     }
 };
 
 keras.TensorType = class {
 
     constructor(dataType, shape) {
-        this._dataType = dataType;
-        this._shape = shape;
-    }
-
-    get dataType() {
-        return this._dataType;
-    }
-
-    get shape() {
-        return this._shape;
+        this.dataType = dataType;
+        this.shape = shape;
     }
 
     toString() {
-        return this._dataType + this._shape.toString();
+        return this.dataType + this.shape.toString();
     }
 };
 
 keras.TensorShape = class {
 
     constructor(dimensions) {
-        this._dimensions = dimensions;
-    }
-
-    get dimensions() {
-        return this._dimensions;
+        this.dimensions = dimensions;
     }
 
     toString() {
-        return this._dimensions && this._dimensions.length > 0 ? (`[${this._dimensions.map((dimension) => dimension.toString()).join(',')}]`) : '';
+        return this.dimensions && this.dimensions.length > 0 ? (`[${this.dimensions.map((dimension) => dimension.toString()).join(',')}]`) : '';
     }
 };
 
 keras.GraphMetadata = class {
 
     constructor(metadata) {
         this._metadata = metadata;
@@ -1476,71 +1375,51 @@
                 return new tfjs.Container(context, 'metadata');
             }
         }
         return null;
     }
 
     constructor(context, type) {
-        this._context = context;
-        this._type = type;
-    }
-
-    get format() {
-        return this._format;
-    }
-
-    get producer() {
-        return this._producer || '';
-    }
-
-    get backend() {
-        return this._backend || '';
-    }
-
-    get config() {
-        return this._config;
-    }
-
-    get weights() {
-        return this._weights;
+        this.context = context;
+        this.type = type;
     }
 
     async open() {
-        switch (this._type) {
+        switch (this.type) {
             case '': {
-                const obj = this._context.peek('json');
+                const obj = this.context.peek('json');
                 return this._openModelJson(obj);
             }
             case 'weights': {
-                this._format = 'TensorFlow.js Weights';
-                this._config = null;
-                const obj = this._context.peek('json');
+                this.format = 'TensorFlow.js Weights';
+                this.config = null;
+                const obj = this.context.peek('json');
                 const manifests = Array.from(obj);
                 for (const manifest of manifests) {
                     for (const weight of manifest.weights) {
                         const name = weight.name;
                         const index = name.lastIndexOf('/');
                         weight.identifier = index === -1 ? name : name.substring(0, index);
                     }
                 }
                 return this._openManifests(manifests);
             }
             case 'metadata': {
-                const content = await this._context.fetch('model.json');
+                const content = await this.context.fetch('model.json');
                 const obj = content.read('json');
                 return this._openModelJson(obj);
             }
             default: {
-                throw new tfjs.Error(`Unsupported TensorFlow.js format '${this._type}'.`);
+                throw new tfjs.Error(`Unsupported TensorFlow.js format '${this.type}'.`);
             }
         }
     }
 
     _openShards(manifests, shards) {
-        this._weights = new keras.Weights();
+        this.weights = new keras.Weights();
         const dtype_size_map = new Map([
             ['float16', 2],
             ['float32', 4],
             ['float64', 8],
             ['int8', 1],
             ['int16', 2],
             ['int32', 4],
@@ -1548,16 +1427,18 @@
             ['uint8', 1],
             ['uint16', 2],
             ['uint32', 4],
             ['uint64', 8]
         ]);
         for (const manifest of manifests) {
             let buffer = null;
+            let location = '';
             if (Array.isArray(manifest.paths) && manifest.paths.length > 0 && manifest.paths.every((path) => shards.has(path))) {
                 const list = manifest.paths.map((path) => shards.get(path));
+                location = manifest.paths.join(', ');
                 const size = list.reduce((a, b) => a + b.length, 0);
                 buffer = new Uint8Array(size);
                 let offset = 0;
                 for (const item of list) {
                     buffer.set(item, offset);
                     offset += item.length;
                 }
@@ -1568,26 +1449,27 @@
                 if (!dtype_size_map.has(dtype)) {
                     throw new keras.Error(`Unsupported weight data type size '${dtype}'.`);
                 }
                 const itemsize = dtype_size_map.get(dtype);
                 const size = weight.shape.reduce((a, b) => a * b, 1);
                 const length = itemsize * size;
                 const data = buffer ? buffer.slice(offset, offset + length) : null;
-                this._weights.add(weight.identifier, new keras.Tensor(weight.name, weight.shape, dtype, null, weight.quantization, '<', data));
+                const tensor = new keras.Tensor(weight.name, weight.shape, dtype, null, weight.quantization, '<', data, location);
+                this.weights.add(weight.identifier, tensor);
                 offset += length;
             }
         }
     }
 
     async _openManifests(manifests) {
         const shards = new Map();
         for (const manifest of manifests) {
             for (const path of manifest.paths) {
                 if (!shards.has(path)) {
-                    const promise = this._context.fetch(path);
+                    const promise = this.context.fetch(path);
                     shards.set(path, promise);
                 }
             }
         }
         const promises = shards.values();
         try {
             const contexts = await Promise.all(promises);
@@ -1601,24 +1483,24 @@
             shards.clear();
             this._openShards(manifests, shards);
         }
     }
 
     _openModelJson(obj) {
         const modelTopology = obj.modelTopology;
-        this._format = `TensorFlow.js ${obj.format ? obj.format : `Keras${modelTopology.keras_version ? (` v${modelTopology.keras_version}`) : ''}`}`;
-        this._producer = obj.convertedBy || obj.generatedBy || '';
-        this._backend = modelTopology.backend || '';
+        this.format = `TensorFlow.js ${obj.format ? obj.format : `Keras${modelTopology.keras_version ? (` v${modelTopology.keras_version}`) : ''}`}`;
+        this.producer = obj.convertedBy || obj.generatedBy || '';
+        this.backend = modelTopology.backend || '';
         const manifests = obj.weightsManifest;
         for (const manifest of manifests) {
             for (const weight of manifest.weights) {
                 weight.identifier = '';
             }
         }
-        this._config = modelTopology.model_config ? modelTopology.model_config : modelTopology;
+        this.config = modelTopology.model_config ? modelTopology.model_config : modelTopology;
         return this._openManifests(manifests);
     }
 };
 
 tfjs.Error = class extends Error {
 
     constructor(message) {
```

## netron/kmodel.js

### js-beautify {}

```diff
@@ -190,27 +190,27 @@
         this.values = data;
     }
 };
 
 kmodel.Node = class {
 
     constructor(layer, value) {
-        this.location = layer.location === undefined ? layer.location : layer.location.toString();
+        this.identifier = layer.location === undefined ? layer.location : layer.location.toString();
         this.name = '';
         this.type = layer.type;
         this.inputs = [];
         this.outputs = [];
         this.chain = [];
         this.attributes = [];
         this.chain = [];
         for (const [name, value] of Object.entries(layer)) {
             if (name === 'type' || name === 'location' || name === 'inputs' || name === 'outputs' || name === 'chain') {
                 continue;
             }
-            const attribute = new kmodel.Attribute(name, value);
+            const attribute = new kmodel.Argument(name, value);
             this.attributes.push(attribute);
         }
         for (const input of layer.inputs || []) {
             const values = input.value.map((arg) => value(arg));
             const argument = new kmodel.Argument(input.name, values);
             this.inputs.push(argument);
         }
@@ -222,22 +222,14 @@
         for (const chain of layer.chain || []) {
             const node = new kmodel.Node(chain, value);
             this.chain.push(node);
         }
     }
 };
 
-kmodel.Attribute = class {
-
-    constructor(name, value) {
-        this.name = name;
-        this.value = value;
-    }
-};
-
 kmodel.Reader = class {
 
     static open(stream) {
         if (stream && stream.length >= 4) {
             const length = Math.min(8, stream.length);
             const buffer = stream.peek(length);
             if ([0x03, 0x00, 0x00, 0x00].every((value, index) => value === buffer[index])) {
```

## netron/lasagne.js

### js-beautify {}

```diff
@@ -69,17 +69,18 @@
             this.outputs.push(new lasagne.Argument(output_layer.name, [values.map(output_layer.name)]));
         }
     }
 };
 
 lasagne.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
     }
 };
 
 lasagne.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
@@ -107,15 +108,16 @@
             if (key === 'name' || key === 'params' || key === 'input_layer' || key === 'input_shape') {
                 continue;
             }
             if (value && value.__class__ && value.__class__.__module__ === 'theano.tensor.sharedvar' && value.__class__.__name__ === 'TensorSharedVariable') {
                 params.set(value.name, key);
                 continue;
             }
-            const attribute = new lasagne.Attribute(null, key, value);
+            const type = value && value.__class__ ? `${value.__class__.__module__}.${value.__class__.__name__}` : null;
+            const attribute = new lasagne.Argument(key, value, type);
             this.attributes.push(attribute);
         }
         if (layer.input_layer && layer.input_layer.name) {
             const value = values.map(layer.input_layer.name);
             const argument = new lasagne.Argument('input', [value]);
             this.inputs.push(argument);
         }
@@ -129,25 +131,14 @@
                 }
             }
         }
         this.outputs.push(new lasagne.Argument('output', [values.map(this.name)]));
     }
 };
 
-lasagne.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this.name = name;
-        this.value = value;
-        if (value && value.__class__) {
-            this.type = `${value.__class__.__module__}.${value.__class__.__name__}`;
-        }
-    }
-};
-
 lasagne.TensorType = class {
 
     constructor(dataType, shape) {
         this.dataType = dataType;
         this.shape = shape;
     }
```

## netron/lightgbm.js

### js-beautify {}

```diff
@@ -70,17 +70,18 @@
         const node = new lightgbm.Node(model, values);
         this.nodes.push(node);
     }
 };
 
 lightgbm.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
     }
 };
 
 lightgbm.Value = class {
 
     constructor(name) {
         if (typeof name !== 'string') {
@@ -119,40 +120,31 @@
                 const values = value.filter((obj) => !stack.has(obj));
                 const nodes = values.map((obj) => {
                     stack.add(obj);
                     const node = new lightgbm.Node(obj, null, stack);
                     stack.delete(obj);
                     return node;
                 });
-                const attribute = new lightgbm.Attribute('object[]', key, nodes);
+                const attribute = new lightgbm.Argument(key, nodes, 'object[]');
                 this.attributes.push(attribute);
                 continue;
             } else if (isObject(value) && !stack.has(value)) {
                 stack.add(obj);
                 const node = new lightgbm.Node(obj, null, stack);
                 stack.delete(obj);
-                const attribute = new lightgbm.Attribute('object', key, node);
+                const attribute = new lightgbm.Argument(key, node, 'object');
                 this.attributes.push(attribute);
             } else {
-                const attribute = new lightgbm.Attribute(null, key, value);
+                const attribute = new lightgbm.Argument(key, value);
                 this.attributes.push(attribute);
             }
         }
     }
 };
 
-lightgbm.Attribute = class {
-
-    constructor(type, name, value) {
-        this.type = type;
-        this.name = name;
-        this.value = value;
-    }
-};
-
 lightgbm.Error = class extends Error {
 
     constructor(message) {
         super(message);
         this.name = 'Error loading LightGBM model.';
     }
 };
```

## netron/megengine.js

### js-beautify {}

```diff
@@ -100,76 +100,14 @@
         };
         const loadGraph = (tmodule, igraph, context, namePrefix, metadata, isRoot) => {
             const expressions = igraph._exprs;
             const getTensorType = (dtype, shape) => {
                 dtype = dtype ? dtype.__name__ : null;
                 return new megengine.TensorType(dtype, new megengine.TensorShape(shape));
             };
-            const getOpNode = (metadata, item, expr, state) => {
-                const node = new megengine.Node(metadata, item);
-                let inpIdx = 0;
-                for (const i of expr.inputs) {
-                    if (i.__class__.__name__ !== 'ModuleNode') {
-                        const initializer = i.initializer === undefined ? null : i.initializer;
-                        const name = `input${inpIdx === 0 ? '' : inpIdx}`;
-                        const type = getTensorType(i._dtype, i._shape);
-                        const value = values.map(i._fullname, type, initializer);
-                        const argument = new megengine.Argument(name, [value]);
-                        node.inputs.push(argument);
-                        inpIdx += 1;
-                    }
-                }
-                let outIdx = 0;
-                let qparams = null;
-                for (const o of expr.outputs) {
-                    if (o._qparams !== null) {
-                        /* eslint-disable prefer-destructuring */
-                        qparams = o._qparams[1];
-                        /* eslint-enable prefer-destructuring */
-                    }
-                    const name = `output${outIdx === 0 ? '' : outIdx}`;
-                    const type = getTensorType(o._dtype, o._shape);
-                    const value = values.map(o._fullname, type, null);
-                    const argument = new megengine.Argument(name, [value]);
-                    node.outputs.push(argument);
-                    outIdx += 1;
-                }
-                if (qparams !== null) {
-                    state = state === null ? {} : state;
-                    state.scale = qparams.scale;
-                    state.zero_point = qparams.zero_point;
-                    state.quant_dtype_meta = qparams.dtype_meta;
-                }
-                if (state !== null) {
-                    for (const key in state) {
-                        const isModule = (obj) => {
-                            return obj && (obj.state || obj._forward_pre_hooks);
-                        };
-                        const isTensor = (obj) => {
-                            return obj && obj.__class__ && obj.__class__.__module__ === 'megengine.tensor' && (obj.__class__.__name__ === 'Tensor' || obj.__class__.__name__ === 'Parameter');
-                        };
-                        if (!key.startsWith('_') && !isModule(state[key])) {
-                            if (isTensor(state[key])) {
-                                const tensor = state[key];
-                                const type = getTensorType(tensor.dtype, tensor.data.shape);
-                                const data = tensor.data.data;
-                                const initializer = new megengine.Tensor(key, type, data);
-                                const value = values.map('', type, initializer);
-                                const argument = new megengine.Argument(key, [value]);
-                                node.inputs.push(argument);
-                            } else {
-                                const value = state[key] === null ? 'None' : state[key];
-                                const attribute = new megengine.Attribute(null, key, value);
-                                node.attributes.push(attribute);
-                            }
-                        }
-                    }
-                }
-                return node;
-            };
             if (isRoot) {
                 for (const node of igraph._inputs) {
                     if (node.__class__.__name__ !== 'ModuleNode') {
                         const type = getTensorType(node._dtype, node._shape);
                         const value = values.map(node._name, type, null);
                         const argument = new megengine.Argument(node._name, [value]);
                         this.inputs.push(argument);
@@ -347,15 +285,15 @@
                             }
                         } else {
                             obj.type = expression.method;
                             const [args, kwargs] = expression.arg_def.children_defs;
                             const schema = metadata.type(expression.method);
                             state = parseArgs(args, kwargs, schema);
                         }
-                        const node = getOpNode(metadata, obj, expression, state);
+                        const node = new megengine.Node(metadata, obj, values, null, expression, state);
                         this.nodes.push(node);
                         break;
                     }
                     case 'CallFunction': {
                         const getFunctionType = (obj) => {
                             if (obj.func.__module__ !== undefined) {
                                 return `${obj.func.__module__}.${obj.func.__name__}`;
@@ -366,25 +304,25 @@
                         const item = {
                             'name': '',
                             'type': func
                         };
                         const [args, kwargs] = expression.arg_def.children_defs;
                         const schema = metadata.type(func);
                         const state = parseArgs(args, kwargs, schema);
-                        const node = getOpNode(metadata, item, expression, state);
+                        const node = new megengine.Node(metadata, item, values, null, expression, state);
                         this.nodes.push(node);
                         break;
                     }
                     case 'Apply': {
                         const opdef = expression.opdef_state ? expression.opdef_state.opdef_type : expression.opdef.type;
                         const item = {
                             'name': '',
                             'type': `${opdef.__module__}.${opdef.__name__}`
                         };
-                        const node = getOpNode(metadata, item, expression, expression.opdef_state);
+                        const node = new megengine.Node(metadata, item, values, null, expression, expression.opdef_state);
                         this.nodes.push(node);
                         break;
                     }
                     default: {
                         break;
                     }
                 }
@@ -470,31 +408,33 @@
         };
         const allOprAndTensor = getAllOprAndTensor(obj.oprs);
         for (const op of Array.from(allOprAndTensor.values())) {
             if (op.type === 'Host2DeviceCopy') {
                 const argument = new megengine.Argument('input', op.extraInfo.args);
                 this.inputs.push(argument);
             } else if (op.type !== 'ImmutableTensor') {
-                this.nodes.push(new megengine.Node(metadata, op, allOprAndTensor));
+                this.nodes.push(new megengine.Node(metadata, op, values, allOprAndTensor));
             }
         }
         for (let i = 0; i < obj.output_vars_idx.length; i++) {
             const id = obj.output_vars_idx[i].compact_id;
             const out_type = `output${i === 0 ? '' : i}`;
             const argument = new megengine.Argument(out_type, allOprAndTensor.get(id).extraInfo.args);
             this.outputs.push(argument);
         }
     }
 };
 
 megengine.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 megengine.Value = class {
 
     constructor(name, type, initializer, quantization) {
         if (typeof name !== 'string') {
@@ -511,15 +451,15 @@
             };
         }
     }
 };
 
 megengine.Node = class {
 
-    constructor(metadata, obj, allOprAndTensor) {
+    constructor(metadata, obj, values, allOprAndTensor, expr, state) {
         this.name = '';
         const type = metadata.type(obj.type);
         this.type = type ? {
             ...type
         } : {
             name: obj.type
         };
@@ -527,64 +467,127 @@
         if (this.type.name.length > 4 && this.type.name.startsWith('__') && this.type.name.endsWith('__')) {
             this.type.name = this.type.name.substring(2, this.type.name.length - 2);
         }
         this.inputs = [];
         this.outputs = [];
         this.chain = [];
         this.attributes = [];
+        const attributes = [];
         if (obj.inputs && obj.outputs) {
             const inputSchemas = this.type && this.type.inputs ? [...this.type.inputs] : [];
             for (let i = 0; i < obj.inputs.length; i++) {
                 const inputOpr = allOprAndTensor.get(obj.inputs[i]);
-                const inputSchema = inputSchemas.length > 0 ? inputSchemas.shift() : {
+                const schema = inputSchemas.length > 0 ? inputSchemas.shift() : {
                     name: `input${i === 0 ? '' : i.toString()}`
                 };
-                const argument = new megengine.Argument(inputSchema.name, inputOpr.extraInfo.args);
+                const argument = new megengine.Argument(schema.name, inputOpr.extraInfo.args);
                 this.inputs.push(argument);
             }
             const outputSchemas = this.type && this.type.outputs ? [...this.type.outputs] : [];
             for (let i = 0; i < obj.outputs.length; i++) {
                 const outputOpr = allOprAndTensor.get(obj.outputs[i]);
-                const outputSchema = outputSchemas.length > 0 ? outputSchemas.shift() : {
+                const schema = outputSchemas.length > 0 ? outputSchemas.shift() : {
                     name: `output${i === 0 ? '' : i.toString()}`
                 };
-                const argument = new megengine.Argument(outputSchema.name, outputOpr.extraInfo.args);
+                const argument = new megengine.Argument(schema.name, outputOpr.extraInfo.args);
                 this.outputs.push(argument);
             }
             if (obj.param) {
                 for (const [name, value] of Object.entries(obj.param)) {
                     if (value !== null) {
-                        const attribute = new megengine.Attribute(metadata.attribute(obj.param.constructor.name, name), name, value);
-                        this.attributes.push(attribute);
+                        const schema = metadata.attribute(obj.param.constructor.name, name);
+                        attributes.push([schema, name, value]);
                     }
                 }
             }
         }
-    }
-};
-
-megengine.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this.type = metadata ? metadata.type : null;
-        this.name = name;
-        this.value = ArrayBuffer.isView(value) ? Array.from(value) : value;
-        if (this.name === 'training') {
-            this.visible = false;
-            this.type = 'boolean';
-        }
-        if (megengine.schema) {
-            if (megengine.schema.param[this.type]) {
-                this.value = megengine.Utility.enum(megengine.schema.param, this.type, this.value);
-            } else if (megengine.schema[this.type]) {
-                this.value = megengine.Utility.enum(megengine.schema, this.type, this.value);
-            } else if (megengine.schema.v2[this.type]) {
-                this.value = megengine.Utility.enum(megengine.schema.v2, this.type, this.value);
+        if (expr) {
+            let inpIdx = 0;
+            for (const i of expr.inputs) {
+                if (i.__class__.__name__ !== 'ModuleNode') {
+                    const initializer = i.initializer === undefined ? null : i.initializer;
+                    const name = `input${inpIdx === 0 ? '' : inpIdx}`;
+                    const dtype = i._dtype ? i._dtype.__name__ : null;
+                    const shape = new megengine.TensorShape(i._shape);
+                    const type = new megengine.TensorType(dtype, shape);
+                    const value = values.map(i._fullname, type, initializer);
+                    const argument = new megengine.Argument(name, [value]);
+                    this.inputs.push(argument);
+                    inpIdx += 1;
+                }
+            }
+            let outIdx = 0;
+            let qparams = null;
+            for (const o of expr.outputs) {
+                if (o._qparams !== null) {
+                    /* eslint-disable prefer-destructuring */
+                    qparams = o._qparams[1];
+                    /* eslint-enable prefer-destructuring */
+                }
+                const name = `output${outIdx === 0 ? '' : outIdx}`;
+                const dtype = o._dtype ? o._dtype.__name__ : null;
+                const shape = new megengine.TensorShape(o._shape);
+                const type = new megengine.TensorType(dtype, shape);
+                const value = values.map(o._fullname, type, null);
+                const argument = new megengine.Argument(name, [value]);
+                this.outputs.push(argument);
+                outIdx += 1;
+            }
+            if (qparams !== null) {
+                state = state === null ? {} : state;
+                state.scale = qparams.scale;
+                state.zero_point = qparams.zero_point;
+                state.quant_dtype_meta = qparams.dtype_meta;
+            }
+            if (state !== null) {
+                for (const key in state) {
+                    const isModule = (obj) => {
+                        return obj && (obj.state || obj._forward_pre_hooks);
+                    };
+                    const isTensor = (obj) => {
+                        return obj && obj.__class__ && obj.__class__.__module__ === 'megengine.tensor' && (obj.__class__.__name__ === 'Tensor' || obj.__class__.__name__ === 'Parameter');
+                    };
+                    if (!key.startsWith('_') && !isModule(state[key])) {
+                        if (isTensor(state[key])) {
+                            const tensor = state[key];
+                            const dtype = tensor.dtype ? tensor.dtype.__name__ : null;
+                            const shape = new megengine.TensorShape(tensor.data.shape);
+                            const type = new megengine.TensorType(dtype, shape);
+                            const data = tensor.data.data;
+                            const initializer = new megengine.Tensor(key, type, data);
+                            const value = values.map('', type, initializer);
+                            const argument = new megengine.Argument(key, [value]);
+                            this.inputs.push(argument);
+                        } else {
+                            const value = state[key] === null ? 'None' : state[key];
+                            attributes.push([null, key, value]);
+                        }
+                    }
+                }
             }
         }
+        this.attributes = attributes.map(([metadata, name, value]) => {
+            value = ArrayBuffer.isView(value) ? Array.from(value) : value;
+            let type = metadata ? metadata.type : null;
+            let visible = true;
+            if (name === 'training') {
+                visible = false;
+                type = 'boolean';
+            }
+            if (megengine.schema) {
+                if (megengine.schema.param[type]) {
+                    value = megengine.Utility.enum(megengine.schema.param, type, value);
+                } else if (megengine.schema[type]) {
+                    value = megengine.Utility.enum(megengine.schema, type, value);
+                } else if (megengine.schema.v2[type]) {
+                    value = megengine.Utility.enum(megengine.schema.v2, type, value);
+                }
+            }
+            return new megengine.Argument(name, value, type, visible);
+        });
     }
 };
 
 megengine.Tensor = class {
 
     constructor(name, type, data) {
         this.category = 'Tensor';
```

## netron/mlir.js

### js-beautify {}

```diff
@@ -220,17 +220,18 @@
             this.nodes.push(node);
         }
     }
 };
 
 mlir.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
     }
 };
 
 mlir.Value = class {
 
     constructor(name, type, description, initializer) {
         if (typeof name !== 'string') {
@@ -257,32 +258,22 @@
         }; // string (metadata.type(type) || { name: type }
         this.name = name || ''; // string
         this.description = description || ''; // string
         this.inputs = inputs || []; // [mlir.Parameter]
         this.outputs = outputs || []; // [mlir.Parameter]
         this.attributes = []; // [mlir.Attribute]
         if (attributes) {
-            for (const key of Object.keys(attributes)) {
-                const value = attributes[key];
-                const attribute = new mlir.Attribute(key, value);
+            for (const [name, value] of Object.entries(attributes)) {
+                const attribute = new mlir.Argument(name, value, 'string');
                 this.attributes.push(attribute);
             }
         }
     }
 };
 
-mlir.Attribute = class {
-
-    constructor(name, value) {
-        this.name = name;
-        this.type = 'string';
-        this.value = value;
-    }
-};
-
 mlir.Tensor = class {
 
     constructor(type, data) {
         this.type = type; // mlir.TensorType
         this.values = data;
         switch (this.type.dataType) {
             case 'float32':
```

## netron/mlnet.js

### js-beautify {}

```diff
@@ -111,17 +111,18 @@
             loadTransformer(scope, '', reader.transformerChain);
         }
     }
 };
 
 mlnet.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
     }
 };
 
 mlnet.Value = class {
 
     constructor(name, type) {
         if (typeof name !== 'string') {
@@ -158,51 +159,24 @@
             let i = 0;
             for (const output of transformer.outputs) {
                 const argument = new mlnet.Argument(i.toString(), [values.map(output.name)]);
                 this.outputs.push(argument);
                 i++;
             }
         }
-        for (const key of Object.keys(transformer).filter((key) => !key.startsWith('_') && key !== 'inputs' && key !== 'outputs')) {
-            const attribute = new mlnet.Attribute(metadata.attribute(type, this.name), key, transformer[key]);
-            this.attributes.push(attribute);
-        }
-    }
-};
-
-mlnet.Attribute = class {
-
-    constructor(schema, name, value) {
-        this.name = name;
-        this.value = value;
-        if (schema) {
-            if (schema.type) {
-                this.type = schema.type;
-            }
-            if (this.type) {
-                let type = mlnet;
-                const id = this.type.split('.');
-                while (type && id.length > 0) {
-                    type = type[id.shift()];
-                }
-                if (type) {
-                    mlnet.Attribute._reverseMap = mlnet.Attribute._reverseMap || {};
-                    let reverse = mlnet.Attribute._reverseMap[this.type];
-                    if (!reverse) {
-                        reverse = {};
-                        for (const key of Object.keys(type)) {
-                            reverse[type[key.toString()]] = key;
-                        }
-                        mlnet.Attribute._reverseMap[this.type] = reverse;
-                    }
-                    if (Object.prototype.hasOwnProperty.call(reverse, this.value)) {
-                        this.value = reverse[this.value];
-                    }
-                }
+        for (const [name, obj] of Object.entries(transformer).filter(([key]) => !key.startsWith('_') && key !== 'inputs' && key !== 'outputs')) {
+            const schema = metadata.attribute(transformer.__type__, name);
+            let value = obj;
+            let type = null;
+            if (schema) {
+                type = schema.type ? schema.type : null;
+                value = mlnet.Utility.enum(type, value);
             }
+            const attribute = new mlnet.Argument(name, value, type);
+            this.attributes.push(attribute);
         }
     }
 };
 
 mlnet.TensorType = class {
 
     constructor(codec) {
@@ -2308,14 +2282,41 @@
 
 mlnet.CdfColumnFunction = class {};
 
 mlnet.MultiClassNetPredictor = class {};
 
 mlnet.ProtonNNMCPred = class {};
 
+mlnet.Utility = class {
+
+    static enum(type, value) {
+        if (type) {
+            mlnet.Utility._enums = mlnet.Utility._enums || new Map();
+            if (!mlnet.Utility._enums.has(type)) {
+                let obj = mlnet;
+                const id = type.split('.');
+                while (obj && id.length > 0) {
+                    obj = obj[id.shift()];
+                }
+                if (obj) {
+                    const entries = new Map(Object.entries(obj).map(([key, value]) => [value, key]));
+                    mlnet.Utility._enums.set(type, entries);
+                } else {
+                    mlnet.Utility._enums.set(type, new Map());
+                }
+            }
+            const map = mlnet.Utility._enums.get(type);
+            if (map.has(value)) {
+                return map.get(value);
+            }
+        }
+        return value;
+    }
+};
+
 mlnet.Error = class extends Error {
 
     constructor(message) {
         super(message);
         this.name = 'Error loading ML.NET model.';
     }
 };
```

## netron/mnn.js

### js-beautify {}

```diff
@@ -184,20 +184,35 @@
                 delete param.slopeCount;
             } else if (param instanceof mnn.schema.Normalize) {
                 this._buildTensor('scale', mnn.schema.DataType.DT_FLOAT, [param.scale.length], param.scale);
                 delete param.scale;
             }
             while (parameters.length > 0) {
                 const parameter = parameters.shift();
-                for (const [key, value] of Object.entries(parameter)) {
-                    if (Object.keys(mnn.schema).find((key) => mnn.schema[key].prototype && value instanceof mnn.schema[key])) {
-                        parameters.push(value);
+                const node_type = type;
+                for (const [key, obj] of Object.entries(parameter)) {
+                    if (Object.keys(mnn.schema).find((key) => mnn.schema[key].prototype && obj instanceof mnn.schema[key])) {
+                        parameters.push(obj);
                         continue;
                     }
-                    const attribute = new mnn.Attribute(metadata.attribute(type, key), key, value);
+                    const schema = metadata.attribute(node_type, key);
+                    let value = ArrayBuffer.isView(obj) ? Array.from(obj) : obj;
+                    let type = null;
+                    if (schema && schema.type) {
+                        type = schema.type;
+                        switch (type) {
+                            case 'DataType':
+                                value = mnn.Utility.dataType(value);
+                                break;
+                            default:
+                                value = mnn.Utility.enum(type, value);
+                                break;
+                        }
+                    }
+                    const attribute = new mnn.Argument(key, value, type);
                     this.attributes.push(attribute);
                 }
             }
         }
     }
 
     _buildTensor(name, dataType, dimensions, value) {
@@ -205,40 +220,20 @@
         const type = new mnn.TensorType(dataType, shape);
         const tensor = new mnn.Tensor('Weight', type, value);
         const argument = new mnn.Argument(name, [new mnn.Value('', null, tensor)]);
         this.inputs.push(argument);
     }
 };
 
-mnn.Attribute = class {
-
-    constructor(metadata, name, value, visible) {
-        this.type = null;
-        this.value = ArrayBuffer.isView(value) ? Array.from(value) : value;
-        this.name = name;
-        this.visible = visible ? true : false;
-        if (metadata && metadata.type) {
-            this.type = metadata.type;
-            switch (this.type) {
-                case 'DataType':
-                    this.value = mnn.Utility.dataType(this.value);
-                    break;
-                default:
-                    this.value = mnn.Utility.enum(this.type, this.value);
-                    break;
-            }
-        }
-    }
-};
-
 mnn.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
     }
 };
 
 mnn.Value = class {
 
     constructor(name, type, initializer) {
         this.name = name;
```

## netron/modular.js

### js-beautify {}

```diff
@@ -14,137 +14,64 @@
         return new modular.Model(context.target);
     }
 };
 
 modular.Model = class {
 
     constructor(obj) {
-        this._graphs = obj.graphs.map((graph) => new modular.Graph(graph));
-    }
-
-    get format() {
-        return 'Modular';
-    }
-
-    get graphs() {
-        return this._graphs;
+        this.format = 'Modular';
+        this.graphs = obj.graphs.map((graph) => new modular.Graph(graph));
     }
 };
 
 modular.Graph = class {
 
     constructor(graph) {
-        this._nodes = Array.from(graph.nodes.map((node) => new modular.Node(node)));
-        this._inputs = [];
-        this._outputs = [];
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
+        this.nodes = Array.from(graph.nodes.map((node) => new modular.Node(node)));
+        this.inputs = [];
+        this.outputs = [];
     }
 };
 
 modular.Argument = class {
 
     constructor(name, value) {
-        this._name = name;
-        this._value = Array.from(value.map((value) => new modular.Value(value.toString(), name)));
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+        this.name = name;
+        this.value = value;
     }
 };
 
 modular.Value = class {
 
     constructor(name, value) {
         if (typeof name !== 'string') {
             throw new modular.Error(`Invalid value identifier '${JSON.stringify(name)}'.`);
         }
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+        this.name = name;
+        this.value = value;
     }
 };
 
 modular.Node = class {
 
     constructor(node) {
-        this._name = node.type.name;
+        this.name = '';
+        this.type = {
+            name: node.type.name
+        };
         if (node.type.category === 'List') {
-            this._category = 'Data';
+            this.type.category = 'Data';
         } else if (node.type.category === 'ControlFlow') {
-            this._category = 'Control';
+            this.type.category = 'Control';
         } else {
-            this._category = node.type.category;
+            this.type.category = node.type.category;
         }
-        this._type = {
-            name: this._name,
-            category: this._category
-        };
-        this._attributes = node.attributes ?
-            Array.from(node.attributes).map((attribute) => new modular.Attribute(attribute.name, attribute.value)) : [];
-        this._inputs = Array.from(node.inputs.map((input) => new modular.Argument(input.name, input.arguments)));
-        this._outputs = Array.from(node.outputs.map((output) => new modular.Argument(output.name, output.arguments)));
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-};
-
-modular.Attribute = class {
-
-    constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+        this.attributes = Array.isArray(node.attributes) ? Array.from(node.attributes).map((attribute) => new modular.Argument(attribute.name, attribute.value)) : [];
+        this.inputs = Array.from(node.inputs.map((input) => new modular.Argument(input.name, Array.from(input.arguments.map((value) => new modular.Value(value.toString(), input.name))))));
+        this.outputs = Array.from(node.outputs.map((output) => new modular.Argument(output.name, Array.from(output.arguments.map((value) => new modular.Value(value.toString(), output.name))))));
     }
 };
 
 modular.Error = class extends Error {
 
     constructor(message) {
         super(message);
```

## netron/mslite.js

### js-beautify {}

```diff
@@ -110,34 +110,43 @@
         this.attributes = [];
         this.inputs = [];
         this.outputs = [];
         const data = op.primitive.value;
         if (data && data.constructor) {
             const type = data.constructor.name;
             this.type = metadata.type(type);
-            this.attributes = Object.keys(data).map((key) => new mslite.Attribute(metadata.attribute(type, key), key.toString(), data[key]));
+            this.attributes = Object.entries(data).map(([key, obj]) => {
+                let value = ArrayBuffer.isView(obj) ? Array.from(obj) : obj;
+                let type = null;
+                const schema = metadata.attribute(this.type.name, key);
+                if (schema && schema.type) {
+                    type = schema.type;
+                    value = type ? mslite.Utility.enum(type, value) : value;
+                }
+                return new mslite.Argument(key.toString(), value, type);
+            });
         }
-
         const input_num = op.inputIndex.length;
         let i = 0;
         if (this.type && this.type.inputs) {
             for (const input of this.type.inputs) {
                 if (i >= input_num) {
                     break;
                 }
                 const index = op.inputIndex[i];
-                this.inputs.push(new mslite.Argument(input.name, [values[index]]));
+                const argument = new mslite.Argument(input.name, [values[index]]);
+                this.inputs.push(argument);
                 i += 1;
             }
         }
         for (let j = i; j < input_num; j++) {
             const index = op.inputIndex[j];
-            this.inputs.push(new mslite.Argument(j.toString(), [values[index]]));
+            const argument = new mslite.Argument(j.toString(), [values[index]]);
+            this.inputs.push(argument);
         }
-
         const output_num = op.outputIndex.length;
         i = 0;
         if (this.type && this.type.outputs) {
             for (const output of this.type.outputs) {
                 if (i >= output_num) {
                     break;
                 }
@@ -151,35 +160,20 @@
             const index = op.outputIndex[j];
             const argument = new mslite.Argument(j.toString(), [values[index]]);
             this.outputs.push(argument);
         }
     }
 };
 
-mslite.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this.type = null;
-        this.name = name;
-        this.visible = false;
-        this.value = ArrayBuffer.isView(value) ? Array.from(value) : value;
-        if (metadata && metadata.type) {
-            this.type = metadata.type;
-            if (this.type) {
-                this.value = mslite.Utility.enum(this.type, this.value);
-            }
-        }
-    }
-};
-
 mslite.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
     }
 };
 
 mslite.Value = class {
 
     constructor(name, tensor, initializer) {
         this.name = name;
```

## netron/mxnet.js

### js-beautify {}

```diff
@@ -250,70 +250,37 @@
             if (!Object.prototype.hasOwnProperty.call(symbol, 'arg_nodes')) {
                 throw new mxnet.Error('JSON file does not contain an MXNet \'arg_nodes\' property.');
             }
             if (!Object.prototype.hasOwnProperty.call(symbol, 'heads')) {
                 throw new mxnet.Error('JSON file does not contain an MXNet \'heads\' property.');
             }
         }
-        this._format = manifest.format || 'MXNet';
-        this._producer = manifest.producer || '';
-        this._name = manifest.name || '';
-        this._version = manifest.version;
-        this._description = manifest.description || '';
-        this._runtime = manifest.runtime || '';
-        this._metadata = [];
+        this.format = manifest.format || 'MXNet';
+        this.producer = manifest.producer || '';
+        this.name = manifest.name || '';
+        this.version = manifest.version;
+        this.description = manifest.description || '';
+        this.runtime = manifest.runtime || '';
+        this.metadata = [];
         if (manifest.author) {
-            this._metadata.push(new mxnet.Argument('author', manifest.author));
+            this.metadata.push(new mxnet.Argument('author', manifest.author));
         }
         if (manifest.license) {
-            this._metadata.push(new mxnet.Argument('license', manifest.license));
+            this.metadata.push(new mxnet.Argument('license', manifest.license));
         }
-        this._graphs = [new mxnet.Graph(metadata, manifest, symbol, params)];
-    }
-
-    get format() {
-        return this._format;
-    }
-
-    get producer() {
-        return this._producer;
-    }
-
-    get runtime() {
-        return this._runtime;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get version() {
-        return this._version;
-    }
-
-    get description() {
-        return this._description;
-    }
-
-    get metadata() {
-        return this._metadata;
-    }
-
-    get graphs() {
-        return this._graphs;
+        this.graphs = [new mxnet.Graph(metadata, manifest, symbol, params)];
     }
 };
 
 mxnet.Graph = class {
 
     constructor(metadata, manifest, symbol, params) {
-        this._metadata = metadata;
-        this._nodes = [];
-        this._inputs = [];
-        this._outputs = [];
+        this.nodes = [];
+        this.inputs = [];
+        this.outputs = [];
         const tensors = new Map();
         if (params) {
             for (const [name, value] of params) {
                 const shape = new mxnet.TensorShape(value.shape);
                 const type = new mxnet.TensorType(value.dtype, shape);
                 const tensor = new mxnet.Tensor(name, type, value.data);
                 tensors.set(name, tensor);
@@ -370,15 +337,15 @@
                 const head = symbol.heads[i];
                 const identifier = updateOutput(nodes, head);
                 const name = nodes[identifier[0]] ? nodes[identifier[0]].name : (`output${(i === 0) ? '' : (i + 1)}`);
                 const signature = outputs[name];
                 const type = signature && signature.data_shape ? new mxnet.TensorType(-1, new mxnet.TensorShape(signature.data_shape)) : null;
                 const value = values.map(`[${identifier.join(',')}]`, type);
                 const argument = new mxnet.Argument(name, [value]);
-                this._outputs.push(argument);
+                this.outputs.push(argument);
             }
             nodes = nodes.filter((node, index) => !arg_nodes.has(index));
             const initializers = new Map();
             for (const node of nodes) {
                 if (node.op === 'RNN') {
                     node.inputs = node.inputs.filter((input) => {
                         const [index] = input;
@@ -438,19 +405,19 @@
                 if (arg_node && (!arg_node.inputs || arg_node.inputs.length === 0) && (arg_node.outputs && arg_node.outputs.length === 1)) {
                     const identifier = `[${arg_node.outputs[0].join(',')}]`;
                     const name = arg_node.name;
                     const signature = inputs[name];
                     const type = signature && signature.data_shape ? new mxnet.TensorType(-1, new mxnet.TensorShape(signature.data_shape)) : null;
                     const value = values.map(identifier, type, tensors.get(identifier));
                     const argument = new mxnet.Argument(name, [value]);
-                    this._inputs.push(argument);
+                    this.inputs.push(argument);
                 }
             }
             for (const node of nodes) {
-                this._nodes.push(new mxnet.Node(this._metadata, node, initializers, values));
+                this.nodes.push(new mxnet.Node(metadata, node, initializers, values));
             }
         } else if (params) {
             const blocks = new Map();
             let separator = Array.from(params.keys()).every((key) => key.indexOf('_') !== -1) ? '_' : '';
             if (separator.length === 0) {
                 separator = Array.from(params.keys()).every((key) => key.indexOf('.') !== -1) ? '.' : '';
             }
@@ -476,377 +443,268 @@
                     values.map(key, null, tensors.get(key));
                 }
             } else {
                 throw new mxnet.Error("Unsupported key format in params.");
             }
 
             for (const block of blocks.values()) {
-                this._nodes.push(new mxnet.Node(metadata, block, new Map(), values));
+                this.nodes.push(new mxnet.Node(metadata, block, new Map(), values));
             }
         }
     }
-
-    get name() {
-        return '';
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
 };
 
 mxnet.Argument = class {
 
-    constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+    constructor(name, value, type, visible) {
+        this.name = name;
+        this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 mxnet.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
             throw new mxnet.Error(`Invalid value identifier '${JSON.stringify(name)}'.`);
         }
-        this._name = name;
-        this._type = type || null;
-        this._initializer = initializer || null;
-    }
-
-    get name() {
-        if (this._initializer) {
-            return this._initializer.name;
-        }
-        return this._name;
-    }
-
-    get type() {
-        if (this._initializer) {
-            return this._initializer.type;
-        }
-        return this._type;
-    }
-
-    get initializer() {
-        return this._initializer;
+        this.name = !name && initializer && initializer.name ? initializer.name : name;
+        this.type = !type && initializer && initializer.type ? initializer.type : type;
+        this.initializer = initializer || null;
     }
 };
 
 mxnet.Node = class {
 
     constructor(metadata, node, initializers, values) {
         let type = node.op;
-        this._name = node.name;
-        this._attributes = [];
-        this._inputs = [];
-        this._outputs = [];
+        this.name = node.name;
+        this.attributes = [];
+        this.inputs = [];
+        this.outputs = [];
         const attrs = node.attrs || node.attr || node.param;
         if (attrs) {
             if (type === 'tvm_op' && attrs.func_name) {
                 type = attrs.func_name;
             }
-            for (const [name, value] of Object.entries(attrs)) {
+            for (const [name, obj] of Object.entries(attrs)) {
                 if (type !== 'tvm_op' && name !== 'func_name') {
-                    const attribute = new mxnet.Attribute(metadata, type, name, value);
-                    this._attributes.push(attribute);
+                    let value = obj;
+                    let visible = true;
+                    const schema = metadata.attribute(type, name);
+                    if (schema && schema.type) {
+                        switch (schema.type) {
+                            case 'boolean':
+                                switch (value) {
+                                    case 0:
+                                    case '0':
+                                    case 'False':
+                                        value = false;
+                                        break;
+                                    case 1:
+                                    case '1':
+                                    case 'True':
+                                        value = true;
+                                        break;
+                                    default:
+                                        throw new mxnet.Error(`Unsupported attribute boolean value '${value}'.`);
+                                }
+                                break;
+                            case 'int32': {
+                                const number = Number.parseInt(value, 10);
+                                value = Number.isNaN(value - number) ? value : number;
+                                break;
+                            }
+                            case 'float32':
+                            case 'float64': {
+                                const number = Number.parseFloat(value);
+                                value = Number.isNaN(value - number) ? value : number;
+                                break;
+                            }
+                            case 'int32[]':
+                                if (value.length > 2 && value.startsWith('(') && value.endsWith(')')) {
+                                    let array = [];
+                                    const items = value.substring(1, value.length - 1).split(',')
+                                        .map((item) => item.trim())
+                                        .map((item) => item.endsWith('L') ? item.substring(0, item.length - 1) : item);
+                                    for (const item of items) {
+                                        const value = Number.parseInt(item, 10);
+                                        if (Number.isNaN(item - value)) {
+                                            array = null;
+                                        } else if (array !== null) {
+                                            array.push(value);
+                                        }
+                                    }
+                                    if (array !== null) {
+                                        value = array;
+                                    }
+                                }
+                                break;
+                            default:
+                                throw new mxnet.Error(`Unsupported attribute type '${metadata.type}'.`);
+                        }
+                    }
+                    if (metadata) {
+                        if (metadata.visible === false) {
+                            visible = false;
+                        } else if (metadata.default !== undefined) {
+                            let defaultValue = metadata.default;
+                            if (value === defaultValue) {
+                                visible = false;
+                            } else if (Array.isArray(value) && Array.isArray(defaultValue)) {
+                                defaultValue = defaultValue.slice(0, defaultValue.length);
+                                if (defaultValue.length > 1 && defaultValue[defaultValue.length - 1] === null) {
+                                    defaultValue.pop();
+                                    while (defaultValue.length < value.length) {
+                                        defaultValue.push(defaultValue[defaultValue.length - 1]);
+                                    }
+                                }
+                                if (value.every((item, index) => item === defaultValue[index])) {
+                                    visible = false;
+                                }
+                            }
+                        }
+                    }
+                    const attribute = new mxnet.Argument(name, value, type, visible);
+                    this.attributes.push(attribute);
                 }
             }
         }
-        this._type = metadata.type(type) || {
+        this.type = metadata.type(type) || {
             name: type
         };
         if (node.inputs) {
             const inputs = node.inputs;
             let inputIndex = 0;
-            if (this._type && this._type.inputs) {
-                for (const inputDef of this._type.inputs) {
+            if (this.type && this.type.inputs) {
+                for (const inputDef of this.type.inputs) {
                     if (inputIndex < inputs.length || inputDef.option !== 'optional') {
                         const count = (inputDef.option === 'variadic') ? (inputs.length - inputIndex) : 1;
                         const list = [];
                         for (const input of inputs.slice(inputIndex, inputIndex + count)) {
                             const identifier = `[${input.join(',')}]`;
                             if (identifier !== '' || inputDef.option !== 'optional') {
                                 const value = values.map(identifier, inputDef.type, initializers.get(identifier));
                                 list.push(value);
                             }
                         }
                         const argument = new mxnet.Argument(inputDef.name, list);
-                        this._inputs.push(argument);
+                        this.inputs.push(argument);
                         inputIndex += count;
                     }
                 }
             }
             if (inputIndex < inputs.length) {
-                this._inputs.push(...inputs.slice(inputIndex).map((input, index) => {
+                this.inputs.push(...inputs.slice(inputIndex).map((input, index) => {
                     const name = (inputIndex + index).toString();
                     const identifier = `[${input.join(',')}]`;
                     const value = values.map(identifier, null, initializers.get(identifier));
                     return new mxnet.Argument(name, [value]);
                 }));
             }
         }
         if (node.outputs) {
             const outputs = node.outputs;
             let outputIndex = 0;
-            if (this._type && this._type.outputs) {
-                for (const outputDef of this._type.outputs) {
+            if (this.type && this.type.outputs) {
+                for (const outputDef of this.type.outputs) {
                     if (outputIndex < outputs.length || outputDef.option !== 'optional') {
                         const list = [];
                         const count = (outputDef.option === 'variadic') ? (outputs.length - outputIndex) : 1;
                         for (const output of outputs.slice(outputIndex, outputIndex + count)) {
                             const value = values.map(`[${output.join(',')}]`);
                             list.push(value);
                         }
                         const argument = new mxnet.Argument(outputDef.name, list);
-                        this._outputs.push(argument);
+                        this.outputs.push(argument);
                         outputIndex += count;
                     }
                 }
             }
             if (outputIndex < outputs.length) {
-                this._outputs.push(...outputs.slice(outputIndex).map((output, index) => {
+                this.outputs.push(...outputs.slice(outputIndex).map((output, index) => {
                     const name = (outputIndex + index).toString();
                     const value = values.map(`[${output.join(',')}]`);
                     return new mxnet.Argument(name, [value]);
                 }));
             }
         }
         if (node.params) {
             for (const param of node.params) {
                 const value = values.map(param.id);
                 const argument = new mxnet.Argument(param.name, [value]);
-                this._inputs.push(argument);
+                this.inputs.push(argument);
             }
         }
     }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-};
-
-mxnet.Attribute = class {
-
-    constructor(metadata, type, name, value) {
-        this._name = name;
-        this._value = value;
-        metadata = metadata.attribute(type, name);
-        if (metadata && metadata.type) {
-            switch (metadata.type) {
-                case 'boolean':
-                    switch (value) {
-                        case 0:
-                        case '0':
-                        case 'False':
-                            this._value = false;
-                            break;
-                        case 1:
-                        case '1':
-                        case 'True':
-                            this._value = true;
-                            break;
-                        default:
-                            throw new mxnet.Error(`Unsupported attribute boolean value '${value}'.`);
-                    }
-                    break;
-                case 'int32': {
-                    const number = Number.parseInt(this._value, 10);
-                    this._value = Number.isNaN(this._value - number) ? value : number;
-                    break;
-                }
-                case 'float32':
-                case 'float64': {
-                    const number = Number.parseFloat(this._value);
-                    this._value = Number.isNaN(this._value - number) ? value : number;
-                    break;
-                }
-                case 'int32[]':
-                    if (this._value.length > 2 && this._value.startsWith('(') && this._value.endsWith(')')) {
-                        let array = [];
-                        const items = this._value.substring(1, this._value.length - 1).split(',')
-                            .map((item) => item.trim())
-                            .map((item) => item.endsWith('L') ? item.substring(0, item.length - 1) : item);
-                        for (const item of items) {
-                            const value = Number.parseInt(item, 10);
-                            if (Number.isNaN(item - value)) {
-                                array = null;
-                            } else if (array !== null) {
-                                array.push(value);
-                            }
-                        }
-                        if (array !== null) {
-                            this._value = array;
-                        }
-                    }
-                    break;
-                default:
-                    throw new mxnet.Error(`Unsupported attribute type '${metadata.type}'.`);
-            }
-        }
-        if (metadata) {
-            if (metadata.visible === false) {
-                this._visible = false;
-            } else if (metadata.default !== undefined) {
-                let defaultValue = metadata.default;
-                if (this._value === defaultValue) {
-                    this._visible = false;
-                } else if (Array.isArray(this._value) && Array.isArray(defaultValue)) {
-                    defaultValue = defaultValue.slice(0, defaultValue.length);
-                    if (defaultValue.length > 1 && defaultValue[defaultValue.length - 1] === null) {
-                        defaultValue.pop();
-                        while (defaultValue.length < this._value.length) {
-                            defaultValue.push(defaultValue[defaultValue.length - 1]);
-                        }
-                    }
-                    if (this._value.every((item, index) => item === defaultValue[index])) {
-                        this._visible = false;
-                    }
-                }
-            }
-        }
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get value() {
-        return this._value;
-    }
-
-    get visible() {
-        return this._visible !== false;
-    }
 };
 
 mxnet.Tensor = class {
 
     constructor(name, type, data) {
-        this._name = name;
-        this._type = type;
-        this._data = data;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get encoding() {
-        return '<';
-    }
-
-    get values() {
-        return this._data;
+        this.name = name;
+        this.type = type;
+        this.values = data;
+        this.encoding = '<';
     }
 };
 
 mxnet.TensorType = class {
 
     constructor(dataType, shape) {
         switch (dataType) {
             case 0:
-                this._dataType = 'float32';
+                this.dataType = 'float32';
                 break;
             case 1:
-                this._dataType = 'float64';
+                this.dataType = 'float64';
                 break;
             case 2:
-                this._dataType = 'float16';
+                this.dataType = 'float16';
                 break;
             case 3:
-                this._dataType = 'uint8';
+                this.dataType = 'uint8';
                 break;
             case 4:
-                this._dataType = 'int32';
+                this.dataType = 'int32';
                 break;
             case 5:
-                this._dataType = 'int8';
+                this.dataType = 'int8';
                 break;
             case 6:
-                this._dataType = 'int64';
+                this.dataType = 'int64';
                 break;
             case -1:
-                this._dataType = '?';
+                this.dataType = '?';
                 break;
             default:
                 throw new mxnet.Error(`Unsupported type '${dataType}'.`);
         }
-        this._shape = shape;
-    }
-
-    get dataType() {
-        return this._dataType;
-    }
-
-    get shape() {
-        return this._shape;
+        this.shape = shape;
     }
 
     toString() {
-        return this._dataType + this._shape.toString();
+        return this.dataType + this.shape.toString();
     }
 };
 
 mxnet.TensorShape = class {
 
     constructor(dimensions) {
-        this._dimensions = dimensions;
-    }
-
-    get dimensions() {
-        return this._dimensions;
+        this.dimensions = dimensions;
     }
 
     toString() {
-        if (this._dimensions) {
-            if (this._dimensions.length === 0) {
+        if (this.dimensions) {
+            if (this.dimensions.length === 0) {
                 return '';
             }
-            return `[${this._dimensions.map((dimension) => dimension.toString()).join(',')}]`;
+            return `[${this.dimensions.map((dimension) => dimension.toString()).join(',')}]`;
         }
         return '';
     }
 };
 
 mxnet.ndarray = class {
 
@@ -907,40 +765,49 @@
                 }
                 this.sshape = null;
                 if (num_aux_data > 0) {
                     this.sshape = reader.uint64s();
                 }
                 this.shape = reader.uint64s();
                 if (this.shape.length !== 0) {
-                    this.context = new mxnet.context.Context(reader);
+                    this.context = {
+                        deviceType: reader.uint32(),
+                        deviceId: reader.uint32()
+                    };
                     this.dtype = reader.uint32();
                     if (num_aux_data > 0) {
                         throw new mxnet.Error('Not implemented.');
                     }
                     const dataTypeSize = (this.dtype < mxnet.ndarray.NDArray._dataTypeSizeTable.length) ? mxnet.ndarray.NDArray._dataTypeSizeTable[this.dtype] : 0;
                     const size = dataTypeSize * this.size;
                     this.data = reader.read(size);
                 }
                 break;
             }
             case 0xf993fac8: { // NDARRAY_V1_MAGIC
                 this.shape = reader.uint64s();
                 if (this.shape.length !== 0) {
-                    this.context = new mxnet.context.Context(reader);
+                    this.context = {
+                        deviceType: reader.uint32(),
+                        deviceId: reader.uint32()
+                    };
                     this.dtype = reader.uint32();
                     const itemsize = (this.dtype < mxnet.ndarray.NDArray._dataTypeSizeTable.length) ? mxnet.ndarray.NDArray._dataTypeSizeTable[this.dtype] : 0;
                     const size = itemsize * this.size;
                     this.data = reader.read(size);
                 }
                 break;
             }
             default: {
                 reader.skip(-4);
                 this.shape = reader.uint32s();
-                this.context = new mxnet.context.Context(reader);
+                this.context = {
+                    deviceType: reader.uint32(),
+                    deviceId: reader.uint32()
+                };
                 this.dtype = reader.uint32();
                 const itemsize = (this.dtype < mxnet.ndarray.NDArray._dataTypeSizeTable.length) ? mxnet.ndarray.NDArray._dataTypeSizeTable[this.dtype] : 0;
                 const size = itemsize * this.size;
                 this.data = reader.read(size);
                 break;
             }
         }
@@ -988,24 +855,14 @@
         for (let i = 0; i < size; i++) {
             array[i] = this.uint64().toNumber();
         }
         return array;
     }
 };
 
-mxnet.context = {};
-
-mxnet.context.Context = class {
-
-    constructor(reader) {
-        this._deviceType = reader.uint32();
-        this._deviceId = reader.uint32();
-    }
-};
-
 mxnet.Error = class extends Error {
 
     constructor(message) {
         super(message);
         this.name = 'Error loading MXNet model.';
     }
 };
```

## netron/nnabla.js

### js-beautify {}

```diff
@@ -139,15 +139,26 @@
                 }
             }
             return undefined;
         };
         this.nodes = network.function.map((func) => {
             const parameters = get_parameters(func) || [];
             const attributes = Object.entries(parameters).map(([name, value]) => {
-                return new nnabla.Attribute(metadata, func.type, name, value);
+                const attribute = metadata.attribute(func.type, name);
+                let type = attribute.type;
+                switch (type) {
+                    case 'shape':
+                        type = "int64[]";
+                        value = value.dim;
+                        break;
+                    default:
+                        break;
+                }
+                const visible = attribute.default !== undefined && value === attribute.default ? false : true;
+                return new nnabla.Argument(name, value, type, visible);
             });
             const func_type = metadata.type(func.type);
             const inputs = [];
             for (let index = 0; index < func.input.length;) {
                 const input = func_type.inputs && index < func_type.inputs.length ? func_type.inputs[index] : {
                     name: index.toString()
                 };
@@ -171,44 +182,28 @@
             return new nnabla.Node(metadata, func, attributes, inputs, outputs);
         });
     }
 };
 
 nnabla.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 nnabla.Value = class {
 
     constructor(name, type, initializer) {
-        this._name = name;
-        this._type = type || null;
-        this._initializer = initializer || null;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        if (this._type) {
-            return this._type;
-        }
-        if (this._initializer) {
-            return this._initializer.type;
-        }
-        return null;
-    }
-
-    get initializer() {
-        return this._initializer;
+        this.name = name;
+        this.type = !type && initializer && initializer.type ? initializer.type : type;
+        this.initializer = initializer || null;
     }
 };
 
 nnabla.Node = class {
 
     constructor(metadata, func, attributes, inputs, outputs) {
         this.name = func.name;
@@ -281,50 +276,26 @@
                 this.inputs = inputs || [];
                 break;
             }
         }
     }
 };
 
-nnabla.Attribute = class {
-
-    constructor(metadata, type, name, value) {
-        this.name = name;
-        const attribute = metadata.attribute(type, name);
-        this.description = attribute.description;
-        switch (attribute.type) {
-            case "shape":
-                this.type = "int64[]";
-                this.value = value.dim;
-                break;
-            default:
-                this.type = attribute.type;
-                this.value = value;
-                break;
-        }
-        if (Object.prototype.hasOwnProperty.call(attribute, 'default') && this.value === attribute.default) {
-            this.visible = false;
-        }
-    }
-};
-
 nnabla.Tensor = class {
 
     constructor(name, type, values) {
         this.name = name;
         this.type = type;
         this.encoding = '|';
-        this._values = values;
-    }
-
-    get values() {
+        this.values = values;
         const dataType = this.type.dataType;
         switch (dataType) {
             case 'float32':
-                return new Float32Array(this._values);
+                this.values = new Float32Array(this.values);
+                break;
             default:
                 throw new nnabla.Error(`Unsupported data type '${dataType}'.`);
         }
     }
 };
 
 nnabla.TensorType = class {
```

## netron/numpy.js

### js-beautify {}

```diff
@@ -232,46 +232,28 @@
         this.initializer = initializer || null;
     }
 };
 
 numpy.Node = class {
 
     constructor(layer) {
-        this._name = layer.name || '';
-        this._type = {
+        this.name = layer.name || '';
+        this.type = {
             name: layer.type || 'Object'
         };
-        this._inputs = [];
+        this.inputs = [];
+        this.outputs = [];
+        this.attributes = [];
         for (const parameter of layer.parameters) {
             const initializer = new numpy.Tensor(parameter.tensor.array);
             const value = new numpy.Value(parameter.tensor.name || '', initializer);
             const argument = new numpy.Argument(parameter.name, [value]);
-            this._inputs.push(argument);
+            this.inputs.push(argument);
         }
     }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return [];
-    }
-
-    get attributes() {
-        return [];
-    }
 };
 
 numpy.Tensor = class {
 
     constructor(array) {
         this.type = new numpy.TensorType(array.dtype.__name__, new numpy.TensorShape(array.shape));
         this.stride = array.strides.map((stride) => stride / array.itemsize);
```

## netron/om.js

### js-beautify {}

```diff
@@ -146,130 +146,123 @@
                 const type = om.Utility.tensorType(op.output_desc[i]);
                 const name = this.type.outputs && i < this.type.outputs.length ? this.type.outputs[i].name : `output${i === 0 ? '' : i}`;
                 const value = values.map(identifier, type);
                 const argument = new om.Argument(name, [value]);
                 this.outputs.push(argument);
             }
         }
-        for (const [name, value] of Object.entries(op.attr || {})) {
+        for (const [name, obj] of Object.entries(op.attr || {})) {
             if (name === 'device') {
-                this.device = value;
+                this.device = obj;
                 continue;
             }
             if (name === 'original_op_names') {
                 continue;
             }
-            if (name === 'relu_flag' && value.b) {
-                this.chain.push(new om.Node(context, {
+            if (name === 'relu_flag' && obj.b) {
+                const node = new om.Node(context, {
                     type: 'ReLU'
-                }, graph, value));
+                }, graph, obj);
+                this.chain.push(node);
                 continue;
             }
-            const attribute = new om.Attribute(context, name, value);
-            this.attributes.push(attribute);
-        }
-    }
-};
-
-om.Attribute = class {
-
-    constructor(context, name, value) {
-        this.name = name;
-        this.value = value;
-        switch (value.value) {
-            case 'i': {
-                this.value = value.i;
-                this.type = 'int64';
-                break;
-            }
-            case 'f': {
-                this.value = value.f;
-                this.type = 'float32';
-                break;
-            }
-            case 'b': {
-                this.value = value.b;
-                this.type = 'boolean';
-                break;
-            }
-            case 'bt': {
-                this.value = null;
-                if (value.bt.length !== 0) {
-                    this.type = 'tensor';
-                    const shape = new om.TensorShape([value.bt.length / 4]);
-                    const type = new om.TensorType('float32', shape);
-                    this.value = new om.Tensor('Constant', type, value.bt);
+            let value = obj;
+            let type = null;
+            switch (obj.value) {
+                case 'i': {
+                    value = obj.i;
+                    type = 'int64';
+                    break;
                 }
-                break;
-            }
-            case 'dt': {
-                this.type = 'DataType';
-                this.value = om.Utility.dtype(Number(value.dt));
-                break;
-            }
-            case 's': {
-                if (typeof value.s === 'string') {
-                    this.value = value.s;
-                } else if (value.s.filter((c) => c <= 32 && c >= 128).length === 0) {
-                    this.value = om.Utility.decodeText(value.s);
-                } else {
-                    this.value = value.s;
+                case 'f': {
+                    value = obj.f;
+                    type = 'float32';
+                    break;
                 }
-                this.type = 'string';
-                break;
-            }
-            case 'g': {
-                this.type = 'graph';
-                this.value = new om.Graph(context, value.g);
-                break;
-            }
-            case 'func': {
-                break;
-            }
-            case 'list': {
-                const list = value.list;
-                this.value = [];
-                if (list.s && list.s.length > 0) {
-                    this.value = list.s.map((v) => String.fromCharCode.apply(null, new Uint16Array(v))).join(', ');
-                    this.type = 'string[]';
-                } else if (list.b && list.b.length > 0) {
-                    this.value = list.b;
-                    this.type = 'boolean[]';
-                } else if (list.i && list.i.length > 0) {
-                    this.value = list.i;
-                    this.type = 'int64[]';
-                } else if (list.f && list.f.length > 0) {
-                    this.value = list.f;
-                    this.type = 'float32[]';
-                } else if (list.type && list.type.length > 0) {
-                    this.type = 'type[]';
-                    this.value = list.type.map((type) => om.Node.enum2Dtype(type) || '?');
-                } else if (list.shape && list.shape.length > 0) {
-                    this.type = 'shape[]';
-                    this.value = list.shape.map((shape) => new om.TensorShape(shape));
+                case 'b': {
+                    value = obj.b;
+                    type = 'boolean';
+                    break;
+                }
+                case 'bt': {
+                    value = null;
+                    if (obj.bt.length !== 0) {
+                        type = 'tensor';
+                        const shape = new om.TensorShape([obj.bt.length / 4]);
+                        value = new om.Tensor('Constant', new om.TensorType('float32', shape), obj.bt);
+                    }
+                    break;
+                }
+                case 'dt': {
+                    type = 'DataType';
+                    value = om.Utility.dtype(Number(obj.dt));
+                    break;
+                }
+                case 's': {
+                    if (typeof obj.s === 'string') {
+                        value = obj.s;
+                    } else if (obj.s.filter((c) => c <= 32 && c >= 128).length === 0) {
+                        value = om.Utility.decodeText(obj.s);
+                    } else {
+                        value = obj.s;
+                    }
+                    type = 'string';
+                    break;
+                }
+                case 'g': {
+                    type = 'graph';
+                    value = new om.Graph(context, obj.g);
+                    break;
+                }
+                case 'func': {
+                    break;
+                }
+                case 'list': {
+                    const list = obj.list;
+                    value = [];
+                    if (list.s && list.s.length > 0) {
+                        value = list.s.map((v) => String.fromCharCode.apply(null, new Uint16Array(v))).join(', ');
+                        type = 'string[]';
+                    } else if (list.b && list.b.length > 0) {
+                        value = list.b;
+                        type = 'boolean[]';
+                    } else if (list.i && list.i.length > 0) {
+                        value = list.i;
+                        type = 'int64[]';
+                    } else if (list.f && list.f.length > 0) {
+                        value = list.f;
+                        type = 'float32[]';
+                    } else if (list.type && list.type.length > 0) {
+                        type = 'type[]';
+                        value = list.type.map((type) => om.Node.enum2Dtype(type) || '?');
+                    } else if (list.shape && list.shape.length > 0) {
+                        type = 'shape[]';
+                        value = list.shape.map((shape) => new om.TensorShape(shape));
+                    }
+                    break;
+                }
+                case 'list_list_int': {
+                    value = obj.list_list_int.list_list_i.map((list) => list.list_i);
+                    break;
+                }
+                case 't': {
+                    type = 'tensor';
+                    value = new om.Tensor('Constant', om.Utility.tensorType(obj.t.desc), obj.t.bytes);
+                    break;
+                }
+                case undefined: {
+                    value = null;
+                    break;
+                }
+                default: {
+                    throw new om.Error(`Unsupported attribute type '${JSON.stringify(obj).substring(0, 32)}'.`);
                 }
-                break;
-            }
-            case 'list_list_int': {
-                this.value = value.list_list_int.list_list_i.map((list) => list.list_i);
-                break;
-            }
-            case 't': {
-                const type = om.Utility.tensorType(value.t.desc);
-                this.value = new om.Tensor('Constant', type, value.t.bytes);
-                this.type = 'tensor';
-                break;
-            }
-            case undefined: {
-                this.value = null;
-                break;
-            }
-            default: {
-                throw new om.Error(`Unsupported attribute type '${JSON.stringify(value).substring(0, 32)}'.`);
             }
+            const attribute = new om.Argument(name, value, type);
+            this.attributes.push(attribute);
         }
     }
 };
 
 om.Argument = class {
 
     constructor(name, value) {
```

## netron/onednn.js

### js-beautify {}

```diff
@@ -16,52 +16,35 @@
     }
 };
 
 onednn.Model = class {
 
     constructor(metadata, symbol) {
         const version = symbol.version;
-        this._format = `oneDNN Graph${version ? ` v${version}` : ''}`;
-        this._runtime = `${symbol.engine_kind} ${symbol.fpmath_mode}`;
-        this._graphs = [new onednn.Graph(metadata, symbol)];
-    }
-
-    get format() {
-        return this._format;
-    }
-
-    get version() {
-        return this._version;
-    }
-
-    get runtime() {
-        return this._runtime;
-    }
-
-    get graphs() {
-        return this._graphs;
+        this.format = `oneDNN Graph${version ? ` v${version}` : ''}`;
+        this.runtime = `${symbol.engine_kind} ${symbol.fpmath_mode}`;
+        this.graphs = [new onednn.Graph(metadata, symbol)];
     }
 };
 
 onednn.Graph = class {
 
     constructor(metadata, symbol) {
-        this._metadata = metadata;
-        this._nodes = [];
-        this._inputs = [];
-        this._outputs = [];
-        const nodes = [];
+        this.nodes = [];
+        this.inputs = [];
+        this.outputs = [];
+        const layers = [];
         const tensors = new Set();
-        for (const node of symbol.graph) {
-            if (node.kind === 'Wildcard' && node.inputs.length === 0) {
-                for (const output of node.outputs) {
+        for (const layer of symbol.graph) {
+            if (layer.kind === 'Wildcard' && layer.inputs.length === 0) {
+                for (const output of layer.outputs) {
                     tensors.add(output.id);
                 }
             } else {
-                nodes.push(node);
+                layers.push(layer);
             }
         }
         const values = new Map();
         const value = (obj) => {
             const id = obj.id;
             const shape = !obj.shape || (obj.shape.length === 1 && obj.shape[0] === -1) ? null : new onednn.TensorShape(obj.shape);
             const type = new onednn.TensorType(obj.dtype, shape);
@@ -69,363 +52,258 @@
             if (!values.has(id)) {
                 values.set(id, new onednn.Value(id.toString(), type, tensor));
             } else if ((type && !type.equals(values.get(id).type)) || (tensor && !tensor.equals(values.get(id).initializer))) {
                 throw new onednn.Error(`Duplicate value '${id}'.`);
             }
             return values.get(id);
         };
-        for (const node of nodes) {
-            for (const input of node.inputs) {
+        for (const layer of layers) {
+            for (const input of layer.inputs) {
                 value(input);
             }
-            for (const output of node.outputs) {
+            for (const output of layer.outputs) {
                 value(output);
             }
         }
         const engine = symbol.engine_kind;
-        for (const node of nodes) {
-            this._nodes.push(new onednn.Node(this._metadata, node, engine, value, tensors));
+        for (const layer of layers) {
+            const node = new onednn.Node(metadata, layer, engine, value, tensors);
+            this.nodes.push(node);
         }
         const inputs = symbol.input_ports || [];
-        for (let i = 0; i < inputs.length; i++) {
-            const id = inputs[i];
-            const value = values.get(id);
+        for (const input of inputs) {
+            const value = values.get(input);
             if (value) {
-                this._inputs.push(new onednn.Argument(id.toString(), [value]));
+                const argument = new onednn.Argument(input.toString(), [value]);
+                this.inputs.push(argument);
             }
         }
         const outputs = symbol.output_ports || [];
-        for (let i = 0; i < outputs.length; i++) {
-            const id = outputs[i];
-            const value = values.get(id);
+        for (const output of outputs) {
+            const value = values.get(output);
             if (value) {
-                this._outputs.push(new onednn.Argument(id.toString(), [value]));
+                const argument = new onednn.Argument(output.toString(), [value]);
+                this.outputs.push(argument);
             }
         }
     }
-
-    get name() {
-        return '';
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
 };
 
 onednn.Node = class {
 
     constructor(metadata, node, device, value) {
-        this._name = node.name;
-        this._attributes = [];
-        this._inputs = [];
-        this._outputs = [];
-        this._type = metadata.type(node.kind) || {
+        this.name = node.name;
+        this.attributes = [];
+        this.inputs = [];
+        this.outputs = [];
+        this.type = metadata.type(node.kind) || {
             name: node.kind
         };
-        this._device = device;
-        this._location = node.id;
+        this.device = device;
+        this.identifier = node.id;
         const attrs = node.attrs;
         if (attrs) {
-            for (const [name, value] of Object.entries(attrs)) {
-                this._attributes.push(new onednn.Attribute(name, value.type, value.value));
+            for (const [name, obj] of Object.entries(attrs)) {
+                let type = obj.type;
+                let value = obj.value;
+                switch (type) {
+                    case 'bool':
+                        type = 'boolean';
+                        switch (value) {
+                            case 1:
+                                value = true;
+                                break;
+                            case 0:
+                                value = false;
+                                break;
+                            default:
+                                throw new onednn.Error(`Unsupported attribute boolean value '${value}'.`);
+                        }
+                        break;
+                    case 's64': {
+                        type = 'int64';
+                        const number = Number.parseInt(value, 10);
+                        value = Number.isNaN(value - number) ? value : number;
+                        break;
+                    }
+                    case 's64[]':
+                        type = 'int64[]';
+                        if (value.length > 2 && value.toString().startsWith('[') && value.toString().endsWith(']')) {
+                            let array = [];
+                            const items = value.substring(1, value.length - 1).split(',')
+                                .map((item) => item.trim())
+                                .map((item) => item.endsWith('L') ? item.substring(0, item.length - 1) : item);
+                            for (const item of items) {
+                                const value = Number.parseInt(item, 10);
+                                if (Number.isNaN(item - value)) {
+                                    array = null;
+                                } else if (array !== null) {
+                                    array.push(value);
+                                }
+                            }
+                            if (array !== null) {
+                                value = array;
+                            }
+                        }
+                        break;
+                    case 'f32': {
+                        type = 'float32';
+                        const number = Number.parseFloat(value);
+                        value = Number.isNaN(value - number) ? value : number;
+                        break;
+                    }
+                    case 'f32[]':
+                        type = 'float32[]';
+                        if (value.length > 2 && value.toString().startsWith('[') && value.toString().endsWith(']')) {
+                            let array = [];
+                            const items = value.substring(1, value.length - 1).split(',')
+                                .map((item) => item.trim())
+                                .map((item) => item.endsWith('L') ? item.substring(0, item.length - 1) : item);
+                            for (const item of items) {
+                                const value = Number.parseFloat(item);
+                                if (Number.isNaN(item - value)) {
+                                    array = null;
+                                } else if (array !== null) {
+                                    array.push(value);
+                                }
+                            }
+                            if (array !== null) {
+                                value = array;
+                            }
+                        }
+                        break;
+                    case 'string':
+                        type = 'string';
+                        break;
+                    default: {
+                        throw new onednn.Error(`Unsupported attribute array data type '${type}'.`);
+                    }
+                }
+                const attribute = new onednn.Argument(name, value, type);
+                this.attributes.push(attribute);
             }
         }
         const inputs = node.inputs || [];
         for (let i = 0; i < inputs.length; i++) {
             let name = inputs.length === 1 ? 'input' : i.toString();
-            if (this._type && this._type.inputs && this._type.inputs.length > 0) {
-                name = this._type.inputs[i].name;
+            if (this.type && this.type.inputs && this.type.inputs.length > 0) {
+                name = this.type.inputs[i].name;
             }
-            this._inputs.push(new onednn.Argument(name, [value(inputs[i])]));
+            const argument = new onednn.Argument(name, [value(inputs[i])]);
+            this.inputs.push(argument);
         }
         const outputs = node.outputs || [];
         for (let i = 0; i < outputs.length; i++) {
             let name = outputs.length === 1 ? 'output' : i.toString();
-            if (this._type && this._type.outputs && this._type.outputs.length > 0) {
-                name = this._type.outputs[i].name;
-            }
-            this._outputs.push(new onednn.Argument(name, [value(outputs[i])]));
-        }
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-
-    get location() {
-        return this._location;
-    }
-
-    get device() {
-        return this._device;
-    }
-};
-
-onednn.Attribute = class {
-
-    constructor(name, type, value) {
-        this._name = name;
-        this._value = value;
-        switch (type) {
-            case 'bool':
-                this._type = 'boolean';
-                switch (value) {
-                    case 1:
-                        this._value = true;
-                        break;
-                    case 0:
-                        this._value = false;
-                        break;
-                    default:
-                        throw new onednn.Error(`Unsupported attribute boolean value '${value}'.`);
-                }
-                break;
-            case 's64': {
-                this._type = 'int64';
-                const number = Number.parseInt(this._value, 10);
-                this._value = Number.isNaN(this._value - number) ? value : number;
-                break;
-            }
-            case 's64[]':
-                this._type = 'int64[]';
-                if (this._value.length > 2 && this._value.toString().startsWith('[') && this._value.toString().endsWith(']')) {
-                    let array = [];
-                    const items = this._value.substring(1, this._value.length - 1).split(',')
-                        .map((item) => item.trim())
-                        .map((item) => item.endsWith('L') ? item.substring(0, item.length - 1) : item);
-                    for (const item of items) {
-                        const value = Number.parseInt(item, 10);
-                        if (Number.isNaN(item - value)) {
-                            array = null;
-                        } else if (array !== null) {
-                            array.push(value);
-                        }
-                    }
-                    if (array !== null) {
-                        this._value = array;
-                    }
-                }
-                break;
-            case 'f32': {
-                this._type = 'float32';
-                const number = Number.parseFloat(this._value);
-                this._value = Number.isNaN(this._value - number) ? value : number;
-                break;
-            }
-            case 'f32[]':
-                this._type = 'float32[]';
-                if (this._value.length > 2 && this._value.toString().startsWith('[') && this._value.toString().endsWith(']')) {
-                    let array = [];
-                    const items = this._value.substring(1, this._value.length - 1).split(',')
-                        .map((item) => item.trim())
-                        .map((item) => item.endsWith('L') ? item.substring(0, item.length - 1) : item);
-                    for (const item of items) {
-                        const value = Number.parseFloat(item);
-                        if (Number.isNaN(item - value)) {
-                            array = null;
-                        } else if (array !== null) {
-                            array.push(value);
-                        }
-                    }
-                    if (array !== null) {
-                        this._value = array;
-                    }
-                }
-                break;
-            case 'string':
-                this._type = 'string';
-                break;
-            default: {
-                throw new onednn.Error(`Unsupported attribute array data type '${type}'.`);
+            if (this.type && this.type.outputs && this.type.outputs.length > 0) {
+                name = this.type.outputs[i].name;
             }
+            const argument = new onednn.Argument(name, [value(outputs[i])]);
+            this.outputs.push(argument);
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get value() {
-        return this._value;
-    }
-
-    get visible() {
-        return this._visible !== false;
-    }
 };
 
 onednn.Argument = class {
 
-    constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+    constructor(name, value, type) {
+        this.name = name;
+        this.value = value;
+        this.type = type || null;
     }
 };
 
 onednn.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
             throw new onednn.Error(`Invalid value identifier '${JSON.stringify(name)}'.`);
         }
-        this._name = name;
-        this._type = type || null;
-        this._initializer = initializer || null;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get initializer() {
-        return this._initializer;
+        this.name = name;
+        this.type = type || null;
+        this.initializer = initializer || null;
     }
 };
 
 onednn.TensorType = class {
 
     constructor(dataType, shape) {
         switch (dataType) {
             case 'f8_e4m3':
-                this._dataType = 'float8e4m3';
+                this.dataType = 'float8e4m3';
                 break;
             case 'f8_e5m2':
-                this._dataType = 'float8e5m2';
+                this.dataType = 'float8e5m2';
                 break;
             case 'f16':
-                this._dataType = 'float16';
+                this.dataType = 'float16';
                 break;
             case 'f32':
-                this._dataType = 'float32';
+                this.dataType = 'float32';
                 break;
             case 's8':
-                this._dataType = 'int8';
+                this.dataType = 'int8';
                 break;
             case 's32':
-                this._dataType = 'int32';
+                this.dataType = 'int32';
                 break;
             case 'u8':
-                this._dataType = 'uint8';
+                this.dataType = 'uint8';
                 break;
             case 'bf16':
-                this._dataType = 'bfloat16';
+                this.dataType = 'bfloat16';
                 break;
             case 'boolean':
-                this._dataType = 'boolean';
+                this.dataType = 'boolean';
                 break;
             case 'undef':
-                this._dataType = '?';
+                this.dataType = '?';
                 break;
             default:
                 throw new onednn.Error(`Unsupported tensor data type '${dataType}'.`);
         }
-        this._shape = shape;
-    }
-
-    get dataType() {
-        return this._dataType;
-    }
-
-    get shape() {
-        return this._shape;
+        this.shape = shape;
     }
 
     equals(obj) {
-        return obj && this._dataType === obj.dataType &&
-            ((this._shape && this._shape.equals(obj.shape)) || (this._shape === null && obj.shape === null));
+        return obj && this.dataType === obj.dataType &&
+            ((this.shape && this.shape.equals(obj.shape)) || (this.shape === null && obj.shape === null));
     }
 
     toString() {
-        return this._dataType + (this._shape ? this._shape.toString() : '[?]');
+        return this.dataType + (this.shape ? this.shape.toString() : '[?]');
     }
 };
 
 onednn.TensorShape = class {
 
     constructor(dimensions) {
-        this._dimensions = dimensions;
-    }
-
-    get dimensions() {
-        return this._dimensions;
+        this.dimensions = dimensions;
     }
 
     equals(obj) {
         return obj && Array.isArray(obj.dimensions) &&
-            Array.isArray(this._dimensions) && this._dimensions.length === obj.dimensions.length &&
-            obj.dimensions.every((value, index) => this._dimensions[index] === value);
+            Array.isArray(this.dimensions) && this.dimensions.length === obj.dimensions.length &&
+            obj.dimensions.every((value, index) => this.dimensions[index] === value);
     }
 
     toString() {
-        return this._dimensions ? (`[${this._dimensions.map((dimension) => dimension ? dimension.toString() : '?').join(',')}]`) : '';
+        return this.dimensions ? (`[${this.dimensions.map((dimension) => dimension ? dimension.toString() : '?').join(',')}]`) : '';
     }
 };
 
 onednn.Tensor = class {
 
     constructor(type, property_type) {
-        this._type = type;
-        this._category = property_type;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get category() {
-        return this._category;
+        this.type = type;
+        this.category = property_type;
     }
 
     equals(obj) {
-        return obj && this._type.equals(obj.type) && this.category === obj.category;
+        return obj && this.type.equals(obj.type) && this.category === obj.category;
     }
 };
 
 onednn.Error = class extends Error {
 
     constructor(message) {
         super(message);
```

## netron/onnx.js

### js-beautify {}

```diff
@@ -607,14 +607,15 @@
                 case onnx.DataLocation.EXTERNAL: {
                     if (Array.isArray(tensor.external_data)) {
                         const external_data = {};
                         for (const entry of tensor.external_data) {
                             external_data[entry.key] = entry.value;
                         }
                         if (external_data.location && external_data.offset && external_data.length) {
+                            this._location = external_data.location.toString();
                             const offset = parseInt(external_data.offset, 10);
                             const length = parseInt(external_data.length, 10);
                             if (Number.isInteger(offset) && Number.isInteger(length)) {
                                 this._data = context.location(external_data.location, offset, length);
                                 this._encoding = '<';
                             }
                         }
@@ -636,14 +637,18 @@
         return this._category;
     }
 
     get encoding() {
         return this._encoding;
     }
 
+    get location() {
+        return this._location;
+    }
+
     get type() {
         return this._type;
     }
 
     get indices() {
         return this._indices;
     }
@@ -1234,19 +1239,19 @@
         }
         throw new onnx.Error(`Unsupported data type '${JSON.stringify(value)}'.`);
     }
 
     createLocation(value) {
         switch (value) {
             case onnx.DataLocation.DEFAULT:
-                return 'default';
+                return '';
             case onnx.DataLocation.EXTERNAL:
                 return 'external';
             default:
-                return 'UNDEFINED';
+                return 'undefined';
         }
     }
 
     decodeText(value) {
         if (typeof value === 'string') {
             return value;
         }
```

## netron/openvino.js

### js-beautify {}

```diff
@@ -27,23 +27,40 @@
                 }
             }
             if (/^.*pytorch_model.*\.bin$/.test(identifier) ||
                 /^.*group.+-shard.+of.+\.bin$/.test(identifier) ||
                 /^.*param\.bin$/.test(identifier)) {
                 return;
             }
-            const identifiers = new Set(['config.bin', 'model.bin', '__model__.bin', 'weights.bin', 'programs.bin', 'best.bin', 'ncnn.bin']);
+            const identifiers = new Set([
+                'config.bin', 'model.bin', '__model__.bin', 'weights.bin',
+                'programs.bin', 'best.bin', 'ncnn.bin',
+                'stories15M.bin', 'stories42M.bin', 'stories110M.bin', 'stories260K.bin'
+            ]);
             if (!identifiers.has(identifier)) {
                 const size = Math.min(stream.length, 1024) & 0xFFFC;
                 const buffer = stream.peek(size).slice(0);
                 const length = buffer.length / 4;
-                const array = new Float32Array(buffer.buffer, buffer.byteOffset, length);
-                const values = Array.from(array);
-                if (values.every((value) => !Number.isNaN(value) && Number.isFinite(value) && value > -10.0 && value < 10.0)) {
-                    context.type = 'openvino.bin';
+                if (length >= 1) {
+                    switch (buffer[0] | buffer[1] << 8 | buffer[2] << 16 | buffer[3] << 24) {
+                        case 0x00000001:
+                        case 0x01306B47:
+                        case 0x000D4B38:
+                        case 0x0002C056: {
+                            break;
+                        }
+                        default: {
+                            const array = new Float32Array(buffer.buffer, buffer.byteOffset, length);
+                            const values = Array.from(array);
+                            if (values.every((x) => x === 0) ||
+                                (array[0] !== 0 && values.every((x) => !Number.isNaN(x) && Number.isFinite(x) && x > -10.0 && x < 10.0))) {
+                                context.type = 'openvino.bin';
+                            }
+                        }
+                    }
                 }
             }
             return;
         }
         const tags = context.tags('xml');
         if (tags.has('net')) {
             context.type = 'openvino.xml';
@@ -521,23 +538,111 @@
             }
             const count = output.type === 'Tensor[]' ? outputs.length - i : 1;
             const values = outputs.slice(i, i + count);
             const argument = new openvino.Argument(output.name, values);
             this.outputs.push(argument);
             i += count;
         }
-        for (const [name, value] of Object.entries(layer.data)) {
-            const attribute = new openvino.Attribute(metadata.attribute(type, name), name, value);
+        const op = type;
+        for (const [name, obj] of Object.entries(layer.data)) {
+            const schema = metadata.attribute(op, name);
+            let value = obj;
+            let type = null;
+            let visible = true;
+            if (schema && schema.type !== undefined) {
+                type = schema.type;
+                switch (schema.type) {
+                    case '':
+                    case 'graph':
+                    case 'string':
+                        break;
+                    case 'boolean':
+                        if (obj === '1' || obj === 'true' || obj === 'True') {
+                            value = true;
+                        } else if (obj === '0' || obj === 'false' || obj === 'False') {
+                            value = false;
+                        } else {
+                            throw new openvino.Error(`Unsupported attribute boolean value '${obj}'.`);
+                        }
+                        break;
+                    case 'int32':
+                    case 'int64': {
+                        const intValue = Number.parseInt(obj, 10);
+                        value = Number.isNaN(obj - intValue) ? obj : intValue;
+                        break;
+                    }
+                    case 'float32':
+                    case 'float64': {
+                        const floatValue = Number.parseFloat(obj);
+                        value = Number.isNaN(obj - floatValue) ? obj : floatValue;
+                        break;
+                    }
+                    case 'int32[]':
+                        if (obj.length > 2) {
+                            let ints = [];
+                            for (const entry of obj.split(',')) {
+                                const item = entry.trim();
+                                const intValue = Number.parseInt(item, 10);
+                                if (Number.isNaN(item - intValue)) {
+                                    ints = null;
+                                } else if (ints !== null) {
+                                    ints.push(intValue);
+                                }
+                            }
+                            if (ints !== null) {
+                                value = ints;
+                            }
+                        }
+                        break;
+                    case 'float32[]':
+                        if (obj.length > 2) {
+                            let floats = [];
+                            for (const entry of obj.split(',')) {
+                                const item = entry.trim();
+                                const floatValue = Number.parseFloat(item);
+                                if (Number.isNaN(item - floatValue)) {
+                                    floats = null;
+                                } else if (floats !== null) {
+                                    floats.push(floatValue);
+                                }
+                            }
+                            if (floats !== null) {
+                                value = floats;
+                            }
+                        }
+                        break;
+                    default:
+                        throw new openvino.Error(`Unsupported attribute type '${schema.type}'.`);
+                }
+            }
+            if (schema && schema.visible === false) {
+                visible = false;
+            } else if (schema && schema.default !== undefined) {
+                let defaultValue = schema.default;
+                if (value === defaultValue) {
+                    visible = false;
+                } else if (Array.isArray(value) && Array.isArray(defaultValue)) {
+                    defaultValue = defaultValue.slice(0, defaultValue.length);
+                    if (defaultValue.length > 1 && defaultValue[defaultValue.length - 1] === null) {
+                        defaultValue.pop();
+                        while (defaultValue.length < value.length) {
+                            defaultValue.push(defaultValue[defaultValue.length - 1]);
+                        }
+                    }
+                    if (value.every((item, index) => item === defaultValue[index])) {
+                        visible = false;
+                    }
+                }
+            }
+            const attribute = new openvino.Argument(name, value, type, visible);
             this.attributes.push(attribute);
         }
         if (layer.type === 'TensorIterator') {
             const graph = new openvino.Graph(metadata, layer, null);
-            const attribute = new openvino.Attribute({
-                type: 'graph'
-            }, 'body', graph);
+            const attribute = new openvino.Argument('body', graph, 'graph');
             this.attributes.push(attribute);
         }
         for (const blob of layer.blobs || []) {
             const name = blob.name;
             const offset = blob.offset;
             let data = (bin && (offset + blob.size) <= bin.length) ? bin.slice(offset, offset + blob.size) : null;
             let dimensions = blob.shape || null;
@@ -680,17 +785,19 @@
             }
         }
     }
 };
 
 openvino.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 openvino.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
@@ -698,107 +805,14 @@
         }
         this.name = name;
         this.type = initializer ? initializer.type : type;
         this.initializer = initializer || null;
     }
 };
 
-openvino.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this.name = name;
-        this.value = value;
-        if (metadata && metadata.type !== undefined) {
-            this.type = metadata.type;
-            switch (metadata.type) {
-                case '':
-                case 'graph':
-                case 'string':
-                    break;
-                case 'boolean':
-                    if (value === '1' || value === 'true' || value === 'True') {
-                        this.value = true;
-                    } else if (value === '0' || value === 'false' || value === 'False') {
-                        this.value = false;
-                    } else {
-                        throw new openvino.Error(`Unsupported attribute boolean value '${value}'.`);
-                    }
-                    break;
-                case 'int32':
-                case 'int64': {
-                    const intValue = Number.parseInt(this.value, 10);
-                    this.value = Number.isNaN(this.value - intValue) ? value : intValue;
-                    break;
-                }
-                case 'float32':
-                case 'float64': {
-                    const floatValue = Number.parseFloat(this.value);
-                    this.value = Number.isNaN(this.value - floatValue) ? value : floatValue;
-                    break;
-                }
-                case 'int32[]':
-                    if (this.value.length > 2) {
-                        let ints = [];
-                        for (const entry of this.value.split(',')) {
-                            const item = entry.trim();
-                            const intValue = Number.parseInt(item, 10);
-                            if (Number.isNaN(item - intValue)) {
-                                ints = null;
-                            } else if (ints !== null) {
-                                ints.push(intValue);
-                            }
-                        }
-                        if (ints !== null) {
-                            this.value = ints;
-                        }
-                    }
-                    break;
-                case 'float32[]':
-                    if (this.value.length > 2) {
-                        let floats = [];
-                        for (const entry of this.value.split(',')) {
-                            const item = entry.trim();
-                            const floatValue = Number.parseFloat(item);
-                            if (Number.isNaN(item - floatValue)) {
-                                floats = null;
-                            } else if (floats !== null) {
-                                floats.push(floatValue);
-                            }
-                        }
-                        if (floats !== null) {
-                            this.value = floats;
-                        }
-                    }
-                    break;
-                default:
-                    throw new openvino.Error(`Unsupported attribute type '${metadata.type}'.`);
-            }
-        }
-        if (metadata && metadata.visible === false) {
-            this.visible = false;
-        } else if (metadata && metadata.default !== undefined) {
-            let defaultValue = metadata.default;
-            if (this.value === defaultValue) {
-                this.visible = false;
-            } else if (Array.isArray(this.value) && Array.isArray(defaultValue)) {
-                defaultValue = defaultValue.slice(0, defaultValue.length);
-                if (defaultValue.length > 1 && defaultValue[defaultValue.length - 1] === null) {
-                    defaultValue.pop();
-                    while (defaultValue.length < this.value.length) {
-                        defaultValue.push(defaultValue[defaultValue.length - 1]);
-                    }
-                }
-                if (this.value.every((item, index) => item === defaultValue[index])) {
-                    this.visible = false;
-                }
-            }
-        }
-    }
-};
-
 openvino.Tensor = class {
 
     constructor(type, data, category) {
         this.type = type;
         this.values = data;
         this.category = category;
     }
```

## netron/python.js

### js-beautify {}

```diff
@@ -1875,35 +1875,40 @@
         this.registerType('builtins.complex', class {
             constructor(real, imaginary) {
                 this.real = real;
                 this.imag = imaginary;
             }
         });
         this.registerType('builtins.NoneType', class {});
-        this.registerType('builtins.object', class {});
+        this.registerType('builtins.object', class {
+            static __new__(cls, ...args) {
+                return execution.invoke(cls, args);
+            }
+        });
         this.registerType('builtins.tuple', class extends Array {
             constructor(items) {
                 super(items ? items.length : 0);
                 if (items) {
                     for (let i = 0; i < items.length; i++) {
                         this[i] = items[i];
                     }
                 }
             }
         });
         this.registerType('builtins.staticmethod', class {});
-        this.registerFunction('builtins.long', this.builtins.int);
-        this.registerFunction('builtins.print', () => {});
-        this.registerFunction('builtins.unicode');
         this.registerType('builtins.Warning', class {});
         this.registerType('builtins.FutureWarning', class extends builtins.Warning {});
         this.registerType('builtins.BaseException', class {});
         this.registerType('builtins.Exception', class extends builtins.BaseException {});
         this.registerType('builtins.AttributeError', class extends builtins.Exception {});
         this.registerType('builtins.SyntaxError', class extends builtins.Exception {});
+        this.registerFunction('builtins.long', this.builtins.int);
+        this.registerFunction('builtins.print', () => {});
+        this.registerFunction('builtins.unicode');
+        builtins.Ellipsis = new builtins.ellipsis();
         this.registerType('typing._Final', class {});
         this.registerType('typing._SpecialForm', class extends typing._Final {});
         this.registerType('typing._BaseGenericAlias', class extends typing._Final {});
         this.registerType('typing._GenericAlias', class extends typing._BaseGenericAlias {});
         this.registerType('typing._SpecialGenericAlias', class extends typing._BaseGenericAlias {});
         this.registerType('typing._TupleType', class extends typing._SpecialGenericAlias {});
         this.registerType('typing._CallableType', class {});
@@ -2936,17 +2941,21 @@
         this.registerType('sklearn.linear_model.logistic.LogisticRegression', class {});
         this.registerType('sklearn.linear_model.logistic.LogisticRegressionCV', class {});
         this.registerType('sklearn.linear_model.LassoLars', class {});
         this.registerType('sklearn.linear_model.ridge.Ridge', class {});
         this.registerType('sklearn.linear_model.sgd_fast.Log', class {});
         this.registerType('sklearn.linear_model.stochastic_gradient.SGDClassifier', class {});
         this.registerType('sklearn.manifold._t_sne.TSNE', class {});
-        this.registerType('sklearn.metrics._dist_metrics.EuclideanDistance', class {});
-        this.registerType('sklearn.metrics._dist_metrics.EuclideanDistance64', class {});
-        this.registerType('sklearn.metrics._dist_metrics.ManhattanDistance', class {});
+        this.registerType('sklearn.metrics._dist_metrics.DistanceMetric', class extends builtins.object {});
+        this.registerType('sklearn.metrics._dist_metrics.DistanceMetric32', class extends sklearn.metrics._dist_metrics.DistanceMetric {});
+        this.registerType('sklearn.metrics._dist_metrics.DistanceMetric64', class extends sklearn.metrics._dist_metrics.DistanceMetric {});
+        this.registerType('sklearn.metrics._dist_metrics.EuclideanDistance', class extends sklearn.metrics._dist_metrics.DistanceMetric {});
+        this.registerType('sklearn.metrics._dist_metrics.EuclideanDistance32', class extends sklearn.metrics._dist_metrics.DistanceMetric32 {});
+        this.registerType('sklearn.metrics._dist_metrics.EuclideanDistance64', class extends sklearn.metrics._dist_metrics.DistanceMetric64 {});
+        this.registerType('sklearn.metrics._dist_metrics.ManhattanDistance', class extends sklearn.metrics._dist_metrics.DistanceMetric {});
         this.registerType('sklearn.metrics._scorer._PassthroughScorer', class {});
         this.registerType('sklearn.metrics._scorer._PredictScorer', class {});
         this.registerType('sklearn.metrics.scorer._PredictScorer', class {});
         this.registerType('sklearn.metrics._scorer._ThresholdScorer', class {});
         this.registerType('sklearn.mixture._bayesian_mixture.BayesianGaussianMixture', class {});
         this.registerType('sklearn.mixture._gaussian_mixture.GaussianMixture', class {});
         this.registerType('sklearn.model_selection._search.GridSearchCV', class {});
@@ -4647,14 +4656,16 @@
         this.registerType('torch.ao.nn.quantized.modules.conv.Conv2d', class extends torch.nn.modules.module.Module {});
         this.registerType('torch.ao.nn.quantized.modules.conv._ConvNd', class extends torch.ao.nn.quantized.modules.utils.WeightedQuantizedModule {});
         this.registerType('torch.ao.nn.quantized.modules.conv._ConvTransposeNd', class extends torch.ao.nn.quantized.modules.conv._ConvNd {});
         this.registerType('torch.ao.nn.quantized.modules.conv.ConvTranspose2d', class extends torch.ao.nn.quantized.modules.conv._ConvTransposeNd {});
         this.registerType('torch.ao.nn.quantized.modules.Quantize', class extends torch.nn.modules.module.Module {});
         this.registerType('torch.ao.nn.quantized.modules.DeQuantize', class extends torch.nn.modules.module.Module {});
         this.registerType('torch.ao.nn.quantized.modules.dropout.Dropout', class extends torch.nn.modules.dropout.Dropout {});
+        this.registerType('torch.ao.nn.quantized.modules.embedding_ops.Embedding', class extends torch.nn.modules.module.Module {});
+        this.registerType('torch.ao.nn.quantized.modules.embedding_ops.EmbeddingPackedParams', class extends torch.nn.modules.module.Module {});
         this.registerType('torch.ao.nn.quantized.modules.functional_modules.FloatFunctional', class extends torch.nn.modules.module.Module {});
         this.registerType('torch.ao.nn.quantized.modules.functional_modules.QFunctional', class extends torch.nn.modules.module.Module {});
         this.registerType('torch.ao.nn.quantized.modules.functional_modules.FXFloatFunctional', class extends torch.nn.modules.module.Module {});
         this.registerType('torch.ao.nn.quantized.modules.linear.Linear', class extends torch.ao.nn.quantized.modules.utils.WeightedQuantizedModule {});
         this.registerType('torch.ao.nn.quantized.modules.linear.LinearPackedParams', class extends torch.nn.modules.module.Module {});
         this.registerType('torch.ao.nn.quantized.modules.normalization.LayerNorm', class extends torch.nn.modules.normalization.LayerNorm {});
         this.registerType('torch.ao.nn.quantized.modules.rnn.LSTM', class {});
@@ -5044,14 +5055,15 @@
                 if (isNaN(start)) {
                     return [];
                 }
             }
             throw new python.Error(`Unsupported range(${JSON.stringify(start)}, ${JSON.stringify(stop)}, ${JSON.stringify(step)})`);
         });
         this.registerFunction('torch._C._nn.gelu');
+        this.registerFunction('torch._native_multi_head_attention');
         this.registerFunction('torch._utils._rebuild_sparse_tensor', (layout, data) => {
             if (layout === torch.sparse_coo) {
                 return self.invoke('torch._sparse_coo_tensor_unsafe', data);
             }
             throw new python.Error(`Unsupported sparse tensor layout '${layout ? layout.__str__() : ''}'.`);
         });
         this.registerFunction('torch._utils._rebuild_wrapper_subclass');
@@ -5085,15 +5097,17 @@
             const tensor = self.invoke('torch.Tensor', []);
             tensor._layout = torch.sparse_coo;
             tensor._indices = indices;
             tensor._values = values;
             tensor._shape = size;
             return tensor;
         });
-        this.registerFunction('torch._utils._rebuild_meta_tensor_no_storage');
+        this.registerFunction('torch._utils._rebuild_meta_tensor_no_storage', (dtype, size, stride, requires_grad) => {
+            return torch.empty_strided(size, stride, dtype, null, 'meta', false, requires_grad);
+        });
         this.registerFunction('torch._utils._rebuild_tensor', (storage, storage_offset, size, stride) => {
             if (Array.isArray(storage) && storage.length === 5 && storage[0] === 'storage') {
                 const [, storage_type, , , size] = storage;
                 storage = new storage_type(size);
             }
             const name = `${storage.__class__.__module__}.${storage.__class__.__name__.replace('Storage', 'Tensor')}`;
             const tensor = self.invoke(name, []);
@@ -5222,16 +5236,32 @@
             }
             return 0;
         });
         this.registerFunction('torch._nested_tensor_from_mask_left_aligned');
         this.registerFunction('torch._unwrap_optional', (value) => {
             return value;
         });
-        this.registerFunction('torch.empty_strided', ( /* size, stride, dtype, layout, device, pin_memory, requires_grad */ ) => {
-            return null;
+        this.registerFunction('torch.get_default_dtype', () => {
+            torch._default_type = torch._default_type || torch.float32;
+            return torch._default_type;
+        });
+        this.registerFunction('torch.set_default_dtype', (value) => {
+            torch._default_type = value;
+        });
+        this.registerFunction('torch._prims_common.dtype_or_default', (value) => {
+            return value || torch.get_default_dtype();
+        });
+        this.registerFunction('torch.empty_strided', (size, stride, dtype /*, layout, device, pin_memory, requires_grad */ ) => {
+            const shape = size;
+            dtype = torch._prims_common.dtype_or_default(dtype);
+            size = shape.reduce((a, b) => a * b, 1);
+            const storage = execution.invoke('torch.storage._TypedStorage', [size, dtype]);
+            const tensor = execution.invoke('torch.Tensor', []);
+            tensor.__setstate__([storage, 0, shape, stride]);
+            return tensor;
         });
         this.registerFunction('torch.add', (left, right) => {
             if (typeof left === 'number' && typeof right === 'number') {
                 return left * right;
             }
             if (Array.isArray(left) && Array.isArray(right)) {
                 return left.concat(right);
@@ -6308,15 +6338,15 @@
                 return ret;
             }
             deserialize_tensor_meta(tensor_meta) {
                 const sizes = tensor_meta.sizes.map((val) => this.deserialize_sym_int(val));
                 const strides = tensor_meta.strides.map((val) => this.deserialize_sym_int(val));
                 const device = this.deserialize_device(tensor_meta.device);
                 const dtype = null; // _SERIALIZE_TO_TORCH_DTYPE[tensor_meta.dtype],
-                return torch.empty_strided(sizes, strides, device, dtype);
+                return torch.empty_strided(sizes, strides, dtype, null, device);
             }
             deserialize_sym_int(s) {
                 if (s.as_expr !== undefined && s.as_expr !== null) {
                     let sym = {};
                     if (this.symbol_name_to_symbol.has(s.as_expr.expr_str)) {
                         sym = this.symbol_name_to_symbol.get(s.as_expr.expr_str);
                     } else {
@@ -6334,17 +6364,22 @@
                                     runtime_min=vr.lower,  # type: ignore[arg-type]
                                     runtime_max=vr.upper  # type: ignore[arg-type]
                                 )
                         }
                         */
                     }
                     const hint = s.as_expr.hint || null;
+                    if (hint && hint.$type === 'as_int') {
+                        return this.deserialize_sym_int(hint);
+                    }
                     return this.shape_env.create_symintnode(sym, hint);
                 } else if (s.as_int !== undefined && s.as_int !== null) {
                     return s.as_int;
+                } else if (s.$type === 'as_int') {
+                    return s.$value;
                 }
                 throw new python.Error('SymInt has invalid field type.');
             }
             deserialize_device(d) {
                 if (d.index !== undefined) {
                     return new torch.device(d.type, d.index);
                 }
@@ -6822,14 +6857,34 @@
         this.registerType('fastcore.basics.GetAttr', class {});
         this.registerType('fastcore.dispatch._TypeDict', class {});
         this.registerType('fastcore.dispatch.TypeDispatch', class {});
         this.registerType('fastcore.foundation.L', class {});
         this.registerType('fastcore.transform.Pipeline', class {});
         this.registerType('fastcore.transform.Transform', class {});
         this.registerType('fastcore.transform.ItemTransform', class extends fastcore.transform.Transform {});
+        this.registerFunction('fastai.torch_core._fa_rebuild_tensor', (cls, ...args) => {
+            const tensor = self.invoke('torch._utils._rebuild_tensor_v2', args);
+            return self.invoke(cls, tensor);
+        });
+        this.registerFunction('fastai.torch_core.trainable_params');
+        this.registerFunction('fastai.torch_core._rebuild_from_type', (func, type, args, dict) => {
+            const tensor = self.invoke(type, [func(...args)]);
+            Object.assign(tensor, dict);
+            return tensor;
+        });
+        this.registerType('fastai.torch_core.Module', class extends torch.nn.modules.module.Module {});
+        this.registerType('fastai.torch_core.TensorBase', class extends torch.Tensor {
+            constructor(x) {
+                super();
+                Object.assign(this, x);
+            }
+        });
+        this.registerType('fastai.torch_core.TensorCategory', class {});
+        this.registerType('fastai.torch_core.TensorImage', class {});
+        this.registerType('fastai.torch_core.TensorMask', class {});
         this.registerType('fastai.callback.core.Callback', class extends fastcore.basics.GetAttr {});
         this.registerType('fastai.callback.core.TrainEvalCallback', class {});
         this.registerType('fastai.callback.fp16.AMPMode', class extends this._enum.Enum {});
         this.registerType('fastai.callback.fp16.MixedPrecision', class {});
         this.registerType('fastai.callback.hook._hook_inner', class {});
         this.registerType('fastai.callback.hook.Hook', class {});
         this.registerType('fastai.callback.hook.Hooks', class {});
@@ -6871,56 +6926,41 @@
         this.registerType('fastai.learner.AvgMetric', class extends fastai.learner.Metric {});
         this.registerType('fastai.learner.AvgSmoothLoss', class extends fastai.learner.Metric {});
         this.registerType('fastai.learner.CastToTensor', class extends fastai.callback.core.Callback {});
         this.registerType('fastai.learner.Dice', class extends fastai.learner.Metric {});
         this.registerType('fastai.learner.Learner', class extends fastcore.basics.GetAttr {});
         this.registerType('fastai.learner.Recorder', class {});
         this.registerType('fastai.losses.BaseLoss', class {});
-        this.registerType('fastai.losses.CrossEntropyLossFlat', class {});
+        this.registerType('fastai.losses.CrossEntropyLossFlat', class extends fastai.losses.BaseLoss {});
+        this.registerType('fastai.losses.FocalLoss', class extends fastai.torch_core.Module {});
+        this.registerType('fastai.losses.FocalLossFlat', class extends fastai.losses.BaseLoss {});
         this.registerType('fastai.metrics.AccumMetric', class extends fastai.learner.Metric {});
         this.registerFunction('fastai.metrics._rmse');
         this.registerFunction('fastai.metrics.accuracy');
         this.registerFunction('fastai.metrics.foreground_acc');
         this.registerFunction('fastai.metrics.mse');
         this.registerFunction('fastai.metrics.error_rate');
         this.registerType('fastai.optimizer._BaseOptimizer', class {});
         this.registerType('fastai.optimizer.Optimizer', class extends fastai.optimizer._BaseOptimizer {});
         this.registerFunction('fastai.optimizer.Adam');
         this.registerFunction('fastai.optimizer.adam_step');
         this.registerFunction('fastai.optimizer.average_grad');
+        this.registerFunction('fastai.optimizer.average_sqr_grad');
+        this.registerFunction('fastai.optimizer.step_stat');
         this.registerFunction('fastai.optimizer.weight_decay');
         this.registerType('fastai.tabular.core.Categorify', class {});
         this.registerType('fastai.tabular.core.FillMissing', class {});
         this.registerType('fastai.tabular.core.FillStrategy', class {});
         this.registerType('fastai.tabular.core.ReadTabBatch', class extends fastcore.transform.ItemTransform {});
         this.registerType('fastai.tabular.core.TabDataLoader', class extends fastai.data.core.TfmdDL {});
         this.registerType('fastai.tabular.data.TabularDataLoaders', class extends fastai.data.core.DataLoaders {});
         this.registerType('fastai.tabular.core.Tabular', class {});
         this.registerType('fastai.tabular.core.TabularPandas', class extends fastai.tabular.core.Tabular {});
         this.registerType('fastai.tabular.learner.TabularLearner', class extends fastai.learner.Learner {});
         this.registerType('fastai.tabular.model.TabularModel', class {});
-        this.registerFunction('fastai.torch_core._fa_rebuild_tensor', (cls, ...args) => {
-            const tensor = self.invoke('torch._utils._rebuild_tensor_v2', args);
-            return self.invoke(cls, tensor);
-        });
-        this.registerType('fastai.torch_core.TensorBase', class extends torch.Tensor {
-            constructor(x) {
-                super();
-                Object.assign(this, x);
-            }
-        });
-        this.registerType('fastai.torch_core.TensorCategory', class {});
-        this.registerType('fastai.torch_core.TensorImage', class {});
-        this.registerType('fastai.torch_core.TensorMask', class {});
-        this.registerFunction('fastai.torch_core.trainable_params');
-        this.registerFunction('fastai.torch_core._rebuild_from_type', (func, type, args, dict) => {
-            const tensor = self.invoke(type, [func(...args)]);
-            Object.assign(tensor, dict);
-            return tensor;
-        });
         this.registerFunction('fastai.vision.augment.aug_transforms');
         this.registerType('fastai.vision.augment._BrightnessLogit', class {});
         this.registerType('fastai.vision.augment._ContrastLogit', class {});
         this.registerType('fastai.vision.augment._WarpCoord', class {});
         this.registerType('fastai.vision.augment.Brightness', class {});
         this.registerType('fastai.vision.augment.flip_mat', class {});
         this.registerType('fastai.vision.augment.Flip', class {});
```

## netron/pytorch-metadata.json

### Pretty-printed

 * *Similarity: 0.9993074792243767%*

 * *Differences: {'insert': "[(37, OrderedDict([('name', 'aten::_adaptive_avg_pool2d'), ('inputs', "*

 * *           "[OrderedDict([('name', 'self'), ('type', 'Tensor')]), OrderedDict([('name', "*

 * *           "'output_size'), ('type', 'SymInt[2]')])]), ('outputs', [OrderedDict([('type', "*

 * *           "'Tensor')])])]))]"}*

```diff
@@ -1085,14 +1085,32 @@
     {
         "inputs": [
             {
                 "name": "self",
                 "type": "Tensor"
             },
             {
+                "name": "output_size",
+                "type": "SymInt[2]"
+            }
+        ],
+        "name": "aten::_adaptive_avg_pool2d",
+        "outputs": [
+            {
+                "type": "Tensor"
+            }
+        ]
+    },
+    {
+        "inputs": [
+            {
+                "name": "self",
+                "type": "Tensor"
+            },
+            {
                 "name": "other",
                 "type": "Scalar"
             },
             {
                 "default": 1,
                 "name": "alpha",
                 "type": "Scalar"
```

## netron/pytorch.js

### js-beautify {}

```diff
@@ -2764,25 +2764,24 @@
                                 for (const item of obj) {
                                     if (Array.isArray(item) || (Object(item) === item && item.type)) {
                                         queue.push(item);
                                     }
                                 }
                             } else if (Object(obj) === obj) {
                                 for (const [key, value] of Object.entries(obj)) {
-                                    if (key === 'location') {
-                                        continue;
-                                    }
-                                    if (Array.isArray(value)) {
-                                        for (const item of value) {
-                                            if (Array.isArray(item) || (Object(item) === item && item.type)) {
-                                                queue.push(item);
+                                    if (key !== 'identifier') {
+                                        if (Array.isArray(value)) {
+                                            for (const item of value) {
+                                                if (Array.isArray(item) || (Object(item) === item && item.type)) {
+                                                    queue.push(item);
+                                                }
                                             }
+                                        } else if (Object(value) === value && value.type) {
+                                            queue.push(value);
                                         }
-                                    } else if (Object(value) === value && value.type) {
-                                        queue.push(value);
                                     }
                                 }
                             }
                         }
                         return false;
                     };
                     if (!containsVariableReference(statements.slice(2, statements.length - 1), statement.target.value)) {
@@ -3888,15 +3887,15 @@
                 source_type: reader.int32(),
                 source_length: reader.uint32()
             };
         }
         for (let i = 0; i < this.operations.length; i++) {
             this.operations[i] = {
                 index: reader.int32(),
-                location: i,
+                identifier: i,
                 inputs: new Array(reader.uint32()),
                 outputs: new Array(reader.uint32())
             };
         }
         for (const operand of operands) {
             for (let i = 0; i < operand.dimensions.length; i++) {
                 operand.dimensions[i] = reader.uint32();
@@ -4058,16 +4057,16 @@
         const signature = (operation.inputs || []).map((input) => input.data_type);
         this.name = '';
         this.type = metadata.type(operation.index, signature);
         this.inputs = [];
         this.outputs = [];
         this.attributes = [];
         this.chain = [];
-        if (operation.location !== undefined) {
-            this.location = operation.location.toString();
+        if (operation.identifier !== undefined) {
+            this.identifier = operation.identifier.toString();
         }
         const inputs = this.type.inputs.concat(this.type.attributes);
         if (operation.inputs) {
             for (let i = 0; i < operation.inputs.length; i++) {
                 const name = i < inputs.length ? inputs[i].name : i.toString();
                 const operand = operation.inputs[i];
                 if (operand.dimensions.length > 0) {
```

## netron/rknn.js

### js-beautify {}

```diff
@@ -75,18 +75,18 @@
         }
     }
 };
 
 rknn.Graph = class {
 
     constructor(metadata, type, name, obj, container) {
-        this._name = name;
-        this._inputs = [];
-        this._outputs = [];
-        this._nodes = [];
+        this.name = name;
+        this.inputs = [];
+        this.outputs = [];
+        this.nodes = [];
         switch (type) {
             case 'json': {
                 const dataType = (value) => {
                     const type = value.vx_type.startsWith('VSI_NN_TYPE_') ? value.vx_type.split('_').pop().toLowerCase() : value.vx_type;
                     switch (type) {
                         case 'uint8':
                         case 'int8':
@@ -154,24 +154,24 @@
                 }
                 for (const graph of model.graph) {
                     const key = `${graph.right}:${graph.right_tensor_id}`;
                     const name = graph.left + (graph.left_tensor_id === 0 ? '' : graph.left_tensor_id.toString());
                     const argument = new rknn.Argument(name, [value(key)]);
                     switch (graph.left) {
                         case 'input':
-                            this._inputs.push(argument);
+                            this.inputs.push(argument);
                             break;
                         case 'output':
-                            this._outputs.push(argument);
+                            this.outputs.push(argument);
                             break;
                         default:
                             throw new rknn.Error(`Unsupported left graph connection '${graph.left}'.`);
                     }
                 }
-                this._nodes = model.nodes.map((node) => new rknn.Node(metadata, type, node, value, container));
+                this.nodes = model.nodes.map((node) => new rknn.Node(metadata, type, node, value, container));
                 break;
             }
             case 'flatbuffers': {
                 const graph = obj;
                 const dataTypes = ['unk0', 'int32', '?', 'int8', '?', 'int16', 'float32', 'int64', '?', '?', 'float16', '?', '?', 'unk13'];
                 const args = graph.tensors.map((tensor) => {
                     const shape = new rknn.TensorShape(Array.from(tensor.shape));
@@ -185,252 +185,180 @@
                 });
                 const arg = (index) => {
                     if (index >= args.length) {
                         throw new rknn.Error(`Invalid tensor index '${index}'.`);
                     }
                     return args[index];
                 };
-                this._nodes = graph.nodes.map((node) => new rknn.Node(metadata, type, node, arg, container));
+                this.nodes = graph.nodes.map((node) => new rknn.Node(metadata, type, node, arg, container));
                 break;
             }
             case 'openvx': {
                 const model = obj;
-                this._nodes = model.nodes.map((node) => new rknn.Node(metadata, type, node, null, container));
+                this.nodes = model.nodes.map((node) => new rknn.Node(metadata, type, node, null, container));
                 break;
             }
             default: {
                 throw new rknn.Error(`Unsupported RKNN graph type '${type}'.`);
             }
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
 };
 
 rknn.Argument = class {
 
     constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+        this.name = name;
+        this.value = value;
     }
 };
 
 rknn.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
             throw new rknn.Error(`Invalid value identifier '${JSON.stringify(name)}'.`);
         }
-        this._name = name;
-        this._type = type || null;
-        this._initializer = initializer || null;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get initializer() {
-        return this._initializer;
+        this.name = name;
+        this.type = type || null;
+        this.initializer = initializer || null;
     }
 };
 
 rknn.Node = class {
 
     constructor(metadata, type, node, value, container) {
-        this._inputs = [];
-        this._outputs = [];
-        this._attributes = [];
+        this.inputs = [];
+        this.outputs = [];
+        this.attributes = [];
         switch (type) {
             case 'json': {
-                this._name = node.name || '';
+                this.name = node.name || '';
                 if (node.op === 'VSI_NN_OP_NBG' && container && container.has('openvx')) {
                     const buffer = container.get('openvx');
                     const model = new openvx.Model(buffer);
-                    this._type = new rknn.Graph(metadata, 'openvx', 'NBG', model, null);
+                    this.type = new rknn.Graph(metadata, 'openvx', 'NBG', model, null);
                 } else if (node.op === 'RKNN_OP_NNBG' && container && container.has('flatbuffers')) {
                     const buffer = container.get('flatbuffers');
                     const reader = flatbuffers.BinaryReader.open(buffer);
                     const model = rknn.schema.Model.create(reader);
-                    this._type = new rknn.Graph(metadata, 'flatbuffers', 'NNBG', model.graphs[0], null);
+                    this.type = new rknn.Graph(metadata, 'flatbuffers', 'NNBG', model.graphs[0], null);
                 } else {
                     const type = metadata.type(node.op);
-                    this._type = type ? {
+                    this.type = type ? {
                         ...type
                     } : {
                         name: node.op
                     };
                     for (const prefix of ['VSI_NN_OP_', 'RKNN_OP_']) {
-                        this._type.name = this._type.name.startsWith(prefix) ? this._type.name.substring(prefix.length) : this._type.name;
+                        this.type.name = this.type.name.startsWith(prefix) ? this.type.name.substring(prefix.length) : this.type.name;
                     }
                 }
                 node.input = node.input || [];
                 for (let i = 0; i < node.input.length;) {
-                    const input = this._type && this._type.inputs && i < this._type.inputs.length ? this._type.inputs[i] : {
+                    const input = this.type && this.type.inputs && i < this.type.inputs.length ? this.type.inputs[i] : {
                         name: i === 0 ? 'input' : i.toString()
                     };
                     const count = input.list ? node.input.length - i : 1;
                     const list = node.input.slice(i, i + count).map((input) => {
                         if (input.right_tensor) {
                             return value(`${input.right_tensor.type}:${input.right_tensor.tensor_id}`);
                         }
                         if (input.right_node) {
                             return value(`${input.right_node.node_id}:${input.right_node.tensor_id}`);
                         }
                         throw new rknn.Error('Invalid input argument.');
                     });
-                    this._inputs.push(new rknn.Argument(input.name, list));
+                    this.inputs.push(new rknn.Argument(input.name, list));
                     i += count;
                 }
                 node.output = node.output || [];
                 for (let i = 0; i < node.output.length;) {
-                    const output = this._metadata && this._metadata.outputs && i < this._metadata.outputs.length ? this._metadata.outputs[i] : {
+                    const output = this.type.outputs && i < this.type.outputs.length ? this.type.outputs[i] : {
                         name: i === 0 ? 'output' : i.toString()
                     };
                     const count = output.list ? node.output.length - i : 1;
                     const list = node.output.slice(i, i + count).map((output) => {
                         if (output.right_tensor) {
                             return value(`${output.right_tensor.type}:${output.right_tensor.tensor_id}`);
                         }
                         if (output.right_node) {
                             return value(`${output.right_node.node_id}:${output.right_node.tensor_id}`);
                         }
                         throw new rknn.Error('Invalid output argument.');
                     });
-                    this._outputs.push(new rknn.Argument(output.name, list));
+                    this.outputs.push(new rknn.Argument(output.name, list));
                     i += count;
                 }
                 if (node.nn) {
                     for (const params of Object.values(node.nn)) {
                         for (const [name, value] of Object.entries(params)) {
-                            const attribute = new rknn.Attribute(name, value);
-                            this._attributes.push(attribute);
+                            const attribute = new rknn.Argument(name, value);
+                            this.attributes.push(attribute);
                         }
                     }
                 }
                 break;
             }
             case 'flatbuffers': {
-                this._name = node.name;
-                this._type = metadata.type(node.type);
+                this.name = node.name;
+                this.type = metadata.type(node.type);
                 if (node.inputs.length > 0) {
-                    const inputs = this._type.inputs || (node.inputs.length === 1 ? [{
+                    const inputs = this.type.inputs || (node.inputs.length === 1 ? [{
                         name: "input"
                     }] : [{
                         name: "inputs",
                         list: true
                     }]);
                     if (Array.isArray(inputs) && inputs.length > 0 && inputs[0].list === true) {
-                        this._inputs = [new rknn.Argument(inputs[0].name, Array.from(node.inputs).map((input) => value(input)))];
+                        this.inputs = [new rknn.Argument(inputs[0].name, Array.from(node.inputs).map((input) => value(input)))];
                     } else {
-                        this._inputs = Array.from(node.inputs).map((input, index) => {
+                        this.inputs = Array.from(node.inputs).map((input, index) => {
                             return new rknn.Argument(index < inputs.length ? inputs[index].name : index.toString(), [value(input)]);
                         });
                     }
                 }
                 if (node.outputs.length > 0) {
-                    const outputs = this._type.outputs || (node.outputs.length === 1 ? [{
+                    const outputs = this.type.outputs || (node.outputs.length === 1 ? [{
                         name: "output"
                     }] : [{
                         name: "outputs",
                         list: true
                     }]);
                     if (Array.isArray(outputs) && outputs.length > 0 && outputs[0].list === true) {
                         const values = Array.from(node.outputs).map((output) => value(output));
                         const argument = new rknn.Argument(outputs[0].name, values);
-                        this._outputs = [argument];
+                        this.outputs = [argument];
                     } else {
-                        this._outputs = Array.from(node.outputs).map((output, index) => {
+                        this.outputs = Array.from(node.outputs).map((output, index) => {
                             return new rknn.Argument(index < outputs.length ? outputs[index].name : index.toString(), [value(output)]);
                         });
                     }
                 }
                 break;
             }
             case 'openvx': {
-                this._name = '';
-                this._type = metadata.type(node.type);
+                this.name = '';
+                this.type = metadata.type(node.type);
                 break;
             }
             default: {
                 throw new rknn.Error(`Unsupported RKNN node type '${type}'.`);
             }
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-};
-
-rknn.Attribute = class {
-
-    constructor(name, value) {
-        this._name = name;
-        this._value = value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
-    }
 };
 
 rknn.Tensor = class {
 
     constructor(type, offset, weights) {
-        this._type = type;
-        this._data = null;
+        this.type = type;
+        this.values = null;
         let itemsize = 0;
-        switch (this._type.dataType) {
+        switch (this.type.dataType) {
             case 'uint8':
                 itemsize = 1;
                 break;
             case 'int8':
                 itemsize = 1;
                 break;
             case 'int16':
@@ -451,69 +379,49 @@
             case 'float64':
                 itemsize = 8;
                 break;
             case 'vdata':
                 itemsize = 1;
                 break;
             default:
-                throw new rknn.Error(`Unsupported tensor data type '${this._type.dataType}'.`);
+                throw new rknn.Error(`Unsupported tensor data type '${this.type.dataType}'.`);
         }
         if (weights) {
             const shape = type.shape.dimensions;
             const size = itemsize * shape.reduce((a, b) => a * b, 1);
             if (size > 0) {
-                this._data = weights.slice(offset, offset + size);
+                this.values = weights.slice(offset, offset + size);
             }
         }
     }
-
-    get type() {
-        return this._type;
-    }
-
-    get values() {
-        return this._data;
-    }
 };
 
 rknn.TensorType = class {
 
     constructor(dataType, shape) {
-        this._dataType = dataType;
-        this._shape = shape;
-    }
-
-    get dataType() {
-        return this._dataType;
-    }
-
-    get shape() {
-        return this._shape;
+        this.dataType = dataType;
+        this.shape = shape;
     }
 
     toString() {
-        return this.dataType + this._shape.toString();
+        return this.dataType + this.shape.toString();
     }
 };
 
 rknn.TensorShape = class {
 
-    constructor(shape) {
-        this._dimensions = shape;
-    }
-
-    get dimensions() {
-        return this._dimensions;
+    constructor(dimensions) {
+        this.dimensions = dimensions;
     }
 
     toString() {
-        if (!this._dimensions || this._dimensions.length === 0) {
+        if (!this.dimensions || this.dimensions.length === 0) {
             return '';
         }
-        return `[${this._dimensions.join(',')}]`;
+        return `[${this.dimensions.join(',')}]`;
     }
 };
 
 rknn.Container = class extends Map {
 
     static open(context) {
         const stream = context.stream;
@@ -672,16 +580,16 @@
     constructor(buffer) {
         const reader = new openvx.BufferReader(buffer);
         reader.skip(4); // signature
         const major = reader.uint16();
         /* const minor = */
         reader.uint16();
         reader.skip(4);
-        this._name = reader.string(64);
-        this._nodes = new Array(reader.uint32());
+        this.name = reader.string(64);
+        this.nodes = new Array(reader.uint32());
         if (major > 3) {
             reader.skip(296);
         } else if (major > 1) {
             reader.skip(288);
         } else {
             reader.skip(32);
         }
@@ -693,35 +601,27 @@
         reader.uint32();
         /* const outputSize = */
         reader.uint32();
         const nodeOffset = reader.uint32();
         /* const nodeSize = */
         reader.uint32();
         reader.seek(nodeOffset);
-        for (let i = 0; i < this._nodes.length; i++) {
+        for (let i = 0; i < this.nodes.length; i++) {
             const type = reader.string(64);
             const node = {
                 type
             };
             node.index = reader.uint32();
             node.c = reader.uint32();
             if (major > 3) {
                 node.d = reader.uint32();
             }
-            this._nodes[i] = node;
+            this.nodes[i] = node;
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
 };
 
 rknn.Error = class extends Error {
 
     constructor(message) {
         super(message);
         this.name = 'Error loading RKNN model.';
```

## netron/safetensors.js

### js-beautify {}

```diff
@@ -94,20 +94,17 @@
     }
 };
 
 safetensors.Value = class {
 
     constructor(name, value) {
         this.name = name;
+        this.type = value.type;
         this.initializer = value;
     }
-
-    get type() {
-        return this.initializer.type;
-    }
 };
 
 safetensors.Node = class {
 
     constructor(name, values) {
         this.name = name;
         this.type = {
```

## netron/server.js

### js-beautify {}

```diff
@@ -25,222 +25,115 @@
         return new message.Model(context.target);
     }
 };
 
 message.Model = class {
 
     constructor(data) {
-        this._format = data.format || '';
-        this._producer = data.producer || '';
-        this._version = data.version || '';
-        this._description = data.description || '';
-        this._metadata = (data.metadata || []).map((entry) => {
+        this.format = data.format || '';
+        this.producer = data.producer || '';
+        this.version = data.version || '';
+        this.description = data.description || '';
+        this.metadata = (data.metadata || []).map((entry) => {
             return {
                 name: entry.name,
                 value: entry.value
             };
         });
-        this._graphs = (data.graphs || []).map((graph) => new message.Graph(graph));
-    }
-
-    get format() {
-        return this._format;
-    }
-
-    get producer() {
-        return this._producer;
-    }
-
-    get version() {
-        return this._version;
-    }
-
-    get description() {
-        return this._description;
-    }
-
-    get metadata() {
-        return this._metadata;
-    }
-
-    get graphs() {
-        return this._graphs;
+        this.graphs = (data.graphs || []).map((graph) => new message.Graph(graph));
     }
 };
 
 message.Graph = class {
 
     constructor(data) {
-        this._inputs = [];
-        this._outputs = [];
-        this._nodes = [];
+        this.inputs = [];
+        this.outputs = [];
+        this.nodes = [];
         const args = data.arguments ? data.arguments.map((argument) => new message.Value(argument)) : [];
         for (const parameter of data.inputs || []) {
             parameter.arguments = parameter.arguments.map((index) => args[index]).filter((argument) => !argument.initializer);
             if (parameter.arguments.filter((argument) => !argument.initializer).length > 0) {
-                this._inputs.push(new message.Argument(parameter));
+                this.inputs.push(new message.Argument(parameter));
             }
         }
         for (const parameter of data.outputs || []) {
             parameter.arguments = parameter.arguments.map((index) => args[index]);
             if (parameter.arguments.filter((argument) => !argument.initializer).length > 0) {
-                this._outputs.push(new message.Argument(parameter));
+                this.outputs.push(new message.Argument(parameter));
             }
         }
         for (const node of data.nodes || []) {
             for (const parameter of node.inputs || []) {
                 parameter.arguments = parameter.arguments.map((index) => args[index]);
             }
             for (const parameter of node.outputs || []) {
                 parameter.arguments = parameter.arguments.map((index) => args[index]);
             }
-            this._nodes.push(new message.Node(node));
+            this.nodes.push(new message.Node(node));
         }
     }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
-    }
 };
 
 message.Argument = class {
 
     constructor(data) {
-        this._name = data.name || '';
-        this._value = (data.arguments || []);
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
+        this.name = data.name || '';
+        this.value = (data.arguments || []);
+        this.type = data.type || '';
     }
 };
 
 message.Value = class {
 
     constructor(data) {
-        this._name = data.name || '';
-        this._type = data.type ? new message.TensorType(data.type) : null;
-        this._initializer = data.initializer ? new message.Tensor(data.initializer) : null;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        if (this._initializer && this._initializer.type) {
-            return this._initializer.type;
+        this.name = data.name || '';
+        this.initializer = data.initializer ? new message.Tensor(data.initializer) : null;
+        if (this.initializer && this.initializer.type) {
+            this.type = this.initializer.type;
+        } else {
+            this.type = data.type ? new message.TensorType(data.type) : null;
         }
-        return this._type;
-    }
-
-    get initializer() {
-        return this._initializer;
     }
 };
 
 message.Node = class {
 
     constructor(data) {
-        this._type = {
+        this.type = {
             name: data.type.name,
             category: data.type.category
         };
-        this._name = data.name;
-        this._inputs = (data.inputs || []).map((input) => new message.Argument(input));
-        this._outputs = (data.outputs || []).map((output) => new message.Argument(output));
-        this._attributes = (data.attributes || []).map((attribute) => new message.Attribute(attribute));
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-};
-
-message.Attribute = class {
-
-    constructor(data) {
-        this._type = data.type || '';
-        this._name = data.name;
-        this._value = data.value;
-    }
-
-    get name() {
-        return this._name;
-    }
-
-    get value() {
-        return this._value;
-    }
-
-    get type() {
-        return this._type;
+        this.name = data.name;
+        this.inputs = (data.inputs || []).map((input) => new message.Argument(input));
+        this.outputs = (data.outputs || []).map((output) => new message.Argument(output));
+        this.attributes = (data.attributes || []).map((attribute) => new message.Argument(attribute));
     }
 };
 
 message.TensorType = class {
 
     constructor(data) {
-        this._dataType = data.dataType;
-        this._shape = new message.TensorShape(data.shape);
-    }
-
-    get dataType() {
-        return this._dataType;
-    }
-
-    get shape() {
-        return this._shape;
+        this.dataType = data.dataType;
+        this.shape = new message.TensorShape(data.shape);
     }
 
     toString() {
-        return this._dataType + this._shape.toString();
+        return this.dataType + this.shape.toString();
     }
 };
 
 message.TensorShape = class {
 
     constructor(data) {
-        this._dimensions = data.dimensions;
-    }
-
-    get dimensions() {
-        return this._dimensions;
+        this.dimensions = data.dimensions;
     }
 
     toString() {
-        return `[${this._dimensions}]`;
+        return `[${this.dimensions}]`;
     }
 };
 
 message.Tensor = class {};
 
 message.Error = class extends Error {
     constructor(message) {
```

## netron/server.py

```diff
@@ -11,15 +11,15 @@
 import socketserver
 import sys
 import threading
 import time
 import webbrowser
 import urllib.parse
 
-__version__ = '7.6.8'
+__version__ = '7.6.9'
 
 class _ContentProvider: # pylint: disable=too-few-public-methods
     data = bytearray()
     base_dir = ''
     base = ''
     identifier = ''
     def __init__(self, data, path, file):
```

## netron/sklearn.js

### js-beautify {}

```diff
@@ -177,37 +177,32 @@
         };
         process('', '', obj, []);
     }
 };
 
 sklearn.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type;
+        this.visible = visible !== false;
     }
 };
 
 sklearn.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
             throw new sklearn.Error(`Invalid value identifier '${JSON.stringify(name)}'.`);
         }
         this.name = name;
-        this._type = type || null;
+        this.type = initializer ? initializer.type : type;
         this.initializer = initializer || null;
     }
-
-    get type() {
-        if (this.initializer) {
-            return this.initializer.type;
-        }
-        return this._type;
-    }
 };
 
 sklearn.Node = class {
 
     constructor(metadata, group, name, obj, inputs, outputs, values, stack) {
         this.group = group || null;
         this.name = name || '';
@@ -232,49 +227,49 @@
         };
         const entries = Object.entries(obj);
         for (const [name, value] of entries) {
             if (name === '__class__') {
                 continue;
             } else if (value && isArray(value)) {
                 const tensor = new sklearn.Tensor(value);
-                const attribute = new sklearn.Attribute(name, tensor, 'tensor');
+                const attribute = new sklearn.Argument(name, tensor, 'tensor');
                 this.attributes.push(attribute);
             } else if (Array.isArray(value) && value.length > 0 && value.every((obj) => isArray(obj))) {
                 const tensors = value.map((obj) => new sklearn.Tensor(obj));
-                const attribute = new sklearn.Attribute(name, tensors, 'tensor[]');
+                const attribute = new sklearn.Argument(name, tensors, 'tensor[]');
                 this.attributes.push(attribute);
             } else {
                 stack = stack || new Set();
                 if (value && Array.isArray(value) && value.every((obj) => typeof obj === 'string')) {
-                    const attribute = new sklearn.Attribute(name, value, 'string[]');
+                    const attribute = new sklearn.Argument(name, value, 'string[]');
                     this.attributes.push(attribute);
                 } else if (value && Array.isArray(value) && value.every((obj) => typeof obj === 'number')) {
-                    const attribute = new sklearn.Attribute(name, value);
+                    const attribute = new sklearn.Argument(name, value);
                     this.attributes.push(attribute);
                 } else if (value && value.__class__ && value.__class__.__module__ === 'builtins' && (value.__class__.__name__ === 'function' || value.__class__.__name__ === 'type')) {
                     const obj = {};
                     obj.__class__ = value;
                     const node = new sklearn.Node(metadata, group, '', obj, [], [], null, stack);
-                    const attribute = new sklearn.Attribute(name, node, 'object');
+                    const attribute = new sklearn.Argument(name, node, 'object');
                     this.attributes.push(attribute);
                 } else if (value && Array.isArray(value) && value.length > 0 && value.every((obj) => obj && (obj.__class__ || obj === Object(obj)))) {
                     const values = value.filter((value) => !stack.has(value));
                     const nodes = values.map((value) => {
                         stack.add(value);
                         const node = new sklearn.Node(metadata, group, '', value, [], [], null, stack);
                         stack.delete(value);
                         return node;
                     });
-                    const attribute = new sklearn.Attribute(name, nodes, 'object[]');
+                    const attribute = new sklearn.Argument(name, nodes, 'object[]');
                     this.attributes.push(attribute);
                 } else if (value && (value.__class__ || isObject(value))) {
                     if (!stack.has(value)) {
                         stack.add(value);
                         const node = new sklearn.Node(metadata, group, '', value, [], [], null, stack);
-                        const attribute = new sklearn.Attribute(name, node, 'object');
+                        const attribute = new sklearn.Argument(name, node, 'object');
                         this.attributes.push(attribute);
                         stack.delete(value);
                     }
                 } else {
                     const schema = metadata.attribute(type, name);
                     if (schema) {
                         let type = '';
@@ -291,36 +286,26 @@
                                 } else {
                                     visible = !value.every((item) => item === schema.default);
                                 }
                             } else {
                                 visible = value !== schema.default;
                             }
                         }
-                        const attribute = new sklearn.Attribute(name, value, type, visible);
+                        const attribute = new sklearn.Argument(name, value, type, visible);
                         this.attributes.push(attribute);
                     } else {
-                        const attribute = new sklearn.Attribute(name, value);
+                        const attribute = new sklearn.Argument(name, value);
                         this.attributes.push(attribute);
                     }
                 }
             }
         }
     }
 };
 
-sklearn.Attribute = class {
-
-    constructor(name, value, type, visible) {
-        this.name = name;
-        this.value = value;
-        this.type = type;
-        this.visible = visible !== false;
-    }
-};
-
 sklearn.Tensor = class {
 
     constructor(array) {
         this.type = new sklearn.TensorType(array.dtype.__name__, new sklearn.TensorShape(array.shape));
         this.stride = array.strides.map((stride) => stride / array.itemsize);
         this.encoding = this.type.dataType === 'string' || this.type.dataType === 'object' ? '|' : array.dtype.byteorder;
         this.values = this.type.dataType === 'string' || this.type.dataType === 'object' ? array.flatten().tolist() : array.tobytes();
```

## netron/tengine.js

### js-beautify {}

```diff
@@ -56,17 +56,19 @@
             }
         }
     }
 };
 
 tengine.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 tengine.Value = class {
 
     constructor(tensor) {
         this.name = tensor.name;
@@ -85,16 +87,31 @@
         this.outputs = [];
         this.attributes = [];
         this.type = metadata.type(type, version) || {
             name: type
         };
         for (let i = 0; i < node.params.length; i++) {
             const metadata = (this.type && this.type.attributes && i < this.type.attributes.length) ? this.type.attributes[i] : null;
-            const name = metadata ? metadata.name : i.toString();
-            this.attributes.push(new tengine.Attribute(metadata, name, node.params[i]));
+            const value = node.params[i];
+            let name = metadata ? metadata.name : i.toString();
+            let type = null;
+            let visible = true;
+            if (metadata) {
+                name = !name && metadata.name ? metadata.name : name;
+                type = !type && metadata.type ? metadata.type : type;
+                if (metadata.visible === false) {
+                    visible = false;
+                } else if (metadata.default !== undefined) {
+                    if (value === metadata.default || (value && value.toString() === metadata.default.toString())) {
+                        visible = false;
+                    }
+                }
+            }
+            const attribute = new tengine.Argument(name, value, type, visible);
+            this.attributes.push(attribute);
         }
         const inputs = node.inputs;
         let inputIndex = 0;
         if (this.type && this.type.inputs) {
             for (const inputDef of this.type.inputs) {
                 if (inputIndex < inputs.length || inputDef.option !== 'optional') {
                     const inputCount = (inputDef.option === 'variadic') ? (inputs.length - inputIndex) : 1;
@@ -125,36 +142,14 @@
                 const outputName = ((outputIndex + index) === 0) ? 'output' : (outputIndex + index).toString();
                 return new tengine.Argument(outputName, [tensors[id]]);
             }));
         }
     }
 };
 
-tengine.Attribute = class {
-
-    constructor(metadata, key, value) {
-        this.type = '';
-        this.name = key;
-        this.value = value;
-        if (metadata) {
-            this.name = metadata.name;
-            if (metadata.type) {
-                this.type = metadata.type;
-            }
-            if (metadata.visible === false) {
-                this.visible = false;
-            } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
-                if (this.value === metadata.default || (this.value && this.value.toString() === metadata.default.toString())) {
-                    this.visible = false;
-                }
-            }
-        }
-    }
-};
-
 tengine.Tensor = class {
 
     constructor(type, values) {
         this.type = type;
         this.values = values;
     }
 };
@@ -398,29 +393,39 @@
         register(98, 0, 'L2Pool', []);
         register(99, 0, 'LogSoftmax', []);
         register(100, 0, 'ReLU1', []);
         register(101, 0, 'L2Normalization', []);
         register(102, 0, 'PackModel', ['i', 'i']);
         register(103, 0, 'Num', []);
         const reader = new tengine.BinaryReader(this.context.read('binary'));
-        this._majorVersion = reader.uint16();
-        this._minorVersion = reader.uint16();
-        if (this._majorVersion !== 2) {
-            throw new tengine.Error(`Unsupported format version 'v${this._majorVersion}.${this._minorVersion}'.`);
+        const major = reader.uint16();
+        const minor = reader.uint16();
+        this.version = `${major}.${minor}`;
+        if (major !== 2) {
+            throw new tengine.Error(`Unsupported format version 'v${this.version}'.`);
         }
-        this._compileVersion = reader.uint16();
+        reader.uint16(); // compileVersion
         reader.skip(2); // struct align
         reader.seek(reader.uint32()); // root table
-        this._originalFormat = reader.int32();
-        this._subFormat = reader.int32();
+        const originalFormat = reader.int32();
+        const subFormat = reader.int32();
+        const sources = [
+            '', 'Tengine', 'Caffe', 'ONNX',
+            'MXNet', 'TensorFlow', 'TensorFlow Lite', 'Darknet',
+            `DLA v${subFormat}`, 'ncnn', 'MegEngine', 'OneFlow',
+            'Horizon', 'Bitman'
+        ];
+        if (originalFormat >= sources.length) {
+            throw new tengine.Error(`Unsupported source '${originalFormat}'.`);
+        }
+        this.source = sources[originalFormat];
         this.graphs = [];
         const subgraphOffsets = reader.uint32s();
         for (const subgraphOffset of subgraphOffsets) {
             reader.seek(subgraphOffset);
-
             const subgraph = {};
             subgraph.id = reader.int32();
             subgraph.graphLayout = reader.int32();
             /*
             if (graphLayout === 0) {
                 return "NCHW";
             }
@@ -487,15 +492,15 @@
                                 break;
                             default:
                                 throw new tengine.Error(`Unsupported param type '${paramType}' in '${node.type}'.`);
                         }
                     }
                 }
                 if (node.type === 'Slice') {
-                    node.params[6] = (this._originalFormat === 5) ? node.params[6] : 0;
+                    node.params[6] = (originalFormat === 5) ? node.params[6] : 0;
                 }
                 node.attributes = attributeOffsets.map((attributeOffset) => {
                     reader.seek(attributeOffset);
                     const name = reader.string();
                     const value = reader.string();
                     const type = reader.int32();
                     return {
@@ -556,53 +561,14 @@
                             throw new tengine.Error(`Unsupported 'Convolution' layout '${subgraph.graphLayout}'.`);
                     }
                 }
             }
         }
         delete this.stream;
     }
-
-    get version() {
-        return `${this._majorVersion}.${this._minorVersion}`;
-    }
-
-    get source() {
-        switch (this._originalFormat) {
-            case 0:
-                return '';
-            case 1:
-                return 'Tengine';
-            case 2:
-                return 'Caffe';
-            case 3:
-                return 'ONNX';
-            case 4:
-                return 'MXNet';
-            case 5:
-                return 'TensorFlow';
-            case 6:
-                return 'TensorFlow Lite';
-            case 7:
-                return 'Darknet';
-            case 8:
-                return `DLA v${this._subFormat}`;
-            case 9:
-                return 'ncnn';
-            case 10:
-                return 'MegEngine';
-            case 11:
-                return 'OneFlow';
-            case 12:
-                return 'Horizon';
-            case 13:
-                return 'Bitman';
-            default:
-                throw new tengine.Error(`Unsupported source '${this._originalFormat}'.`);
-        }
-    }
 };
 
 tengine.BinaryReader = class {
 
     constructor(reader) {
         this._reader = reader;
     }
```

## netron/tensorrt.js

### js-beautify {}

```diff
@@ -25,45 +25,25 @@
         return new tensorrt.Model(null, target);
     }
 };
 
 tensorrt.Model = class {
 
     constructor(metadata, model) {
-        this._format = model.format;
-        this._graphs = [new tensorrt.Graph(metadata, model)];
-    }
-
-    get format() {
-        return this._format;
-    }
-
-    get graphs() {
-        return this._graphs;
+        this.format = model.format;
+        this.graphs = [new tensorrt.Graph(metadata, model)];
     }
 };
 
 tensorrt.Graph = class {
 
     constructor( /* metadata, model */ ) {
-        this._inputs = [];
-        this._outputs = [];
-        this._nodes = [];
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get nodes() {
-        return this._nodes;
+        this.inputs = [];
+        this.outputs = [];
+        this.nodes = [];
     }
 };
 
 tensorrt.Engine = class {
 
     static open(context) {
         const stream = context.stream;
@@ -126,15 +106,15 @@
             }
             default: {
                 const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
                 throw new tensorrt.Error(`Unsupported TensorRT engine signature (${content.substring(8)}).`);
             }
         }
         // const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
-        // buffer = this._stream.read(24 + size);
+        // buffer = this.stream.read(24 + size);
         // reader = new tensorrt.BinaryReader(buffer);
         throw new tensorrt.Error('Invalid file content. File contains undocumented TensorRT engine data.');
     }
 };
 
 tensorrt.Container = class {
 
@@ -169,15 +149,15 @@
         this.type = 'tensorrt.container';
         this.format = 'TensorRT FlatBuffers';
         this.stream = stream;
     }
 
     read() {
         delete this.stream;
-        // const buffer = this._stream.peek(Math.min(24, this._stream.length));
+        // const buffer = this.stream.peek(Math.min(24, this.stream.length));
         // const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
         throw new tensorrt.Error('Invalid file content. File contains undocumented TensorRT data.');
     }
 };
 
 tensorrt.BinaryReader = class {
```

## netron/tf.js

### js-beautify {}

```diff
@@ -880,17 +880,19 @@
         this.inputs = inputs;
         this.outputs = outputs;
     }
 };
 
 tf.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 tf.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
@@ -979,16 +981,131 @@
                 this.inputs.push(argument);
             }
         } else {
             if (node.device !== undefined) {
                 this.device = node.device;
             }
             if (node.attr) {
-                this.attributes = Object.entries(node.attr).map(([name, value]) => {
-                    return new tf.Attribute(metadata, node.op, name, value);
+                this.attributes = Object.entries(node.attr).map(([name, obj]) => {
+                    const schema = obj && obj.metadata ? obj.metadata : metadata.attribute(node.op, name);
+                    let value = null;
+                    let type = schema && schema.type ? schema.type : null;
+                    let visible = metadata.visible(node.op, name);
+                    switch (obj.value) {
+                        case undefined:
+                            type = '';
+                            value = null;
+                            break;
+                        case 'type':
+                            type = 'type';
+                            value = tf.Utility.dataType(obj.type);
+                            break;
+                        case 'i':
+                            value = obj.i;
+                            break;
+                        case 'f':
+                            value = obj.f;
+                            break;
+                        case 'b':
+                            value = obj.b;
+                            break;
+                        case 'shape':
+                            type = 'shape';
+                            value = new tf.TensorShape(obj.shape);
+                            break;
+                        case 's':
+                            value = tf.Utility.decodeText(obj.s);
+                            break;
+                        case 'tensor': {
+                            type = 'tensor';
+                            value = new tf.Tensor(obj.tensor);
+                            break;
+                        }
+                        case 'func': {
+                            type = 'function';
+                            value = new tf.Node(metadata, {
+                                op: obj.func.name,
+                                attr: obj.func.attr
+                            }, null, new tf.Context());
+                            break;
+                        }
+                        case 'placeholder': {
+                            type = 'placeholder';
+                            value = obj;
+                            break;
+                        }
+                        case 'list': {
+                            const list = obj.list;
+                            if (list.s && list.s.length > 0) {
+                                value = list.s.map((s) => tf.Utility.decodeText(s));
+                            } else if (list.i && list.i.length > 0) {
+                                value = list.i;
+                            } else if (list.f && list.f.length > 0) {
+                                value = list.f;
+                            } else if (list.type && list.type.length > 0) {
+                                type = 'type[]';
+                                value = list.type.map((type) => tf.Utility.dataType(type));
+                            } else if (list.shape && list.shape.length > 0) {
+                                type = 'shape[]';
+                                value = list.shape.map((shape) => new tf.TensorShape(shape));
+                            } else if (list.func && list.func.length > 0) {
+                                type = 'function[]';
+                                value = list.func.map((func) => new tf.Node(metadata, {
+                                    op: func.name,
+                                    attr: func.attr
+                                }));
+                            } else {
+                                value = [];
+                            }
+                            break;
+                        }
+                        default: {
+                            throw new tf.Error(`Unsupported attribute value type '${JSON.stringify(value).substring(0, 32)}'.`);
+                        }
+                    }
+                    if (schema) {
+                        if (schema.visible === false) {
+                            visible = false;
+                        } else if (schema.default !== undefined) {
+                            const equals = (value, defaultValue) => {
+                                if (!Array.isArray(defaultValue) && defaultValue === Object(defaultValue)) {
+                                    switch (defaultValue.type) {
+                                        case 'type':
+                                            defaultValue = tf.Utility.dataType(defaultValue.value);
+                                            break;
+                                        case 'shape':
+                                        case 'tensor':
+                                            defaultValue = defaultValue.value;
+                                            break;
+                                        default:
+                                            throw new tf.Error(JSON.stringify(defaultValue));
+                                    }
+                                }
+                                if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') {
+                                    return value === defaultValue;
+                                }
+                                if (typeof value === 'bigint') {
+                                    return Number(value) === defaultValue;
+                                }
+                                return false;
+                            };
+                            const defaultValue = schema.default;
+                            if (Array.isArray(value) && Array.isArray(defaultValue)) {
+                                if (value.length === defaultValue.length && value.every((item, index) => equals(item, defaultValue[index]))) {
+                                    visible = false;
+                                }
+                            } else if (equals(value, defaultValue)) {
+                                visible = false;
+                            }
+                        }
+                    }
+                    if (name === '_class' || name === '_output_shapes' || visible === false) {
+                        visible = false;
+                    }
+                    return new tf.Argument(name, value, type, visible);
                 });
             }
             let inputIndex = 0;
             const inputs = (node.input || []).filter((input) => !input.name.startsWith('^'));
             if (this.type && this.type.inputs) {
                 for (const input of this.type.inputs) {
                     let count = 1;
@@ -1045,146 +1162,14 @@
             }));
             const controlDependencies = node.controlDependencies || [];
             this.controlDependencies = controlDependencies.map((input) => context.value(input.name));
         }
     }
 };
 
-tf.Attribute = class {
-
-    constructor(metadata, op, name, value) {
-        this.name = name;
-        this.value = null;
-        this.type = null;
-        const schema = value && value.metadata ? value.metadata : metadata.attribute(op, name);
-        const visible = metadata.visible(op, name);
-        if (schema && schema.type) {
-            this.type = schema.type;
-        }
-        switch (value.value) {
-            case undefined:
-                this.type = '';
-                this.value = null;
-                break;
-            case 'type':
-                this.type = 'type';
-                this.value = tf.Utility.dataType(value.type);
-                break;
-            case 'i':
-                this.value = value.i;
-                break;
-            case 'f':
-                this.value = value.f;
-                break;
-            case 'b':
-                this.value = value.b;
-                break;
-            case 'shape':
-                this.type = 'shape';
-                this.value = new tf.TensorShape(value.shape);
-                break;
-            case 's':
-                this.value = tf.Utility.decodeText(value.s);
-                break;
-            case 'tensor': {
-                this.type = 'tensor';
-                this.value = new tf.Tensor(value.tensor);
-                break;
-            }
-            case 'func': {
-                this.type = 'function';
-                this.value = new tf.Node(metadata, {
-                    op: value.func.name,
-                    attr: value.func.attr
-                }, null, new tf.Context());
-                break;
-            }
-            case 'placeholder': {
-                this.type = 'placeholder';
-                this.value = value;
-                break;
-            }
-            case 'list': {
-                const list = value.list;
-                if (list.s && list.s.length > 0) {
-                    this.value = list.s.map((s) => tf.Utility.decodeText(s));
-                } else if (list.i && list.i.length > 0) {
-                    this.value = list.i;
-                } else if (list.f && list.f.length > 0) {
-                    this.value = list.f;
-                } else if (list.type && list.type.length > 0) {
-                    this.type = 'type[]';
-                    this.value = list.type.map((type) => tf.Utility.dataType(type));
-                } else if (list.shape && list.shape.length > 0) {
-                    this.type = 'shape[]';
-                    this.value = list.shape.map((shape) => new tf.TensorShape(shape));
-                } else if (list.func && list.func.length > 0) {
-                    this.type = 'function[]';
-                    this.value = list.func.map((func) => new tf.Node(metadata, {
-                        op: func.name,
-                        attr: func.attr
-                    }));
-                } else {
-                    this.value = [];
-                }
-                break;
-            }
-            default: {
-                throw new tf.Error(`Unsupported attribute value type '${JSON.stringify(value).substring(0, 32)}'.`);
-            }
-        }
-        if (schema) {
-            if (schema.visible === false) {
-                this.visible = false;
-            } else if (Object.prototype.hasOwnProperty.call(schema, 'default')) {
-                const equals = (value, defaultValue) => {
-                    if (!Array.isArray(defaultValue) && defaultValue === Object(defaultValue)) {
-                        switch (defaultValue.type) {
-                            case 'type':
-                                defaultValue = tf.Utility.dataType(defaultValue.value);
-                                break;
-                            case 'shape':
-                            case 'tensor':
-                                defaultValue = defaultValue.value;
-                                break;
-                            default:
-                                throw new tf.Error(JSON.stringify(defaultValue));
-                        }
-                    }
-                    if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') {
-                        return value === defaultValue;
-                    }
-                    if (typeof value === 'bigint') {
-                        return Number(value) === defaultValue;
-                    }
-                    return false;
-                };
-                const value = this.value;
-                const defaultValue = schema.default;
-                if (Array.isArray(value) && Array.isArray(defaultValue)) {
-                    if (value.length === defaultValue.length && value.every((item, index) => equals(item, defaultValue[index]))) {
-                        this.visible = false;
-                    }
-                } else if (equals(value, defaultValue)) {
-                    this.visible = false;
-                }
-            }
-        }
-        if (name === '_output_shapes') {
-            this.visible = false;
-        }
-        if (name === '_class') {
-            this.visible = false;
-        }
-        if (visible === false) {
-            this.visible = false;
-        }
-    }
-};
-
 tf.Tensor = class {
 
     constructor(tensor, name, category) {
         this.name = name;
         this.category = category || null;
         if (tensor) {
             this.type = new tf.TensorType(tensor.dtype, tensor.tensor_shape || tensor.tensorShape);
```

## netron/tflite.js

### js-beautify {}

```diff
@@ -126,15 +126,15 @@
                         if (modelMetadata.name) {
                             this.name = modelMetadata.name;
                         }
                         if (modelMetadata.version) {
                             this.version = modelMetadata.version;
                         }
                         if (modelMetadata.description) {
-                            this.description = this._description ? [this._description, modelMetadata.description].join(' ') : modelMetadata.description;
+                            this.description = this.description ? [this.description, modelMetadata.description].join(' ') : modelMetadata.description;
                         }
                         if (modelMetadata.author) {
                             this.metadata.push(new tflite.Argument('author', modelMetadata.author));
                         }
                         if (modelMetadata.license) {
                             this.metadata.push(new tflite.Argument('license', modelMetadata.license));
                         }
@@ -282,31 +282,33 @@
             return new tflite.Argument(output.name, values);
         });
     }
 };
 
 tflite.Node = class {
 
-    constructor(metadata, node, type, location, tensors) {
-        this._location = location;
-        this._type = type.custom ? {
+    constructor(metadata, node, type, identifier, tensors) {
+        this.name = '';
+        this.identifier = identifier;
+        this.type = type.custom ? {
             name: type.name
         } : metadata.type(type.name);
-        this._inputs = [];
-        this._outputs = [];
-        this._attributes = [];
+        this.inputs = [];
+        this.outputs = [];
+        this.attributes = [];
         if (node) {
+            const attributes = [];
             const inputs = Array.from(node.inputs || new Int32Array(0));
             for (let i = 0; i < inputs.length;) {
                 let count = 1;
                 let name = null;
                 let visible = true;
                 const values = [];
-                if (this._type && this._type.inputs && i < this._type.inputs.length) {
-                    const input = this._type.inputs[i];
+                if (this.type && this.type.inputs && i < this.type.inputs.length) {
+                    const input = this.type.inputs[i];
                     name = input.name;
                     if (input.list) {
                         count = inputs.length - i;
                     }
                     if (input.visible === false) {
                         visible = false;
                     }
@@ -315,172 +317,121 @@
                     const value = tensors.map(index);
                     if (value) {
                         values.push(value);
                     }
                 }
                 name = name ? name : (i + 1).toString();
                 i += count;
-                const argument = new tflite.Argument(name, values, visible);
-                this._inputs.push(argument);
+                const argument = new tflite.Argument(name, values, null, visible);
+                this.inputs.push(argument);
             }
             const outputs = Array.from(node.outputs || new Int32Array(0));
             for (let i = 0; i < outputs.length; i++) {
                 const index = outputs[i];
                 const value = tensors.map(index);
                 const values = value ? [value] : [];
                 let name = (i + 1).toString();
-                if (this._type && this._type.outputs && i < this._type.outputs.length) {
-                    const output = this._type.outputs[i];
+                if (this.type && this.type.outputs && i < this.type.outputs.length) {
+                    const output = this.type.outputs[i];
                     if (output && output.name) {
                         name = output.name;
                     }
                 }
                 const argument = new tflite.Argument(name, values);
-                this._outputs.push(argument);
+                this.outputs.push(argument);
             }
             if (type.custom && node.custom_options && node.custom_options.length > 0) {
                 let decoded = false;
                 if (node.custom_options_format === tflite.schema.CustomOptionsFormat.FLEXBUFFERS) {
                     try {
                         const reader = flexbuffers.BinaryReader.open(node.custom_options);
                         if (reader) {
                             const custom_options = reader.read();
                             if (Array.isArray(custom_options)) {
-                                const attribute = new tflite.Attribute(null, 'custom_options', custom_options);
-                                this._attributes.push(attribute);
+                                attributes.push([null, 'custom_options', custom_options]);
                                 decoded = true;
                             } else if (custom_options) {
                                 for (const [key, value] of Object.entries(custom_options)) {
                                     const schema = metadata.attribute(type.name, key);
-                                    const attribute = new tflite.Attribute(schema, key, value);
-                                    this._attributes.push(attribute);
+                                    attributes.push([schema, key, value]);
                                 }
                                 decoded = true;
                             }
                         }
                     } catch {
                         // continue regardless of error
                     }
                 }
                 if (!decoded) {
                     const schema = metadata.attribute(type.name, 'custom');
-                    const attribute = new tflite.Attribute(schema, 'custom', Array.from(node.custom_options));
-                    this._attributes.push(attribute);
+                    attributes.push([schema, 'custom', Array.from(node.custom_options)]);
                 }
             }
             const options = node.builtin_options;
             if (options) {
                 for (const [name, value] of Object.entries(options)) {
                     if (name === 'fused_activation_function' && value) {
                         if (value < 1 || value > 5) {
                             throw new tflite.Error(`Unsupported activation funtion index '${value}'.`);
                         }
                         const list = ['Unknown', 'Relu', 'ReluN1To1', 'Relu6', 'Tanh', 'SignBit'];
                         const type = list[value];
                         const node = new tflite.Node(metadata, null, {
                             name: type
                         }, null, []);
-                        this._chain = [node];
+                        this.chain = [node];
                     }
                     const schema = metadata.attribute(type.name, name);
-                    const attribute = new tflite.Attribute(schema, name, value);
-                    this._attributes.push(attribute);
+                    this.attributes.push([schema, name, value]);
                 }
             }
-        }
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get name() {
-        return '';
-    }
-
-    get location() {
-        return this._location;
-    }
-
-    get inputs() {
-        return this._inputs;
-    }
-
-    get outputs() {
-        return this._outputs;
-    }
-
-    get chain() {
-        return this._chain;
-    }
-
-    get attributes() {
-        return this._attributes;
-    }
-};
-
-tflite.Attribute = class {
-
-    constructor(metadata, name, value) {
-        this._name = name;
-        this._value = ArrayBuffer.isView(value) ? Array.from(value) : value;
-        this._type = metadata && metadata.type ? metadata.type : null;
-        if (this._name === 'fused_activation_function') {
-            this._visible = false;
-        }
-        if (this._type) {
-            this._value = tflite.Utility.enum(this._type, this._value);
-        }
-        if (metadata) {
-            if (metadata.visible === false) {
-                this._visible = false;
-            } else if (metadata.default !== undefined) {
-                value = this._value;
-                if (typeof value === 'function') {
-                    value = value();
+            this.attributes = attributes.map(([metadata, name, value]) => {
+                const type = metadata && metadata.type ? metadata.type : null;
+                value = ArrayBuffer.isView(value) ? Array.from(value) : value;
+                let visible = true;
+                if (name === 'fused_activation_function') {
+                    visible = false;
                 }
-                if (value === metadata.default) {
-                    this._visible = false;
+                if (type) {
+                    value = tflite.Utility.enum(type, value);
                 }
-            }
+                if (metadata) {
+                    if (metadata.visible === false) {
+                        visible = false;
+                    } else if (metadata.default !== undefined) {
+                        if (typeof value === 'function') {
+                            value = value();
+                        }
+                        if (value === metadata.default) {
+                            visible = false;
+                        }
+                    }
+                }
+                return new tflite.Argument(name, value, type, visible);
+            });
         }
     }
-
-    get name() {
-        return this._name;
-    }
-
-    get type() {
-        return this._type;
-    }
-
-    get value() {
-        return this._value;
-    }
-
-    get visible() {
-        return this._visible !== false;
-    }
 };
 
 tflite.Argument = class {
 
-    constructor(name, value, visible) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
         this.visible = visible !== false;
     }
 };
 
 tflite.Value = class {
 
     constructor(index, tensor, initializer, description, denotation) {
         const name = tensor.name || '';
         this.name = `${name}\n${index}`;
-        this.location = index.toString();
+        this.identifier = index.toString();
         this.type = tensor.type !== undefined && tensor.shape !== undefined ? new tflite.TensorType(tensor, denotation) : null;
         this.initializer = initializer;
         this.description = description;
         const quantization = tensor.quantization;
         if (quantization && (quantization.scale.length > 0 || quantization.zero_point.length > 0 || quantization.min.length > 0 || quantization.max.length)) {
             this.quantization = {
                 type: 'linear',
@@ -493,15 +444,15 @@
         }
     }
 };
 
 tflite.Tensor = class {
 
     constructor(index, tensor, buffer, stream, is_variable) {
-        this.location = index.toString();
+        this.identifier = index.toString();
         this.name = tensor.name;
         this.type = new tflite.TensorType(tensor);
         this.category = is_variable ? 'Variable' : '';
         this.encoding = this.type.dataType === 'string' ? '|' : '<';
         if (buffer && buffer.data && buffer.data.length > 0) {
             this._data = buffer.data.slice(0);
         } else if (buffer && buffer.offset !== 0n && buffer.size !== 0n) {
```

## netron/tnn.js

### js-beautify {}

```diff
@@ -140,35 +140,33 @@
 
     constructor(metadata, resources, layer, values) {
         this.inputs = [];
         this.outputs = [];
         this.attributes = [];
         this.name = layer.name;
         this.type = metadata.type(layer.type);
-        const attributeSchemas = this.type && this.type.attributes ? this.type && this.type.attributes.slice() : [];
-        const attributes = layer.attributes.slice();
-        while (attributes.length > 0) {
-            const metadata = attributeSchemas.shift();
+        for (let i = 0; i < layer.attributes.length;) {
+            const metadata = this.type && Array.isArray(this.type.attributes) ? this.type.attributes[i] : null;
             let name = '';
             let value = null;
             let type = '';
             let visible = true;
             if (metadata && metadata.type === 'int32[]' && metadata.size) {
-                const size = layer.attr[metadata.size];
-                value = attributes.splice(0, size).map((attribute) => parseInt(attribute.value, 10));
+                const size = parseInt(layer.attr[metadata.size], 10);
+                value = layer.attributes.slice(i, i + size).map((attribute) => parseInt(attribute.value, 10));
+                i += size;
             } else {
-                const attribute = attributes.shift();
-                name = attribute.key;
+                const attribute = layer.attributes[i];
+                name = attribute.key.toString();
                 value = attribute.value;
+                i += 1;
             }
             if (metadata) {
-                name = metadata.name;
-                if (metadata.type) {
-                    type = metadata.type;
-                }
+                name = metadata.name ? metadata.name : name;
+                type = metadata.type ? metadata.type : type;
                 switch (type) {
                     case '':
                         break;
                     case 'int32':
                         value = parseInt(value, 10);
                         break;
                     case 'float32':
@@ -176,21 +174,15 @@
                         break;
                     case 'int32[]':
                         value = value.map((v) => parseInt(v, 10));
                         break;
                     default:
                         throw new tnn.Error(`Unsupported attribute type '${type}'.`);
                 }
-                if (metadata && metadata.visible === false) {
-                    visible = false;
-                } else if (metadata.default !== undefined) {
-                    if (value === metadata.default || (value && value.toString() === metadata.default.toString())) {
-                        visible = false;
-                    }
-                }
+                visible = (metadata.visible === false) || (metadata.default !== undefined && (value === metadata.default || (value && value.toString() === metadata.default.toString()))) ? false : visible;
             }
             const argument = new tnn.Argument(name, value, type, visible);
             this.attributes.push(argument);
         }
 
         const inputs = layer.inputs;
         let inputIndex = 0;
```

## netron/torch.js

### js-beautify {}

```diff
@@ -175,17 +175,19 @@
             return new torch.Argument(`output${index === 0 ? '' : (index + 1).toString()}`, [output]);
         }));
     }
 };
 
 torch.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 torch.Value = class {
 
     constructor(name, type, initializer) {
         if (typeof name !== 'string') {
@@ -301,32 +303,42 @@
                 delete module.output_L;
                 break;
             default:
                 break;
         }
         this.attributes = [];
         if (module.__class__) {
-            for (const [key, obj] of Object.entries(module)) {
-                if (key === '_type') {
+            for (const [name, obj] of Object.entries(module)) {
+                if (name === '_type') {
                     continue;
                 }
                 if (Array.isArray(obj) && obj.every(((item) => item && item.__class__ && item.__class__.__module__ === 'nn'))) {
                     continue;
                 }
                 if (obj.__class__ && obj.__class__.__module__ === 'torch' && obj.__class__.__name__.endsWith('Tensor')) {
-                    initializers.push(new torch.Argument(key, [values.map('', null, new torch.Tensor(obj))]));
+                    const argument = new torch.Argument(name, [values.map('', null, new torch.Tensor(obj))]);
+                    initializers.push(argument);
                     continue;
                 }
-                if (key === 'modules') {
+                if (name === 'modules') {
                     continue;
                 }
                 if (obj.__class__ && obj.__class__.__module__ !== '' && obj.__class__.__name__ !== 'LuaFunction') {
                     continue;
                 }
-                const attribute = new torch.Attribute(metadata, type, key, obj);
+                let visible = name === 'train' ? false : true;
+                const schema = metadata.attribute(type, name);
+                if (schema) {
+                    if (schema.visible === false) {
+                        visible = false;
+                    } else if (schema.default !== undefined && Object.prototype.hasOwnProperty.call(schema, 'default')) {
+                        visible = false;
+                    }
+                }
+                const attribute = new torch.Argument(name, obj, null, visible);
                 this.attributes.push(attribute);
             }
         }
         this.inputs = [];
         if (inputs.length === 0 && this.name) {
             inputs.push(values.map(`${this.name}:in`));
         }
@@ -372,35 +384,14 @@
             delete module[`${name}_r`];
             delete module[`${name}_b`];
             delete module[`${name}_l`];
         }
     }
 };
 
-torch.Attribute = class {
-
-    constructor(metadata, type, name, value) {
-        this.name = name;
-        this.value = value;
-        if (name === 'train') {
-            this.visible = false;
-        }
-        metadata = metadata.attribute(type, name);
-        if (metadata) {
-            if (metadata.visible === false) {
-                this.visible = false;
-            } else if (Object.prototype.hasOwnProperty.call(metadata, 'default')) {
-                if (JSON.stringify(metadata.default) === JSON.stringify(this.value)) {
-                    this.visible = false;
-                }
-            }
-        }
-    }
-};
-
 torch.Tensor = class {
 
     constructor(tensor) {
         this.type = new torch.TensorType(tensor);
         this.encoding = '|';
         this._storage = tensor.storage;
         this._offset = tensor.storage_offset;
```

## netron/view.js

### js-beautify {}

```diff
@@ -2391,28 +2391,28 @@
         }
         const element = content.element;
         return Array.isArray(element) ? element : [element];
     }
 
     _update(stack) {
         const sidebar = this._element('sidebar');
+        const content = this._element('sidebar-content');
         const container = this._element('graph');
         const closeButton = this._element('sidebar-closebutton');
         closeButton.removeEventListener('click', this._closeSidebarHandler);
         this._host.document.removeEventListener('keydown', this._closeSidebarKeyDownHandler);
         if (stack) {
             this._stack = stack;
         } else if (this._stack.length > 0) {
             this._stack.pop();
         }
         if (this._stack.length > 0) {
             const item = this._stack[this._stack.length - 1];
             this._element('sidebar-title').innerHTML = item.title || '';
             closeButton.addEventListener('click', this._closeSidebarHandler);
-            const content = this._element('sidebar-content');
             if (typeof item.content === 'string') {
                 content.innerHTML = item.content;
             } else if (item.content instanceof Array) {
                 content.innerHTML = '';
                 for (const element of item.content) {
                     content.appendChild(element);
                 }
@@ -2424,14 +2424,16 @@
             sidebar.style.right = 0;
             sidebar.style.opacity = 1;
             this._host.document.addEventListener('keydown', this._closeSidebarKeyDownHandler);
             container.style.width = 'max(40vw, calc(100vw - 42em))';
         } else {
             sidebar.style.right = 'calc(0px - min(calc(100% * 0.6), 42em))';
             sidebar.style.opacity = 0;
+            const clone = content.cloneNode(true);
+            content.parentNode.replaceChild(clone, content);
             container.style.width = '100%';
             container.focus();
         }
     }
 };
 
 view.Control = class {
@@ -2529,16 +2531,16 @@
                 const value = list.filter((value) => value).join(' ');
                 this.addProperty('module', value, 'nowrap');
             }
         }
         if (node.name) {
             this.addProperty('name', node.name, 'nowrap');
         }
-        if (node.location) {
-            this.addProperty('location', node.location, 'nowrap');
+        if (node.identifier) {
+            this.addProperty('identifier', node.identifier, 'nowrap');
         }
         if (node.description) {
             this.addProperty('description', node.description);
         }
         if (node.device) {
             this.addProperty('device', node.device);
         }
@@ -2548,25 +2550,17 @@
             for (const entry of metadata) {
                 this._addAttribute(entry.name, entry);
             }
         }
         const attributes = node.attributes;
         if (Array.isArray(attributes) && attributes.length > 0) {
             this.addHeader('Attributes');
-            attributes.sort((a, b) => {
-                const au = a.name.toUpperCase();
-                const bu = b.name.toUpperCase();
-                if (au < bu) {
-                    return -1;
-                }
-                if (au > bu) {
-                    return +1;
-                }
-                return 0;
-            });
+            attributes.sort((a, b) => a.name.localeCompare(b.name, undefined, {
+                sensitivity: 'base'
+            }));
             for (const attribute of attributes) {
                 this._addAttribute(attribute.name, attribute);
             }
         }
         const inputs = node.inputs;
         if (Array.isArray(inputs) && inputs.length > 0) {
             this.addHeader('Inputs');
@@ -2895,26 +2889,26 @@
             }
             const tensor = name !== undefined;
             name = this._value.name ? this._value.name.split('\n').shift() : ''; // custom argument id
             this._hasId = name && !tensor ? true : false;
             this._hasCategory = initializer && initializer.category ? true : false;
             if (this._hasId || (!this._hasCategory && !type && !tensor)) {
                 this._hasId = true;
-                const nameLine = this.createElement('div', 'sidebar-item-value-line');
+                const element = this.createElement('div', 'sidebar-item-value-line');
                 if (typeof name !== 'string') {
                     throw new Error(`Invalid value identifier '${JSON.stringify(name)}'.`);
                 }
-                nameLine.innerHTML = `<span class='sidebar-item-value-line-content'>name: <b>${name || ' '}</b></span>`;
-                nameLine.addEventListener('pointerenter', () => this.emit('activate', this._value));
-                nameLine.addEventListener('pointerleave', () => this.emit('deactivate', this._value));
+                element.innerHTML = `<span class='sidebar-item-value-line-content'>name: <b>${name || ' '}</b></span>`;
+                element.addEventListener('pointerenter', () => this.emit('activate', this._value));
+                element.addEventListener('pointerleave', () => this.emit('deactivate', this._value));
                 if (!initializer) {
-                    nameLine.style.cursor = 'pointer';
-                    nameLine.addEventListener('click', () => this.emit('select', this._value));
+                    element.style.cursor = 'pointer';
+                    element.addEventListener('click', () => this.emit('select', this._value));
                 }
-                this._element.appendChild(nameLine);
+                this._element.appendChild(element);
             } else if (this._hasCategory) {
                 this._bold('category', initializer.category);
             } else if (type) {
                 this._code('tensor', type.toString().split('<').join('&lt;').split('>').join('&gt;'));
             }
         } catch (error) {
             super.error(error, false);
@@ -2967,31 +2961,34 @@
                             if (value) {
                                 content.push(`<pre style='margin: 4px 0 2px 0'>${value}</pre>`);
                             }
                             line.innerHTML = content.join('');
                             this._element.appendChild(line);
                         }
                     }
-                    const location = this._value.location;
-                    if (location !== undefined) {
-                        this._bold('location', location);
+                    const identifier = this._value.identifier;
+                    if (identifier !== undefined) {
+                        this._bold('identifier', identifier);
                     }
                     const layout = this._value.type ? this._value.type.layout : null;
                     if (layout) {
                         const layouts = new Map([
                             ['sparse', 'sparse'],
                             ['sparse.coo', 'sparse coo'],
                             ['sparse.csr', 'sparse csr'],
                             ['sparse.csc', 'sparse csc'],
                             ['sparse.bsr', 'sparse bsr'],
                             ['sparse.bsc', 'sparse bsc']
                         ]);
                         this._bold('layout', layouts.get(layout));
                     }
                     if (initializer) {
+                        if (initializer.location) {
+                            this._bold('location', initializer.location);
+                        }
                         this._tensor(initializer);
                     }
                 } catch (error) {
                     super.error(error, false);
                     this._info('ERROR', error.message);
                 }
             } else {
```

## netron/xmodel.js

### js-beautify {}

```diff
@@ -75,17 +75,19 @@
         }
         this.nodes = nodes.map((node) => new xmodel.Node(metadata, node, values));
     }
 };
 
 xmodel.Argument = class {
 
-    constructor(name, value) {
+    constructor(name, value, type, visible) {
         this.name = name;
         this.value = value;
+        this.type = type || null;
+        this.visible = visible !== false;
     }
 };
 
 xmodel.Value = class {
 
     constructor(name, node, initializer) {
         if (typeof name !== 'string') {
@@ -115,75 +117,52 @@
         this.outputs = [];
         this.attributes = [];
         this.chain = [];
         if (op_node.op_attr) {
             for (const [name, obj] of Object.entries(op_node.op_attr)) {
                 if (name === 'device') {
                     this.device = obj.string_value;
-                    continue;
-                }
-                if (name === 'workload') {
-                    continue;
-                }
-                if (name.startsWith('quant_in_') || name.startsWith('quant_out_')) {
-                    continue;
-                }
-                const value = xmodel.Utility.attribute(obj);
-                if (name === 'nonlinear' && value.value && value.value !== 'NONE' && value.value !== 0) {
-                    let activation = value.value;
-                    if (typeof activation === 'string') {
-                        activation = activation.toLowerCase();
-                    } else if (Number.isInteger(activation) && activation < 5) {
-                        activation = ['none', 'relu', 'prelu', 'leakyrelu', 'relu6'][activation];
+                } else if (name !== 'workload' && !name.startsWith('quant_in_') && !name.startsWith('quant_out_')) {
+                    const attr = xmodel.Utility.attribute(obj);
+                    if (name === 'nonlinear' && attr.value && attr.value !== 'NONE' && attr.value !== 0) {
+                        let activation = attr.value;
+                        if (typeof activation === 'string') {
+                            activation = activation.toLowerCase();
+                        } else if (Number.isInteger(activation) && activation < 5) {
+                            activation = ['none', 'relu', 'prelu', 'leakyrelu', 'relu6'][activation];
+                        } else {
+                            activation = JSON.stringify(activation);
+                        }
+                        const node = new xmodel.Node(metadata, {
+                            op_type: activation
+                        }, values);
+                        this.chain.push(node);
                     } else {
-                        activation = JSON.stringify(activation);
+                        const schema = metadata.attribute(this.type.name, name);
+                        const visible = (schema && schema.default !== undefined && schema.default === attr.value) ||
+                            (schema && Array.isArray(schema.default) && Array.isArray(this.value) && schema.default.length === attr.value.length && schema.default.every((value, index) => value === attr.value[index])) ? false : true;
+                        const attribute = new xmodel.Argument(name, attr.value, attr.type, visible);
+                        this.attributes.push(attribute);
                     }
-                    this.chain.push(new xmodel.Node(metadata, {
-                        op_type: activation
-                    }, values));
-                    continue;
                 }
-                const attribute = new xmodel.Attribute(metadata.attribute(this.type, name), name, value);
-                this.attributes.push(attribute);
             }
         }
         if (op_node.args) {
             for (const input of op_node.args) {
-                const args = input.arg_ops.map((arg_op) => values.map(arg_op));
-                const argument = new xmodel.Argument(input.arg_name, args);
+                const argument = new xmodel.Argument(input.arg_name, input.arg_ops.map((arg_op) => values.map(arg_op)));
                 this.inputs.push(argument);
             }
         }
         if (op_node.op_name) {
             const argument = new xmodel.Argument('output', [values.map(op_node.op_name)]);
             this.outputs.push(argument);
         }
     }
 };
 
-xmodel.Attribute = class {
-
-    constructor(metadata, name, attribute) {
-        this.name = name;
-        this.type = attribute.type;
-        this.value = attribute.value;
-        if (metadata) {
-            if (metadata.default !== undefined) {
-                if (metadata.default === this.value) {
-                    this.visible = false;
-                }
-                if (Array.isArray(metadata.default) && Array.isArray(this.value) &&
-                    metadata.default.length === this.value.length && metadata.default.every((value, index) => value === this.value[index])) {
-                    this.visible = false;
-                }
-            }
-        }
-    }
-};
-
 xmodel.TensorType = class {
 
     constructor(tensor) {
         switch (tensor.data_type) {
             case 0:
                 this.dataType = 'int';
                 break;
```

## Comparing `netron-7.6.8.dist-info/METADATA` & `netron-7.6.9.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: netron
-Version: 7.6.8
+Version: 7.6.9
 Summary: Viewer for neural network, deep learning, and machine learning models
 Home-page: https://github.com/lutzroeder/netron
 Author: Lutz Roeder
 Author-email: lutzroeder@users.noreply.github.com
 License: MIT
 Keywords: onnx,keras,tensorflow,tflite,coreml,mxnet,caffe,caffe2,torchscript,pytorch,ncnn,mnn,openvino,darknet,paddlepaddle,chainer,artificial intelligence,machine learning,deep learning,neural network,visualizer,viewer
 Classifier: Intended Audience :: Developers
```

## Comparing `netron-7.6.8.dist-info/RECORD` & `netron-7.6.9.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,152 +1,152 @@
 netron/__init__.py,sha256=4X_FliRM4GvcwqYDnJ7SHmJoR6u4vdcPBgzfGe62os0,1526
 netron/acuity-metadata.json,sha256=IBLd6SxrRI6rbznfzogXc_jO2CCQP7LRnuzpLzchgXI,57928
 netron/acuity.js,sha256=MNjDL7UgNY0x-Xz2c9qD8ggOqnyU7UyeGI6Jpuz9ToI,22154
 netron/armnn-metadata.json,sha256=YFuZrTItVAo2SaO8mHr5Gk9MW-hgUNyYY4lHgY8ZtKc,11404
 netron/armnn-schema.js,sha256=gQE-NdgIRKNbF1JGvKs9rEGaULmZaQHNK0VdotJedNo,99904
-netron/armnn.js,sha256=cHU5RFG2vqwVQUqX299tG542tbitrJbR6-MuaAT59vk,12186
-netron/barracuda.js,sha256=3arCUYRF06KxFB4SI97EITLm7bSNk-ivDGggetX-VbY,15640
+netron/armnn.js,sha256=IoMVCrNICk5_U3mqpM_RRMeOZ4SUmLiGzGSZzmEe8tA,12154
+netron/barracuda.js,sha256=12yWPngn4j0XVjUPclA72otVEa1nPBjvThimKlEZyE8,15386
 netron/base.js,sha256=z3WqUr9v2gmZcG7BtyvvGP-9hxEjZh0z8ROnfRzqbXg,26395
 netron/bigdl-metadata.json,sha256=TRtkhMaMeFVOIG7C7sB5cdedbGRifKEQFGQKjqikIBM,2017
 netron/bigdl-proto.js,sha256=-_PR7G6W8EUcjWFnt1HJq5aZgz0C6RIiL853qsqul84,23686
-netron/bigdl.js,sha256=FTkVeeCqwijtcGIgh4vnTmoHFzOaNXYqAhStataOhWI,11051
+netron/bigdl.js,sha256=8Y0Ig0jOiyFvvq3uEJ1LlF7unyFkZ57LnFTavtm0as4,11237
 netron/browser.js,sha256=RqpPMNoPyHAu1KuzbCp9YJn5OFjiOqPnwRaVG_kt8Qo,32794
 netron/caffe-metadata.json,sha256=PfjdGkv0ND0C_RRZTlBp8xU4dbO7IaRVsJswgfS6l-k,9505
 netron/caffe-proto.js,sha256=CoFmR-TfSKqScfwWtbOaPoePm_G-hD9JAnS82b5TMHY,182571
-netron/caffe.js,sha256=Ov4xvFuWiqUt8LJSBSRg1_Y_Zdu6UKKydIXtWoGloV0,25175
+netron/caffe.js,sha256=FYE1dl7DMJzwzpHYtU9bj-YPHZA-KKlSQhFOAdPgZgs,23542
 netron/caffe2-metadata.json,sha256=2uApNj06QES26k3krNU4UeLhnhihnLl9un09bd54saI,863689
 netron/caffe2-proto.js,sha256=6uwzZvAJgLlGS8B_Yj2moCrXGoRcGWrG5xVRgeLRVYI,59284
-netron/caffe2.js,sha256=OalQLvzzxQSuDkPZXCBTE3iVToEjPdnBnY8JifoVf-8,20638
+netron/caffe2.js,sha256=TYLPEGuQAjwdApWEko5NyE9054_QT-N1LAui9M5saEw,20687
 netron/cambricon.js,sha256=r42wY08SdjnKT46CUD5VhkPy3kPMC25gDpq9DpgV4C4,791
 netron/catboost.js,sha256=YAOVR9VOUcxvIfePiYZafr25TVS77wMimAo18j5UADQ,890
 netron/circle-metadata.json,sha256=WgyTiqN74uFLXLXN9NCmrXJ79FyxEIuKWAR_Whj7438,36814
 netron/circle-schema.js,sha256=zOlIYS10p6VFKXR8blWy_3x2H73Rfryo56UFNOrmjk4,121498
-netron/circle.js,sha256=3FoVA1Kw88HyQ7GByM2slh3rw82feZdW57wmQFAggaY,23748
+netron/circle.js,sha256=iiwEiQ2OMe4iJQk-k0I1UK0dL63CyFQ7DHjNFZMRDZM,23082
 netron/cntk-metadata.json,sha256=XTsJD8M0AvBUS8jYtOS_pfhJsXLNuRdltqy3jnp0Mjc,14193
 netron/cntk-proto.js,sha256=U8PNYGd6c-L3PQemRdQHnZ_k3FeWVyzvM2HhLvdGi4M,11085
-netron/cntk.js,sha256=ql4WdjVgOTpRJ1kXruuQYn1evSmBiWK7uDfu7eRujXA,42286
+netron/cntk.js,sha256=n1-TovB_PidAVb5mIGZkDlMkZ3gO7RNxjokGgSeAIJU,42418
 netron/coreml-metadata.json,sha256=6wmTgce8CbDepB53YCoPOB4GRuC7cYYomn8NmP_GKoQ,16093
 netron/coreml-proto.js,sha256=h0_w79S6iuQhCXfRb6wj_VHn3AwJdv15eWoFRDiAE78,673516
-netron/coreml.js,sha256=oSpiMlxx7TW6xluLnB4N0nKaplGXZIsys5WWOQ-jF8w,68689
-netron/dagre.js,sha256=WCQ6n1ENTkHs9gv_qJvqjv98WGPDVzNiGobNjeI8jDw,96165
+netron/coreml.js,sha256=aZdgkmfNPh7ERoUjASA3c4v74iIH9gDVAp-umG8xWVc,68675
+netron/dagre.js,sha256=iQR2Lmt1UKkKnCAXq1nd-DOW1szyzIBBLgjkq4SweO4,96272
 netron/darknet-metadata.json,sha256=dw1vThEJwGVlV74G2cvyzQ6v7LWoGdF_LAnUM77JfXk,20570
-netron/darknet.js,sha256=RrTYtvrEHQWydAZtGiQetCIbje1RmXDzQAVpzu_bAAw,55349
+netron/darknet.js,sha256=mOPVz-2Lo1JxeiojWZTo-UVGZnYCmNYAI3hFzsVquOI,53700
 netron/dl4j-metadata.json,sha256=wh1OJVSWT2PQtQRq35NanPXfNF8s0bspM2Ww573U8To,1417
 netron/dl4j.js,sha256=mNUItcANYwfGEZyKvYxTwI_fh1Ldd6LSj1orgIePX8g,15309
 netron/dlc-metadata.json,sha256=VKrDC_pYt3IvHyUMmBb3Rvw6W_UZVl9UV5A3k_FSJqE,2309
 netron/dlc-schema.js,sha256=tADvZw6_xeWcc3-VAPgpevWjp7t0uygNc_4csA-O2vQ,8427
-netron/dlc.js,sha256=AAdvpb6fi33I6YH0J6npquSs5mX8wM3g4Y40C_6TDH8,25980
+netron/dlc.js,sha256=xlMj1-zyiWGC8oB86Tm3bkCmABGn1k7TAflqNbvFcB8,25940
 netron/dnn-metadata.json,sha256=5-48ChRcuDJQ5WA6_c5xOYs66J3XjsPYbrz7LyH_d9E,1777
 netron/dnn-proto.js,sha256=3kcrw2CxIQRxM5quLXwa4_U-8Gvcsw1JGUv80xlUyUs,10997
-netron/dnn.js,sha256=uanlYELKSLULS8Ne6zLoHckgUnJpd0DV_8U_0hpFZaE,9189
+netron/dnn.js,sha256=s02GERxjcf5gxlsNHoA-mxQnlEBfSBveMjPBqaX6F7Y,9030
 netron/favicon.ico,sha256=o3hrI04KVfImdrgo9Ucs1f27tMPVjCiJzGogjeR8pHg,34494
 netron/flatbuffers.js,sha256=6oWZNnIprhdmXZeHoJjVzAnKHJu55UH3rwKBMEJ8vmA,16331
-netron/flax.js,sha256=ribOV_wDysghVyv4zzmYJvVyYX2-Sg3gnfqaafcQX0I,6287
+netron/flax.js,sha256=wp6gOfivovrA3ROnFJJ7U2xv7ZHSQILF0rXf5IibB98,6164
 netron/flexbuffers.js,sha256=25hz5VghxS2OnWFiahyGIfRmewY4FYAF07_nc4CP8w0,7479
 netron/flux-metadata.json,sha256=lK6y0flbBJakM3nkhtmqqPtuJrN4D2n9pM_k0MPDR0c,3
-netron/flux.js,sha256=fs-c7wgmAYTlHRyfJzf-On4LNWB5N3Q_JGDLY_qsiEo,2210
-netron/gguf.js,sha256=3s_PD1QaSUfmiWmg3Dmt2l8yNMTWaIOkhXN7wku4wMY,14767
+netron/flux.js,sha256=TZNC9Y1HBalLiDZ-4fMYFQaYGB-y1B5C01pBVLMyMiI,2098
+netron/gguf.js,sha256=qwntXCOS2pp3BMzh3aEJH8begPSJxDqPW9iLjBIdELQ,14645
 netron/grapher.css,sha256=H6Dl5PstUWGTtjPHGbj0TAG7bseGXewAZd7UpkBgECI,6275
 netron/grapher.js,sha256=p-i9OqgWKEjd7eYnkKpevh_Im0kJLMWe84SSvM_tWVs,32108
 netron/hailo-metadata.json,sha256=jW-ICek73g2UQxJrVRlte4XojbisPcRW4-GSw3Q_oPw,29515
-netron/hailo.js,sha256=yN8j39bVLX2SPBlctP3Slm5N7JjVBSytDQ5HnCyNSeQ,13692
+netron/hailo.js,sha256=q2VkqNv3EsDS6Ck_oVm1n7w2NgykCKQ4UafPTeVfqUs,13722
 netron/hdf5.js,sha256=Zt4DMutbnh0qp_G7itI7ijluOMAYS8WGvphrubTxbZ8,58492
 netron/hickle.js,sha256=JBEA_yEBJq8lgt6sNbdL987t7tTYieVzP4F1fpxoyjo,5068
 netron/icon.png,sha256=8PZX7X6-sLBgonyQTGelX60C661x3YZ13eIGcuXQcHc,58106
-netron/imgdnn.js,sha256=dz8BvNgVSY3nKKPQEDg9_Agb7ioZIW8nrYAmHSULFV8,1308
-netron/index.html,sha256=DGWNkeTcApcyq9iHwBNv7iY6cQYidYmWNsq-EoLxcvo,47289
-netron/index.js,sha256=7Z8tE6fvQ6SVMPlzESbJQko-b30AGABOEX8xc3CTa48,4491
+netron/imgdnn.js,sha256=qVvaGoj4Jj3yBj-Tsp1sRkaWrpDKoe1f-7HehE4wsss,1028
+netron/index.html,sha256=DmzwLct5ofWtoB6BpH6ssD3_Pvca_i6kkYmhoxNEe6c,47289
+netron/index.js,sha256=Tlu2unRWXY9-gVuzr9P0AleyqxdPW-g7R91Jq_uLY0Q,4557
 netron/json.js,sha256=_f2rB91K-wI6k-jY0_YIlHi4R9DlKlMg3Y0TuM6BgqQ,18560
 netron/keras-metadata.json,sha256=-k0EBkOYs5JWmQCFqQi4qsAmyXDahjWPWCaVCMkF2xc,242543
 netron/keras-proto.js,sha256=4796-RDrEDod_c4p5DayObWyRCSc0xR4KW7SvQAGVns,6112
-netron/keras.js,sha256=4rDF8nCltf1yM0mGkcSV81nb5lGsM8ax3DgxaFzjAPM,72448
-netron/kmodel.js,sha256=3dRZ6gq-dXh3cRYa7G_cAsqIArhqcUYdAy_1Gm7gDxA,61683
+netron/keras.js,sha256=6NPf9wR79BntBYconvUXDhA6yqo_bmtaNU_XFO1EKy8,70960
+netron/kmodel.js,sha256=E8kvTmSEwXhjHb0IQKglvVTd_ffaH3IEXD2Rc4MuMsU,61561
 netron/lasagne-metadata.json,sha256=UAy5q6DnjJWEav_Vo-G-OncwvHVuytNlTStpDJ8MB2U,244
-netron/lasagne.js,sha256=P4gBC7z4I4ay3rXAbdlNlXvJm5t_j4oKo1I485Z9kr8,6565
-netron/lightgbm.js,sha256=WbpzM1Og2QcKKoMIIgLgjaYgo8kTEIPtZj6saamVEu8,5305
+netron/lasagne.js,sha256=gDCVnrSw4XOx75ke7IhHPGOBS7BBoZ1KbkekRzW1FFI,6455
+netron/lightgbm.js,sha256=uV3ZES0jhPiG1bXX04TW7Q94GhZs2V4GqCwpP3w0I84,5179
 netron/mediapipe.js,sha256=N05uVi1RRTrzVPD_-Ov9j1CnxgLtHwLiHXX-yUq-n0A,10332
 netron/megengine-metadata.json,sha256=xCIX1972WjP0rDNPOkPd0L7wC0SluTsa2nOnTMs00mE,92025
 netron/megengine-schema.js,sha256=baVNm5dMiWoKYsHLE7GggqHe6ZX9Pm1Gtm85wdqOiEs,79468
-netron/megengine.js,sha256=sS8HUN30jqonP8oNNGsccepbbJVh48U2tQNQHCt2oWU,30357
-netron/mlir.js,sha256=SGl_O1V9P7egoAlUrdNbeCTGDLMLbaPib5GwbAP2YDM,42241
+netron/megengine.js,sha256=Lba4_XKpzdSN2Ir09C8ViU9-S84T-kDNDIe6vhC7Sb4,30571
+netron/mlir.js,sha256=OUbOZNt4Y8PAQidPyWeRnzE7TtkL2ofQkIIOArAvFN0,42106
 netron/mlnet-metadata.json,sha256=y_pySnY22XYqxvTVdLSEvDLfD76B0UZeB3uZiQp4dys,3423
-netron/mlnet.js,sha256=V6sdRbva8zifHsLCn1jmXTaRp-umbUp9pWmBNKTOS14,75764
+netron/mlnet.js,sha256=jbCt0z9c6gFwlpd9f3bBhe11UTf9ebiYgHlEXEu_V_U,75760
 netron/mnn-metadata.json,sha256=MquTy8tMAA1FpqrRRSpN4iUXSjRoyKEn33cvuuCNKWI,10268
 netron/mnn-schema.js,sha256=rne7SlgqeRx7L8m4tuHlD-9H8emeXkmbeyDqYNoIDR4,60632
-netron/mnn.js,sha256=xcjg3krKIkqJSU-t6n4Z2BJEGTdfO1mZxPb1kNveV6k,15187
-netron/modular.js,sha256=HfHhDvyScWFknpUFUqFAwx6MziBCNK5hf79Q4d8TOlQ,3163
+netron/mnn.js,sha256=jVpRpvxmilB51MSmOL5fD8uYF9VTGGyZQd2m0Y2DK08,15255
+netron/modular.js,sha256=qyKPKDkokSAoXSLqivsZubg1pEL0wZBn1jIJmsyEvjI,2247
 netron/mslite-metadata.json,sha256=fq8SEE83c6AJBgefdKgfHrXjURdcRqo9MBIuEoSFzj0,85645
 netron/mslite-schema.js,sha256=A4ng01GO1RdZk0JGFFZPzZTiPJ040A_NZYraGgD3_JI,164705
-netron/mslite.js,sha256=NuyZkV7eCKsgpM9bPhlTpm7A7iSu4t2jip_P8hKIFak,12405
+netron/mslite.js,sha256=hlNn66kr6C7YldBN0Tw9YckLRV8OnfCsDA6jmrIxSWE,12464
 netron/mxnet-metadata.json,sha256=sf1taquijGWKNTAkxVbDMAk4wbkiZ-IYkkYekHxtKfc,11884
-netron/mxnet.js,sha256=5sob4JMeDXB_8g-ZEfuLA4ZUWT3RWKBgCmgEr0Bznt8,38395
+netron/mxnet.js,sha256=JX0DPnDaEu87XTmDMI5nLWlUDjAFEXWhTsGvBy_lh7U,37333
 netron/ncnn-metadata.json,sha256=_B9UHBJ0PdkbeVcktCkjZnXqSVBe2OvTld-SkTHOqlw,30967
 netron/ncnn.js,sha256=Vs_gqeDXLKPH-VuJg6JGy0JeR4F9FcGvVHSDy1zyrK8,36876
 netron/nnabla-metadata.json,sha256=KWC3Q70brr61KJyuikki68VoaHIPJerE7F6yXvgD030,296983
 netron/nnabla-proto.js,sha256=VIbcVnPcaTKm9oJ5jKjOYesz2In1eHIlSJJvtLDZ0no,427254
-netron/nnabla.js,sha256=G9JBicqbicARZtwUHo3emgJo-zRDhpaRStyjbNtYnic,12563
+netron/nnabla.js,sha256=hgJk06y_kGlonaCmyCYEw0sBva1HqnXZKPucdWT5IwQ,12186
 netron/nnc.js,sha256=-xLgq4hpk3Z75TP5SePGnj7BzNpwoROcOR2boQntnRo,678
 netron/nnef.js,sha256=biv-0smiaCBWzH5Vl9ifJN0nhokEFdXilJXM8_zB8Z0,2316
-netron/numpy.js,sha256=gpKX6DjcrYcBDxUJBplm8-7jmlopBhT293KT3HFbJP4,13434
+netron/numpy.js,sha256=5nX9gNJxNu6FoggxI5I21Eqy4hzozd5bYzzSXLwSuNc,13235
 netron/om-metadata.json,sha256=s6JIqi9Uce3_t4OLBthFyn-bT1cs0xTcrXm-0uesTVQ,53484
 netron/om-proto.js,sha256=k9u_2WoxkvjTrTTlLJUt05qXQIceJDrJbwlQj45Xmfg,35979
-netron/om.js,sha256=QvzOrBqNIatIqCj7z_gd1RoKnnyt5Ypc_1y0EEzzVrM,32645
+netron/om.js,sha256=23eLJbBDq7uC_wHU7QaHDqqsDPARmfE6RYbxy_0vWQQ,32676
 netron/onednn-metadata.json,sha256=ZzCrrVEwXx36AWZ_TbOLa6PM-VL4LpEit0u35yj_-LU,6818
-netron/onednn.js,sha256=iWPgKZcGReBljt_MTpqEyngKOaKUp-1kx7DdEmf9uPU,11926
+netron/onednn.js,sha256=YE6bKgNt-40IrtvT6jdna1T_LWGJcrC5htTA0cz2Clw,10709
 netron/onnx-metadata.json,sha256=gZJu7SladZa0FKTn6RcTnO96DSzPvKhbsyY-wyitOKY,3895258
 netron/onnx-proto.js,sha256=tRIZWygX1mOTYEKSTSJdRSMoYAvCW_wEZPYlZFq8P6U,60553
 netron/onnx-schema.js,sha256=hNeNUttjX-okeIOVO1htco_bSRFGTnOMc7LrAbDEVrU,14697
-netron/onnx.js,sha256=oNsIR66QGtDfREmeIwEiVs9UJuYhGYLdNF_vETWoBd4,107063
+netron/onnx.js,sha256=U83H4I6n0jjoIxuU1vr1ZvIptxH34iHVSPaEI80yLj4,107195
 netron/onnx.py,sha256=GkNnqLXIZjHMviBblu_XorcDKrNcvmVZ0A-Yxg5l2Hg,9053
 netron/openvino-metadata.json,sha256=APn-Gb5Qi3GvP-1Ye5dduhWbvywWAdMbem1tKfyJnqk,87071
-netron/openvino.js,sha256=OC4JLwmSMnIRp99SrXI0pZbg6wQyc_GIBGAbpPYbURs,37370
+netron/openvino.js,sha256=Zxmo87xplGb4TQNm4HFmKAJGBJbhPY76CO0hVhd8ou4,38357
 netron/paddle-metadata.json,sha256=iyV8jUl7AhSOMTVcWLrChsBqS1l8iqGYl99KLYFl93w,2894
 netron/paddle-proto.js,sha256=hwTL87STW8GQuexIn4mOEzYz64FQhMWwcwTmRZ7UGSE,57979
 netron/paddle-schema.js,sha256=3JL2gHNkxPWvt5Z4Paz7Qf9FRKYRrdhX6ODUm4eyiKs,17792
 netron/paddle.js,sha256=_lyrSU8KXYmNm1WMEJr27LSsTl5tFqDmZ5rcv8FNzZ8,37036
 netron/pickle.js,sha256=CaITmtpqq9AejxvV6M5A2bsBoPOpMbWyI8KdUFJxq8Y,8813
 netron/protobuf.js,sha256=sLCllUsnf5Rj9IF9JmRcPB50ORNOiIHCNmP5yc8Jrgs,43012
-netron/python.js,sha256=TSBAw1oF37XkpA3VGre6Ze19WlU3HWTOZVRITkyENS8,382216
-netron/pytorch-metadata.json,sha256=xRb9fZhQ4ANrH9dUCarQV5UBYYCH_8habD6oai_QyzU,427041
+netron/python.js,sha256=Kx5btEv9Ocd6aeGqsWPSI0On5KVxjgkOyOBnOnRGxow,385110
+netron/pytorch-metadata.json,sha256=-pF_InDw1QW-5soHbPSxa6Tps-Hfcx7nUfDkzkjlS7E,427262
 netron/pytorch-schema.js,sha256=ycNASGTpMiuewGSs732006hBDL3VVN4PY9rLlQ4xqy0,25351
-netron/pytorch.js,sha256=9ODs4ysa9NiAb9EWdiLaYRHZWM8z19ZVSx-iEAc6q-Q,191197
+netron/pytorch.js,sha256=0u3Aya992kyAk7gmV84RXIehuFVR67YUKaex6dukEuk,191193
 netron/pytorch.py,sha256=gkEnA4OGqooxARhnsEZfzDYmAsycMSTkLXIB1hMJm9Y,24259
 netron/rknn-metadata.json,sha256=jhqFzxfj8LHEJS03GjQy7oBfeuXY8Rr3MTWYwix8Rk0,6464
 netron/rknn-schema.js,sha256=9BoIHqA-Q0rO6K4iArJ3eo6vAznXAQxHzvCKcIKSyBI,3957
-netron/rknn.js,sha256=uYmRV6evn8JepV12n1N8lebbRQPPxe07CDyzyhNCyp0,24930
-netron/safetensors.js,sha256=b0w9TuR1KHVpgI7MOqNxZuJddYny5XtEsA21CWrLuqM,7507
+netron/rknn.js,sha256=6_1wIEfXW8fAb9AvFWZteWdYGjYFwF83Xm3CQJ4Tqgc,23478
+netron/safetensors.js,sha256=OR9bEQKgl6oHjfXSiuiUyKB6DA9EpB2sFTYsV86Qxck,7477
 netron/sentencepiece-proto.js,sha256=oKiEyJfCONIQel1fVmcTalD5sJzEh0A1-Kou5PysSZ4,25450
 netron/sentencepiece.js,sha256=UcLCdDe_VwAZFOqSAYM73G7RTxgA61AipIGgyScvbfE,3083
-netron/server.js,sha256=lGMEnnHngn4N_rrrQ97riIVIgT4qhbsU25_W6INWUNU,5799
-netron/server.py,sha256=-N6Ibp79jP9fBi_d7AlRnkC3qBfBulSGn_uw0fLTpak,11894
+netron/server.js,sha256=JvKSl7Dcc6BhMq6as3CqESXyq5L6lDE0PdNmvQMqbCE,4270
+netron/server.py,sha256=F6WckWKeNm0ZCv3Cubk4zqMidOUepzXz075MbzSmD8M,11894
 netron/sklearn-metadata.json,sha256=y22q4MIRWLGjAZhqE6pfiNvHqLL8FHbEG7kldiETEI4,162764
-netron/sklearn.js,sha256=F3g6ppMz9QVzDMyX434P44nP8mWLWRNiiQIKMt4kuqM,14143
+netron/sklearn.js,sha256=CpaTCuL8kTK38MHq59hJYkfQ2TngPf995_Xkl9sQY_o,13899
 netron/tar.js,sha256=1HAnG5kK0ZIV4u3bKk5idjQ5tyr6CfRSz44GM2LpaiE,4821
 netron/tengine-metadata.json,sha256=v4dIwOf9t_f1bhYkJBORa71SBWlYuwi3LuZZJQjcYGY,27914
-netron/tengine.js,sha256=mB7tvsr6etdmJjhRgTrse_sA_W09m4ihFCtMwsqIRnQ,25771
-netron/tensorrt.js,sha256=Ka3tbE-Iy2Rf10EwRLqeZLoL5kEeLgElypch2ZjbFU8,6125
+netron/tengine.js,sha256=8dR5xKqaLNmcWNNgfOKVvGeaOfz0iKsM0JPYj6tY8xk,25435
+netron/tensorrt.js,sha256=eL8MlensT9zpX1RD8Qf4kgpQuk_A37kk8hO1t9mFYxk,5842
 netron/text.js,sha256=p1057Jtqzhm4o3Jd3FJQ_XW7bMgLgBSLVrwb0x7YFWs,11033
 netron/tf-metadata.json,sha256=WPX1MfDr8KoPoN0odV1GFL9mfTwMInwml-Nt6-olCDw,2285490
 netron/tf-proto.js,sha256=3oZG557XTY748M92W0e4TzLTcABzCeKX8WpNpkjYttU,354531
-netron/tf.js,sha256=EhuhZOzKQIJE-rAzTXZIsLBj7leQDcWKWMm27d2cVKc,104036
+netron/tf.js,sha256=YQYjdjeBHVjbbBujdWJUvydEtz3B8LMk2ri2RXX-LS0,104922
 netron/tflite-metadata.json,sha256=Gmua8HdRI6cJFDfDELu63qv2qWq53BZS4uMo5l2eBDM,37054
 netron/tflite-schema.js,sha256=TA_fF2oGBjKc8FOsmJWYvZVbryE669XfBcbb8FJnUiU,136338
-netron/tflite.js,sha256=O7wH1zk2QokuArJSA5kZwHAuLrhOIRPEbcIC1doqNyI,24205
+netron/tflite.js,sha256=L1HPnjVXSCvNSCb7q2gC51cEMAQrsd9-o3cnhL7-ayU,23539
 netron/tnn-metadata.json,sha256=lH6FZTYbjbV3CE_l13M6m8EF3D0Ryao80RdjRsiY-gk,20444
-netron/tnn.js,sha256=PMQBFvJkxVCUUQiiFhX5MGbbToXIR04K2DgllZl0WFo,24994
+netron/tnn.js,sha256=Ql45qRBtwUmV5LRzCO24mvoa4Hz_YKwi2fY0YnduSzU,24817
 netron/torch-metadata.json,sha256=fj2b1n_Ih7eZdst4ohdUEAL5T3XmjTMlkUBmUo3Ogng,12510
-netron/torch.js,sha256=IBJCL70ZD1s6vZKFwtie8AdeVVSR52tzWI1cG4FoAic,39029
+netron/torch.js,sha256=87ImP-F9C9q9WDQaUgeldO5Hh9P9so6Q5KFpUx0PLek,38994
 netron/uff-metadata.json,sha256=kVCe02DZKfSoTgwqfjh18jQcImre1KcYkg76_WNOagI,2333
 netron/uff-proto.js,sha256=XxBojvmiK4j74cfc6fn9PVbYMhRf0JeXvWKrgtZkjNs,29834
 netron/uff.js,sha256=QiFM5aYoLjusUumQpbZTPHo-DdScso278orJwtfrGts,11034
-netron/view.js,sha256=cBWl75jiHgkKRF_1Mmpu6FaS9Cuh6HKBFKQ1y24JuG0,261808
+netron/view.js,sha256=3ru9uL8l38qatZnicfqbeN9ecRs6hGsv444sN9yQqLU,261842
 netron/weka.js,sha256=AdJjzWIyUtp8vB_NzfJfflFEcM_QY4xeKgJk2FJ-gqg,7839
 netron/worker.js,sha256=Bic5ZRsrhNF7H4-1gT3FGdF9h-msPS9YWgtk7r29UhM,782
 netron/xml.js,sha256=doYU8nRJ5_tJv-dvR95MssfSNUPF1sNFQNs39oovDak,63818
 netron/xmodel-proto.js,sha256=UaG_sFDu0s93zA2JXm8OpAH8ctQ0J5_H3c9E2zTNiYs,54312
-netron/xmodel.js,sha256=vuCLwc4UfvEkKMkL1zAbx7qioQz7m7WQ6EKwUsWmoMs,13664
+netron/xmodel.js,sha256=ayE5Go853hQQaa5L4E98yX-F74KKBsxpizyBwMheqTM,13420
 netron/zip.js,sha256=XsGiv36zt3WzkA6IBJM1O2O_p68M-GDkjoG8G9uMCBw,32712
-netron-7.6.8.dist-info/METADATA,sha256=pPLYejnN9P_d5WIzQ0SdDQgzLocDO4wueYBs93QQHs8,1447
-netron-7.6.8.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-netron-7.6.8.dist-info/entry_points.txt,sha256=3fHM6H_AIEjt21838iCMZ72hmRqtnNTuL66UnCIOSpU,39
-netron-7.6.8.dist-info/top_level.txt,sha256=qt4XhfLsmugdsjAczetcmraULS1GexprL8Ruo2YQubU,7
-netron-7.6.8.dist-info/RECORD,,
+netron-7.6.9.dist-info/METADATA,sha256=qAuVngQnY8onU8UTZuvIvWnT1ud-kGxD0U5t-ZPPSIQ,1447
+netron-7.6.9.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+netron-7.6.9.dist-info/entry_points.txt,sha256=3fHM6H_AIEjt21838iCMZ72hmRqtnNTuL66UnCIOSpU,39
+netron-7.6.9.dist-info/top_level.txt,sha256=qt4XhfLsmugdsjAczetcmraULS1GexprL8Ruo2YQubU,7
+netron-7.6.9.dist-info/RECORD,,
```

