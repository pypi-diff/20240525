# Comparing `tmp/broken_source-0.2.1-py3-none-any.whl.zip` & `tmp/broken_source-0.3.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,26 @@
-Zip file size: 645675 bytes, number of entries: 117
--rw-r--r--  2.0 unx     1040 b- defN 20-Feb-02 00:00 Broken/Types.py
--rw-r--r--  2.0 unx     4020 b- defN 20-Feb-02 00:00 Broken/__init__.py
--rw-r--r--  2.0 unx    22411 b- defN 20-Feb-02 00:00 Broken/__main__.py
--rw-r--r--  2.0 unx    11807 b- defN 20-Feb-02 00:00 Broken/Core/BrokenEnum.py
+Zip file size: 642081 bytes, number of entries: 115
+-rw-r--r--  2.0 unx     1146 b- defN 20-Feb-02 00:00 Broken/Types.py
+-rw-r--r--  2.0 unx     4267 b- defN 20-Feb-02 00:00 Broken/__init__.py
+-rw-r--r--  2.0 unx    22547 b- defN 20-Feb-02 00:00 Broken/__main__.py
+-rw-r--r--  2.0 unx    16073 b- defN 20-Feb-02 00:00 Broken/Core/BrokenEnum.py
 -rw-r--r--  2.0 unx     2586 b- defN 20-Feb-02 00:00 Broken/Core/BrokenLogging.py
--rw-r--r--  2.0 unx    18629 b- defN 20-Feb-02 00:00 Broken/Core/BrokenPath.py
+-rw-r--r--  2.0 unx    19509 b- defN 20-Feb-02 00:00 Broken/Core/BrokenPath.py
 -rw-r--r--  2.0 unx     4011 b- defN 20-Feb-02 00:00 Broken/Core/BrokenPlatform.py
--rw-r--r--  2.0 unx     1741 b- defN 20-Feb-02 00:00 Broken/Core/BrokenProfiler.py
--rw-r--r--  2.0 unx    12963 b- defN 20-Feb-02 00:00 Broken/Core/BrokenProject.py
--rw-r--r--  2.0 unx     3364 b- defN 20-Feb-02 00:00 Broken/Core/BrokenResolution.py
--rw-r--r--  2.0 unx     7259 b- defN 20-Feb-02 00:00 Broken/Core/BrokenScheduler.py
--rw-r--r--  2.0 unx     2221 b- defN 20-Feb-02 00:00 Broken/Core/BrokenSpinner.py
+-rw-r--r--  2.0 unx     1665 b- defN 20-Feb-02 00:00 Broken/Core/BrokenProfiler.py
+-rw-r--r--  2.0 unx    13333 b- defN 20-Feb-02 00:00 Broken/Core/BrokenProject.py
+-rw-r--r--  2.0 unx     6313 b- defN 20-Feb-02 00:00 Broken/Core/BrokenResolution.py
+-rw-r--r--  2.0 unx     7313 b- defN 20-Feb-02 00:00 Broken/Core/BrokenScheduler.py
+-rw-r--r--  2.0 unx     2220 b- defN 20-Feb-02 00:00 Broken/Core/BrokenSpinner.py
 -rw-r--r--  2.0 unx     3783 b- defN 20-Feb-02 00:00 Broken/Core/BrokenThread.py
 -rw-r--r--  2.0 unx     2475 b- defN 20-Feb-02 00:00 Broken/Core/BrokenTorch.py
--rw-r--r--  2.0 unx     3741 b- defN 20-Feb-02 00:00 Broken/Core/BrokenTyper.py
--rw-r--r--  2.0 unx     4348 b- defN 20-Feb-02 00:00 Broken/Core/BrokenUtils.py
--rw-r--r--  2.0 unx     9571 b- defN 20-Feb-02 00:00 Broken/Core/__init__.py
--rw-r--r--  2.0 unx     8147 b- defN 20-Feb-02 00:00 Broken/Core/Staging/BrokenDotmap.py
+-rw-r--r--  2.0 unx     3460 b- defN 20-Feb-02 00:00 Broken/Core/BrokenTyper.py
+-rw-r--r--  2.0 unx     4612 b- defN 20-Feb-02 00:00 Broken/Core/BrokenUtils.py
+-rw-r--r--  2.0 unx    11194 b- defN 20-Feb-02 00:00 Broken/Core/__init__.py
+-rw-r--r--  2.0 unx     8081 b- defN 20-Feb-02 00:00 Broken/Core/Staging/BrokenDotmap.py
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 Broken/Core/Staging/__init__.py
 -rw-r--r--  2.0 unx    18413 b- defN 20-Feb-02 00:00 Broken/Core/Staging/umidi.py
 -rw-r--r--  2.0 unx     1736 b- defN 20-Feb-02 00:00 Broken/Core/Staging/Dotmap/BaseLoader.py
 -rw-r--r--  2.0 unx    12082 b- defN 20-Feb-02 00:00 Broken/Core/Staging/Dotmap/BrokenDotmap.py
 -rw-r--r--  2.0 unx      368 b- defN 20-Feb-02 00:00 Broken/Core/Staging/Dotmap/Readme.md
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 Broken/Core/Staging/Dotmap/__init__.py
 -rw-r--r--  2.0 unx     3568 b- defN 20-Feb-02 00:00 Broken/Core/Staging/Dotmap/__test__.py
@@ -37,83 +37,81 @@
 -rw-r--r--  2.0 unx      856 b- defN 20-Feb-02 00:00 Broken/Loaders/LoaderString.py
 -rw-r--r--  2.0 unx      546 b- defN 20-Feb-02 00:00 Broken/Loaders/__init__.py
 -rw-r--r--  2.0 unx     4765 b- defN 20-Feb-02 00:00 Broken/Resources/Fonts/DejaVu License.txt
 -rw-r--r--  2.0 unx   757076 b- defN 20-Feb-02 00:00 Broken/Resources/Fonts/DejaVuSans.ttf
 -rw-r--r--  2.0 unx     8764 b- defN 20-Feb-02 00:00 Broken/Resources/Images/Broken.ico
 -rw-r--r--  2.0 unx    15418 b- defN 20-Feb-02 00:00 Broken/Resources/Images/Broken.png
 -rw-r--r--  2.0 unx     1444 b- defN 20-Feb-02 00:00 Broken/Resources/Images/Broken.svg
--rw-r--r--  2.0 unx     3804 b- defN 20-Feb-02 00:00 Broken/Tests/Enum.py
 -rw-r--r--  2.0 unx       76 b- defN 20-Feb-02 00:00 Broken/Vectron/__init__.py
--rw-r--r--  2.0 unx     7851 b- defN 20-Feb-02 00:00 DepthFlow/DepthFlow.py
--rw-r--r--  2.0 unx      324 b- defN 20-Feb-02 00:00 DepthFlow/__init__.py
--rw-r--r--  2.0 unx      317 b- defN 20-Feb-02 00:00 DepthFlow/__main__.py
+-rw-r--r--  2.0 unx      528 b- defN 20-Feb-02 00:00 DepthFlow/CustomScene.py
+-rw-r--r--  2.0 unx     8874 b- defN 20-Feb-02 00:00 DepthFlow/DepthFlow.py
+-rw-r--r--  2.0 unx      387 b- defN 20-Feb-02 00:00 DepthFlow/__init__.py
+-rw-r--r--  2.0 unx      257 b- defN 20-Feb-02 00:00 DepthFlow/__main__.py
 -rw-r--r--  2.0 unx    14623 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Images/DepthFlow.png
 -rw-r--r--  2.0 unx     1445 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Images/DepthFlow.svg
--rw-r--r--  2.0 unx     2477 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Shaders/DepthFlow.frag
--rw-r--r--  2.0 unx     2499 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Shaders/DepthFlow2D.frag
--rw-r--r--  2.0 unx     1688 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Shaders/DepthFlowMarch.frag
--rw-r--r--  2.0 unx     2999 b- defN 20-Feb-02 00:00 Pianola/Pianola.py
+-rw-r--r--  2.0 unx     2803 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Shaders/DepthFlow.frag
+-rw-r--r--  2.0 unx     2495 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Shaders/Deprecated/DepthFlow2D.frag
+-rw-r--r--  2.0 unx     1684 b- defN 20-Feb-02 00:00 DepthFlow/Resources/Shaders/Deprecated/DepthFlowMarch.frag
+-rw-r--r--  2.0 unx     3399 b- defN 20-Feb-02 00:00 Pianola/Pianola.py
 -rw-r--r--  2.0 unx      280 b- defN 20-Feb-02 00:00 Pianola/__init__.py
--rw-r--r--  2.0 unx      297 b- defN 20-Feb-02 00:00 Pianola/__main__.py
+-rw-r--r--  2.0 unx      243 b- defN 20-Feb-02 00:00 Pianola/__main__.py
 -rw-r--r--  2.0 unx    12579 b- defN 20-Feb-02 00:00 Pianola/Resources/Images/Pianola.png
 -rw-r--r--  2.0 unx     3038 b- defN 20-Feb-02 00:00 Pianola/Resources/Images/Pianola.svg
--rw-r--r--  2.0 unx    27430 b- defN 20-Feb-02 00:00 Pianola/Resources/Midis/Hopeless Sparkle.mid
--rw-r--r--  2.0 unx     8171 b- defN 20-Feb-02 00:00 Pianola/Resources/Shaders/Pianola.frag
+-rw-r--r--  2.0 unx     8189 b- defN 20-Feb-02 00:00 Pianola/Resources/Shaders/Pianola.frag
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 ShaderFlow/Imgui.py
 -rw-r--r--  2.0 unx     2568 b- defN 20-Feb-02 00:00 ShaderFlow/Message.py
--rw-r--r--  2.0 unx     3215 b- defN 20-Feb-02 00:00 ShaderFlow/Module.py
+-rw-r--r--  2.0 unx     2979 b- defN 20-Feb-02 00:00 ShaderFlow/Module.py
 -rw-r--r--  2.0 unx     3855 b- defN 20-Feb-02 00:00 ShaderFlow/Notes.py
--rw-r--r--  2.0 unx    39206 b- defN 20-Feb-02 00:00 ShaderFlow/Scene.py
--rw-r--r--  2.0 unx    13833 b- defN 20-Feb-02 00:00 ShaderFlow/Shader.py
--rw-r--r--  2.0 unx    15278 b- defN 20-Feb-02 00:00 ShaderFlow/Texture.py
+-rw-r--r--  2.0 unx    45131 b- defN 20-Feb-02 00:00 ShaderFlow/Scene.py
+-rw-r--r--  2.0 unx    13816 b- defN 20-Feb-02 00:00 ShaderFlow/Shader.py
+-rw-r--r--  2.0 unx    15876 b- defN 20-Feb-02 00:00 ShaderFlow/Texture.py
 -rw-r--r--  2.0 unx     4187 b- defN 20-Feb-02 00:00 ShaderFlow/Variable.py
 -rw-r--r--  2.0 unx      349 b- defN 20-Feb-02 00:00 ShaderFlow/__init__.py
--rw-r--r--  2.0 unx     3269 b- defN 20-Feb-02 00:00 ShaderFlow/__main__.py
+-rw-r--r--  2.0 unx     3216 b- defN 20-Feb-02 00:00 ShaderFlow/__main__.py
 -rw-r--r--  2.0 unx    12816 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Audio.py
--rw-r--r--  2.0 unx     3160 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Bouncing.py
--rw-r--r--  2.0 unx    17597 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Camera.py
--rw-r--r--  2.0 unx     8763 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Dynamics.py
+-rw-r--r--  2.0 unx     3144 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Bouncing.py
+-rw-r--r--  2.0 unx    17526 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Camera.py
+-rw-r--r--  2.0 unx     9121 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Dynamics.py
 -rw-r--r--  2.0 unx     2332 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Frametimer.py
--rw-r--r--  2.0 unx     1494 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Keyboard.py
--rw-r--r--  2.0 unx     2475 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Noise.py
--rw-r--r--  2.0 unx    14040 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Piano.py
--rw-r--r--  2.0 unx    11396 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Spectrogram.py
--rw-r--r--  2.0 unx     7203 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Video.py
--rw-r--r--  2.0 unx     3088 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Waveform.py
+-rw-r--r--  2.0 unx     1473 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Keyboard.py
+-rw-r--r--  2.0 unx     2459 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Noise.py
+-rw-r--r--  2.0 unx    14761 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Piano.py
+-rw-r--r--  2.0 unx    11360 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Spectrogram.py
+-rw-r--r--  2.0 unx     7209 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Video.py
+-rw-r--r--  2.0 unx     3094 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/Waveform.py
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 ShaderFlow/Modules/__init__.py
--rw-r--r--  2.0 unx     3503 b- defN 20-Feb-02 00:00 ShaderFlow/Optional/Monocular.py
+-rw-r--r--  2.0 unx     3703 b- defN 20-Feb-02 00:00 ShaderFlow/Optional/Monocular.py
 -rw-r--r--  2.0 unx        2 b- defN 20-Feb-02 00:00 ShaderFlow/Optional/OpticalFlow.py
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 ShaderFlow/Optional/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/__init__.py
 -rw-r--r--  2.0 unx    20132 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Images/ShaderFlow.png
 -rw-r--r--  2.0 unx     1448 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Images/ShaderFlow.svg
--rw-r--r--  2.0 unx    10171 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/Demo.py
+-rw-r--r--  2.0 unx    10658 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/Demo.py
 -rw-r--r--  2.0 unx      495 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Bars.frag
 -rw-r--r--  2.0 unx     1285 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Bouncing.frag
--rw-r--r--  2.0 unx     1278 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Multipass.frag
+-rw-r--r--  2.0 unx      518 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/MotionBlur.frag
+-rw-r--r--  2.0 unx     1276 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Multipass.frag
 -rw-r--r--  2.0 unx     1380 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/RayMarch.frag
 -rw-r--r--  2.0 unx     2399 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/ShaderToy.frag
--rw-r--r--  2.0 unx      525 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Temporal.frag
--rw-r--r--  2.0 unx      115 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Video.frag
--rw-r--r--  2.0 unx     1654 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Visualizer.frag
+-rw-r--r--  2.0 unx      113 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Video.frag
+-rw-r--r--  2.0 unx     1639 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Visualizer.frag
 -rw-r--r--  2.0 unx      341 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Waveform.frag
--rw-r--r--  2.0 unx     1030 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Life/Simulation.glsl
--rw-r--r--  2.0 unx      985 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Life/Visuals.glsl
+-rw-r--r--  2.0 unx     1032 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Life/Simulation.glsl
+-rw-r--r--  2.0 unx      975 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Scenes/Examples/GLSL/Life/Visuals.glsl
 -rw-r--r--  2.0 unx     1618 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Fragment/Default.glsl
 -rw-r--r--  2.0 unx       79 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Fragment/Final.glsl
 -rw-r--r--  2.0 unx      895 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Fragment/Loading.frag
 -rw-r--r--  2.0 unx      574 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Fragment/Missing.glsl
--rw-r--r--  2.0 unx     5079 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Include/Camera.glsl
+-rw-r--r--  2.0 unx     5356 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Include/Camera.glsl
 -rw-r--r--  2.0 unx        0 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Include/Complex.glsl
--rw-r--r--  2.0 unx    11762 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Include/ShaderFlow.glsl
+-rw-r--r--  2.0 unx    12163 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Include/ShaderFlow.glsl
 -rw-r--r--  2.0 unx      538 b- defN 20-Feb-02 00:00 ShaderFlow/Resources/Shaders/Vertex/Default.glsl
--rw-r--r--  2.0 unx     1967 b- defN 20-Feb-02 00:00 SpectroNote/SpectroNote.py
+-rw-r--r--  2.0 unx     1966 b- defN 20-Feb-02 00:00 SpectroNote/SpectroNote.py
 -rw-r--r--  2.0 unx      282 b- defN 20-Feb-02 00:00 SpectroNote/__init__.py
--rw-r--r--  2.0 unx      337 b- defN 20-Feb-02 00:00 SpectroNote/__main__.py
+-rw-r--r--  2.0 unx      271 b- defN 20-Feb-02 00:00 SpectroNote/__main__.py
 -rw-r--r--  2.0 unx    20132 b- defN 20-Feb-02 00:00 SpectroNote/Resources/Images/SpectroNote.png
 -rw-r--r--  2.0 unx     1448 b- defN 20-Feb-02 00:00 SpectroNote/Resources/Images/SpectroNote.svg
 -rw-r--r--  2.0 unx     3087 b- defN 20-Feb-02 00:00 SpectroNote/Resources/Shaders/SpectroNote.frag
-?rw-r--r--  2.0 unx     3415 b- defN 20-Feb-02 00:00 broken_source-0.2.1.dist-info/METADATA
-?rw-r--r--  2.0 unx       87 b- defN 20-Feb-02 00:00 broken_source-0.2.1.dist-info/WHEEL
-?rw-r--r--  2.0 unx      194 b- defN 20-Feb-02 00:00 broken_source-0.2.1.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx    10620 b- defN 20-Feb-02 00:00 broken_source-0.2.1.dist-info/RECORD
-117 files, 1382043 bytes uncompressed, 628689 bytes compressed:  54.5%
+?rw-r--r--  2.0 unx     3414 b- defN 20-Feb-02 00:00 broken_source-0.3.0.dist-info/METADATA
+?rw-r--r--  2.0 unx       87 b- defN 20-Feb-02 00:00 broken_source-0.3.0.dist-info/WHEEL
+?rw-r--r--  2.0 unx      194 b- defN 20-Feb-02 00:00 broken_source-0.3.0.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx    10460 b- defN 20-Feb-02 00:00 broken_source-0.3.0.dist-info/RECORD
+115 files, 1371767 bytes uncompressed, 625343 bytes compressed:  54.4%
```

## zipnote {}

```diff
@@ -120,18 +120,18 @@
 
 Filename: Broken/Resources/Images/Broken.png
 Comment: 
 
 Filename: Broken/Resources/Images/Broken.svg
 Comment: 
 
-Filename: Broken/Tests/Enum.py
+Filename: Broken/Vectron/__init__.py
 Comment: 
 
-Filename: Broken/Vectron/__init__.py
+Filename: DepthFlow/CustomScene.py
 Comment: 
 
 Filename: DepthFlow/DepthFlow.py
 Comment: 
 
 Filename: DepthFlow/__init__.py
 Comment: 
@@ -144,18 +144,18 @@
 
 Filename: DepthFlow/Resources/Images/DepthFlow.svg
 Comment: 
 
 Filename: DepthFlow/Resources/Shaders/DepthFlow.frag
 Comment: 
 
-Filename: DepthFlow/Resources/Shaders/DepthFlow2D.frag
+Filename: DepthFlow/Resources/Shaders/Deprecated/DepthFlow2D.frag
 Comment: 
 
-Filename: DepthFlow/Resources/Shaders/DepthFlowMarch.frag
+Filename: DepthFlow/Resources/Shaders/Deprecated/DepthFlowMarch.frag
 Comment: 
 
 Filename: Pianola/Pianola.py
 Comment: 
 
 Filename: Pianola/__init__.py
 Comment: 
@@ -165,17 +165,14 @@
 
 Filename: Pianola/Resources/Images/Pianola.png
 Comment: 
 
 Filename: Pianola/Resources/Images/Pianola.svg
 Comment: 
 
-Filename: Pianola/Resources/Midis/Hopeless Sparkle.mid
-Comment: 
-
 Filename: Pianola/Resources/Shaders/Pianola.frag
 Comment: 
 
 Filename: ShaderFlow/Imgui.py
 Comment: 
 
 Filename: ShaderFlow/Message.py
@@ -246,17 +243,14 @@
 
 Filename: ShaderFlow/Optional/OpticalFlow.py
 Comment: 
 
 Filename: ShaderFlow/Optional/__init__.py
 Comment: 
 
-Filename: ShaderFlow/Resources/__init__.py
-Comment: 
-
 Filename: ShaderFlow/Resources/Images/ShaderFlow.png
 Comment: 
 
 Filename: ShaderFlow/Resources/Images/ShaderFlow.svg
 Comment: 
 
 Filename: ShaderFlow/Resources/Scenes/Examples/Demo.py
@@ -264,26 +258,26 @@
 
 Filename: ShaderFlow/Resources/Scenes/Examples/GLSL/Bars.frag
 Comment: 
 
 Filename: ShaderFlow/Resources/Scenes/Examples/GLSL/Bouncing.frag
 Comment: 
 
+Filename: ShaderFlow/Resources/Scenes/Examples/GLSL/MotionBlur.frag
+Comment: 
+
 Filename: ShaderFlow/Resources/Scenes/Examples/GLSL/Multipass.frag
 Comment: 
 
 Filename: ShaderFlow/Resources/Scenes/Examples/GLSL/RayMarch.frag
 Comment: 
 
 Filename: ShaderFlow/Resources/Scenes/Examples/GLSL/ShaderToy.frag
 Comment: 
 
-Filename: ShaderFlow/Resources/Scenes/Examples/GLSL/Temporal.frag
-Comment: 
-
 Filename: ShaderFlow/Resources/Scenes/Examples/GLSL/Video.frag
 Comment: 
 
 Filename: ShaderFlow/Resources/Scenes/Examples/GLSL/Visualizer.frag
 Comment: 
 
 Filename: ShaderFlow/Resources/Scenes/Examples/GLSL/Waveform.frag
@@ -333,20 +327,20 @@
 
 Filename: SpectroNote/Resources/Images/SpectroNote.svg
 Comment: 
 
 Filename: SpectroNote/Resources/Shaders/SpectroNote.frag
 Comment: 
 
-Filename: broken_source-0.2.1.dist-info/METADATA
+Filename: broken_source-0.3.0.dist-info/METADATA
 Comment: 
 
-Filename: broken_source-0.2.1.dist-info/WHEEL
+Filename: broken_source-0.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: broken_source-0.2.1.dist-info/entry_points.txt
+Filename: broken_source-0.3.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: broken_source-0.2.1.dist-info/RECORD
+Filename: broken_source-0.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Broken/Types.py

```diff
@@ -1,10 +1,17 @@
 import warnings
 from math import pi as PI
-from typing import TypeAlias, Union
+
+from typing import Union
+
+# Python 3.9
+try:
+    from typing import TypeAlias
+except ImportError:
+    from typing_extensions import TypeAlias
 
 # Ignore mostly NumPy warnings
 warnings.filterwarnings("ignore")
 
 # # Custom types and utilities
 Unchanged: TypeAlias = None
 URL:       TypeAlias = str
```

## Broken/__init__.py

```diff
@@ -10,20 +10,22 @@
     line_color        = pretty_errors.RED + "> \033[1;37m",
     code_color        = '  \033[1;37m',
     line_number_first = True,
     lines_before      = 10,
     lines_after       = 10,
 )
 
+# Huge CPU usage for little to no speed up on matrix multiplication of NumPy's BLAS
+# Warn: If using PyTorch CPU, set `torch.set_num_threads(multiprocessing.cpu_count())`
 # https://github.com/numpy/numpy/issues/18669#issuecomment-820510379
 os.environ["OMP_NUM_THREADS"] = "1"
 
+# High CPU usage on glfw.swap_buffers when vsync is off and the GPU is wayy behind own vblank
 # https://forums.developer.nvidia.com/t/glxswapbuffers-gobbling-up-a-full-cpu-core-when-vsync-is-off/156635
 # https://forums.developer.nvidia.com/t/gl-yield-and-performance-issues/27736
-# High CPU usage on glfw.swap_buffers when vsync is off and the GPU is wayy behind own vblank
 os.environ["__GL_YIELD"] = "USLEEP"
 
 # Keep repository clean of __pycache__ and .pyc files by writing to .venv
 if (_venv := Path(__file__).parent.parent/".venv").exists():
     sys.pycache_prefix = str(_venv/"pycache")
 
 # Fix: typing.Self was implemented on Python >= 3.11
@@ -64,18 +66,21 @@
     apply,
     clamp,
     denum,
     dunder,
     extend,
     flatten,
     have_import,
+    hyphen_range,
     image_hash,
     last_locals,
+    limited_integer_ratio,
     nearest,
     shell,
+    temp_env,
 )
 from Broken.Core.BrokenEnum import BrokenEnum
 from Broken.Core.BrokenLogging import BrokenLogging
 from Broken.Core.BrokenPath import BrokenPath
 from Broken.Core.BrokenPlatform import BrokenPlatform
 from Broken.Core.BrokenProfiler import BrokenProfiler, BrokenProfilerEnum
 from Broken.Core.BrokenProject import BrokenApp, BrokenProject
@@ -88,14 +93,15 @@
 from Broken.Core.BrokenUtils import (
     BrokenAttrs,
     BrokenFluentBuilder,
     BrokenRelay,
     BrokenSingleton,
     BrokenWatchdog,
     Ignore,
+    OnceTracker,
     SameTracker,
 )
 
 BROKEN = BrokenProject(
     PACKAGE=__file__,
     APP_NAME="Broken",
     APP_AUTHOR="BrokenSource",
```

## Broken/__main__.py

```diff
@@ -428,23 +428,25 @@
 
     def ryedeps(self) -> None:
         """ðŸ“¦ Rye doesn't have a command to bump versions, but (re)adding dependencies does it"""
         import re
 
         pyproject = DotMap(toml.loads((BROKEN.DIRECTORIES.REPOSITORY/"pyproject.toml").read_text()))
 
-        def update_dependencies(data: List[str], *, dev: bool=False) -> None:
+        def update_dependencies(data: List[str], *, dev: bool=False, optional: str=None) -> None:
             for dependency in data:
                 name, compare, version = re.split("(<|<=|!=|==|>=|>|~=|===)", dependency)
                 if (compare == "=="):
                     continue
-                shell("rye", "add", name, "--dev"*dev, "--no-sync")
+                shell("rye", "add", name, "--dev"*dev, ["--optional", optional] if optional else None, "--no-sync")
 
         update_dependencies(pyproject.project.dependencies)
         update_dependencies(pyproject.tool.rye["dev-dependencies"], dev=True)
+        for (optional, items) in pyproject.project["optional-dependencies"].items():
+            update_dependencies(items, optional=optional)
         shell("rye", "sync")
 
     def docs(self, deploy: Annotated[bool, Option("--deploy", "-d", help="Deploy Documentation to GitHub Pages")]=False) -> None:
         """ðŸ“š Generate or Deploy Documentation for all Projects"""
         GITHUB_PAGE = "git@github.com:BrokenSource/brokensource.github.io.git"
         if deploy:
             shell("mkdocs", "gh-deploy", "--force", "--remote-name", GITHUB_PAGE)
@@ -529,17 +531,15 @@
 
     def sync(self) -> None:
         """â™»ï¸  Synchronize common Resources Files across all Projects"""
         root = Broken.BROKEN.DIRECTORIES.REPOSITORY
 
         for project in self.projects:
             for file in flatten(
-                (root/"poetry.toml"),
-                (root/".gitignore"),
-                (root/".github"/"Funding.yml"),
+                (root/".github"/"funding.yml"),
                 (root/".github"/"ISSUE_TEMPLATE").glob("*.md"),
             ):
                 target = project.path/file.relative_to(root)
                 BrokenPath.copy(src=file, dst=target)
 
     def uninstall(self):
         """âž– Selectively removes Data or Artifacts created by Projects outside of the Repository"""
```

## Broken/Core/BrokenEnum.py

```diff
@@ -391,7 +391,134 @@
             computer.os = "dne"   # Not ok
             ```
 
         Args:
             `kwargs`: Keyword arguments to pass to the field, may override default and converter
         """
         return attrs.field(default=self, converter=self.__class__.get, **kwargs)
+
+# -------------------------------------------------------------------------------------------------|
+# Test
+
+class _PyTest:
+
+    # # Basic usage
+
+    def get_fruits(self) -> BrokenEnum:
+        # A translation enum example
+        class Fruits(BrokenEnum):
+            Apple  = "MaÃ§Ã£"
+            Banana = "Banana"
+            Orange = "Laranja"
+        return Fruits
+
+    # Test inheritance
+    def test_inheritance(self):
+        self.get_fruits()
+        assert True
+
+    # Test initialization
+    def test_initialization(self):
+        Fruits = self.get_fruits()
+        assert Fruits("MaÃ§Ã£") == Fruits.Apple
+
+    # Test .from_name
+    def test_from_name(self):
+        Fruits = self.get_fruits()
+        assert Fruits.from_name("Apple")  == Fruits.Apple
+        assert Fruits.from_name("apple")  == Fruits.Apple
+        assert Fruits.from_name("MaÃ§Ã£")   is None
+
+    # Test .options property
+    def test_options(self):
+        Fruits = self.get_fruits()
+        assert Fruits.options == (Fruits.Apple, Fruits.Banana, Fruits.Orange)
+
+    # Test .values property
+    def test_values(self):
+        Fruits = self.get_fruits()
+        assert Fruits.values == ("MaÃ§Ã£", "Banana", "Laranja")
+
+    # Test .keys property
+    def test_keys(self):
+        Fruits = self.get_fruits()
+        assert Fruits.keys == ("Apple", "Banana", "Orange")
+
+    # Test .names property
+    def test_names(self):
+        Fruits = self.get_fruits()
+        assert Fruits.names == ("Apple", "Banana", "Orange")
+
+    # Test .names_lower property
+    def test_names_lower(self):
+        Fruits = self.get_fruits()
+        assert Fruits.names_lower == ("apple", "banana", "orange")
+
+    # Test .items
+    def test_items(self):
+        Fruits = self.get_fruits()
+        assert Fruits.items == (
+            ("Apple", Fruits.Apple.value),
+            ("Banana", Fruits.Banana.value),
+            ("Orange", Fruits.Orange.value),
+        )
+
+    # Test .as_dict
+    def test_as_dict(self):
+        Fruits = self.get_fruits()
+        assert Fruits.as_dict == dict(
+            Apple="MaÃ§Ã£",
+            Banana="Banana",
+            Orange="Laranja",
+        )
+
+    # # Advanced usage
+
+    def get_multivalue(self) -> BrokenEnum:
+        # This is a bad example of usage
+        # - Multi options with False will collide
+        class Multivalue(BrokenEnum):
+            Color  = "blue"
+            Hat    = False
+            Age    = 9000
+            Height = 1.41
+            Emoji  = "ðŸ”±"
+        return Multivalue
+
+    # Test .from_value
+    def test_from_value(self):
+        Multivalue = self.get_multivalue()
+        assert Multivalue.from_value("blue")  == Multivalue.Color
+        assert Multivalue.from_value(False)   == Multivalue.Hat
+        assert Multivalue.from_value(9000)    == Multivalue.Age
+        assert Multivalue.from_value(1.41)    == Multivalue.Height
+        assert Multivalue.from_value("ðŸ”±")    == Multivalue.Emoji
+        assert Multivalue.from_value("color") is None
+
+    # Test .get
+    def test_get(self):
+        Multivalue = self.get_multivalue()
+        assert Multivalue.get("blue")           == Multivalue.Color
+        assert Multivalue.get(Multivalue.Color) == Multivalue.Color
+        assert Multivalue.get("height")         == Multivalue.Height
+        assert Multivalue.get("Height")         == Multivalue.Height
+        assert Multivalue.get(9000)             == Multivalue.Age
+
+    # Test .next
+    def test_next_previous(self):
+        Multivalue = self.get_multivalue()
+
+        # Cycling through options with .next
+        value = Multivalue.Color
+        assert (value := value.next()) == Multivalue.Hat
+        assert (value := value.next()) == Multivalue.Age
+        assert (value := value.next()) == Multivalue.Height
+        assert (value := value.next()) == Multivalue.Emoji
+        assert (value := value.next()) == Multivalue.Color
+
+        # Cycling through options with .previous
+        value = Multivalue.Color
+        assert (value := value.previous()) == Multivalue.Emoji
+        assert (value := value.previous()) == Multivalue.Height
+        assert (value := value.previous()) == Multivalue.Age
+        assert (value := value.previous()) == Multivalue.Hat
+        assert (value := value.previous()) == Multivalue.Color
```

## Broken/Core/BrokenPath.py

```diff
@@ -21,76 +21,73 @@
 from Broken.Core.BrokenSpinner import BrokenSpinner
 from Broken.Types import FileExtensions
 
 
 class ShutilFormat(BrokenEnum):
     Zip   = "zip"
     Tar   = "tar"
-    GzTar = "tar.gz"
-    BzTar = "tar.bz2"
-    XzTar = "tar.xz"
+    TarGz = "tar.gz"
+    TarBz = "tar.bz2"
+    TarXz = "tar.xz"
 
 class BrokenPath(pathlib.Path):
     """
-    Extended pathlib.BrokenPath with utilities and always use absolute expanded user paths.
+    Extended pathlib.Path with utilities, absolute paths always, accepts None
 
     - Clever mechanism: Functions aren't staticmethods but still can be called from the outside,
-        they just imply self. For example: Both BrokenPath("/tmp").valid() or BrokenPath.valid("/tmp") works
+        they just imply self eg. Both BrokenPath("/tmp").valid() or BrokenPath.valid("/tmp") works
 
-    - Convenience: Can use BrokenPath(None), BrokenPath("/ok/stuff", None, "file.mp4")
+    - Convenience: Can use BrokenPath(None), BrokenPath("/ok", None, "file.mp4") -> "/ok/file.mp4"
     """
     _flavour = type(pathlib.Path())._flavour
 
     def __new__(cls, *args, **kwargs):
 
         # Return None if all args are falsy
         if not (args := list(filter(None, args))):
             return None
 
         # Use absolute expanded user always. Note that we do not want
         # to .resolve() as having symlink paths _can_ be wanted
         instance = super().__new__(cls, *args, **kwargs)
-        instance._raw_paths = list(map(str, args))
+        instance._raw_paths = list(map(str, args)) # Py312 fix
         return instance.expanduser().absolute()
 
     def pathlib(self) -> pathlib.Path:
-        """Some packages test `var == pathlib.Path` instead of `isinstance(var, pathlib.Path)`"""
+        """Some packages test `type(var) == pathlib.Path` instead of `isinstance(var, pathlib.Path)`"""
         return pathlib.Path(self)
 
     def str(self) -> str:
         return str(self)
 
-    def valid(path: BrokenPath) -> Optional[BrokenPath]:
+    def valid(path: Optional[BrokenPath]) -> Optional[BrokenPath]:
         """Returns the BrokenPath if it exists, else None"""
-        if (path := BrokenPath(path)) is None:
+        if (path is None):
             return None
-        if path.exists():
-            return path
+        if (path := Path(path)).exists():
+            return BrokenPath(path)
         return None
 
-    @staticmethod
     def copy(src: Path, dst: Path, *, echo=True) -> Path:
-        src, dst = BrokenPath(src, dst)
+        src, dst = BrokenPath(src), BrokenPath(dst)
         BrokenPath.mkdirs(dst.parent, echo=False)
         if src.is_dir():
             log.info(f"Copying Directory ({src})\n â†’ ({dst})", echo=echo)
             shutil.copytree(src, dst)
         else:
             log.info(f"Copying File ({src})\n â†’ ({dst})", echo=echo)
             shutil.copy2(src, dst)
         return dst
 
-    @staticmethod
     def move(src: Path, dst: Path, *, echo=True) -> Path:
-        src, dst = BrokenPath(src, dst)
+        src, dst = BrokenPath(src), BrokenPath(dst)
         log.info(f"Moving ({src})\n â†’ ({dst})", echo=echo)
         shutil.move(src, dst)
         return dst
 
-    @staticmethod
     def remove(path: Path, *, confirm=False, echo=True) -> Path:
 
         # Already removed or doesn't exist
         if not (path := BrokenPath(path).valid()):
             return path
 
         log.info(f"Removing Path ({path})", echo=echo)
@@ -125,30 +122,28 @@
             log.success(f"Directory ({path}) already exists", echo=echo)
             return path
         log.info(f"Creating directory {path}", echo=echo)
         path.mkdir(parents=True, exist_ok=True)
         return path
 
     def resetdir(path: Path, *, echo=True) -> Path:
-        """Creates a directory and its parents, fail safeâ„¢"""
-        BrokenPath.remove(path, echo=echo)
-        return BrokenPath.mkdirs(path, echo=echo)
+        """Delete and re-create a directory"""
+        return BrokenPath.mkdirs(BrokenPath.remove(path, echo=echo), echo=echo)
 
     @contextlib.contextmanager
     def pushd(path: Path, *, echo: bool=True) -> Generator[Path, None, None]:
         """Change directory, then change back when done"""
         path = BrokenPath(path)
         cwd = os.getcwd()
         log.info(f"Pushd ({path})", echo=echo)
         os.chdir(path)
         yield path
         log.info(f"Popd  ({path})", echo=echo)
         os.chdir(cwd)
 
-    @staticmethod
     def symlink(virtual: Path, real: Path, *, echo: bool=True) -> Path:
         """
         Symlink [virtual] -> [real], `virtual` being the symlink file and `real` the target
 
         Args:
             virtual (Path): Symlink path (file)
             real (Path): Target path (real path)
@@ -189,27 +184,26 @@
 
         # Actually symlink
         virtual.symlink_to(real)
         return virtual
 
     def make_executable(path: Path, *, echo=False) -> Path:
         """Make a file executable"""
-        path = BrokenPath(path)
         if BrokenPlatform.OnUnix:
             shell("chmod", "+x", path, echo=echo)
         elif BrokenPlatform.OnWindows:
             shell("attrib", "+x", path, echo=echo)
         return path
 
     def zip(path: Path, output: Path=None, *, format: ShutilFormat=ShutilFormat.Zip, echo: bool=True) -> Path:
-        format = ShutilFormat(format)
+        format = ShutilFormat.get(format)
         output = BrokenPath(output or path).with_suffix(f".{format}")
         path   = BrokenPath(path)
-        BrokenPath.remove(output, echo=echo)
         log.info(f"Zipping ({path})\n â†’ ({output})", echo=echo)
+        BrokenPath.remove(output, echo=echo)
         shutil.make_archive(output.with_suffix(""), format, path)
         return output
 
     def stem(path: Path) -> str:
         """
         Get the "true stem" of a path, as pathlib's only gets the last dot one
         â€¢ "/path/with/many.ext.ens.ions" -> "many" instead of "many.ext.ens"
@@ -248,165 +242,176 @@
         return
 
     def extract(
         path: Path,
         output: Path=None,
         *,
         overwrite: bool=False,
-        PATH: bool=False,
         echo: bool=True
     ) -> Path:
         path, output = BrokenPath(path), BrokenPath(output)
 
-        # Output is input without suffix if not given
+        # Extract to the same directory by default
         if (output is None):
-            output = path.parent/BrokenPath.stem(path)
+            output = path.parent
 
         # Add stem to the output as some archives might be flat
         output /= BrokenPath.stem(path)
 
         # Re-extract on order
         if overwrite:
             BrokenPath.remove(output)
 
         # A file to skip if it exists, created after successful extraction
         if (extract_flag := (output/"BrokenPath.extract.ok")).exists():
             log.minor(f"Already extracted ({output})", echo=echo)
-            if PATH: BrokenPath.add_to_path(path=output, recursively=True, echo=echo)
-            return output
+        else:
+            # Show progress as this might take a while on slower IOs
+            log.info(f"Extracting ({path})\n â†’ ({output})", echo=echo)
+            with BrokenSpinner("Extracting archive.."):
+                shutil.unpack_archive(path, output)
+            extract_flag.touch()
 
-        # Show progress as this might take a while on slower IOs
-        log.info(f"Extracting ({path})\n â†’ ({output})", echo=echo)
-        with BrokenSpinner("Extracting archive.."):
-            shutil.unpack_archive(path, output)
-
-        extract_flag.touch()
-        if PATH: BrokenPath.add_to_path(path=output, recursively=True, echo=echo)
-        return output/BrokenPath.stem(path)
+        return output
+
+    def url_filename(url: str) -> Path:
+        return Path(url.split("#")[0].split("?")[0].split("/")[-1])
 
     def download(
         url: str,
         output: Path=None,
         *,
         size_check: bool=True,
         chunk: int=1024,
         echo: bool=True
     ) -> Optional[Path]:
+        """
+        Note: If the output is a directory, the url's file name will be appended to it
+        Note: The output will default to Broken Project's Download directory
+        """
 
         # Link must be valid
         if not validators.url(url):
-            log.error(f"The string ({url}) doesn't look like a valid URL", echo=echo)
-            return
-
-        import requests
+            import click
+            if not click.confirm(log.error(f"The following string doesn't look like a valid download URL on validator's eyes\nâ€¢ ({url})\nContinue normally?")):
+                return None
 
         # Default to Broken's Download directory
         if (output is None):
             output = Broken.BROKEN.DIRECTORIES.DOWNLOADS
 
         # Append url's file name to the output path
         if (output := BrokenPath(output)).is_dir():
-            output /= Path(url.split("#")[0].split("?")[0].split("/")[-1])
+            output /= BrokenPath.url_filename(url)
+
+        log.info(f"Downloading\nâ€¢ URL:  ({url})\nâ€¢ Path: ({output})", echo=echo)
 
         # Without size check, the existence of the file is enough
-        if output.exists() and (not size_check):
-            log.info(f"Already Downloaded ({output})", echo=echo)
-            log.minor("â€¢ Size check was skipped, the file might be incomplete", echo=echo)
-            return
+        if (not size_check) and output.exists():
+            log.minor("â€¢ File exists and Size check was skipped", echo=echo)
+            return None
 
-        # Send the GET request, we might be offline!
         try:
-            response = requests.get(url, stream=True)
+            import requests
+            response = requests.get(url, stream=True, headers={"Accept-Encoding": None})
         except requests.exceptions.RequestException as error:
-            log.error(f"Failed to download file ({url}) â†’ ({output}): {error}", echo=echo)
+            log.error(f"â€¢ Failed to download: {error}", echo=echo)
+            # Note: Return output as it might be downloaded but we're without internet
             return output
 
-        size = int(response.headers.get('content-length', 0))
+        # Note: The length header is not always present, if that, just check for existence
+        if not (expected_size := int(response.headers.get('content-length', 0))):
+            log.minor("The Download doesn't advertise a size, just checking for existence", echo=echo)
+            if output.exists():
+                return output
 
         # The file might already be (partially) downloaded
-        if output.exists():
-            A, B = (output.stat().st_size, size)
-            if (A == B):
-                log.info(f"Already Downloaded ({output})", echo=echo)
+        if (expected_size and size_check) and output.exists():
+            if (output.stat().st_size == expected_size):
                 return output
-            else:
-                log.warning(f"Wrong Download at ({output})", echo=echo)
+            if (len(output.read_bytes()) == expected_size):
+                return output
+            log.warning("â€¢ Wrong Download size", echo=echo)
 
-        log.info(f"Downloading file at ({url}):", echo=echo)
-        log.info(f"â€¢ Output: ({output})", echo=echo)
+        log.info("Downloading", echo=echo)
 
         # It is binary prefix, right? kibi, mebi, gibi, etc. as we're dealing with raw bytes
         with open(output, "wb") as file, tqdm.tqdm(
             desc=f"Downloading ({output.name})",
-            total=size, unit="iB", unit_scale=True, unit_divisor=1024,
+            total=expected_size, unit="iB", unit_scale=True, unit_divisor=1024,
             mininterval=1/30, maxinterval=0.5, leave=False
         ) as progress:
             for data in response.iter_content(chunk_size=chunk):
                 progress.update(file.write(data))
 
-        # Url was invalid
+        # Url was invalid or something
         if (response.status_code != 200):
             log.error(f"Failed to Download File at ({url}):", echo=echo)
             log.error(f"â€¢ HTTP Error: {response.status_code}", echo=echo)
             return
 
         # Wrong downloaded and expected size
-        elif (output.stat().st_size != size):
-            log.error(f"File ({output}) was not downloaded correctly", echo=echo)
+        elif (expected_size and size_check) and (output.stat().st_size != expected_size):
+            log.error(f"File ({output}) was not downloaded correctly ({output.stat().st_size} != {expected_size})", echo=echo)
             return
 
         log.success(f"Downloaded file ({output}) from ({url})", echo=echo)
         return output
 
-    @staticmethod
     def get_external(url: str, *, subdir: str="", echo: bool=True) -> Path:
-        file = BrokenPath.download(denum(url), echo=echo)
-
-        # File is a Archive, extract
-        if any((str(file).endswith(ext) for ext in ShutilFormat.values)):
-            directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_ARCHIVES
-            return BrokenPath.extract(file, directory, PATH=True, echo=echo)
+        file = BrokenPath.url_filename(denum(url))
+        ARCHIVE = any((str(file).endswith(ext) for ext in ShutilFormat.values))
 
         # File is some known type, move to their own external directory
         if bool(subdir):
             directory = Broken.BROKEN.DIRECTORIES.EXTERNALS/subdir
-        elif file.suffix in FileExtensions.Audio:
+        elif ARCHIVE:
+            directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_ARCHIVES
+        elif (file.suffix in FileExtensions.Audio):
             directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_AUDIO
-        elif file.suffix in FileExtensions.Image:
+        elif (file.suffix in FileExtensions.Image):
             directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_IMAGES
-        elif file.suffix in FileExtensions.Font:
+        elif (file.suffix in FileExtensions.Font):
             directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_FONTS
-        elif file.suffix in FileExtensions.Soundfont:
+        elif (file.suffix in FileExtensions.Soundfont):
             directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_SOUNDFONTS
-        elif file.suffix in FileExtensions.Midi:
+        elif (file.suffix in FileExtensions.Midi):
             directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_MIDIS
         else:
             directory = Broken.BROKEN.DIRECTORIES.EXTERNALS
-        return BrokenPath.move(file, directory/subdir, echo=echo)
 
-    @staticmethod
+        # Download to target directory, avoiding a move/copy, be known on future calls
+        if not ARCHIVE:
+            directory = (directory/subdir/file.name)
+
+        # Finally download the file
+        file = BrokenPath.download(denum(url), directory, echo=echo)
+
+        # Maybe extract the downloaded file
+        if ARCHIVE:
+            file = BrokenPath.extract(file, echo=echo)
+
+        return BrokenPath.add_to_path(path=file, recurse=True, echo=echo)
+
     def which(name: str) -> Optional[Path]:
         BrokenPath.update_externals_path()
         return BrokenPath(shutil.which(name))
 
-    @staticmethod
     def update_externals_path(path: Path=None, *, echo: bool=True) -> Optional[Path]:
-        path = path or Broken.BROKEN.DIRECTORIES.EXTERNALS
-        return BrokenPath.add_to_path(path, recursively=True, echo=echo)
+        path = (path or Broken.BROKEN.DIRECTORIES.EXTERNALS)
+        return BrokenPath.add_to_path(path, recurse=True, echo=echo)
 
-    @staticmethod
     def on_path(path: Path) -> bool:
         """Check if a path is on PATH, works with symlinks"""
-        return BrokenPath(path) in map(BrokenPath, os.environ.get("PATH", "").split(os.pathsep))
+        return (Path(path) in map(Path, os.environ.get("PATH", "").split(os.pathsep)))
 
-    @staticmethod
     def add_to_path(
         path: Path,
         *,
-        recursively: bool=False,
+        recurse: bool=False,
         persistent: bool=False,
         preferential: bool=True,
         echo: bool=True
     ) -> Path:
         """
         Add a path, recursively or not, to System's Path or this Python process's Path
 
@@ -414,60 +419,68 @@
             recursively: Also add all subdirectories of the given path
             persistent: Use 'userpath' package to add to the Shell's or Registry PATH
             preferential: Prepends the path for less priority on system binaries
 
         Returns:
             The Path argument itself
         """
-        path = BrokenPath(path)
+        original = path = BrokenPath(path)
 
-        # Can't recurse on file or non existing directories
-        if (not path.exists()) and path.is_file() and recursively:
-            log.warning(f"Can't add non existing path or file recursively to Path ({path})", echo=echo)
+        if (path.is_file()):
+            path = path.parent
+            recurse = False
+
+        # Can't recurse on non existing directories
+        if (not path.exists()) and recurse:
+            log.warning(f"Not adding to PATH as directory doesn't exist ({path})", echo=echo)
             return path
 
-        log.debug(f"Adding to Path (Recursively: {recursively}, Persistent: {persistent}): ({path})", echo=echo)
+        log.debug(f"Adding to Path (Recursively: {recurse}, Persistent: {persistent}): ({path})", echo=echo)
+
+        for other in list(path.rglob("*") if recurse else []) + [path]:
 
-        for other in (path.rglob("*") if recursively else [path]):
+            # Skip conditions
             if other.is_file():
                 continue
             if BrokenPath.on_path(other):
                 continue
+
+            # Actual logic
             if persistent:
                 import userpath
                 userpath.append(str(other))
             else:
                 if preferential:
-                    os.environ["PATH"] = (str(other)+os.pathsep+os.environ["PATH"])
+                    log.debug(f"â€¢ Prepending: ({other})", echo=echo)
+                    os.environ["PATH"] = (str(other) + os.pathsep + os.environ["PATH"])
                     sys.path.insert(0, str(other))
                 else:
-                    os.environ["PATH"] = (os.environ["PATH"]+os.pathsep+str(other))
+                    log.debug(f"â€¢ Appending: ({other})", echo=echo)
+                    os.environ["PATH"] = (os.environ["PATH"] + os.pathsep + str(other))
                     sys.path.append(str(other))
-        return path
+
+        return original
 
     # # Specific / "Utils"
 
-    @staticmethod
     def open_in_file_explorer(path: Path):
         """Opens a path in the file explorer"""
         path = BrokenPath(path)
         if BrokenPlatform.OnWindows:
             os.startfile(str(path))
         elif BrokenPlatform.OnLinux:
             shell("xdg-open", path)
         elif BrokenPlatform.OnMacOS:
             shell("open", path)
 
     # Fixme: Untested functions, needs better name; are these useful?
 
-    @staticmethod
     def non_empty_file(path: Path) -> bool:
         return path.exists() and path.is_file() and path.stat().st_size > 0
 
-    @staticmethod
     def empty_file(path: Path, create: bool=True) -> bool:
         if create and not path.exists():
             path.parent.mkdirs(parents=True, exist_ok=True)
             path.touch()
         return path.exists() and path.is_file() and len(path.read_text()) == 0
 
     @contextlib.contextmanager
@@ -514,8 +527,8 @@
 
         # Set new PATH
         os.environ["PATH"] = os.pathsep.join(map(str, PATH))
 
         yield os.environ["PATH"]
 
         # Restore PATH
-        os.environ["PATH"] = old
+        os.environ["PATH"] = old
```

## Broken/Core/BrokenProfiler.py

```diff
@@ -37,27 +37,25 @@
     # The actual profiler object
     __profiler__: Any = None
 
     def __enter__(self) -> Self:
         if not self.enabled:
             return self
 
-        match self.profiler:
-            case BrokenProfilerEnum.cprofile:
-                log.trace("Profiling with cProfile")
-                import cProfile
-                self.__profiler__ = cProfile.Profile()
-                self.__profiler__.enable()
-                return self
+        if (self.profiler == BrokenProfilerEnum.cprofile):
+            log.trace("Profiling with cProfile")
+            import cProfile
+            self.__profiler__ = cProfile.Profile()
+            self.__profiler__.enable()
+            return self
 
     def __exit__(self, *args) -> None:
         if not self.enabled:
             return
 
-        match self.profiler:
-            case BrokenProfilerEnum.cprofile:
-                log.trace("Finishing cProfile")
-                output = self.output.with_suffix(".prof")
-                self.__profiler__.disable()
-                self.__profiler__.dump_stats(output)
-                shell("snakeviz", output)
-                return
+        if (self.profiler == BrokenProfilerEnum.cprofile):
+            log.trace("Finishing cProfile")
+            output = self.output.with_suffix(".prof")
+            self.__profiler__.disable()
+            self.__profiler__.dump_stats(output)
+            shell("snakeviz", output)
+            return
```

## Broken/Core/BrokenProject.py

```diff
@@ -286,14 +286,20 @@
 
     # # Internal states
 
     __RESOURCES__: Path = field(default=None)
 
     def __attrs_post_init__(self):
         if self.BROKEN_PROJECT.RESOURCES:
+
+            # Fixme (#spec): Python 3.9 workaround; Spec-less packages
+            if (sys.version_info < (3, 10)):
+                spec = self.BROKEN_PROJECT.RESOURCES.__spec__
+                spec.origin = spec.submodule_search_locations[0] + "/WorkaroundIgnore"
+
             self.__RESOURCES__ = importlib.resources.files(self.BROKEN_PROJECT.RESOURCES)
 
     def __div__(self, name: str) -> Path:
         return self.__RESOURCES__/name
 
     def __truediv__(self, name: str) -> Path:
         return self.__div__(name)
@@ -380,16 +386,16 @@
     def __attrs_post_init__(self):
 
         # Create Directories class
         self.DIRECTORIES = _BrokenProjectDirectories(BROKEN_PROJECT=self)
         self.RESOURCES   = _BrokenProjectResources  (BROKEN_PROJECT=self)
         self.PACKAGE     = Path(self.PACKAGE)
 
-        # Fixme: Split the projects into many packages
-        # self.VERSION = importlib.metadata.version(self.PACKAGE.parent.name.replace("Broken", "broken-source"))
+        # Fixme (#spec): Projects don't have their own spec as they are included
+        # self.VERSION = importlib.metadata.version(self.PACKAGE.parent.name)
         self.VERSION = Broken.VERSION
         BrokenLogging.set_project(self.APP_NAME)
 
         # Convenience: Symlink Workspace to projects data directory
         if Broken.DEVELOPMENT:
             try:
                 BrokenPath.symlink(
@@ -400,14 +406,17 @@
             except Exception as e:
                 log.minor(f"Failed to symlink Workspace: {e}")
 
         # Load .env files from the project
         for env in self.DIRECTORIES.REPOSITORY.glob("*.env"):
             dotenv.load_dotenv(env)
 
+        if (os.environ.get("WELCOME", "0") == "1") and (self.APP_NAME != "Broken"):
+            self.welcome()
+
     def welcome(self):
         """Pretty Welcome Message!"""
         import pyfiglet
 
         # Build message
         ascii = pyfiglet.figlet_format(self.APP_NAME, font="dos_rebel", width=1000)
         ascii = '\n'.join((x for x in ascii.split('\n') if x.strip()))
```

## Broken/Core/BrokenResolution.py

```diff
@@ -6,31 +6,28 @@
 
 from Broken import nearest
 
 
 class BrokenResolution:
 
     @staticmethod
-    def round(width: Number, height: Number, *, scale: Number=1) -> Tuple[int, int]:
-        """FFmpeg likes multiples of 2, so let it be"""
-        return (
-            max(1, nearest(scale*width,  multiple=2, type=int, operator=round)),
-            max(1, nearest(scale*height, multiple=2, type=int, operator=round))
-        )
+    def round_component(component: Number, *, scale: Number=1) -> int:
+        return max(1, nearest(scale*component, multiple=2, type=int, operator=round))
+
+    @staticmethod
+    def round_resolution(width: Number, height: Number, *, scale: Number=1) -> Tuple[int, int]:
+        """FFmpeg likes multiples of 2, so let's make it happy"""
+        return tuple(map(BrokenResolution.round_component, (scale*width, scale*height)))
 
     @staticmethod
     def fit(
-        ow: int,
-        oh: int,
-        nw: int=None,
-        nh: int=None,
-        sc: float=1.0,
+        old: Tuple[int, int]=None,
+        new: Tuple[int, int]=None,
+        max: Tuple[int, int]=None,
         ar: float=None,
-        mw: int=None,
-        mh: int=None,
     ) -> Tuple[int, int]:
         """Fit, Scale and optionally force Aspect Ratio on a base to a (un)limited target resolution
 
         This method solves the following problem:
             "A window is at some initial size (ow, oh) and a resize was asked to (nw, nh); what
             final resolution the window should be, optionally enforcing an aspect ratio (ar),
             and limited by the monitor resolution (mw, mh)?"
@@ -38,72 +35,125 @@
         To which, the behavior is as follows in the two branches:
             No aspect ratio (ar=None) is send:
                 - Returns the original resolution overrided by any new (nw, nh)
 
             Aspect ratio (ar!=None) is send:
                 - If any of the new (nw, nh) is missing, find the other based on the aspect ratio
                 - Else, prioritize width changes, and downscale/upscale accordingly;
-                - Limits the resolution to (mw, mh) by multiplying both components to max fit it
+                - Post-limits resolution to (mw, mh) by multiplying both components to max fit it
 
         Notes
         -----
             - The resolution is rounded to the nearest multiple of 2, so FFmpeg is happy
 
         Parameters
         ----------
-        ow
-            Original width
-        oh
-            Original height
-        nw
-            Target width
-        nh
-            Target height
-        sc
-            Scale factor
+        old
+            Old resolution
+        new
+            New resolution
+        max
+            Maximum resolution
         ar
             Force aspect ratio, if any
-        mw
-            Maximum width
-        mh
-            Maximum height
 
         Returns
         -------
         (int, int)
             The new best-fit width and height
         """
-        log.debug(f"Fit resolution: ({ow}, {oh}) -> ({nw}, {nh})^({mw}, {mh}) @ {sc}x, AR {ar}")
+
+        # Unpack
+        old_width, old_height = (old or (None, None))
+        new_width, new_height = (new or (None, None))
+        max_width, max_height = (max or (None, None))
+
+        log.debug(f"Fit resolution: ({old_width}, {old_height}) -> ({new_width}, {new_height})^({max_width}, {max_height}), AR {ar}")
 
         # Force or keep either component
-        (w, h) = ((nw or ow), (nh or oh))
+        (width, height) = ((new_width or old_width), (new_height or old_height))
+
+        if not all((width, height)):
+            raise ValueError("Can't build a resolution with missing component(s): ({width}, {height})")
 
         if (ar is None):
             pass
 
         else:
             # Build from width (W) or from height (H)
-            W = (w, w/ar)
-            H = (h*ar, h)
+            from_width  = (width, width/ar)
+            from_height = (height*ar, height)
 
             # Pick the non missing component's
-            if (nh is None):
-                (w, h) = W
-            elif (nw is None):
-                (w, h) = H
+            if (new_height is None):
+                (width, height) = from_width
+            elif (new_width is None):
+                (width, height) = from_height
 
             # Based on upscale or downscale
-            elif (nw != ow):
-                (w, h) = W
-            elif (nh != oh):
-                (w, h) = H
+            elif (new_width != old_width):
+                (width, height) = from_width
+            elif (new_height != old_height):
+                (width, height) = from_height
 
         # Limit the resolution to (mw, mh) bounding box and keep aspect ratio
         # - The idea is to find the maximum reduce factor for either component so it normalizes
         #   to the respective (mw, mh), and apply it to both components to scale down
-        reduce = max(
-            w/min(w, mw or math.inf),
-            h/min(h, mh or math.inf)
-        )
-        w, h = (w/reduce, h/reduce)
+        if (ar is not None):
+            reduce = __builtins__["max"](
+                width/(min(width, max_width or math.inf) or 1),
+                height/(min(height, max_height or math.inf) or 1)
+            ) or 1
+
+            width, height = (width/reduce, height/reduce)
+
+        else:
+            # Limit each component independently
+            width  = min(width,  max_width or math.inf)
+            height = min(height, max_height or math.inf)
+
+        return BrokenResolution.round_resolution(width, height)
+
+# -------------------------------------------------------------------------------------------------|
+# Test
+
+class _PyTest:
+    def test_round_component(self):
+        assert BrokenResolution.round_component(100) == 100
+        assert BrokenResolution.round_component(2.5) == 2
+        assert BrokenResolution.round_component(3.2) == 4
+
+    def test_round_resolution(self):
+        assert BrokenResolution.round_resolution(1920, 1080)   == (1920, 1080)
+        assert BrokenResolution.round_resolution(1921, 1080.0) == (1920, 1080)
+        assert BrokenResolution.round_resolution(1921.5, 1080) == (1922, 1080)
+        assert BrokenResolution.round_resolution(1920, 1080, scale=2) == (3840, 2160)
+
+    def test_keep_nothing(self):
+        assert BrokenResolution.fit(old=(1920, 1080)) == (1920, 1080)
+
+    def test_override_components(self):
+        assert BrokenResolution.fit(old=(1920, 1080), new=(1280, None)) == (1280, 1080)
+        assert BrokenResolution.fit(old=(1920, 1080), new=(None, 720))  == (1920, 720)
+
+    def test_missing_components(self):
+        import pytest
+        with pytest.raises(ValueError):
+            BrokenResolution.fit(old=(1920, None), new=(1280, None))
+        with pytest.raises(ValueError):
+            BrokenResolution.fit(old=(None, 1080), new=(None, None))
+
+    def test_aspect_ratio(self):
+        # Widescreen
+        assert BrokenResolution.fit(old=(1920, 1080), new=(1280, None), ar=16/9) == (1280, 720)
+        assert BrokenResolution.fit(old=(1920, 1080), new=(None, 720),  ar=16/9) == (1280, 720)
+        # Univisium
+        assert BrokenResolution.fit(old=(1920, 1080), new=(1000, None), ar=2.0) == (1000, 500)
+        assert BrokenResolution.fit(old=(1920, 1080), new=(None, 500),  ar=2.0) == (1000, 500)
+
+    def test_aspect_ratio_prioritize_width(self):
+        assert BrokenResolution.fit(old=(1920, 1080), new=(1000, 720), ar=2) == (1000, 500)
+
+    def test_limit_maximum_resolution(self):
+        assert BrokenResolution.fit(old=(3840, 2160), new=(3800, 2100), max=(1920, 1080)) == (1920, 1080)
+        assert BrokenResolution.fit(old=(3000, 3000), new=(2000, 2000), max=(6000, 720), ar=16/9) == (1280, 720)
 
-        return BrokenResolution.round(width=w, height=h, scale=sc)
```

## Broken/Core/BrokenScheduler.py

```diff
@@ -1,14 +1,14 @@
 import contextlib
 import functools
 import inspect
 import time
 from collections import deque
 from threading import Lock
-from typing import Any, Callable, Deque, Dict, Iterable, List, Self
+from typing import Any, Callable, Deque, Dict, Iterable, List, Optional, Self
 
 from attr import Factory, define, field
 
 from Broken import BIG_BANG
 from Broken.Types import Hertz, Seconds
 
 
@@ -24,15 +24,15 @@
     args: List[Any] = field(factory=list, repr=False)
     """Method's positional arguments"""
 
     kwargs: Dict[str, Any] = field(factory=dict, repr=False)
     """Method's keyword arguments"""
 
     output: Any = field(default=None, repr=False)
-    """Method's return value after last call"""
+    """Method's return value of the last call"""
 
     context: Any = None
     """Context to use when calling task (with statement)"""
 
     lock: Lock = None
     """Threading Lock to use when calling task (with statement)"""
 
@@ -46,16 +46,16 @@
 
     frequency: Hertz = 60.0
     """Ideal frequency of task calls"""
 
     frameskip: bool = True
     """Constant deltatime mode (False) or real deltatime mode (True)"""
 
-    decoupled: bool = False
-    """"Rendering" mode, do not sleep on real time"""
+    freewheel: bool = False
+    """"Rendering" mode, do not sleep on real time, exact virtual frametimes"""
 
     precise: bool = False
     """Use precise time sleeping for near-perfect frametimes"""
 
     # # Timing
     started: Seconds = Factory(lambda: time.bang_counter())
     """Time when client was started (initializes $now+started, value in now() seconds)"""
@@ -72,15 +72,15 @@
 
     def __attrs_post_init__(self):
         signature = inspect.signature(self.task)
         self._dt   = ("dt"   in signature.parameters)
         self._time = ("time" in signature.parameters)
 
         # Assign idealistic values for decoupled
-        if self.decoupled: self.started = BIG_BANG
+        if self.freewheel: self.started = BIG_BANG
         self.last_call = (self.last_call or self.started)
         self.next_call = (self.next_call or self.started)
 
         # Note: We could use numpy.float128 for the most frametime precision on the above..
         #       .. But the Client code is smart enough to auto adjust itself to sync
 
     # # Useful properties
@@ -115,33 +115,33 @@
         return self.next_call < other.next_call
 
     def __gt__(self, other: Self) -> bool:
         return self.next_call > other.next_call
 
     # # Implementation
 
-    def next(self, block: bool=True) -> None | Any:
+    def next(self, block: bool=True) -> Self:
 
         # Time to wait for next call if block
         # - Next call at 110 seconds, now=100, wait=10
         # - Positive means to wait, negative we are behind
         wait = max(0, (self.next_call - time.bang_counter()))
 
-        if self.decoupled:
+        if self.freewheel:
             pass
         elif block:
             if self.precise:
                 time.precise_sleep(wait)
             else:
                 time.sleep(wait)
         elif wait > 0:
             return None
 
         # The assumed instant the code below will run instantly
-        now = self.next_call if self.decoupled else time.bang_counter()
+        now = self.next_call if self.freewheel else time.bang_counter()
         if self._dt:   self.kwargs["dt"]   = (now - self.last_call)
         if self._time: self.kwargs["time"] = (now - self.started)
 
         # Enter or not the given context, call task with args and kwargs
         with (self.lock or contextlib.nullcontext()):
             with (self.context or contextlib.nullcontext()):
                 self.output = self.task(*self.args, **self.kwargs)
@@ -186,25 +186,25 @@
     def enabled_tasks(self) -> Iterable[BrokenTask]:
         """Returns a list of enabled clients"""
         for client in self.clients:
             if client.enabled:
                 yield client
 
     @property
-    def next_task(self) -> BrokenTask | None:
+    def next_task(self) -> Optional[BrokenTask]:
         """Returns the next client to be called"""
         return min(self.enabled_tasks)
 
     def _sanitize(self) -> None:
         """Removes not enabled 'once' clients"""
         self.clients = list(filter(lambda client: client.tag_alive, self.clients))
 
     # # Actions
 
-    def next(self, block=True) -> None | Any:
+    def next(self, block=True) -> Optional[BrokenTask]:
         try:
             if (client := self.next_task):
                 return client.next(block=block)
         finally:
             self._sanitize()
 
     def all_once(self) -> None:
@@ -214,15 +214,15 @@
                 client.next()
         self._sanitize()
 
     # # Block-free next
 
     __work__: bool = False
 
-    def smart_next(self) -> None | Any:
+    def smart_next(self) -> Optional[BrokenTask]:
         # Note: Proof of concept. The frametime Ticking might be enough for ShaderFlow
 
         # Too close to the next known call, call blocking
         if abs(time.bang_counter() - self.next_task.next_call) < 0.005:
             return self.next(block=True)
 
         # By chance any "recently added" client was added
```

## Broken/Core/BrokenSpinner.py

```diff
@@ -7,19 +7,20 @@
 
 
 class Spinners:
     Simple: str = "â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
 
 @define
 class BrokenSpinner:
+
     text: str = ""
-    """The text to display next to the spinner. Also defines if the spinner is active."""
+    """The text to display next to the spinner. Also defines if the spinner is active"""
 
     spinner: Union[str, List[str]] = Spinners.Simple
-    """A Sequence or list of printable objects to use as the spinner."""
+    """A Sequence or list of printable objects to use as the spinner"""
 
     framerate: float = 10
     """Update rate of the spinner"""
 
     _index: int = 0
     """Current index of the spinner"""
```

## Broken/Core/BrokenTyper.py

```diff
@@ -1,45 +1,32 @@
-from __future__ import annotations
-
 import contextlib
 import shlex
 from typing import (
     Callable,
     Generator,
     List,
 )
 
 from attr import Factory, define
 from loguru import logger as log
 from typer import Typer
 
 import Broken
 from Broken import flatten
-from Broken.Core.BrokenUtils import Ignore
 
 
 @define
 class BrokenTyper:
-    """
-    A wrap around Typer with goodies
-
-    â€¢ Why? Automation.
-    â€¢ Stupid? Absolutely.
-    â€¢ Useful? Maybe.
-    â€¢ Fun? Yes.
-    â€¢ Worth it? Probably not.
-    â€¢ Will I use it? Yes.
-    """
+    """A wrap around Typer with goodies. # Todo: Maybe try Cyclopts"""
     description: str       = ""
     app:         Typer     = None
     chain:       bool      = False
     commands:    List[str] = Factory(list)
     default:     str       = None
     help_option: bool      = False
-    exit_hook:   Callable  = Factory(Ignore)
     __first__:   bool      = True
     epilog:      str       = (
         f"â€¢ Made with [red]:heart:[/red] by [green]Broken Source Software[/green] [yellow]v{Broken.VERSION}[/yellow]\n\n"
         "â†’ [italic grey53]Consider [blue][link=https://www.patreon.com/Tremeschin]Sponsoring[/link][/blue] my Open Source Work[/italic grey53]"
     )
 
     def __attrs_post_init__(self):
@@ -113,18 +100,16 @@
             if not self.__first__:
                 args = shlex.split(input("\n:: BrokenShell (enter for help) $ "))
             self.__first__ = False
 
             try:
                 self.app(args)
             except SystemExit:
-                self.exit_hook()
+                log.trace("Skipping SystemExit on BrokenTyper")
             except KeyboardInterrupt:
-                log.success("BrokenTyper stopped by user")
-                self.exit_hook()
-            except Exception as e:
-                self.exit_hook()
-                raise e
+                log.success("BrokenTyper exit KeyboardInterrupt")
+            except Exception as error:
+                raise error
 
             # Don't continue on non BrokenShell mode
             if not shell:
                 break
```

## Broken/Core/BrokenUtils.py

```diff
@@ -1,37 +1,42 @@
 from __future__ import annotations
 
 import copy
 from abc import ABC, abstractmethod
-from typing import (
-    Any,
-    Self,
-)
+from typing import Any, Self
 
 from attr import Factory, define
 from loguru import logger as log
 
 from Broken import flatten
 
 
 @define
 class SameTracker:
-    """Doumo same desu"""
+    """Doumo same desu. If a value is the same, returns True, else updates it and returns False
+    â€¢ Useful on ignoring expensive calls where parameters doesn't changes"""
     value: Any = None
 
-    def __call__(self, value: Any) -> bool:
-        """
-        If a value is the same, returns True, else updates it and returns False
-        â€¢ Useful on ignoring expensive calls where parameters doesn't changes
-        """
+    def __call__(self, value: Any=True) -> bool:
         if self.value != value:
             self.value = value
             return False
         return True
 
+@define
+class OnceTracker:
+    """Returns False the first time it's called, never nest style: `if once/already(): return`"""
+    _first: bool = False
+
+    def __call__(self) -> bool:
+        if not self._first:
+            self._first = True
+            return False
+        return True
+
 class Ignore:
     """A class that does nothing. No-operation faster Mock"""
     def __nop__(self, *args, **kwargs) -> Self:
         return self
     def __call__(self, *args, **kwargs) -> Self:
         return self
     def __getattr__(self, _):
@@ -44,16 +49,17 @@
     # Fixme: Can improve by starting on BrokenAttrs itself
     """
     def __attrs_post_init__(self):
         for cls in reversed(type(self).mro()):
             if method := cls.__dict__.get("__post__"):
                 method(self)
 
+    @abstractmethod
     def __post__(self) -> None:
-        pass
+        ...
 
 class BrokenWatchdog(ABC):
 
     @abstractmethod
     def __changed__(self, key, value) -> None:
         """Called when a property changes"""
         ...
```

## Broken/Core/__init__.py

```diff
@@ -1,25 +1,30 @@
+import contextlib
 import enum
 import hashlib
 import inspect
 import os
+import re
 import shutil
 import subprocess
 import sys
 import time
 import types
 import uuid
 from numbers import Number
 from pathlib import Path
 from typing import (
     Any,
     Callable,
+    Dict,
     Generator,
     Iterable,
     List,
+    Optional,
+    Tuple,
     Union,
 )
 
 import click
 from loguru import logger as log
 
 
@@ -142,15 +147,15 @@
         return
 
     # Update kwargs on the fly
     kwargs["env"] = os.environ | (env or {})
     kwargs["shell"] = shell
 
     # preexec_fn is not supported on windows, pop from kwargs
-    if (os.name == "nt") and (_ := kwargs.pop("preexec_fn", None)):
+    if (os.name == "nt") and (kwargs.pop("preexec_fn")):
         log.minor("preexec_fn is not supported on Windows, ignoring..")
 
     # Run the command and return specified object
     if output: return subprocess.check_output(command, **kwargs).decode("utf-8")
     if Popen:  return subprocess.Popen(command, **kwargs)
     else:      return subprocess.run(command, **kwargs)
 
@@ -161,18 +166,81 @@
     """map(f, x) is lazy, this consumes the generator, returning a list"""
     return list(map(callback, iterable))
 
 def denum(item: Union[enum.Enum, Any]) -> Any:
     """De-enumerates an item: Returns the item's value if Enum else the item itself"""
     return (item.value if isinstance(item, enum.Enum) else item)
 
-@staticmethod
 def dunder(name: str) -> bool:
     return name.startswith("__") and name.endswith("__")
 
+def hyphen_range(string: Optional[str], *, inclusive: bool=True) -> Generator[int, None, None]:
+    """
+    Yields the numbers in a hyphenated CSV range, just like when selecting what pages to print
+    - Accepts "-", "..", "...", or a hyphenated range
+
+    Example:
+        ```python
+        hyphen_range("2,3") # 2, 3
+        hyphen_range("2-5") # 2, 3, 4, 5
+        hyphen_range("1-3, 5") # 1, 2, 3, 5
+        ```
+    """
+    if not bool(string):
+        return None
+
+    for part in string.split(","):
+        if ("-" in part):
+            start, end = map(int, re.split("-|\.\.|\.\.\.", part))
+            yield from range(start, end + int(inclusive))
+        else:
+            yield int(part)
+
+def image_hash(image) -> str:
+    """A Fast-ish method to get an object's hash that implements .tobytes()"""
+    return str(uuid.UUID(hashlib.sha256(image.tobytes()).hexdigest()[::2]))
+
+def nearest(number: Number, multiple: Number, *, type=int, operator: Callable=round) -> Number:
+    """Finds the nearest multiple of a base number"""
+    return type(multiple * operator(number/multiple))
+
+def limited_integer_ratio(number: Optional[float], *, limit: float=None) -> Optional[Tuple[int, int]]:
+    """Same as Number.as_integer_ratio but with an optional upper limit and optional return"""
+    if number is None:
+        return None
+
+    num, den = number.as_integer_ratio()
+
+    if limit and (den > limit or num > limit):
+        normalize = limit/min(num, den)
+        num, den = int(num * normalize), int(den * normalize)
+
+    return num, den
+
+def have_import(module: str, *, load: bool=False) -> bool:
+    if load:
+        try:
+            __import__(module)
+            return True
+        except ImportError:
+            return False
+    return sys.modules.get(module, False)
+
+@contextlib.contextmanager
+def temp_env(**env: Dict[str, str]) -> Generator[None, None, None]:
+    """Temporarily sets environment variables"""
+    old = os.environ.copy()
+    os.environ.clear()
+    os.environ.update({k: str(v) for k, v in (old | env).items() if v})
+    yield
+    os.environ.clear()
+    os.environ.update(old)
+
+# -------------------------------------------------------------------------------------------------|
+
 def transcends(method, base, generator: bool=False):
     """
     Are you tired of managing and calling super().<name>(*args, **kwargs) in your methods?
     > We have just the right solution for you!
 
     Introducing transcends, the decorator that crosses your class's MRO and calls the method
     with the same name as the one you are decorating. It's an automatic super() !
@@ -210,22 +278,14 @@
 
     # Remove self from locals
     if self:
         locals.pop("self", None)
 
     return locals
 
-def image_hash(image) -> str:
-    """A Fast-ish method to get an object's hash that implements .tobytes()"""
-    return str(uuid.UUID(hashlib.sha256(image.tobytes()).hexdigest()[::2]))
-
-def nearest(number: Number, multiple: Number, *, type=int, operator: Callable=round) -> Number:
-    """Finds the nearest multiple of a base number"""
-    return type(multiple * operator(number/multiple))
-
 def extend(base: type, name: str=None, as_property: bool=False) -> type:
     """
     Extend a class with another class's methods or a method directly.
 
     # Usage:
     Decorator of the class or method, class to extend as argument
 
@@ -262,16 +322,7 @@
         for key, value in add.__dict__.items():
             if key.startswith("__"):
                 continue
             setattr(base, key, value)
             return base
 
     return extender
-
-def have_import(module: str, *, load: bool=False) -> bool:
-    if load:
-        try:
-            __import__(module)
-            return True
-        except ImportError:
-            return False
-    return sys.modules.get(module, False)
```

## Broken/Core/Staging/BrokenDotmap.py

```diff
@@ -107,31 +107,30 @@
     def from_file(self, path: Path) -> Self:
         """Load a file into this dotmap instance"""
         path   = BrokenPath(path)
         format = path.suffix.lower()
 
         # Load data from file
         try:
-            match format:
-                case ".toml":
-                    import toml
-                    data = toml.loads(path.read_text())
-                case ".json":
-                    import json
-                    data = json.loads(path.read_text())
-                case ".yaml":
-                    import yaml
-                    data = yaml.load(path.read_text(), Loader=yaml.FullLoader)
-                case ".pickle":
-                    import pickle
-                    data = pickle.loads(path.read_bytes())
-                case _:
-                    log.error(f"â€¢ BrokenDotmap: Unknown file format ({format})")
-                    log.error(f"â””â”€ File: ({path})")
-                    return
+            if (format == ".toml"):
+                import toml
+                data = toml.loads(path.read_text())
+            elif (format == ".json"):
+                import json
+                data = json.loads(path.read_text())
+            elif (format == ".yaml"):
+                import yaml
+                data = yaml.load(path.read_text(), Loader=yaml.FullLoader)
+            elif (format == ".pickle"):
+                import pickle
+                data = pickle.loads(path.read_bytes())
+            else:
+                log.error(f"â€¢ BrokenDotmap: Unknown file format ({format})")
+                log.error(f"â””â”€ File: ({path})")
+                return
 
         except Exception as e:
             log.error(f"â€¢ BrokenDotmap: Failed to load file ({path})")
             log.error(f"â””â”€ {e}")
             return
 
         return self.from_dict(data)
@@ -233,23 +232,22 @@
         if not self.__sync__:
             return
 
         # Get the full dictionary to save
         dict = self.to_dict()
 
         # Load file based on format
-        match self.__ext__:
-            case ".toml":
-                import toml
-                self.__path__.write_text(toml.dumps(dict))
-            case ".json":
-                import json
-                self.__path__.write_text(json.dumps(dict, indent=2, ensure_ascii=False))
-            case ".yaml":
-                import yaml
-                self.__path__.write_text(yaml.dump(dict))
-            case ".pickle":
-                import pickle
-                self.__path__.write_bytes(pickle.dumps(dict))
-            case _:
-                log.error(f"BrokenDotmap: Unknown file format ({self.__ext__}), cannot save to file")
-                return
+        if (self.__ext__ == ".toml"):
+            import toml
+            self.__path__.write_text(toml.dumps(dict))
+        elif (self.__ext__ == ".json"):
+            import json
+            self.__path__.write_text(json.dumps(dict, indent=2, ensure_ascii=False))
+        elif (self.__ext__ == ".yaml"):
+            import yaml
+            self.__path__.write_text(yaml.dump(dict))
+        elif (self.__ext__ == ".pickle"):
+            import pickle
+            self.__path__.write_bytes(pickle.dumps(dict))
+        else:
+            log.error(f"BrokenDotmap: Unknown file format ({self.__ext__}), cannot save to file")
+            return
```

## DepthFlow/DepthFlow.py

```diff
@@ -1,173 +1,195 @@
+from __future__ import annotations
+
 import math
-from typing import Annotated, Iterable, Tuple
+from typing import Annotated, Iterable, Self, Tuple
 
 import imgui
 from attr import define, field
+from pydantic import BaseModel, Field
 from ShaderFlow import SHADERFLOW
 from ShaderFlow.Message import Message
-from ShaderFlow.Optional.Monocular import Monocular
+from ShaderFlow.Optional.Monocular import DepthEstimator
 from ShaderFlow.Scene import ShaderScene
 from ShaderFlow.Texture import ShaderTexture
 from ShaderFlow.Variable import ShaderVariable
 from typer import Option
 
 from Broken import image_hash
 from Broken.Externals.Upscaler import BrokenUpscaler
 from Broken.Externals.Upscaler.ncnn import BrokenRealEsrgan
 from Broken.Loaders import LoaderImage
 from DepthFlow import DEPTHFLOW
 
 
+class DepthFlowState(BaseModel):
+
+    height: float = Field(default=0.35)
+    """Peak value of the Depth Map, in the range [0, 1]. The camera is 1 distance away from depth=0
+    at the z=1 plane, so this also controls the intensity of the effect"""
+
+    focus: float = Field(default=0.0)
+    """Focal depth of offsets, in the range [0, 1]. A value of 0 makes the background (depth=0)
+    stationary, while a value of 1 makes the foreground (depth=1) stationary on offset changes"""
+
+    plane: float = Field(default=0.5)
+    """Focal depth of projections, in the range [0, 1]. A value of 0 makes the background (depth=0)
+    stationaty, while a value of 1 makes the foreground (depth=1) stationary on isometric changes"""
+
+    invert: float = Field(default=0.0)
+    """Interpolate between (0=max, 1=min)=0 or (0=min, 1=max)=1 Depth Map's value interpretation"""
+
+    zoom: float = Field(default=1.0)
+    """Camera zoom factor, in the range [0, inf]. 2 means a quarter of the image is visible"""
+
+    isometric: float = Field(default=0.0)
+    """Isometric factor of the camera projection. Zero is fully perspective, 1 is orthographic"""
+
+    dolly: float = Field(default=0.0)
+    """Same effect as isometric, but with "natural units" of AFAIK `isometric = atan(dolly)*(2/pi)`.
+    Keeps the ray target constant and move back ray origins by this amount"""
+
+    offset_x: float = Field(default=0)
+    """Parallax horizontal displacement, change this over time for the 3D effect"""
+
+    offset_y: float = Field(default=0)
+    """Parallax vertical displacement, change this over time for the 3D effect"""
+
+    @property
+    def offset(self) -> Tuple[float, float]:
+        """Parallax displacement, change this over time for the 3D effect"""
+        return (self.offset_x, self.offset_y)
+
+    @offset.setter
+    def offset(self, value: Tuple[float, float]):
+        self.offset_x, self.offset_y = value
+
+    center_x: float = Field(default=0)
+    """Hozirontal focal point of the offset, as if the camera was above this point"""
+
+    center_y: float = Field(default=0)
+    """Vertical focal point of the offset, as if the camera was above this point"""
+
+    @property
+    def center(self) -> Tuple[float, float]:
+        """Focal point of the offset, as if the camera was above this point"""
+        return (self.center_x, self.center_y)
+
+    @center.setter
+    def center(self, value: Tuple[float, float]):
+        self.center_x, self.center_y = value
+
+    mirror: bool = Field(default=True)
+    """Apply GL_MIRRORED_REPEAT to the image, makes it continuous"""
+
+    def reset(self) -> None:
+        for name, field in self.model_fields.items(): # noqa
+            setattr(self, name, field.default)
+
+# -------------------------------------------------------------------------------------------------|
+
 @define
 class DepthFlowScene(ShaderScene):
-    """ðŸŒŠ Image to â†’ 2.5D Parallax Effect Video. High quality, user first."""
+    """ðŸŒŠ Image to â†’ 2.5D Parallax Effect Video. High quality, user first"""
     __name__ = "DepthFlow"
 
     # Constants
-    DEFAULT_IMAGE  = "https://w.wallhaven.cc/full/pk/wallhaven-pkz5r9.png"
-    DEPTH_SHADER   = (DEPTHFLOW.RESOURCES.SHADERS/"DepthFlow.frag")
-    LOADING_SHADER = (SHADERFLOW.RESOURCES.FRAGMENT/"Loading.frag")
+    DEFAULT_IMAGE = "https://w.wallhaven.cc/full/pk/wallhaven-pkz5r9.png"
+    DEPTH_SHADER  = (DEPTHFLOW.RESOURCES.SHADERS/"DepthFlow.frag")
 
     # DepthFlow objects
-    monocular: Monocular = field(factory=Monocular)
+    estimator: DepthEstimator = field(factory=DepthEstimator)
     upscaler: BrokenUpscaler = field(factory=BrokenRealEsrgan)
-
-    # ------------------------------------------|
-    # Parallax MDE and Loading screen tricky implementation
+    state: DepthFlowState = field(factory=DepthFlowState)
 
     def input(self,
         image: Annotated[str,  Option("--image",   "-i", help="â€¢ (Basic  ) Image to Parallax (Path, URL, NumPy, PIL)")],
         depth: Annotated[str,  Option("--depth",   "-d", help="â€¢ (Basic  ) Depthmap of the Image, None to estimate")]=None,
         cache: Annotated[bool, Option(" /--nc",          help="â€¢ (Basic  ) Cache the Depthmap estimations on Disk")]=True,
         ratio: Annotated[Tuple[int, int], Option("--upscale", "-u", help="â€¢ (Upscale) Upscale the Input and Depthmap respectively with Realesrgan (1, 2, 3, 4)")]=(1, 1),
-    ):
+    ) -> None:
         image = LoaderImage(image)
-        depth = LoaderImage(depth) or self.monocular.estimate(image, cache=cache)
+        depth = LoaderImage(depth) or self.estimator.estimate(image, cache=cache)
         width, height = image.size
         cache = DEPTHFLOW.DIRECTORIES.CACHE/f"{image_hash(image)}"
         depth = self.upscaler.upscale(depth, scale=ratio[1])
         image = self.upscaler.upscale(image, scale=ratio[0])
         self.aspect_ratio = (width/height)
         self.image.from_image(image)
         self.depth.from_image(depth)
         self.time = 0
 
-    # ------------------------------------------|
-
-    parallax_height: float = field(default=0.2)
-    """Peak value of the Depth Map, in the range [0, 1]. The camera is 1 distance away from depth=0
-    at the z=1 plane, so this also controls the intensity of the effect"""
-
-    parallax_focus: float = field(default=0.0)
-    """Focal depth of the effect, in the range [0, 1]. A value of 0 makes the background (depth=0)
-    stationary, while a value of 1 makes the foreground (depth=1) stationary on displacements"""
-
-    parallax_invert: float = field(default=0.0)
-    """Interpolate between (0=max, 1=min)=0 or (0=min, 1=max)=1 Depth Map's value interpretation"""
-
-    parallax_zoom: float = field(default=1.0)
-    """Camera zoom factor, in the range [0, inf]. 2 means a quarter of the image is visible"""
-
-    parallax_isometric: float = field(default=0.0)
-    """Isometric factor of the camera projection. Zero is fully perspective, 1 is orthographic"""
-
-    parallax_dolly: float = field(default=0.0)
-    """Same effect as isometric, but with "natural units" of AFAIK `isometric = atan(dolly)*(2/pi)`.
-    Keeps the ray target constant and move back ray origins by this amount"""
-
-    parallax_offset: Tuple[float, float] = field(factory=lambda: [0.0, 0.0])
-    """The effect displacement offset, change this over time for the 3D parallax effect"""
-
-    parallax_center: Tuple[float, float] = field(factory=lambda: [0.0, 0.0])
-    """Focal point of the offsets, use this to center off-screen objects"""
-
     def commands(self):
         self.broken_typer.command(self.input)
 
     def setup(self):
         if self.image.is_empty():
             self.input(image=DepthFlowScene.DEFAULT_IMAGE)
 
     def build(self):
         ShaderScene.build(self)
         self.image = ShaderTexture(scene=self, name="image").repeat(False)
         self.depth = ShaderTexture(scene=self, name="depth").repeat(False)
         self.shader.fragment = self.DEPTH_SHADER
+        self.aspect_ratio = (16/9)
 
     def update(self):
 
         # In and out dolly zoom
-        self.parallax_dolly = 0.5*(1 + math.cos(self.time))
+        self.state.dolly = (0.5 + 0.5*math.cos(self.time))
 
         # Infinite 8 loop shift
-        self.parallax_offset = [
-            0.1 * math.sin(self.time),
-            0.1 * math.sin(2*self.time)
-        ]
+        self.state.offset_x = (0.1 * math.sin(self.time))
+        self.state.offset_y = (0.1 * math.sin(2*self.time))
 
         # # Oscillating rotation
         self.camera.rotate(
             direction=self.camera.base_z,
             angle=math.cos(self.time)*self.dt*0.4
         )
 
         # Zoom in on the start
-        # self.parallax_zoom = 1.2 - 0.2*(2/math.pi)*math.atan(self.time)
+        # self.config.zoom = 1.2 - 0.2*(2/math.pi)*math.atan(self.time)
 
     def handle(self, message: Message):
         ShaderScene.handle(self, message)
 
         if isinstance(message, Message.Window.FileDrop):
             files = iter(message.files)
             self.input(image=next(files), depth=next(files, None))
 
     def pipeline(self) -> Iterable[ShaderVariable]:
         yield from ShaderScene.pipeline(self)
-        yield ShaderVariable("uniform", "float", "iParallaxHeight",    self.parallax_height)
-        yield ShaderVariable("uniform", "float", "iParallaxFocus",     self.parallax_focus)
-        yield ShaderVariable("uniform", "float", "iParallaxInvert",    self.parallax_invert)
-        yield ShaderVariable("uniform", "float", "iParallaxZoom",      self.parallax_zoom)
-        yield ShaderVariable("uniform", "float", "iParallaxIsometric", self.parallax_isometric)
-        yield ShaderVariable("uniform", "float", "iParallaxDolly",     self.parallax_dolly)
-        yield ShaderVariable("uniform", "vec2",  "iParallaxOffset",    self.parallax_offset)
-        yield ShaderVariable("uniform", "vec2",  "iParallaxCenter",    self.parallax_center)
-
-    # ------------------------------------------|
+        yield ShaderVariable("uniform", "float", "iParallaxHeight",    self.state.height)
+        yield ShaderVariable("uniform", "float", "iParallaxFocus",     self.state.focus)
+        yield ShaderVariable("uniform", "float", "iParallaxPlane",     self.state.plane)
+        yield ShaderVariable("uniform", "float", "iParallaxInvert",    self.state.invert)
+        yield ShaderVariable("uniform", "float", "iParallaxZoom",      self.state.zoom)
+        yield ShaderVariable("uniform", "float", "iParallaxIsometric", self.state.isometric)
+        yield ShaderVariable("uniform", "float", "iParallaxDolly",     self.state.dolly)
+        yield ShaderVariable("uniform", "vec2",  "iParallaxOffset",    self.state.offset)
+        yield ShaderVariable("uniform", "vec2",  "iParallaxCenter",    self.state.center)
+        yield ShaderVariable("uniform", "bool",  "iParallaxMirror",    self.state.mirror)
 
     def ui(self) -> None:
-        if (state := imgui.slider_float("Height", self.parallax_height, 0, 1, "%.2f"))[0]:
-            self.parallax_height = max(0, state[1])
-        if (state := imgui.slider_float("Focus", self.parallax_focus, 0, 1, "%.2f"))[0]:
-            self.parallax_focus = max(0, state[1])
-        if (state := imgui.slider_float("Invert", self.parallax_invert, 0, 1, "%.2f"))[0]:
-            self.parallax_invert = max(0, state[1])
-        if (state := imgui.slider_float("Zoom", self.parallax_zoom, 0, 2, "%.2f"))[0]:
-            self.parallax_zoom = max(0, state[1])
-        if (state := imgui.slider_float("Isometric", self.parallax_isometric, 0, 1, "%.2f"))[0]:
-            self.parallax_isometric = max(0, state[1])
-        if (state := imgui.slider_float("Dolly", self.parallax_dolly, 0, 5, "%.2f"))[0]:
-            self.parallax_dolly = max(0, state[1])
-        if (state := imgui.slider_float("Offset X", self.parallax_offset[0], -2, 2, "%.2f"))[0]:
-            self.parallax_offset[0] = state[1]
-        if (state := imgui.slider_float("Offset Y", self.parallax_offset[1], -2, 2, "%.2f"))[0]:
-            self.parallax_offset[1] = state[1]
-        if (state := imgui.slider_float("Center X", self.parallax_center[0], -2, 2, "%.2f"))[0]:
-            self.parallax_center[0] = state[1]
-        if (state := imgui.slider_float("Center Y", self.parallax_center[1], -2, 2, "%.2f"))[0]:
-            self.parallax_center[1] = state[1]
-
-# -------------------------------------------------------------------------------------------------|
-
-class YourFlow(DepthFlowScene):
-    """Example of defining your own class based on DepthFlowScene"""
-
-    def update(self):
-        DepthFlowScene.update(self)
-
-    def pipeline(self) -> Iterable[ShaderVariable]:
-        yield from DepthFlowScene.pipeline(self)
-        ...
-
-    def handle(self, message: Message):
-        DepthFlowScene.handle(self, message)
-        ...
+        if (state := imgui.slider_float("Height", self.state.height, 0, 1, "%.2f"))[0]:
+            self.state.height = max(0, state[1])
+        if (state := imgui.slider_float("Focus", self.state.focus, 0, 1, "%.2f"))[0]:
+            self.state.focus = max(0, state[1])
+        if (state := imgui.slider_float("Plane", self.state.plane, 0, 1, "%.2f"))[0]:
+            self.state.plane = max(0, state[1])
+        if (state := imgui.slider_float("Invert", self.state.invert, 0, 1, "%.2f"))[0]:
+            self.state.invert = max(0, state[1])
+        if (state := imgui.slider_float("Zoom", self.state.zoom, 0, 2, "%.2f"))[0]:
+            self.state.zoom = max(0, state[1])
+        if (state := imgui.slider_float("Isometric", self.state.isometric, 0, 1, "%.2f"))[0]:
+            self.state.isometric = max(0, state[1])
+        if (state := imgui.slider_float("Dolly", self.state.dolly, 0, 5, "%.2f"))[0]:
+            self.state.dolly = max(0, state[1])
+        if (state := imgui.slider_float("Offset X", self.state.offset_x, -2, 2, "%.2f"))[0]:
+            self.state.offset_x = state[1]
+        if (state := imgui.slider_float("Offset Y", self.state.offset_y, -2, 2, "%.2f"))[0]:
+            self.state.offset_y = state[1]
+        if (state := imgui.slider_float("Center X", self.state.center_x, -self.aspect_ratio, self.aspect_ratio, "%.2f"))[0]:
+            self.state.center_x = state[1]
+        if (state := imgui.slider_float("Center Y", self.state.center_y, -1, 1, "%.2f"))[0]:
+            self.state.center_y = state[1]
```

## DepthFlow/__init__.py

```diff
@@ -1,14 +1,15 @@
-
 import Broken
 import DepthFlow.Resources as DepthFlowResources
 from Broken import BrokenProject, BrokenTorch
 
 DEPTHFLOW = BrokenProject(
     PACKAGE=__file__,
     APP_NAME="DepthFlow",
     APP_AUTHOR="BrokenSource",
     RESOURCES=DepthFlowResources,
 )
 
 Broken.set_project(DEPTHFLOW)
 BrokenTorch.manage(DEPTHFLOW.RESOURCES)
+
+from DepthFlow.DepthFlow import DepthFlowScene, DepthFlowState
```

## DepthFlow/__main__.py

```diff
@@ -1,15 +1,13 @@
 import sys
 
 from Broken import BrokenProfiler
-from DepthFlow import DEPTHFLOW
 from DepthFlow.DepthFlow import DepthFlowScene
 
 
 def main():
     with BrokenProfiler("DEPTHFLOW"):
-        DEPTHFLOW.welcome()
         depthflow = DepthFlowScene()
         depthflow.cli(sys.argv[1:])
 
 if __name__ == "__main__":
     main()
```

## DepthFlow/Resources/Shaders/DepthFlow.frag

```diff
@@ -1,49 +1,53 @@
 /*
 // (c) 2023-2024 CC BY-SA 4.0, Tremeschin
 */
 
 void main() {
     Camera iCamera = iInitCamera(gluv);
 
+    // The distance the maximum depth projection plane is from the camera.
+    float iParallaxDistance = 1 + mix(0, iParallaxHeight, iParallaxPlane);
+
     // Add parallax options
     iCamera.position.xy += iParallaxOffset;
     iCamera.isometric   += iParallaxIsometric;
     iCamera.dolly       += iParallaxDolly;
-    iCamera.zoom        += iParallaxZoom - 1;
+    iCamera.zoom        += (iParallaxZoom - 1) + (iParallaxDistance - 1);
+    iCamera.plane_point  = vec3(0, 0, iParallaxDistance);
     iCamera              = iProjectCamera(iCamera);
 
     // Doesn't intersect with the XY plane
     if (iCamera.out_of_bounds) {
         fragColor = vec4(vec3(0.2), 1);
         return;
     }
 
     // // DepthFlow math
 
     // Point where the ray intersects with the fixed image plane
     vec2 lambda = (iCamera.gluv - iCamera.position.xy);
 
-    // Same as above but overshooted by depth focal point (fixed point at depth=focus)
-    vec2 sigma  = iCamera.gluv - iCamera.position.xy * (1 + iParallaxFocus*iParallaxHeight);
+    // Same as above but overshoot by depth focal point (fixed offsets point at depth=focus)
+    vec2 sigma  = iCamera.gluv - iCamera.position.xy * (1 + iParallaxFocus*iParallaxHeight/iParallaxDistance);
 
     // The vector from Lambda to the camera's projection on the XY plane
     vec2 displacement = (iCamera.origin.xy - lambda) + iParallaxCenter;
     vec2 walk = normalize(displacement);
 
     // Angle between the Ray's origin and the XY plane
     float theta = atan(
         length(displacement),
-        abs(1 - iCamera.origin.z)
+        abs(iParallaxDistance - iCamera.origin.z)
     );
 
     // The distance Beta we care for the depth map
-    float delta = abs(tan(theta) * (1 - iCamera.origin.z - iParallaxHeight));
-    float alpha = abs(tan(theta) * (1 - iCamera.origin.z));
-    float beta  = abs(alpha - delta);
+    float delta = tan(theta) * (iParallaxDistance - iCamera.origin.z - iParallaxHeight);
+    float alpha = tan(theta) * (iParallaxDistance - iCamera.origin.z);
+    float beta  = alpha - delta;
 
     // Start the parallax on the point itself
     vec2 parallax = sigma;
 
     // The quality of the parallax effect is how tiny the steps are
     const float min_quality = 0.05;
     const float max_quality = 0.002;
@@ -54,22 +58,22 @@
     // Fixme: Calculate walk distance based on pixel and angle?
     for (float i=1; i>0; i-=quality) {
 
         // Get the uv we'll check for the heights
         vec2 sample = sigma + (i*beta*walk);
 
         // Interpolate between (0=max) and (0=min) depending on focus
-        float height       = gmtexture(depth, sample).r;
+        float height       = gtexture(depth, sample, iParallaxMirror).r;
         float depth_height = iParallaxHeight * mix(height, 1-height, iParallaxInvert);
         float walk_height  = (i*beta) / tan(theta);
 
         // Stop whenever an intersection is found
         if (depth_height >= walk_height) {
             parallax = sample;
             break;
         }
     }
 
     // Draw the parallax image
-    fragColor = gmtexture(image, parallax);
+    fragColor = gtexture(image, parallax, iParallaxMirror);
 }
```

## Pianola/Pianola.py

```diff
@@ -1,81 +1,94 @@
 from pathlib import Path
 from typing import Annotated
 
-from attr import define
+from attr import Factory, define
 from loguru import logger as log
 from ShaderFlow.Message import Message
 from ShaderFlow.Modules.Audio import ShaderAudio
 from ShaderFlow.Modules.Piano import ShaderPiano
 from ShaderFlow.Scene import ShaderScene
 from typer import Option
 
 from Broken import BrokenEnum, BrokenPath
 from Pianola import PIANOLA
 
 
-class PianolaSoundFont(BrokenEnum):
-    Salamander = "https://freepats.zenvoid.org/Piano/SalamanderGrandPiano/SalamanderGrandPiano-SF2-V3+20200602.tar.xz"
-    """# Note: Salamander Grand Piano, Licensed under CC BY 3.0, by Alexander Holm"""
-
 @define
 class PianolaConfig:
-    soundfont: PianolaSoundFont = PianolaSoundFont.Salamander.field()
+    class SoundFont(BrokenEnum):
+        Salamander = "https://freepats.zenvoid.org/Piano/SalamanderGrandPiano/SalamanderGrandPiano-SF2-V3+20200602.tar.xz"
+        """# Note: Salamander Grand Piano, Licensed under CC BY 3.0, by Alexander Holm"""
+
+    class Songs(BrokenEnum):
+        TheEntertainer = "https://bitmidi.com/uploads/28765.mid"
+
+    soundfont: SoundFont = SoundFont.Salamander.field()
+    midi:      Songs     = Songs.TheEntertainer.field()
+
+# -------------------------------------------------------------------------------------------------|
+
 
 @define
 class PianolaScene(ShaderScene):
     """Basic piano roll"""
     __name__ = "Pianola"
 
+    config: PianolaConfig = Factory(PianolaConfig)
+
     # Todo: Think better ways of presetting Scenes in general
     def input(self,
         midi:      Annotated[str,  Option("--midi",      "-m", help="Midi file to load")],
         audio:     Annotated[str,  Option("--audio",     "-a", help="Pre-rendered Audio File of the Input Midi")]=None,
         normalize: Annotated[bool, Option("--normalize", "-n", help="Normalize the velocities of the Midi")]=False,
     ):
         ...
 
     def build(self):
         ShaderScene.build(self)
-        self.soundfont_file = next(BrokenPath.get_external(PianolaSoundFont.Salamander).rglob("*.sf2"))
+        self.soundfont_file = next(BrokenPath.get_external(self.config.soundfont).rglob("*.sf2"))
 
         # Define scene inputs
-        self.midi_file  = PIANOLA.RESOURCES/"Midis"/"Hopeless Sparkle.mid"
+        self.midi_file  = BrokenPath.get_external(self.config.midi)
         self.audio_file = "/path/to/your/midis/audio.ogg"
 
         # Make modules
         self.audio = ShaderAudio(scene=self, name="Audio")
         self.piano = ShaderPiano(scene=self)
-        self.piano.load_midi(self.midi_file)
         self.piano.normalize_velocities(100, 100)
         self.piano.fluid_load(self.soundfont_file)
         self.shader.fragment = (PIANOLA.RESOURCES.SHADERS/"Pianola.frag")
+        self.load_midi(self.midi_file)
+
+    def load_midi(self, path: Path):
+        self.piano.fluid_all_notes_off()
+        self.piano.clear()
+        self.piano.load_midi(path)
+        self.time = (-1 * self.piano.roll_time)
+        self.set_duration(self.piano.duration)
 
     def handle(self, message: Message):
         ShaderScene.handle(self, message)
 
         if isinstance(message, Message.Window.FileDrop):
             file = BrokenPath(message.files[0])
 
             if (file.suffix == ".mid"):
-                self.piano.fluid_all_notes_off()
-                self.piano.clear()
-                self.piano.load_midi(file)
-                self.time = 0
+                self.load_midi(file)
 
             elif (file.suffix == ".sf2"):
                 self.piano.fluid_load(file)
 
             elif (file.suffix in (".png", ".jpg", ".jpeg")):
                 log.warning("No background image support yet")
 
     def setup(self):
 
         # Midi -> Audio if rendering or input audio doesn't exist
-        if (self.rendering and not self.benchmark) and not Path(self.audio.file).exists():
+        if (self.rendering and not self.benchmark) and not BrokenPath(self.audio.file):
             self.audio.file = self.piano.fluid_render(soundfont=self.soundfont_file, midi=self.midi_file)
 
     def update(self):
 
         # Mouse drag time scroll to match piano roll size
         self._mouse_drag_time_factor = (self.piano.roll_time/(self.piano.height - 1))/self.camera.zoom.value
```

## Pianola/__main__.py

```diff
@@ -1,15 +1,13 @@
 import sys
 
 from Broken import BrokenProfiler
-from Pianola import PIANOLA
 from Pianola.Pianola import PianolaScene
 
 
 def main():
     with BrokenProfiler("PIANOLA"):
-        PIANOLA.welcome()
         pianola = PianolaScene()
         pianola.cli(sys.argv[1:])
 
 if __name__ == "__main__":
     main()
```

## Pianola/Resources/Shaders/Pianola.frag

```diff
@@ -56,16 +56,16 @@
     vec2 uv   = iCamera.astuv;
 
     #if HORIZONTAL
         uv = vec2(uv.y, uv.x);
     #endif
 
     // Calculate indices and coordinates
-    float iPianoMin = (iPianoDynamic.x - iPianoExtra);
-    float iPianoMax = (iPianoDynamic.y + iPianoExtra);
+    float iPianoMin = (iPianoDynamic.x - iPianoExtra) - 0.1;
+    float iPianoMax = (iPianoDynamic.y + iPianoExtra) + 0.1;
     float octave    = abs(mix(iPianoMin, iPianoMax, uv.x))/12;
     float nkeys     = abs(iPianoMax - iPianoMin);
     float whiteSize = 1/( 7*(nkeys/12));
     float blackSize = 1/(12*(nkeys/12));
     Segment segment;
 
     /* Ugly calculate segments */ {
@@ -97,32 +97,32 @@
 
         // Get note propertikes
         int  channel      = int(texelFetch(iPianoChan, ivec2(keyIndex, 0), 0).r);
         vec3 channelColor = getChannelColor(channel);
         vec3 keyColor     = getKeyColor(keyIndex);
         vec2 keyGluv      = stuv2gluv(keyStuv);
         float press       = (texelFetch(iPianoKeys, ivec2(keyIndex, 0), 0).r)/128;
-        float dark        = mix(1, 0.5, press) * (black?0.3:0.8);
+        float dark        = mix(1, 0.5, press) * (black?0.3+press:0.8);
         float down        = mix(0.11, 0, press); // Key perspective
 
         // Color the key
         fragColor.rgb = (channel==-1)?keyColor:mix(keyColor, channelColor, pow(abs(press), 0.5));
         // fragColor.rgb = mix(keyColor, channelColor, pow(abs(press), 0.5));
         // fragColor.rgb = keyColor;
 
         // Press animation
-        if (keyStuv.y < down+iPianoHeight*0.05) {
+        if (keyStuv.y < down+iPianoHeight*0.1) {
             fragColor.rgb *= dark;
         }
 
         // Separation lines
-        fragColor.rgb *= 0.7 + 0.3*pow(1 - abs(keyGluv.x), 0.1);
+        fragColor.rgb *= (0.7 - press) + (press + 0.3)*pow(1 - abs(keyGluv.x), 0.1);
 
         // Fade to Black
-        fragColor.rgb *= pow(1 - 1*press*(uv.y/iPianoHeight), 0.5);
+        fragColor.rgb *= pow(1 - 1*press*(uv.y/iPianoHeight), 0.3);
 
         // Top border
         float topBorder = iPianoHeight*(1 - TOP_BORDER);
         if (uv.y > topBorder) {
             vec2 uv = vec2(uv.x, lerp(topBorder, -1, iPianoHeight, 1, uv.y));
             fragColor.rgb = vec3(232, 7, 0)/255;
             fragColor.rgb *= 1 - 0.6*pow(length(uv.y), 1);
@@ -143,19 +143,20 @@
             beat = 60.0/tempo.y;
             if (seconds < tempo.x) {
                 break;
             }
         }
 
         /* Draw the beat lines */ {
-            fragColor.rgb = fragColor.rgb*mix(1, 0.95, smoothstep(2, 0, fract(seconds/beat)));
-            fragColor.rgb *= mix(0.9, 1, 1 - pow(abs(fract(seconds/beat/4)*2 - 1), 100));
-        }
+            float full = fract(seconds/beat/4);
+            float beat = fract(seconds/beat);
 
-        // fragColor.rgb += 0.2*smoothstep(0.005, 0, abs(fract(seconds/(beat*4)) - 0.5));
+            fragColor.rgb += 0.1*pow(max(2*full-1, 1-2*full), 500);
+            fragColor.rgb += 0.3*pow(max(2*beat-1, 1-2*beat), 80)*(abs(agluv.x)>0.97?1:0);
+        }
 
         // Draw the white key then black key
         for (int layer=0; layer<2; layer++) {
 
             // Skip drawing a duplicate black on top of white
             if ((layer == 1) && isWhiteKey(rollIndex)) {continue;}
 
@@ -189,23 +190,22 @@
                     );
 
                     // Minimum and maximum distances to the borders
                     vec2 dist = vec2(1 - max(real.x, real.y), 1 - min(real.x, real.y));
                     vec3 color = thisColor;
 
                     // Round shadows "as borders"
-                    float border_size = 0.003;
+                    float border_size = 0.002;
                     float border = (smoothstep(1, 1-border_size, real.x) * smoothstep(1, 1-border_size, real.y));
-                    color *= border;
-                    color *= thisBlack?0.4:1.0;
-                    fragColor.rgb += color;
+                    color *= border * (thisBlack?0.55:1.0);
+                    fragColor.rgb = mix(fragColor.rgb, color, border);
                     color *= (dist.x<border*2)?0.5:1;
                     fragColor.rgb = mix(
                         fragColor.rgb,
-                        fragColor.rgb*mix(0.3, 1, border),
+                        fragColor.rgb*mix(0.1, 1, border),
                         mix(0, 1, border)
                     );
                 }
             }
         }
     }
 
@@ -215,15 +215,15 @@
     #if VIGNETTE
         vec2 vig = astuv * (1 - astuv.yx);
         fragColor.rgb *= pow(vig.x*vig.y * 10, 0.05);
         fragColor.a = 1;
     #endif
 
     // Progress bar
-    if (uv.y > 0.99 && uv.x < iTau) {
+    if (uv.y > 0.985 && uv.x < iTau) {
         fragColor.rgb *= 0.8 - 0.2 * smoothstep(0, 1, uv.x);
     }
 
     // Fade in/out
     float fade = 3;
     if (iRendering) {
         fragColor.rgb *= mix(0.5, 1, smoothstep(0, fade, iTime));
```

## ShaderFlow/Module.py

```diff
@@ -3,15 +3,15 @@
 import itertools
 from abc import abstractmethod
 from typing import Any, Iterable, Self, Type, Union
 
 from attr import Factory, define, field
 from loguru import logger as log
 
-from Broken import BrokenAttrs, BrokenFluentBuilder, extend
+from Broken import BrokenAttrs, BrokenFluentBuilder
 from Broken.Externals.FFmpeg import BrokenFFmpeg
 from ShaderFlow.Message import Message
 from ShaderFlow.Variable import ShaderVariable
 
 
 @define
 class ShaderModule(BrokenFluentBuilder, BrokenAttrs):
@@ -29,21 +29,14 @@
         return f"({self.uuid:>2}) {type(self).__name__[:18].ljust(18)} â”‚ â–¸"
 
     def find(self, type: Type[ShaderModule]) -> Iterable[ShaderModule]:
         for module in self.scene.modules:
             if isinstance(module, type):
                 yield module
 
-    @staticmethod
-    def make_findable(type: ShaderModule) -> None:
-        name = type.__name__.lower()
-        extend(ShaderModule, name=name, as_property=True)(
-            lambda self: next(self.find(type=type))
-        )
-
     # # Messaging
 
     def relay(self, message: Union[Message, Type[Message]]) -> Self:
         if isinstance(message, type):
             message = message()
         for module in self.scene.modules:
             module.handle(message)
```

## ShaderFlow/Scene.py

```diff
@@ -1,8 +1,9 @@
 import importlib
+import inspect
 import math
 import os
 import time
 from abc import abstractmethod
 from collections import deque
 from pathlib import Path
 from subprocess import PIPE
@@ -12,14 +13,15 @@
     Deque,
     Dict,
     Iterable,
     List,
     Optional,
     Self,
     Tuple,
+    Union,
 )
 
 import glfw
 import imgui
 import moderngl
 import PIL
 import tqdm
@@ -36,18 +38,20 @@
     BrokenPath,
     BrokenPlatform,
     BrokenResolution,
     BrokenScheduler,
     BrokenTask,
     BrokenThread,
     BrokenTyper,
-    SameTracker,
+    OnceTracker,
     clamp,
     denum,
     flatten,
+    hyphen_range,
+    limited_integer_ratio,
 )
 from Broken.Externals.FFmpeg import (
     BrokenFFmpeg,
     FFmpegAudioCodec,
     FFmpegFilterFactory,
     FFmpegFormat,
     FFmpegH264Preset,
@@ -66,15 +70,15 @@
 from ShaderFlow.Modules.Dynamics import DynamicNumber
 from ShaderFlow.Modules.Frametimer import ShaderFrametimer
 from ShaderFlow.Modules.Keyboard import ShaderKeyboard
 from ShaderFlow.Shader import ShaderObject
 from ShaderFlow.Variable import ShaderVariable
 
 
-class ShaderBackend(BrokenEnum):
+class WindowBackend(BrokenEnum):
     Headless = "headless"
     GLFW     = "glfw"
 
 @define
 class ShaderScene(ShaderModule):
     __name__ = "Scene"
 
@@ -84,202 +88,215 @@
     """Deque of all Modules on the Scene, not a set for order preservation"""
 
     # Scheduling
     scheduler: BrokenScheduler = Factory(BrokenScheduler)
     vsync: BrokenTask = None
 
     # ShaderFlow modules
-    camera: ShaderCamera = None
+    frametimer: ShaderFrametimer = None
     keyboard: ShaderKeyboard = None
+    camera: ShaderCamera = None
     ffmpeg: BrokenFFmpeg = None
 
     # # Fractional SSAA
 
-    _final: ShaderObject = None
-    """
-    Implementing Fractional Super-Sampling Anti-Aliasing (SSAA) is a bit tricky:
-    â€¢ A Window's FBO always match its real resolution (can't final render in other resolution)
-    â€¢ We need a final shader to sample from some other SSAA-ed texture to the window
-
-    For that, a internal self._final is used to sample from the user's main self.shader
-    â€¢ _final: Uses the FBO of the Window, simply samples from a `final` texture to the screen
-    â€¢ shader: Scene's main Shader, where the user's final shader is rendered to
-    """
-
     shader: ShaderObject = None
     """The main ShaderObject of the Scene, the visible content of the Window"""
 
+    _final: ShaderObject = None
+    """Internal ShaderObject used for a Fractional Super-Sampling Anti-Aliasing (SSAA). This shader
+    samples the texture from the user's final self.shader, which is rendered at SSAA resolution"""
+
     alpha: bool = False
     """Makes the final texture have an alpha channel, useful for transparent windows. Exporting
     videos might fail, perhaps output a Chroma Key compatible video - add this to the shader:
     - `fragColor.rgb = mix(vec3(0, 1, 0), fragColor.rgb, fragColor.a);`"""
 
+    quality: float = field(default=80, converter=lambda x: clamp(x, 0, 100))
+    """Rendering Quality, if implemented - either on the GPU Shader or CPU Python side"""
+
+    def __post__(self):
+        self.build()
+
+    __built_once__: OnceTracker = Factory(OnceTracker)
+
     def build(self):
+        if self.__built_once__():
+            return
 
         # Init Imgui
         imgui.create_context()
         self.imguio = imgui.get_io()
         self.imguio.font_global_scale = 1
         self.imguio.fonts.add_font_from_file_ttf(
             str(Broken.BROKEN.RESOURCES.FONTS/"DejaVuSans.ttf"),
             16*self.imguio.font_global_scale,
         )
 
         # Default modules
         self.init_window()
         log.info(f"{self.who} Adding default base Scene modules")
-        ShaderFrametimer(scene=self)
+        self.frametimer = ShaderFrametimer(scene=self)
         self.keyboard = ShaderKeyboard(scene=self)
-        self.camera   = ShaderCamera(scene=self)
+        self.camera = ShaderCamera(scene=self)
 
         # Create the SSAA Workaround engines
         log.info(f"{self.who} Creating SSAA Implementation")
-        self.shader = ShaderObject(self)
+        self.shader = ShaderObject(scene=self)
         self.shader.texture.name = "iScreen"
         self.shader.texture.track = True
-        self._final = ShaderObject(self)
+        self.shader.texture.repeat(False)
+        self._final = ShaderObject(scene=self)
         self._final.texture.components = 3 + int(self.alpha)
         self._final.texture.dtype = "f1"
         self._final.texture.final = True
         self._final.texture.track = True
         self._final.fragment = (SHADERFLOW.RESOURCES.FRAGMENT/"Final.glsl")
 
     # ---------------------------------------------------------------------------------------------|
     # Temporal
 
-    time: Seconds = 0.0
+    time: Seconds = field(default=0.0, converter=float)
     """Current time in seconds. Ideally, everything should depend on time, for flexibility"""
 
     tempo: float = Factory(lambda: DynamicNumber(value=1, frequency=3))
     """Time scale factor, used for `dt`, which integrates to `time`"""
 
-    runtime: float = field(default=10.0, converter=float)
+    runtime: Seconds = field(default=10.0, converter=float)
     """The longest module duration; overriden by the user; or default length of 10s"""
 
-    fps: Hertz = 60.0
+    fps: Hertz = field(default=60.0, converter=lambda x: max(float(x), 1.0))
     """Target frames per second rendering speed"""
 
-    dt: Seconds = 0.0
+    dt: Seconds = field(default=0.0, converter=float)
     """Virtual delta time since last frame, time scaled by `tempo`"""
 
-    rdt: Seconds = 0.0
+    rdt: Seconds = field(default=0.0, converter=float)
     """Real life, physical delta time since last frame"""
 
     @property
     def tau(self) -> float:
-        """Normalized time value between 0 and 1"""
-        return self.time / self.runtime
+        """Normalized time value relative to runtime between 0 and 1"""
+        return (self.time / self.runtime)
 
     @property
     def frametime(self) -> Seconds:
-        """Ideal time between two frames, coupled with `fps`"""
-        return 1/self.fps
+        """Ideal time between two frames. This value is coupled with `fps`"""
+        return (1 / self.fps)
 
     @frametime.setter
-    def frametime(self, value: Seconds) -> None:
-        self.fps = 1/value
+    def frametime(self, value: Seconds):
+        self.fps = (1 / value)
 
     @property
     def frame(self) -> int:
-        """Current frame being rendered. Coupled with 'time' and 'fps'"""
-        return int(self.time * self.fps)
+        """Current frame being rendered. This value is coupled with 'time' and 'fps'"""
+        return round(self.time * self.fps)
 
     @frame.setter
-    def frame(self, value: int) -> None:
-        self.time = value / self.fps
+    def frame(self, value: int):
+        self.time = (value / self.fps)
 
     # Total Duration
 
     @property
-    def duration(self) -> float:
+    def duration(self) -> Seconds:
+        """Alias to self.runtime. Set both with `.set_duration()`"""
         return self.runtime
 
-    def set_duration(self, override: float=None, *, default: float=10) -> float:
-        self.runtime = (override or default)
+    def set_duration(self, override: Seconds=None, *, minimum: Seconds=10) -> Seconds:
+        """Either force the runtime to be 'override' or find the longest module lower bounded"""
+        self.runtime = (override or minimum)
         for module in (not bool(override)) * self.modules:
             self.runtime = max(self.runtime, module.duration)
         return self.runtime
 
     @property
     def total_frames(self) -> int:
-        return int(self.runtime * self.fps)
+        """The total frames this scene should render when exporting, if 'runtime' isn't changed"""
+        return round(self.runtime * self.fps)
 
     # ---------------------------------------------------------------------------------------------|
     # Window synchronized properties
 
     # # Title
 
     _title: str = "ShaderFlow"
 
     @property
     def title(self) -> str:
+        """Realtime window 'title' property"""
         return self._title
 
     @title.setter
-    def title(self, value: str) -> None:
-        log.info(f"{self.who} Changing Window Title to ({value})")
+    def title(self, value: str):
+        log.debug(f"{self.who} Changing Window Title to ({value})")
         self.window.title = value
         self._title = value
 
     # # Resizable
 
     _resizable: bool = True
 
     @property
     def resizable(self) -> bool:
+        """Realtime window 'is resizable' property"""
         return self._resizable
 
     @resizable.setter
-    def resizable(self, value: bool) -> None:
-        log.info(f"{self.who} Changing Window Resizable to ({value})")
+    def resizable(self, value: bool):
+        log.debug(f"{self.who} Changing Window Resizable to ({value})")
         self.window.resizable = value
         self._resizable = value
 
     # # Visible
 
     _visible: bool = False
 
     @property
     def visible(self) -> bool:
+        """Realtime window 'is visible' property"""
         return self._visible
 
     @visible.setter
-    def visible(self, value: bool) -> None:
-        log.info(f"{self.who} Changing Window Visibility to ({value})")
+    def visible(self, value: bool):
+        log.debug(f"{self.who} Changing Window Visibility to ({value})")
         self.window.visible = value
         self._visible = value
 
     # # Window Fullscreen
 
     _fullscreen: bool = False
 
     @property
     def fullscreen(self) -> bool:
+        """Realtime window 'is fullscreen' property"""
         return self._fullscreen
 
     @fullscreen.setter
-    def fullscreen(self, value: bool) -> None:
-        log.info(f"{self.who} Changing Window Fullscreen to ({value})")
+    def fullscreen(self, value: bool):
+        log.debug(f"{self.who} Changing Window Fullscreen to ({value})")
         self._fullscreen = value
         try:
             self.window.fullscreen = value
         except AttributeError:
             pass
 
     # # Window Exclusive
 
     _exclusive: bool = False
 
     @property
     def exclusive(self) -> bool:
+        """Window 'mouse exclusivity' property"""
         return self._exclusive
 
     @exclusive.setter
-    def exclusive(self, value: bool) -> None:
-        log.info(f"{self.who} Changing Window Exclusive to ({value})")
+    def exclusive(self, value: bool):
+        log.debug(f"{self.who} Changing Window Exclusive to ({value})")
         self.window.mouse_exclusivity = value
         self._exclusive = value
 
     # # Video modes and monitor
 
     monitor: int = os.environ.get("MONITOR", 0)
 
@@ -316,140 +333,193 @@
     def monitor_height(self) -> Optional[int]:
         if (resolution := self.monitor_size):
             return resolution[1]
 
     # ---------------------------------------------------------------------------------------------|
     # Resolution
 
-    quality: float = field(default=80,   converter=lambda x: clamp(x, 0, 100))
-    _ssaa:   float = field(default=1.0,  converter=lambda x: max(0.01, x))
-    _width:  int   = field(default=1920, converter=lambda x: int(max(1, x)))
-    _height: int   = field(default=1080, converter=lambda x: int(max(1, x)))
+    # # Scale
 
-    def resize(self, width: int=Unchanged, height: int=Unchanged, *, scale: float=1) -> Tuple[int, int]:
-        """
-        Resize the true final rendering resolution of the Scene
-        - Rounded to nearest multiple of 2, so FFmpeg is happy
-        - Limited by the Monitor resolution if Realtime
-        - Safe to use floats as input arguments
-        - Use None to not change this resolution component
-        - Doesn't signal a resize if same resolution as before
+    _scale: float = field(default=1.0, converter=lambda x: max(0.01, x))
 
-        Args:
-            width:  New width of the Scene, None to not change
-            height: New height of the Scene, None to not change
+    @property
+    def scale(self) -> float:
+        """Resolution scale factor, the `self.width` and `self.height` are multiplied by this"""
+        return self._scale
 
-        Returns:
-            Self: Fluent interface
-        """
-        resolution = BrokenResolution.fit(
-            ow=self.width, oh=self.height, nw=width, nh=height,
-            mw=self.monitor_width, mh=self.monitor_height,
-            sc=scale, ar=self._aspect_ratio,
-        )
+    @scale.setter
+    def scale(self, value: float):
+        log.debug(f"{self.who} Changing Resolution Scale to ({value})")
+        self.resize(scale=value)
 
-        # Optimization: Only resize when resolution changes
-        if resolution != (self._width, self._height):
-            log.info(f"{self.who} Resizing window to resolution {resolution}")
-            self.window.fbo.viewport = (0, 0, self.width, self.height)
-            self._width, self._height = resolution
-            self.window.size = resolution
-            self.relay(Message.Shader.RecreateTextures)
-        return self.resolution
-
-    def read_screen(self) -> bytes:
-        return self.window.fbo.read(viewport=(0, 0, self.width, self.height))
+    # # Width
 
-    # # Resolution related
+    _width: int = field(default=1920, converter=lambda x: int(max(1, x)))
 
     @property
     def width(self) -> int:
-        return self._width
+        """Rendering width (horizontal size) of the Scene in pixels"""
+        return BrokenResolution.round_component(self._width * self._scale)
 
     @width.setter
-    def width(self, value: int) -> None:
+    def width(self, value: int):
         self.resize(width=value)
 
+    # # Height
+
+    _height: int = field(default=1080, converter=lambda x: int(max(1, x)))
+
     @property
     def height(self) -> int:
-        return self._height
+        """Rendering height (vertical size) of the Scene in pixels"""
+        return BrokenResolution.round_component(self._height * self._scale)
 
     @height.setter
-    def height(self, value: int) -> None:
+    def height(self, value: int):
         self.resize(height=value)
 
-    @property
-    def resolution(self) -> Tuple[int, int]:
-        return self.width, self.height
+    # # SSAA
 
-    @resolution.setter
-    def resolution(self, value: Tuple[int, int]) -> None:
-        self.resize(*value)
+    _ssaa: float = field(default=1.0,  converter=lambda x: max(0.01, x))
 
     @property
     def ssaa(self) -> float:
+        """Fractional Super Sampling Anti-Aliasing (SSAA) factor. Improves the image quality (>1) by
+        rendering at a higher resolution and then downsampling, resulting in smoother edges at a
+        significant GPU computational cost of O(N^2). Values lower than 1 (yield worse quality, but)
+        are useful when the GPU can't keep up: when the resolution is too high or FPS is too low"""
         return self._ssaa
 
     @ssaa.setter
-    def ssaa(self, value: float) -> None:
-        log.info(f"{self.who} Changing Fractional SSAA to {value}")
+    def ssaa(self, value: float):
+        log.debug(f"{self.who} Changing Fractional SSAA to {value}")
         self._ssaa = value
         self.relay(Message.Shader.RecreateTextures)
 
+    # # Resolution (With, Height)
+
+    @property
+    def resolution(self) -> Tuple[int, int]:
+        """The resolution the Scene is rendering in pixels"""
+        return BrokenResolution.round_resolution(self.width, self.height)
+
+    @resolution.setter
+    def resolution(self, value: Tuple[int, int]):
+        self.resize(*value)
+
     @property
     def render_resolution(self) -> Tuple[int, int]:
-        return BrokenResolution.round(self.width*self.ssaa, self.height*self.ssaa)
+        """Internal 'true' rendering resolution for SSAA. Same as `self.resolution*self.ssaa`"""
+        return BrokenResolution.round_resolution(self.width*self.ssaa, self.height*self.ssaa)
+
+    # # Aspect Ratio
 
     _aspect_ratio: float = None
 
     @property
     def aspect_ratio(self) -> float:
-        """Either the forced `self._aspect_ratio` or dynamic from `self.width/self.height`"""
+        """Either the forced `self._aspect_ratio` or dynamic from `self.width/self.height`. When set
+        and resizing, the logic of `BrokenResolution.fit` is applied to enforce ratios"""
         return self._aspect_ratio or (self.width/self.height)
 
     @aspect_ratio.setter
-    def aspect_ratio(self, value: float) -> None:
-        log.info(f"{self.who} Changing Aspect Ratio to {value}")
+    def aspect_ratio(self, value: Union[float, str]):
+        log.debug(f"{self.who} Changing Aspect Ratio to {value}")
+
+        # The aspect ratio can be sent as a fraction or "none", "false"
+        if isinstance(value, str):
+            value = eval(value.replace(":", "/").capitalize())
+
+        # Optimization: Only change if different
+        if (self._aspect_ratio == value):
+            return
+
         self._aspect_ratio = value
 
-        if (self.backend == ShaderBackend.GLFW):
-            w, h = (int(10000*value), 10000) if bool(value) else (glfw.DONT_CARE, glfw.DONT_CARE)
-            glfw.set_window_aspect_ratio(self.window._window, w, h)
+        if (self.backend == WindowBackend.GLFW):
+            num, den = limited_integer_ratio(self._aspect_ratio, limit=2**20) or (glfw.DONT_CARE, glfw.DONT_CARE)
+            glfw.set_window_aspect_ratio(self.window._window, num, den)
+
+    def resize(self,
+        width: Union[int, float]=Unchanged,
+        height: Union[int, float]=Unchanged,
+        *,
+        aspect_ratio: Union[Unchanged, float, str]=None,
+        scale: float=Unchanged
+    ) -> Tuple[int, int]:
+        """
+        Resize the true final rendering resolution of the Scene. Rounded to nearest multiple of 2,
+        so FFmpeg is happy, and limited by the monitor resolution if realtime
+
+        Args:
+            width:  New width of the Scene, None to not change
+            height: New height of the Scene, None to not change
+
+        Returns:
+            Self: Fluent interface
+        """
+
+        # Maybe update auxiliary properties
+        self.aspect_ratio = (aspect_ratio or self._aspect_ratio)
+        self._scale = (scale or self._scale)
+
+        # The parameters aren't trivial. The idea is to fit resolution from the scale-less components,
+        # so scaling isn't carried over, then to apply scaling (self.resolution)
+        resolution = BrokenResolution.fit(
+            old=(self._width, self._height),
+            new=(width, height),
+            max=(self.monitor_size),
+            ar=self._aspect_ratio
+        )
 
-    # # Backend
+        # Optimization: Only resize when resolution changes
+        if (resolution != (self.width, self.height)):
+            self._width, self._height = resolution
+            self.window.size = self.resolution
+            self.relay(Message.Shader.RecreateTextures)
+            log.info(f"{self.who} Resized Window to {self.resolution}")
 
-    backend: ShaderBackend = ShaderBackend.get(os.environ.get("SHADERFLOW_BACKEND", ShaderBackend.GLFW))
-    """The ModernGL Window Backend. Cannot be changed after creation."""
+        return self.resolution
+
+    # ---------------------------------------------------------------------------------------------|
+    # Window, OpenGL, Backend
+
+    backend: WindowBackend = WindowBackend.get(os.environ.get("WINDOW_BACKEND", WindowBackend.GLFW))
+    """The ModernGL Window Backend. **Cannot be changed after creation**. Can also be set with the
+    environment variable `WINDOW_BACKEND=<backend>`, where `backend = {glfw, headless}`"""
 
     opengl: moderngl.Context = None
-    """ModernGL Context of this Scene"""
+    """ModernGL Context of this Scene. The thread accessing this MUST own or ENTER its context for
+    creating, changing, deleting objects; more often than not, it's the Main thread"""
 
     window: ModernglWindow = None
-    """ModernGL Window object with context/backend defined on self._backend"""
+    """ModernGL Window instance at `site-packages/moderngl_window.context.<self.backend>.Window`"""
 
     imgui: ModernglImgui = None
     """ModernGL Imgui integration class bound to the Window"""
 
     imguio: Any = None
     """Imgui IO object"""
 
     # Todo: Proper UI classes? For main menu, settings, exporting, etc
     render_ui: bool = False
     """Whether to render the Main UI"""
 
     def init_window(self) -> None:
         """Create the window and the OpenGL context"""
-        log.info(f"{self.who} Creating Window and OpenGL Context")
-        log.info(f"{self.who} â€¢ Backend:    {denum(self.backend)}")
-        log.info(f"{self.who} â€¢ Resolution: {self.resolution}")
+        if self.window:
+            raise RuntimeError("Window backend cannot be changed after creation")
 
-        # Provide GPU Acceleration on headless rendering, as xvfb-run is software rendering
+        log.info(f"{self.who} Creating {denum(self.backend)} Window")
+
+        # Provide GPU Acceleration on Linux Headless rendering, as xvfb-run is software rendering
         # https://forums.developer.nvidia.com/t/81412 - Comments 2 and 6
-        backend = "egl" * (self.backend == ShaderBackend.Headless) * (BrokenPlatform.OnLinux) or None
+        backend = "egl" * (self.backend == WindowBackend.Headless) * (BrokenPlatform.OnLinux) or None
 
+        # Dynamically import the ModernGL Window Backend and instantiate it. Vsync is on our side ðŸ˜‰
         module = f"moderngl_window.context.{denum(self.backend).lower()}"
         self.window = importlib.import_module(module).Window(
             size=self.resolution,
             title=self.title,
             resizable=self.resizable,
             visible=self.visible,
             fullscreen=self.fullscreen,
@@ -469,51 +539,55 @@
         self.window.mouse_press_event_func    = self.__window_mouse_press_event__
         self.window.mouse_release_event_func  = self.__window_mouse_release_event__
         self.window.mouse_drag_event_func     = self.__window_mouse_drag_event__
         self.window.mouse_scroll_event_func   = self.__window_mouse_scroll_event__
         self.window.unicode_char_entered_func = self.__window_unicode_char_entered__
         self.window.files_dropped_event_func  = self.__window_files_dropped_event__
 
-        if (self.backend == ShaderBackend.GLFW):
+        if (self.backend == WindowBackend.GLFW):
             BrokenThread.new(target=self.window.set_icon, icon_path=Broken.PROJECT.RESOURCES.ICON, daemon=True)
             glfw.set_cursor_enter_callback(self.window._window, lambda _, enter: self.__window_mouse_enter_event__(inside=enter))
             glfw.set_drop_callback(self.window._window, self.__window_files_dropped_event__)
             ShaderKeyboard.Keys.LEFT_SHIFT = glfw.KEY_LEFT_SHIFT
             ShaderKeyboard.Keys.LEFT_CTRL  = glfw.KEY_LEFT_CONTROL
             ShaderKeyboard.Keys.LEFT_ALT   = glfw.KEY_LEFT_ALT
             # glfw.maximize_window(self.window._window)
 
         log.debug(f"{self.who} Finished Window creation")
 
+    def read_screen(self) -> bytes:
+        """Take a screenshot of the screen and return raw bytes. Length `width*height*components`"""
+        return self.window.fbo.read(viewport=(0, 0, self.width, self.height))
+
     # ---------------------------------------------------------------------------------------------|
     # User actions
 
     @abstractmethod
     def commands(self) -> None:
         """Configure commands for the Scene. Add with self.broken_typer.command(...)"""
         ...
 
-    _built: SameTracker = Factory(SameTracker)
-
     def cli(self, *args: List[str]):
         args = flatten(args)
         self.broken_typer = BrokenTyper(chain=True)
         self.broken_typer.command(self.main, context=True, default=True)
         self.commands()
-        if ("--help" not in args) and (not self._built(True)):
-            self.build()
         self.broken_typer(args)
 
     @property
     def directory(self) -> Path:
-        """Directory of the current Scene script"""
-        # Fixme: How to deal with ShaderFlow as a dependency scenario?
-        return BrokenPath(SHADERFLOW.DIRECTORIES.CURRENT_SCENE)
+        """Path of the current Scene file Python script. This works by searching up the call stack
+        for the first context whose filename isn't the local __file__ (of ShaderFlow.Scene)
+        # Idea: Maybe `type(self).mro()[0]` could help
+        """
+        for frame in inspect.stack():
+            if (frame.filename != __file__):
+                return Path(frame.filename).parent
 
-    def read_file(self, file: Path, bytes: bool=False) -> str | bytes:
+    def read_file(self, file: Path, bytes: bool=False) -> Union[str, bytes]:
         """
         Read a file relative to the current Scene Python script
 
         Args:
             `file`:  File to read, relative to the current Scene script directory
             `bytes`: Whether to read the file as bytes, defaults to text
 
@@ -531,14 +605,15 @@
     """Should the the main event loop end on Realtime mode?"""
 
     def quit(self) -> None:
         if self.realtime:
             self._quit = True
 
     def next(self, dt: float) -> Self:
+        """Integrate time, update all modules and render the next frame"""
 
         # Fixme: Windows: https://github.com/glfw/glfw/pull/1426
         # Immediately swap the buffer with previous frame for vsync
         if self.realtime:
             self.window.swap_buffers()
 
         # Temporal logic
@@ -563,197 +638,237 @@
 
     exporting: bool = True
     """Is this Scene exporting to a video file?"""
 
     rendering: bool = False
     """Either Exporting, Rendering or Benchmarking. 'Not Realtime' mode"""
 
-    realtime:  bool = False
+    realtime: bool = False
     """Running with a window and user interaction"""
 
-    headless:  bool = False
+    headless: bool = False
     """Running Headlessly, without a window and user interaction"""
 
     benchmark: bool = False
     """Stress test the rendering speed of the Scene"""
 
+    # Batch exporting
+
+    export_batch: Iterable[int] = field(factory=lambda: [0], converter=lambda x: list(x) or [0])
+    """Batch indices iterable to export"""
+
+    export_index: int = 0
+    """Current Batch exporting video index"""
+
+    export_format: str = field(default="mp4", converter=lambda x: str(denum(x)))
+    """The last (or only) video export format (extension) to use"""
+
+    export_base: BrokenPath = field(default=Broken.PROJECT.DIRECTORIES.DATA, converter=lambda x: Path(x))
+    """The last (or only) video export base directory. Videos should render to ($base/$name) if $name
+    is plain, that is, the path isn't absolute"""
+
+    @abstractmethod
+    def export_name(self, path: Path) -> Path:
+        """Change the video file name being exported based on the current batch index. By default,
+        the name is unchanged in single export, else the stem is appended with the batch index"""
+        if (len(self.export_batch) > 1):
+            return path.with_stem(f"{path.stem}_{self.export_index}")
+        return path
+
     def main(self,
         width:      Annotated[int,   Option("--width",      "-w", help="(ðŸ”´ Basic    ) Width  of the Rendering Resolution. None to keep or find by Aspect Ratio (1920 on init)")]=None,
         height:     Annotated[int,   Option("--height",     "-h", help="(ðŸ”´ Basic    ) Height of the Rendering Resolution. None to keep or find by Aspect Ratio (1080 on init)")]=None,
         scale:      Annotated[float, Option("--scale",      "-x", help="(ðŸ”´ Basic    ) Post-multiply Width and Height by a Scale Factor")]=1.0,
         aspect:     Annotated[str,   Option("--ar",         "-a", help="(ðŸ”´ Basic    ) Force resolution aspect ratio, None for dynamic. Examples: '16:9', '16/9', '1.777'")]=None,
         fps:        Annotated[float, Option("--fps",        "-f", help="(ðŸ”´ Basic    ) Target Frames per Second. On Realtime, defaults to the monitor framerate else 60")]=None,
         fullscreen: Annotated[bool,  Option("--fullscreen",       help="(ðŸ”´ Basic    ) Start the Real Time Window in Fullscreen Mode")]=False,
         quality:    Annotated[float, Option("--quality",    "-q", help="(ðŸŸ¡ Quality  ) Shader Quality level, if supported (0-100%)")]=80,
         ssaa:       Annotated[float, Option("--ssaa",       "-s", help="(ðŸŸ¡ Quality  ) Fractional Super Sampling Anti Aliasing factor, O(N^2) GPU cost")]=1.0,
         render:     Annotated[bool,  Option("--render",     "-r", help="(ðŸŸ¢ Exporting) Export the Scene to a Video File (defined on --output, and implicit if so)")]=False,
         output:     Annotated[str,   Option("--output",     "-o", help="(ðŸŸ¢ Exporting) Output File Name: Absolute, Relative Path or Plain Name. Saved on ($base/$(plain_name or $scene-$date))")]=None,
         end:        Annotated[float, Option("--end",        "-t", help="(ðŸŸ¢ Exporting) How many seconds to render, defaults to 10 or longest advertised module")]=None,
         format:     Annotated[str,   Option("--format",           help="(ðŸŸ¢ Exporting) Output Video Container (mp4, mkv, webm, avi..), overrides --output one")]="mp4",
         base:       Annotated[Path,  Option("--base",             help="(ðŸŸ¢ Exporting) Output File Base Directory")]=Broken.PROJECT.DIRECTORIES.DATA,
-        benchmark:  Annotated[bool,  Option("--benchmark",  "-b", help="(ðŸ”µ Special  ) Benchmark the Scene's speed on raw rendering. Use SKIP_GPU=1 for CPU only benchmark")]=False,
-        raw:        Annotated[bool,  Option("--raw",              help="(ðŸ”µ Special  ) Send raw OpenGL Frames before GPU SSAA to FFmpeg (Enabled if SSAA < 1)")]=False,
+        batch:      Annotated[str,   Option("--batch",      "-b", help="(ðŸ”µ Special  ) [WIP] Hyphenated indices range to export multiple videos, if implemented. (1,5-7,10)")]="0",
+        benchmark:  Annotated[bool,  Option("--benchmark",        help="(ðŸ”µ Special  ) Benchmark the Scene's speed on raw rendering. Use SKIP_GPU=1 for CPU only benchmark")]=False,
+        raw:        Annotated[bool,  Option("--raw",              help="(ðŸ”µ Special  ) Send raw OpenGL Frames before GPU SSAA to FFmpeg (CPU Downsampling) (Enabled if SSAA < 1)")]=False,
         open:       Annotated[bool,  Option("--open",             help="(ðŸ”µ Special  ) Open the Video's Output Directory after render finishes")]=False,
-    ) -> Optional[Path]:
+    ) -> Optional[Union[Path, List[Path]]]:
         """Main Event Loop of the Scene. Options to start a realtime window, exports to a file, or stress test speeds"""
+        outputs: List[Path] = []
 
-        self.relay(Message.Shader.Compile)
-        self.exporting  = (render or bool(output))
-        self.rendering  = (self.exporting or benchmark)
-        self.realtime   = (not self.rendering)
-        self.benchmark  = benchmark
-        self.headless   = (self.rendering)
-        self.fps        = (fps or self.monitor_framerate)
-        self.title      = f"ShaderFlow | {self.__name__}"
-        self.fullscreen = fullscreen
-        self.quality    = quality
-        self.ssaa       = ssaa
-        self.time       = 0
-
-        # Maybe keep or force aspect ratio, and find best resolution
-        self.aspect_ratio = eval((aspect or "0").replace(":", "/")) or self._aspect_ratio
-        video_resolution = self.resize(width=width, height=height, scale=scale)
-
-        # Optimization: Save bandwidth by piping native frames on ssaa < 1
-        if self.rendering and (raw or ssaa < 1):
-            self.resolution = self.render_resolution
-            self.ssaa = 1
+        from arrow import now as arrow_now
+        export_started = arrow_now().format("YYYY-MM-DD HH-mm-ss")
 
-        for module in self.modules:
-            module.setup()
+        # Maybe update indices of exporting videos
+        self.export_batch  = hyphen_range(batch) or self.export_batch
+        self.export_format = format
+        self.export_base   = base
+
+        for index in self.export_batch:
+            self.export_index = index
+            self.exporting  = (render or bool(output))
+            self.rendering  = (self.exporting or benchmark)
+            self.realtime   = (not self.rendering)
+            self.benchmark  = benchmark
+            self.headless   = (self.rendering)
+            self.fps        = (fps or self.monitor_framerate)
+            self.title      = f"ShaderFlow | {self.__name__}"
+            self.fullscreen = fullscreen
+            self.quality    = quality
+            self.ssaa       = ssaa
+            self.time       = 0
+
+            # Maybe keep or force aspect ratio, and find best resolution
+            video_resolution = self.resize(width=width, height=height, scale=scale, aspect_ratio=aspect)
+
+            # Optimization: Save bandwidth by piping native frames on ssaa < 1
+            if self.rendering and (raw or ssaa < 1):
+                self.resolution = self.render_resolution
+                self.ssaa = 1
 
-        self.set_duration(end)
+            for module in self.modules:
+                module.setup()
 
-        # Configure FFmpeg and Popen it
-        if (self.rendering):
-            import arrow
-
-            # Get video output path - if not absolute, save to data directory
-            output = Path(output or f"({arrow.utcnow().format('YYYY-MM-DD_HH-mm-ss')}) {self.__name__}")
-            output = output if output.is_absolute() else base/output
-            output = output.with_suffix(output.suffix or f".{format}")
-
-            self.ffmpeg = (
-                BrokenFFmpeg()
-                .quiet()
-                .format(FFmpegFormat.Rawvideo)
-                .pixel_format(FFmpegPixelFormat.RGBA if self.alpha else FFmpegPixelFormat.RGB24)
-                .resolution(self.resolution)
-                .framerate(self.fps)
-                .filter(FFmpegFilterFactory.scale(video_resolution))
-                .filter(FFmpegFilterFactory.flip_vertical())
-                .overwrite()
-                .input("-")
-            )
+            self.relay(Message.Shader.Compile)
+            self.set_duration(end)
 
-            # Fixme: Is this the correct point for modules to manage FFmpeg?
-            for module in self.modules:
-                module.ffmpeg(self.ffmpeg)
+            # Configure FFmpeg and Popen it
+            if (self.rendering):
 
-            # Add empty audio track if no input audio
-            # self.ffmpeg = (
-            #     self.ffmpeg
-            #     .custom("-f lavfi -i anullsrc=channel_layout=stereo:sample_rate=44100".split())
-            #     .shortest()
-            # )
-
-            # Todo: Apply preset based config
-            self.ffmpeg = (
-                self.ffmpeg
-                .video_codec(FFmpegVideoCodec.H264)
-                .audio_codec(FFmpegAudioCodec.AAC)
-                .audio_bitrate("300k")
-                .preset(FFmpegH264Preset.Slow)
-                .tune(FFmpegH264Tune.Film)
-                .quality(FFmpegH264Quality.High)
-                .pixel_format(FFmpegPixelFormat.YUV420P)
-                .custom("-t", self.runtime)
-                .custom("-movflags", "+faststart")
-            )
+                # Get video output path - if not absolute, save to data directory
+                export_name = Path(output or f"({export_started}) {self.__name__}")
+                export_name = export_name if export_name.is_absolute() else (self.export_base/export_name)
+                export_name = export_name.with_suffix(export_name.suffix or f".{self.export_format}")
+                export_name = self.export_name(export_name)
+
+                self.ffmpeg = (
+                    BrokenFFmpeg()
+                    .quiet()
+                    .format(FFmpegFormat.Rawvideo)
+                    .pixel_format(FFmpegPixelFormat.RGBA if self.alpha else FFmpegPixelFormat.RGB24)
+                    .resolution(self.resolution)
+                    .framerate(self.fps)
+                    .filter(FFmpegFilterFactory.scale(video_resolution))
+                    .filter(FFmpegFilterFactory.flip_vertical())
+                    .overwrite()
+                    .input("-")
+                )
 
-            self.ffmpeg.output(output)
+                # Fixme: Is this the correct point for modules to manage FFmpeg?
+                for module in self.modules:
+                    module.ffmpeg(self.ffmpeg)
+
+                # Add empty audio track if no input audio
+                # self.ffmpeg = (
+                #     self.ffmpeg
+                #     .custom("-f lavfi -i anullsrc=channel_layout=stereo:sample_rate=44100".split())
+                #     .shortest()
+                # )
+
+                # Todo: Apply preset based config
+                self.ffmpeg = (
+                    self.ffmpeg
+                    .video_codec(FFmpegVideoCodec.H264)
+                    .audio_codec(FFmpegAudioCodec.AAC)
+                    .audio_bitrate("300k")
+                    .preset(FFmpegH264Preset.Slow)
+                    .tune(FFmpegH264Tune.Film)
+                    .quality(FFmpegH264Quality.High)
+                    .pixel_format(FFmpegPixelFormat.YUV420P)
+                    .custom("-t", self.runtime)
+                    .custom("-movflags", "+faststart")
+                )
 
-            # Optimization: Don't allocate new buffers on each read for piping
-            buffer = self.opengl.buffer(reserve=self._final.texture.length)
+                self.ffmpeg.output(export_name)
 
-            # Fixme: Why Popen on Linux is slower on main thread (blocking?)
-            # Idea: Python 3.13 Sub-interpreters could help, but require >= 3.13
-            if self.exporting:
-                if BrokenPlatform.OnWindows:
-                    self.ffmpeg = self.ffmpeg.Popen(stdin=PIPE)
-                else:
-                    self.ffmpeg = self.ffmpeg.pipe()
-
-            # Status tracker
-            status = DotMap(
-                start=time.perf_counter(),
-                bar=tqdm.tqdm(
-                    total=self.total_frames,
-                    desc=f"Scene ({type(self).__name__}) â†’ Video",
-                    dynamic_ncols=True,
-                    colour="#43BFEF",
-                    leave=False,
-                    unit=" frames",
-                    mininterval=1/60,
-                    maxinterval=0.1,
-                    smoothing=0.1,
+                # Fixme: Why Popen on Linux is slower on main thread (blocking?)
+                # Idea: Python 3.13 Sub-interpreters could help, but require >= 3.13
+                if self.exporting:
+                    if BrokenPlatform.OnWindows:
+                        self.ffmpeg = self.ffmpeg.Popen(stdin=PIPE)
+                    else:
+                        self.ffmpeg = self.ffmpeg.pipe()
+
+                # Optimization: Don't allocate new buffers on each read for piping
+                buffer = self.opengl.buffer(reserve=self._final.texture.length)
+
+                # Status tracker
+                status = DotMap(
+                    start=time.perf_counter(),
+                    bar=tqdm.tqdm(
+                        total=self.total_frames,
+                        desc=f"Scene #{self.export_index} ({type(self).__name__}) â†’ Video",
+                        dynamic_ncols=True,
+                        colour="#43BFEF",
+                        leave=False,
+                        unit=" frames",
+                        mininterval=1/60,
+                        maxinterval=0.1,
+                        smoothing=0.1,
+                    )
                 )
+
+            # Add self.next to the event loop
+            self.vsync = self.scheduler.new(
+                task=self.next,
+                frequency=self.fps,
+                freewheel=self.rendering,
+                precise=True,
             )
 
-        # Add self.next to the event loop
-        self.vsync = self.scheduler.new(
-            task=self.next,
-            frequency=self.fps,
-            decoupled=self.rendering,
-            precise=True,
-        )
+            # Some scenes might take a while to setup
+            self.visible = not self.headless
 
-        # Some scenes might take a while to setup
-        self.visible = not self.headless
+            # Main rendering loop
+            while (self.rendering) or (not self._quit):
+                task = self.scheduler.next()
+
+                # Only continue if exporting
+                if (task.output is not self):
+                    continue
+                if self.realtime:
+                    continue
+
+                # Update status bar
+                status.bar.update(1)
+                status.bar.disable = False
+
+                # Write a new frame to FFmpeg
+                if self.exporting:
+                    self._final.texture.fbo().read_into(buffer)
+                    self.ffmpeg.stdin.write(buffer.read())
+
+                # Finish exporting condition
+                if (status.bar.n < self.total_frames):
+                    continue
+
+                if self.exporting:
+                    self.ffmpeg.stdin.close()
+                    outputs.append(export_name)
+
+                # Log stats
+                status.bar.refresh()
+                status.bar.close()
+                status.took = (time.perf_counter() - status.start)
+                log.info(f"Finished rendering ({export_name})", echo=not self.benchmark)
+                log.info((
+                    f"â€¢ Stats: "
+                    f"(Took {status.took:.2f} s) at "
+                    f"({self.frame/status.took:.2f} FPS | "
+                    f"{self.runtime/status.took:.2f} x Realtime) with "
+                    f"({status.bar.n} Total Frames)"
+                ))
+
+                if self.benchmark:
+                    return None
+                break
 
-        # Main rendering loop
-        while (self.rendering) or (not self._quit):
-            task = self.scheduler.next()
-
-            # Only continue if exporting
-            if (task.output is not self):
-                continue
-            if self.realtime:
-                continue
-
-            status.bar.update(1)
-
-            if self.exporting:
-                self._final.texture.fbo().read_into(buffer)
-                self.ffmpeg.stdin.write(buffer.read())
-
-            if status.bar.n < self.total_frames:
-                continue
-
-            if self.exporting:
-                self.ffmpeg.stdin.close()
-
-            # Log stats
-            status.bar.refresh()
-            status.bar.close()
-            status.took = (time.perf_counter() - status.start)
-            log.info(f"Finished rendering ({output})", echo=not self.benchmark)
-            log.info((
-                f"â€¢ Stats: "
-                f"(Took {status.took:.2f} s) at "
-                f"({self.frame/status.took:.2f} FPS | "
-                f"{self.runtime/status.took:.2f} x Realtime) with "
-                f"({status.bar.n} Total Frames)"
-            ))
-
-            if self.benchmark:
-                return None
-            if open:
-                BrokenPath.open_in_file_explorer(output.parent)
-            return output
+        BrokenPath.open_in_file_explorer(outputs[0].parent) if open else None
+        return (outputs[0] if len(outputs) == 1 else outputs) or None
 
     # ---------------------------------------------------------------------------------------------|
     # Module
 
     def handle(self, message: Message) -> None:
 
         if isinstance(message, Message.Window.Close):
@@ -761,28 +876,29 @@
             self.quit()
 
         elif isinstance(message, Message.Keyboard.KeyDown):
             if message.key == ShaderKeyboard.Keys.O:
                 log.info(f"{self.who} (O  ) Resetting the Scene")
                 for module in self.modules:
                     module.setup()
+                self.time = 0
 
             elif message.key == ShaderKeyboard.Keys.R:
                 log.info(f"{self.who} (R  ) Reloading Shaders")
                 for module in self.modules:
                     if isinstance(module, ShaderObject):
                         module.compile()
 
             elif message.key == ShaderKeyboard.Keys.TAB:
                 log.info(f"{self.who} (TAB) Toggling Menu")
-                self.render_ui  = not self.render_ui
+                self.render_ui = not self.render_ui
 
             elif message.key == ShaderKeyboard.Keys.F1:
                 log.info(f"{self.who} (F1 ) Toggling Exclusive Mode")
-                self.exclusive  = not self.exclusive
+                self.exclusive = not self.exclusive
 
             elif message.key == ShaderKeyboard.Keys.F2:
                 import arrow
                 time  = arrow.now().format("YYYY-MM-DD_HH-mm-ss")
                 image = PIL.Image.frombytes("RGB", self.resolution, self.read_screen())
                 image = image.transpose(PIL.Image.FLIP_TOP_BOTTOM)
                 path  = Broken.PROJECT.DIRECTORIES.SCREENSHOTS/f"({time}) {self.__name__}.png"
@@ -985,15 +1101,15 @@
         imgui.pop_style_var(6)
         imgui.render()
         self.imgui.render(imgui.get_draw_data())
 
     def __ui__(self) -> None:
 
         # Render status
-        imgui.text(f"Resolution: {self.render_resolution} -> {self.resolution} @ {self.ssaa}x SSAA")
+        imgui.text(f"Resolution: {self.render_resolution} -> {self.resolution} @ {self.ssaa:.2f}x SSAA")
 
         # Framerate
         imgui.spacing()
         if (state := imgui.slider_float("Framerate", self.fps, 10, 240, "%.0f"))[0]:
             self.fps = round(state[1])
         for fps in (options := [24, 30, 60, 120, 144, 240]):
             if (state := imgui.button(f"{fps} Hz")):
@@ -1020,8 +1136,8 @@
                 self.ssaa = ssaa
             if ssaa != options[-1]:
                 imgui.same_line()
 
         # Quality
         imgui.spacing()
         if (state := imgui.slider_float("Quality", self.quality, 0, 100, "%.0f%%"))[0]:
-            self.quality = state[1]
+            self.quality = state[1]
```

## ShaderFlow/Shader.py

```diff
@@ -91,15 +91,15 @@
                 Syntax(code='\n'.join(code), lexer="glsl"),
                 title=f"({errno} at Module #{self.shader.uuid}, Line {lineno}): {message}",
             ))
 
 @define
 class ShaderObject(ShaderModule):
     version: int = 330
-    """OpenGL Version to use for the shader. Must be <= than the Window Backend version."""
+    """OpenGL Version to use for the shader. Must be <= than the Window Backend version"""
 
     program: moderngl.Program = None
     """ModernGL 'Compiled Shaders' object"""
 
     vao: moderngl.VertexArray = None
     """Buffer object for the vertices of the shader"""
 
@@ -243,15 +243,15 @@
         return self._build_shader(LoaderString(content), self.vertex_variables)
 
     @property
     def vertex(self) -> str:
         return self.make_vertex(self._vertex)
 
     @vertex.setter
-    def vertex(self, value: Union[Path, str]) -> None:
+    def vertex(self, value: Union[Path, str]):
         self._watchshader(value)
         self._vertex = value
 
     # # Fragment shader content
 
     _fragment: Union[Path, str] = ""
     """The 'User Content' of the Fragment Shader, interted after the Metaprogramming.
@@ -261,15 +261,15 @@
         return self._build_shader(LoaderString(content), self.fragment_variables)
 
     @property
     def fragment(self) -> str:
         return self.make_fragment(self._fragment)
 
     @fragment.setter
-    def fragment(self, value: Union[Path, str]) -> None:
+    def fragment(self, value: Union[Path, str]):
         self._watchshader(value)
         self._fragment = value
 
     # # Uniforms
 
     def set_uniform(self, name: str, value: Any=None) -> None:
         # Note: Denum safety, called hundreds of times: No noticeable performance impact (?)
```

## ShaderFlow/Texture.py

```diff
@@ -55,15 +55,15 @@
     x2  = 2
     x4  = 4
     x8  = 8
     x16 = 16
 
 @define
 class TextureBox:
-    """Holds a Framebuffer and bound Texture on the Matrix"""
+    """Holds a Framebuffer and bound Texture on the TextureMatrix"""
     texture: moderngl.Texture = None
     fbo:     moderngl.Framebuffer = None
     clear:   bool  = False
     data:    bytes = None
     empty:   bool  = True
 
     def release(self) -> Self:
@@ -245,25 +245,25 @@
     def resolution(self) -> Tuple[int, int]:
         if not self.track:
             return (self.width, self.height)
         if self.final:
             return self.scene.resolution
         return self.scene.render_resolution
 
-    @property
-    def size(self) -> Tuple[int, int]:
-        return self.resolution
-
     @resolution.setter
-    def resolution(self, value: Tuple[int, int]) -> None:
+    def resolution(self, value: Tuple[int, int]):
         if not self.track:
             self.width, self.height = value
 
+    @property
+    def size(self) -> Tuple[int, int]:
+        return self.resolution
+
     @size.setter
-    def size(self, value: Tuple[int, int]) -> None:
+    def size(self, value: Tuple[int, int]):
         self.resolution = value
 
     @property
     def aspect_ratio(self) -> float:
         return self.width/(self.height or 1)
 
     # Components
@@ -357,14 +357,17 @@
             for b, box in enumerate(temporal):
                 yield (t, b, box)
 
     def row(self, n: int=0) -> Iterable[TextureBox]:
         yield from self.matrix[n]
 
     def make(self) -> Self:
+        if (max(self.size) > 2**15):
+            raise Exception(f"Texture size likely too large {self.size}")
+
         self._populate()
         for (_, _, box) in self.boxes:
             box.release()
             box.texture = self.scene.opengl.texture(
                 components=self.components,
                 dtype=self.dtype.name,
                 size=self.size,
@@ -491,16 +494,25 @@
     # Module
 
     def _coord2name(self, old: int, layer: int) -> str:
         return f"{self.name}{old}x{layer}"
 
     def defines(self) -> Iterable[str]:
         """Define last frames as plain name (iTex0x(-1) -> iTex, iTex1x(-1) -> iTex1)"""
-        for old in range(self.temporal):
-            yield f"#define {self.name}{old or ''} {self.name}{old}x{self.layers-1}"
+        for temporal in range(self.temporal):
+            yield f"#define {self.name}{temporal or ''} {self.name}{temporal}x{self.layers-1}"
+
+        # Function to sample a dynamic temporal, layer
+        yield f"\nvec4 {self.name}Texture(int temporal, int layer, vec2 astuv) {{"
+        yield "    if (false) return vec4(0);"
+        for temporal in range(self.temporal):
+            for layer in range(self.layers):
+                yield f"    else if (temporal == {temporal} && layer == {layer}) return texture({self._coord2name(temporal, layer)}, astuv);"
+        yield "    else {return vec4(0);}"
+        yield "}"
 
     def handle(self, message: Message):
         if self.track:
             if isinstance(message, Message.Shader.RecreateTextures):
                 self.make()
 
     def pipeline(self) -> Iterable[ShaderVariable]:
```

## ShaderFlow/__main__.py

```diff
@@ -32,15 +32,15 @@
         """Find all Scenes: Project directory and current directory"""
         direct = sys.argv[1] if (len(sys.argv) > 1) else ""
         files = set()
 
         # The user might point to a file or directory
         if (direct.endswith(".py")):
             files.add(BrokenPath(sys.argv.pop(1)))
-        elif BrokenPath.valid(direct):
+        elif (len(sys.argv) > 1) and BrokenPath.valid(sys.argv[1]):
             files.update(BrokenPath(sys.argv.pop(1)).rglob("*.py"))
         else:
             files.update(SHADERFLOW.DIRECTORIES.REPOSITORY.glob("Community/**/*.py"))
             files.update(SHADERFLOW.RESOURCES.SCENES.rglob("*.py"))
             files.update(Path.cwd().glob("*.py"))
 
         # Add the files, exit if no scene was added
@@ -58,15 +58,14 @@
         if not (file := BrokenPath(file).valid()):
             return False
         if not (code := LoaderString(file)):
             return False
 
         def partial_run(file, name, code):
             def run_scene(ctx: Context):
-                SHADERFLOW.DIRECTORIES.CURRENT_SCENE = file.parent
                 # Note: Point of trust transfer to the file the user is running
                 exec(compile(code, file, "exec"), namespace := {})
                 scene = namespace[name]
                 instance = scene()
                 instance.cli(*ctx.args)
             return run_scene
 
@@ -82,13 +81,12 @@
                 context=True,
             )
 
         return True
 
 def main():
     with BrokenProfiler("SHADERFLOW"):
-        SHADERFLOW.welcome()
-        app = ShaderFlowManager()
-        app.cli()
+        shaderflow = ShaderFlowManager()
+        shaderflow.cli()
 
 if __name__ == "__main__":
     main()
```

## ShaderFlow/Modules/Bouncing.py

```diff
@@ -46,19 +46,19 @@
         return self.position[0]
 
     @property
     def y(self) -> float:
         return self.position[1]
 
     @x.setter
-    def x(self, value: float) -> None:
+    def x(self, value: float):
         self.position[0] = value
 
     @y.setter
-    def y(self, value: float) -> None:
+    def y(self, value: float):
         self.position[1] = value
 
     # # Advanced
 
     def advanced_ratios(self, image: LoadableImage, steps: int=1000) -> ShaderTexture:
         """Get a texture of `aspect_ratio(angle)` from linspace(0, tau, steps)"""
         ratios = numpy.zeros((steps, 1), dtype=numpy.float32)
```

## ShaderFlow/Modules/Camera.py

```diff
@@ -25,15 +25,15 @@
   - https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab
 
 â€¢ "here, have a coordinate system chart~" by @FreyaHolmer
   - https://twitter.com/FreyaHolmer/status/1325556229410861056
 """
 
 import math
-from typing import Iterable, Self, Union
+from typing import Iterable, Self, Tuple, Union
 
 import numpy
 import quaternion
 from attr import define
 from loguru import logger as log
 
 from Broken import BrokenEnum, clamp
@@ -81,17 +81,17 @@
 class CameraMode(BrokenEnum):
     """
     How to deal with Rotations and actions on 3D or 2D space
     - FreeCamera: Apply quaternion rotation and don't care of roll changing the "UP" direction
     - Camera2D:   Fixed direction, drag moves position on the plane of the screen, becomes isometric
     - Spherical:  Always correct such that the camera orthonormal base is pointing "UP"
     """
-    FreeCamera = 1
-    Camera2D   = 2
-    Spherical  = 3
+    FreeCamera = 0
+    Camera2D   = 1
+    Spherical  = 2
 
 # -------------------------------------------------------------------------------------------------|
 
 class Algebra:
 
     def rotate_vector(vector: Vector3D, R: Quaternion) -> Vector3D:
         """
@@ -142,15 +142,15 @@
         """Returns the unit vector of a given vector, safely"""
         if (factor := numpy.linalg.norm(vector)):
             return vector/factor
         return vector
 
     @staticmethod
     def safe(
-        *vector: Union[numpy.ndarray | tuple[float] | tuple[int] | float | int],
+        *vector: Union[numpy.ndarray, Tuple[float], float, int],
         dimensions: int=3,
         dtype: numpy.dtype=_dtype
     ) -> numpy.ndarray:
         """
         Returns a safe numpy array from a given vector, with the correct dimensions and dtype
         """
         return numpy.array(vector, dtype=dtype).reshape(dimensions)
@@ -296,29 +296,29 @@
     def base_z_target(self) -> Vector3D:
         return Algebra.rotate_vector(GlobalBasis.Z, self.rotation.target)
 
     @property
     def x(self) -> float:
         return self.position.value[0]
     @x.setter
-    def x(self, value: float) -> None:
+    def x(self, value: float):
         self.position.target[0] = value
 
     @property
     def y(self) -> float:
         return self.position.value[1]
     @y.setter
-    def y(self, value: float) -> None:
+    def y(self, value: float):
         self.position.target[1] = value
 
     @property
     def z(self) -> float:
         return self.position.value[2]
     @z.setter
-    def z(self, value: float) -> None:
+    def z(self, value: float):
         self.position.target[2] = value
 
     # ---------------------------------------------------------------------------------------------|
     # Interaction
 
     def update(self):
         dt = abs(self.scene.dt or self.scene.rdt)
@@ -380,30 +380,29 @@
         if any([
             isinstance(message, Message.Mouse.Position) and self.scene.exclusive,
             isinstance(message, Message.Mouse.Drag)
         ]):
             if not (self.scene.mouse_buttons[1] or self.scene.exclusive):
                 return
 
-            match self.mode:
-                # Rotate around the camera basis itself
-                case CameraMode.FreeCamera:
-                    self.rotate(direction=self.base_y/self.zoom.value, angle= message.du*100)
-                    self.rotate(direction=self.base_x/self.zoom.value, angle=-message.dv*100)
-
-                # Rotate relative to the XY plane
-                case CameraMode.Camera2D:
-                    move = (message.du*GlobalBasis.X) + (message.dv*GlobalBasis.Y)
-                    move = Algebra.rotate_vector(move, self.rotation.target)
-                    self.move(move*(1 if self.scene.exclusive else -1)/self.zoom.value)
-
-                case CameraMode.Spherical:
-                    up = 1 if (Algebra.angle(self.base_y_target, self.up) < 90) else -1
-                    self.rotate(direction=self.up*up /self.zoom.value, angle= message.du*100)
-                    self.rotate(direction=self.base_x/self.zoom.value, angle=-message.dv*100)
+            # Rotate around the camera basis itself
+            if (self.mode == CameraMode.FreeCamera):
+                self.rotate(direction=self.base_y/self.zoom.value, angle= message.du*100)
+                self.rotate(direction=self.base_x/self.zoom.value, angle=-message.dv*100)
+
+            # Rotate relative to the XY plane
+            elif (self.mode == CameraMode.Camera2D):
+                move = (message.du*GlobalBasis.X) + (message.dv*GlobalBasis.Y)
+                move = Algebra.rotate_vector(move, self.rotation.target)
+                self.move(move*(1 if self.scene.exclusive else -1)/self.zoom.value)
+
+            elif (self.mode == CameraMode.Spherical):
+                up = 1 if (Algebra.angle(self.base_y_target, self.up) < 90) else -1
+                self.rotate(direction=self.up*up /self.zoom.value, angle= message.du*100)
+                self.rotate(direction=self.base_x/self.zoom.value, angle=-message.dv*100)
 
         # Wheel Scroll Zoom
         elif isinstance(message, Message.Mouse.Scroll):
             self.apply_zoom(0.05*message.dy)
 
         # Camera alignments and modes
         elif isinstance(message, Message.Keyboard.Press) and (message.action == 1):
```

## ShaderFlow/Modules/Dynamics.py

```diff
@@ -77,14 +77,17 @@
 
     derivative: float = 0.0
     """Derivative of the system, the rate of change of the value in ($unit/second)"""
 
     acceleration: float = 0.0
     """Acceleration of the system, the rate of change of the derivative in ($unit/second^2)"""
 
+    instant: bool = False
+    """Update the system immediately to the target value, """
+
     @property
     def k1(self) -> float:
         """Y velocity coefficient"""
         return self.zeta/(pi * self.frequency)
 
     @property
     def k2(self) -> float:
@@ -124,20 +127,29 @@
         if not dt:
             return self.value
 
         # Update target
         if (target is not None):
             self.target = target
 
+        # Instant mode
+        if self.instant:
+            self.value = self.target*1
+            self.integral += self.value * dt
+            self.derivative = 0
+            self.acceleration = 0
+            return self.value
+
         # Optimization: Do not compute if value within precision to target
         if abs(numpy.sum(self.target - self.value)) < self.precision:
+            self.integral += self.value * dt
             return self.value
 
         # "Estimate velocity"
-        velocity      = (self.target - self.previous)/dt
+        velocity = (self.target - self.previous)/dt
         self.previous = self.target
 
         # "Clamp k2 to stable values without jitter"
         if (self.radians*dt < self.zeta):
             k2 = max(self.k1*dt, self.k2, 0.5*(self.k1+dt)*dt)
             k1 = self.k1
```

## ShaderFlow/Modules/Keyboard.py

```diff
@@ -1,13 +1,11 @@
 import functools
-from typing import Dict
-from typing import Iterable
+from typing import Dict, Iterable, Union
 
-from attr import Factory
-from attr import define
+from attr import Factory, define
 from moderngl_window.context.base import BaseKeys as ModernglKeys
 
 from ShaderFlow.Message import Message
 from ShaderFlow.Module import ShaderModule
 from ShaderFlow.Variable import ShaderVariable
 
 
@@ -24,15 +22,15 @@
     _pressed: Dict[int, bool] = Factory(dict)
 
     @staticmethod
     def set_keymap(keymap: ModernglKeys) -> None:
         ShaderKeyboard.DirKeys = {key: getattr(keymap, key) for key in dir(keymap) if not key.startswith("_")}
         ShaderKeyboard.Keys = keymap
 
-    def pressed(self, key: int | ModernglKeys=None) -> bool:
+    def pressed(self, key: Union[int, ModernglKeys]=None) -> bool:
         return self._pressed.setdefault(key, False)
 
     def __call__(self, *a, **k) -> bool:
         return self.pressed(*a, **k)
 
     def pipeline(self) -> Iterable[ShaderVariable]:
         return
```

## ShaderFlow/Modules/Noise.py

```diff
@@ -1,15 +1,14 @@
 import functools
 import random
 from typing import Iterable
 
 import numpy
 import opensimplex
-from attr import Factory
-from attr import define
+from attr import Factory, define
 
 from ShaderFlow.Module import ShaderModule
 from ShaderFlow.Variable import ShaderVariable
 
 
 @define
 class ShaderNoise(ShaderModule):
```

## ShaderFlow/Modules/Piano.py

```diff
@@ -59,30 +59,38 @@
 
     global_maximum_note: int = 0
     """The highest note in the loaded notes"""
 
     extra_side_keys: int = 6
     """Display the dynamic range plus this many keys on each side"""
 
-    note_range_ahead: Seconds = 2
+    future_range_lookup: Seconds = 2
     """Lookup notes in (roll_time + this) for setting the dynamic ranges"""
 
+    release_before_end: Seconds = 0.05
+    """Workaround for the transition between close/glued to be perceived"""
+
     key_press_dynamics: DynamicNumber = Factory(lambda: DynamicNumber(
         value=numpy.zeros(MAX_NOTE, numpy.float32),
         frequency=4, zeta=0.4, response=0, precision=0
     ))
 
     note_range_dynamics: DynamicNumber = Factory(lambda: DynamicNumber(
         value=numpy.zeros(2, numpy.float32),
         frequency=0.05, zeta=1/(2**0.5), response=0,
     ))
 
     tree: Dict[int, Dict[int, Deque[BrokenPianoNote]]] = Factory(dict)
     """Internal data structure for storing the notes"""
 
+    @property
+    def lookup_time(self) -> Seconds:
+        """The full lookup time we should care for future notes (rolling+future range)"""
+        return (self.roll_time + self.future_range_lookup)
+
     # # Internal
 
     def __post__(self):
         self.keys_texture    = ShaderTexture(scene=self.scene, name=f"{self.name}Keys").from_numpy(self._empty_keys())
         self.channel_texture = ShaderTexture(scene=self.scene, name=f"{self.name}Chan").from_numpy(self._empty_keys())
         self.roll_texture    = ShaderTexture(scene=self.scene, name=f"{self.name}Roll").from_numpy(self._empty_roll())
         self.tempo_texture   = ShaderTexture(scene=self.scene, name=f"{self.name}Tempo").from_numpy(numpy.zeros((100, 1, 2), numpy.float32))
@@ -111,14 +119,18 @@
 
     @property
     def notes(self) -> Iterable[BrokenPianoNote]:
         for block in self.tree.values():
             for notes in block.values():
                 yield from notes
 
+    @property
+    def duration(self) -> float:
+        return max((note.end for note in self.notes), default=0)
+
     def __iter__(self) -> Iterable[BrokenPianoNote]:
         return self.notes
 
     def notes_between(self, index: int, start: Seconds, end: Seconds) -> Iterable[BrokenPianoNote]:
         exists = set()
         for other in self._ranges(start, end):
             for note in self.tree.get(index, dict()).get(other, deque()):
@@ -185,65 +197,70 @@
 
     # A (MAX_MIDI Notes x MAX_CHANNELS Channels) matrix of the end-most note being played
     _playing_matrix: List[List[Optional[BrokenPianoNote]]] = Factory(lambda: [[None]*MAX_CHANNELS for _ in range(MAX_NOTE)])
 
     def update(self):
 
         # Utilities and trackers
-        time     = (self.scene.time + self.time_offset)
-        lookup   = (self.roll_time + self.note_range_ahead)
+        time = (self.scene.time + self.time_offset)
         upcoming = set()
 
         # # Get and update pressed keys
         self.key_press_dynamics.target.fill(0)
         roll = self._empty_roll()
 
         # Channel '-1' means the note is not being played !
         channels = (self._empty_keys() - 1)
 
-        # No need to check for the entire range ðŸ˜‰
+        # Optimization: No need to check for the entire range ðŸ˜‰
         for midi in range(self.global_minimum_note, self.global_maximum_note+1):
             simultaneous = 0
 
-            for note in self.notes_between(midi, time, time+lookup):
+            for note in self.notes_between(midi, time, time+self.lookup_time):
                 upcoming.add(midi)
 
+                # Ignore notes out of the viewport
                 if (note.start >= time+self.roll_time):
                     continue
 
-                # This note is being played
-                if (playing := (note.start <= time <= note.end)):
-                    self.key_press_dynamics.target[midi] = note.velocity
-                    channels[midi] = note.channel
-
                 # Build a 2D Grid of the piano keys being played
                 # â€¢ Coordinate: (Note, #offset) @ (Start, End, Channel, Velocity)
                 if (simultaneous < MAX_ROLLING):
                     roll[note.note, simultaneous] = (note.start, note.end, note.channel, note.velocity)
                     simultaneous += 1
 
-                # Real time play notes condition
-                if self.scene.rendering: continue
-                if not self.fluidsynth:  continue
-                if not playing: continue
+                # Skip non-playing notes
+                if not (note.start <= time <= note.end):
+                    continue
+
+                # Workaround: Don't play the full note, so close notes velocities are perceived twice
+                _note_too_small = (note.end - note.start) < self.release_before_end
+                _shorter_note = (time < (note.end - self.release_before_end))
+
+                if (_shorter_note or _note_too_small):
+                    self.key_press_dynamics.target[midi] = note.velocity
+
+                # Either way, the channel must be colored
+                channels[midi] = note.channel
 
                 # Find empty slots or notes that will end soon, replace and play
                 other = self._playing_matrix[midi][note.channel]
                 if (other is None) or (other.end > note.end):
-                    self.fluid_key_down(midi, note.velocity, note.channel)
+                    play_velocity = int(128*((note.velocity/128)**0.5))
+                    self.fluid_key_down(midi, play_velocity, note.channel)
                     self._playing_matrix[midi][note.channel] = note
 
             # Find notes that are not being played
-            for channel in range(MAX_CHANNELS if self.scene.realtime else 0):
+            for channel in range(MAX_CHANNELS * self.scene.realtime):
                 if (other := self._playing_matrix[midi][channel]) and (other.end < time):
                     self._playing_matrix[midi][channel] = None
                     self.fluid_key_up(midi, other.channel)
 
         # Dynamic zoom velocity based on future lookup
-        self.note_range_dynamics.frequency = 0.5/lookup
+        self.note_range_dynamics.frequency = 0.5/self.lookup_time
 
         # Set dynamic note range to the globals on the start
         if sum(self.note_range_dynamics.value) == 0:
             self.note_range_dynamics.value[:] = (self.global_minimum_note, self.global_maximum_note)
 
         # Set new targets for dynamic keys
         self.note_range_dynamics.target[:] = (
```

## ShaderFlow/Modules/Spectrogram.py

```diff
@@ -52,20 +52,18 @@
     # Sinc(x) is already normalized (divided by the area, pi) as in sinc(x) = sin(pi*x)/(pi*x).
     #
     # The general case for a interpolation formula is to normalize some function f(x) by its area.
     # For example, in the case of exp(-x^2) as the function, its area is the  magical sqrt(pi)
     # as seen in @3b1b https://www.youtube.com/watch?v=cy8r7WSuT1I
     #
 
-    @staticmethod
     # Note: A value above 1.54 is recommended
     def make_euler(end: float=1.54) -> Callable:
         return (lambda x: numpy.exp(-(2*x/end)**2) / (end*(pi**0.5)))
 
-    @staticmethod
     def Dirac(x):
         dirac = numpy.zeros(x.shape)
         dirac[numpy.round(x) == 0] = 1
         return dirac
 
     Euler = make_euler(end=1.2)
```

## ShaderFlow/Modules/Video.py

```diff
@@ -212,16 +212,16 @@
             width=self.width,
             height=self.height,
             temporal=self.temporal,
             components=3,
             dtype="f1"
         )
 
-    _same: SameTracker = Factory(SameTracker)
+    __same__: SameTracker = Factory(SameTracker)
 
     def update(self):
         index, decode = self.get_frame(self.scene.time)
 
-        if not self._same(index):
+        if not self.__same__(index):
             image = decode()
             self.texture.roll()
             self.texture.write(image)
```

## ShaderFlow/Modules/Waveform.py

```diff
@@ -76,21 +76,21 @@
         return nearest(
             number=self.audio.buffer_size,
             multiple=self.chunk_size,
             operator=math.floor,
             type=int,
         )
 
-    _same: SameTracker = Factory(SameTracker)
+    __same__: SameTracker = Factory(SameTracker)
 
     def update(self):
         self.texture.filter     = ("linear" if self.smooth else "nearest")
         self.texture.components = self.audio.channels
         self.texture.width      = self._points
-        if self._same(self.audio.read):
+        if self.__same__(self.audio.read):
             return
         start  = -int(self.chunk_size*self._points + self._offset + 1)
         end    = -int(self._offset + 1)
         chunks = self.audio.data[:, start:end]
         chunks = chunks.reshape(self.audio.channels, -1, self.chunk_size)
         chunks = self.reducer(chunks)
         chunks = numpy.ascontiguousarray(chunks.T)
```

## ShaderFlow/Optional/Monocular.py

```diff
@@ -1,7 +1,8 @@
+import multiprocessing
 from typing import Any
 
 import numpy
 import PIL
 import PIL.ImageFilter
 from attr import define
 from loguru import logger as log
@@ -9,15 +10,15 @@
 
 import Broken
 from Broken import BrokenSpinner, image_hash
 from Broken.Loaders import LoadableImage, LoaderImage
 
 
 @define
-class Monocular:
+class DepthEstimator:
     _model:     Any = None
     _processor: Any = None
 
     @property
     def device(self) -> str:
         import torch
         if torch.cuda.is_available():
@@ -68,14 +69,17 @@
             self._model.to(self.device)
 
         # Estimate Depth Map
         with BrokenSpinner(f"Estimating Depth Map for the input image (CUDA: {torch.cuda.is_available()})"):
             inputs = self._processor(images=image, return_tensors="pt")
             inputs = {key: value.to(self.device) for key, value in inputs.items()}
 
+            # Optimization: We import torch with OMP_NUM_THREADS=1 because NumPy, so "revert" it
+            torch.set_num_threads(max(4, multiprocessing.cpu_count()//2))
+
             # Inference the model
             with torch.no_grad():
                 depth = self._model(**inputs).predicted_depth
 
         # -----------------------------------------------------------------------------------------|
         # Post-processing
```

## ShaderFlow/Resources/Scenes/Examples/Demo.py

```diff
@@ -1,8 +1,9 @@
 import math
+from pathlib import Path
 
 import numpy
 from ShaderFlow import SHADERFLOW
 from ShaderFlow.Modules.Audio import ShaderAudio
 from ShaderFlow.Modules.Bouncing import ShaderBouncing
 from ShaderFlow.Modules.Dynamics import ShaderDynamics
 from ShaderFlow.Modules.Noise import ShaderNoise
@@ -18,15 +19,15 @@
 from Broken import BrokenPath
 
 BACKGROUND = "https://w.wallhaven.cc/full/e7/wallhaven-e778vr.jpg"
 
 # -------------------------------------------------------------------------------------------------|
 
 class Default(ShaderScene):
-    """The most basic ShaderFlow Scene, the default shader"""
+    """The most basic ShaderScene, the default shader"""
     ...
 
 # -------------------------------------------------------------------------------------------------|
 
 class ShaderToy(ShaderScene):
     """ShaderToy Default Shader"""
 
@@ -72,40 +73,39 @@
         ShaderScene.build(self)
         ShaderTexture(scene=self, name="background").from_image(BACKGROUND)
         self.shader.texture.layers = 2
         self.shader.fragment = (self.directory/"GLSL"/"Multipass.frag")
 
 # -------------------------------------------------------------------------------------------------|
 
-class Temporal(ShaderScene):
+class MotionBlur(ShaderScene):
     """Poor's man Motion Blur. If you dislike the effect, definitely don't run this"""
-    __name__ = "Temporal"
+    __name__ = "MotionBlur"
 
     def build(self):
         ShaderScene.build(self)
         ShaderTexture(scene=self, name="background").from_image(BACKGROUND)
         self.shader.texture.temporal = 10
         self.shader.texture.layers = 2
-        self.shader.fragment = (self.directory/"GLSL"/"Temporal.frag")
+        self.shader.fragment = (self.directory/"GLSL"/"MotionBlur.frag")
 
 # -------------------------------------------------------------------------------------------------|
 
 class Dynamics(ShaderScene):
     """Second order system"""
     __name__ = "Dynamics"
 
     def build(self):
         ShaderScene.build(self)
         ShaderTexture(scene=self, name="background").from_image(BACKGROUND)
         self.dynamics = ShaderDynamics(scene=self, name="iShaderDynamics", frequency=4)
         self.shader.fragment = ("""
             void main() {
                 vec2 uv = zoom(stuv, 0.85 + 0.1*iShaderDynamics, vec2(0.5));
-                fragColor = draw_image(background, uv);
-                fragColor.a = 1;
+                fragColor = stexture(background, uv);
             }
         """)
 
     def update(self):
         self.dynamics.target = 0.5 * (1 + numpy.sign(numpy.sin(2*math.pi*self.time * 0.5)))
 
 # -------------------------------------------------------------------------------------------------|
@@ -119,15 +119,15 @@
         ShaderTexture(scene=self, name="background").from_image(BACKGROUND)
         self.shake_noise = ShaderNoise(scene=self, name="Shake", dimensions=2)
         self.zoom_noise  = ShaderNoise(scene=self, name="Zoom")
         self.shader.fragment = ("""
             void main() {
                 vec2 uv = zoom(stuv, 0.95 + 0.02*iZoom, vec2(0.5));
                 uv += 0.02 * iShake;
-                fragColor = draw_image(background, uv);
+                fragColor = stexture(background, uv);
             }
         """)
 
 # -------------------------------------------------------------------------------------------------|
 
 class Bouncing(ShaderScene):
     """Bouncing Logo animation"""
@@ -225,19 +225,45 @@
         ShaderTexture(scene=self, name="logo").from_image(SHADERFLOW.RESOURCES.ICON)
         ShaderNoise(scene=self, name="Shake", dimensions=2)
         ShaderNoise(scene=self, name="Zoom")
         self.shader.fragment = (self.directory/"GLSL"/"Visualizer.frag")
 
 # -------------------------------------------------------------------------------------------------|
 
+class RayMarch(ShaderScene):
+    """Ray Marching demo"""
+    __name__ = "Ray Marching"
+
+    def build(self):
+        ShaderScene.build(self)
+        self.shader.fragment = (self.directory/"GLSL"/"RayMarch.frag")
+
+# -------------------------------------------------------------------------------------------------|
+
+class Batch(ShaderScene):
+    """Batch exporting demo. Run with `shaderflow batch -b 1-3 --base /path/to/folder"""
+    __name__ = "Batch"
+
+    def export_name(self, path: Path) -> Path:
+        return path.with_stem({
+            1: "SubScene A",
+            2: "SubScene B",
+            3: "SubScene C",
+        }[self.export_index])
+
+    def build(self):
+        ShaderScene.build(self)
+
+# -------------------------------------------------------------------------------------------------|
+
 class Life(ShaderScene):
     """Conway's Game of Life in GLSL"""
     __name__ = "Game of Life"
 
-    life_each: int = 6
+    life_period: int = 6
     """Number of frames between each life update"""
 
     def setup(self):
         width, height = 192, 108
         random = numpy.random.randint(0, 2, (width, height), dtype=bool)
         self.simulation.texture.size = (width, height)
         self.simulation.texture.write(random.astype(numpy.float32), temporal=1)
@@ -250,20 +276,10 @@
         self.simulation.texture.components = 1
         self.simulation.texture.track = False
         self.simulation.fragment = (self.directory/"GLSL"/"Life/Simulation.glsl")
         self.shader.fragment = (self.directory/"GLSL"/"Life/Visuals.glsl")
 
     def pipeline(self):
         yield from ShaderScene.pipeline(self)
-        yield ShaderVariable("uniform", "int", "iLifeEach", self.life_each)
-
-# -------------------------------------------------------------------------------------------------|
-
-class RayMarch(ShaderScene):
-    """Ray Marching demo"""
-    __name__ = "Ray Marching"
-
-    def build(self):
-        ShaderScene.build(self)
-        self.shader.fragment = (self.directory/"GLSL"/"RayMarch.frag")
+        yield ShaderVariable("uniform", "int", "iLifePeriod", self.life_period)
 
 # -------------------------------------------------------------------------------------------------|
```

## ShaderFlow/Resources/Scenes/Examples/GLSL/Multipass.frag

```diff
@@ -22,15 +22,15 @@
     }
 
     return color / weights;
 }
 
 void main() {
     if (iLayer == 0) {
-        fragColor = draw_image(background, stuv);
+        fragColor = stexture(background, stuv);
 
     } else if (iLayer == 1) {
         fragColor = texture(iScreen0x0, astuv);
 
         // Invert red on the left, blur the right
         if (gluv.x < 0) {
             fragColor.r = 1 - fragColor.r;
```

## ShaderFlow/Resources/Scenes/Examples/GLSL/Video.frag

```diff
@@ -1,5 +1,5 @@
 void main() {
     vec2 uv = iCamera.astuv;
-    fragColor = draw_image(iVideo, iCamera.stuv);
+    fragColor = stexture(iVideo, iCamera.stuv);
     fragColor.a = 1;
 }
```

## ShaderFlow/Resources/Scenes/Examples/GLSL/Visualizer.frag

```diff
@@ -11,15 +11,15 @@
         fragColor.rgb = space;
         return;
     }
 
     // Draw background
     vec2 background_uv = zoom(gluv2stuv(uv), 0.95 + 0.02*iZoom - 0.02*iAudioVolume, vec2(0.5));
     background_uv += 0.01 * iShake;
-    fragColor = draw_image(background, background_uv);
+    fragColor = stexture(background, background_uv);
 
     // Music bars coordinates
     vec2 music_uv = rotate2d(-PI/2) * uv;
     music_uv *= 1 - 0.4 * pow(abs(iAudioVolume), 0.5);
     float radius = 0.17;
 
     // Get spectrogram bar volumes
@@ -27,15 +27,15 @@
     vec2 freq = sqrt(texture(iSpectrogram, vec2(0, circle)).xy / 1000);
     freq *= 0.3 + 1.3*smoothstep(0, 1, circle);
 
     // Music bars
     if (length(music_uv) < radius) {
         vec2 logo_uv = (rotate2d(0.3*sin(3*iAudioVolumeIntegral + iTime/2)) * music_uv / (1.3*radius));
         logo_uv *= 1 - 0.02*pow(abs(iAudioVolume), 0.1);
-        fragColor = draw_image(logo, gluv2stuv(logo_uv * rotate2d(-PI/2)));
+        fragColor = gtexture(logo, logo_uv * rotate2d(-PI/2));
     } else {
         float bar = (music_uv.y < 0) ? freq.x : freq.y;
         float r = radius + 0.5*bar;
 
         if (length(music_uv) < r) {
             fragColor.rgb = mix(fragColor.rgb, vec3(1), smoothstep(0, 1, 0.5 + bar));
         } else {
```

## ShaderFlow/Resources/Scenes/Examples/GLSL/Life/Simulation.glsl

```diff
@@ -18,15 +18,15 @@
 );
 
 void main() {
     int near = 0;
     int current;
 
     // Make the animation slower
-    if ((iFrame % iLifeEach) != 0) {
+    if ((iFrame % iLifePeriod) != 0) {
         fragColor.r = texture(iLife1x0, astuv).r;
         fragColor.a = 1;
         return;
     }
 
     ivec2 pixel = ivec2(astuv*iLifeSize);
```

## ShaderFlow/Resources/Scenes/Examples/GLSL/Life/Visuals.glsl

```diff
@@ -14,18 +14,18 @@
     // Rratio of the life temporal integration of f(t) = (1 - t)^k
     // Higher values prefer latest states, lower values smooths all
     float exponent = 1.3;
     float area = 1/(exponent + 1);
 
     // Integrate life
     float life = 0;
-    life += draw_image(iLife0x0, uv).r;
-    life += draw_image(iLife1x0, uv).r * pow(0.8, exponent);
-    life += draw_image(iLife2x0, uv).r * pow(0.6, exponent);
-    life += draw_image(iLife3x0, uv).r * pow(0.4, exponent);
-    life += draw_image(iLife4x0, uv).r * pow(0.2, exponent);
+    life += stexture(iLife0x0, uv).r;
+    life += stexture(iLife1x0, uv).r * pow(0.8, exponent);
+    life += stexture(iLife2x0, uv).r * pow(0.6, exponent);
+    life += stexture(iLife3x0, uv).r * pow(0.4, exponent);
+    life += stexture(iLife4x0, uv).r * pow(0.2, exponent);
     life /= (5*area);
 
     // Colorize life
     fragColor.rgb = palette(life, COLOR1, COLOR2, COLOR3, COLOR4);
     fragColor.a = 1;
 }
```

## ShaderFlow/Resources/Shaders/Include/Camera.glsl

```diff
@@ -1,14 +1,14 @@
 #ifndef SHADERFLOW_CAMERA
 #define SHADERFLOW_CAMERA
 
     // Camera Mode Enum
-    #define CameraModeFreeCamera 1
-    #define CameraMode2D 2
-    #define CameraModeSpherical 3
+    #define CameraModeFreeCamera 0
+    #define CameraMode2D 1
+    #define CameraModeSpherical 2
 
     // Camera Projection Enum
     #define CameraProjectionPerspective 0
     #define CameraProjectionVirtualReality 1
     #define CameraProjectionEquirectangular 2
 
     struct Camera {
@@ -32,14 +32,16 @@
         vec3 target;   // Target of the camera ray
         vec3 ray;      // Camera ray normalized vector
         float orbital; // Displacement of origin and target from the position
         float dolly;   // Displacement of the origin from the position
 
         //// Rays 2D
 
+        vec3 plane_point;
+        vec3 plane_normal;
         vec2 screen;
         vec2 gluv;
         vec2 agluv;
         vec2 stuv;
         vec2 astuv;
         vec2 glxy;
         vec2 stxy;
@@ -70,17 +72,19 @@
             + CameraRectangle(camera, (1/camera.zoom))
             - (camera.Z*camera.orbital)
             + camera.Z;
     }
 
     Camera CameraRay2D(Camera camera) {
 
-        // Calculate the intersection with the z=1 plane
-        // The equation is: origin + (t * direction) = (x, y, 1)
-        float t = (1 - camera.origin.z) / camera.ray.z;
+        // Calculate the interstion with the plane define by a point and norm
+        // https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection
+        float num = dot(camera.plane_point - camera.origin, camera.plane_normal);
+        float den = dot(camera.ray, camera.plane_normal);
+        float t = num/den;
 
         // The ray intersects the plane behind the camera
         if (t < 0) {
             camera.out_of_bounds = true;
             return camera;
         }
 
@@ -135,14 +139,16 @@
 
 #endif
 
 // Initialization
 
 Camera iInitCamera(vec2 gluv) {
     Camera camera;
+    camera.plane_point   = vec3(0, 0, 1);
+    camera.plane_normal  = vec3(0, 0, 1);
     camera.screen        = gluv;
     camera.mode          = iCameraMode;
     camera.projection    = iCameraProjection;
     camera.position      = iCameraPosition;
     camera.orbital       = iCameraOrbital;
     camera.dolly         = iCameraDolly;
     camera.UP            = iCameraUP;
```

## ShaderFlow/Resources/Shaders/Include/ShaderFlow.glsl

```diff
@@ -167,35 +167,47 @@
 
 // GLUV Coordinate + Mirrored Repeat texture
 // Note: Have .repeat(False) (CLAMP_TO_EDGE) on the sampler
 vec4 gmtexture(sampler2D image, vec2 gluv) {
     return gtexture(image, gluv_mirrored_repeat(gluv));
 }
 
+// Function overloading to call gmtexture on gtexture(_, _, true)
+vec4 gtexture(sampler2D image, vec2 gluv, bool mirror) {
+    if (mirror)
+    return gmtexture(image, gluv);
+    return gtexture(image, gluv);
+}
+
 // AGLUV Coordinate texture
 vec4 agtexture(sampler2D image, vec2 agluv) {
     return gtexture(image, agluv2gluv(agluv));
 }
 
 // AGLUV Coordinate + Mirrored Repeat texture
 // Note: Have .repeat(False) (CLAMP_TO_EDGE) on the sampler
 vec4 agmtexture(sampler2D image, vec2 agluv) {
     return agtexture(image, agluv_mirrored_repeat(agluv));
 }
 
+// Function overloading to call agmtexture on agtexture(_, _, true)
+vec4 agtexture(sampler2D image, vec2 agluv, bool mirror) {
+    if (mirror)
+    return agmtexture(image, agluv);
+    return agtexture(image, agluv);
+}
+
 vec4 stexture(sampler2D image, vec2 stuv) {
     return gtexture(image, stuv2gluv(stuv));
 }
 
 vec4 astexture(sampler2D image, vec2 astuv) {
     return agtexture(image, stuv2gluv(astuv));
 }
 
-#define draw_image stexture
-
 // // Palettes
 
 vec3 palette(float t, vec3 A, vec3 B, vec3 C, vec3 D) {
     if (t < 0.25) {
         return mix(A, B, t*4);
     } else if (t < 0.5) {
         return mix(B, C, (t - 0.25)*4);
```

## SpectroNote/SpectroNote.py

```diff
@@ -6,15 +6,15 @@
 
 from Broken.Types import Hertz
 from SpectroNote import SPECTRONOTE
 
 
 @define
 class SpectroNoteScene(ShaderScene):
-    """ðŸŽ§ Piano-Perfect Audio Spectrogram. Unlock a hidden Absolute Pitch in you. Lightning fast, reliable, customizable."""
+    """ðŸŽ§ Piano-Perfect Audio Spectrogram. Unlock a hidden Absolute Pitch in you. Lightning fast, reliable, customizable"""
     __name__ = "SpectroNote"
 
     # Scene parameters
     piano_bins:   bool  = False
     piano_range:  bool  = False
     piano_size:   float = 0.05
     black_ratio:  float = 0.5
```

## SpectroNote/__main__.py

```diff
@@ -1,15 +1,13 @@
 import sys
 
 from Broken import BrokenProfiler
-from SpectroNote import SPECTRONOTE
 from SpectroNote.SpectroNote import SpectroNoteScene
 
 
 def main():
     with BrokenProfiler("SPECTRONOTE"):
-        SPECTRONOTE.welcome()
         spectronote = SpectroNoteScene()
         spectronote.cli(sys.argv[1:])
 
 if __name__ == "__main__":
     main()
```

## Comparing `DepthFlow/Resources/Shaders/DepthFlow2D.frag` & `DepthFlow/Resources/Shaders/Deprecated/DepthFlow2D.frag`

 * *Files 4% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // Kept as a simpler older relic of the past
 
 // ------------------------------------------------------------------------------------------------|
 
 // Get the clamped depth of a image (no overshooting) based on iFocus
 // - Zero depth means the object does not move
 float get_depth(vec2 stuv, sampler2D depth) {
-    return iFocus - draw_image(depth, stuv).r;
+    return iFocus - stexture(depth, stuv).r;
 }
 
 // Depth-Layer displacement for a pixel, composed of the camera displacement times max
 // camera displacement (iParallaxFactor) times the depth of the pixel (zero should not move)
 vec2 displacement(vec2 stuv, sampler2D depth) {
     return iPosition * get_depth(stuv, depth) * iParallaxFactor;
 }
@@ -52,15 +52,15 @@
         // This pixel is on top of us, update the parallax stuv
         if (i < length(other_displacement)) {
             parallax_uv = walk_stuv;
         }
     }
 
     // Sample the texture on the parallax space
-    return draw_image(image, parallax_uv);
+    return stexture(image, parallax_uv);
 }
 
 // ------------------------------------------------------------------------------------------------|
 
 void main() {
     vec2 uv = zoom(stuv, 0.95 + 0.05*iZoom, vec2(0.5));
     fragColor = image_parallax(uv, image, depth);
```

## Comparing `DepthFlow/Resources/Shaders/DepthFlowMarch.frag` & `DepthFlow/Resources/Shaders/Deprecated/DepthFlowMarch.frag`

 * *Files 11% similar despite different names*

```diff
@@ -35,19 +35,19 @@
     const float max_step = 0.0006;
     float quality = mix(min_step, max_step, iQuality);
     vec2 parallax = ray.xy;
 
     for (float i=0.0; i<walk+quality; i+=quality) {
         vec3 sample = ray + i*direction;
         sample.xy = gluv2stuv(sample.xy);
-        float depth_height = iParallaxHeight * draw_image(depth, sample.xy).r;
+        float depth_height = iParallaxHeight * stexture(depth, sample.xy).r;
         float walk_height  = 1 - sample.z;
 
         if (walk_height <= depth_height) {
             parallax = sample.xy;
             break;
         }
     }
 
-    fragColor = draw_image(image, parallax);
+    fragColor = stexture(image, parallax);
 }
```

## Comparing `ShaderFlow/Resources/Scenes/Examples/GLSL/Temporal.frag` & `ShaderFlow/Resources/Scenes/Examples/GLSL/MotionBlur.frag`

 * *Files 7% similar despite different names*

```diff
@@ -2,19 +2,19 @@
 // (c) MIT, Tremeschin
 */
 
 void main() {
     vec2 uv = iCamera.stuv;
 
     if (iLayer == 0) {
-        fragColor = draw_image(background, uv);
+        fragColor = stexture(background, uv);
     } else if (iLayer == 1) {
         // Average of the last iTemporal layers
         vec4 color = vec4(0);
         for (int i=0; i<iScreenTemporal; i++) {
             float factor = smoothstep(1.0, 0.0, float(i)/iScreenTemporal);
-            color += texture(iScreenGet(i, 0), astuv) * factor;
+            color += iScreenTexture(i, 0, astuv) * factor;
         }
         fragColor = 2 * color/iScreenTemporal;
     }
     fragColor.a = 1;
 }
```

## Comparing `broken_source-0.2.1.dist-info/METADATA` & `broken_source-0.3.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 Metadata-Version: 2.3
 Name: broken-source
-Version: 0.2.1
+Version: 0.3.0
 Summary: ðŸš€ Broken Source Software Framework and All Projects in One Place
 Project-URL: repository, https://github.com/BrokenSource/BrokenSource
 Project-URL: homepage, https://brokensrc.dev
 Project-URL: documentation, https://brokensrc.dev
 Project-URL: issues, https://brokensrc.dev/contact
 Author-email: Tremeschin <29046864+Tremeschin@users.noreply.github.com>
 License-Expression: AGPL-3.0
-Requires-Python: >=3.10
+Requires-Python: >=3.9
 Requires-Dist: appdirs>=1.4.4
 Requires-Dist: arrow>=1.3.0
 Requires-Dist: attrs>=23.2.0
 Requires-Dist: audioread>=3.0.1
 Requires-Dist: cachetools>=5.3.3
 Requires-Dist: datetime>=5.5
 Requires-Dist: diskcache>=5.6.3
@@ -40,32 +40,32 @@
 Requires-Dist: pyfluidsynth>=1.3.3
 Requires-Dist: pygame>=2.5.2
 Requires-Dist: python-dotenv>=1.0.1
 Requires-Dist: python-rtmidi>=1.5.8
 Requires-Dist: pyturbojpeg>=1.7.3
 Requires-Dist: pyyaml>=6.0.1
 Requires-Dist: requests-cache>=1.2.0
-Requires-Dist: requests>=2.31.0
+Requires-Dist: requests>=2.32.2
 Requires-Dist: rich>=13.7.1
 Requires-Dist: schedule>=1.2.1
-Requires-Dist: scipy>=1.13.0
+Requires-Dist: scipy>=1.13.1
 Requires-Dist: soundcard>=0.4.3
 Requires-Dist: thefuzz>=0.22.1
 Requires-Dist: toml>=0.10.2
 Requires-Dist: tqdm>=4.66.4
 Requires-Dist: typer>=0.12.3
 Requires-Dist: validators>=0.28.1
-Requires-Dist: watchdog>=4.0.0
+Requires-Dist: watchdog>=4.0.1
 Provides-Extra: cpp
 Requires-Dist: meson>=1.4.0; extra == 'cpp'
 Requires-Dist: ninja>=1.11.1.1; extra == 'cpp'
 Provides-Extra: samplerate
 Requires-Dist: samplerate>=0.2.1; extra == 'samplerate'
 Provides-Extra: staging
-Requires-Dist: streamlit>=1.34.0; extra == 'staging'
+Requires-Dist: streamlit>=1.35.0; extra == 'staging'
 Requires-Dist: yt-dlp>=2024.4.9; extra == 'staging'
 Description-Content-Type: text/markdown
 
 <div align="center">
   <a href="https://brokensrc.dev"><img src="https://raw.githubusercontent.com/BrokenSource/BrokenSource/Master/Broken/Resources/Images/Broken.png" width="200"></a>
   <h2>Broken Source Software</h2>
   <br>
```

### html2text {}

```diff
@@ -1,36 +1,36 @@
-Metadata-Version: 2.3 Name: broken-source Version: 0.2.1 Summary: Ã°ÂŸÂšÂ€ Broken
+Metadata-Version: 2.3 Name: broken-source Version: 0.3.0 Summary: Ã°ÂŸÂšÂ€ Broken
 Source Software Framework and All Projects in One Place Project-URL:
 repository, https://github.com/BrokenSource/BrokenSource Project-URL: homepage,
 https://brokensrc.dev Project-URL: documentation, https://brokensrc.dev
 Project-URL: issues, https://brokensrc.dev/contact Author-email: Tremeschin
 <29046864+Tremeschin@users.noreply.github.com> License-Expression: AGPL-3.0
-Requires-Python: >=3.10 Requires-Dist: appdirs>=1.4.4 Requires-Dist:
+Requires-Python: >=3.9 Requires-Dist: appdirs>=1.4.4 Requires-Dist:
 arrow>=1.3.0 Requires-Dist: attrs>=23.2.0 Requires-Dist: audioread>=3.0.1
 Requires-Dist: cachetools>=5.3.3 Requires-Dist: datetime>=5.5 Requires-Dist:
 diskcache>=5.6.3 Requires-Dist: distro>=1.9.0 Requires-Dist: dotmap>=1.3.30
 Requires-Dist: glcontext>=2.5.0 Requires-Dist: glfw>=2.7.0 Requires-Dist:
 imgui>=2.0.0 Requires-Dist: intervaltree>=3.1.0 Requires-Dist: loguru>=0.7.2
 Requires-Dist: midi2audio>=0.1.1 Requires-Dist: mido>=1.3.2 Requires-Dist:
 moderngl-window>=2.4.6 Requires-Dist: moderngl>=5.10.0 Requires-Dist: numpy-
 quaternion>=2023.0.3 Requires-Dist: numpy>=1.26.4 Requires-Dist: opencv-
 contrib-python>=4.9.0.80 Requires-Dist: opensimplex>=0.4.5.1 Requires-Dist:
 pillow>=10.3.0 Requires-Dist: pip>=24.0 Requires-Dist: pretty-errors>=1.2.25
 Requires-Dist: pretty-midi>=0.2.10 Requires-Dist: pydantic>=2.7.1 Requires-
 Dist: pyfiglet>=1.0.2 Requires-Dist: pyfluidsynth>=1.3.3 Requires-Dist:
 pygame>=2.5.2 Requires-Dist: python-dotenv>=1.0.1 Requires-Dist: python-
 rtmidi>=1.5.8 Requires-Dist: pyturbojpeg>=1.7.3 Requires-Dist: pyyaml>=6.0.1
-Requires-Dist: requests-cache>=1.2.0 Requires-Dist: requests>=2.31.0 Requires-
-Dist: rich>=13.7.1 Requires-Dist: schedule>=1.2.1 Requires-Dist: scipy>=1.13.0
+Requires-Dist: requests-cache>=1.2.0 Requires-Dist: requests>=2.32.2 Requires-
+Dist: rich>=13.7.1 Requires-Dist: schedule>=1.2.1 Requires-Dist: scipy>=1.13.1
 Requires-Dist: soundcard>=0.4.3 Requires-Dist: thefuzz>=0.22.1 Requires-Dist:
 toml>=0.10.2 Requires-Dist: tqdm>=4.66.4 Requires-Dist: typer>=0.12.3 Requires-
-Dist: validators>=0.28.1 Requires-Dist: watchdog>=4.0.0 Provides-Extra: cpp
+Dist: validators>=0.28.1 Requires-Dist: watchdog>=4.0.1 Provides-Extra: cpp
 Requires-Dist: meson>=1.4.0; extra == 'cpp' Requires-Dist: ninja>=1.11.1.1;
 extra == 'cpp' Provides-Extra: samplerate Requires-Dist: samplerate>=0.2.1;
-extra == 'samplerate' Provides-Extra: staging Requires-Dist: streamlit>=1.34.0;
+extra == 'samplerate' Provides-Extra: staging Requires-Dist: streamlit>=1.35.0;
 extra == 'staging' Requires-Dist: yt-dlp>=2024.4.9; extra == 'staging'
 Description-Content-Type: text/markdown
   _[_h_t_t_p_s_:_/_/_r_a_w_._g_i_t_h_u_b_u_s_e_r_c_o_n_t_e_n_t_._c_o_m_/_B_r_o_k_e_n_S_o_u_r_c_e_/_B_r_o_k_e_n_S_o_u_r_c_e_/_M_a_s_t_e_r_/_B_r_o_k_e_n_/
                          _R_e_s_o_u_r_c_e_s_/_I_m_a_g_e_s_/_B_r_o_k_e_n_._p_n_g_]
                       ********** BBrrookkeenn SSoouurrccee SSooffttwwaarree **********
 
     Here lies BBrrookkeenn: The SShhaarreedd LLiibbrraarryy and MMaannaaggeerr + SSuubbmmoodduulleess of all my
```

## Comparing `broken_source-0.2.1.dist-info/RECORD` & `broken_source-0.3.0.dist-info/RECORD`

 * *Files 5% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-Broken/Types.py,sha256=iOmSBAm5_-lpim5TkCsNAkLwO4WSCg4E-RmehIpiyV8,1040
-Broken/__init__.py,sha256=TWh2Onfkkw93mcLTBr3bP38eKzqrkWYheVi8WHth0ks,4020
-Broken/__main__.py,sha256=kg04NdJSt6tZHvB5xm7EFW9PMSvFT_fug7_etJboWro,22411
-Broken/Core/BrokenEnum.py,sha256=b-ZT2h2qpudgTpRI82ST4QjJw3jzXruZPY_Ntr9r5LM,11807
+Broken/Types.py,sha256=pw2WvbRe48gAADqSbOFMNHIHF0NwQnllN8m2fL8o-wA,1146
+Broken/__init__.py,sha256=jfLDQ-LpHgK6flXYYws7HJh0RWE6CWvplalu213FRyY,4267
+Broken/__main__.py,sha256=hVOTjkHO8RawhqFN_lukGAloVS7XDs7qDlMKcwxqV2k,22547
+Broken/Core/BrokenEnum.py,sha256=ckq8voxf-D2D_KrffRYBwowFUyDmSwQMETbIXtd72k0,16073
 Broken/Core/BrokenLogging.py,sha256=ux-yuPvxUQC1Z5RBlNzfH_w4DlnKJQtK2d2Qy6HAnZ0,2586
-Broken/Core/BrokenPath.py,sha256=fB2TqlW_TIWGfHQwld5YAVxJjRoI_EPOgR9ny1rjxHo,18629
+Broken/Core/BrokenPath.py,sha256=HWaGmXyIt5mGfFLy_U9MUwLQWyPPJ9cTo_cfCS7XlDo,19509
 Broken/Core/BrokenPlatform.py,sha256=cUHhJpzpOcAxikWhbJVvMIOeAlYiY7tvNBS1qicOp00,4011
-Broken/Core/BrokenProfiler.py,sha256=pkjB98aI6PCzI-XdOwSRTJvMfhEPS179WsVQ1NBVwL4,1741
-Broken/Core/BrokenProject.py,sha256=Lg4X58FmdHtUxoHGftRi4seTEYezmeLMvZSl3Tcz4_8,12963
-Broken/Core/BrokenResolution.py,sha256=L0_nt5tgMYEXxJ8bJhOac5lndCPgNQO38mBdnVB8AOY,3364
-Broken/Core/BrokenScheduler.py,sha256=3vP7Xc1XxeRhVvDbqE9wPM9i4M0oboBW5ho4wKGTbOA,7259
-Broken/Core/BrokenSpinner.py,sha256=J9bX0PBQ_myn55h8a_TNnCYz97AbQ3h43XU_cdDS7Z4,2221
+Broken/Core/BrokenProfiler.py,sha256=mr8cpbxwvY47yoxD67yGd6vd-v3snWRr624IrNPBofs,1665
+Broken/Core/BrokenProject.py,sha256=XbWKfKS1QZrIL1qyYPUYEetN7dW7-wFMAWrwQnpXeFs,13333
+Broken/Core/BrokenResolution.py,sha256=xcULpQVI2tE1AEP3y8VnoHOXcluglpZoJcdhZgeUzSY,6313
+Broken/Core/BrokenScheduler.py,sha256=FlixvYJMfAs62756DxrEo8xO5ll6RBwg1MiIuwQUOUw,7313
+Broken/Core/BrokenSpinner.py,sha256=YXkzJ4viSA0DrgvuwiQU8WYsa7nB1NZj5nCY6WHAOek,2220
 Broken/Core/BrokenThread.py,sha256=AhSMix25ykZ7pLg8n5rczYwq1PleOqfrj4BIlrHGG2o,3783
 Broken/Core/BrokenTorch.py,sha256=CrkFA9uFBrdso2I6iXK2s-QO7GMU5VF536fF3VOsXgY,2475
-Broken/Core/BrokenTyper.py,sha256=7eiu_ZKKe_q2HQ7gml2zBSbneA7h6VeiQ2b_Jn2-G3M,3741
-Broken/Core/BrokenUtils.py,sha256=RYckFtQ47KG66oJEmFwOgFwetmH3mvT36fvU3Ru_zzg,4348
-Broken/Core/__init__.py,sha256=RVeebkreqe53-jRQQjvrbhjiA-L16-5iYaEoP0vR0yg,9571
-Broken/Core/Staging/BrokenDotmap.py,sha256=GtSoGtbiHyCb_d__5R2rwsMKyd9FHesVNPVVq_xr6Ac,8147
+Broken/Core/BrokenTyper.py,sha256=ykPnSMoRFWgyxX4fqEDC3_J0ISsX3SBKiQoBTK8kqIo,3460
+Broken/Core/BrokenUtils.py,sha256=qQHkYq3D8mZI7Xx8FoUkVaz2mQVp1VEipTQZIMUSwpg,4612
+Broken/Core/__init__.py,sha256=BCy9N1_kaWD7U-wGhgLRSmvl__R8DGFAiyNUUaPLLZs,11194
+Broken/Core/Staging/BrokenDotmap.py,sha256=g1TzFD4oaJsInXJIcH6w2d-68dwLZbfzW259i6Ioprg,8081
 Broken/Core/Staging/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 Broken/Core/Staging/umidi.py,sha256=mKi37fOFNWE4yNQWL9Hv6H_eob8cphZKq3dGhbCUV08,18413
 Broken/Core/Staging/Dotmap/BaseLoader.py,sha256=omvfs7KqJKswYiY-HVFFLF6XlXU2hjDIHQCvubCP43k,1736
 Broken/Core/Staging/Dotmap/BrokenDotmap.py,sha256=PDYmq1qojJMc71Y7Gf8LPlPTN4ZOqIuAW88vd-piDJQ,12082
 Broken/Core/Staging/Dotmap/Readme.md,sha256=vnlwmb2qAeivLvsh3weieTyf4HgGbUoGxmeQgPLGkLc,368
 Broken/Core/Staging/Dotmap/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 Broken/Core/Staging/Dotmap/__test__.py,sha256=Hg-kTzP8AvGt_mCg241Uz5cbOtXnTebuLb7cl594U5Y,3568
@@ -36,82 +36,80 @@
 Broken/Loaders/LoaderString.py,sha256=tGvHBrrAHBT8rIWfpoSeOp50Qew_ODFH6xBgVM93wiE,856
 Broken/Loaders/__init__.py,sha256=v8l8a4dNmWISNPTXaTIgrzGtmoFsxSNe5RnlAOhAmZ0,546
 Broken/Resources/Fonts/DejaVu License.txt,sha256=ow8kZqlc0erv9gQWkvQ0ae3MoFLQAuh3AVqBnG4xwZQ,4765
 Broken/Resources/Fonts/DejaVuSans.ttf,sha256=faGVp0xVvvmI0NSPlQi9XYSUJcF3Dbpde_xs6e2EiVQ,757076
 Broken/Resources/Images/Broken.ico,sha256=Geb0VBYO_QIKhbWCqiG58LYo_6mVa1Yq-XjPI8NodL8,8764
 Broken/Resources/Images/Broken.png,sha256=9zBkD7_ZiWnTXXFXLqmIpnS0qfb_5C3dh-3PZ2Kn4uQ,15418
 Broken/Resources/Images/Broken.svg,sha256=dxfZZVKPutJOriOfGtjnaF8mCQkGu8K1oHM1zF-8DDE,1444
-Broken/Tests/Enum.py,sha256=4QRl4FckF-eUGueY25uH_8vumX_ifyB6_pMhmUV8Qcc,3804
 Broken/Vectron/__init__.py,sha256=9uaHmCgKSry93BVoitAcSEsumiRYizJZ-uejQP4ByrM,76
-DepthFlow/DepthFlow.py,sha256=KN_1Yc6Z07PZY7fgID83bRByQNCFHspqpAr084h9_SM,7851
-DepthFlow/__init__.py,sha256=mj1BTYiVIBMSfoWDRNnwURevgS8FVHFMLbomSw34ekE,324
-DepthFlow/__main__.py,sha256=WaRiKNdBcyVZnTo2lFQVp-GbSoFMatRXt_CCfvpoHCU,317
+DepthFlow/CustomScene.py,sha256=V1RL94P-oIh0dFaZG5zh8IJ1agHn1rQzWVP6LSxt6cE,528
+DepthFlow/DepthFlow.py,sha256=Kp8bnGBod8WGuMmpM4avZk6-ErhBmyd290lYJWsaWrU,8874
+DepthFlow/__init__.py,sha256=7g7LGWNp4-ACZ3c8CrqHDjDKRRxpD2hbAGtAccUiCr8,387
+DepthFlow/__main__.py,sha256=t87VucsGle9cmQM8iPOsdNVSwUvlU2RD37a7yF9mwWk,257
 DepthFlow/Resources/Images/DepthFlow.png,sha256=oUlRG-luFGw_D4vEEK4YX_fyNlJVoosIp3fYTXRUld8,14623
 DepthFlow/Resources/Images/DepthFlow.svg,sha256=PJ4PG-Bg9guS_kCOrmWrjPAF4R7i9WG26zJIIjT4rmc,1445
-DepthFlow/Resources/Shaders/DepthFlow.frag,sha256=88ViFDfKsOiOi8NPpCUMQyrXgEspqT6anWjAXZw6x9k,2477
-DepthFlow/Resources/Shaders/DepthFlow2D.frag,sha256=2bbH0HQQjkidtB2d2_szqktFMQ_cSsXErzj03RiCOyw,2499
-DepthFlow/Resources/Shaders/DepthFlowMarch.frag,sha256=ynyTiNw9tyUqXijUfg-xtKKsN1Cyia8HEYJEGmohvh4,1688
-Pianola/Pianola.py,sha256=m8U8ATscFBVj3ugWHVU0gs-25li9DXWxM8yVLxIe2NA,2999
+DepthFlow/Resources/Shaders/DepthFlow.frag,sha256=JvlYRhRMqIr7sMCIAAvu2tBY_EBQK61AIPtHBoIrk1I,2803
+DepthFlow/Resources/Shaders/Deprecated/DepthFlow2D.frag,sha256=6W9ELs4wIw_d6XABYtF5-S_EpKa6zkX22KHilJ0Vk4E,2495
+DepthFlow/Resources/Shaders/Deprecated/DepthFlowMarch.frag,sha256=-J9YwO8JsC3dO0MyEcWMgrUz0ySbolU3lzwXZwgupwg,1684
+Pianola/Pianola.py,sha256=i2ZwswqTjNYpoEMkZmD4Jk4BGUthe6RLpvKLN7_qZ7A,3399
 Pianola/__init__.py,sha256=TMR-5n6kjD_cR-Wf774y74SFr9bWM9WRyG1qtgJUncU,280
-Pianola/__main__.py,sha256=9V9BhWRoMyz879A1984JDGKR0XcjR2LDnpdnF3hs5X4,297
+Pianola/__main__.py,sha256=7Oo2fvHyiItR2clbrYbBqUaCaAWCgwZh6n_MKAe1Imw,243
 Pianola/Resources/Images/Pianola.png,sha256=8gOx3TNtazAUt4tbm0bs5NAf32KzMBBZpZJ-P6Q0SiE,12579
 Pianola/Resources/Images/Pianola.svg,sha256=JRXhOtJMihRQdALQtm1b-i7HLsnwryFHZxKHll1zxOk,3038
-Pianola/Resources/Midis/Hopeless Sparkle.mid,sha256=LIVjUHMXzl_8vKH2cIUbpMsYbxntvY7IdYLosYNiQNQ,27430
-Pianola/Resources/Shaders/Pianola.frag,sha256=9aoTG2z5r21v8jrmIjooF84laqP-jVGmTKM8tGskfwE,8171
+Pianola/Resources/Shaders/Pianola.frag,sha256=KuAbnLtpeAZ0nWHm6WXj0ZU_7IR8iDKqz0jsD_gszqE,8189
 ShaderFlow/Imgui.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ShaderFlow/Message.py,sha256=_Z2ixBbyo0kqBL22pArnHOaSd7MYzsW_SXBlG6XjmuU,2568
-ShaderFlow/Module.py,sha256=K2KXnya9NF7-aPTln1tlzyvt1ulZiqQ_8ypdtQ5h228,3215
+ShaderFlow/Module.py,sha256=CnqikROMgcPeGtDjh4gVG9dXbZDbukjFTwMV6KMmkuY,2979
 ShaderFlow/Notes.py,sha256=wFm9qJbQDfnp_HwJo_-ntk9O4WeADCF6b36MTl7tNqQ,3855
-ShaderFlow/Scene.py,sha256=QAxRUR4aurckD78h72Tv2_Cw4KYwsg3Yc2ihx-DA9gw,39206
-ShaderFlow/Shader.py,sha256=1Z8HwRvKZCqmeLa4YhHIE_h0XP-zlj7S7qjU0GBWq3g,13833
-ShaderFlow/Texture.py,sha256=zNtQo9BBVQy-0Ypa1lpHGyMH_4sRyOYyC84qft1t5QU,15278
+ShaderFlow/Scene.py,sha256=ytJgm0jb4qoAA5RCX4z9x3mGmSGnPyJKP9d4p-PEFwI,45131
+ShaderFlow/Shader.py,sha256=vfNXMPVVyCev75V8UQcb56jd9TzBjo_6VUkH9BfwI6A,13816
+ShaderFlow/Texture.py,sha256=65kLZ54G9NuWssi4wDqiRIUF59D2yVk88-ZtrIX8A08,15876
 ShaderFlow/Variable.py,sha256=Q6JFGMMusiUN6ysF23oRqq0Hl7j_r6XRCBe-mkFjZik,4187
 ShaderFlow/__init__.py,sha256=kAz0EgJUkDTstsNM6ZNhHpg2AJ5suEb_tBQxIlOTTv0,349
-ShaderFlow/__main__.py,sha256=cgYNA2gUJcj4DGEuFNEL8VigpZkvMtyDpjU9fQVYVwk,3269
+ShaderFlow/__main__.py,sha256=ptWGokBjML5N5AOZAiNDs1W00jmPeXfokn4BzBo2xBM,3216
 ShaderFlow/Modules/Audio.py,sha256=hLQu6x2u7B7kzpWu_nt7aTs3_-Mvc-z9KrTgLkNkOcU,12816
-ShaderFlow/Modules/Bouncing.py,sha256=T57agYc9JzTQaljOo9z3ZBECXxyN5zPJl4C-fT0CE9A,3160
-ShaderFlow/Modules/Camera.py,sha256=BGJHtmZrobjdGh1DNF_e3PjXo3X9XNiAP9BkumZEApk,17597
-ShaderFlow/Modules/Dynamics.py,sha256=RW9kdLkgVIsomjTo85mCd-4XGUtmF_0v2oj5t3pe0Vo,8763
+ShaderFlow/Modules/Bouncing.py,sha256=-2Zmq2xaGWuPtp8QaoYRWoLcrlkbnzqMLDTRenthuw0,3144
+ShaderFlow/Modules/Camera.py,sha256=05dDTKR6uHN9N2EWG8i19k2iCtnBcnAhxnRHrUmPDao,17526
+ShaderFlow/Modules/Dynamics.py,sha256=Xh9_agUYQbXNvpgfhMSFMs_C8JuRKt1x-hQqgYyG9i8,9121
 ShaderFlow/Modules/Frametimer.py,sha256=9fsVLPoV90v6cXeyv5wszxv9v4_lLSUazCMhCPgIv_w,2332
-ShaderFlow/Modules/Keyboard.py,sha256=uSq0WKVcZA3gNklF9vdtnKa1ZQWH92MA533cXSNvoLU,1494
-ShaderFlow/Modules/Noise.py,sha256=MDUHEA4kS-5iUCHaKgdyDXRnRBqplIBSUVNMuGEYlvY,2475
-ShaderFlow/Modules/Piano.py,sha256=SQP5LiwNwQo2QbLW0c94q-rFdBlcLaU-p4PkzcpF0qA,14040
-ShaderFlow/Modules/Spectrogram.py,sha256=4GDDSK9jY-J-1CI2ddDQMYiOKOhXuNYIf8RSB-Xa2Fc,11396
-ShaderFlow/Modules/Video.py,sha256=GLupGgbp5AigsD640sx0IBMURFr4FeLmCV4BJ5Vmlck,7203
-ShaderFlow/Modules/Waveform.py,sha256=ND7q53uDX8mILSlnm4wR9f5pCIWv0loCdVCKbinAXPI,3088
+ShaderFlow/Modules/Keyboard.py,sha256=adnuf_gcdrK_9WxjH5w9sKOEPQQaOIORJtkDTW1wBWw,1473
+ShaderFlow/Modules/Noise.py,sha256=4OAKYa608O2tHRAx26ppB3ZH9g1zn3zOcRo5RM-MYTs,2459
+ShaderFlow/Modules/Piano.py,sha256=SVjKrmBlora6Tvajb8cJji1yYhGR04qms8Y4WaOcDIY,14761
+ShaderFlow/Modules/Spectrogram.py,sha256=9PsGmx80kCbat-A6PRErIlL3VipL9LOwf1XZh41hHeY,11360
+ShaderFlow/Modules/Video.py,sha256=XWJZtD3B4B2npebSzZ1DPxWkLhhg7fjdvGQEw5W0Hys,7209
+ShaderFlow/Modules/Waveform.py,sha256=nGMi25b9Nh4s2A22kkNfLPHFviA5Byx-amgwtlwTovo,3094
 ShaderFlow/Modules/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-ShaderFlow/Optional/Monocular.py,sha256=Ks8k6DCFxwZLQ1em8wG7aUuOULdVZl4qmr7qX-wmD8E,3503
+ShaderFlow/Optional/Monocular.py,sha256=3MBOC4RSPg085TNasAWe8gtuydqq-A5J3n374k8XYns,3703
 ShaderFlow/Optional/OpticalFlow.py,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
 ShaderFlow/Optional/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-ShaderFlow/Resources/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 ShaderFlow/Resources/Images/ShaderFlow.png,sha256=Z7DL7FqIiwG6o6U3inHe1QmipsRkcmnjXNPxM5-xlWs,20132
 ShaderFlow/Resources/Images/ShaderFlow.svg,sha256=5SlxYmSOAODpXpClTSI2DceG8gbmfKViU1EX2scIbDE,1448
-ShaderFlow/Resources/Scenes/Examples/Demo.py,sha256=SW7NgQ1nyF38pj2lNFO-K0Zoi1F1JiJjE7IXIQjA_eg,10171
+ShaderFlow/Resources/Scenes/Examples/Demo.py,sha256=HvFTX0dI74-An7mWTrODi0osV4OlE_xp_bRTsKNqYuA,10658
 ShaderFlow/Resources/Scenes/Examples/GLSL/Bars.frag,sha256=5clkqgKlg4Hhp4UqAVu2_XrpJz01LWbbcjR83546ylc,495
 ShaderFlow/Resources/Scenes/Examples/GLSL/Bouncing.frag,sha256=sV7saaaHtHTjkpdAsoOLFseXQfzdTPYvQ0XyjXyBOF0,1285
-ShaderFlow/Resources/Scenes/Examples/GLSL/Multipass.frag,sha256=OxXZ0ILKUPtIbNOaaHsOjHvRNGtqm5Bk7GZ8wRbCKkk,1278
+ShaderFlow/Resources/Scenes/Examples/GLSL/MotionBlur.frag,sha256=uNGDVKqbq3Mu24sgh7HniiR1kt-AKqj5ozUb8KXoQlA,518
+ShaderFlow/Resources/Scenes/Examples/GLSL/Multipass.frag,sha256=IHRTGzAfR4sJvJzZSAoTaod06E6NHgChwCEu7iG_TXg,1276
 ShaderFlow/Resources/Scenes/Examples/GLSL/RayMarch.frag,sha256=q42osayKA9xMRHfUkWVJkIiNNT3hLlVdt1tT6B3a4Y8,1380
 ShaderFlow/Resources/Scenes/Examples/GLSL/ShaderToy.frag,sha256=C18Z5sAe5kC-KxDWRZ8sA1KQVf8qU0k-ibCZUkty_8A,2399
-ShaderFlow/Resources/Scenes/Examples/GLSL/Temporal.frag,sha256=8OKokh9ASiEhHQguqTRL6vye3Nx33LwGvc_HQqAQA6k,525
-ShaderFlow/Resources/Scenes/Examples/GLSL/Video.frag,sha256=Lc6iAW8I9qA7C_SB4V4dI1oI9-knVfKN4lzss_TKKoM,115
-ShaderFlow/Resources/Scenes/Examples/GLSL/Visualizer.frag,sha256=Q8OQyKsaaTvDH00VCfOIAgr_XQmB0iijJOVHmjL2S04,1654
+ShaderFlow/Resources/Scenes/Examples/GLSL/Video.frag,sha256=jXC73Crh8z5UbF9WzX3T_kYV2aQMx8TpzbK8_75sg80,113
+ShaderFlow/Resources/Scenes/Examples/GLSL/Visualizer.frag,sha256=SHfhjAAKudO-ThytJkJOd6LIg6sfHyCCNyAbSEQuCCQ,1639
 ShaderFlow/Resources/Scenes/Examples/GLSL/Waveform.frag,sha256=uvF0F9D4OKN92SGrU42rhGdnpEOUi5MWgqjx2ODK4SY,341
-ShaderFlow/Resources/Scenes/Examples/GLSL/Life/Simulation.glsl,sha256=J0Ep0A-xLq551sd2hYM7Xff2dXfjvEjgJ2OkRAReu1g,1030
-ShaderFlow/Resources/Scenes/Examples/GLSL/Life/Visuals.glsl,sha256=AO4KwxUSPalAOetlgoP2JlkGPSw17RPX2F6otfgKiR0,985
+ShaderFlow/Resources/Scenes/Examples/GLSL/Life/Simulation.glsl,sha256=SiH4jPA4FBSRWWEUJyEnVdRNEweWh7SwWBZPyJ_-OaY,1032
+ShaderFlow/Resources/Scenes/Examples/GLSL/Life/Visuals.glsl,sha256=jPjqq5gc7bIJ8QbP5mZBLkLGYf85Jfd81p9h2JiP_2Y,975
 ShaderFlow/Resources/Shaders/Fragment/Default.glsl,sha256=syBoZdAkdvRF2_3GkEb3iwW-OseAYFzYhBxs-kx_ifo,1618
 ShaderFlow/Resources/Shaders/Fragment/Final.glsl,sha256=nM-L5WSYKRoU1kz1UZBYegGlzPxLoFWeY_eHZW2sQno,79
 ShaderFlow/Resources/Shaders/Fragment/Loading.frag,sha256=gIGMnh611vEJsOpB-DmjBI9EW6_4clkghbZVqB1czDA,895
 ShaderFlow/Resources/Shaders/Fragment/Missing.glsl,sha256=NEiuErlE1z0CE2r6WGS_rn6k7Wd4q9qnCoq7E1wBGfs,574
-ShaderFlow/Resources/Shaders/Include/Camera.glsl,sha256=NOQGK6LidzDO7oUKCnRrssfIECwwAItEaRz-SFmJ66w,5079
+ShaderFlow/Resources/Shaders/Include/Camera.glsl,sha256=CBU0ddZ9SEpxFLBIKPWrXJ0ficwtF3f5JfeMfdasB6M,5356
 ShaderFlow/Resources/Shaders/Include/Complex.glsl,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-ShaderFlow/Resources/Shaders/Include/ShaderFlow.glsl,sha256=NSWqZ875seP929VOwMxpCn8OUieYxFp0wwOmVKr6LdE,11762
+ShaderFlow/Resources/Shaders/Include/ShaderFlow.glsl,sha256=YGyHzPsXGw8M9jfoHirlgqz8iBxeyRA8L0xc7UwOJek,12163
 ShaderFlow/Resources/Shaders/Vertex/Default.glsl,sha256=mptLPRKopeWq7ybJL5kV4xT_yL3hMeUAxe2LsJYX4gA,538
-SpectroNote/SpectroNote.py,sha256=uEONCPrSBfZFucolvNM5K3mYPRzgu0hEfXtaPQSzIdg,1967
+SpectroNote/SpectroNote.py,sha256=jnb-8cIvn-ryN1cytDZDaXtpSyQ3kKucL82En-zAMHI,1966
 SpectroNote/__init__.py,sha256=FzjJdWJPcbcDlu8oT4LYJa41Q0TK1RC6qlMdKEvkHXU,282
-SpectroNote/__main__.py,sha256=PlbxnFkEiUIS-h1LjO4Am3rX1wMcCn2ashl_diQ7vgk,337
+SpectroNote/__main__.py,sha256=7ySDRQ1I-EnGfseXvFXkFvFS-zZkqCS4AUGM3pqqwKg,271
 SpectroNote/Resources/Images/SpectroNote.png,sha256=Z7DL7FqIiwG6o6U3inHe1QmipsRkcmnjXNPxM5-xlWs,20132
 SpectroNote/Resources/Images/SpectroNote.svg,sha256=5SlxYmSOAODpXpClTSI2DceG8gbmfKViU1EX2scIbDE,1448
 SpectroNote/Resources/Shaders/SpectroNote.frag,sha256=AVEvro1zKx9E-4vFG6rUmxTY0PGYhaRHAexZDHAmLhY,3087
-broken_source-0.2.1.dist-info/METADATA,sha256=A8h46dAnW7D3xjZPcGIwaDELRcaoSmpunoCxcd9lz_8,3415
-broken_source-0.2.1.dist-info/WHEEL,sha256=zEMcRr9Kr03x1ozGwg5v9NQBKn3kndp6LSoSlVg-jhU,87
-broken_source-0.2.1.dist-info/entry_points.txt,sha256=sliTXdLGMPAHvny75SJgCoSIb556KPPyvqTew_2EI98,194
-broken_source-0.2.1.dist-info/RECORD,,
+broken_source-0.3.0.dist-info/METADATA,sha256=DStVLrQUYFZI81xMD_Cr_WY0WbFk-yGfW2T2GNhqgVQ,3414
+broken_source-0.3.0.dist-info/WHEEL,sha256=zEMcRr9Kr03x1ozGwg5v9NQBKn3kndp6LSoSlVg-jhU,87
+broken_source-0.3.0.dist-info/entry_points.txt,sha256=sliTXdLGMPAHvny75SJgCoSIb556KPPyvqTew_2EI98,194
+broken_source-0.3.0.dist-info/RECORD,,
```

