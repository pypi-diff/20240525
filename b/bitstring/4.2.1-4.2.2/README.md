# Comparing `tmp/bitstring-4.2.1.tar.gz` & `tmp/bitstring-4.2.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "bitstring-4.2.1.tar", last modified: Wed Apr 24 19:48:51 2024, max compression
+gzip compressed data, was "bitstring-4.2.2.tar", last modified: Fri May 10 19:40:40 2024, max compression
```

## Comparing `bitstring-4.2.1.tar` & `bitstring-4.2.2.tar`

### file list

```diff
@@ -1,47 +1,47 @@
-drwxr-xr-x   0 scott     (1000) scott     (1000)        0 2024-04-24 19:48:51.607929 bitstring-4.2.1/
--rw-r--r--   0 scott     (1000) scott     (1000)     1127 2024-04-24 19:43:26.000000 bitstring-4.2.1/LICENSE
--rw-r--r--   0 scott     (1000) scott     (1000)      182 2024-04-24 19:43:26.000000 bitstring-4.2.1/MANIFEST.in
--rw-r--r--   0 scott     (1000) scott     (1000)     5847 2024-04-24 19:48:51.607929 bitstring-4.2.1/PKG-INFO
--rw-r--r--   0 scott     (1000) scott     (1000)     4914 2024-04-24 19:43:26.000000 bitstring-4.2.1/README.md
-drwxr-xr-x   0 scott     (1000) scott     (1000)        0 2024-04-24 19:48:51.607929 bitstring-4.2.1/bitstring/
--rw-r--r--   0 scott     (1000) scott     (1000)    14290 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/__init__.py
--rw-r--r--   0 scott     (1000) scott     (1000)     1706 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/__main__.py
--rw-r--r--   0 scott     (1000) scott     (1000)    36635 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/array_.py
--rw-r--r--   0 scott     (1000) scott     (1000)    22862 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/bitarray_.py
--rw-r--r--   0 scott     (1000) scott     (1000)    78616 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/bits.py
--rw-r--r--   0 scott     (1000) scott     (1000)     9745 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/bitstore.py
--rw-r--r--   0 scott     (1000) scott     (1000)     9328 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/bitstore_helpers.py
--rw-r--r--   0 scott     (1000) scott     (1000)    29729 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/bitstream.py
--rw-r--r--   0 scott     (1000) scott     (1000)     3651 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/bitstring_options.py
--rw-r--r--   0 scott     (1000) scott     (1000)    16912 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/dtypes.py
--rw-r--r--   0 scott     (1000) scott     (1000)      578 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/exceptions.py
--rw-r--r--   0 scott     (1000) scott     (1000)     3865 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/fp8.py
--rw-r--r--   0 scott     (1000) scott     (1000)    27588 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/luts.py
--rw-r--r--   0 scott     (1000) scott     (1000)     4446 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/methods.py
--rw-r--r--   0 scott     (1000) scott     (1000)     9061 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/mxfp.py
--rw-r--r--   0 scott     (1000) scott     (1000)        0 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/py.typed
--rw-r--r--   0 scott     (1000) scott     (1000)     9456 2024-04-24 19:43:26.000000 bitstring-4.2.1/bitstring/utils.py
-drwxr-xr-x   0 scott     (1000) scott     (1000)        0 2024-04-24 19:48:51.607929 bitstring-4.2.1/bitstring.egg-info/
--rw-r--r--   0 scott     (1000) scott     (1000)     5847 2024-04-24 19:48:51.000000 bitstring-4.2.1/bitstring.egg-info/PKG-INFO
--rw-r--r--   0 scott     (1000) scott     (1000)      894 2024-04-24 19:48:51.000000 bitstring-4.2.1/bitstring.egg-info/SOURCES.txt
--rw-r--r--   0 scott     (1000) scott     (1000)        1 2024-04-24 19:48:51.000000 bitstring-4.2.1/bitstring.egg-info/dependency_links.txt
--rw-r--r--   0 scott     (1000) scott     (1000)       23 2024-04-24 19:48:51.000000 bitstring-4.2.1/bitstring.egg-info/requires.txt
--rw-r--r--   0 scott     (1000) scott     (1000)       10 2024-04-24 19:48:51.000000 bitstring-4.2.1/bitstring.egg-info/top_level.txt
--rw-r--r--   0 scott     (1000) scott     (1000)     1192 2024-04-24 19:43:26.000000 bitstring-4.2.1/pyproject.toml
--rw-r--r--   0 scott     (1000) scott     (1000)    69844 2024-04-24 19:48:22.000000 bitstring-4.2.1/release_notes.txt
--rw-r--r--   0 scott     (1000) scott     (1000)       38 2024-04-24 19:48:51.607929 bitstring-4.2.1/setup.cfg
-drwxr-xr-x   0 scott     (1000) scott     (1000)        0 2024-04-24 19:48:51.607929 bitstring-4.2.1/tests/
--rw-r--r--   0 scott     (1000) scott     (1000)        0 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/__init__.py
--rw-r--r--   0 scott     (1000) scott     (1000)        8 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/smalltestfile
--rw-r--r--   0 scott     (1000) scott     (1000)   125300 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test.m1v
--rw-r--r--   0 scott     (1000) scott     (1000)    29098 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_array.py
--rw-r--r--   0 scott     (1000) scott     (1000)    28435 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_bitarray.py
--rw-r--r--   0 scott     (1000) scott     (1000)    30568 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_bits.py
--rw-r--r--   0 scott     (1000) scott     (1000)     2974 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_bitstore.py
--rw-r--r--   0 scott     (1000) scott     (1000)   136365 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_bitstream.py
--rw-r--r--   0 scott     (1000) scott     (1000)     6751 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_bitstring.py
--rw-r--r--   0 scott     (1000) scott     (1000)     7555 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_constbitstream.py
--rw-r--r--   0 scott     (1000) scott     (1000)     3748 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_dtypes.py
--rw-r--r--   0 scott     (1000) scott     (1000)    14031 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_fp8.py
--rw-r--r--   0 scott     (1000) scott     (1000)    14497 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_mxfp.py
--rw-r--r--   0 scott     (1000) scott     (1000)      263 2024-04-24 19:43:26.000000 bitstring-4.2.1/tests/test_scaled_dtypes.py
+drwxr-xr-x   0 scottg     (503) staff       (20)        0 2024-05-10 19:40:40.163642 bitstring-4.2.2/
+-rw-r--r--   0 scottg     (503) staff       (20)     1106 2024-05-10 19:39:47.000000 bitstring-4.2.2/LICENSE
+-rw-r--r--   0 scottg     (503) staff       (20)      174 2024-05-10 19:39:47.000000 bitstring-4.2.2/MANIFEST.in
+-rw-r--r--   0 scottg     (503) staff       (20)     5845 2024-05-10 19:40:40.163417 bitstring-4.2.2/PKG-INFO
+-rw-r--r--   0 scottg     (503) staff       (20)     4789 2024-05-10 19:39:47.000000 bitstring-4.2.2/README.md
+drwxr-xr-x   0 scottg     (503) staff       (20)        0 2024-05-10 19:40:40.157236 bitstring-4.2.2/bitstring/
+-rw-r--r--   0 scottg     (503) staff       (20)    13972 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/__init__.py
+-rw-r--r--   0 scottg     (503) staff       (20)     1657 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/__main__.py
+-rw-r--r--   0 scottg     (503) staff       (20)    35860 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/array_.py
+-rw-r--r--   0 scottg     (503) staff       (20)    22285 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/bitarray_.py
+-rw-r--r--   0 scottg     (503) staff       (20)    76821 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/bits.py
+-rw-r--r--   0 scottg     (503) staff       (20)    10326 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/bitstore.py
+-rw-r--r--   0 scottg     (503) staff       (20)     9068 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/bitstore_helpers.py
+-rw-r--r--   0 scottg     (503) staff       (20)    29016 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/bitstream.py
+-rw-r--r--   0 scottg     (503) staff       (20)     3558 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/bitstring_options.py
+-rw-r--r--   0 scottg     (503) staff       (20)    16892 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/dtypes.py
+-rw-r--r--   0 scottg     (503) staff       (20)      554 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/exceptions.py
+-rw-r--r--   0 scottg     (503) staff       (20)     3768 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/fp8.py
+-rw-r--r--   0 scottg     (503) staff       (20)    27340 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/luts.py
+-rw-r--r--   0 scottg     (503) staff       (20)     4351 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/methods.py
+-rw-r--r--   0 scottg     (503) staff       (20)     8861 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/mxfp.py
+-rw-r--r--   0 scottg     (503) staff       (20)        0 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/py.typed
+-rw-r--r--   0 scottg     (503) staff       (20)     9223 2024-05-10 19:39:47.000000 bitstring-4.2.2/bitstring/utils.py
+drwxr-xr-x   0 scottg     (503) staff       (20)        0 2024-05-10 19:40:40.163145 bitstring-4.2.2/bitstring.egg-info/
+-rw-r--r--   0 scottg     (503) staff       (20)     5845 2024-05-10 19:40:40.000000 bitstring-4.2.2/bitstring.egg-info/PKG-INFO
+-rw-r--r--   0 scottg     (503) staff       (20)      894 2024-05-10 19:40:40.000000 bitstring-4.2.2/bitstring.egg-info/SOURCES.txt
+-rw-r--r--   0 scottg     (503) staff       (20)        1 2024-05-10 19:40:40.000000 bitstring-4.2.2/bitstring.egg-info/dependency_links.txt
+-rw-r--r--   0 scottg     (503) staff       (20)       23 2024-05-10 19:40:40.000000 bitstring-4.2.2/bitstring.egg-info/requires.txt
+-rw-r--r--   0 scottg     (503) staff       (20)       10 2024-05-10 19:40:40.000000 bitstring-4.2.2/bitstring.egg-info/top_level.txt
+-rw-r--r--   0 scottg     (503) staff       (20)     1155 2024-05-10 19:39:47.000000 bitstring-4.2.2/pyproject.toml
+-rw-r--r--   0 scottg     (503) staff       (20)    68386 2024-05-10 19:39:47.000000 bitstring-4.2.2/release_notes.txt
+-rw-r--r--   0 scottg     (503) staff       (20)       38 2024-05-10 19:40:40.163691 bitstring-4.2.2/setup.cfg
+drwxr-xr-x   0 scottg     (503) staff       (20)        0 2024-05-10 19:40:40.162300 bitstring-4.2.2/tests/
+-rw-r--r--   0 scottg     (503) staff       (20)        0 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/__init__.py
+-rw-r--r--   0 scottg     (503) staff       (20)        8 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/smalltestfile
+-rw-r--r--   0 scottg     (503) staff       (20)   125300 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test.m1v
+-rw-r--r--   0 scottg     (503) staff       (20)    28170 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_array.py
+-rw-r--r--   0 scottg     (503) staff       (20)    27444 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_bitarray.py
+-rw-r--r--   0 scottg     (503) staff       (20)    29587 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_bits.py
+-rw-r--r--   0 scottg     (503) staff       (20)     2880 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_bitstore.py
+-rw-r--r--   0 scottg     (503) staff       (20)   132609 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_bitstream.py
+-rw-r--r--   0 scottg     (503) staff       (20)     6551 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_bitstring.py
+-rw-r--r--   0 scottg     (503) staff       (20)     7499 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_constbitstream.py
+-rw-r--r--   0 scottg     (503) staff       (20)     4181 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_dtypes.py
+-rw-r--r--   0 scottg     (503) staff       (20)    15151 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_fp8.py
+-rw-r--r--   0 scottg     (503) staff       (20)    14033 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_mxfp.py
+-rw-r--r--   0 scottg     (503) staff       (20)      250 2024-05-10 19:39:47.000000 bitstring-4.2.2/tests/test_scaled_dtypes.py
```

### Comparing `bitstring-4.2.1/PKG-INFO` & `bitstring-4.2.2/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: bitstring
-Version: 4.2.1
+Version: 4.2.2
 Summary: Simple construction, analysis and modification of binary data.
 Author-email: Scott Griffiths <dr.scottgriffiths@gmail.com>
 Project-URL: homepage, https://github.com/scott-griffiths/bitstring
 Project-URL: documentation, https://bitstring.readthedocs.io/
 Keywords: binary,bitarray,bitvector,bitfield
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
@@ -39,15 +39,15 @@
 &nbsp; &nbsp;
 [![Pepy Total Downlods](https://img.shields.io/pepy/dt/bitstring?logo=python&logoColor=white&labelColor=blue&color=blue)](https://www.pepy.tech/projects/bitstring)
 [![PyPI - Downloads](https://img.shields.io/pypi/dm/bitstring?label=%40&labelColor=blue&color=blue)](https://pypistats.org/packages/bitstring)
 
 
 News
 ----
-**April 2024**: bitstring 4.2.1 released.
+**May 2024**: bitstring 4.2.2 released.
  
 New in version 4.2:
 
 * Dropped support for Python 3.7. Minimum version is now 3.8.
 * A new `Dtype` class can be optionally used to specify types.
 * The `bitstring.options` object is now the preferred method for changing module options.
 * New `fromstring` method as another way to create bitstrings from formatted strings.
```

### Comparing `bitstring-4.2.1/README.md` & `bitstring-4.2.2/README.md`

 * *Files 14% similar despite different names*

```diff
@@ -1,123 +1,123 @@
-
-
-![bitstring](https://raw.githubusercontent.com/scott-griffiths/bitstring/main/doc/bitstring_logo_small.png "bitstring")
-
-**bitstring** is a Python module to help make the creation and analysis of all types of bit-level binary data as simple and efficient as possible.
-
-It has been actively maintained since 2006.
-
-
-
-[![CI badge](https://github.com/scott-griffiths/bitstring/actions/workflows/.github/workflows/ci.yml/badge.svg)](https://github.com/scott-griffiths/bitstring/actions/workflows/ci.yml)
-[![Docs](https://img.shields.io/readthedocs/bitstring?logo=readthedocs&logoColor=white)](https://bitstring.readthedocs.io/en/latest/)
-[![Codacy Badge](https://img.shields.io/codacy/grade/8869499b2eed44548fa1a5149dd451f4?logo=codacy)](https://app.codacy.com/gh/scott-griffiths/bitstring/dashboard?utm_source=gh&utm_medium=referral&utm_content=&utm_campaign=Badge_grade)
-[![Dependents (via libraries.io)](https://img.shields.io/librariesio/dependents/pypi/bitstring?logo=libraries.io&logoColor=white)](https://libraries.io/pypi/bitstring)
-&nbsp; &nbsp;
-[![Pepy Total Downlods](https://img.shields.io/pepy/dt/bitstring?logo=python&logoColor=white&labelColor=blue&color=blue)](https://www.pepy.tech/projects/bitstring)
-[![PyPI - Downloads](https://img.shields.io/pypi/dm/bitstring?label=%40&labelColor=blue&color=blue)](https://pypistats.org/packages/bitstring)
-
-
-News
-----
-**April 2024**: bitstring 4.2.1 released.
- 
-New in version 4.2:
-
-* Dropped support for Python 3.7. Minimum version is now 3.8.
-* A new `Dtype` class can be optionally used to specify types.
-* The `bitstring.options` object is now the preferred method for changing module options.
-* New `fromstring` method as another way to create bitstrings from formatted strings.
-* More types can now be pretty printed.
-* A range of 8-bit, 6-bit and even 4-bit floating point formats added (beta):
-* Performance improvements.
-
-See the [release notes](https://github.com/scott-griffiths/bitstring/blob/main/release_notes.txt) for details. Please let me know if you encounter any problems.
-
-
-Overview
---------
-
-* Efficiently store and manipulate binary data in idiomatic Python.
-* Create bitstrings from hex, octal, binary, files, formatted strings, bytes, integers and floats of different endiannesses.
-* Powerful binary packing and unpacking functions.
-* Bit-level slicing, joining, searching, replacing and more.
-* Create and manipulate arrays of fixed-length bitstrings.
-* Read from and interpret bitstrings as streams of binary data.
-* Rich API - chances are that whatever you want to do there's a simple and elegant way of doing it.
-* Open source software, released under the MIT licence.
-
-Documentation
--------------
-Extensive documentation for the bitstring module is available.
-Some starting points are given below:
-
-* [Overview](https://bitstring.readthedocs.io/en/stable/index.html)
-* [Quick Reference](https://bitstring.readthedocs.io/en/stable/quick_reference.html)
-* [Full Reference](https://bitstring.readthedocs.io/en/stable/reference.html)
-
-There is also an introductory walkthrough notebook on [binder](https://mybinder.org/v2/gh/scott-griffiths/bitstring/main?labpath=doc%2Fwalkthrough.ipynb).
-
-Release Notes
--------------
-
-To see what been added, improved or fixed, and also to see what's coming in the next version, see the [release notes](https://github.com/scott-griffiths/bitstring/blob/main/release_notes.txt).
-
-Examples
---------
-
-### Installation
-
-    $ pip install bitstring
-
-### Creation
-
-     >>> from bitstring import Bits, BitArray, BitStream, pack
-     >>> a = BitArray(bin='00101')
-     >>> b = Bits(a_file_object)
-     >>> c = BitArray('0xff, 0b101, 0o65, uint6=22')
-     >>> d = pack('intle16, hex=a, 0b1', 100, a='0x34f')
-     >>> e = pack('<16h', *range(16))
-
-### Different interpretations, slicing and concatenation
-
-     >>> a = BitArray('0x3348')
-     >>> a.hex, a.bin, a.uint, a.float, a.bytes
-     ('3348', '0011001101001000', 13128, 0.2275390625, b'3H')
-     >>> a[10:3:-1].bin
-     '0101100'
-     >>> '0b100' + 3*a
-     BitArray('0x866906690669, 0b000')
-
-### Reading data sequentially
-
-     >>> b = BitStream('0x160120f')
-     >>> b.read(12).hex
-     '160'
-     >>> b.pos = 0
-     >>> b.read('uint12')
-     352
-     >>> b.readlist('uint12, bin3')
-     [288, '111']
-
-### Searching, inserting and deleting
-
-     >>> c = BitArray('0b00010010010010001111')   # c.hex == '0x1248f'
-     >>> c.find('0x48')
-     (8,)
-     >>> c.replace('0b001', '0xabc')
-     >>> c.insert('0b0000', pos=3)
-     >>> del c[12:16]
-
-### Arrays of fixed-length formats
-
-     >>> from bitstring import Array
-     >>> a = Array('uint7', [9, 100, 3, 1])
-     >>> a.data
-     BitArray('0x1390181')
-     >>> a[::2] *= 5
-     >>> a
-     Array('uint7', [45, 100, 15, 1])
-
-
-
-<sub>Copyright (c) 2006 - 2024 Scott Griffiths</sub>
+
+
+![bitstring](https://raw.githubusercontent.com/scott-griffiths/bitstring/main/doc/bitstring_logo_small.png "bitstring")
+
+**bitstring** is a Python module to help make the creation and analysis of all types of bit-level binary data as simple and efficient as possible.
+
+It has been actively maintained since 2006.
+
+
+
+[![CI badge](https://github.com/scott-griffiths/bitstring/actions/workflows/.github/workflows/ci.yml/badge.svg)](https://github.com/scott-griffiths/bitstring/actions/workflows/ci.yml)
+[![Docs](https://img.shields.io/readthedocs/bitstring?logo=readthedocs&logoColor=white)](https://bitstring.readthedocs.io/en/latest/)
+[![Codacy Badge](https://img.shields.io/codacy/grade/8869499b2eed44548fa1a5149dd451f4?logo=codacy)](https://app.codacy.com/gh/scott-griffiths/bitstring/dashboard?utm_source=gh&utm_medium=referral&utm_content=&utm_campaign=Badge_grade)
+[![Dependents (via libraries.io)](https://img.shields.io/librariesio/dependents/pypi/bitstring?logo=libraries.io&logoColor=white)](https://libraries.io/pypi/bitstring)
+&nbsp; &nbsp;
+[![Pepy Total Downlods](https://img.shields.io/pepy/dt/bitstring?logo=python&logoColor=white&labelColor=blue&color=blue)](https://www.pepy.tech/projects/bitstring)
+[![PyPI - Downloads](https://img.shields.io/pypi/dm/bitstring?label=%40&labelColor=blue&color=blue)](https://pypistats.org/packages/bitstring)
+
+
+News
+----
+**May 2024**: bitstring 4.2.2 released.
+ 
+New in version 4.2:
+
+* Dropped support for Python 3.7. Minimum version is now 3.8.
+* A new `Dtype` class can be optionally used to specify types.
+* The `bitstring.options` object is now the preferred method for changing module options.
+* New `fromstring` method as another way to create bitstrings from formatted strings.
+* More types can now be pretty printed.
+* A range of 8-bit, 6-bit and even 4-bit floating point formats added (beta):
+* Performance improvements.
+
+See the [release notes](https://github.com/scott-griffiths/bitstring/blob/main/release_notes.txt) for details. Please let me know if you encounter any problems.
+
+
+Overview
+--------
+
+* Efficiently store and manipulate binary data in idiomatic Python.
+* Create bitstrings from hex, octal, binary, files, formatted strings, bytes, integers and floats of different endiannesses.
+* Powerful binary packing and unpacking functions.
+* Bit-level slicing, joining, searching, replacing and more.
+* Create and manipulate arrays of fixed-length bitstrings.
+* Read from and interpret bitstrings as streams of binary data.
+* Rich API - chances are that whatever you want to do there's a simple and elegant way of doing it.
+* Open source software, released under the MIT licence.
+
+Documentation
+-------------
+Extensive documentation for the bitstring module is available.
+Some starting points are given below:
+
+* [Overview](https://bitstring.readthedocs.io/en/stable/index.html)
+* [Quick Reference](https://bitstring.readthedocs.io/en/stable/quick_reference.html)
+* [Full Reference](https://bitstring.readthedocs.io/en/stable/reference.html)
+
+There is also an introductory walkthrough notebook on [binder](https://mybinder.org/v2/gh/scott-griffiths/bitstring/main?labpath=doc%2Fwalkthrough.ipynb).
+
+Release Notes
+-------------
+
+To see what been added, improved or fixed, and also to see what's coming in the next version, see the [release notes](https://github.com/scott-griffiths/bitstring/blob/main/release_notes.txt).
+
+Examples
+--------
+
+### Installation
+
+    $ pip install bitstring
+
+### Creation
+
+     >>> from bitstring import Bits, BitArray, BitStream, pack
+     >>> a = BitArray(bin='00101')
+     >>> b = Bits(a_file_object)
+     >>> c = BitArray('0xff, 0b101, 0o65, uint6=22')
+     >>> d = pack('intle16, hex=a, 0b1', 100, a='0x34f')
+     >>> e = pack('<16h', *range(16))
+
+### Different interpretations, slicing and concatenation
+
+     >>> a = BitArray('0x3348')
+     >>> a.hex, a.bin, a.uint, a.float, a.bytes
+     ('3348', '0011001101001000', 13128, 0.2275390625, b'3H')
+     >>> a[10:3:-1].bin
+     '0101100'
+     >>> '0b100' + 3*a
+     BitArray('0x866906690669, 0b000')
+
+### Reading data sequentially
+
+     >>> b = BitStream('0x160120f')
+     >>> b.read(12).hex
+     '160'
+     >>> b.pos = 0
+     >>> b.read('uint12')
+     352
+     >>> b.readlist('uint12, bin3')
+     [288, '111']
+
+### Searching, inserting and deleting
+
+     >>> c = BitArray('0b00010010010010001111')   # c.hex == '0x1248f'
+     >>> c.find('0x48')
+     (8,)
+     >>> c.replace('0b001', '0xabc')
+     >>> c.insert('0b0000', pos=3)
+     >>> del c[12:16]
+
+### Arrays of fixed-length formats
+
+     >>> from bitstring import Array
+     >>> a = Array('uint7', [9, 100, 3, 1])
+     >>> a.data
+     BitArray('0x1390181')
+     >>> a[::2] *= 5
+     >>> a
+     Array('uint7', [45, 100, 15, 1])
+
+
+
+<sub>Copyright (c) 2006 - 2024 Scott Griffiths</sub>
```

### Comparing `bitstring-4.2.1/bitstring/__init__.py` & `bitstring-4.2.2/bitstring/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,318 +1,318 @@
-#!/usr/bin/env python
-r"""
-This package defines classes that simplify bit-wise creation, manipulation and
-interpretation of data.
-
-Classes:
-
-Bits -- An immutable container for binary data.
-BitArray -- A mutable container for binary data.
-ConstBitStream -- An immutable container with streaming methods.
-BitStream -- A mutable container with streaming methods.
-Array -- An efficient list-like container where each item has a fixed-length binary format.
-Dtype -- Encapsulate the data types used in the other classes.
-
-Functions:
-
-pack -- Create a BitStream from a format string.
-
-Data:
-
-options -- Module-wide options.
-
-Exceptions:
-
-Error -- Module exception base class.
-CreationError -- Error during creation.
-InterpretError -- Inappropriate interpretation of binary data.
-ByteAlignError -- Whole byte position or length needed.
-ReadError -- Reading or peeking past the end of a bitstring.
-
-https://github.com/scott-griffiths/bitstring
-"""
-
-__licence__ = """
-The MIT License
-
-Copyright (c) 2006 Scott Griffiths (dr.scottgriffiths@gmail.com)
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-"""
-
-__version__ = "4.2.1"
-
-__author__ = "Scott Griffiths"
-
-import sys
-
-from .bits import Bits
-from .bitstring_options import Options
-from .bitarray_ import BitArray
-from .bitstream import ConstBitStream, BitStream
-from .methods import pack
-from .array_ import Array
-from .exceptions import Error, ReadError, InterpretError, ByteAlignError, CreationError
-from .dtypes import DtypeDefinition, dtype_register, Dtype
-import types
-from typing import List, Tuple, Literal
-from .mxfp import decompress_luts as mxfp_decompress_luts
-from .fp8 import decompress_luts as binary8_decompress_luts
-
-# Decompress the LUTs for the exotic floating point formats
-mxfp_decompress_luts()
-binary8_decompress_luts()
-
-# The Options class returns a singleton.
-options = Options()
-
-# These get defined properly by the module magic below. This just stops mypy complaining about them.
-bytealigned = lsb0 = None
-
-
-# An opaque way of adding module level properties. Taken from https://peps.python.org/pep-0549/
-# This is now deprecated. Use the options object directly instead.
-class _MyModuleType(types.ModuleType):
-    @property
-    def bytealigned(self) -> bool:
-        """Determines whether a number of methods default to working only on byte boundaries."""
-        return options.bytealigned
-
-    @bytealigned.setter
-    def bytealigned(self, value: bool) -> None:
-        """Determines whether a number of methods default to working only on byte boundaries."""
-        options.bytealigned = value
-
-    @property
-    def lsb0(self) -> bool:
-        """If True, the least significant bit (the final bit) is indexed as bit zero."""
-        return options.lsb0
-
-    @lsb0.setter
-    def lsb0(self, value: bool) -> None:
-        """If True, the least significant bit (the final bit) is indexed as bit zero."""
-        options.lsb0 = value
-
-
-sys.modules[__name__].__class__ = _MyModuleType
-
-"""These methods convert a bit length to the number of characters needed to print it for different interpretations."""
-def hex_bits2chars(bitlength: int):
-    # One character for every 4 bits
-    return bitlength // 4
-
-def oct_bits2chars(bitlength: int):
-    # One character for every 3 bits
-    return bitlength // 3
-
-def bin_bits2chars(bitlength: int):
-    # One character for each bit
-    return bitlength
-
-def bytes_bits2chars(bitlength: int):
-    # One character for every 8 bits
-    return bitlength // 8
-
-def uint_bits2chars(bitlength: int):
-    # How many characters is largest possible int of this length?
-    return len(str((1 << bitlength) - 1))
-
-def int_bits2chars(bitlength: int):
-    # How many characters is largest negative int of this length? (To include minus sign).
-    return len(str((-1 << (bitlength - 1))))
-
-def float_bits2chars(bitlength: Literal[16, 32, 64]):
-    # These bit lengths were found by looking at lots of possible values
-    if bitlength in [16, 32]:
-        return 23  # Empirical value
-    else:
-        return 24  # Empirical value
-
-def p3binary_bits2chars(bitlength: Literal[8]):
-    return 19  # Empirical value
-
-def p4binary_bits2chars(bitlength: Literal[8]):
-    # Found by looking at all the possible values
-    return 13  # Empirical value
-
-def e4m3mxfp_bits2chars(bitlength: Literal[8]):
-    return 13
-
-def e5m2mxfp_bits2chars(bitlength: Literal[8]):
-    return 19
-
-def e3m2mxfp_bits2chars(bitlength: Literal[6]):
-    # Not sure what the best value is here. It's 7 without considering the scale that could be applied.
-    return 7
-
-def e2m3mxfp_bits2chars(bitlength: Literal[6]):
-    # Not sure what the best value is here.
-    return 7
-
-def e2m1mxfp_bits2chars(bitlength: Literal[4]):
-    # Not sure what the best value is here.
-    return 7
-
-def e8m0mxfp_bits2chars(bitlength: Literal[8]):
-    # Can range same as float32
-    return 23
-
-def mxint_bits2chars(bitlength: Literal[8]):
-    # Not sure what the best value is here.
-    return 10
-
-
-def bfloat_bits2chars(bitlength: Literal[16]):
-    # Found by looking at all the possible values
-    return 23  # Empirical value
-
-def bits_bits2chars(bitlength: int):
-    # For bits type we can see how long it needs to be printed by trying any value
-    temp = Bits(bitlength)
-    return len(str(temp))
-
-def bool_bits2chars(bitlength: Literal[1]):
-    # Bools are printed as 1 or 0, not True or False, so are one character each
-    return 1
-
-dtype_definitions = [
-    # Integer types
-    DtypeDefinition('uint', Bits._setuint, Bits._getuint, int, False, uint_bits2chars,
-                    description="a two's complement unsigned int"),
-    DtypeDefinition('uintle', Bits._setuintle, Bits._getuintle, int, False, uint_bits2chars,
-                    allowed_lengths=(8, 16, 24, ...), description="a two's complement little-endian unsigned int"),
-    DtypeDefinition('uintbe', Bits._setuintbe, Bits._getuintbe, int, False, uint_bits2chars,
-                    allowed_lengths=(8, 16, 24, ...), description="a two's complement big-endian unsigned int"),
-    DtypeDefinition('int', Bits._setint, Bits._getint, int, True, int_bits2chars,
-                    description="a two's complement signed int"),
-    DtypeDefinition('intle', Bits._setintle, Bits._getintle, int, True, int_bits2chars,
-                    allowed_lengths=(8, 16, 24, ...), description="a two's complement little-endian signed int"),
-    DtypeDefinition('intbe', Bits._setintbe, Bits._getintbe, int, True, int_bits2chars,
-                    allowed_lengths=(8, 16, 24, ...), description="a two's complement big-endian signed int"),
-    # String types
-    DtypeDefinition('hex', Bits._sethex, Bits._gethex, str, False, hex_bits2chars,
-                    allowed_lengths=(0, 4, 8, ...), description="a hexadecimal string"),
-    DtypeDefinition('bin', Bits._setbin_safe, Bits._getbin, str, False, bin_bits2chars,
-                    description="a binary string"),
-    DtypeDefinition('oct', Bits._setoct, Bits._getoct, str, False, oct_bits2chars,
-                    allowed_lengths=(0, 3, 6, ...), description="an octal string"),
-    # Float types
-    DtypeDefinition('float', Bits._setfloatbe, Bits._getfloatbe, float, True, float_bits2chars,
-                    allowed_lengths=(16, 32, 64), description="a big-endian floating point number"),
-    DtypeDefinition('floatle', Bits._setfloatle, Bits._getfloatle, float, True, float_bits2chars,
-                    allowed_lengths=(16, 32, 64), description="a little-endian floating point number"),
-    DtypeDefinition('bfloat', Bits._setbfloatbe, Bits._getbfloatbe, float, True, bfloat_bits2chars,
-                    allowed_lengths=(16,), description="a 16 bit big-endian bfloat floating point number"),
-    DtypeDefinition('bfloatle', Bits._setbfloatle, Bits._getbfloatle, float, True, bfloat_bits2chars,
-                    allowed_lengths=(16,), description="a 16 bit little-endian bfloat floating point number"),
-    # Other known length types
-    DtypeDefinition('bits', Bits._setbits, Bits._getbits, Bits, False, bits_bits2chars,
-                    description="a bitstring object"),
-    DtypeDefinition('bool', Bits._setbool, Bits._getbool, bool, False, bool_bits2chars,
-                    allowed_lengths=(1,), description="a bool (True or False)"),
-    DtypeDefinition('bytes', Bits._setbytes, Bits._getbytes, bytes, False, bytes_bits2chars,
-                    multiplier=8, description="a bytes object"),
-    # Unknown length types
-    DtypeDefinition('se', Bits._setse, Bits._getse, int, True, None,
-                    variable_length=True, description="a signed exponential-Golomb code"),
-    DtypeDefinition('ue', Bits._setue, Bits._getue, int, False, None,
-                    variable_length=True, description="an unsigned exponential-Golomb code"),
-    DtypeDefinition('sie', Bits._setsie, Bits._getsie, int, True, None,
-                    variable_length=True, description="a signed interleaved exponential-Golomb code"),
-    DtypeDefinition('uie', Bits._setuie, Bits._getuie, int, False, None,
-                    variable_length=True, description="an unsigned interleaved exponential-Golomb code"),
-    # Special case pad type
-    DtypeDefinition('pad', Bits._setpad, Bits._getpad, None, False, None,
-                    description="a skipped section of padding"),
-
-    # MXFP and IEEE 8-bit float types
-    DtypeDefinition('p3binary', Bits._setp3binary, Bits._getp3binary, float, True, p3binary_bits2chars,
-                    allowed_lengths=(8,), description="an 8 bit float with binary8p3 format"),
-    DtypeDefinition('p4binary', Bits._setp4binary, Bits._getp4binary, float, True, p4binary_bits2chars,
-                    allowed_lengths=(8,), description="an 8 bit float with binary8p4 format"),
-    DtypeDefinition('e4m3mxfp', Bits._sete4m3mxfp, Bits._gete4m3mxfp, float, True, e4m3mxfp_bits2chars,
-                    allowed_lengths=(8,), description="an 8 bit float with MXFP E4M3 format"),
-    DtypeDefinition('e5m2mxfp', Bits._sete5m2mxfp, Bits._gete5m2mxfp, float, True, e5m2mxfp_bits2chars,
-                    allowed_lengths=(8,), description="an 8 bit float with MXFP E5M2 format"),
-    DtypeDefinition('e3m2mxfp', Bits._sete3m2mxfp, Bits._gete3m2mxfp, float, True, e3m2mxfp_bits2chars,
-                    allowed_lengths=(6,), description="a 6 bit float with MXFP E3M2 format"),
-    DtypeDefinition('e2m3mxfp', Bits._sete2m3mxfp, Bits._gete2m3mxfp, float, True, e2m3mxfp_bits2chars,
-                    allowed_lengths=(6,), description="a 6 bit float with MXFP E2M3 format"),
-    DtypeDefinition('e2m1mxfp', Bits._sete2m1mxfp, Bits._gete2m1mxfp, float, True, e2m1mxfp_bits2chars,
-                    allowed_lengths=(4,), description="a 4 bit float with MXFP E2M1 format"),
-    DtypeDefinition('e8m0mxfp', Bits._sete8m0mxfp, Bits._gete8m0mxfp, float, False, e8m0mxfp_bits2chars,
-                    allowed_lengths=(8,), description="an 8 bit float with MXFP E8M0 format"),
-    DtypeDefinition('mxint', Bits._setmxint, Bits._getmxint, float, True, mxint_bits2chars,
-                    allowed_lengths=(8,), description="an 8 bit float with MXFP INT8 format"),
-]
-
-
-aliases: List[Tuple[str, str]] = [
-    # Floats default to big endian
-    ('float', 'floatbe'),
-    ('bfloat', 'bfloatbe'),
-
-    # Some single letter aliases for popular types
-    ('int', 'i'),
-    ('uint', 'u'),
-    ('hex', 'h'),
-    ('oct', 'o'),
-    ('bin', 'b'),
-    ('float', 'f'),
-]
-
-# Create native-endian aliases depending on the byteorder of the system
-byteorder: str = sys.byteorder
-if byteorder == 'little':
-    aliases.extend([
-        ('uintle', 'uintne'),
-        ('intle', 'intne'),
-        ('floatle', 'floatne'),
-        ('bfloatle', 'bfloatne'),
-    ])
-else:
-    aliases.extend([
-        ('uintbe', 'uintne'),
-        ('intbe', 'intne'),
-        ('floatbe', 'floatne'),
-        ('bfloatbe', 'bfloatne'),
-    ])
-
-
-for dt in dtype_definitions:
-    dtype_register.add_dtype(dt)
-for alias in aliases:
-    dtype_register.add_dtype_alias(alias[0], alias[1])
-
-property_docstrings = [f'{name} -- Interpret as {dtype_register[name].description}.' for name in dtype_register.names]
-property_docstring = '\n    '.join(property_docstrings)
-
-# We can't be sure the docstrings are present, as it might be compiled without docstrings.
-if Bits.__doc__ is not None:
-    Bits.__doc__ = Bits.__doc__.replace('[GENERATED_PROPERTY_DESCRIPTIONS]', property_docstring)
-if BitArray.__doc__ is not None:
-    BitArray.__doc__ = BitArray.__doc__.replace('[GENERATED_PROPERTY_DESCRIPTIONS]', property_docstring)
-if ConstBitStream.__doc__ is not None:
-    ConstBitStream.__doc__ = ConstBitStream.__doc__.replace('[GENERATED_PROPERTY_DESCRIPTIONS]', property_docstring)
-if BitStream.__doc__ is not None:
-    BitStream.__doc__ = BitStream.__doc__.replace('[GENERATED_PROPERTY_DESCRIPTIONS]', property_docstring)
-
-
-__all__ = ['ConstBitStream', 'BitStream', 'BitArray', 'Array',
-           'Bits', 'pack', 'Error', 'ReadError', 'InterpretError',
-           'ByteAlignError', 'CreationError', 'bytealigned', 'lsb0', 'Dtype', 'options']
+#!/usr/bin/env python
+r"""
+This package defines classes that simplify bit-wise creation, manipulation and
+interpretation of data.
+
+Classes:
+
+Bits -- An immutable container for binary data.
+BitArray -- A mutable container for binary data.
+ConstBitStream -- An immutable container with streaming methods.
+BitStream -- A mutable container with streaming methods.
+Array -- An efficient list-like container where each item has a fixed-length binary format.
+Dtype -- Encapsulate the data types used in the other classes.
+
+Functions:
+
+pack -- Create a BitStream from a format string.
+
+Data:
+
+options -- Module-wide options.
+
+Exceptions:
+
+Error -- Module exception base class.
+CreationError -- Error during creation.
+InterpretError -- Inappropriate interpretation of binary data.
+ByteAlignError -- Whole byte position or length needed.
+ReadError -- Reading or peeking past the end of a bitstring.
+
+https://github.com/scott-griffiths/bitstring
+"""
+
+__licence__ = """
+The MIT License
+
+Copyright (c) 2006 Scott Griffiths (dr.scottgriffiths@gmail.com)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+"""
+
+__version__ = "4.2.2"
+
+__author__ = "Scott Griffiths"
+
+import sys
+
+from .bits import Bits
+from .bitstring_options import Options
+from .bitarray_ import BitArray
+from .bitstream import ConstBitStream, BitStream
+from .methods import pack
+from .array_ import Array
+from .exceptions import Error, ReadError, InterpretError, ByteAlignError, CreationError
+from .dtypes import DtypeDefinition, dtype_register, Dtype
+import types
+from typing import List, Tuple, Literal
+from .mxfp import decompress_luts as mxfp_decompress_luts
+from .fp8 import decompress_luts as binary8_decompress_luts
+
+# Decompress the LUTs for the exotic floating point formats
+mxfp_decompress_luts()
+binary8_decompress_luts()
+
+# The Options class returns a singleton.
+options = Options()
+
+# These get defined properly by the module magic below. This just stops mypy complaining about them.
+bytealigned = lsb0 = None
+
+
+# An opaque way of adding module level properties. Taken from https://peps.python.org/pep-0549/
+# This is now deprecated. Use the options object directly instead.
+class _MyModuleType(types.ModuleType):
+    @property
+    def bytealigned(self) -> bool:
+        """Determines whether a number of methods default to working only on byte boundaries."""
+        return options.bytealigned
+
+    @bytealigned.setter
+    def bytealigned(self, value: bool) -> None:
+        """Determines whether a number of methods default to working only on byte boundaries."""
+        options.bytealigned = value
+
+    @property
+    def lsb0(self) -> bool:
+        """If True, the least significant bit (the final bit) is indexed as bit zero."""
+        return options.lsb0
+
+    @lsb0.setter
+    def lsb0(self, value: bool) -> None:
+        """If True, the least significant bit (the final bit) is indexed as bit zero."""
+        options.lsb0 = value
+
+
+sys.modules[__name__].__class__ = _MyModuleType
+
+"""These methods convert a bit length to the number of characters needed to print it for different interpretations."""
+def hex_bits2chars(bitlength: int):
+    # One character for every 4 bits
+    return bitlength // 4
+
+def oct_bits2chars(bitlength: int):
+    # One character for every 3 bits
+    return bitlength // 3
+
+def bin_bits2chars(bitlength: int):
+    # One character for each bit
+    return bitlength
+
+def bytes_bits2chars(bitlength: int):
+    # One character for every 8 bits
+    return bitlength // 8
+
+def uint_bits2chars(bitlength: int):
+    # How many characters is largest possible int of this length?
+    return len(str((1 << bitlength) - 1))
+
+def int_bits2chars(bitlength: int):
+    # How many characters is largest negative int of this length? (To include minus sign).
+    return len(str((-1 << (bitlength - 1))))
+
+def float_bits2chars(bitlength: Literal[16, 32, 64]):
+    # These bit lengths were found by looking at lots of possible values
+    if bitlength in [16, 32]:
+        return 23  # Empirical value
+    else:
+        return 24  # Empirical value
+
+def p3binary_bits2chars(bitlength: Literal[8]):
+    return 19  # Empirical value
+
+def p4binary_bits2chars(bitlength: Literal[8]):
+    # Found by looking at all the possible values
+    return 13  # Empirical value
+
+def e4m3mxfp_bits2chars(bitlength: Literal[8]):
+    return 13
+
+def e5m2mxfp_bits2chars(bitlength: Literal[8]):
+    return 19
+
+def e3m2mxfp_bits2chars(bitlength: Literal[6]):
+    # Not sure what the best value is here. It's 7 without considering the scale that could be applied.
+    return 7
+
+def e2m3mxfp_bits2chars(bitlength: Literal[6]):
+    # Not sure what the best value is here.
+    return 7
+
+def e2m1mxfp_bits2chars(bitlength: Literal[4]):
+    # Not sure what the best value is here.
+    return 7
+
+def e8m0mxfp_bits2chars(bitlength: Literal[8]):
+    # Can range same as float32
+    return 23
+
+def mxint_bits2chars(bitlength: Literal[8]):
+    # Not sure what the best value is here.
+    return 10
+
+
+def bfloat_bits2chars(bitlength: Literal[16]):
+    # Found by looking at all the possible values
+    return 23  # Empirical value
+
+def bits_bits2chars(bitlength: int):
+    # For bits type we can see how long it needs to be printed by trying any value
+    temp = Bits(bitlength)
+    return len(str(temp))
+
+def bool_bits2chars(bitlength: Literal[1]):
+    # Bools are printed as 1 or 0, not True or False, so are one character each
+    return 1
+
+dtype_definitions = [
+    # Integer types
+    DtypeDefinition('uint', Bits._setuint, Bits._getuint, int, False, uint_bits2chars,
+                    description="a two's complement unsigned int"),
+    DtypeDefinition('uintle', Bits._setuintle, Bits._getuintle, int, False, uint_bits2chars,
+                    allowed_lengths=(8, 16, 24, ...), description="a two's complement little-endian unsigned int"),
+    DtypeDefinition('uintbe', Bits._setuintbe, Bits._getuintbe, int, False, uint_bits2chars,
+                    allowed_lengths=(8, 16, 24, ...), description="a two's complement big-endian unsigned int"),
+    DtypeDefinition('int', Bits._setint, Bits._getint, int, True, int_bits2chars,
+                    description="a two's complement signed int"),
+    DtypeDefinition('intle', Bits._setintle, Bits._getintle, int, True, int_bits2chars,
+                    allowed_lengths=(8, 16, 24, ...), description="a two's complement little-endian signed int"),
+    DtypeDefinition('intbe', Bits._setintbe, Bits._getintbe, int, True, int_bits2chars,
+                    allowed_lengths=(8, 16, 24, ...), description="a two's complement big-endian signed int"),
+    # String types
+    DtypeDefinition('hex', Bits._sethex, Bits._gethex, str, False, hex_bits2chars,
+                    allowed_lengths=(0, 4, 8, ...), description="a hexadecimal string"),
+    DtypeDefinition('bin', Bits._setbin_safe, Bits._getbin, str, False, bin_bits2chars,
+                    description="a binary string"),
+    DtypeDefinition('oct', Bits._setoct, Bits._getoct, str, False, oct_bits2chars,
+                    allowed_lengths=(0, 3, 6, ...), description="an octal string"),
+    # Float types
+    DtypeDefinition('float', Bits._setfloatbe, Bits._getfloatbe, float, True, float_bits2chars,
+                    allowed_lengths=(16, 32, 64), description="a big-endian floating point number"),
+    DtypeDefinition('floatle', Bits._setfloatle, Bits._getfloatle, float, True, float_bits2chars,
+                    allowed_lengths=(16, 32, 64), description="a little-endian floating point number"),
+    DtypeDefinition('bfloat', Bits._setbfloatbe, Bits._getbfloatbe, float, True, bfloat_bits2chars,
+                    allowed_lengths=(16,), description="a 16 bit big-endian bfloat floating point number"),
+    DtypeDefinition('bfloatle', Bits._setbfloatle, Bits._getbfloatle, float, True, bfloat_bits2chars,
+                    allowed_lengths=(16,), description="a 16 bit little-endian bfloat floating point number"),
+    # Other known length types
+    DtypeDefinition('bits', Bits._setbits, Bits._getbits, Bits, False, bits_bits2chars,
+                    description="a bitstring object"),
+    DtypeDefinition('bool', Bits._setbool, Bits._getbool, bool, False, bool_bits2chars,
+                    allowed_lengths=(1,), description="a bool (True or False)"),
+    DtypeDefinition('bytes', Bits._setbytes, Bits._getbytes, bytes, False, bytes_bits2chars,
+                    multiplier=8, description="a bytes object"),
+    # Unknown length types
+    DtypeDefinition('se', Bits._setse, Bits._getse, int, True, None,
+                    variable_length=True, description="a signed exponential-Golomb code"),
+    DtypeDefinition('ue', Bits._setue, Bits._getue, int, False, None,
+                    variable_length=True, description="an unsigned exponential-Golomb code"),
+    DtypeDefinition('sie', Bits._setsie, Bits._getsie, int, True, None,
+                    variable_length=True, description="a signed interleaved exponential-Golomb code"),
+    DtypeDefinition('uie', Bits._setuie, Bits._getuie, int, False, None,
+                    variable_length=True, description="an unsigned interleaved exponential-Golomb code"),
+    # Special case pad type
+    DtypeDefinition('pad', Bits._setpad, Bits._getpad, None, False, None,
+                    description="a skipped section of padding"),
+
+    # MXFP and IEEE 8-bit float types
+    DtypeDefinition('p3binary', Bits._setp3binary, Bits._getp3binary, float, True, p3binary_bits2chars,
+                    allowed_lengths=(8,), description="an 8 bit float with binary8p3 format"),
+    DtypeDefinition('p4binary', Bits._setp4binary, Bits._getp4binary, float, True, p4binary_bits2chars,
+                    allowed_lengths=(8,), description="an 8 bit float with binary8p4 format"),
+    DtypeDefinition('e4m3mxfp', Bits._sete4m3mxfp, Bits._gete4m3mxfp, float, True, e4m3mxfp_bits2chars,
+                    allowed_lengths=(8,), description="an 8 bit float with MXFP E4M3 format"),
+    DtypeDefinition('e5m2mxfp', Bits._sete5m2mxfp, Bits._gete5m2mxfp, float, True, e5m2mxfp_bits2chars,
+                    allowed_lengths=(8,), description="an 8 bit float with MXFP E5M2 format"),
+    DtypeDefinition('e3m2mxfp', Bits._sete3m2mxfp, Bits._gete3m2mxfp, float, True, e3m2mxfp_bits2chars,
+                    allowed_lengths=(6,), description="a 6 bit float with MXFP E3M2 format"),
+    DtypeDefinition('e2m3mxfp', Bits._sete2m3mxfp, Bits._gete2m3mxfp, float, True, e2m3mxfp_bits2chars,
+                    allowed_lengths=(6,), description="a 6 bit float with MXFP E2M3 format"),
+    DtypeDefinition('e2m1mxfp', Bits._sete2m1mxfp, Bits._gete2m1mxfp, float, True, e2m1mxfp_bits2chars,
+                    allowed_lengths=(4,), description="a 4 bit float with MXFP E2M1 format"),
+    DtypeDefinition('e8m0mxfp', Bits._sete8m0mxfp, Bits._gete8m0mxfp, float, False, e8m0mxfp_bits2chars,
+                    allowed_lengths=(8,), description="an 8 bit float with MXFP E8M0 format"),
+    DtypeDefinition('mxint', Bits._setmxint, Bits._getmxint, float, True, mxint_bits2chars,
+                    allowed_lengths=(8,), description="an 8 bit float with MXFP INT8 format"),
+]
+
+
+aliases: List[Tuple[str, str]] = [
+    # Floats default to big endian
+    ('float', 'floatbe'),
+    ('bfloat', 'bfloatbe'),
+
+    # Some single letter aliases for popular types
+    ('int', 'i'),
+    ('uint', 'u'),
+    ('hex', 'h'),
+    ('oct', 'o'),
+    ('bin', 'b'),
+    ('float', 'f'),
+]
+
+# Create native-endian aliases depending on the byteorder of the system
+byteorder: str = sys.byteorder
+if byteorder == 'little':
+    aliases.extend([
+        ('uintle', 'uintne'),
+        ('intle', 'intne'),
+        ('floatle', 'floatne'),
+        ('bfloatle', 'bfloatne'),
+    ])
+else:
+    aliases.extend([
+        ('uintbe', 'uintne'),
+        ('intbe', 'intne'),
+        ('floatbe', 'floatne'),
+        ('bfloatbe', 'bfloatne'),
+    ])
+
+
+for dt in dtype_definitions:
+    dtype_register.add_dtype(dt)
+for alias in aliases:
+    dtype_register.add_dtype_alias(alias[0], alias[1])
+
+property_docstrings = [f'{name} -- Interpret as {dtype_register[name].description}.' for name in dtype_register.names]
+property_docstring = '\n    '.join(property_docstrings)
+
+# We can't be sure the docstrings are present, as it might be compiled without docstrings.
+if Bits.__doc__ is not None:
+    Bits.__doc__ = Bits.__doc__.replace('[GENERATED_PROPERTY_DESCRIPTIONS]', property_docstring)
+if BitArray.__doc__ is not None:
+    BitArray.__doc__ = BitArray.__doc__.replace('[GENERATED_PROPERTY_DESCRIPTIONS]', property_docstring)
+if ConstBitStream.__doc__ is not None:
+    ConstBitStream.__doc__ = ConstBitStream.__doc__.replace('[GENERATED_PROPERTY_DESCRIPTIONS]', property_docstring)
+if BitStream.__doc__ is not None:
+    BitStream.__doc__ = BitStream.__doc__.replace('[GENERATED_PROPERTY_DESCRIPTIONS]', property_docstring)
+
+
+__all__ = ['ConstBitStream', 'BitStream', 'BitArray', 'Array',
+           'Bits', 'pack', 'Error', 'ReadError', 'InterpretError',
+           'ByteAlignError', 'CreationError', 'bytealigned', 'lsb0', 'Dtype', 'options']
```

### Comparing `bitstring-4.2.1/bitstring/__main__.py` & `bitstring-4.2.2/bitstring/__main__.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-import sys
-from bitstring.bits import Bits
-from bitstring.dtypes import Register
-
-dtype_register = Register()
-
-
-def main() -> None:
-    # check if final parameter is an interpretation string
-    fp = sys.argv[-1]
-    if fp in ['-h', '--help'] or len(sys.argv) == 1:
-        print("""Create and interpret a bitstring from command-line parameters.
-
-Command-line parameters are concatenated and a bitstring created
-from them. If the final parameter is either an interpretation string
-or ends with a '.' followed by an interpretation string then that
-interpretation of the bitstring will be used when printing it.
-
-Typical usage might be invoking the Python module from a console
-as a one-off calculation:
-
-$ python -m bitstring int:16=-400
-0xfe70
-$ python -m bitstring float:32=0.2 bin
-00111110010011001100110011001101
-$ python -m bitstring 0xff 3*0b01,0b11 uint
-65367
-$ python -m bitstring hex=01, uint:12=352.hex
-01160
-        """)
-        return
-    if fp in dtype_register.names:
-        # concatenate all other parameters and interpret using the final one
-        b1 = Bits(','.join(sys.argv[1: -1]))
-        print(b1._readtoken(fp, 0, b1.__len__())[0])
-    else:
-        # does final parameter end with a dot then an interpretation string?
-        interp = fp[fp.rfind('.') + 1:]
-        if interp in dtype_register.names:
-            sys.argv[-1] = fp[:fp.rfind('.')]
-            b1 = Bits(','.join(sys.argv[1:]))
-            print(b1._readtoken(interp, 0, b1.__len__())[0])
-        else:
-            # No interpretation - just use default print
-            b1 = Bits(','.join(sys.argv[1:]))
-            print(b1)
-
-
-if __name__ == '__main__':
+import sys
+from bitstring.bits import Bits
+from bitstring.dtypes import Register
+
+dtype_register = Register()
+
+
+def main() -> None:
+    # check if final parameter is an interpretation string
+    fp = sys.argv[-1]
+    if fp in ['-h', '--help'] or len(sys.argv) == 1:
+        print("""Create and interpret a bitstring from command-line parameters.
+
+Command-line parameters are concatenated and a bitstring created
+from them. If the final parameter is either an interpretation string
+or ends with a '.' followed by an interpretation string then that
+interpretation of the bitstring will be used when printing it.
+
+Typical usage might be invoking the Python module from a console
+as a one-off calculation:
+
+$ python -m bitstring int:16=-400
+0xfe70
+$ python -m bitstring float:32=0.2 bin
+00111110010011001100110011001101
+$ python -m bitstring 0xff 3*0b01,0b11 uint
+65367
+$ python -m bitstring hex=01, uint:12=352.hex
+01160
+        """)
+        return
+    if fp in dtype_register.names:
+        # concatenate all other parameters and interpret using the final one
+        b1 = Bits(','.join(sys.argv[1: -1]))
+        print(b1._readtoken(fp, 0, b1.__len__())[0])
+    else:
+        # does final parameter end with a dot then an interpretation string?
+        interp = fp[fp.rfind('.') + 1:]
+        if interp in dtype_register.names:
+            sys.argv[-1] = fp[:fp.rfind('.')]
+            b1 = Bits(','.join(sys.argv[1:]))
+            print(b1._readtoken(interp, 0, b1.__len__())[0])
+        else:
+            # No interpretation - just use default print
+            b1 = Bits(','.join(sys.argv[1:]))
+            print(b1)
+
+
+if __name__ == '__main__':
     main()
```

### Comparing `bitstring-4.2.1/bitstring/bitarray_.py` & `bitstring-4.2.2/bitstring/bitarray_.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,577 +1,577 @@
-from __future__ import annotations
-
-import copy
-import numbers
-import re
-from collections import abc
-from typing import Union, List, Iterable, Any, Optional
-from bitstring import utils
-from bitstring.exceptions import CreationError, Error
-from bitstring.bits import Bits, BitsType, TBits
-
-import bitstring.dtypes
-
-class BitArray(Bits):
-    """A container holding a mutable sequence of bits.
-
-    Subclass of the immutable Bits class. Inherits all of its
-    methods (except __hash__) and adds mutating methods.
-
-    Mutating methods:
-
-    append() -- Append a bitstring.
-    byteswap() -- Change byte endianness in-place.
-    clear() -- Remove all bits from the bitstring.
-    insert() -- Insert a bitstring.
-    invert() -- Flip bit(s) between one and zero.
-    overwrite() -- Overwrite a section with a new bitstring.
-    prepend() -- Prepend a bitstring.
-    replace() -- Replace occurrences of one bitstring with another.
-    reverse() -- Reverse bits in-place.
-    rol() -- Rotate bits to the left.
-    ror() -- Rotate bits to the right.
-    set() -- Set bit(s) to 1 or 0.
-
-    Methods inherited from Bits:
-
-    all() -- Check if all specified bits are set to 1 or 0.
-    any() -- Check if any of specified bits are set to 1 or 0.
-    copy() -- Return a copy of the bitstring.
-    count() -- Count the number of bits set to 1 or 0.
-    cut() -- Create generator of constant sized chunks.
-    endswith() -- Return whether the bitstring ends with a sub-string.
-    find() -- Find a sub-bitstring in the current bitstring.
-    findall() -- Find all occurrences of a sub-bitstring in the current bitstring.
-    fromstring() -- Create a bitstring from a formatted string.
-    join() -- Join bitstrings together using current bitstring.
-    pp() -- Pretty print the bitstring.
-    rfind() -- Seek backwards to find a sub-bitstring.
-    split() -- Create generator of chunks split by a delimiter.
-    startswith() -- Return whether the bitstring starts with a sub-bitstring.
-    tobitarray() -- Return bitstring as a bitarray from the bitarray package.
-    tobytes() -- Return bitstring as bytes, padding if needed.
-    tofile() -- Write bitstring to file, padding if needed.
-    unpack() -- Interpret bits using format string.
-
-    Special methods:
-
-    Mutating operators are available: [], <<=, >>=, +=, *=, &=, |= and ^=
-    in addition to the inherited [], ==, !=, +, *, ~, <<, >>, &, | and ^.
-
-    Properties:
-
-    [GENERATED_PROPERTY_DESCRIPTIONS]
-
-    len -- Length of the bitstring in bits.
-
-    """
-
-    __slots__ = ()
-
-    # As BitArray objects are mutable, we shouldn't allow them to be hashed.
-    __hash__: None = None
-
-
-    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,
-                 offset: Optional[int] = None, **kwargs) -> None:
-        """Either specify an 'auto' initialiser:
-        A string of comma separated tokens, an integer, a file object,
-        a bytearray, a boolean iterable or another bitstring.
-
-        Or initialise via **kwargs with one (and only one) of:
-        bin -- binary string representation, e.g. '0b001010'.
-        hex -- hexadecimal string representation, e.g. '0x2ef'
-        oct -- octal string representation, e.g. '0o777'.
-        bytes -- raw data as a bytes object, for example read from a binary file.
-        int -- a signed integer.
-        uint -- an unsigned integer.
-        float / floatbe -- a big-endian floating point number.
-        bool -- a boolean (True or False).
-        se -- a signed exponential-Golomb code.
-        ue -- an unsigned exponential-Golomb code.
-        sie -- a signed interleaved exponential-Golomb code.
-        uie -- an unsigned interleaved exponential-Golomb code.
-        floatle -- a little-endian floating point number.
-        floatne -- a native-endian floating point number.
-        bfloat / bfloatbe - a big-endian bfloat format 16-bit floating point number.
-        bfloatle -- a little-endian bfloat format 16-bit floating point number.
-        bfloatne -- a native-endian bfloat format 16-bit floating point number.
-        intbe -- a signed big-endian whole byte integer.
-        intle -- a signed little-endian whole byte integer.
-        intne -- a signed native-endian whole byte integer.
-        uintbe -- an unsigned big-endian whole byte integer.
-        uintle -- an unsigned little-endian whole byte integer.
-        uintne -- an unsigned native-endian whole byte integer.
-        filename -- the path of a file which will be opened in binary read-only mode.
-
-        Other keyword arguments:
-        length -- length of the bitstring in bits, if needed and appropriate.
-                  It must be supplied for all integer and float initialisers.
-        offset -- bit offset to the data. These offset bits are
-                  ignored and this is intended for use when
-                  initialising using 'bytes' or 'filename'.
-
-        """
-        if self._bitstore.immutable:
-            self._bitstore = self._bitstore._copy()
-            self._bitstore.immutable = False
-
-    def copy(self: TBits) -> TBits:
-        """Return a copy of the bitstring."""
-        return self.__copy__()
-
-    def __setattr__(self, attribute, value) -> None:
-        try:
-            # First try the ordinary attribute setter
-            super().__setattr__(attribute, value)
-        except AttributeError:
-            dtype = bitstring.dtypes.Dtype(attribute)
-            x = object.__new__(Bits)
-            if (set_fn := dtype.set_fn) is None:
-                raise AttributeError(f"Cannot set attribute '{attribute}' as it does not have a set_fn.")
-            set_fn(x, value)
-            if len(x) != dtype.bitlength:
-                raise CreationError(f"Can't initialise with value of length {len(x)} bits, "
-                                    f"as attribute has length of {dtype.bitlength} bits.")
-            self._bitstore = x._bitstore
-            return
-
-    def __iadd__(self, bs: BitsType) -> BitArray:
-        """Append bs to current bitstring. Return self.
-
-        bs -- the bitstring to append.
-
-        """
-        self._append(bs)
-        return self
-
-    def __copy__(self) -> BitArray:
-        """Return a new copy of the BitArray."""
-        s_copy = BitArray()
-        s_copy._bitstore = self._bitstore._copy()
-        assert s_copy._bitstore.immutable is False
-        return s_copy
-
-    def _setitem_int(self, key: int, value: Union[BitsType, int]) -> None:
-        if isinstance(value, numbers.Integral):
-            if value == 0:
-                self._bitstore[key] = 0
-                return
-            if value in (1, -1):
-                self._bitstore[key] = 1
-                return
-            raise ValueError(f"Cannot set a single bit with integer {value}.")
-        try:
-            value = self._create_from_bitstype(value)
-        except TypeError:
-            raise TypeError(f"Bitstring, integer or string expected. Got {type(value)}.")
-        positive_key = key + len(self) if key < 0 else key
-        if positive_key < 0 or positive_key >= len(self._bitstore):
-            raise IndexError(f"Bit position {key} out of range.")
-        self._bitstore[positive_key: positive_key + 1] = value._bitstore
-
-    def _setitem_slice(self, key: slice, value: BitsType) -> None:
-        if isinstance(value, numbers.Integral):
-            if key.step not in [None, -1, 1]:
-                if value in [0, 1]:
-                    self.set(value, range(*key.indices(len(self))))
-                    return
-                else:
-                    raise ValueError("Can't assign an integer except 0 or 1 to a slice with a step value.")
-            # To find the length we first get the slice
-            s = self._bitstore.getslice(key.start, key.stop)
-            length = len(s)
-            # Now create an int of the correct length
-            if value >= 0:
-                value = self.__class__(uint=value, length=length)
-            else:
-                value = self.__class__(int=value, length=length)
-        else:
-            try:
-                value = self._create_from_bitstype(value)
-            except TypeError:
-                raise TypeError(f"Bitstring, integer or string expected. Got {type(value)}.")
-        self._bitstore.__setitem__(key, value._bitstore)
-
-    def __setitem__(self, key: Union[slice, int], value: BitsType) -> None:
-        if isinstance(key, numbers.Integral):
-            self._setitem_int(key, value)
-        else:
-            self._setitem_slice(key, value)
-
-    def __delitem__(self, key: Union[slice, int]) -> None:
-        """Delete item or range.
-
-        >>> a = BitArray('0x001122')
-        >>> del a[8:16]
-        >>> print a
-        0x0022
-
-        """
-        self._bitstore.__delitem__(key)
-        return
-
-    def __ilshift__(self: TBits, n: int) -> TBits:
-        """Shift bits by n to the left in place. Return self.
-
-        n -- the number of bits to shift. Must be >= 0.
-
-        """
-        if n < 0:
-            raise ValueError("Cannot shift by a negative amount.")
-        if not len(self):
-            raise ValueError("Cannot shift an empty bitstring.")
-        if not n:
-            return self
-        n = min(n, len(self))
-        return self._ilshift(n)
-
-    def __irshift__(self: TBits, n: int) -> TBits:
-        """Shift bits by n to the right in place. Return self.
-
-        n -- the number of bits to shift. Must be >= 0.
-
-        """
-        if n < 0:
-            raise ValueError("Cannot shift by a negative amount.")
-        if not len(self):
-            raise ValueError("Cannot shift an empty bitstring.")
-        if not n:
-            return self
-        n = min(n, len(self))
-        return self._irshift(n)
-
-    def __imul__(self: TBits, n: int) -> TBits:
-        """Concatenate n copies of self in place. Return self.
-
-        Called for expressions of the form 'a *= 3'.
-        n -- The number of concatenations. Must be >= 0.
-
-        """
-        if n < 0:
-            raise ValueError("Cannot multiply by a negative integer.")
-        return self._imul(n)
-
-    def __ior__(self: TBits, bs: BitsType) -> TBits:
-        bs = self._create_from_bitstype(bs)
-        self._bitstore |= bs._bitstore
-        return self
-
-    def __iand__(self: TBits, bs: BitsType) -> TBits:
-        bs = self._create_from_bitstype(bs)
-        self._bitstore &= bs._bitstore
-        return self
-
-    def __ixor__(self: TBits, bs: BitsType) -> TBits:
-        bs = self._create_from_bitstype(bs)
-        self._bitstore ^= bs._bitstore
-        return self
-
-    def _replace(self, old: Bits, new: Bits, start: int, end: int, count: int, bytealigned: Optional[bool]) -> int:
-        if bytealigned is None:
-            bytealigned = bitstring.options.bytealigned
-        # First find all the places where we want to do the replacements
-        starting_points: List[int] = []
-        for x in self.findall(old, start, end, bytealigned=bytealigned):
-            if not starting_points:
-                starting_points.append(x)
-            elif x >= starting_points[-1] + len(old):
-                # Can only replace here if it hasn't already been replaced!
-                starting_points.append(x)
-            if count != 0 and len(starting_points) == count:
-                break
-        if not starting_points:
-            return 0
-        replacement_list = [self._bitstore.getslice(0, starting_points[0])]
-        for i in range(len(starting_points) - 1):
-            replacement_list.append(new._bitstore)
-            replacement_list.append(
-                self._bitstore.getslice(starting_points[i] + len(old), starting_points[i + 1]))
-        # Final replacement
-        replacement_list.append(new._bitstore)
-        replacement_list.append(self._bitstore.getslice(starting_points[-1] + len(old), None))
-        if bitstring.options.lsb0:
-            # Addition of bitarray is always on the right, so assemble from other end
-            replacement_list.reverse()
-        self._bitstore.clear()
-        for r in replacement_list:
-            self._bitstore += r
-        return len(starting_points)
-
-    def replace(self, old: BitsType, new: BitsType, start: Optional[int] = None, end: Optional[int] = None,
-                count: Optional[int] = None, bytealigned: Optional[bool] = None) -> int:
-        """Replace all occurrences of old with new in place.
-
-        Returns number of replacements made.
-
-        old -- The bitstring to replace.
-        new -- The replacement bitstring.
-        start -- Any occurrences that start before this will not be replaced.
-                 Defaults to 0.
-        end -- Any occurrences that finish after this will not be replaced.
-               Defaults to len(self).
-        count -- The maximum number of replacements to make. Defaults to
-                 replace all occurrences.
-        bytealigned -- If True replacements will only be made on byte
-                       boundaries.
-
-        Raises ValueError if old is empty or if start or end are
-        out of range.
-
-        """
-        if count == 0:
-            return 0
-        old = self._create_from_bitstype(old)
-        new = self._create_from_bitstype(new)
-        if len(old) == 0:
-            raise ValueError("Empty bitstring cannot be replaced.")
-        start, end = self._validate_slice(start, end)
-
-        if new is self:
-            # Prevent self assignment woes
-            new = copy.copy(self)
-        return self._replace(old, new, start, end, 0 if count is None else count, bytealigned)
-
-    def insert(self, bs: BitsType, pos: int) -> None:
-        """Insert bs at bit position pos.
-
-        bs -- The bitstring to insert.
-        pos -- The bit position to insert at.
-
-        Raises ValueError if pos < 0 or pos > len(self).
-
-        """
-        bs = self._create_from_bitstype(bs)
-        if len(bs) == 0:
-            return
-        if bs is self:
-            bs = self._copy()
-        if pos < 0:
-            pos += len(self)
-        if not 0 <= pos <= len(self):
-            raise ValueError("Invalid insert position.")
-        self._insert(bs, pos)
-
-    def overwrite(self, bs: BitsType, pos: int) -> None:
-        """Overwrite with bs at bit position pos.
-
-        bs -- The bitstring to overwrite with.
-        pos -- The bit position to begin overwriting from.
-
-        Raises ValueError if pos < 0 or pos > len(self).
-
-        """
-        bs = self._create_from_bitstype(bs)
-        if len(bs) == 0:
-            return
-        if pos < 0:
-            pos += len(self)
-        if pos < 0 or pos > len(self):
-            raise ValueError("Overwrite starts outside boundary of bitstring.")
-        self._overwrite(bs, pos)
-
-    def append(self, bs: BitsType) -> None:
-        """Append a bitstring to the current bitstring.
-
-        bs -- The bitstring to append.
-
-        """
-        self._append(bs)
-
-    def prepend(self, bs: BitsType) -> None:
-        """Prepend a bitstring to the current bitstring.
-
-        bs -- The bitstring to prepend.
-
-        """
-        self._prepend(bs)
-
-    def _append_msb0(self, bs: BitsType) -> None:
-        self._addright(self._create_from_bitstype(bs))
-
-    def _append_lsb0(self, bs: BitsType) -> None:
-        bs = self._create_from_bitstype(bs)
-        self._addleft(bs)
-
-    def reverse(self, start: Optional[int] = None, end: Optional[int] = None) -> None:
-        """Reverse bits in-place.
-
-        start -- Position of first bit to reverse. Defaults to 0.
-        end -- One past the position of the last bit to reverse.
-               Defaults to len(self).
-
-        Using on an empty bitstring will have no effect.
-
-        Raises ValueError if start < 0, end > len(self) or end < start.
-
-        """
-        start, end = self._validate_slice(start, end)
-        if start == 0 and end == len(self):
-            self._bitstore.reverse()
-            return
-        s = self._slice(start, end)
-        s._bitstore.reverse()
-        self[start:end] = s
-
-    def set(self, value: Any, pos: Optional[Union[int, Iterable[int]]] = None) -> None:
-        """Set one or many bits to 1 or 0.
-
-        value -- If bool(value) is True bits are set to 1, otherwise they are set to 0.
-        pos -- Either a single bit position or an iterable of bit positions.
-               Negative numbers are treated in the same way as slice indices.
-               Defaults to the entire bitstring.
-
-        Raises IndexError if pos < -len(self) or pos >= len(self).
-
-        """
-        if pos is None:
-            # Set all bits to either 1 or 0
-            self._setint(-1 if value else 0)
-            return
-        if not isinstance(pos, abc.Iterable):
-            pos = (pos,)
-        v = 1 if value else 0
-        if isinstance(pos, range):
-            self._bitstore.__setitem__(slice(pos.start, pos.stop, pos.step), v)
-            return
-        for p in pos:
-            self._bitstore[p] = v
-
-    def invert(self, pos: Optional[Union[Iterable[int], int]] = None) -> None:
-        """Invert one or many bits from 0 to 1 or vice versa.
-
-        pos -- Either a single bit position or an iterable of bit positions.
-               Negative numbers are treated in the same way as slice indices.
-
-        Raises IndexError if pos < -len(self) or pos >= len(self).
-
-        """
-        if pos is None:
-            self._invert_all()
-            return
-        if not isinstance(pos, abc.Iterable):
-            pos = (pos,)
-        length = len(self)
-
-        for p in pos:
-            if p < 0:
-                p += length
-            if not 0 <= p < length:
-                raise IndexError(f"Bit position {p} out of range.")
-            self._invert(p)
-
-    def ror(self, bits: int, start: Optional[int] = None, end: Optional[int] = None) -> None:
-        """Rotate bits to the right in-place.
-
-        bits -- The number of bits to rotate by.
-        start -- Start of slice to rotate. Defaults to 0.
-        end -- End of slice to rotate. Defaults to len(self).
-
-        Raises ValueError if bits < 0.
-
-        """
-        if not len(self):
-            raise Error("Cannot rotate an empty bitstring.")
-        if bits < 0:
-            raise ValueError("Cannot rotate by negative amount.")
-        self._ror(bits, start, end)
-
-    def _ror_msb0(self, bits: int, start: Optional[int] = None, end: Optional[int] = None) -> None:
-        start, end = self._validate_slice(start, end)  # the _slice deals with msb0/lsb0
-        bits %= (end - start)
-        if not bits:
-            return
-        rhs = self._slice(end - bits, end)
-        self._delete(bits, end - bits)
-        self._insert(rhs, start)
-
-    def rol(self, bits: int, start: Optional[int] = None, end: Optional[int] = None) -> None:
-        """Rotate bits to the left in-place.
-
-        bits -- The number of bits to rotate by.
-        start -- Start of slice to rotate. Defaults to 0.
-        end -- End of slice to rotate. Defaults to len(self).
-
-        Raises ValueError if bits < 0.
-
-        """
-        if not len(self):
-            raise Error("Cannot rotate an empty bitstring.")
-        if bits < 0:
-            raise ValueError("Cannot rotate by negative amount.")
-        self._rol(bits, start, end)
-
-    def _rol_msb0(self, bits: int, start: Optional[int] = None, end: Optional[int] = None):
-        start, end = self._validate_slice(start, end)
-        bits %= (end - start)
-        if bits == 0:
-            return
-        lhs = self._slice(start, start + bits)
-        self._delete(bits, start)
-        self._insert(lhs, end - bits)
-
-    def byteswap(self, fmt: Optional[Union[int, Iterable[int], str]] = None, start: Optional[int] = None,
-                 end: Optional[int] = None, repeat: bool = True) -> int:
-        """Change the endianness in-place. Return number of repeats of fmt done.
-
-        fmt -- A compact structure string, an integer number of bytes or
-               an iterable of integers. Defaults to 0, which byte reverses the
-               whole bitstring.
-        start -- Start bit position, defaults to 0.
-        end -- End bit position, defaults to len(self).
-        repeat -- If True (the default) the byte swapping pattern is repeated
-                  as much as possible.
-
-        """
-        start_v, end_v = self._validate_slice(start, end)
-        if fmt is None or fmt == 0:
-            # reverse all of the whole bytes.
-            bytesizes = [(end_v - start_v) // 8]
-        elif isinstance(fmt, numbers.Integral):
-            if fmt < 0:
-                raise ValueError(f"Improper byte length {fmt}.")
-            bytesizes = [fmt]
-        elif isinstance(fmt, str):
-            if not (m := utils.BYTESWAP_STRUCT_PACK_RE.match(fmt)):
-                raise ValueError(f"Cannot parse format string {fmt}.")
-            # Split the format string into a list of 'q', '4h' etc.
-            formatlist = re.findall(utils.STRUCT_SPLIT_RE, m.group('fmt'))
-            # Now deal with multiplicative factors, 4h -> hhhh etc.
-            bytesizes = []
-            for f in formatlist:
-                if len(f) == 1:
-                    bytesizes.append(utils.PACK_CODE_SIZE[f])
-                else:
-                    bytesizes.extend([utils.PACK_CODE_SIZE[f[-1]]] * int(f[:-1]))
-        elif isinstance(fmt, abc.Iterable):
-            bytesizes = fmt
-            for bytesize in bytesizes:
-                if not isinstance(bytesize, numbers.Integral) or bytesize < 0:
-                    raise ValueError(f"Improper byte length {bytesize}.")
-        else:
-            raise TypeError("Format must be an integer, string or iterable.")
-
-        repeats = 0
-        totalbitsize: int = 8 * sum(bytesizes)
-        if not totalbitsize:
-            return 0
-        if repeat:
-            # Try to repeat up to the end of the bitstring.
-            finalbit = end_v
-        else:
-            # Just try one (set of) byteswap(s).
-            finalbit = start_v + totalbitsize
-        for patternend in range(start_v + totalbitsize, finalbit + 1, totalbitsize):
-            bytestart = patternend - totalbitsize
-            for bytesize in bytesizes:
-                byteend = bytestart + bytesize * 8
-                self._reversebytes(bytestart, byteend)
-                bytestart += bytesize * 8
-            repeats += 1
-        return repeats
-
-    def clear(self) -> None:
-        """Remove all bits, reset to zero length."""
-        self._clear()
-
-
+from __future__ import annotations
+
+import copy
+import numbers
+import re
+from collections import abc
+from typing import Union, List, Iterable, Any, Optional
+from bitstring import utils
+from bitstring.exceptions import CreationError, Error
+from bitstring.bits import Bits, BitsType, TBits
+
+import bitstring.dtypes
+
+class BitArray(Bits):
+    """A container holding a mutable sequence of bits.
+
+    Subclass of the immutable Bits class. Inherits all of its
+    methods (except __hash__) and adds mutating methods.
+
+    Mutating methods:
+
+    append() -- Append a bitstring.
+    byteswap() -- Change byte endianness in-place.
+    clear() -- Remove all bits from the bitstring.
+    insert() -- Insert a bitstring.
+    invert() -- Flip bit(s) between one and zero.
+    overwrite() -- Overwrite a section with a new bitstring.
+    prepend() -- Prepend a bitstring.
+    replace() -- Replace occurrences of one bitstring with another.
+    reverse() -- Reverse bits in-place.
+    rol() -- Rotate bits to the left.
+    ror() -- Rotate bits to the right.
+    set() -- Set bit(s) to 1 or 0.
+
+    Methods inherited from Bits:
+
+    all() -- Check if all specified bits are set to 1 or 0.
+    any() -- Check if any of specified bits are set to 1 or 0.
+    copy() -- Return a copy of the bitstring.
+    count() -- Count the number of bits set to 1 or 0.
+    cut() -- Create generator of constant sized chunks.
+    endswith() -- Return whether the bitstring ends with a sub-string.
+    find() -- Find a sub-bitstring in the current bitstring.
+    findall() -- Find all occurrences of a sub-bitstring in the current bitstring.
+    fromstring() -- Create a bitstring from a formatted string.
+    join() -- Join bitstrings together using current bitstring.
+    pp() -- Pretty print the bitstring.
+    rfind() -- Seek backwards to find a sub-bitstring.
+    split() -- Create generator of chunks split by a delimiter.
+    startswith() -- Return whether the bitstring starts with a sub-bitstring.
+    tobitarray() -- Return bitstring as a bitarray from the bitarray package.
+    tobytes() -- Return bitstring as bytes, padding if needed.
+    tofile() -- Write bitstring to file, padding if needed.
+    unpack() -- Interpret bits using format string.
+
+    Special methods:
+
+    Mutating operators are available: [], <<=, >>=, +=, *=, &=, |= and ^=
+    in addition to the inherited [], ==, !=, +, *, ~, <<, >>, &, | and ^.
+
+    Properties:
+
+    [GENERATED_PROPERTY_DESCRIPTIONS]
+
+    len -- Length of the bitstring in bits.
+
+    """
+
+    __slots__ = ()
+
+    # As BitArray objects are mutable, we shouldn't allow them to be hashed.
+    __hash__: None = None
+
+
+    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,
+                 offset: Optional[int] = None, **kwargs) -> None:
+        """Either specify an 'auto' initialiser:
+        A string of comma separated tokens, an integer, a file object,
+        a bytearray, a boolean iterable or another bitstring.
+
+        Or initialise via **kwargs with one (and only one) of:
+        bin -- binary string representation, e.g. '0b001010'.
+        hex -- hexadecimal string representation, e.g. '0x2ef'
+        oct -- octal string representation, e.g. '0o777'.
+        bytes -- raw data as a bytes object, for example read from a binary file.
+        int -- a signed integer.
+        uint -- an unsigned integer.
+        float / floatbe -- a big-endian floating point number.
+        bool -- a boolean (True or False).
+        se -- a signed exponential-Golomb code.
+        ue -- an unsigned exponential-Golomb code.
+        sie -- a signed interleaved exponential-Golomb code.
+        uie -- an unsigned interleaved exponential-Golomb code.
+        floatle -- a little-endian floating point number.
+        floatne -- a native-endian floating point number.
+        bfloat / bfloatbe - a big-endian bfloat format 16-bit floating point number.
+        bfloatle -- a little-endian bfloat format 16-bit floating point number.
+        bfloatne -- a native-endian bfloat format 16-bit floating point number.
+        intbe -- a signed big-endian whole byte integer.
+        intle -- a signed little-endian whole byte integer.
+        intne -- a signed native-endian whole byte integer.
+        uintbe -- an unsigned big-endian whole byte integer.
+        uintle -- an unsigned little-endian whole byte integer.
+        uintne -- an unsigned native-endian whole byte integer.
+        filename -- the path of a file which will be opened in binary read-only mode.
+
+        Other keyword arguments:
+        length -- length of the bitstring in bits, if needed and appropriate.
+                  It must be supplied for all integer and float initialisers.
+        offset -- bit offset to the data. These offset bits are
+                  ignored and this is intended for use when
+                  initialising using 'bytes' or 'filename'.
+
+        """
+        if self._bitstore.immutable:
+            self._bitstore = self._bitstore._copy()
+            self._bitstore.immutable = False
+
+    def copy(self: TBits) -> TBits:
+        """Return a copy of the bitstring."""
+        return self.__copy__()
+
+    def __setattr__(self, attribute, value) -> None:
+        try:
+            # First try the ordinary attribute setter
+            super().__setattr__(attribute, value)
+        except AttributeError:
+            dtype = bitstring.dtypes.Dtype(attribute)
+            x = object.__new__(Bits)
+            if (set_fn := dtype.set_fn) is None:
+                raise AttributeError(f"Cannot set attribute '{attribute}' as it does not have a set_fn.")
+            set_fn(x, value)
+            if len(x) != dtype.bitlength:
+                raise CreationError(f"Can't initialise with value of length {len(x)} bits, "
+                                    f"as attribute has length of {dtype.bitlength} bits.")
+            self._bitstore = x._bitstore
+            return
+
+    def __iadd__(self, bs: BitsType) -> BitArray:
+        """Append bs to current bitstring. Return self.
+
+        bs -- the bitstring to append.
+
+        """
+        self._append(bs)
+        return self
+
+    def __copy__(self) -> BitArray:
+        """Return a new copy of the BitArray."""
+        s_copy = BitArray()
+        s_copy._bitstore = self._bitstore._copy()
+        assert s_copy._bitstore.immutable is False
+        return s_copy
+
+    def _setitem_int(self, key: int, value: Union[BitsType, int]) -> None:
+        if isinstance(value, numbers.Integral):
+            if value == 0:
+                self._bitstore[key] = 0
+                return
+            if value in (1, -1):
+                self._bitstore[key] = 1
+                return
+            raise ValueError(f"Cannot set a single bit with integer {value}.")
+        try:
+            value = self._create_from_bitstype(value)
+        except TypeError:
+            raise TypeError(f"Bitstring, integer or string expected. Got {type(value)}.")
+        positive_key = key + len(self) if key < 0 else key
+        if positive_key < 0 or positive_key >= len(self._bitstore):
+            raise IndexError(f"Bit position {key} out of range.")
+        self._bitstore[positive_key: positive_key + 1] = value._bitstore
+
+    def _setitem_slice(self, key: slice, value: BitsType) -> None:
+        if isinstance(value, numbers.Integral):
+            if key.step not in [None, -1, 1]:
+                if value in [0, 1]:
+                    self.set(value, range(*key.indices(len(self))))
+                    return
+                else:
+                    raise ValueError("Can't assign an integer except 0 or 1 to a slice with a step value.")
+            # To find the length we first get the slice
+            s = self._bitstore.getslice(key.start, key.stop)
+            length = len(s)
+            # Now create an int of the correct length
+            if value >= 0:
+                value = self.__class__(uint=value, length=length)
+            else:
+                value = self.__class__(int=value, length=length)
+        else:
+            try:
+                value = self._create_from_bitstype(value)
+            except TypeError:
+                raise TypeError(f"Bitstring, integer or string expected. Got {type(value)}.")
+        self._bitstore.__setitem__(key, value._bitstore)
+
+    def __setitem__(self, key: Union[slice, int], value: BitsType) -> None:
+        if isinstance(key, numbers.Integral):
+            self._setitem_int(key, value)
+        else:
+            self._setitem_slice(key, value)
+
+    def __delitem__(self, key: Union[slice, int]) -> None:
+        """Delete item or range.
+
+        >>> a = BitArray('0x001122')
+        >>> del a[8:16]
+        >>> print a
+        0x0022
+
+        """
+        self._bitstore.__delitem__(key)
+        return
+
+    def __ilshift__(self: TBits, n: int) -> TBits:
+        """Shift bits by n to the left in place. Return self.
+
+        n -- the number of bits to shift. Must be >= 0.
+
+        """
+        if n < 0:
+            raise ValueError("Cannot shift by a negative amount.")
+        if not len(self):
+            raise ValueError("Cannot shift an empty bitstring.")
+        if not n:
+            return self
+        n = min(n, len(self))
+        return self._ilshift(n)
+
+    def __irshift__(self: TBits, n: int) -> TBits:
+        """Shift bits by n to the right in place. Return self.
+
+        n -- the number of bits to shift. Must be >= 0.
+
+        """
+        if n < 0:
+            raise ValueError("Cannot shift by a negative amount.")
+        if not len(self):
+            raise ValueError("Cannot shift an empty bitstring.")
+        if not n:
+            return self
+        n = min(n, len(self))
+        return self._irshift(n)
+
+    def __imul__(self: TBits, n: int) -> TBits:
+        """Concatenate n copies of self in place. Return self.
+
+        Called for expressions of the form 'a *= 3'.
+        n -- The number of concatenations. Must be >= 0.
+
+        """
+        if n < 0:
+            raise ValueError("Cannot multiply by a negative integer.")
+        return self._imul(n)
+
+    def __ior__(self: TBits, bs: BitsType) -> TBits:
+        bs = self._create_from_bitstype(bs)
+        self._bitstore |= bs._bitstore
+        return self
+
+    def __iand__(self: TBits, bs: BitsType) -> TBits:
+        bs = self._create_from_bitstype(bs)
+        self._bitstore &= bs._bitstore
+        return self
+
+    def __ixor__(self: TBits, bs: BitsType) -> TBits:
+        bs = self._create_from_bitstype(bs)
+        self._bitstore ^= bs._bitstore
+        return self
+
+    def _replace(self, old: Bits, new: Bits, start: int, end: int, count: int, bytealigned: Optional[bool]) -> int:
+        if bytealigned is None:
+            bytealigned = bitstring.options.bytealigned
+        # First find all the places where we want to do the replacements
+        starting_points: List[int] = []
+        for x in self.findall(old, start, end, bytealigned=bytealigned):
+            if not starting_points:
+                starting_points.append(x)
+            elif x >= starting_points[-1] + len(old):
+                # Can only replace here if it hasn't already been replaced!
+                starting_points.append(x)
+            if count != 0 and len(starting_points) == count:
+                break
+        if not starting_points:
+            return 0
+        replacement_list = [self._bitstore.getslice(0, starting_points[0])]
+        for i in range(len(starting_points) - 1):
+            replacement_list.append(new._bitstore)
+            replacement_list.append(
+                self._bitstore.getslice(starting_points[i] + len(old), starting_points[i + 1]))
+        # Final replacement
+        replacement_list.append(new._bitstore)
+        replacement_list.append(self._bitstore.getslice(starting_points[-1] + len(old), None))
+        if bitstring.options.lsb0:
+            # Addition of bitarray is always on the right, so assemble from other end
+            replacement_list.reverse()
+        self._bitstore.clear()
+        for r in replacement_list:
+            self._bitstore += r
+        return len(starting_points)
+
+    def replace(self, old: BitsType, new: BitsType, start: Optional[int] = None, end: Optional[int] = None,
+                count: Optional[int] = None, bytealigned: Optional[bool] = None) -> int:
+        """Replace all occurrences of old with new in place.
+
+        Returns number of replacements made.
+
+        old -- The bitstring to replace.
+        new -- The replacement bitstring.
+        start -- Any occurrences that start before this will not be replaced.
+                 Defaults to 0.
+        end -- Any occurrences that finish after this will not be replaced.
+               Defaults to len(self).
+        count -- The maximum number of replacements to make. Defaults to
+                 replace all occurrences.
+        bytealigned -- If True replacements will only be made on byte
+                       boundaries.
+
+        Raises ValueError if old is empty or if start or end are
+        out of range.
+
+        """
+        if count == 0:
+            return 0
+        old = self._create_from_bitstype(old)
+        new = self._create_from_bitstype(new)
+        if len(old) == 0:
+            raise ValueError("Empty bitstring cannot be replaced.")
+        start, end = self._validate_slice(start, end)
+
+        if new is self:
+            # Prevent self assignment woes
+            new = copy.copy(self)
+        return self._replace(old, new, start, end, 0 if count is None else count, bytealigned)
+
+    def insert(self, bs: BitsType, pos: int) -> None:
+        """Insert bs at bit position pos.
+
+        bs -- The bitstring to insert.
+        pos -- The bit position to insert at.
+
+        Raises ValueError if pos < 0 or pos > len(self).
+
+        """
+        bs = self._create_from_bitstype(bs)
+        if len(bs) == 0:
+            return
+        if bs is self:
+            bs = self._copy()
+        if pos < 0:
+            pos += len(self)
+        if not 0 <= pos <= len(self):
+            raise ValueError("Invalid insert position.")
+        self._insert(bs, pos)
+
+    def overwrite(self, bs: BitsType, pos: int) -> None:
+        """Overwrite with bs at bit position pos.
+
+        bs -- The bitstring to overwrite with.
+        pos -- The bit position to begin overwriting from.
+
+        Raises ValueError if pos < 0 or pos > len(self).
+
+        """
+        bs = self._create_from_bitstype(bs)
+        if len(bs) == 0:
+            return
+        if pos < 0:
+            pos += len(self)
+        if pos < 0 or pos > len(self):
+            raise ValueError("Overwrite starts outside boundary of bitstring.")
+        self._overwrite(bs, pos)
+
+    def append(self, bs: BitsType) -> None:
+        """Append a bitstring to the current bitstring.
+
+        bs -- The bitstring to append.
+
+        """
+        self._append(bs)
+
+    def prepend(self, bs: BitsType) -> None:
+        """Prepend a bitstring to the current bitstring.
+
+        bs -- The bitstring to prepend.
+
+        """
+        self._prepend(bs)
+
+    def _append_msb0(self, bs: BitsType) -> None:
+        self._addright(self._create_from_bitstype(bs))
+
+    def _append_lsb0(self, bs: BitsType) -> None:
+        bs = self._create_from_bitstype(bs)
+        self._addleft(bs)
+
+    def reverse(self, start: Optional[int] = None, end: Optional[int] = None) -> None:
+        """Reverse bits in-place.
+
+        start -- Position of first bit to reverse. Defaults to 0.
+        end -- One past the position of the last bit to reverse.
+               Defaults to len(self).
+
+        Using on an empty bitstring will have no effect.
+
+        Raises ValueError if start < 0, end > len(self) or end < start.
+
+        """
+        start, end = self._validate_slice(start, end)
+        if start == 0 and end == len(self):
+            self._bitstore.reverse()
+            return
+        s = self._slice(start, end)
+        s._bitstore.reverse()
+        self[start:end] = s
+
+    def set(self, value: Any, pos: Optional[Union[int, Iterable[int]]] = None) -> None:
+        """Set one or many bits to 1 or 0.
+
+        value -- If bool(value) is True bits are set to 1, otherwise they are set to 0.
+        pos -- Either a single bit position or an iterable of bit positions.
+               Negative numbers are treated in the same way as slice indices.
+               Defaults to the entire bitstring.
+
+        Raises IndexError if pos < -len(self) or pos >= len(self).
+
+        """
+        if pos is None:
+            # Set all bits to either 1 or 0
+            self._setint(-1 if value else 0)
+            return
+        if not isinstance(pos, abc.Iterable):
+            pos = (pos,)
+        v = 1 if value else 0
+        if isinstance(pos, range):
+            self._bitstore.__setitem__(slice(pos.start, pos.stop, pos.step), v)
+            return
+        for p in pos:
+            self._bitstore[p] = v
+
+    def invert(self, pos: Optional[Union[Iterable[int], int]] = None) -> None:
+        """Invert one or many bits from 0 to 1 or vice versa.
+
+        pos -- Either a single bit position or an iterable of bit positions.
+               Negative numbers are treated in the same way as slice indices.
+
+        Raises IndexError if pos < -len(self) or pos >= len(self).
+
+        """
+        if pos is None:
+            self._invert_all()
+            return
+        if not isinstance(pos, abc.Iterable):
+            pos = (pos,)
+        length = len(self)
+
+        for p in pos:
+            if p < 0:
+                p += length
+            if not 0 <= p < length:
+                raise IndexError(f"Bit position {p} out of range.")
+            self._invert(p)
+
+    def ror(self, bits: int, start: Optional[int] = None, end: Optional[int] = None) -> None:
+        """Rotate bits to the right in-place.
+
+        bits -- The number of bits to rotate by.
+        start -- Start of slice to rotate. Defaults to 0.
+        end -- End of slice to rotate. Defaults to len(self).
+
+        Raises ValueError if bits < 0.
+
+        """
+        if not len(self):
+            raise Error("Cannot rotate an empty bitstring.")
+        if bits < 0:
+            raise ValueError("Cannot rotate by negative amount.")
+        self._ror(bits, start, end)
+
+    def _ror_msb0(self, bits: int, start: Optional[int] = None, end: Optional[int] = None) -> None:
+        start, end = self._validate_slice(start, end)  # the _slice deals with msb0/lsb0
+        bits %= (end - start)
+        if not bits:
+            return
+        rhs = self._slice(end - bits, end)
+        self._delete(bits, end - bits)
+        self._insert(rhs, start)
+
+    def rol(self, bits: int, start: Optional[int] = None, end: Optional[int] = None) -> None:
+        """Rotate bits to the left in-place.
+
+        bits -- The number of bits to rotate by.
+        start -- Start of slice to rotate. Defaults to 0.
+        end -- End of slice to rotate. Defaults to len(self).
+
+        Raises ValueError if bits < 0.
+
+        """
+        if not len(self):
+            raise Error("Cannot rotate an empty bitstring.")
+        if bits < 0:
+            raise ValueError("Cannot rotate by negative amount.")
+        self._rol(bits, start, end)
+
+    def _rol_msb0(self, bits: int, start: Optional[int] = None, end: Optional[int] = None):
+        start, end = self._validate_slice(start, end)
+        bits %= (end - start)
+        if bits == 0:
+            return
+        lhs = self._slice(start, start + bits)
+        self._delete(bits, start)
+        self._insert(lhs, end - bits)
+
+    def byteswap(self, fmt: Optional[Union[int, Iterable[int], str]] = None, start: Optional[int] = None,
+                 end: Optional[int] = None, repeat: bool = True) -> int:
+        """Change the endianness in-place. Return number of repeats of fmt done.
+
+        fmt -- A compact structure string, an integer number of bytes or
+               an iterable of integers. Defaults to 0, which byte reverses the
+               whole bitstring.
+        start -- Start bit position, defaults to 0.
+        end -- End bit position, defaults to len(self).
+        repeat -- If True (the default) the byte swapping pattern is repeated
+                  as much as possible.
+
+        """
+        start_v, end_v = self._validate_slice(start, end)
+        if fmt is None or fmt == 0:
+            # reverse all of the whole bytes.
+            bytesizes = [(end_v - start_v) // 8]
+        elif isinstance(fmt, numbers.Integral):
+            if fmt < 0:
+                raise ValueError(f"Improper byte length {fmt}.")
+            bytesizes = [fmt]
+        elif isinstance(fmt, str):
+            if not (m := utils.BYTESWAP_STRUCT_PACK_RE.match(fmt)):
+                raise ValueError(f"Cannot parse format string {fmt}.")
+            # Split the format string into a list of 'q', '4h' etc.
+            formatlist = re.findall(utils.STRUCT_SPLIT_RE, m.group('fmt'))
+            # Now deal with multiplicative factors, 4h -> hhhh etc.
+            bytesizes = []
+            for f in formatlist:
+                if len(f) == 1:
+                    bytesizes.append(utils.PACK_CODE_SIZE[f])
+                else:
+                    bytesizes.extend([utils.PACK_CODE_SIZE[f[-1]]] * int(f[:-1]))
+        elif isinstance(fmt, abc.Iterable):
+            bytesizes = fmt
+            for bytesize in bytesizes:
+                if not isinstance(bytesize, numbers.Integral) or bytesize < 0:
+                    raise ValueError(f"Improper byte length {bytesize}.")
+        else:
+            raise TypeError("Format must be an integer, string or iterable.")
+
+        repeats = 0
+        totalbitsize: int = 8 * sum(bytesizes)
+        if not totalbitsize:
+            return 0
+        if repeat:
+            # Try to repeat up to the end of the bitstring.
+            finalbit = end_v
+        else:
+            # Just try one (set of) byteswap(s).
+            finalbit = start_v + totalbitsize
+        for patternend in range(start_v + totalbitsize, finalbit + 1, totalbitsize):
+            bytestart = patternend - totalbitsize
+            for bytesize in bytesizes:
+                byteend = bytestart + bytesize * 8
+                self._reversebytes(bytestart, byteend)
+                bytestart += bytesize * 8
+            repeats += 1
+        return repeats
+
+    def clear(self) -> None:
+        """Remove all bits, reset to zero length."""
+        self._clear()
+
+
```

### Comparing `bitstring-4.2.1/bitstring/bits.py` & `bitstring-4.2.2/bitstring/bits.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,1789 +1,1788 @@
-from __future__ import annotations
-
-import numbers
-import pathlib
-import sys
-import mmap
-import struct
-import array
-import io
-from collections import abc
-import functools
-from typing import Tuple, Union, List, Iterable, Any, Optional, BinaryIO, TextIO, overload, Iterator, Type, TypeVar
-import bitarray
-import bitarray.util
-import bitstring
-from bitstring.bitstore import BitStore
-from bitstring import bitstore_helpers, utils
-from bitstring.dtypes import Dtype, dtype_register
-from bitstring.fp8 import p4binary_fmt, p3binary_fmt
-from bitstring.mxfp import e3m2mxfp_fmt, e2m3mxfp_fmt, e2m1mxfp_fmt, e4m3mxfp_saturate_fmt, e5m2mxfp_saturate_fmt
-from bitstring.bitstring_options import Colour
-
-# Things that can be converted to Bits when a Bits type is needed
-BitsType = Union['Bits', str, Iterable[Any], bool, BinaryIO, bytearray, bytes, memoryview, bitarray.bitarray]
-
-TBits = TypeVar("TBits", bound='Bits')
-
-# Maximum number of digits to use in __str__ and __repr__.
-MAX_CHARS: int = 250
-
-
-class Bits:
-    """A container holding an immutable sequence of bits.
-
-    For a mutable container use the BitArray class instead.
-
-    Methods:
-
-    all() -- Check if all specified bits are set to 1 or 0.
-    any() -- Check if any of specified bits are set to 1 or 0.
-    copy() - Return a copy of the bitstring.
-    count() -- Count the number of bits set to 1 or 0.
-    cut() -- Create generator of constant sized chunks.
-    endswith() -- Return whether the bitstring ends with a sub-string.
-    find() -- Find a sub-bitstring in the current bitstring.
-    findall() -- Find all occurrences of a sub-bitstring in the current bitstring.
-    fromstring() -- Create a bitstring from a formatted string.
-    join() -- Join bitstrings together using current bitstring.
-    pp() -- Pretty print the bitstring.
-    rfind() -- Seek backwards to find a sub-bitstring.
-    split() -- Create generator of chunks split by a delimiter.
-    startswith() -- Return whether the bitstring starts with a sub-bitstring.
-    tobitarray() -- Return bitstring as a bitarray from the bitarray package.
-    tobytes() -- Return bitstring as bytes, padding if needed.
-    tofile() -- Write bitstring to file, padding if needed.
-    unpack() -- Interpret bits using format string.
-
-    Special methods:
-
-    Also available are the operators [], ==, !=, +, *, ~, <<, >>, &, |, ^.
-
-    Properties:
-
-    [GENERATED_PROPERTY_DESCRIPTIONS]
-
-    len -- Length of the bitstring in bits.
-
-    """
-    __slots__ = ('_bitstore', '_filename')
-
-    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,
-                 offset: Optional[int] = None, **kwargs) -> None:
-        """Either specify an 'auto' initialiser:
-        A string of comma separated tokens, an integer, a file object,
-        a bytearray, a boolean iterable, an array or another bitstring.
-
-        Or initialise via **kwargs with one (and only one) of:
-        bin -- binary string representation, e.g. '0b001010'.
-        hex -- hexadecimal string representation, e.g. '0x2ef'
-        oct -- octal string representation, e.g. '0o777'.
-        bytes -- raw data as a bytes object, for example read from a binary file.
-        int -- a signed integer.
-        uint -- an unsigned integer.
-        float / floatbe -- a big-endian floating point number.
-        bool -- a boolean (True or False).
-        se -- a signed exponential-Golomb code.
-        ue -- an unsigned exponential-Golomb code.
-        sie -- a signed interleaved exponential-Golomb code.
-        uie -- an unsigned interleaved exponential-Golomb code.
-        floatle -- a little-endian floating point number.
-        floatne -- a native-endian floating point number.
-        bfloat / bfloatbe - a big-endian bfloat format 16-bit floating point number.
-        bfloatle -- a little-endian bfloat format 16-bit floating point number.
-        bfloatne -- a native-endian bfloat format 16-bit floating point number.
-        intbe -- a signed big-endian whole byte integer.
-        intle -- a signed little-endian whole byte integer.
-        intne -- a signed native-endian whole byte integer.
-        uintbe -- an unsigned big-endian whole byte integer.
-        uintle -- an unsigned little-endian whole byte integer.
-        uintne -- an unsigned native-endian whole byte integer.
-        filename -- the path of a file which will be opened in binary read-only mode.
-
-        Other keyword arguments:
-        length -- length of the bitstring in bits, if needed and appropriate.
-                  It must be supplied for all integer and float initialisers.
-        offset -- bit offset to the data. These offset bits are
-                  ignored and this is mainly intended for use when
-                  initialising using 'bytes' or 'filename'.
-
-        """
-        self._bitstore.immutable = True
-
-    def __new__(cls: Type[TBits], auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,
-                offset: Optional[int] = None, pos: Optional[int] = None, **kwargs) -> TBits:
-        x = super().__new__(cls)
-        if auto is None and not kwargs:
-            # No initialiser so fill with zero bits up to length
-            if length is not None:
-                x._bitstore = BitStore(length)
-                x._bitstore.setall(0)
-            else:
-                x._bitstore = BitStore()
-            return x
-        x._initialise(auto, length, offset, **kwargs)
-        return x
-
-    @classmethod
-    def _create_from_bitstype(cls: Type[TBits], auto: BitsType, /) -> TBits:
-        if isinstance(auto, Bits):
-            return auto
-        b = super().__new__(cls)
-        b._setauto_no_length_or_offset(auto)
-        return b
-
-    def _initialise(self, auto: Any, /, length: Optional[int], offset: Optional[int], **kwargs) -> None:
-        if auto is not None:
-            if isinstance(auto, numbers.Integral):
-                # Initialise with s zero bits.
-                if auto < 0:
-                    raise bitstring.CreationError(f"Can't create bitstring of negative length {auto}.")
-                self._bitstore = BitStore(int(auto))
-                self._bitstore.setall(0)
-                return
-            self._setauto(auto, length, offset)
-            return
-        k, v = kwargs.popitem()
-        if k == 'bytes':
-            # Special case for bytes as we want to allow offsets and lengths to work only on creation.
-            self._setbytes_with_truncation(v, length, offset)
-            return
-        if k == 'filename':
-            self._setfile(v, length, offset)
-            return
-        if k == 'bitarray':
-            self._setbitarray(v, length, offset)
-            return
-        if k == 'auto':
-            raise bitstring.CreationError(
-                f"The 'auto' parameter should not be given explicitly - just use the first positional argument. "
-                f"Instead of '{self.__class__.__name__}(auto=x)' use '{self.__class__.__name__}(x)'.")
-        if offset is not None:
-            raise bitstring.CreationError("offset cannot be used when initialising with '{k}'.")
-        try:
-            Dtype(k, length).set_fn(self, v)
-        except ValueError as e:
-            raise bitstring.CreationError(e)
-
-    def __getattr__(self, attribute: str) -> Any:
-        # Support for arbitrary attributes like u16 or f64.
-        try:
-            d = Dtype(attribute)
-        except ValueError:
-            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{attribute}'.")
-        if d.bitlength is not None and len(self) != d.bitlength:
-            raise ValueError(f"bitstring length {len(self)} doesn't match length {d.bitlength} of property '{attribute}'.")
-        return d.read_fn(self, 0)
-
-    def __iter__(self) -> Iterable[bool]:
-        return iter(self._bitstore)
-
-    def __copy__(self: TBits) -> TBits:
-        """Return a new copy of the Bits for the copy module."""
-        # Note that if you want a new copy (different ID), use _copy instead.
-        # The copy can return self as it's immutable.
-        return self
-
-    def __lt__(self, other: Any) -> bool:
-        # bitstrings can't really be ordered.
-        return NotImplemented
-
-    def __gt__(self, other: Any) -> bool:
-        return NotImplemented
-
-    def __le__(self, other: Any) -> bool:
-        return NotImplemented
-
-    def __ge__(self, other: Any) -> bool:
-        return NotImplemented
-
-    def __add__(self: TBits, bs: BitsType) -> TBits:
-        """Concatenate bitstrings and return new bitstring.
-
-        bs -- the bitstring to append.
-
-        """
-        bs = self.__class__._create_from_bitstype(bs)
-        s = self._copy() if len(bs) <= len(self) else bs._copy()
-        if len(bs) <= len(self):
-            s._addright(bs)
-        else:
-            s._addleft(self)
-        return s
-
-    def __radd__(self: TBits, bs: BitsType) -> TBits:
-        """Append current bitstring to bs and return new bitstring.
-
-        bs -- An object that can be 'auto' initialised as a bitstring that will be appended to.
-
-        """
-        bs = self.__class__._create_from_bitstype(bs)
-        return bs.__add__(self)
-
-    @overload
-    def __getitem__(self: TBits, key: slice, /) -> TBits:
-        ...
-
-    @overload
-    def __getitem__(self, key: int, /) -> bool:
-        ...
-
-    def __getitem__(self: TBits, key: Union[slice, int], /) -> Union[TBits, bool]:
-        """Return a new bitstring representing a slice of the current bitstring.
-
-        Indices are in units of the step parameter (default 1 bit).
-        Stepping is used to specify the number of bits in each item.
-
-        >>> print(BitArray('0b00110')[1:4])
-        '0b011'
-        >>> print(BitArray('0x00112233')[1:3:8])
-        '0x1122'
-
-        """
-        if isinstance(key, numbers.Integral):
-            return bool(self._bitstore.getindex(key))
-        bs = super().__new__(self.__class__)
-        bs._bitstore = self._bitstore.getslice_withstep(key)
-        return bs
-
-    def __len__(self) -> int:
-        """Return the length of the bitstring in bits."""
-        return self._getlength()
-
-    def __bytes__(self) -> bytes:
-        return self.tobytes()
-
-    def __str__(self) -> str:
-        """Return approximate string representation of bitstring for printing.
-
-        Short strings will be given wholly in hexadecimal or binary. Longer
-        strings may be part hexadecimal and part binary. Very long strings will
-        be truncated with '...'.
-
-        """
-        length = len(self)
-        if not length:
-            return ''
-        if length > MAX_CHARS * 4:
-            # Too long for hex. Truncate...
-            return ''.join(('0x', self[0:MAX_CHARS*4]._gethex(), '...'))
-        # If it's quite short and we can't do hex then use bin
-        if length < 32 and length % 4 != 0:
-            return '0b' + self.bin
-        # If we can use hex then do so
-        if not length % 4:
-            return '0x' + self.hex
-        # Otherwise first we do as much as we can in hex
-        # then add on 1, 2 or 3 bits on at the end
-        bits_at_end = length % 4
-        return ''.join(('0x', self[0:length - bits_at_end]._gethex(),
-                        ', ', '0b', self[length - bits_at_end:]._getbin()))
-
-    def _repr(self, classname: str, length: int, pos: int):
-        pos_string = f', pos={pos}' if pos else ''
-        if hasattr(self, '_filename') and self._filename:
-            return f"{classname}(filename={self._filename!r}, length={length}{pos_string})"
-        else:
-            s = self.__str__()
-            lengthstring = ''
-            if s.endswith('...'):
-                lengthstring = f'  # length={length}'
-            return f"{classname}('{s}'{pos_string}){lengthstring}"
-
-    def __repr__(self) -> str:
-        """Return representation that could be used to recreate the bitstring.
-
-        If the returned string is too long it will be truncated. See __str__().
-
-        """
-        return self._repr(self.__class__.__name__, len(self), 0)
-
-    def __eq__(self, bs: Any, /) -> bool:
-        """Return True if two bitstrings have the same binary representation.
-
-        >>> BitArray('0b1110') == '0xe'
-        True
-
-        """
-        try:
-            return self._bitstore == Bits._create_from_bitstype(bs)._bitstore
-        except TypeError:
-            return False
-
-    def __ne__(self, bs: Any, /) -> bool:
-        """Return False if two bitstrings have the same binary representation.
-
-        >>> BitArray('0b111') == '0x7'
-        False
-
-        """
-        return not self.__eq__(bs)
-
-    def __invert__(self: TBits) -> TBits:
-        """Return bitstring with every bit inverted.
-
-        Raises Error if the bitstring is empty.
-
-        """
-        if len(self) == 0:
-            raise bitstring.Error("Cannot invert empty bitstring.")
-        s = self._copy()
-        s._invert_all()
-        return s
-
-    def __lshift__(self: TBits, n: int, /) -> TBits:
-        """Return bitstring with bits shifted by n to the left.
-
-        n -- the number of bits to shift. Must be >= 0.
-
-        """
-        if n < 0:
-            raise ValueError("Cannot shift by a negative amount.")
-        if len(self) == 0:
-            raise ValueError("Cannot shift an empty bitstring.")
-        n = min(n, len(self))
-        s = self._absolute_slice(n, len(self))
-        s._addright(Bits(n))
-        return s
-
-    def __rshift__(self: TBits, n: int, /) -> TBits:
-        """Return bitstring with bits shifted by n to the right.
-
-        n -- the number of bits to shift. Must be >= 0.
-
-        """
-        if n < 0:
-            raise ValueError("Cannot shift by a negative amount.")
-        if len(self) == 0:
-            raise ValueError("Cannot shift an empty bitstring.")
-        if not n:
-            return self._copy()
-        s = self.__class__(length=min(n, len(self)))
-        n = min(n, len(self))
-        s._addright(self._absolute_slice(0, len(self) - n))
-        return s
-
-    def __mul__(self: TBits, n: int, /) -> TBits:
-        """Return bitstring consisting of n concatenations of self.
-
-        Called for expression of the form 'a = b*3'.
-        n -- The number of concatenations. Must be >= 0.
-
-        """
-        if n < 0:
-            raise ValueError("Cannot multiply by a negative integer.")
-        if not n:
-            return self.__class__()
-        s = self._copy()
-        s._imul(n)
-        return s
-
-    def __rmul__(self: TBits, n: int, /) -> TBits:
-        """Return bitstring consisting of n concatenations of self.
-
-        Called for expressions of the form 'a = 3*b'.
-        n -- The number of concatenations. Must be >= 0.
-
-        """
-        return self.__mul__(n)
-
-    def __and__(self: TBits, bs: BitsType, /) -> TBits:
-        """Bit-wise 'and' between two bitstrings. Returns new bitstring.
-
-        bs -- The bitstring to '&' with.
-
-        Raises ValueError if the two bitstrings have differing lengths.
-
-        """
-        if bs is self:
-            return self.copy()
-        bs = Bits._create_from_bitstype(bs)
-        s = object.__new__(self.__class__)
-        s._bitstore = self._bitstore & bs._bitstore
-        return s
-
-    def __rand__(self: TBits, bs: BitsType, /) -> TBits:
-        """Bit-wise 'and' between two bitstrings. Returns new bitstring.
-
-        bs -- the bitstring to '&' with.
-
-        Raises ValueError if the two bitstrings have differing lengths.
-
-        """
-        return self.__and__(bs)
-
-    def __or__(self: TBits, bs: BitsType, /) -> TBits:
-        """Bit-wise 'or' between two bitstrings. Returns new bitstring.
-
-        bs -- The bitstring to '|' with.
-
-        Raises ValueError if the two bitstrings have differing lengths.
-
-        """
-        if bs is self:
-            return self.copy()
-        bs = Bits._create_from_bitstype(bs)
-        s = object.__new__(self.__class__)
-        s._bitstore = self._bitstore | bs._bitstore
-        return s
-
-    def __ror__(self: TBits, bs: BitsType, /) -> TBits:
-        """Bit-wise 'or' between two bitstrings. Returns new bitstring.
-
-        bs -- The bitstring to '|' with.
-
-        Raises ValueError if the two bitstrings have differing lengths.
-
-        """
-        return self.__or__(bs)
-
-    def __xor__(self: TBits, bs: BitsType, /) -> TBits:
-        """Bit-wise 'xor' between two bitstrings. Returns new bitstring.
-
-        bs -- The bitstring to '^' with.
-
-        Raises ValueError if the two bitstrings have differing lengths.
-
-        """
-        bs = Bits._create_from_bitstype(bs)
-        s = object.__new__(self.__class__)
-        s._bitstore = self._bitstore ^ bs._bitstore
-        return s
-
-    def __rxor__(self: TBits, bs: BitsType, /) -> TBits:
-        """Bit-wise 'xor' between two bitstrings. Returns new bitstring.
-
-        bs -- The bitstring to '^' with.
-
-        Raises ValueError if the two bitstrings have differing lengths.
-
-        """
-        return self.__xor__(bs)
-
-    def __contains__(self, bs: BitsType, /) -> bool:
-        """Return whether bs is contained in the current bitstring.
-
-        bs -- The bitstring to search for.
-
-        """
-        found = Bits.find(self, bs, bytealigned=False)
-        return bool(found)
-
-    def __hash__(self) -> int:
-        """Return an integer hash of the object."""
-        # Only requirement is that equal bitstring should return the same hash.
-        # For equal bitstrings the bytes at the start/end will be the same and they will have the same length
-        # (need to check the length as there could be zero padding when getting the bytes). We do not check any
-        # bit position inside the bitstring as that does not feature in the __eq__ operation.
-        if len(self) <= 2000:
-            # Use the whole bitstring.
-            return hash((self.tobytes(), len(self)))
-        else:
-            # We can't in general hash the whole bitstring (it could take hours!)
-            # So instead take some bits from the start and end.
-            return hash(((self[:800] + self[-800:]).tobytes(), len(self)))
-
-    def __bool__(self) -> bool:
-        """Return False if bitstring is empty, otherwise return True."""
-        return len(self) != 0
-
-    def _clear(self) -> None:
-        """Reset the bitstring to an empty state."""
-        self._bitstore = BitStore()
-
-    def _setauto_no_length_or_offset(self, s: BitsType, /) -> None:
-        """Set bitstring from a bitstring, file, bool, array, iterable or string."""
-        if isinstance(s, str):
-            self._bitstore = bitstore_helpers.str_to_bitstore(s)
-        elif isinstance(s, Bits):
-            self._bitstore = s._bitstore.copy()
-        elif isinstance(s, (bytes, bytearray, memoryview)):
-            self._bitstore = BitStore.frombytes(bytearray(s))
-        elif isinstance(s, io.BytesIO):
-            self._bitstore = BitStore.frombytes(s.getvalue())
-        elif isinstance(s, io.BufferedReader):
-            self._setfile(s.name)
-        elif isinstance(s, bitarray.bitarray):
-            self._bitstore = BitStore(s)
-        elif isinstance(s, array.array):
-            self._bitstore = BitStore.frombytes(s.tobytes())
-        elif isinstance(s, abc.Iterable):
-            # Evaluate each item as True or False and set bits to 1 or 0.
-            self._setbin_unsafe(''.join(str(int(bool(x))) for x in s))
-        elif isinstance(s, numbers.Integral):
-            raise TypeError(f"It's no longer possible to auto initialise a bitstring from an integer."
-                            f" Use '{self.__class__.__name__}({s})' instead of just '{s}' as this makes it "
-                            f"clearer that a bitstring of {int(s)} zero bits will be created.")
-        else:
-            raise TypeError(f"Cannot initialise bitstring from type '{type(s)}'.")
-
-    def _setauto(self, s: BitsType, length: Optional[int], offset: Optional[int], /) -> None:
-        """Set bitstring from a bitstring, file, bool, array, iterable or string."""
-        # As s can be so many different things it's important to do the checks
-        # in the correct order, as some types are also other allowed types.
-        if offset is None and length is None:
-            return self._setauto_no_length_or_offset(s)
-        if offset is None:
-            offset = 0
-
-        if isinstance(s, io.BytesIO):
-            if length is None:
-                length = s.seek(0, 2) * 8 - offset
-            byteoffset, offset = divmod(offset, 8)
-            bytelength = (length + byteoffset * 8 + offset + 7) // 8 - byteoffset
-            if length + byteoffset * 8 + offset > s.seek(0, 2) * 8:
-                raise bitstring.CreationError("BytesIO object is not long enough for specified length and offset.")
-            self._bitstore = BitStore.frombytes(s.getvalue()[byteoffset: byteoffset + bytelength]).getslice(
-                offset, offset + length)
-            return
-
-        if isinstance(s, io.BufferedReader):
-            self._setfile(s.name, length, offset)
-            return
-
-        if isinstance(s, (str, Bits, bytes, bytearray, memoryview, io.BytesIO, io.BufferedReader,
-                          bitarray.bitarray, array.array, abc.Iterable)):
-            raise bitstring.CreationError(f"Cannot initialise bitstring from type '{type(s)}' when using explicit lengths or offsets.")
-        raise TypeError(f"Cannot initialise bitstring from type '{type(s)}'.")
-
-    def _setfile(self, filename: str, length: Optional[int] = None, offset: Optional[int] = None) -> None:
-        """Use file as source of bits."""
-        with open(pathlib.Path(filename), 'rb') as source:
-            if offset is None:
-                offset = 0
-            m = mmap.mmap(source.fileno(), 0, access=mmap.ACCESS_READ)
-            if offset == 0:
-                self._filename = source.name
-                self._bitstore = BitStore.frombuffer(m, length=length)
-            else:
-                # If offset is given then always read into memory.
-                temp = BitStore.frombuffer(m)
-                if length is None:
-                    if offset > len(temp):
-                        raise bitstring.CreationError(f"The offset of {offset} bits is greater than the file length ({len(temp)} bits).")
-                    self._bitstore = temp.getslice(offset, None)
-                else:
-                    self._bitstore = temp.getslice(offset, offset + length)
-                    if len(self) != length:
-                        raise bitstring.CreationError(f"Can't use a length of {length} bits and an offset of {offset} bits as file length is only {len(temp)} bits.")
-
-    def _setbitarray(self, ba: bitarray.bitarray, length: Optional[int], offset: Optional[int]) -> None:
-        if offset is None:
-            offset = 0
-        if offset > len(ba):
-            raise bitstring.CreationError(f"Offset of {offset} too large for bitarray of length {len(ba)}.")
-        if length is None:
-            self._bitstore = BitStore(ba[offset:])
-        else:
-            if offset + length > len(ba):
-                raise bitstring.CreationError(
-                    f"Offset of {offset} and length of {length} too large for bitarray of length {len(ba)}.")
-            self._bitstore = BitStore(ba[offset: offset + length])
-
-    def _setbits(self, bs: BitsType, length: None = None) -> None:
-        bs = Bits._create_from_bitstype(bs)
-        self._bitstore = bs._bitstore
-
-    def _setp3binary(self, f: float) -> None:
-        self._bitstore = bitstore_helpers.p3binary2bitstore(f)
-
-    def _setp4binary(self, f: float) -> None:
-        self._bitstore = bitstore_helpers.p4binary2bitstore(f)
-
-    def _sete4m3mxfp(self, f: float) -> None:
-        self._bitstore = bitstore_helpers.e4m3mxfp2bitstore(f)
-
-    def _sete5m2mxfp(self, f: float) -> None:
-        self._bitstore = bitstore_helpers.e5m2mxfp2bitstore(f)
-
-    def _sete3m2mxfp(self, f: float) -> None:
-        self._bitstore = bitstore_helpers.e3m2mxfp2bitstore(f)
-
-    def _sete2m3mxfp(self, f: float) -> None:
-        self._bitstore = bitstore_helpers.e2m3mxfp2bitstore(f)
-
-    def _sete2m1mxfp(self, f: float) -> None:
-        self._bitstore = bitstore_helpers.e2m1mxfp2bitstore(f)
-
-    def _sete8m0mxfp(self, f: float) -> None:
-        self._bitstore = bitstore_helpers.e8m0mxfp2bitstore(f)
-
-    def _setmxint(self, f: float) -> None:
-        self._bitstore = bitstore_helpers.mxint2bitstore(f)
-
-    def _setbytes(self, data: Union[bytearray, bytes, List], length:None = None) -> None:
-        """Set the data from a bytes or bytearray object."""
-        self._bitstore = BitStore.frombytes(bytes(data))
-
-    def _setbytes_with_truncation(self, data: Union[bytearray, bytes], length: Optional[int] = None, offset: Optional[int] = None) -> None:
-        """Set the data from a bytes or bytearray object, with optional offset and length truncations."""
-        if offset is None and length is None:
-            return self._setbytes(data)
-        data = bytearray(data)
-        if offset is None:
-            offset = 0
-        if length is None:
-            # Use to the end of the data
-            length = len(data) * 8 - offset
-        else:
-            if length + offset > len(data) * 8:
-                raise bitstring.CreationError(f"Not enough data present. Need {length + offset} bits, have {len(data) * 8}.")
-        self._bitstore = BitStore.frombytes(data).getslice_msb0(offset, offset + length)
-
-    def _getbytes(self) -> bytes:
-        """Return the data as an ordinary bytes object."""
-        if len(self) % 8:
-            raise bitstring.InterpretError("Cannot interpret as bytes unambiguously - not multiple of 8 bits.")
-        return self._bitstore.tobytes()
-
-    _unprintable = list(range(0x00, 0x20))  # ASCII control characters
-    _unprintable.extend(range(0x7f, 0xff))  # DEL char + non-ASCII
-
-    def _getbytes_printable(self) -> str:
-        """Return an approximation of the data as a string of printable characters."""
-        bytes_ = self._getbytes()
-        # For everything that isn't printable ASCII, use value from 'Latin Extended-A' unicode block.
-        string = ''.join(chr(0x100 + x) if x in Bits._unprintable else chr(x) for x in bytes_)
-        return string
-
-    def _setuint(self, uint: int, length: Optional[int] = None) -> None:
-        """Reset the bitstring to have given unsigned int interpretation."""
-        # If no length given, and we've previously been given a length, use it.
-        if length is None and hasattr(self, 'len') and len(self) != 0:
-            length = len(self)
-        if length is None or length == 0:
-            raise bitstring.CreationError("A non-zero length must be specified with a uint initialiser.")
-        self._bitstore = bitstore_helpers.int2bitstore(uint, length, False)
-
-    def _getuint(self) -> int:
-        """Return data as an unsigned int."""
-        if len(self) == 0:
-            raise bitstring.InterpretError("Cannot interpret a zero length bitstring as an integer.")
-        return self._bitstore.slice_to_uint()
-
-    def _setint(self, int_: int, length: Optional[int] = None) -> None:
-        """Reset the bitstring to have given signed int interpretation."""
-        # If no length given, and we've previously been given a length, use it.
-        if length is None and hasattr(self, 'len') and len(self) != 0:
-            length = len(self)
-        if length is None or length == 0:
-            raise bitstring.CreationError("A non-zero length must be specified with an int initialiser.")
-        self._bitstore = bitstore_helpers.int2bitstore(int_, length, True)
-
-    def _getint(self) -> int:
-        """Return data as a two's complement signed int."""
-        if len(self) == 0:
-            raise bitstring.InterpretError("Cannot interpret bitstring without a length as an integer.")
-        return self._bitstore.slice_to_int()
-
-    def _setuintbe(self, uintbe: int, length: Optional[int] = None) -> None:
-        """Set the bitstring to a big-endian unsigned int interpretation."""
-        if length is None and hasattr(self, 'len') and len(self) != 0:
-            length = len(self)
-        if length is None or length == 0:
-            raise bitstring.CreationError("A non-zero length must be specified with a uintbe initialiser.")
-        self._bitstore = bitstore_helpers.int2bitstore(uintbe, length, False)
-
-    def _getuintbe(self) -> int:
-        """Return data as a big-endian two's complement unsigned int."""
-        if len(self) % 8:
-            raise bitstring.InterpretError(f"Big-endian integers must be whole-byte. Length = {len(self)} bits.")
-        return self._getuint()
-
-    def _setintbe(self, intbe: int, length: Optional[int] = None) -> None:
-        """Set bitstring to a big-endian signed int interpretation."""
-        if length is None and hasattr(self, 'len') and len(self) != 0:
-            length = len(self)
-        if length is None or length == 0:
-            raise bitstring.CreationError("A non-zero length must be specified with a intbe initialiser.")
-        self._bitstore = bitstore_helpers.int2bitstore(intbe, length, True)
-
-    def _getintbe(self) -> int:
-        """Return data as a big-endian two's complement signed int."""
-        if len(self) % 8:
-            raise bitstring.InterpretError(f"Big-endian integers must be whole-byte. Length = {len(self)} bits.")
-        return self._getint()
-
-    def _setuintle(self, uintle: int, length: Optional[int] = None) -> None:
-        if length is None and hasattr(self, 'len') and len(self) != 0:
-            length = len(self)
-        if length is None or length == 0:
-            raise bitstring.CreationError("A non-zero length must be specified with a uintle initialiser.")
-        self._bitstore = bitstore_helpers.intle2bitstore(uintle, length, False)
-
-    def _getuintle(self) -> int:
-        """Interpret as a little-endian unsigned int."""
-        if len(self) % 8:
-            raise bitstring.InterpretError(f"Little-endian integers must be whole-byte. Length = {len(self)} bits.")
-        bs = BitStore.frombytes(self._bitstore.tobytes()[::-1])
-        return bs.slice_to_uint()
-
-    def _setintle(self, intle: int, length: Optional[int] = None) -> None:
-        if length is None and hasattr(self, 'len') and len(self) != 0:
-            length = len(self)
-        if length is None or length == 0:
-            raise bitstring.CreationError("A non-zero length must be specified with an intle initialiser.")
-        self._bitstore = bitstore_helpers.intle2bitstore(intle, length, True)
-
-    def _getintle(self) -> int:
-        """Interpret as a little-endian signed int."""
-        if len(self) % 8:
-            raise bitstring.InterpretError(f"Little-endian integers must be whole-byte. Length = {len(self)} bits.")
-        bs = BitStore.frombytes(self._bitstore.tobytes()[::-1])
-        return bs.slice_to_int()
-
-    def _getp4binary(self) -> float:
-        u = self._getuint()
-        return p4binary_fmt.lut_binary8_to_float[u]
-
-    def _getp3binary(self) -> float:
-        u = self._getuint()
-        return p3binary_fmt.lut_binary8_to_float[u]
-
-    def _gete4m3mxfp(self) -> float:
-        u = self._getuint()
-        return e4m3mxfp_saturate_fmt.lut_int_to_float[u]
-
-    def _gete5m2mxfp(self) -> float:
-        u = self._getuint()
-        return e5m2mxfp_saturate_fmt.lut_int_to_float[u]
-
-    def _gete3m2mxfp(self) -> float:
-        u = self._getuint()
-        return e3m2mxfp_fmt.lut_int_to_float[u]
-
-    def _gete2m3mxfp(self) -> float:
-        u = self._getuint()
-        return e2m3mxfp_fmt.lut_int_to_float[u]
-
-    def _gete2m1mxfp(self) -> float:
-        u = self._getuint()
-        return e2m1mxfp_fmt.lut_int_to_float[u]
-
-    def _gete8m0mxfp(self) -> float:
-        u = self._getuint() - 127
-        if u == 128:
-            return float('nan')
-        return 2.0 ** u
-
-    def _getmxint(self) -> float:
-        u = self._getint()
-        return float(u) * 2 ** -6
-
-
-    def _setfloat(self, f: float, length: Optional[int], big_endian: bool) -> None:
-        if length is None and hasattr(self, 'len') and len(self) != 0:
-            length = len(self)
-        if length is None or length not in [16, 32, 64]:
-            raise bitstring.CreationError("A length of 16, 32, or 64 must be specified with a float initialiser.")
-        self._bitstore = bitstore_helpers.float2bitstore(f, length, big_endian)
-
-    def _setfloatbe(self, f: float, length: Optional[int] = None) -> None:
-        self._setfloat(f, length, True)
-
-    def _getfloatbe(self) -> float:
-        """Interpret the whole bitstring as a big-endian float."""
-        fmt = {16: '>e', 32: '>f', 64: '>d'}[len(self)]
-        return struct.unpack(fmt, self._bitstore.tobytes())[0]
-
-    def _setfloatle(self, f: float, length: Optional[int] = None) -> None:
-        self._setfloat(f, length, False)
-
-    def _getfloatle(self) -> float:
-        """Interpret the whole bitstring as a little-endian float."""
-        fmt = {16: '<e', 32: '<f', 64: '<d'}[len(self)]
-        return struct.unpack(fmt, self._bitstore.tobytes())[0]
-
-    def _getbfloatbe(self) -> float:
-        zero_padded = self + Bits(16)
-        return zero_padded._getfloatbe()
-
-    def _setbfloatbe(self, f: Union[float, str], length: Optional[int] = None) -> None:
-        if length is not None and length != 16:
-            raise bitstring.CreationError(f"bfloats must be length 16, received a length of {length} bits.")
-        self._bitstore = bitstore_helpers.bfloat2bitstore(f, True)
-
-    def _getbfloatle(self) -> float:
-        zero_padded = Bits(16) + self
-        return zero_padded._getfloatle()
-
-    def _setbfloatle(self, f: Union[float, str], length: Optional[int] = None) -> None:
-        if length is not None and length != 16:
-            raise bitstring.CreationError(f"bfloats must be length 16, received a length of {length} bits.")
-        self._bitstore = bitstore_helpers.bfloat2bitstore(f, False)
-
-    def _setue(self, i: int) -> None:
-        """Initialise bitstring with unsigned exponential-Golomb code for integer i.
-
-        Raises CreationError if i < 0.
-
-        """
-        if bitstring.options.lsb0:
-            raise bitstring.CreationError("Exp-Golomb codes cannot be used in lsb0 mode.")
-        self._bitstore = bitstore_helpers.ue2bitstore(i)
-
-    def _readue(self, pos: int) -> Tuple[int, int]:
-        """Return interpretation of next bits as unsigned exponential-Golomb code.
-
-        Raises ReadError if the end of the bitstring is encountered while
-        reading the code.
-
-        """
-        if bitstring.options.lsb0:
-            raise bitstring.ReadError("Exp-Golomb codes cannot be read in lsb0 mode.")
-        oldpos = pos
-        try:
-            while not self[pos]:
-                pos += 1
-        except IndexError:
-            raise bitstring.ReadError("Read off end of bitstring trying to read code.")
-        leadingzeros = pos - oldpos
-        codenum = (1 << leadingzeros) - 1
-        if leadingzeros > 0:
-            if pos + leadingzeros + 1 > len(self):
-                raise bitstring.ReadError("Read off end of bitstring trying to read code.")
-            codenum += self[pos + 1:pos + 1 + leadingzeros]._getuint()
-            pos += leadingzeros + 1
-        else:
-            assert codenum == 0
-            pos += 1
-        return codenum, pos
-
-    def _getue(self) -> Tuple[int, int]:
-        try:
-            return self._readue(0)
-        except bitstring.ReadError:
-            raise bitstring.InterpretError
-
-    def _getse(self) -> Tuple[int, int]:
-        try:
-            return self._readse(0)
-        except bitstring.ReadError:
-            raise bitstring.InterpretError
-
-    def _getuie(self) -> Tuple[int, int]:
-        try:
-            return self._readuie(0)
-        except bitstring.ReadError:
-            raise bitstring.InterpretError
-
-    def _getsie(self) -> Tuple[int, int]:
-        try:
-            return self._readsie(0)
-        except bitstring.ReadError:
-            raise bitstring.InterpretError
-
-    def _setse(self, i: int) -> None:
-        """Initialise bitstring with signed exponential-Golomb code for integer i."""
-        if bitstring.options.lsb0:
-            raise bitstring.CreationError("Exp-Golomb codes cannot be used in lsb0 mode.")
-        self._bitstore = bitstore_helpers.se2bitstore(i)
-
-    def _readse(self, pos: int) -> Tuple[int, int]:
-        """Return interpretation of next bits as a signed exponential-Golomb code.
-
-        Advances position to after the read code.
-
-        Raises ReadError if the end of the bitstring is encountered while
-        reading the code.
-
-        """
-        codenum, pos = self._readue(pos)
-        m = (codenum + 1) // 2
-        return (m, pos) if codenum % 2 else (-m, pos)
-
-    def _setuie(self, i: int) -> None:
-        """Initialise bitstring with unsigned interleaved exponential-Golomb code for integer i.
-
-        Raises CreationError if i < 0.
-
-        """
-        if bitstring.options.lsb0:
-            raise bitstring.CreationError("Exp-Golomb codes cannot be used in lsb0 mode.")
-        self._bitstore = bitstore_helpers.uie2bitstore(i)
-
-    def _readuie(self, pos: int) -> Tuple[int, int]:
-        """Return interpretation of next bits as unsigned interleaved exponential-Golomb code.
-
-        Raises ReadError if the end of the bitstring is encountered while
-        reading the code.
-
-        """
-        if bitstring.options.lsb0:
-            raise bitstring.ReadError("Exp-Golomb codes cannot be read in lsb0 mode.")
-        try:
-            codenum: int = 1
-            while not self[pos]:
-                pos += 1
-                codenum <<= 1
-                codenum += self[pos]
-                pos += 1
-            pos += 1
-        except IndexError:
-            raise bitstring.ReadError("Read off end of bitstring trying to read code.")
-        return codenum - 1, pos
-
-    def _setsie(self, i: int, ) -> None:
-        """Initialise bitstring with signed interleaved exponential-Golomb code for integer i."""
-        if bitstring.options.lsb0:
-            raise bitstring.CreationError("Exp-Golomb codes cannot be used in lsb0 mode.")
-        self._bitstore = bitstore_helpers.sie2bitstore(i)
-
-    def _readsie(self, pos: int) -> Tuple[int, int]:
-        """Return interpretation of next bits as a signed interleaved exponential-Golomb code.
-
-        Advances position to after the read code.
-
-        Raises ReadError if the end of the bitstring is encountered while
-        reading the code.
-
-        """
-        codenum, pos = self._readuie(pos)
-        if not codenum:
-            return 0, pos
-        try:
-            return (-codenum, pos + 1) if self[pos] else (codenum, pos + 1)
-        except IndexError:
-            raise bitstring.ReadError("Read off end of bitstring trying to read code.")
-
-    def _setbool(self, value: Union[bool, str]) -> None:
-        # We deliberately don't want to have implicit conversions to bool here.
-        # If we did then it would be difficult to deal with the 'False' string.
-        if value in (1, 'True', '1'):
-            self._bitstore = BitStore('1')
-        elif value in (0, 'False', '0'):
-            self._bitstore = BitStore('0')
-        else:
-            raise bitstring.CreationError(f"Cannot initialise boolean with {value}.")
-
-    def _getbool(self) -> bool:
-        return self[0]
-
-    def _getpad(self) -> None:
-        return None
-
-    def _setpad(self, value: None, length: int) -> None:
-        self._bitstore = BitStore(length)
-
-    def _setbin_safe(self, binstring: str, length: None = None) -> None:
-        """Reset the bitstring to the value given in binstring."""
-        self._bitstore = bitstore_helpers.bin2bitstore(binstring)
-
-    def _setbin_unsafe(self, binstring: str, length: None = None) -> None:
-        """Same as _setbin_safe, but input isn't sanity checked. binstring mustn't start with '0b'."""
-        self._bitstore = bitstore_helpers.bin2bitstore_unsafe(binstring)
-
-    def _getbin(self) -> str:
-        """Return interpretation as a binary string."""
-        return self._bitstore.slice_to_bin()
-
-    def _setoct(self, octstring: str, length: None = None) -> None:
-        """Reset the bitstring to have the value given in octstring."""
-        self._bitstore = bitstore_helpers.oct2bitstore(octstring)
-
-    def _getoct(self) -> str:
-        """Return interpretation as an octal string."""
-        return self._bitstore.slice_to_oct()
-
-    def _sethex(self, hexstring: str, length: None = None) -> None:
-        """Reset the bitstring to have the value given in hexstring."""
-        self._bitstore = bitstore_helpers.hex2bitstore(hexstring)
-
-    def _gethex(self) -> str:
-        """Return the hexadecimal representation as a string.
-
-        Raises an InterpretError if the bitstring's length is not a multiple of 4.
-
-        """
-        return self._bitstore.slice_to_hex()
-
-    def _getlength(self) -> int:
-        """Return the length of the bitstring in bits."""
-        return len(self._bitstore)
-
-    def _copy(self: TBits) -> TBits:
-        """Create and return a new copy of the Bits (always in memory)."""
-        # Note that __copy__ may choose to return self if it's immutable. This method always makes a copy.
-        s_copy = self.__class__()
-        s_copy._bitstore = self._bitstore._copy()
-        return s_copy
-
-    def _slice(self: TBits, start: int, end: int) -> TBits:
-        """Used internally to get a slice, without error checking."""
-        bs = self.__class__()
-        bs._bitstore = self._bitstore.getslice(start, end)
-        return bs
-
-    def _absolute_slice(self: TBits, start: int, end: int) -> TBits:
-        """Used internally to get a slice, without error checking.
-        Uses MSB0 bit numbering even if LSB0 is set."""
-        if end == start:
-            return self.__class__()
-        assert start < end, f"start={start}, end={end}"
-        bs = self.__class__()
-        bs._bitstore = self._bitstore.getslice_msb0(start, end)
-        return bs
-
-    def _readtoken(self, name: str, pos: int, length: Optional[int]) -> Tuple[Union[float, int, str, None, Bits], int]:
-        """Reads a token from the bitstring and returns the result."""
-        dtype = dtype_register.get_dtype(name, length)
-        if dtype.bitlength is not None and dtype.bitlength > len(self) - pos:
-            raise bitstring.ReadError("Reading off the end of the data. "
-                            f"Tried to read {dtype.bitlength} bits when only {len(self) - pos} available.")
-        try:
-            val = dtype.read_fn(self, pos)
-            if isinstance(val, tuple):
-                return val
-            else:
-                assert length is not None
-                return val, pos + dtype.bitlength
-        except KeyError:
-            raise ValueError(f"Can't parse token {name}:{length}")
-
-    def _addright(self, bs: Bits, /) -> None:
-        """Add a bitstring to the RHS of the current bitstring."""
-        self._bitstore += bs._bitstore
-
-    def _addleft(self, bs: Bits, /) -> None:
-        """Prepend a bitstring to the current bitstring."""
-        if bs._bitstore.immutable:
-            self._bitstore = bs._bitstore._copy() + self._bitstore
-        else:
-            self._bitstore = bs._bitstore + self._bitstore
-
-    def _truncateleft(self: TBits, bits: int, /) -> TBits:
-        """Truncate bits from the start of the bitstring. Return the truncated bits."""
-        assert 0 <= bits <= len(self)
-        if bits == 0:
-            return self.__class__()
-        truncated_bits = self._absolute_slice(0, bits)
-        if bits == len(self):
-            self._clear()
-            return truncated_bits
-        self._bitstore = self._bitstore.getslice_msb0(bits, None)
-        return truncated_bits
-
-    def _truncateright(self: TBits, bits: int, /) -> TBits:
-        """Truncate bits from the end of the bitstring. Return the truncated bits."""
-        assert 0 <= bits <= len(self)
-        if bits == 0:
-            return self.__class__()
-        truncated_bits = self._absolute_slice(len(self) - bits, len(self))
-        if bits == len(self):
-            self._clear()
-            return truncated_bits
-        self._bitstore = self._bitstore.getslice_msb0(None, -bits)
-        return truncated_bits
-
-    def _insert(self, bs: Bits, pos: int, /) -> None:
-        """Insert bs at pos."""
-        assert 0 <= pos <= len(self)
-        self._bitstore[pos: pos] = bs._bitstore
-        return
-
-    def _overwrite(self, bs: Bits, pos: int, /) -> None:
-        """Overwrite with bs at pos."""
-        assert 0 <= pos <= len(self)
-        if bs is self:
-            # Just overwriting with self, so do nothing.
-            assert pos == 0
-            return
-        self._bitstore[pos: pos + len(bs)] = bs._bitstore
-
-    def _delete(self, bits: int, pos: int, /) -> None:
-        """Delete bits at pos."""
-        assert 0 <= pos <= len(self)
-        assert pos + bits <= len(self), f"pos={pos}, bits={bits}, len={len(self)}"
-        del self._bitstore[pos: pos + bits]
-        return
-
-    def _reversebytes(self, start: int, end: int) -> None:
-        """Reverse bytes in-place."""
-        assert (end - start) % 8 == 0
-        self._bitstore[start:end] = BitStore.frombytes(self._bitstore.getslice(start, end).tobytes()[::-1])
-
-    def _invert(self, pos: int, /) -> None:
-        """Flip bit at pos 1<->0."""
-        assert 0 <= pos < len(self)
-        self._bitstore.invert(pos)
-
-    def _invert_all(self) -> None:
-        """Invert every bit."""
-        self._bitstore.invert()
-
-    def _ilshift(self: TBits, n: int, /) -> TBits:
-        """Shift bits by n to the left in place. Return self."""
-        assert 0 < n <= len(self)
-        self._addright(Bits(n))
-        self._truncateleft(n)
-        return self
-
-    def _irshift(self: TBits, n: int, /) -> TBits:
-        """Shift bits by n to the right in place. Return self."""
-        assert 0 < n <= len(self)
-        self._addleft(Bits(n))
-        self._truncateright(n)
-        return self
-
-    def _imul(self: TBits, n: int, /) -> TBits:
-        """Concatenate n copies of self in place. Return self."""
-        assert n >= 0
-        if n == 0:
-            self._clear()
-        else:
-            m = 1
-            old_len = len(self)
-            while m * 2 < n:
-                self._addright(self)
-                m *= 2
-            self._addright(self[0:(n - m) * old_len])
-        return self
-
-    def _getbits(self: TBits):
-        return self._copy()
-
-    def _validate_slice(self, start: Optional[int], end: Optional[int]) -> Tuple[int, int]:
-        """Validate start and end and return them as positive bit positions."""
-        start = 0 if start is None else (start + len(self) if start < 0 else start)
-        end = len(self) if end is None else (end + len(self) if end < 0 else end)
-        if not 0 <= start <= end <= len(self):
-            raise ValueError(f"Invalid slice positions for bitstring length {len(self)}: start={start}, end={end}.")
-        return start, end
-
-    def unpack(self, fmt: Union[str, List[Union[str, int]]], **kwargs) -> List[Union[int, float, str, Bits, bool, bytes, None]]:
-        """Interpret the whole bitstring using fmt and return list.
-
-        fmt -- A single string or a list of strings with comma separated tokens
-               describing how to interpret the bits in the bitstring. Items
-               can also be integers, for reading new bitstring of the given length.
-        kwargs -- A dictionary or keyword-value pairs - the keywords used in the
-                  format string will be replaced with their given value.
-
-        Raises ValueError if the format is not understood. If not enough bits
-        are available then all bits to the end of the bitstring will be used.
-
-        See the docstring for 'read' for token examples.
-
-        """
-        return self._readlist(fmt, 0, **kwargs)[0]
-
-    def _readlist(self, fmt: Union[str, List[Union[str, int, Dtype]]], pos: int, **kwargs) \
-            -> Tuple[List[Union[int, float, str, Bits, bool, bytes, None]], int]:
-        if isinstance(fmt, str):
-            fmt = [fmt]
-        # Convert to a flat list of Dtypes
-        dtype_list = []
-        for f_item in fmt:
-            if isinstance(f_item, numbers.Integral):
-                dtype_list.append(Dtype('bits', f_item))
-            elif isinstance(f_item, Dtype):
-                dtype_list.append(f_item)
-            else:
-                token_list = utils.preprocess_tokens(f_item)
-                for t in token_list:
-                    try:
-                        name, length = utils.parse_name_length_token(t, **kwargs)
-                    except ValueError:
-                        dtype_list.append(Dtype('bits', int(t)))
-                    else:
-                        dtype_list.append(Dtype(name, length))
-        return self._read_dtype_list(dtype_list, pos)
-
-    def _read_dtype_list(self, dtypes: List[Dtype], pos: int) -> Tuple[List[Union[int, float, str, Bits, bool, bytes, None]], int]:
-        has_stretchy_token = False
-        bits_after_stretchy_token = 0
-        for dtype in dtypes:
-            stretchy = dtype.bitlength is None and not dtype.variable_length
-            if stretchy:
-                if has_stretchy_token:
-                    raise bitstring.Error("It's not possible to have more than one 'filler' token.")
-                has_stretchy_token = True
-            elif has_stretchy_token:
-                if dtype.variable_length:
-                    raise bitstring.Error(f"It's not possible to parse a variable length token '{dtype}' after a 'filler' token.")
-                bits_after_stretchy_token += dtype.bitlength
-
-        # We should have precisely zero or one stretchy token
-        vals = []
-        for dtype in dtypes:
-            stretchy = dtype.bitlength is None and not dtype.variable_length
-            if stretchy:
-                bits_remaining = len(self) - pos
-                # Set length to the remaining bits
-                bitlength = max(bits_remaining - bits_after_stretchy_token, 0)
-                items, remainder = divmod(bitlength, dtype.bits_per_item)
-                if remainder != 0:
-                    raise ValueError(
-                        f"The '{dtype.name}' type must have a bit length that is a multiple of {dtype.bits_per_item}"
-                        f" so cannot be created from the {bitlength} bits that are available for this stretchy token.")
-                dtype = Dtype(dtype.name, items)
-            if dtype.bitlength is not None:
-                val = dtype.read_fn(self, pos)
-                pos += dtype.bitlength
-            else:
-                val, pos = dtype.read_fn(self, pos)
-            if val is not None:  # Don't append pad tokens
-                vals.append(val)
-        return vals, pos
-
-    def find(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,
-             bytealigned: Optional[bool] = None) -> Union[Tuple[int], Tuple[()]]:
-        """Find first occurrence of substring bs.
-
-        Returns a single item tuple with the bit position if found, or an
-        empty tuple if not found. The bit position (pos property) will
-        also be set to the start of the substring if it is found.
-
-        bs -- The bitstring to find.
-        start -- The bit position to start the search. Defaults to 0.
-        end -- The bit position one past the last bit to search.
-               Defaults to len(self).
-        bytealigned -- If True the bitstring will only be
-                       found on byte boundaries.
-
-        Raises ValueError if bs is empty, if start < 0, if end > len(self) or
-        if end < start.
-
-        >>> BitArray('0xc3e').find('0b1111')
-        (6,)
-
-        """
-        bs = Bits._create_from_bitstype(bs)
-        if len(bs) == 0:
-            raise ValueError("Cannot find an empty bitstring.")
-        start, end = self._validate_slice(start, end)
-        ba = bitstring.options.bytealigned if bytealigned is None else bytealigned
-        p = self._find(bs, start, end, ba)
-        return p
-
-    def _find_lsb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -> Union[Tuple[int], Tuple[()]]:
-        # A forward find in lsb0 is very like a reverse find in msb0.
-        assert start <= end
-        assert bitstring.options.lsb0
-
-        new_slice = bitstring.bitstore.offset_slice_indices_lsb0(slice(start, end, None), len(self))
-        msb0_start, msb0_end = self._validate_slice(new_slice.start, new_slice.stop)
-        p = self._rfind_msb0(bs, msb0_start, msb0_end, bytealigned)
-
-        if p:
-            return (len(self) - p[0] - len(bs),)
-        else:
-            return ()
-
-    def _find_msb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -> Union[Tuple[int], Tuple[()]]:
-        """Find first occurrence of a binary string."""
-        p = self._bitstore.find(bs._bitstore, start, end, bytealigned)
-        return () if p == -1 else (p,)
-
-    def findall(self, bs: BitsType, start: Optional[int] = None, end: Optional[int] = None, count: Optional[int] = None,
-                bytealigned: Optional[bool] = None) -> Iterable[int]:
-        """Find all occurrences of bs. Return generator of bit positions.
-
-        bs -- The bitstring to find.
-        start -- The bit position to start the search. Defaults to 0.
-        end -- The bit position one past the last bit to search.
-               Defaults to len(self).
-        count -- The maximum number of occurrences to find.
-        bytealigned -- If True the bitstring will only be found on
-                       byte boundaries.
-
-        Raises ValueError if bs is empty, if start < 0, if end > len(self) or
-        if end < start.
-
-        Note that all occurrences of bs are found, even if they overlap.
-
-        """
-        if count is not None and count < 0:
-            raise ValueError("In findall, count must be >= 0.")
-        bs = Bits._create_from_bitstype(bs)
-        start, end = self._validate_slice(start, end)
-        ba = bitstring.options.bytealigned if bytealigned is None else bytealigned
-        return self._findall(bs, start, end, count, ba)
-
-    def _findall_msb0(self, bs: Bits, start: int, end: int, count: Optional[int],
-                      bytealigned: bool) -> Iterable[int]:
-        c = 0
-        for i in self._bitstore.findall_msb0(bs._bitstore, start, end, bytealigned):
-            if count is not None and c >= count:
-                return
-            c += 1
-            yield i
-        return
-
-    def _findall_lsb0(self, bs: Bits, start: int, end: int, count: Optional[int],
-                      bytealigned: bool) -> Iterable[int]:
-        assert start <= end
-        assert bitstring.options.lsb0
-
-        new_slice = bitstring.bitstore.offset_slice_indices_lsb0(slice(start, end, None), len(self))
-        msb0_start, msb0_end = self._validate_slice(new_slice.start, new_slice.stop)
-
-        # Search chunks starting near the end and then moving back.
-        c = 0
-        increment = max(8192, len(bs) * 80)
-        buffersize = min(increment + len(bs), msb0_end - msb0_start)
-        pos = max(msb0_start, msb0_end - buffersize)
-        while True:
-            found = list(self._findall_msb0(bs, start=pos, end=pos + buffersize, count=None, bytealigned=False))
-            if not found:
-                if pos == msb0_start:
-                    return
-                pos = max(msb0_start, pos - increment)
-                continue
-            while found:
-                if count is not None and c >= count:
-                    return
-                c += 1
-                lsb0_pos = len(self) - found.pop() - len(bs)
-                if not bytealigned or lsb0_pos % 8 == 0:
-                    yield lsb0_pos
-
-            pos = max(msb0_start, pos - increment)
-            if pos == msb0_start:
-                return
-
-    def rfind(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,
-              bytealigned: Optional[bool] = None) -> Union[Tuple[int], Tuple[()]]:
-        """Find final occurrence of substring bs.
-
-        Returns a single item tuple with the bit position if found, or an
-        empty tuple if not found. The bit position (pos property) will
-        also be set to the start of the substring if it is found.
-
-        bs -- The bitstring to find.
-        start -- The bit position to end the reverse search. Defaults to 0.
-        end -- The bit position one past the first bit to reverse search.
-               Defaults to len(self).
-        bytealigned -- If True the bitstring will only be found on byte
-                       boundaries.
-
-        Raises ValueError if bs is empty, if start < 0, if end > len(self) or
-        if end < start.
-
-        """
-        bs = Bits._create_from_bitstype(bs)
-        start, end = self._validate_slice(start, end)
-        ba = bitstring.options.bytealigned if bytealigned is None else bytealigned
-        if len(bs) == 0:
-            raise ValueError("Cannot find an empty bitstring.")
-        p = self._rfind(bs, start, end, ba)
-        return p
-
-    def _rfind_msb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -> Union[Tuple[int], Tuple[()]]:
-        """Find final occurrence of a binary string."""
-        p = self._bitstore.rfind(bs._bitstore, start, end, bytealigned)
-        return () if p == -1 else (p,)
-
-    def _rfind_lsb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -> Union[Tuple[int], Tuple[()]]:
-        # A reverse find in lsb0 is very like a forward find in msb0.
-        assert start <= end
-        assert bitstring.options.lsb0
-        new_slice = bitstring.bitstore.offset_slice_indices_lsb0(slice(start, end, None), len(self))
-        msb0_start, msb0_end = self._validate_slice(new_slice.start, new_slice.stop)
-
-        p = self._find_msb0(bs, msb0_start, msb0_end, bytealigned)
-        if p:
-            return (len(self) - p[0] - len(bs),)
-        else:
-            return ()
-
-    def cut(self, bits: int, start: Optional[int] = None, end: Optional[int] = None,
-            count: Optional[int] = None) -> Iterator[Bits]:
-        """Return bitstring generator by cutting into bits sized chunks.
-
-        bits -- The size in bits of the bitstring chunks to generate.
-        start -- The bit position to start the first cut. Defaults to 0.
-        end -- The bit position one past the last bit to use in the cut.
-               Defaults to len(self).
-        count -- If specified then at most count items are generated.
-                 Default is to cut as many times as possible.
-
-        """
-        start_, end_ = self._validate_slice(start, end)
-        if count is not None and count < 0:
-            raise ValueError("Cannot cut - count must be >= 0.")
-        if bits <= 0:
-            raise ValueError("Cannot cut - bits must be >= 0.")
-        c = 0
-        while count is None or c < count:
-            c += 1
-            nextchunk = self._slice(start_, min(start_ + bits, end_))
-            if len(nextchunk) == 0:
-                return
-            yield nextchunk
-            if len(nextchunk) != bits:
-                return
-            start_ += bits
-        return
-
-    def split(self, delimiter: BitsType, start: Optional[int] = None, end: Optional[int] = None,
-              count: Optional[int] = None, bytealigned: Optional[bool] = None) -> Iterable[Bits]:
-        """Return bitstring generator by splitting using a delimiter.
-
-        The first item returned is the initial bitstring before the delimiter,
-        which may be an empty bitstring.
-
-        delimiter -- The bitstring used as the divider.
-        start -- The bit position to start the split. Defaults to 0.
-        end -- The bit position one past the last bit to use in the split.
-               Defaults to len(self).
-        count -- If specified then at most count items are generated.
-                 Default is to split as many times as possible.
-        bytealigned -- If True splits will only occur on byte boundaries.
-
-        Raises ValueError if the delimiter is empty.
-
-        """
-        delimiter = Bits._create_from_bitstype(delimiter)
-        if len(delimiter) == 0:
-            raise ValueError("split delimiter cannot be empty.")
-        start, end = self._validate_slice(start, end)
-        bytealigned_: bool = bitstring.options.bytealigned if bytealigned is None else bytealigned
-        if count is not None and count < 0:
-            raise ValueError("Cannot split - count must be >= 0.")
-        if count == 0:
-            return
-        f = functools.partial(self._find_msb0, bs=delimiter, bytealigned=bytealigned_)
-        found = f(start=start, end=end)
-        if not found:
-            # Initial bits are the whole bitstring being searched
-            yield self._slice(start, end)
-            return
-        # yield the bytes before the first occurrence of the delimiter, even if empty
-        yield self._slice(start, found[0])
-        startpos = pos = found[0]
-        c = 1
-        while count is None or c < count:
-            pos += len(delimiter)
-            found = f(start=pos, end=end)
-            if not found:
-                # No more occurrences, so return the rest of the bitstring
-                yield self._slice(startpos, end)
-                return
-            c += 1
-            yield self._slice(startpos, found[0])
-            startpos = pos = found[0]
-        # Have generated count bitstrings, so time to quit.
-        return
-
-    def join(self: TBits, sequence: Iterable[Any]) -> TBits:
-        """Return concatenation of bitstrings joined by self.
-
-        sequence -- A sequence of bitstrings.
-
-        """
-        s = self.__class__()
-        if len(self) == 0:
-            # Optimised version that doesn't need to add self between every item
-            for item in sequence:
-                s._addright(Bits._create_from_bitstype(item))
-            return s
-        else:
-            sequence_iter = iter(sequence)
-            try:
-                s._addright(Bits._create_from_bitstype(next(sequence_iter)))
-            except StopIteration:
-                return s
-            for item in sequence_iter:
-                s._addright(self)
-                s._addright(Bits._create_from_bitstype(item))
-            return s
-
-    def tobytes(self) -> bytes:
-        """Return the bitstring as bytes, padding with zero bits if needed.
-
-        Up to seven zero bits will be added at the end to byte align.
-
-        """
-        return self._bitstore.tobytes()
-
-    def tobitarray(self) -> bitarray.bitarray:
-        """Convert the bitstring to a bitarray object."""
-        if self._bitstore.modified_length is not None:
-            # Removes the offset and truncates to length
-            return self._bitstore.getslice(0, len(self))._bitarray
-        else:
-            return self._bitstore._bitarray
-
-    def tofile(self, f: BinaryIO) -> None:
-        """Write the bitstring to a file object, padding with zero bits if needed.
-
-        Up to seven zero bits will be added at the end to byte align.
-
-        """
-        # If the bitstring is file based then we don't want to read it all in to memory first.
-        chunk_size = 8 * 100 * 1024 * 1024  # 100 MiB
-        for chunk in self.cut(chunk_size):
-            f.write(chunk.tobytes())
-
-    def startswith(self, prefix: BitsType, start: Optional[int] = None, end: Optional[int] = None) -> bool:
-        """Return whether the current bitstring starts with prefix.
-
-        prefix -- The bitstring to search for.
-        start -- The bit position to start from. Defaults to 0.
-        end -- The bit position to end at. Defaults to len(self).
-
-        """
-        prefix = self._create_from_bitstype(prefix)
-        start, end = self._validate_slice(start, end)
-        return self._slice(start, start + len(prefix)) == prefix if end >= start + len(prefix) else False
-
-    def endswith(self, suffix: BitsType, start: Optional[int] = None, end: Optional[int] = None) -> bool:
-        """Return whether the current bitstring ends with suffix.
-
-        suffix -- The bitstring to search for.
-        start -- The bit position to start from. Defaults to 0.
-        end -- The bit position to end at. Defaults to len(self).
-
-        """
-        suffix = self._create_from_bitstype(suffix)
-        start, end = self._validate_slice(start, end)
-        return self._slice(end - len(suffix), end) == suffix if start + len(suffix) <= end else False
-
-    def all(self, value: Any, pos: Optional[Iterable[int]] = None) -> bool:
-        """Return True if one or many bits are all set to bool(value).
-
-        value -- If value is True then checks for bits set to 1, otherwise
-                 checks for bits set to 0.
-        pos -- An iterable of bit positions. Negative numbers are treated in
-               the same way as slice indices. Defaults to the whole bitstring.
-
-        """
-        value = 1 if bool(value) else 0
-        if pos is None:
-            return self._bitstore.all_set() if value else not self._bitstore.any_set()
-        for p in pos:
-            if self._bitstore.getindex(p) != value:
-                return False
-        return True
-
-    def any(self, value: Any, pos: Optional[Iterable[int]] = None) -> bool:
-        """Return True if any of one or many bits are set to bool(value).
-
-        value -- If value is True then checks for bits set to 1, otherwise
-                 checks for bits set to 0.
-        pos -- An iterable of bit positions. Negative numbers are treated in
-               the same way as slice indices. Defaults to the whole bitstring.
-
-        """
-        value = 1 if bool(value) else 0
-        if pos is None:
-            return self._bitstore.any_set() if value else not self._bitstore.all_set()
-        for p in pos:
-            if self._bitstore.getindex(p) == value:
-                return True
-        return False
-
-    def count(self, value: Any) -> int:
-        """Return count of total number of either zero or one bits.
-
-        value -- If bool(value) is True then bits set to 1 are counted, otherwise bits set
-                 to 0 are counted.
-
-        >>> Bits('0xef').count(1)
-        7
-
-        """
-        # count the number of 1s (from which it's easy to work out the 0s).
-        count = self._bitstore.count(1)
-        return count if value else len(self) - count
-
-    @staticmethod
-    def _format_bits(bits: Bits, bits_per_group: int, sep: str, dtype: Dtype,
-                     colour_start: str, colour_end: str, width: Optional[int]=None) -> Tuple[str, int]:
-        get_fn = dtype.get_fn
-        if dtype.name == 'bytes':  # Special case for bytes to print one character each.
-            get_fn = Bits._getbytes_printable
-        if dtype.name == 'bool':  # Special case for bool to print '1' or '0' instead of `True` or `False`.
-            get_fn = dtype_register.get_dtype('uint', bits_per_group).get_fn
-        if bits_per_group == 0:
-            x = str(get_fn(bits))
-        else:
-            # Left-align for fixed width types when msb0, otherwise right-align.
-            align = '<' if dtype.name in ['bin', 'oct', 'hex', 'bits', 'bytes'] and not bitstring.options.lsb0 else '>'
-            chars_per_group = 0
-            if dtype_register[dtype.name].bitlength2chars_fn is not None:
-                chars_per_group = dtype_register[dtype.name].bitlength2chars_fn(bits_per_group)
-            x = sep.join(f"{str(get_fn(b)): {align}{chars_per_group}}" for b in bits.cut(bits_per_group))
-
-        chars_used = len(x)
-        padding_spaces = 0 if width is None else max(width - len(x), 0)
-        x = colour_start + x + colour_end
-        # Pad final line with spaces to align it
-        if bitstring.options.lsb0:
-            x = ' ' * padding_spaces + x
-        else:
-            x += ' ' * padding_spaces
-        return x, chars_used
-
-    @staticmethod
-    def _chars_per_group(bits_per_group: int, fmt: Optional[str]):
-        """How many characters are needed to represent a number of bits with a given format."""
-        if fmt is None or dtype_register[fmt].bitlength2chars_fn is None:
-            return 0
-        return dtype_register[fmt].bitlength2chars_fn(bits_per_group)
-
-    @staticmethod
-    def _bits_per_char(fmt: str):
-        """How many bits are represented by each character of a given format."""
-        if fmt not in ['bin', 'oct', 'hex', 'bytes']:
-            raise ValueError
-        return 24 // dtype_register[fmt].bitlength2chars_fn(24)
-
-    def _pp(self, dtype1: Dtype, dtype2: Optional[Dtype], bits_per_group: int, width: int, sep: str, format_sep: str,
-            show_offset: bool, stream: TextIO, lsb0: bool, offset_factor: int) -> None:
-        """Internal pretty print method."""
-        colour = Colour(not bitstring.options.no_color)
-        name1 = dtype1.name
-        name2 = dtype2.name if dtype2 is not None else None
-        if dtype1.variable_length:
-            raise ValueError(f"Can't use Dtype '{dtype1}' in pp() as it has a variable length.")
-        if dtype2 is not None and dtype2.variable_length:
-            raise ValueError(f"Can't use Dtype '{dtype2}' in pp() as it has a variable length.")
-        offset_width = 0
-        offset_sep = ' :' if lsb0 else ': '
-        if show_offset:
-            # This could be 1 too large in some circumstances. Slightly recurrent logic needed to fix it...
-            offset_width = len(str(len(self))) + len(offset_sep)
-        if bits_per_group > 0:
-            group_chars1 = Bits._chars_per_group(bits_per_group, name1)
-            group_chars2 = Bits._chars_per_group(bits_per_group, name2)
-            # The number of characters that get added when we add an extra group (after the first one)
-            total_group_chars = group_chars1 + group_chars2 + len(sep) + len(sep) * bool(group_chars2)
-            width_excluding_offset_and_final_group = width - offset_width - group_chars1 - group_chars2 - len(
-                format_sep) * bool(group_chars2)
-            width_excluding_offset_and_final_group = max(width_excluding_offset_and_final_group, 0)
-            groups_per_line = 1 + width_excluding_offset_and_final_group // total_group_chars
-            max_bits_per_line = groups_per_line * bits_per_group  # Number of bits represented on each line
-        else:
-            assert bits_per_group == 0  # Don't divide into groups
-            width_available = width - offset_width - len(format_sep) * (name2 is not None)
-            width_available = max(width_available, 1)
-            if name2 is None:
-                max_bits_per_line = width_available * Bits._bits_per_char(name1)
-            else:
-                chars_per_24_bits = dtype_register[name1].bitlength2chars_fn(24) + dtype_register[name2].bitlength2chars_fn(24)
-                max_bits_per_line = 24 * (width_available // chars_per_24_bits)
-                if max_bits_per_line == 0:
-                    max_bits_per_line = 24  # We can't fit into the width asked for. Show something small.
-        assert max_bits_per_line > 0
-
-        bitpos = 0
-        first_fb_width = second_fb_width = None
-        for bits in self.cut(max_bits_per_line):
-            offset_str = ''
-            if show_offset:
-                offset = bitpos // offset_factor
-                bitpos += len(bits)
-                if bitstring.options.lsb0:
-                    offset_str = colour.green + offset_sep + f'{offset: <{offset_width - len(offset_sep)}}' + colour.off
-                else:
-                    offset_str = colour.green + f'{offset: >{offset_width - len(offset_sep)}}' + offset_sep + colour.off
-
-            fb1, chars_used = Bits._format_bits(bits, bits_per_group, sep, dtype1, colour.purple, colour.off, first_fb_width)
-            if first_fb_width is None:
-                first_fb_width = chars_used
-
-            fb2 = ''
-            if dtype2 is not None:
-                fb2, chars_used = Bits._format_bits(bits, bits_per_group, sep, dtype2, colour.blue, colour.off, second_fb_width)
-                if second_fb_width is None:
-                    second_fb_width = chars_used
-                fb2 = format_sep + fb2
-
-            if bitstring.options.lsb0 is True:
-                line_fmt = fb1 + fb2 + offset_str + '\n'
-            else:
-                line_fmt = offset_str + fb1 + fb2 + '\n'
-            stream.write(line_fmt)
-        return
-
-    @staticmethod
-    def _process_pp_tokens(token_list, fmt):
-        has_length_in_fmt = True
-        if len(token_list) == 1:
-            dtype1 = Dtype(*utils.parse_name_length_token(token_list[0]))
-            dtype2 = None
-            bits_per_group = dtype1.bitlength
-            if bits_per_group is None:
-                has_length_in_fmt = False
-                bits_per_group = {'bin': 8, 'hex': 8, 'oct': 12, 'bytes': 32}.get(dtype1.name)
-                if bits_per_group is None:
-                    raise ValueError(f"No length or default length available for pp() format '{fmt}'.")
-        elif len(token_list) == 2:
-            dtype1 = Dtype(*utils.parse_name_length_token(token_list[0]))
-            dtype2 = Dtype(*utils.parse_name_length_token(token_list[1]))
-            if dtype1.bitlength is not None and dtype2.bitlength is not None and dtype1.bitlength != dtype2.bitlength:
-                raise ValueError(
-                    f"Differing bit lengths of {dtype1.bitlength} and {dtype2.bitlength} in format string '{fmt}'.")
-            bits_per_group = dtype1.bitlength if dtype1.bitlength is not None else dtype2.bitlength
-            if bits_per_group is None:
-                has_length_in_fmt = False
-                try:
-                    bits_per_group = 2 * Bits._bits_per_char(dtype1.name) * Bits._bits_per_char(dtype2.name)
-                except ValueError:
-                    raise ValueError(f"Can't find a default bitlength to use for pp() format '{fmt}'.")
-                if bits_per_group >= 24:
-                    bits_per_group //= 2
-        else:
-            raise ValueError(
-                f"Only one or two tokens can be used in an pp() format - '{fmt}' has {len(token_list)} tokens.")
-        return dtype1, dtype2, bits_per_group, has_length_in_fmt
-
-    def pp(self, fmt: Optional[str] = None, width: int = 120, sep: str = ' ',
-           show_offset: bool = True, stream: TextIO = sys.stdout) -> None:
-        """Pretty print the bitstring's value.
-
-        fmt -- Printed data format. One or two of 'bin', 'oct', 'hex' or 'bytes'.
-              The number of bits represented in each printed group defaults to 8 for hex and bin,
-              12 for oct and 32 for bytes. This can be overridden with an explicit length, e.g. 'hex:64'.
-              Use a length of 0 to not split into groups, e.g. `bin:0`.
-        width -- Max width of printed lines. Defaults to 120. A single group will always be printed
-                 per line even if it exceeds the max width.
-        sep -- A separator string to insert between groups. Defaults to a single space.
-        show_offset -- If True (the default) shows the bit offset in the first column of each line.
-        stream -- A TextIO object with a write() method. Defaults to sys.stdout.
-
-        >>> s.pp('hex16')
-        >>> s.pp('b, h', sep='_', show_offset=False)
-
-        """
-        colour = Colour(not bitstring.options.no_color)
-        if fmt is None:
-            fmt = 'bin, hex' if len(self) % 8 == 0 and len(self) >= 8 else 'bin'
-        token_list = utils.preprocess_tokens(fmt)
-        dtype1, dtype2, bits_per_group, has_length_in_fmt = Bits._process_pp_tokens(token_list, fmt)
-        trailing_bit_length = len(self) % bits_per_group if has_length_in_fmt and bits_per_group else 0
-        data = self if trailing_bit_length == 0 else self[0: -trailing_bit_length]
-        format_sep = " : "  # String to insert on each line between multiple formats
-        tidy_fmt = colour.purple + str(dtype1) + colour.off
-        if dtype2 is not None:
-            tidy_fmt += ', ' + colour.blue + str(dtype2) + colour.off
-        output_stream = io.StringIO()
-        len_str = colour.green + str(len(self)) + colour.off
-        output_stream.write(f"<{self.__class__.__name__}, fmt='{tidy_fmt}', length={len_str} bits> [\n")
-        data._pp(dtype1, dtype2, bits_per_group, width, sep, format_sep, show_offset,
-                 output_stream, bitstring.options.lsb0, 1)
-        output_stream.write("]")
-        if trailing_bit_length != 0:
-            output_stream.write(" + trailing_bits = " + str(self[-trailing_bit_length:]))
-        output_stream.write("\n")
-        stream.write(output_stream.getvalue())
-        return
-
-    def copy(self: TBits) -> TBits:
-        """Return a copy of the bitstring."""
-        # Note that if you want a new copy (different ID), use _copy instead.
-        # The copy can return self as it's immutable.
-        return self
-
-    @classmethod
-    def fromstring(cls: TBits, s: str, /) -> TBits:
-        """Create a new bitstring from a formatted string."""
-        x = super().__new__(cls)
-        x._bitstore = bitstore_helpers.str_to_bitstore(s)
-        return x
-
-    len = length = property(_getlength, doc="The length of the bitstring in bits. Read only.")
-
-
+from __future__ import annotations
+
+import numbers
+import pathlib
+import sys
+import mmap
+import struct
+import array
+import io
+from collections import abc
+import functools
+from typing import Tuple, Union, List, Iterable, Any, Optional, BinaryIO, TextIO, overload, Iterator, Type, TypeVar
+import bitarray
+import bitarray.util
+import bitstring
+from bitstring.bitstore import BitStore
+from bitstring import bitstore_helpers, utils
+from bitstring.dtypes import Dtype, dtype_register
+from bitstring.fp8 import p4binary_fmt, p3binary_fmt
+from bitstring.mxfp import e3m2mxfp_fmt, e2m3mxfp_fmt, e2m1mxfp_fmt, e4m3mxfp_saturate_fmt, e5m2mxfp_saturate_fmt
+from bitstring.bitstring_options import Colour
+
+# Things that can be converted to Bits when a Bits type is needed
+BitsType = Union['Bits', str, Iterable[Any], bool, BinaryIO, bytearray, bytes, memoryview, bitarray.bitarray]
+
+TBits = TypeVar("TBits", bound='Bits')
+
+# Maximum number of digits to use in __str__ and __repr__.
+MAX_CHARS: int = 250
+
+
+class Bits:
+    """A container holding an immutable sequence of bits.
+
+    For a mutable container use the BitArray class instead.
+
+    Methods:
+
+    all() -- Check if all specified bits are set to 1 or 0.
+    any() -- Check if any of specified bits are set to 1 or 0.
+    copy() - Return a copy of the bitstring.
+    count() -- Count the number of bits set to 1 or 0.
+    cut() -- Create generator of constant sized chunks.
+    endswith() -- Return whether the bitstring ends with a sub-string.
+    find() -- Find a sub-bitstring in the current bitstring.
+    findall() -- Find all occurrences of a sub-bitstring in the current bitstring.
+    fromstring() -- Create a bitstring from a formatted string.
+    join() -- Join bitstrings together using current bitstring.
+    pp() -- Pretty print the bitstring.
+    rfind() -- Seek backwards to find a sub-bitstring.
+    split() -- Create generator of chunks split by a delimiter.
+    startswith() -- Return whether the bitstring starts with a sub-bitstring.
+    tobitarray() -- Return bitstring as a bitarray from the bitarray package.
+    tobytes() -- Return bitstring as bytes, padding if needed.
+    tofile() -- Write bitstring to file, padding if needed.
+    unpack() -- Interpret bits using format string.
+
+    Special methods:
+
+    Also available are the operators [], ==, !=, +, *, ~, <<, >>, &, |, ^.
+
+    Properties:
+
+    [GENERATED_PROPERTY_DESCRIPTIONS]
+
+    len -- Length of the bitstring in bits.
+
+    """
+    __slots__ = ('_bitstore', '_filename')
+
+    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,
+                 offset: Optional[int] = None, **kwargs) -> None:
+        """Either specify an 'auto' initialiser:
+        A string of comma separated tokens, an integer, a file object,
+        a bytearray, a boolean iterable, an array or another bitstring.
+
+        Or initialise via **kwargs with one (and only one) of:
+        bin -- binary string representation, e.g. '0b001010'.
+        hex -- hexadecimal string representation, e.g. '0x2ef'
+        oct -- octal string representation, e.g. '0o777'.
+        bytes -- raw data as a bytes object, for example read from a binary file.
+        int -- a signed integer.
+        uint -- an unsigned integer.
+        float / floatbe -- a big-endian floating point number.
+        bool -- a boolean (True or False).
+        se -- a signed exponential-Golomb code.
+        ue -- an unsigned exponential-Golomb code.
+        sie -- a signed interleaved exponential-Golomb code.
+        uie -- an unsigned interleaved exponential-Golomb code.
+        floatle -- a little-endian floating point number.
+        floatne -- a native-endian floating point number.
+        bfloat / bfloatbe - a big-endian bfloat format 16-bit floating point number.
+        bfloatle -- a little-endian bfloat format 16-bit floating point number.
+        bfloatne -- a native-endian bfloat format 16-bit floating point number.
+        intbe -- a signed big-endian whole byte integer.
+        intle -- a signed little-endian whole byte integer.
+        intne -- a signed native-endian whole byte integer.
+        uintbe -- an unsigned big-endian whole byte integer.
+        uintle -- an unsigned little-endian whole byte integer.
+        uintne -- an unsigned native-endian whole byte integer.
+        filename -- the path of a file which will be opened in binary read-only mode.
+
+        Other keyword arguments:
+        length -- length of the bitstring in bits, if needed and appropriate.
+                  It must be supplied for all integer and float initialisers.
+        offset -- bit offset to the data. These offset bits are
+                  ignored and this is mainly intended for use when
+                  initialising using 'bytes' or 'filename'.
+
+        """
+        self._bitstore.immutable = True
+
+    def __new__(cls: Type[TBits], auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,
+                offset: Optional[int] = None, pos: Optional[int] = None, **kwargs) -> TBits:
+        x = super().__new__(cls)
+        if auto is None and not kwargs:
+            # No initialiser so fill with zero bits up to length
+            if length is not None:
+                x._bitstore = BitStore(length)
+                x._bitstore.setall(0)
+            else:
+                x._bitstore = BitStore()
+            return x
+        x._initialise(auto, length, offset, **kwargs)
+        return x
+
+    @classmethod
+    def _create_from_bitstype(cls: Type[TBits], auto: BitsType, /) -> TBits:
+        if isinstance(auto, cls):
+            return auto
+        b = super().__new__(cls)
+        b._setauto_no_length_or_offset(auto)
+        return b
+
+    def _initialise(self, auto: Any, /, length: Optional[int], offset: Optional[int], **kwargs) -> None:
+        if auto is not None:
+            if isinstance(auto, numbers.Integral):
+                # Initialise with s zero bits.
+                if auto < 0:
+                    raise bitstring.CreationError(f"Can't create bitstring of negative length {auto}.")
+                self._bitstore = BitStore(int(auto))
+                self._bitstore.setall(0)
+                return
+            self._setauto(auto, length, offset)
+            return
+        k, v = kwargs.popitem()
+        if k == 'bytes':
+            # Special case for bytes as we want to allow offsets and lengths to work only on creation.
+            self._setbytes_with_truncation(v, length, offset)
+            return
+        if k == 'filename':
+            self._setfile(v, length, offset)
+            return
+        if k == 'bitarray':
+            self._setbitarray(v, length, offset)
+            return
+        if k == 'auto':
+            raise bitstring.CreationError(
+                f"The 'auto' parameter should not be given explicitly - just use the first positional argument. "
+                f"Instead of '{self.__class__.__name__}(auto=x)' use '{self.__class__.__name__}(x)'.")
+        if offset is not None:
+            raise bitstring.CreationError("offset cannot be used when initialising with '{k}'.")
+        try:
+            Dtype(k, length).set_fn(self, v)
+        except ValueError as e:
+            raise bitstring.CreationError(e)
+
+    def __getattr__(self, attribute: str) -> Any:
+        # Support for arbitrary attributes like u16 or f64.
+        try:
+            d = Dtype(attribute)
+        except ValueError:
+            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{attribute}'.")
+        if d.bitlength is not None and len(self) != d.bitlength:
+            raise ValueError(f"bitstring length {len(self)} doesn't match length {d.bitlength} of property '{attribute}'.")
+        return d.get_fn(self)
+
+    def __iter__(self) -> Iterable[bool]:
+        return iter(self._bitstore)
+
+    def __copy__(self: TBits) -> TBits:
+        """Return a new copy of the Bits for the copy module."""
+        # Note that if you want a new copy (different ID), use _copy instead.
+        # The copy can return self as it's immutable.
+        return self
+
+    def __lt__(self, other: Any) -> bool:
+        # bitstrings can't really be ordered.
+        return NotImplemented
+
+    def __gt__(self, other: Any) -> bool:
+        return NotImplemented
+
+    def __le__(self, other: Any) -> bool:
+        return NotImplemented
+
+    def __ge__(self, other: Any) -> bool:
+        return NotImplemented
+
+    def __add__(self: TBits, bs: BitsType) -> TBits:
+        """Concatenate bitstrings and return new bitstring.
+
+        bs -- the bitstring to append.
+
+        """
+        bs = self.__class__._create_from_bitstype(bs)
+        s = self._copy() if len(bs) <= len(self) else bs._copy()
+        if len(bs) <= len(self):
+            s._addright(bs)
+        else:
+            s._addleft(self)
+        return s
+
+    def __radd__(self: TBits, bs: BitsType) -> TBits:
+        """Append current bitstring to bs and return new bitstring.
+
+        bs -- An object that can be 'auto' initialised as a bitstring that will be appended to.
+
+        """
+        bs = self.__class__._create_from_bitstype(bs)
+        return bs.__add__(self)
+
+    @overload
+    def __getitem__(self: TBits, key: slice, /) -> TBits:
+        ...
+
+    @overload
+    def __getitem__(self, key: int, /) -> bool:
+        ...
+
+    def __getitem__(self: TBits, key: Union[slice, int], /) -> Union[TBits, bool]:
+        """Return a new bitstring representing a slice of the current bitstring.
+
+        Indices are in units of the step parameter (default 1 bit).
+        Stepping is used to specify the number of bits in each item.
+
+        >>> print(BitArray('0b00110')[1:4])
+        '0b011'
+        >>> print(BitArray('0x00112233')[1:3:8])
+        '0x1122'
+
+        """
+        if isinstance(key, numbers.Integral):
+            return bool(self._bitstore.getindex(key))
+        bs = super().__new__(self.__class__)
+        bs._bitstore = self._bitstore.getslice_withstep(key)
+        return bs
+
+    def __len__(self) -> int:
+        """Return the length of the bitstring in bits."""
+        return self._getlength()
+
+    def __bytes__(self) -> bytes:
+        return self.tobytes()
+
+    def __str__(self) -> str:
+        """Return approximate string representation of bitstring for printing.
+
+        Short strings will be given wholly in hexadecimal or binary. Longer
+        strings may be part hexadecimal and part binary. Very long strings will
+        be truncated with '...'.
+
+        """
+        length = len(self)
+        if not length:
+            return ''
+        if length > MAX_CHARS * 4:
+            # Too long for hex. Truncate...
+            return ''.join(('0x', self[0:MAX_CHARS*4]._gethex(), '...'))
+        # If it's quite short and we can't do hex then use bin
+        if length < 32 and length % 4 != 0:
+            return '0b' + self.bin
+        # If we can use hex then do so
+        if not length % 4:
+            return '0x' + self.hex
+        # Otherwise first we do as much as we can in hex
+        # then add on 1, 2 or 3 bits on at the end
+        bits_at_end = length % 4
+        return ''.join(('0x', self[0:length - bits_at_end]._gethex(),
+                        ', ', '0b', self[length - bits_at_end:]._getbin()))
+
+    def _repr(self, classname: str, length: int, pos: int):
+        pos_string = f', pos={pos}' if pos else ''
+        if hasattr(self, '_filename') and self._filename:
+            return f"{classname}(filename={self._filename!r}, length={length}{pos_string})"
+        else:
+            s = self.__str__()
+            lengthstring = ''
+            if s.endswith('...'):
+                lengthstring = f'  # length={length}'
+            return f"{classname}('{s}'{pos_string}){lengthstring}"
+
+    def __repr__(self) -> str:
+        """Return representation that could be used to recreate the bitstring.
+
+        If the returned string is too long it will be truncated. See __str__().
+
+        """
+        return self._repr(self.__class__.__name__, len(self), 0)
+
+    def __eq__(self, bs: Any, /) -> bool:
+        """Return True if two bitstrings have the same binary representation.
+
+        >>> BitArray('0b1110') == '0xe'
+        True
+
+        """
+        try:
+            return self._bitstore == Bits._create_from_bitstype(bs)._bitstore
+        except TypeError:
+            return False
+
+    def __ne__(self, bs: Any, /) -> bool:
+        """Return False if two bitstrings have the same binary representation.
+
+        >>> BitArray('0b111') == '0x7'
+        False
+
+        """
+        return not self.__eq__(bs)
+
+    def __invert__(self: TBits) -> TBits:
+        """Return bitstring with every bit inverted.
+
+        Raises Error if the bitstring is empty.
+
+        """
+        if len(self) == 0:
+            raise bitstring.Error("Cannot invert empty bitstring.")
+        s = self._copy()
+        s._invert_all()
+        return s
+
+    def __lshift__(self: TBits, n: int, /) -> TBits:
+        """Return bitstring with bits shifted by n to the left.
+
+        n -- the number of bits to shift. Must be >= 0.
+
+        """
+        if n < 0:
+            raise ValueError("Cannot shift by a negative amount.")
+        if len(self) == 0:
+            raise ValueError("Cannot shift an empty bitstring.")
+        n = min(n, len(self))
+        s = self._absolute_slice(n, len(self))
+        s._addright(Bits(n))
+        return s
+
+    def __rshift__(self: TBits, n: int, /) -> TBits:
+        """Return bitstring with bits shifted by n to the right.
+
+        n -- the number of bits to shift. Must be >= 0.
+
+        """
+        if n < 0:
+            raise ValueError("Cannot shift by a negative amount.")
+        if len(self) == 0:
+            raise ValueError("Cannot shift an empty bitstring.")
+        if not n:
+            return self._copy()
+        s = self.__class__(length=min(n, len(self)))
+        n = min(n, len(self))
+        s._addright(self._absolute_slice(0, len(self) - n))
+        return s
+
+    def __mul__(self: TBits, n: int, /) -> TBits:
+        """Return bitstring consisting of n concatenations of self.
+
+        Called for expression of the form 'a = b*3'.
+        n -- The number of concatenations. Must be >= 0.
+
+        """
+        if n < 0:
+            raise ValueError("Cannot multiply by a negative integer.")
+        if not n:
+            return self.__class__()
+        s = self._copy()
+        s._imul(n)
+        return s
+
+    def __rmul__(self: TBits, n: int, /) -> TBits:
+        """Return bitstring consisting of n concatenations of self.
+
+        Called for expressions of the form 'a = 3*b'.
+        n -- The number of concatenations. Must be >= 0.
+
+        """
+        return self.__mul__(n)
+
+    def __and__(self: TBits, bs: BitsType, /) -> TBits:
+        """Bit-wise 'and' between two bitstrings. Returns new bitstring.
+
+        bs -- The bitstring to '&' with.
+
+        Raises ValueError if the two bitstrings have differing lengths.
+
+        """
+        if bs is self:
+            return self.copy()
+        bs = Bits._create_from_bitstype(bs)
+        s = object.__new__(self.__class__)
+        s._bitstore = self._bitstore & bs._bitstore
+        return s
+
+    def __rand__(self: TBits, bs: BitsType, /) -> TBits:
+        """Bit-wise 'and' between two bitstrings. Returns new bitstring.
+
+        bs -- the bitstring to '&' with.
+
+        Raises ValueError if the two bitstrings have differing lengths.
+
+        """
+        return self.__and__(bs)
+
+    def __or__(self: TBits, bs: BitsType, /) -> TBits:
+        """Bit-wise 'or' between two bitstrings. Returns new bitstring.
+
+        bs -- The bitstring to '|' with.
+
+        Raises ValueError if the two bitstrings have differing lengths.
+
+        """
+        if bs is self:
+            return self.copy()
+        bs = Bits._create_from_bitstype(bs)
+        s = object.__new__(self.__class__)
+        s._bitstore = self._bitstore | bs._bitstore
+        return s
+
+    def __ror__(self: TBits, bs: BitsType, /) -> TBits:
+        """Bit-wise 'or' between two bitstrings. Returns new bitstring.
+
+        bs -- The bitstring to '|' with.
+
+        Raises ValueError if the two bitstrings have differing lengths.
+
+        """
+        return self.__or__(bs)
+
+    def __xor__(self: TBits, bs: BitsType, /) -> TBits:
+        """Bit-wise 'xor' between two bitstrings. Returns new bitstring.
+
+        bs -- The bitstring to '^' with.
+
+        Raises ValueError if the two bitstrings have differing lengths.
+
+        """
+        bs = Bits._create_from_bitstype(bs)
+        s = object.__new__(self.__class__)
+        s._bitstore = self._bitstore ^ bs._bitstore
+        return s
+
+    def __rxor__(self: TBits, bs: BitsType, /) -> TBits:
+        """Bit-wise 'xor' between two bitstrings. Returns new bitstring.
+
+        bs -- The bitstring to '^' with.
+
+        Raises ValueError if the two bitstrings have differing lengths.
+
+        """
+        return self.__xor__(bs)
+
+    def __contains__(self, bs: BitsType, /) -> bool:
+        """Return whether bs is contained in the current bitstring.
+
+        bs -- The bitstring to search for.
+
+        """
+        found = Bits.find(self, bs, bytealigned=False)
+        return bool(found)
+
+    def __hash__(self) -> int:
+        """Return an integer hash of the object."""
+        # Only requirement is that equal bitstring should return the same hash.
+        # For equal bitstrings the bytes at the start/end will be the same and they will have the same length
+        # (need to check the length as there could be zero padding when getting the bytes). We do not check any
+        # bit position inside the bitstring as that does not feature in the __eq__ operation.
+        if len(self) <= 2000:
+            # Use the whole bitstring.
+            return hash((self.tobytes(), len(self)))
+        else:
+            # We can't in general hash the whole bitstring (it could take hours!)
+            # So instead take some bits from the start and end.
+            return hash(((self[:800] + self[-800:]).tobytes(), len(self)))
+
+    def __bool__(self) -> bool:
+        """Return False if bitstring is empty, otherwise return True."""
+        return len(self) != 0
+
+    def _clear(self) -> None:
+        """Reset the bitstring to an empty state."""
+        self._bitstore = BitStore()
+
+    def _setauto_no_length_or_offset(self, s: BitsType, /) -> None:
+        """Set bitstring from a bitstring, file, bool, array, iterable or string."""
+        if isinstance(s, str):
+            self._bitstore = bitstore_helpers.str_to_bitstore(s)
+        elif isinstance(s, Bits):
+            self._bitstore = s._bitstore.copy()
+        elif isinstance(s, (bytes, bytearray, memoryview)):
+            self._bitstore = BitStore.frombytes(bytearray(s))
+        elif isinstance(s, io.BytesIO):
+            self._bitstore = BitStore.frombytes(s.getvalue())
+        elif isinstance(s, io.BufferedReader):
+            self._setfile(s.name)
+        elif isinstance(s, bitarray.bitarray):
+            self._bitstore = BitStore(s)
+        elif isinstance(s, array.array):
+            self._bitstore = BitStore.frombytes(s.tobytes())
+        elif isinstance(s, abc.Iterable):
+            # Evaluate each item as True or False and set bits to 1 or 0.
+            self._setbin_unsafe(''.join(str(int(bool(x))) for x in s))
+        elif isinstance(s, numbers.Integral):
+            raise TypeError(f"It's no longer possible to auto initialise a bitstring from an integer."
+                            f" Use '{self.__class__.__name__}({s})' instead of just '{s}' as this makes it "
+                            f"clearer that a bitstring of {int(s)} zero bits will be created.")
+        else:
+            raise TypeError(f"Cannot initialise bitstring from type '{type(s)}'.")
+
+    def _setauto(self, s: BitsType, length: Optional[int], offset: Optional[int], /) -> None:
+        """Set bitstring from a bitstring, file, bool, array, iterable or string."""
+        # As s can be so many different things it's important to do the checks
+        # in the correct order, as some types are also other allowed types.
+        if offset is None and length is None:
+            return self._setauto_no_length_or_offset(s)
+        if offset is None:
+            offset = 0
+
+        if isinstance(s, io.BytesIO):
+            if length is None:
+                length = s.seek(0, 2) * 8 - offset
+            byteoffset, offset = divmod(offset, 8)
+            bytelength = (length + byteoffset * 8 + offset + 7) // 8 - byteoffset
+            if length + byteoffset * 8 + offset > s.seek(0, 2) * 8:
+                raise bitstring.CreationError("BytesIO object is not long enough for specified length and offset.")
+            self._bitstore = BitStore.frombytes(s.getvalue()[byteoffset: byteoffset + bytelength]).getslice(
+                offset, offset + length)
+            return
+
+        if isinstance(s, io.BufferedReader):
+            self._setfile(s.name, length, offset)
+            return
+
+        if isinstance(s, (str, Bits, bytes, bytearray, memoryview, io.BytesIO, io.BufferedReader,
+                          bitarray.bitarray, array.array, abc.Iterable)):
+            raise bitstring.CreationError(f"Cannot initialise bitstring from type '{type(s)}' when using explicit lengths or offsets.")
+        raise TypeError(f"Cannot initialise bitstring from type '{type(s)}'.")
+
+    def _setfile(self, filename: str, length: Optional[int] = None, offset: Optional[int] = None) -> None:
+        """Use file as source of bits."""
+        with open(pathlib.Path(filename), 'rb') as source:
+            if offset is None:
+                offset = 0
+            m = mmap.mmap(source.fileno(), 0, access=mmap.ACCESS_READ)
+            if offset == 0:
+                self._filename = source.name
+                self._bitstore = BitStore.frombuffer(m, length=length)
+            else:
+                # If offset is given then always read into memory.
+                temp = BitStore.frombuffer(m)
+                if length is None:
+                    if offset > len(temp):
+                        raise bitstring.CreationError(f"The offset of {offset} bits is greater than the file length ({len(temp)} bits).")
+                    self._bitstore = temp.getslice(offset, None)
+                else:
+                    self._bitstore = temp.getslice(offset, offset + length)
+                    if len(self) != length:
+                        raise bitstring.CreationError(f"Can't use a length of {length} bits and an offset of {offset} bits as file length is only {len(temp)} bits.")
+
+    def _setbitarray(self, ba: bitarray.bitarray, length: Optional[int], offset: Optional[int]) -> None:
+        if offset is None:
+            offset = 0
+        if offset > len(ba):
+            raise bitstring.CreationError(f"Offset of {offset} too large for bitarray of length {len(ba)}.")
+        if length is None:
+            self._bitstore = BitStore(ba[offset:])
+        else:
+            if offset + length > len(ba):
+                raise bitstring.CreationError(
+                    f"Offset of {offset} and length of {length} too large for bitarray of length {len(ba)}.")
+            self._bitstore = BitStore(ba[offset: offset + length])
+
+    def _setbits(self, bs: BitsType, length: None = None) -> None:
+        bs = Bits._create_from_bitstype(bs)
+        self._bitstore = bs._bitstore
+
+    def _setp3binary(self, f: float) -> None:
+        self._bitstore = bitstore_helpers.p3binary2bitstore(f)
+
+    def _setp4binary(self, f: float) -> None:
+        self._bitstore = bitstore_helpers.p4binary2bitstore(f)
+
+    def _sete4m3mxfp(self, f: float) -> None:
+        self._bitstore = bitstore_helpers.e4m3mxfp2bitstore(f)
+
+    def _sete5m2mxfp(self, f: float) -> None:
+        self._bitstore = bitstore_helpers.e5m2mxfp2bitstore(f)
+
+    def _sete3m2mxfp(self, f: float) -> None:
+        self._bitstore = bitstore_helpers.e3m2mxfp2bitstore(f)
+
+    def _sete2m3mxfp(self, f: float) -> None:
+        self._bitstore = bitstore_helpers.e2m3mxfp2bitstore(f)
+
+    def _sete2m1mxfp(self, f: float) -> None:
+        self._bitstore = bitstore_helpers.e2m1mxfp2bitstore(f)
+
+    def _sete8m0mxfp(self, f: float) -> None:
+        self._bitstore = bitstore_helpers.e8m0mxfp2bitstore(f)
+
+    def _setmxint(self, f: float) -> None:
+        self._bitstore = bitstore_helpers.mxint2bitstore(f)
+
+    def _setbytes(self, data: Union[bytearray, bytes, List], length:None = None) -> None:
+        """Set the data from a bytes or bytearray object."""
+        self._bitstore = BitStore.frombytes(bytes(data))
+
+    def _setbytes_with_truncation(self, data: Union[bytearray, bytes], length: Optional[int] = None, offset: Optional[int] = None) -> None:
+        """Set the data from a bytes or bytearray object, with optional offset and length truncations."""
+        if offset is None and length is None:
+            return self._setbytes(data)
+        data = bytearray(data)
+        if offset is None:
+            offset = 0
+        if length is None:
+            # Use to the end of the data
+            length = len(data) * 8 - offset
+        else:
+            if length + offset > len(data) * 8:
+                raise bitstring.CreationError(f"Not enough data present. Need {length + offset} bits, have {len(data) * 8}.")
+        self._bitstore = BitStore.frombytes(data).getslice_msb0(offset, offset + length)
+
+    def _getbytes(self) -> bytes:
+        """Return the data as an ordinary bytes object."""
+        if len(self) % 8:
+            raise bitstring.InterpretError("Cannot interpret as bytes unambiguously - not multiple of 8 bits.")
+        return self._bitstore.tobytes()
+
+    _unprintable = list(range(0x00, 0x20))  # ASCII control characters
+    _unprintable.extend(range(0x7f, 0xff))  # DEL char + non-ASCII
+
+    def _getbytes_printable(self) -> str:
+        """Return an approximation of the data as a string of printable characters."""
+        bytes_ = self._getbytes()
+        # For everything that isn't printable ASCII, use value from 'Latin Extended-A' unicode block.
+        string = ''.join(chr(0x100 + x) if x in Bits._unprintable else chr(x) for x in bytes_)
+        return string
+
+    def _setuint(self, uint: int, length: Optional[int] = None) -> None:
+        """Reset the bitstring to have given unsigned int interpretation."""
+        # If no length given, and we've previously been given a length, use it.
+        if length is None and hasattr(self, 'len') and len(self) != 0:
+            length = len(self)
+        if length is None or length == 0:
+            raise bitstring.CreationError("A non-zero length must be specified with a uint initialiser.")
+        self._bitstore = bitstore_helpers.int2bitstore(uint, length, False)
+
+    def _getuint(self) -> int:
+        """Return data as an unsigned int."""
+        if len(self) == 0:
+            raise bitstring.InterpretError("Cannot interpret a zero length bitstring as an integer.")
+        return self._bitstore.slice_to_uint()
+
+    def _setint(self, int_: int, length: Optional[int] = None) -> None:
+        """Reset the bitstring to have given signed int interpretation."""
+        # If no length given, and we've previously been given a length, use it.
+        if length is None and hasattr(self, 'len') and len(self) != 0:
+            length = len(self)
+        if length is None or length == 0:
+            raise bitstring.CreationError("A non-zero length must be specified with an int initialiser.")
+        self._bitstore = bitstore_helpers.int2bitstore(int_, length, True)
+
+    def _getint(self) -> int:
+        """Return data as a two's complement signed int."""
+        if len(self) == 0:
+            raise bitstring.InterpretError("Cannot interpret bitstring without a length as an integer.")
+        return self._bitstore.slice_to_int()
+
+    def _setuintbe(self, uintbe: int, length: Optional[int] = None) -> None:
+        """Set the bitstring to a big-endian unsigned int interpretation."""
+        if length is None and hasattr(self, 'len') and len(self) != 0:
+            length = len(self)
+        if length is None or length == 0:
+            raise bitstring.CreationError("A non-zero length must be specified with a uintbe initialiser.")
+        self._bitstore = bitstore_helpers.int2bitstore(uintbe, length, False)
+
+    def _getuintbe(self) -> int:
+        """Return data as a big-endian two's complement unsigned int."""
+        if len(self) % 8:
+            raise bitstring.InterpretError(f"Big-endian integers must be whole-byte. Length = {len(self)} bits.")
+        return self._getuint()
+
+    def _setintbe(self, intbe: int, length: Optional[int] = None) -> None:
+        """Set bitstring to a big-endian signed int interpretation."""
+        if length is None and hasattr(self, 'len') and len(self) != 0:
+            length = len(self)
+        if length is None or length == 0:
+            raise bitstring.CreationError("A non-zero length must be specified with a intbe initialiser.")
+        self._bitstore = bitstore_helpers.int2bitstore(intbe, length, True)
+
+    def _getintbe(self) -> int:
+        """Return data as a big-endian two's complement signed int."""
+        if len(self) % 8:
+            raise bitstring.InterpretError(f"Big-endian integers must be whole-byte. Length = {len(self)} bits.")
+        return self._getint()
+
+    def _setuintle(self, uintle: int, length: Optional[int] = None) -> None:
+        if length is None and hasattr(self, 'len') and len(self) != 0:
+            length = len(self)
+        if length is None or length == 0:
+            raise bitstring.CreationError("A non-zero length must be specified with a uintle initialiser.")
+        self._bitstore = bitstore_helpers.intle2bitstore(uintle, length, False)
+
+    def _getuintle(self) -> int:
+        """Interpret as a little-endian unsigned int."""
+        if len(self) % 8:
+            raise bitstring.InterpretError(f"Little-endian integers must be whole-byte. Length = {len(self)} bits.")
+        bs = BitStore.frombytes(self._bitstore.tobytes()[::-1])
+        return bs.slice_to_uint()
+
+    def _setintle(self, intle: int, length: Optional[int] = None) -> None:
+        if length is None and hasattr(self, 'len') and len(self) != 0:
+            length = len(self)
+        if length is None or length == 0:
+            raise bitstring.CreationError("A non-zero length must be specified with an intle initialiser.")
+        self._bitstore = bitstore_helpers.intle2bitstore(intle, length, True)
+
+    def _getintle(self) -> int:
+        """Interpret as a little-endian signed int."""
+        if len(self) % 8:
+            raise bitstring.InterpretError(f"Little-endian integers must be whole-byte. Length = {len(self)} bits.")
+        bs = BitStore.frombytes(self._bitstore.tobytes()[::-1])
+        return bs.slice_to_int()
+
+    def _getp4binary(self) -> float:
+        u = self._getuint()
+        return p4binary_fmt.lut_binary8_to_float[u]
+
+    def _getp3binary(self) -> float:
+        u = self._getuint()
+        return p3binary_fmt.lut_binary8_to_float[u]
+
+    def _gete4m3mxfp(self) -> float:
+        u = self._getuint()
+        return e4m3mxfp_saturate_fmt.lut_int_to_float[u]
+
+    def _gete5m2mxfp(self) -> float:
+        u = self._getuint()
+        return e5m2mxfp_saturate_fmt.lut_int_to_float[u]
+
+    def _gete3m2mxfp(self) -> float:
+        u = self._getuint()
+        return e3m2mxfp_fmt.lut_int_to_float[u]
+
+    def _gete2m3mxfp(self) -> float:
+        u = self._getuint()
+        return e2m3mxfp_fmt.lut_int_to_float[u]
+
+    def _gete2m1mxfp(self) -> float:
+        u = self._getuint()
+        return e2m1mxfp_fmt.lut_int_to_float[u]
+
+    def _gete8m0mxfp(self) -> float:
+        u = self._getuint() - 127
+        if u == 128:
+            return float('nan')
+        return 2.0 ** u
+
+    def _getmxint(self) -> float:
+        u = self._getint()
+        return float(u) * 2 ** -6
+
+    def _setfloat(self, f: float, length: Optional[int], big_endian: bool) -> None:
+        if length is None and hasattr(self, 'len') and len(self) != 0:
+            length = len(self)
+        if length is None or length not in [16, 32, 64]:
+            raise bitstring.CreationError("A length of 16, 32, or 64 must be specified with a float initialiser.")
+        self._bitstore = bitstore_helpers.float2bitstore(f, length, big_endian)
+
+    def _setfloatbe(self, f: float, length: Optional[int] = None) -> None:
+        self._setfloat(f, length, True)
+
+    def _getfloatbe(self) -> float:
+        """Interpret the whole bitstring as a big-endian float."""
+        fmt = {16: '>e', 32: '>f', 64: '>d'}[len(self)]
+        return struct.unpack(fmt, self._bitstore.tobytes())[0]
+
+    def _setfloatle(self, f: float, length: Optional[int] = None) -> None:
+        self._setfloat(f, length, False)
+
+    def _getfloatle(self) -> float:
+        """Interpret the whole bitstring as a little-endian float."""
+        fmt = {16: '<e', 32: '<f', 64: '<d'}[len(self)]
+        return struct.unpack(fmt, self._bitstore.tobytes())[0]
+
+    def _getbfloatbe(self) -> float:
+        zero_padded = self + Bits(16)
+        return zero_padded._getfloatbe()
+
+    def _setbfloatbe(self, f: Union[float, str], length: Optional[int] = None) -> None:
+        if length is not None and length != 16:
+            raise bitstring.CreationError(f"bfloats must be length 16, received a length of {length} bits.")
+        self._bitstore = bitstore_helpers.bfloat2bitstore(f, True)
+
+    def _getbfloatle(self) -> float:
+        zero_padded = Bits(16) + self
+        return zero_padded._getfloatle()
+
+    def _setbfloatle(self, f: Union[float, str], length: Optional[int] = None) -> None:
+        if length is not None and length != 16:
+            raise bitstring.CreationError(f"bfloats must be length 16, received a length of {length} bits.")
+        self._bitstore = bitstore_helpers.bfloat2bitstore(f, False)
+
+    def _setue(self, i: int) -> None:
+        """Initialise bitstring with unsigned exponential-Golomb code for integer i.
+
+        Raises CreationError if i < 0.
+
+        """
+        if bitstring.options.lsb0:
+            raise bitstring.CreationError("Exp-Golomb codes cannot be used in lsb0 mode.")
+        self._bitstore = bitstore_helpers.ue2bitstore(i)
+
+    def _readue(self, pos: int) -> Tuple[int, int]:
+        """Return interpretation of next bits as unsigned exponential-Golomb code.
+
+        Raises ReadError if the end of the bitstring is encountered while
+        reading the code.
+
+        """
+        if bitstring.options.lsb0:
+            raise bitstring.ReadError("Exp-Golomb codes cannot be read in lsb0 mode.")
+        oldpos = pos
+        try:
+            while not self[pos]:
+                pos += 1
+        except IndexError:
+            raise bitstring.ReadError("Read off end of bitstring trying to read code.")
+        leadingzeros = pos - oldpos
+        codenum = (1 << leadingzeros) - 1
+        if leadingzeros > 0:
+            if pos + leadingzeros + 1 > len(self):
+                raise bitstring.ReadError("Read off end of bitstring trying to read code.")
+            codenum += self[pos + 1:pos + 1 + leadingzeros]._getuint()
+            pos += leadingzeros + 1
+        else:
+            assert codenum == 0
+            pos += 1
+        return codenum, pos
+
+    def _getue(self) -> Tuple[int, int]:
+        try:
+            return self._readue(0)
+        except bitstring.ReadError:
+            raise bitstring.InterpretError
+
+    def _getse(self) -> Tuple[int, int]:
+        try:
+            return self._readse(0)
+        except bitstring.ReadError:
+            raise bitstring.InterpretError
+
+    def _getuie(self) -> Tuple[int, int]:
+        try:
+            return self._readuie(0)
+        except bitstring.ReadError:
+            raise bitstring.InterpretError
+
+    def _getsie(self) -> Tuple[int, int]:
+        try:
+            return self._readsie(0)
+        except bitstring.ReadError:
+            raise bitstring.InterpretError
+
+    def _setse(self, i: int) -> None:
+        """Initialise bitstring with signed exponential-Golomb code for integer i."""
+        if bitstring.options.lsb0:
+            raise bitstring.CreationError("Exp-Golomb codes cannot be used in lsb0 mode.")
+        self._bitstore = bitstore_helpers.se2bitstore(i)
+
+    def _readse(self, pos: int) -> Tuple[int, int]:
+        """Return interpretation of next bits as a signed exponential-Golomb code.
+
+        Advances position to after the read code.
+
+        Raises ReadError if the end of the bitstring is encountered while
+        reading the code.
+
+        """
+        codenum, pos = self._readue(pos)
+        m = (codenum + 1) // 2
+        return (m, pos) if codenum % 2 else (-m, pos)
+
+    def _setuie(self, i: int) -> None:
+        """Initialise bitstring with unsigned interleaved exponential-Golomb code for integer i.
+
+        Raises CreationError if i < 0.
+
+        """
+        if bitstring.options.lsb0:
+            raise bitstring.CreationError("Exp-Golomb codes cannot be used in lsb0 mode.")
+        self._bitstore = bitstore_helpers.uie2bitstore(i)
+
+    def _readuie(self, pos: int) -> Tuple[int, int]:
+        """Return interpretation of next bits as unsigned interleaved exponential-Golomb code.
+
+        Raises ReadError if the end of the bitstring is encountered while
+        reading the code.
+
+        """
+        if bitstring.options.lsb0:
+            raise bitstring.ReadError("Exp-Golomb codes cannot be read in lsb0 mode.")
+        try:
+            codenum: int = 1
+            while not self[pos]:
+                pos += 1
+                codenum <<= 1
+                codenum += self[pos]
+                pos += 1
+            pos += 1
+        except IndexError:
+            raise bitstring.ReadError("Read off end of bitstring trying to read code.")
+        return codenum - 1, pos
+
+    def _setsie(self, i: int, ) -> None:
+        """Initialise bitstring with signed interleaved exponential-Golomb code for integer i."""
+        if bitstring.options.lsb0:
+            raise bitstring.CreationError("Exp-Golomb codes cannot be used in lsb0 mode.")
+        self._bitstore = bitstore_helpers.sie2bitstore(i)
+
+    def _readsie(self, pos: int) -> Tuple[int, int]:
+        """Return interpretation of next bits as a signed interleaved exponential-Golomb code.
+
+        Advances position to after the read code.
+
+        Raises ReadError if the end of the bitstring is encountered while
+        reading the code.
+
+        """
+        codenum, pos = self._readuie(pos)
+        if not codenum:
+            return 0, pos
+        try:
+            return (-codenum, pos + 1) if self[pos] else (codenum, pos + 1)
+        except IndexError:
+            raise bitstring.ReadError("Read off end of bitstring trying to read code.")
+
+    def _setbool(self, value: Union[bool, str]) -> None:
+        # We deliberately don't want to have implicit conversions to bool here.
+        # If we did then it would be difficult to deal with the 'False' string.
+        if value in (1, 'True', '1'):
+            self._bitstore = BitStore('1')
+        elif value in (0, 'False', '0'):
+            self._bitstore = BitStore('0')
+        else:
+            raise bitstring.CreationError(f"Cannot initialise boolean with {value}.")
+
+    def _getbool(self) -> bool:
+        return self[0]
+
+    def _getpad(self) -> None:
+        return None
+
+    def _setpad(self, value: None, length: int) -> None:
+        self._bitstore = BitStore(length)
+
+    def _setbin_safe(self, binstring: str, length: None = None) -> None:
+        """Reset the bitstring to the value given in binstring."""
+        self._bitstore = bitstore_helpers.bin2bitstore(binstring)
+
+    def _setbin_unsafe(self, binstring: str, length: None = None) -> None:
+        """Same as _setbin_safe, but input isn't sanity checked. binstring mustn't start with '0b'."""
+        self._bitstore = bitstore_helpers.bin2bitstore_unsafe(binstring)
+
+    def _getbin(self) -> str:
+        """Return interpretation as a binary string."""
+        return self._bitstore.slice_to_bin()
+
+    def _setoct(self, octstring: str, length: None = None) -> None:
+        """Reset the bitstring to have the value given in octstring."""
+        self._bitstore = bitstore_helpers.oct2bitstore(octstring)
+
+    def _getoct(self) -> str:
+        """Return interpretation as an octal string."""
+        return self._bitstore.slice_to_oct()
+
+    def _sethex(self, hexstring: str, length: None = None) -> None:
+        """Reset the bitstring to have the value given in hexstring."""
+        self._bitstore = bitstore_helpers.hex2bitstore(hexstring)
+
+    def _gethex(self) -> str:
+        """Return the hexadecimal representation as a string.
+
+        Raises an InterpretError if the bitstring's length is not a multiple of 4.
+
+        """
+        return self._bitstore.slice_to_hex()
+
+    def _getlength(self) -> int:
+        """Return the length of the bitstring in bits."""
+        return len(self._bitstore)
+
+    def _copy(self: TBits) -> TBits:
+        """Create and return a new copy of the Bits (always in memory)."""
+        # Note that __copy__ may choose to return self if it's immutable. This method always makes a copy.
+        s_copy = self.__class__()
+        s_copy._bitstore = self._bitstore._copy()
+        return s_copy
+
+    def _slice(self: TBits, start: int, end: int) -> TBits:
+        """Used internally to get a slice, without error checking."""
+        bs = self.__class__()
+        bs._bitstore = self._bitstore.getslice(start, end)
+        return bs
+
+    def _absolute_slice(self: TBits, start: int, end: int) -> TBits:
+        """Used internally to get a slice, without error checking.
+        Uses MSB0 bit numbering even if LSB0 is set."""
+        if end == start:
+            return self.__class__()
+        assert start < end, f"start={start}, end={end}"
+        bs = self.__class__()
+        bs._bitstore = self._bitstore.getslice_msb0(start, end)
+        return bs
+
+    def _readtoken(self, name: str, pos: int, length: Optional[int]) -> Tuple[Union[float, int, str, None, Bits], int]:
+        """Reads a token from the bitstring and returns the result."""
+        dtype = dtype_register.get_dtype(name, length)
+        if dtype.bitlength is not None and dtype.bitlength > len(self) - pos:
+            raise bitstring.ReadError("Reading off the end of the data. "
+                            f"Tried to read {dtype.bitlength} bits when only {len(self) - pos} available.")
+        try:
+            val = dtype.read_fn(self, pos)
+            if isinstance(val, tuple):
+                return val
+            else:
+                assert length is not None
+                return val, pos + dtype.bitlength
+        except KeyError:
+            raise ValueError(f"Can't parse token {name}:{length}")
+
+    def _addright(self, bs: Bits, /) -> None:
+        """Add a bitstring to the RHS of the current bitstring."""
+        self._bitstore += bs._bitstore
+
+    def _addleft(self, bs: Bits, /) -> None:
+        """Prepend a bitstring to the current bitstring."""
+        if bs._bitstore.immutable:
+            self._bitstore = bs._bitstore._copy() + self._bitstore
+        else:
+            self._bitstore = bs._bitstore + self._bitstore
+
+    def _truncateleft(self: TBits, bits: int, /) -> TBits:
+        """Truncate bits from the start of the bitstring. Return the truncated bits."""
+        assert 0 <= bits <= len(self)
+        if bits == 0:
+            return self.__class__()
+        truncated_bits = self._absolute_slice(0, bits)
+        if bits == len(self):
+            self._clear()
+            return truncated_bits
+        self._bitstore = self._bitstore.getslice_msb0(bits, None)
+        return truncated_bits
+
+    def _truncateright(self: TBits, bits: int, /) -> TBits:
+        """Truncate bits from the end of the bitstring. Return the truncated bits."""
+        assert 0 <= bits <= len(self)
+        if bits == 0:
+            return self.__class__()
+        truncated_bits = self._absolute_slice(len(self) - bits, len(self))
+        if bits == len(self):
+            self._clear()
+            return truncated_bits
+        self._bitstore = self._bitstore.getslice_msb0(None, -bits)
+        return truncated_bits
+
+    def _insert(self, bs: Bits, pos: int, /) -> None:
+        """Insert bs at pos."""
+        assert 0 <= pos <= len(self)
+        self._bitstore[pos: pos] = bs._bitstore
+        return
+
+    def _overwrite(self, bs: Bits, pos: int, /) -> None:
+        """Overwrite with bs at pos."""
+        assert 0 <= pos <= len(self)
+        if bs is self:
+            # Just overwriting with self, so do nothing.
+            assert pos == 0
+            return
+        self._bitstore[pos: pos + len(bs)] = bs._bitstore
+
+    def _delete(self, bits: int, pos: int, /) -> None:
+        """Delete bits at pos."""
+        assert 0 <= pos <= len(self)
+        assert pos + bits <= len(self), f"pos={pos}, bits={bits}, len={len(self)}"
+        del self._bitstore[pos: pos + bits]
+        return
+
+    def _reversebytes(self, start: int, end: int) -> None:
+        """Reverse bytes in-place."""
+        assert (end - start) % 8 == 0
+        self._bitstore[start:end] = BitStore.frombytes(self._bitstore.getslice(start, end).tobytes()[::-1])
+
+    def _invert(self, pos: int, /) -> None:
+        """Flip bit at pos 1<->0."""
+        assert 0 <= pos < len(self)
+        self._bitstore.invert(pos)
+
+    def _invert_all(self) -> None:
+        """Invert every bit."""
+        self._bitstore.invert()
+
+    def _ilshift(self: TBits, n: int, /) -> TBits:
+        """Shift bits by n to the left in place. Return self."""
+        assert 0 < n <= len(self)
+        self._addright(Bits(n))
+        self._truncateleft(n)
+        return self
+
+    def _irshift(self: TBits, n: int, /) -> TBits:
+        """Shift bits by n to the right in place. Return self."""
+        assert 0 < n <= len(self)
+        self._addleft(Bits(n))
+        self._truncateright(n)
+        return self
+
+    def _imul(self: TBits, n: int, /) -> TBits:
+        """Concatenate n copies of self in place. Return self."""
+        assert n >= 0
+        if n == 0:
+            self._clear()
+        else:
+            m = 1
+            old_len = len(self)
+            while m * 2 < n:
+                self._addright(self)
+                m *= 2
+            self._addright(self[0:(n - m) * old_len])
+        return self
+
+    def _getbits(self: TBits):
+        return self._copy()
+
+    def _validate_slice(self, start: Optional[int], end: Optional[int]) -> Tuple[int, int]:
+        """Validate start and end and return them as positive bit positions."""
+        start = 0 if start is None else (start + len(self) if start < 0 else start)
+        end = len(self) if end is None else (end + len(self) if end < 0 else end)
+        if not 0 <= start <= end <= len(self):
+            raise ValueError(f"Invalid slice positions for bitstring length {len(self)}: start={start}, end={end}.")
+        return start, end
+
+    def unpack(self, fmt: Union[str, List[Union[str, int]]], **kwargs) -> List[Union[int, float, str, Bits, bool, bytes, None]]:
+        """Interpret the whole bitstring using fmt and return list.
+
+        fmt -- A single string or a list of strings with comma separated tokens
+               describing how to interpret the bits in the bitstring. Items
+               can also be integers, for reading new bitstring of the given length.
+        kwargs -- A dictionary or keyword-value pairs - the keywords used in the
+                  format string will be replaced with their given value.
+
+        Raises ValueError if the format is not understood. If not enough bits
+        are available then all bits to the end of the bitstring will be used.
+
+        See the docstring for 'read' for token examples.
+
+        """
+        return self._readlist(fmt, 0, **kwargs)[0]
+
+    def _readlist(self, fmt: Union[str, List[Union[str, int, Dtype]]], pos: int, **kwargs) \
+            -> Tuple[List[Union[int, float, str, Bits, bool, bytes, None]], int]:
+        if isinstance(fmt, str):
+            fmt = [fmt]
+        # Convert to a flat list of Dtypes
+        dtype_list = []
+        for f_item in fmt:
+            if isinstance(f_item, numbers.Integral):
+                dtype_list.append(Dtype('bits', f_item))
+            elif isinstance(f_item, Dtype):
+                dtype_list.append(f_item)
+            else:
+                token_list = utils.preprocess_tokens(f_item)
+                for t in token_list:
+                    try:
+                        name, length = utils.parse_name_length_token(t, **kwargs)
+                    except ValueError:
+                        dtype_list.append(Dtype('bits', int(t)))
+                    else:
+                        dtype_list.append(Dtype(name, length))
+        return self._read_dtype_list(dtype_list, pos)
+
+    def _read_dtype_list(self, dtypes: List[Dtype], pos: int) -> Tuple[List[Union[int, float, str, Bits, bool, bytes, None]], int]:
+        has_stretchy_token = False
+        bits_after_stretchy_token = 0
+        for dtype in dtypes:
+            stretchy = dtype.bitlength is None and not dtype.variable_length
+            if stretchy:
+                if has_stretchy_token:
+                    raise bitstring.Error("It's not possible to have more than one 'filler' token.")
+                has_stretchy_token = True
+            elif has_stretchy_token:
+                if dtype.variable_length:
+                    raise bitstring.Error(f"It's not possible to parse a variable length token '{dtype}' after a 'filler' token.")
+                bits_after_stretchy_token += dtype.bitlength
+
+        # We should have precisely zero or one stretchy token
+        vals = []
+        for dtype in dtypes:
+            stretchy = dtype.bitlength is None and not dtype.variable_length
+            if stretchy:
+                bits_remaining = len(self) - pos
+                # Set length to the remaining bits
+                bitlength = max(bits_remaining - bits_after_stretchy_token, 0)
+                items, remainder = divmod(bitlength, dtype.bits_per_item)
+                if remainder != 0:
+                    raise ValueError(
+                        f"The '{dtype.name}' type must have a bit length that is a multiple of {dtype.bits_per_item}"
+                        f" so cannot be created from the {bitlength} bits that are available for this stretchy token.")
+                dtype = Dtype(dtype.name, items)
+            if dtype.bitlength is not None:
+                val = dtype.read_fn(self, pos)
+                pos += dtype.bitlength
+            else:
+                val, pos = dtype.read_fn(self, pos)
+            if val is not None:  # Don't append pad tokens
+                vals.append(val)
+        return vals, pos
+
+    def find(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,
+             bytealigned: Optional[bool] = None) -> Union[Tuple[int], Tuple[()]]:
+        """Find first occurrence of substring bs.
+
+        Returns a single item tuple with the bit position if found, or an
+        empty tuple if not found. The bit position (pos property) will
+        also be set to the start of the substring if it is found.
+
+        bs -- The bitstring to find.
+        start -- The bit position to start the search. Defaults to 0.
+        end -- The bit position one past the last bit to search.
+               Defaults to len(self).
+        bytealigned -- If True the bitstring will only be
+                       found on byte boundaries.
+
+        Raises ValueError if bs is empty, if start < 0, if end > len(self) or
+        if end < start.
+
+        >>> BitArray('0xc3e').find('0b1111')
+        (6,)
+
+        """
+        bs = Bits._create_from_bitstype(bs)
+        if len(bs) == 0:
+            raise ValueError("Cannot find an empty bitstring.")
+        start, end = self._validate_slice(start, end)
+        ba = bitstring.options.bytealigned if bytealigned is None else bytealigned
+        p = self._find(bs, start, end, ba)
+        return p
+
+    def _find_lsb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -> Union[Tuple[int], Tuple[()]]:
+        # A forward find in lsb0 is very like a reverse find in msb0.
+        assert start <= end
+        assert bitstring.options.lsb0
+
+        new_slice = bitstring.bitstore.offset_slice_indices_lsb0(slice(start, end, None), len(self))
+        msb0_start, msb0_end = self._validate_slice(new_slice.start, new_slice.stop)
+        p = self._rfind_msb0(bs, msb0_start, msb0_end, bytealigned)
+
+        if p:
+            return (len(self) - p[0] - len(bs),)
+        else:
+            return ()
+
+    def _find_msb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -> Union[Tuple[int], Tuple[()]]:
+        """Find first occurrence of a binary string."""
+        p = self._bitstore.find(bs._bitstore, start, end, bytealigned)
+        return () if p == -1 else (p,)
+
+    def findall(self, bs: BitsType, start: Optional[int] = None, end: Optional[int] = None, count: Optional[int] = None,
+                bytealigned: Optional[bool] = None) -> Iterable[int]:
+        """Find all occurrences of bs. Return generator of bit positions.
+
+        bs -- The bitstring to find.
+        start -- The bit position to start the search. Defaults to 0.
+        end -- The bit position one past the last bit to search.
+               Defaults to len(self).
+        count -- The maximum number of occurrences to find.
+        bytealigned -- If True the bitstring will only be found on
+                       byte boundaries.
+
+        Raises ValueError if bs is empty, if start < 0, if end > len(self) or
+        if end < start.
+
+        Note that all occurrences of bs are found, even if they overlap.
+
+        """
+        if count is not None and count < 0:
+            raise ValueError("In findall, count must be >= 0.")
+        bs = Bits._create_from_bitstype(bs)
+        start, end = self._validate_slice(start, end)
+        ba = bitstring.options.bytealigned if bytealigned is None else bytealigned
+        return self._findall(bs, start, end, count, ba)
+
+    def _findall_msb0(self, bs: Bits, start: int, end: int, count: Optional[int],
+                      bytealigned: bool) -> Iterable[int]:
+        c = 0
+        for i in self._bitstore.findall_msb0(bs._bitstore, start, end, bytealigned):
+            if count is not None and c >= count:
+                return
+            c += 1
+            yield i
+        return
+
+    def _findall_lsb0(self, bs: Bits, start: int, end: int, count: Optional[int],
+                      bytealigned: bool) -> Iterable[int]:
+        assert start <= end
+        assert bitstring.options.lsb0
+
+        new_slice = bitstring.bitstore.offset_slice_indices_lsb0(slice(start, end, None), len(self))
+        msb0_start, msb0_end = self._validate_slice(new_slice.start, new_slice.stop)
+
+        # Search chunks starting near the end and then moving back.
+        c = 0
+        increment = max(8192, len(bs) * 80)
+        buffersize = min(increment + len(bs), msb0_end - msb0_start)
+        pos = max(msb0_start, msb0_end - buffersize)
+        while True:
+            found = list(self._findall_msb0(bs, start=pos, end=pos + buffersize, count=None, bytealigned=False))
+            if not found:
+                if pos == msb0_start:
+                    return
+                pos = max(msb0_start, pos - increment)
+                continue
+            while found:
+                if count is not None and c >= count:
+                    return
+                c += 1
+                lsb0_pos = len(self) - found.pop() - len(bs)
+                if not bytealigned or lsb0_pos % 8 == 0:
+                    yield lsb0_pos
+
+            pos = max(msb0_start, pos - increment)
+            if pos == msb0_start:
+                return
+
+    def rfind(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,
+              bytealigned: Optional[bool] = None) -> Union[Tuple[int], Tuple[()]]:
+        """Find final occurrence of substring bs.
+
+        Returns a single item tuple with the bit position if found, or an
+        empty tuple if not found. The bit position (pos property) will
+        also be set to the start of the substring if it is found.
+
+        bs -- The bitstring to find.
+        start -- The bit position to end the reverse search. Defaults to 0.
+        end -- The bit position one past the first bit to reverse search.
+               Defaults to len(self).
+        bytealigned -- If True the bitstring will only be found on byte
+                       boundaries.
+
+        Raises ValueError if bs is empty, if start < 0, if end > len(self) or
+        if end < start.
+
+        """
+        bs = Bits._create_from_bitstype(bs)
+        start, end = self._validate_slice(start, end)
+        ba = bitstring.options.bytealigned if bytealigned is None else bytealigned
+        if len(bs) == 0:
+            raise ValueError("Cannot find an empty bitstring.")
+        p = self._rfind(bs, start, end, ba)
+        return p
+
+    def _rfind_msb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -> Union[Tuple[int], Tuple[()]]:
+        """Find final occurrence of a binary string."""
+        p = self._bitstore.rfind(bs._bitstore, start, end, bytealigned)
+        return () if p == -1 else (p,)
+
+    def _rfind_lsb0(self, bs: Bits, start: int, end: int, bytealigned: bool) -> Union[Tuple[int], Tuple[()]]:
+        # A reverse find in lsb0 is very like a forward find in msb0.
+        assert start <= end
+        assert bitstring.options.lsb0
+        new_slice = bitstring.bitstore.offset_slice_indices_lsb0(slice(start, end, None), len(self))
+        msb0_start, msb0_end = self._validate_slice(new_slice.start, new_slice.stop)
+
+        p = self._find_msb0(bs, msb0_start, msb0_end, bytealigned)
+        if p:
+            return (len(self) - p[0] - len(bs),)
+        else:
+            return ()
+
+    def cut(self, bits: int, start: Optional[int] = None, end: Optional[int] = None,
+            count: Optional[int] = None) -> Iterator[Bits]:
+        """Return bitstring generator by cutting into bits sized chunks.
+
+        bits -- The size in bits of the bitstring chunks to generate.
+        start -- The bit position to start the first cut. Defaults to 0.
+        end -- The bit position one past the last bit to use in the cut.
+               Defaults to len(self).
+        count -- If specified then at most count items are generated.
+                 Default is to cut as many times as possible.
+
+        """
+        start_, end_ = self._validate_slice(start, end)
+        if count is not None and count < 0:
+            raise ValueError("Cannot cut - count must be >= 0.")
+        if bits <= 0:
+            raise ValueError("Cannot cut - bits must be >= 0.")
+        c = 0
+        while count is None or c < count:
+            c += 1
+            nextchunk = self._slice(start_, min(start_ + bits, end_))
+            if len(nextchunk) == 0:
+                return
+            yield nextchunk
+            if len(nextchunk) != bits:
+                return
+            start_ += bits
+        return
+
+    def split(self, delimiter: BitsType, start: Optional[int] = None, end: Optional[int] = None,
+              count: Optional[int] = None, bytealigned: Optional[bool] = None) -> Iterable[Bits]:
+        """Return bitstring generator by splitting using a delimiter.
+
+        The first item returned is the initial bitstring before the delimiter,
+        which may be an empty bitstring.
+
+        delimiter -- The bitstring used as the divider.
+        start -- The bit position to start the split. Defaults to 0.
+        end -- The bit position one past the last bit to use in the split.
+               Defaults to len(self).
+        count -- If specified then at most count items are generated.
+                 Default is to split as many times as possible.
+        bytealigned -- If True splits will only occur on byte boundaries.
+
+        Raises ValueError if the delimiter is empty.
+
+        """
+        delimiter = Bits._create_from_bitstype(delimiter)
+        if len(delimiter) == 0:
+            raise ValueError("split delimiter cannot be empty.")
+        start, end = self._validate_slice(start, end)
+        bytealigned_: bool = bitstring.options.bytealigned if bytealigned is None else bytealigned
+        if count is not None and count < 0:
+            raise ValueError("Cannot split - count must be >= 0.")
+        if count == 0:
+            return
+        f = functools.partial(self._find_msb0, bs=delimiter, bytealigned=bytealigned_)
+        found = f(start=start, end=end)
+        if not found:
+            # Initial bits are the whole bitstring being searched
+            yield self._slice(start, end)
+            return
+        # yield the bytes before the first occurrence of the delimiter, even if empty
+        yield self._slice(start, found[0])
+        startpos = pos = found[0]
+        c = 1
+        while count is None or c < count:
+            pos += len(delimiter)
+            found = f(start=pos, end=end)
+            if not found:
+                # No more occurrences, so return the rest of the bitstring
+                yield self._slice(startpos, end)
+                return
+            c += 1
+            yield self._slice(startpos, found[0])
+            startpos = pos = found[0]
+        # Have generated count bitstrings, so time to quit.
+        return
+
+    def join(self: TBits, sequence: Iterable[Any]) -> TBits:
+        """Return concatenation of bitstrings joined by self.
+
+        sequence -- A sequence of bitstrings.
+
+        """
+        s = self.__class__()
+        if len(self) == 0:
+            # Optimised version that doesn't need to add self between every item
+            for item in sequence:
+                s._addright(Bits._create_from_bitstype(item))
+            return s
+        else:
+            sequence_iter = iter(sequence)
+            try:
+                s._addright(Bits._create_from_bitstype(next(sequence_iter)))
+            except StopIteration:
+                return s
+            for item in sequence_iter:
+                s._addright(self)
+                s._addright(Bits._create_from_bitstype(item))
+            return s
+
+    def tobytes(self) -> bytes:
+        """Return the bitstring as bytes, padding with zero bits if needed.
+
+        Up to seven zero bits will be added at the end to byte align.
+
+        """
+        return self._bitstore.tobytes()
+
+    def tobitarray(self) -> bitarray.bitarray:
+        """Convert the bitstring to a bitarray object."""
+        if self._bitstore.modified_length is not None:
+            # Removes the offset and truncates to length
+            return self._bitstore.getslice(0, len(self))._bitarray
+        else:
+            return self._bitstore._bitarray
+
+    def tofile(self, f: BinaryIO) -> None:
+        """Write the bitstring to a file object, padding with zero bits if needed.
+
+        Up to seven zero bits will be added at the end to byte align.
+
+        """
+        # If the bitstring is file based then we don't want to read it all in to memory first.
+        chunk_size = 8 * 100 * 1024 * 1024  # 100 MiB
+        for chunk in self.cut(chunk_size):
+            f.write(chunk.tobytes())
+
+    def startswith(self, prefix: BitsType, start: Optional[int] = None, end: Optional[int] = None) -> bool:
+        """Return whether the current bitstring starts with prefix.
+
+        prefix -- The bitstring to search for.
+        start -- The bit position to start from. Defaults to 0.
+        end -- The bit position to end at. Defaults to len(self).
+
+        """
+        prefix = self._create_from_bitstype(prefix)
+        start, end = self._validate_slice(start, end)
+        return self._slice(start, start + len(prefix)) == prefix if end >= start + len(prefix) else False
+
+    def endswith(self, suffix: BitsType, start: Optional[int] = None, end: Optional[int] = None) -> bool:
+        """Return whether the current bitstring ends with suffix.
+
+        suffix -- The bitstring to search for.
+        start -- The bit position to start from. Defaults to 0.
+        end -- The bit position to end at. Defaults to len(self).
+
+        """
+        suffix = self._create_from_bitstype(suffix)
+        start, end = self._validate_slice(start, end)
+        return self._slice(end - len(suffix), end) == suffix if start + len(suffix) <= end else False
+
+    def all(self, value: Any, pos: Optional[Iterable[int]] = None) -> bool:
+        """Return True if one or many bits are all set to bool(value).
+
+        value -- If value is True then checks for bits set to 1, otherwise
+                 checks for bits set to 0.
+        pos -- An iterable of bit positions. Negative numbers are treated in
+               the same way as slice indices. Defaults to the whole bitstring.
+
+        """
+        value = 1 if bool(value) else 0
+        if pos is None:
+            return self._bitstore.all_set() if value else not self._bitstore.any_set()
+        for p in pos:
+            if self._bitstore.getindex(p) != value:
+                return False
+        return True
+
+    def any(self, value: Any, pos: Optional[Iterable[int]] = None) -> bool:
+        """Return True if any of one or many bits are set to bool(value).
+
+        value -- If value is True then checks for bits set to 1, otherwise
+                 checks for bits set to 0.
+        pos -- An iterable of bit positions. Negative numbers are treated in
+               the same way as slice indices. Defaults to the whole bitstring.
+
+        """
+        value = 1 if bool(value) else 0
+        if pos is None:
+            return self._bitstore.any_set() if value else not self._bitstore.all_set()
+        for p in pos:
+            if self._bitstore.getindex(p) == value:
+                return True
+        return False
+
+    def count(self, value: Any) -> int:
+        """Return count of total number of either zero or one bits.
+
+        value -- If bool(value) is True then bits set to 1 are counted, otherwise bits set
+                 to 0 are counted.
+
+        >>> Bits('0xef').count(1)
+        7
+
+        """
+        # count the number of 1s (from which it's easy to work out the 0s).
+        count = self._bitstore.count(1)
+        return count if value else len(self) - count
+
+    @staticmethod
+    def _format_bits(bits: Bits, bits_per_group: int, sep: str, dtype: Dtype,
+                     colour_start: str, colour_end: str, width: Optional[int]=None) -> Tuple[str, int]:
+        get_fn = dtype.get_fn
+        if dtype.name == 'bytes':  # Special case for bytes to print one character each.
+            get_fn = Bits._getbytes_printable
+        if dtype.name == 'bool':  # Special case for bool to print '1' or '0' instead of `True` or `False`.
+            get_fn = dtype_register.get_dtype('uint', bits_per_group).get_fn
+        if bits_per_group == 0:
+            x = str(get_fn(bits))
+        else:
+            # Left-align for fixed width types when msb0, otherwise right-align.
+            align = '<' if dtype.name in ['bin', 'oct', 'hex', 'bits', 'bytes'] and not bitstring.options.lsb0 else '>'
+            chars_per_group = 0
+            if dtype_register[dtype.name].bitlength2chars_fn is not None:
+                chars_per_group = dtype_register[dtype.name].bitlength2chars_fn(bits_per_group)
+            x = sep.join(f"{str(get_fn(b)): {align}{chars_per_group}}" for b in bits.cut(bits_per_group))
+
+        chars_used = len(x)
+        padding_spaces = 0 if width is None else max(width - len(x), 0)
+        x = colour_start + x + colour_end
+        # Pad final line with spaces to align it
+        if bitstring.options.lsb0:
+            x = ' ' * padding_spaces + x
+        else:
+            x += ' ' * padding_spaces
+        return x, chars_used
+
+    @staticmethod
+    def _chars_per_group(bits_per_group: int, fmt: Optional[str]):
+        """How many characters are needed to represent a number of bits with a given format."""
+        if fmt is None or dtype_register[fmt].bitlength2chars_fn is None:
+            return 0
+        return dtype_register[fmt].bitlength2chars_fn(bits_per_group)
+
+    @staticmethod
+    def _bits_per_char(fmt: str):
+        """How many bits are represented by each character of a given format."""
+        if fmt not in ['bin', 'oct', 'hex', 'bytes']:
+            raise ValueError
+        return 24 // dtype_register[fmt].bitlength2chars_fn(24)
+
+    def _pp(self, dtype1: Dtype, dtype2: Optional[Dtype], bits_per_group: int, width: int, sep: str, format_sep: str,
+            show_offset: bool, stream: TextIO, lsb0: bool, offset_factor: int) -> None:
+        """Internal pretty print method."""
+        colour = Colour(not bitstring.options.no_color)
+        name1 = dtype1.name
+        name2 = dtype2.name if dtype2 is not None else None
+        if dtype1.variable_length:
+            raise ValueError(f"Can't use Dtype '{dtype1}' in pp() as it has a variable length.")
+        if dtype2 is not None and dtype2.variable_length:
+            raise ValueError(f"Can't use Dtype '{dtype2}' in pp() as it has a variable length.")
+        offset_width = 0
+        offset_sep = ' :' if lsb0 else ': '
+        if show_offset:
+            # This could be 1 too large in some circumstances. Slightly recurrent logic needed to fix it...
+            offset_width = len(str(len(self))) + len(offset_sep)
+        if bits_per_group > 0:
+            group_chars1 = Bits._chars_per_group(bits_per_group, name1)
+            group_chars2 = Bits._chars_per_group(bits_per_group, name2)
+            # The number of characters that get added when we add an extra group (after the first one)
+            total_group_chars = group_chars1 + group_chars2 + len(sep) + len(sep) * bool(group_chars2)
+            width_excluding_offset_and_final_group = width - offset_width - group_chars1 - group_chars2 - len(
+                format_sep) * bool(group_chars2)
+            width_excluding_offset_and_final_group = max(width_excluding_offset_and_final_group, 0)
+            groups_per_line = 1 + width_excluding_offset_and_final_group // total_group_chars
+            max_bits_per_line = groups_per_line * bits_per_group  # Number of bits represented on each line
+        else:
+            assert bits_per_group == 0  # Don't divide into groups
+            width_available = width - offset_width - len(format_sep) * (name2 is not None)
+            width_available = max(width_available, 1)
+            if name2 is None:
+                max_bits_per_line = width_available * Bits._bits_per_char(name1)
+            else:
+                chars_per_24_bits = dtype_register[name1].bitlength2chars_fn(24) + dtype_register[name2].bitlength2chars_fn(24)
+                max_bits_per_line = 24 * (width_available // chars_per_24_bits)
+                if max_bits_per_line == 0:
+                    max_bits_per_line = 24  # We can't fit into the width asked for. Show something small.
+        assert max_bits_per_line > 0
+
+        bitpos = 0
+        first_fb_width = second_fb_width = None
+        for bits in self.cut(max_bits_per_line):
+            offset_str = ''
+            if show_offset:
+                offset = bitpos // offset_factor
+                bitpos += len(bits)
+                if bitstring.options.lsb0:
+                    offset_str = colour.green + offset_sep + f'{offset: <{offset_width - len(offset_sep)}}' + colour.off
+                else:
+                    offset_str = colour.green + f'{offset: >{offset_width - len(offset_sep)}}' + offset_sep + colour.off
+
+            fb1, chars_used = Bits._format_bits(bits, bits_per_group, sep, dtype1, colour.purple, colour.off, first_fb_width)
+            if first_fb_width is None:
+                first_fb_width = chars_used
+
+            fb2 = ''
+            if dtype2 is not None:
+                fb2, chars_used = Bits._format_bits(bits, bits_per_group, sep, dtype2, colour.blue, colour.off, second_fb_width)
+                if second_fb_width is None:
+                    second_fb_width = chars_used
+                fb2 = format_sep + fb2
+
+            if bitstring.options.lsb0 is True:
+                line_fmt = fb1 + fb2 + offset_str + '\n'
+            else:
+                line_fmt = offset_str + fb1 + fb2 + '\n'
+            stream.write(line_fmt)
+        return
+
+    @staticmethod
+    def _process_pp_tokens(token_list, fmt):
+        has_length_in_fmt = True
+        if len(token_list) == 1:
+            dtype1 = Dtype(*utils.parse_name_length_token(token_list[0]))
+            dtype2 = None
+            bits_per_group = dtype1.bitlength
+            if bits_per_group is None:
+                has_length_in_fmt = False
+                bits_per_group = {'bin': 8, 'hex': 8, 'oct': 12, 'bytes': 32}.get(dtype1.name)
+                if bits_per_group is None:
+                    raise ValueError(f"No length or default length available for pp() format '{fmt}'.")
+        elif len(token_list) == 2:
+            dtype1 = Dtype(*utils.parse_name_length_token(token_list[0]))
+            dtype2 = Dtype(*utils.parse_name_length_token(token_list[1]))
+            if dtype1.bitlength is not None and dtype2.bitlength is not None and dtype1.bitlength != dtype2.bitlength:
+                raise ValueError(
+                    f"Differing bit lengths of {dtype1.bitlength} and {dtype2.bitlength} in format string '{fmt}'.")
+            bits_per_group = dtype1.bitlength if dtype1.bitlength is not None else dtype2.bitlength
+            if bits_per_group is None:
+                has_length_in_fmt = False
+                try:
+                    bits_per_group = 2 * Bits._bits_per_char(dtype1.name) * Bits._bits_per_char(dtype2.name)
+                except ValueError:
+                    raise ValueError(f"Can't find a default bitlength to use for pp() format '{fmt}'.")
+                if bits_per_group >= 24:
+                    bits_per_group //= 2
+        else:
+            raise ValueError(
+                f"Only one or two tokens can be used in an pp() format - '{fmt}' has {len(token_list)} tokens.")
+        return dtype1, dtype2, bits_per_group, has_length_in_fmt
+
+    def pp(self, fmt: Optional[str] = None, width: int = 120, sep: str = ' ',
+           show_offset: bool = True, stream: TextIO = sys.stdout) -> None:
+        """Pretty print the bitstring's value.
+
+        fmt -- Printed data format. One or two of 'bin', 'oct', 'hex' or 'bytes'.
+              The number of bits represented in each printed group defaults to 8 for hex and bin,
+              12 for oct and 32 for bytes. This can be overridden with an explicit length, e.g. 'hex:64'.
+              Use a length of 0 to not split into groups, e.g. `bin:0`.
+        width -- Max width of printed lines. Defaults to 120. A single group will always be printed
+                 per line even if it exceeds the max width.
+        sep -- A separator string to insert between groups. Defaults to a single space.
+        show_offset -- If True (the default) shows the bit offset in the first column of each line.
+        stream -- A TextIO object with a write() method. Defaults to sys.stdout.
+
+        >>> s.pp('hex16')
+        >>> s.pp('b, h', sep='_', show_offset=False)
+
+        """
+        colour = Colour(not bitstring.options.no_color)
+        if fmt is None:
+            fmt = 'bin, hex' if len(self) % 8 == 0 and len(self) >= 8 else 'bin'
+        token_list = utils.preprocess_tokens(fmt)
+        dtype1, dtype2, bits_per_group, has_length_in_fmt = Bits._process_pp_tokens(token_list, fmt)
+        trailing_bit_length = len(self) % bits_per_group if has_length_in_fmt and bits_per_group else 0
+        data = self if trailing_bit_length == 0 else self[0: -trailing_bit_length]
+        format_sep = " : "  # String to insert on each line between multiple formats
+        tidy_fmt = colour.purple + str(dtype1) + colour.off
+        if dtype2 is not None:
+            tidy_fmt += ', ' + colour.blue + str(dtype2) + colour.off
+        output_stream = io.StringIO()
+        len_str = colour.green + str(len(self)) + colour.off
+        output_stream.write(f"<{self.__class__.__name__}, fmt='{tidy_fmt}', length={len_str} bits> [\n")
+        data._pp(dtype1, dtype2, bits_per_group, width, sep, format_sep, show_offset,
+                 output_stream, bitstring.options.lsb0, 1)
+        output_stream.write("]")
+        if trailing_bit_length != 0:
+            output_stream.write(" + trailing_bits = " + str(self[-trailing_bit_length:]))
+        output_stream.write("\n")
+        stream.write(output_stream.getvalue())
+        return
+
+    def copy(self: TBits) -> TBits:
+        """Return a copy of the bitstring."""
+        # Note that if you want a new copy (different ID), use _copy instead.
+        # The copy can return self as it's immutable.
+        return self
+
+    @classmethod
+    def fromstring(cls: TBits, s: str, /) -> TBits:
+        """Create a new bitstring from a formatted string."""
+        x = super().__new__(cls)
+        x._bitstore = bitstore_helpers.str_to_bitstore(s)
+        return x
+
+    len = length = property(_getlength, doc="The length of the bitstring in bits. Read only.")
+
+
```

### Comparing `bitstring-4.2.1/bitstring/bitstore.py` & `bitstring-4.2.2/bitstring/bitstore.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,254 +1,272 @@
-from __future__ import annotations
-
-import bitarray
-from bitstring.exceptions import CreationError
-from typing import Union, Iterable, Optional, overload, Iterator, Any
-
-
-def offset_slice_indices_lsb0(key: slice, length: int) -> slice:
-    # First convert slice to all integers
-    # Length already should take account of the offset
-    start, stop, step = key.indices(length)
-    new_start = length - stop
-    new_stop = length - start
-    # For negative step we sometimes get a negative stop, which can't be used correctly in a new slice
-    return slice(new_start, None if new_stop < 0 else new_stop, step)
-
-def offset_start_stop_lsb0(start: Optional[int], stop: Optional[int], length: int) -> slice:
-    # First convert slice to all integers
-    # Length already should take account of the offset
-    start, stop, _ = slice(start, stop, None).indices(length)
-    new_start = length - stop
-    new_stop = length - start
-    return new_start, new_stop
-
-
-class BitStore:
-    """A light wrapper around bitarray that does the LSB0 stuff"""
-
-    __slots__ = ('_bitarray', 'modified_length', 'immutable')
-
-    def __init__(self, initializer: Union[int, bitarray.bitarray, str, None] = None,
-                 immutable: bool = False) -> None:
-        self._bitarray = bitarray.bitarray(initializer)
-        self.immutable = immutable
-        self.modified_length = None
-
-    @classmethod
-    def frombytes(cls, b: Union[bytes, bytearray, memoryview], /) -> BitStore:
-        x = super().__new__(cls)
-        x._bitarray = bitarray.bitarray()
-        x._bitarray.frombytes(b)
-        x.immutable = False
-        x.modified_length = None
-        return x
-
-    @classmethod
-    def frombuffer(cls, buffer, /, length: Optional[int] = None) -> BitStore:
-        x = super().__new__(cls)
-        x._bitarray = bitarray.bitarray(buffer=buffer)
-        x.immutable = True
-        x.modified_length = length
-        # Here 'modified' means it shouldn't be changed further, so setting, deleting etc. are disallowed.
-        if x.modified_length is not None:
-            if x.modified_length < 0:
-                raise CreationError("Can't create bitstring with a negative length.")
-            if x.modified_length > len(x._bitarray):
-                raise CreationError(
-                    f"Can't create bitstring with a length of {x.modified_length} from {len(x._bitarray)} bits of data.")
-        return x
-
-    def setall(self, value: int, /) -> None:
-        self._bitarray.setall(value)
-
-    def tobytes(self) -> bytes:
-        if self.modified_length is not None:
-            return self._bitarray[:self.modified_length].tobytes()
-        return self._bitarray.tobytes()
-
-    def slice_to_uint(self, start: Optional[int] = None, end: Optional[int] = None) -> int:
-        return bitarray.util.ba2int(self.getslice(start, end)._bitarray, signed=False)
-
-    def slice_to_int(self, start: Optional[int] = None, end: Optional[int] = None) -> int:
-        return bitarray.util.ba2int(self.getslice(start, end)._bitarray, signed=True)
-
-    def slice_to_hex(self, start: Optional[int] = None, end: Optional[int] = None) -> str:
-        return bitarray.util.ba2hex(self.getslice(start, end)._bitarray)
-
-    def slice_to_bin(self, start: Optional[int] = None, end: Optional[int] = None) -> str:
-        return self.getslice(start, end)._bitarray.to01()
-
-    def slice_to_oct(self, start: Optional[int] = None, end: Optional[int] = None) -> str:
-        return bitarray.util.ba2base(8, self.getslice(start, end)._bitarray)
-
-    def __iadd__(self, other: BitStore, /) -> BitStore:
-        self._bitarray += other._bitarray
-        return self
-
-    def __add__(self, other: BitStore, /) -> BitStore:
-        bs = self._copy()
-        bs += other
-        return bs
-
-    def __eq__(self, other: Any, /) -> bool:
-        return self._bitarray == other._bitarray
-
-    def __and__(self, other: BitStore, /) -> BitStore:
-        return BitStore(self._bitarray & other._bitarray)
-
-    def __or__(self, other: BitStore, /) -> BitStore:
-        return BitStore(self._bitarray | other._bitarray)
-
-    def __xor__(self, other: BitStore, /) -> BitStore:
-        return BitStore(self._bitarray ^ other._bitarray)
-
-    def __iand__(self, other: BitStore, /) -> BitStore:
-        self._bitarray &= other._bitarray
-        return self
-
-    def __ior__(self, other: BitStore, /) -> BitStore:
-        self._bitarray |= other._bitarray
-        return self
-
-    def __ixor__(self, other: BitStore, /) -> BitStore:
-        self._bitarray ^= other._bitarray
-        return self
-
-    def find(self, bs: BitStore, start: int, end: int, bytealigned: bool = False) -> int:
-        if not bytealigned:
-            return self._bitarray.find(bs._bitarray, start, end)
-        try:
-            return next(self.findall_msb0(bs, start, end, bytealigned))
-        except StopIteration:
-            return -1
-
-    def rfind(self, bs: BitStore, start: int, end: int, bytealigned: bool = False):
-        if not bytealigned:
-            return self._bitarray.find(bs._bitarray, start, end, right=True)
-        try:
-            return next(self.rfindall_msb0(bs, start, end, bytealigned))
-        except StopIteration:
-            return -1
-
-    def findall_msb0(self, bs: BitStore, start: int, end: int, bytealigned: bool = False) -> Iterator[int]:
-        i = self._bitarray.itersearch(bs._bitarray, start, end)
-        if not bytealigned:
-            for p in i:
-                yield p
-        else:
-            for p in i:
-                if (p % 8) == 0:
-                    yield p
-
-    def rfindall_msb0(self, bs: BitStore, start: int, end: int, bytealigned: bool = False) -> Iterator[int]:
-        i = self._bitarray.itersearch(bs._bitarray, start, end, right=True)
-        if not bytealigned:
-            for p in i:
-                yield p
-        else:
-            for p in i:
-                if (p % 8) == 0:
-                    yield p
-
-    def count(self, value, /) -> int:
-        return self._bitarray.count(value)
-
-    def clear(self) -> None:
-        self._bitarray.clear()
-
-    def reverse(self) -> None:
-        self._bitarray.reverse()
-
-    def __iter__(self) -> Iterable[bool]:
-        for i in range(len(self)):
-            yield self.getindex(i)
-
-    def _copy(self) -> BitStore:
-        """Always creates a copy, even if instance is immutable."""
-        return BitStore(self._bitarray)
-
-    def copy(self) -> BitStore:
-        return self if self.immutable else self._copy()
-
-    def __getitem__(self, item: Union[int, slice], /) -> Union[int, BitStore]:
-        # Use getindex or getslice instead
-        raise NotImplementedError
-
-    def getindex_msb0(self, index: int, /) -> bool:
-        return bool(self._bitarray.__getitem__(index))
-
-    def getslice_withstep_msb0(self, key: slice, /) -> BitStore:
-        if self.modified_length is not None:
-            key = slice(*key.indices(self.modified_length))
-        return BitStore(self._bitarray.__getitem__(key))
-
-    def getslice_withstep_lsb0(self, key: slice, /) -> BitStore:
-        key = offset_slice_indices_lsb0(key, len(self))
-        return BitStore(self._bitarray.__getitem__(key))
-
-    def getslice_msb0(self, start: Optional[int], stop: Optional[int], /) -> BitStore:
-        if self.modified_length is not None:
-            key = slice(*slice(start, stop, None).indices(self.modified_length))
-            start = key.start
-            stop = key.stop
-        return BitStore(self._bitarray[start:stop])
-
-    def getslice_lsb0(self, start: Optional[int], stop: Optional[int], /) -> BitStore:
-        start, stop = offset_start_stop_lsb0(start, stop, len(self))
-        return BitStore(self._bitarray[start:stop])
-
-    def getindex_lsb0(self, index: int, /) -> bool:
-        return bool(self._bitarray.__getitem__(-index - 1))
-
-
-    @overload
-    def setitem_lsb0(self, key: int, value: int, /) -> None:
-        ...
-
-    @overload
-    def setitem_lsb0(self, key: slice, value: BitStore, /) -> None:
-        ...
-
-    def setitem_lsb0(self, key: Union[int, slice], value: Union[int, BitStore], /) -> None:
-        if isinstance(key, slice):
-            new_slice = offset_slice_indices_lsb0(key, len(self))
-            self._bitarray.__setitem__(new_slice, value._bitarray)
-        else:
-            self._bitarray.__setitem__(-key - 1, value)
-
-    def delitem_lsb0(self, key: Union[int, slice], /) -> None:
-        if isinstance(key, slice):
-            new_slice = offset_slice_indices_lsb0(key, len(self))
-            self._bitarray.__delitem__(new_slice)
-        else:
-            self._bitarray.__delitem__(-key - 1)
-
-    def invert_msb0(self, index: Optional[int] = None, /) -> None:
-        if index is not None:
-            self._bitarray.invert(index)
-        else:
-            self._bitarray.invert()
-
-    def invert_lsb0(self, index: Optional[int] = None, /) -> None:
-        if index is not None:
-            self._bitarray.invert(-index - 1)
-        else:
-            self._bitarray.invert()
-
-    def any_set(self) -> bool:
-        return self._bitarray.any()
-
-    def all_set(self) -> bool:
-        return self._bitarray.all()
-
-    def __len__(self) -> int:
-        return self.modified_length if self.modified_length is not None else len(self._bitarray)
-
-    def setitem_msb0(self, key, value, /):
-        if isinstance(value, BitStore):
-            self._bitarray.__setitem__(key, value._bitarray)
-        else:
-            self._bitarray.__setitem__(key, value)
-
-    def delitem_msb0(self, key, /):
+from __future__ import annotations
+
+import bitarray
+from bitstring.exceptions import CreationError
+from typing import Union, Iterable, Optional, overload, Iterator, Any
+
+
+def offset_slice_indices_lsb0(key: slice, length: int) -> slice:
+    # First convert slice to all integers
+    # Length already should take account of the offset
+    start, stop, step = key.indices(length)
+    new_start = length - stop
+    new_stop = length - start
+    # For negative step we sometimes get a negative stop, which can't be used correctly in a new slice
+    return slice(new_start, None if new_stop < 0 else new_stop, step)
+
+def offset_start_stop_lsb0(start: Optional[int], stop: Optional[int], length: int) -> slice:
+    # First convert slice to all integers
+    # Length already should take account of the offset
+    start, stop, _ = slice(start, stop, None).indices(length)
+    new_start = length - stop
+    new_stop = length - start
+    return new_start, new_stop
+
+
+class BitStore:
+    """A light wrapper around bitarray that does the LSB0 stuff"""
+
+    __slots__ = ('_bitarray', 'modified_length', 'immutable')
+
+    def __init__(self, initializer: Union[int, bitarray.bitarray, str, None] = None,
+                 immutable: bool = False) -> None:
+        self._bitarray = bitarray.bitarray(initializer)
+        self.immutable = immutable
+        self.modified_length = None
+
+    @classmethod
+    def frombytes(cls, b: Union[bytes, bytearray, memoryview], /) -> BitStore:
+        x = super().__new__(cls)
+        x._bitarray = bitarray.bitarray()
+        x._bitarray.frombytes(b)
+        x.immutable = False
+        x.modified_length = None
+        return x
+
+    @classmethod
+    def frombuffer(cls, buffer, /, length: Optional[int] = None) -> BitStore:
+        x = super().__new__(cls)
+        x._bitarray = bitarray.bitarray(buffer=buffer)
+        x.immutable = True
+        x.modified_length = length
+        # Here 'modified' means it shouldn't be changed further, so setting, deleting etc. are disallowed.
+        if x.modified_length is not None:
+            if x.modified_length < 0:
+                raise CreationError("Can't create bitstring with a negative length.")
+            if x.modified_length > len(x._bitarray):
+                raise CreationError(
+                    f"Can't create bitstring with a length of {x.modified_length} from {len(x._bitarray)} bits of data.")
+        return x
+
+    def setall(self, value: int, /) -> None:
+        self._bitarray.setall(value)
+
+    def tobytes(self) -> bytes:
+        if self.modified_length is not None:
+            return self._bitarray[:self.modified_length].tobytes()
+        return self._bitarray.tobytes()
+
+    def slice_to_uint(self, start: Optional[int] = None, end: Optional[int] = None) -> int:
+        return bitarray.util.ba2int(self.getslice(start, end)._bitarray, signed=False)
+
+    def slice_to_int(self, start: Optional[int] = None, end: Optional[int] = None) -> int:
+        return bitarray.util.ba2int(self.getslice(start, end)._bitarray, signed=True)
+
+    def slice_to_hex(self, start: Optional[int] = None, end: Optional[int] = None) -> str:
+        return bitarray.util.ba2hex(self.getslice(start, end)._bitarray)
+
+    def slice_to_bin(self, start: Optional[int] = None, end: Optional[int] = None) -> str:
+        return self.getslice(start, end)._bitarray.to01()
+
+    def slice_to_oct(self, start: Optional[int] = None, end: Optional[int] = None) -> str:
+        return bitarray.util.ba2base(8, self.getslice(start, end)._bitarray)
+
+    def __iadd__(self, other: BitStore, /) -> BitStore:
+        self._bitarray += other._bitarray
+        return self
+
+    def __add__(self, other: BitStore, /) -> BitStore:
+        bs = self._copy()
+        bs += other
+        return bs
+
+    def __eq__(self, other: Any, /) -> bool:
+        return self._bitarray == other._bitarray
+
+    def __and__(self, other: BitStore, /) -> BitStore:
+        return BitStore(self._bitarray & other._bitarray)
+
+    def __or__(self, other: BitStore, /) -> BitStore:
+        return BitStore(self._bitarray | other._bitarray)
+
+    def __xor__(self, other: BitStore, /) -> BitStore:
+        return BitStore(self._bitarray ^ other._bitarray)
+
+    def __iand__(self, other: BitStore, /) -> BitStore:
+        self._bitarray &= other._bitarray
+        return self
+
+    def __ior__(self, other: BitStore, /) -> BitStore:
+        self._bitarray |= other._bitarray
+        return self
+
+    def __ixor__(self, other: BitStore, /) -> BitStore:
+        self._bitarray ^= other._bitarray
+        return self
+
+    def find(self, bs: BitStore, start: int, end: int, bytealigned: bool = False) -> int:
+        if not bytealigned:
+            return self._bitarray.find(bs._bitarray, start, end)
+        try:
+            return next(self.findall_msb0(bs, start, end, bytealigned))
+        except StopIteration:
+            return -1
+
+    def rfind(self, bs: BitStore, start: int, end: int, bytealigned: bool = False):
+        if not bytealigned:
+            return self._bitarray.find(bs._bitarray, start, end, right=True)
+        try:
+            return next(self.rfindall_msb0(bs, start, end, bytealigned))
+        except StopIteration:
+            return -1
+
+    def findall_msb0(self, bs: BitStore, start: int, end: int, bytealigned: bool = False) -> Iterator[int]:
+        if bytealigned is True and len(bs) % 8 == 0:
+            # Special case, looking for whole bytes on whole byte boundaries
+            bytes_ = bs.tobytes()
+            # Round up start byte to next byte, and round end byte down.
+            # We're only looking for whole bytes, so can ignore bits at either end.
+            start_byte = (start + 7) // 8
+            end_byte = end // 8
+            b = self._bitarray[start_byte * 8: end_byte * 8].tobytes()
+            byte_pos = 0
+            bytes_to_search = end_byte - start_byte
+            while byte_pos < bytes_to_search:
+                byte_pos = b.find(bytes_, byte_pos)
+                if byte_pos == -1:
+                    break
+                yield (byte_pos + start_byte) * 8
+                byte_pos = byte_pos + 1
+            return
+        # General case
+        i = self._bitarray.itersearch(bs._bitarray, start, end)
+        if not bytealigned:
+            for p in i:
+                yield p
+        else:
+            for p in i:
+                if (p % 8) == 0:
+                    yield p
+
+    def rfindall_msb0(self, bs: BitStore, start: int, end: int, bytealigned: bool = False) -> Iterator[int]:
+        i = self._bitarray.itersearch(bs._bitarray, start, end, right=True)
+        if not bytealigned:
+            for p in i:
+                yield p
+        else:
+            for p in i:
+                if (p % 8) == 0:
+                    yield p
+
+    def count(self, value, /) -> int:
+        return self._bitarray.count(value)
+
+    def clear(self) -> None:
+        self._bitarray.clear()
+
+    def reverse(self) -> None:
+        self._bitarray.reverse()
+
+    def __iter__(self) -> Iterable[bool]:
+        for i in range(len(self)):
+            yield self.getindex(i)
+
+    def _copy(self) -> BitStore:
+        """Always creates a copy, even if instance is immutable."""
+        return BitStore(self._bitarray)
+
+    def copy(self) -> BitStore:
+        return self if self.immutable else self._copy()
+
+    def __getitem__(self, item: Union[int, slice], /) -> Union[int, BitStore]:
+        # Use getindex or getslice instead
+        raise NotImplementedError
+
+    def getindex_msb0(self, index: int, /) -> bool:
+        return bool(self._bitarray.__getitem__(index))
+
+    def getslice_withstep_msb0(self, key: slice, /) -> BitStore:
+        if self.modified_length is not None:
+            key = slice(*key.indices(self.modified_length))
+        return BitStore(self._bitarray.__getitem__(key))
+
+    def getslice_withstep_lsb0(self, key: slice, /) -> BitStore:
+        key = offset_slice_indices_lsb0(key, len(self))
+        return BitStore(self._bitarray.__getitem__(key))
+
+    def getslice_msb0(self, start: Optional[int], stop: Optional[int], /) -> BitStore:
+        if self.modified_length is not None:
+            key = slice(*slice(start, stop, None).indices(self.modified_length))
+            start = key.start
+            stop = key.stop
+        return BitStore(self._bitarray[start:stop])
+
+    def getslice_lsb0(self, start: Optional[int], stop: Optional[int], /) -> BitStore:
+        start, stop = offset_start_stop_lsb0(start, stop, len(self))
+        return BitStore(self._bitarray[start:stop])
+
+    def getindex_lsb0(self, index: int, /) -> bool:
+        return bool(self._bitarray.__getitem__(-index - 1))
+
+
+    @overload
+    def setitem_lsb0(self, key: int, value: int, /) -> None:
+        ...
+
+    @overload
+    def setitem_lsb0(self, key: slice, value: BitStore, /) -> None:
+        ...
+
+    def setitem_lsb0(self, key: Union[int, slice], value: Union[int, BitStore], /) -> None:
+        if isinstance(key, slice):
+            new_slice = offset_slice_indices_lsb0(key, len(self))
+            self._bitarray.__setitem__(new_slice, value._bitarray)
+        else:
+            self._bitarray.__setitem__(-key - 1, value)
+
+    def delitem_lsb0(self, key: Union[int, slice], /) -> None:
+        if isinstance(key, slice):
+            new_slice = offset_slice_indices_lsb0(key, len(self))
+            self._bitarray.__delitem__(new_slice)
+        else:
+            self._bitarray.__delitem__(-key - 1)
+
+    def invert_msb0(self, index: Optional[int] = None, /) -> None:
+        if index is not None:
+            self._bitarray.invert(index)
+        else:
+            self._bitarray.invert()
+
+    def invert_lsb0(self, index: Optional[int] = None, /) -> None:
+        if index is not None:
+            self._bitarray.invert(-index - 1)
+        else:
+            self._bitarray.invert()
+
+    def any_set(self) -> bool:
+        return self._bitarray.any()
+
+    def all_set(self) -> bool:
+        return self._bitarray.all()
+
+    def __len__(self) -> int:
+        return self.modified_length if self.modified_length is not None else len(self._bitarray)
+
+    def setitem_msb0(self, key, value, /):
+        if isinstance(value, BitStore):
+            self._bitarray.__setitem__(key, value._bitarray)
+        else:
+            self._bitarray.__setitem__(key, value)
+
+    def delitem_msb0(self, key, /):
         self._bitarray.__delitem__(key)
```

### Comparing `bitstring-4.2.1/bitstring/bitstore_helpers.py` & `bitstring-4.2.2/bitstring/bitstore_helpers.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,260 +1,260 @@
-from __future__ import annotations
-
-import struct
-import math
-import functools
-from typing import Union, Optional, Dict, Callable
-import bitarray
-from bitstring.bitstore import BitStore
-import bitstring
-from bitstring.fp8 import p4binary_fmt, p3binary_fmt
-from bitstring.mxfp import e3m2mxfp_fmt, e2m3mxfp_fmt, e2m1mxfp_fmt, e4m3mxfp_saturate_fmt, e5m2mxfp_saturate_fmt, e4m3mxfp_overflow_fmt, e5m2mxfp_overflow_fmt
-
-# The size of various caches used to improve performance
-CACHE_SIZE = 256
-
-
-def tidy_input_string(s: str) -> str:
-    """Return string made lowercase and with all whitespace and underscores removed."""
-    try:
-        t = s.split()
-    except (AttributeError, TypeError):
-        raise ValueError(f"Expected str object but received a {type(s)} with value {s}.")
-    return ''.join(t).lower().replace('_', '')
-
-
-@functools.lru_cache(CACHE_SIZE)
-def str_to_bitstore(s: str) -> BitStore:
-    _, tokens = bitstring.utils.tokenparser(s)
-    bs = BitStore()
-    for token in tokens:
-        bs += bitstore_from_token(*token)
-    bs.immutable = True
-    return bs
-
-
-def bin2bitstore(binstring: str) -> BitStore:
-    binstring = tidy_input_string(binstring)
-    binstring = binstring.replace('0b', '')
-    try:
-        return BitStore(binstring)
-    except ValueError:
-        raise bitstring.CreationError(f"Invalid character in bin initialiser {binstring}.")
-
-
-def bin2bitstore_unsafe(binstring: str) -> BitStore:
-    return BitStore(binstring)
-
-
-def hex2bitstore(hexstring: str) -> BitStore:
-    hexstring = tidy_input_string(hexstring)
-    hexstring = hexstring.replace('0x', '')
-    try:
-        ba = bitarray.util.hex2ba(hexstring)
-    except ValueError:
-        raise bitstring.CreationError("Invalid symbol in hex initialiser.")
-    return BitStore(ba)
-
-
-def oct2bitstore(octstring: str) -> BitStore:
-    octstring = tidy_input_string(octstring)
-    octstring = octstring.replace('0o', '')
-    try:
-        ba = bitarray.util.base2ba(8, octstring)
-    except ValueError:
-        raise bitstring.CreationError("Invalid symbol in oct initialiser.")
-    return BitStore(ba)
-
-
-def ue2bitstore(i: Union[str, int]) -> BitStore:
-    i = int(i)
-    if i < 0:
-        raise bitstring.CreationError("Cannot use negative initialiser for unsigned exponential-Golomb.")
-    if i == 0:
-        return BitStore('1')
-    tmp = i + 1
-    leadingzeros = -1
-    while tmp > 0:
-        tmp >>= 1
-        leadingzeros += 1
-    remainingpart = i + 1 - (1 << leadingzeros)
-    return BitStore('0' * leadingzeros + '1') + int2bitstore(remainingpart, leadingzeros, False)
-
-
-def se2bitstore(i: Union[str, int]) -> BitStore:
-    i = int(i)
-    if i > 0:
-        u = (i * 2) - 1
-    else:
-        u = -2 * i
-    return ue2bitstore(u)
-
-
-def uie2bitstore(i: Union[str, int]) -> BitStore:
-    i = int(i)
-    if i < 0:
-        raise bitstring.CreationError("Cannot use negative initialiser for unsigned interleaved exponential-Golomb.")
-    return BitStore('1' if i == 0 else '0' + '0'.join(bin(i + 1)[3:]) + '1')
-
-
-def sie2bitstore(i: Union[str, int]) -> BitStore:
-    i = int(i)
-    if i == 0:
-        return BitStore('1')
-    else:
-        return uie2bitstore(abs(i)) + (BitStore('1') if i < 0 else BitStore('0'))
-
-
-def bfloat2bitstore(f: Union[str, float], big_endian: bool) -> BitStore:
-    f = float(f)
-    fmt = '>f' if big_endian else '<f'
-    try:
-        b = struct.pack(fmt, f)
-    except OverflowError:
-        # For consistency we overflow to 'inf'.
-        b = struct.pack(fmt, float('inf') if f > 0 else float('-inf'))
-    return BitStore.frombytes(b[0:2]) if big_endian else BitStore.frombytes(b[2:4])
-
-
-def p4binary2bitstore(f: Union[str, float]) -> BitStore:
-    f = float(f)
-    u = p4binary_fmt.float_to_int8(f)
-    return int2bitstore(u, 8, False)
-
-def p3binary2bitstore(f: Union[str, float]) -> BitStore:
-    f = float(f)
-    u = p3binary_fmt.float_to_int8(f)
-    return int2bitstore(u, 8, False)
-
-def e4m3mxfp2bitstore(f: Union[str, float]) -> BitStore:
-    f = float(f)
-    if bitstring.options.mxfp_overflow == 'saturate':
-        u = e4m3mxfp_saturate_fmt.float_to_int(f)
-    else:
-        u = e4m3mxfp_overflow_fmt.float_to_int(f)
-    return int2bitstore(u, 8, False)
-
-def e5m2mxfp2bitstore(f: Union[str, float]) -> BitStore:
-    f = float(f)
-    if bitstring.options.mxfp_overflow == 'saturate':
-        u = e5m2mxfp_saturate_fmt.float_to_int(f)
-    else:
-        u = e5m2mxfp_overflow_fmt.float_to_int(f)
-    return int2bitstore(u, 8, False)
-
-def e3m2mxfp2bitstore(f: Union[str, float]) -> BitStore:
-    f = float(f)
-    if math.isnan(f):
-        raise ValueError("Cannot convert float('nan') to e3m2mxfp format as it has no representation for it.")
-    u = e3m2mxfp_fmt.float_to_int(f)
-    return int2bitstore(u, 6, False)
-
-def e2m3mxfp2bitstore(f: Union[str, float]) -> BitStore:
-    f = float(f)
-    if math.isnan(f):
-        raise ValueError("Cannot convert float('nan') to e2m3mxfp format as it has no representation for it.")
-    u = e2m3mxfp_fmt.float_to_int(f)
-    return int2bitstore(u, 6, False)
-
-def e2m1mxfp2bitstore(f: Union[str, float]) -> BitStore:
-    f = float(f)
-    if math.isnan(f):
-        raise ValueError("Cannot convert float('nan') to e2m1mxfp format as it has no representation for it.")
-    u = e2m1mxfp_fmt.float_to_int(f)
-    return int2bitstore(u, 4, False)
-
-
-e8m0mxfp_allowed_values = [float(2 ** x) for x in range(-127, 128)]
-def e8m0mxfp2bitstore(f: Union[str, float]) -> BitStore:
-    f = float(f)
-    if math.isnan(f):
-        return BitStore('11111111')
-    try:
-        i = e8m0mxfp_allowed_values.index(f)
-    except ValueError:
-        raise ValueError(f"{f} is not a valid e8m0mxfp value. It must be exactly 2 ** i, for -127 <= i <= 127 or float('nan') as no rounding will be done.")
-    return int2bitstore(i, 8, False)
-
-
-def mxint2bitstore(f: Union[str, float]) -> BitStore:
-    f = float(f)
-    if math.isnan(f):
-        raise ValueError("Cannot convert float('nan') to mxint format as it has no representation for it.")
-    f *= 2 ** 6  # Remove the implicit scaling factor
-    if f > 127:  # 1 + 63/64
-        return BitStore('01111111')
-    if f <= -128:  # -2
-        return BitStore('10000000')
-    # Want to round to nearest, so move by 0.5 away from zero and round down by converting to int
-    if f >= 0.0:
-        f += 0.5
-        i = int(f)
-        # For ties-round-to-even
-        if f - i == 0.0 and i % 2:
-            i -= 1
-    else:
-        f -= 0.5
-        i = int(f)
-        if f - i == 0.0 and i % 2:
-            i += 1
-    return int2bitstore(i, 8, True)
-
-def int2bitstore(i: int, length: int, signed: bool) -> BitStore:
-    i = int(i)
-    try:
-        x = BitStore(bitarray.util.int2ba(i, length=length, endian='big', signed=signed))
-    except OverflowError as e:
-        if signed:
-            if i >= (1 << (length - 1)) or i < -(1 << (length - 1)):
-                raise bitstring.CreationError(f"{i} is too large a signed integer for a bitstring of length {length}. "
-                                    f"The allowed range is [{-(1 << (length - 1))}, {(1 << (length - 1)) - 1}].")
-        else:
-            if i >= (1 << length):
-                raise bitstring.CreationError(f"{i} is too large an unsigned integer for a bitstring of length {length}. "
-                                    f"The allowed range is [0, {(1 << length) - 1}].")
-            if i < 0:
-                raise bitstring.CreationError("uint cannot be initialised with a negative number.")
-        raise e
-    return x
-
-
-def intle2bitstore(i: int, length: int, signed: bool) -> BitStore:
-    x = int2bitstore(i, length, signed).tobytes()
-    return BitStore.frombytes(x[::-1])
-
-
-def float2bitstore(f: Union[str, float], length: int, big_endian: bool) -> BitStore:
-    f = float(f)
-    fmt = {16: '>e', 32: '>f', 64: '>d'}[length] if big_endian else {16: '<e', 32: '<f', 64: '<d'}[length]
-    try:
-        b = struct.pack(fmt, f)
-    except OverflowError:
-        # If float64 doesn't fit it automatically goes to 'inf'. This reproduces that behaviour for other types.
-        b = struct.pack(fmt, float('inf') if f > 0 else float('-inf'))
-    return BitStore.frombytes(b)
-
-
-literal_bit_funcs: Dict[str, Callable[..., BitStore]] = {
-    '0x': hex2bitstore,
-    '0X': hex2bitstore,
-    '0b': bin2bitstore,
-    '0B': bin2bitstore,
-    '0o': oct2bitstore,
-    '0O': oct2bitstore,
-}
-
-
-def bitstore_from_token(name: str, token_length: Optional[int], value: Optional[str]) -> BitStore:
-    if name in literal_bit_funcs:
-        return literal_bit_funcs[name](value)
-    try:
-        d = bitstring.dtypes.Dtype(name, token_length)
-    except ValueError as e:
-        raise bitstring.CreationError(f"Can't parse token: {e}")
-    if value is None and name != 'pad':
-        raise ValueError(f"Token {name} requires a value.")
-    bs = d.build(value)._bitstore
-    if token_length is not None and len(bs) != d.bitlength:
-        raise bitstring.CreationError(f"Token with length {token_length} packed with value of length {len(bs)} "
-                                      f"({name}:{token_length}={value}).")
-    return bs
+from __future__ import annotations
+
+import struct
+import math
+import functools
+from typing import Union, Optional, Dict, Callable
+import bitarray
+from bitstring.bitstore import BitStore
+import bitstring
+from bitstring.fp8 import p4binary_fmt, p3binary_fmt
+from bitstring.mxfp import e3m2mxfp_fmt, e2m3mxfp_fmt, e2m1mxfp_fmt, e4m3mxfp_saturate_fmt, e5m2mxfp_saturate_fmt, e4m3mxfp_overflow_fmt, e5m2mxfp_overflow_fmt
+
+# The size of various caches used to improve performance
+CACHE_SIZE = 256
+
+
+def tidy_input_string(s: str) -> str:
+    """Return string made lowercase and with all whitespace and underscores removed."""
+    try:
+        t = s.split()
+    except (AttributeError, TypeError):
+        raise ValueError(f"Expected str object but received a {type(s)} with value {s}.")
+    return ''.join(t).lower().replace('_', '')
+
+
+@functools.lru_cache(CACHE_SIZE)
+def str_to_bitstore(s: str) -> BitStore:
+    _, tokens = bitstring.utils.tokenparser(s)
+    bs = BitStore()
+    for token in tokens:
+        bs += bitstore_from_token(*token)
+    bs.immutable = True
+    return bs
+
+
+def bin2bitstore(binstring: str) -> BitStore:
+    binstring = tidy_input_string(binstring)
+    binstring = binstring.replace('0b', '')
+    try:
+        return BitStore(binstring)
+    except ValueError:
+        raise bitstring.CreationError(f"Invalid character in bin initialiser {binstring}.")
+
+
+def bin2bitstore_unsafe(binstring: str) -> BitStore:
+    return BitStore(binstring)
+
+
+def hex2bitstore(hexstring: str) -> BitStore:
+    hexstring = tidy_input_string(hexstring)
+    hexstring = hexstring.replace('0x', '')
+    try:
+        ba = bitarray.util.hex2ba(hexstring)
+    except ValueError:
+        raise bitstring.CreationError("Invalid symbol in hex initialiser.")
+    return BitStore(ba)
+
+
+def oct2bitstore(octstring: str) -> BitStore:
+    octstring = tidy_input_string(octstring)
+    octstring = octstring.replace('0o', '')
+    try:
+        ba = bitarray.util.base2ba(8, octstring)
+    except ValueError:
+        raise bitstring.CreationError("Invalid symbol in oct initialiser.")
+    return BitStore(ba)
+
+
+def ue2bitstore(i: Union[str, int]) -> BitStore:
+    i = int(i)
+    if i < 0:
+        raise bitstring.CreationError("Cannot use negative initialiser for unsigned exponential-Golomb.")
+    if i == 0:
+        return BitStore('1')
+    tmp = i + 1
+    leadingzeros = -1
+    while tmp > 0:
+        tmp >>= 1
+        leadingzeros += 1
+    remainingpart = i + 1 - (1 << leadingzeros)
+    return BitStore('0' * leadingzeros + '1') + int2bitstore(remainingpart, leadingzeros, False)
+
+
+def se2bitstore(i: Union[str, int]) -> BitStore:
+    i = int(i)
+    if i > 0:
+        u = (i * 2) - 1
+    else:
+        u = -2 * i
+    return ue2bitstore(u)
+
+
+def uie2bitstore(i: Union[str, int]) -> BitStore:
+    i = int(i)
+    if i < 0:
+        raise bitstring.CreationError("Cannot use negative initialiser for unsigned interleaved exponential-Golomb.")
+    return BitStore('1' if i == 0 else '0' + '0'.join(bin(i + 1)[3:]) + '1')
+
+
+def sie2bitstore(i: Union[str, int]) -> BitStore:
+    i = int(i)
+    if i == 0:
+        return BitStore('1')
+    else:
+        return uie2bitstore(abs(i)) + (BitStore('1') if i < 0 else BitStore('0'))
+
+
+def bfloat2bitstore(f: Union[str, float], big_endian: bool) -> BitStore:
+    f = float(f)
+    fmt = '>f' if big_endian else '<f'
+    try:
+        b = struct.pack(fmt, f)
+    except OverflowError:
+        # For consistency we overflow to 'inf'.
+        b = struct.pack(fmt, float('inf') if f > 0 else float('-inf'))
+    return BitStore.frombytes(b[0:2]) if big_endian else BitStore.frombytes(b[2:4])
+
+
+def p4binary2bitstore(f: Union[str, float]) -> BitStore:
+    f = float(f)
+    u = p4binary_fmt.float_to_int8(f)
+    return int2bitstore(u, 8, False)
+
+def p3binary2bitstore(f: Union[str, float]) -> BitStore:
+    f = float(f)
+    u = p3binary_fmt.float_to_int8(f)
+    return int2bitstore(u, 8, False)
+
+def e4m3mxfp2bitstore(f: Union[str, float]) -> BitStore:
+    f = float(f)
+    if bitstring.options.mxfp_overflow == 'saturate':
+        u = e4m3mxfp_saturate_fmt.float_to_int(f)
+    else:
+        u = e4m3mxfp_overflow_fmt.float_to_int(f)
+    return int2bitstore(u, 8, False)
+
+def e5m2mxfp2bitstore(f: Union[str, float]) -> BitStore:
+    f = float(f)
+    if bitstring.options.mxfp_overflow == 'saturate':
+        u = e5m2mxfp_saturate_fmt.float_to_int(f)
+    else:
+        u = e5m2mxfp_overflow_fmt.float_to_int(f)
+    return int2bitstore(u, 8, False)
+
+def e3m2mxfp2bitstore(f: Union[str, float]) -> BitStore:
+    f = float(f)
+    if math.isnan(f):
+        raise ValueError("Cannot convert float('nan') to e3m2mxfp format as it has no representation for it.")
+    u = e3m2mxfp_fmt.float_to_int(f)
+    return int2bitstore(u, 6, False)
+
+def e2m3mxfp2bitstore(f: Union[str, float]) -> BitStore:
+    f = float(f)
+    if math.isnan(f):
+        raise ValueError("Cannot convert float('nan') to e2m3mxfp format as it has no representation for it.")
+    u = e2m3mxfp_fmt.float_to_int(f)
+    return int2bitstore(u, 6, False)
+
+def e2m1mxfp2bitstore(f: Union[str, float]) -> BitStore:
+    f = float(f)
+    if math.isnan(f):
+        raise ValueError("Cannot convert float('nan') to e2m1mxfp format as it has no representation for it.")
+    u = e2m1mxfp_fmt.float_to_int(f)
+    return int2bitstore(u, 4, False)
+
+
+e8m0mxfp_allowed_values = [float(2 ** x) for x in range(-127, 128)]
+def e8m0mxfp2bitstore(f: Union[str, float]) -> BitStore:
+    f = float(f)
+    if math.isnan(f):
+        return BitStore('11111111')
+    try:
+        i = e8m0mxfp_allowed_values.index(f)
+    except ValueError:
+        raise ValueError(f"{f} is not a valid e8m0mxfp value. It must be exactly 2 ** i, for -127 <= i <= 127 or float('nan') as no rounding will be done.")
+    return int2bitstore(i, 8, False)
+
+
+def mxint2bitstore(f: Union[str, float]) -> BitStore:
+    f = float(f)
+    if math.isnan(f):
+        raise ValueError("Cannot convert float('nan') to mxint format as it has no representation for it.")
+    f *= 2 ** 6  # Remove the implicit scaling factor
+    if f > 127:  # 1 + 63/64
+        return BitStore('01111111')
+    if f <= -128:  # -2
+        return BitStore('10000000')
+    # Want to round to nearest, so move by 0.5 away from zero and round down by converting to int
+    if f >= 0.0:
+        f += 0.5
+        i = int(f)
+        # For ties-round-to-even
+        if f - i == 0.0 and i % 2:
+            i -= 1
+    else:
+        f -= 0.5
+        i = int(f)
+        if f - i == 0.0 and i % 2:
+            i += 1
+    return int2bitstore(i, 8, True)
+
+def int2bitstore(i: int, length: int, signed: bool) -> BitStore:
+    i = int(i)
+    try:
+        x = BitStore(bitarray.util.int2ba(i, length=length, endian='big', signed=signed))
+    except OverflowError as e:
+        if signed:
+            if i >= (1 << (length - 1)) or i < -(1 << (length - 1)):
+                raise bitstring.CreationError(f"{i} is too large a signed integer for a bitstring of length {length}. "
+                                    f"The allowed range is [{-(1 << (length - 1))}, {(1 << (length - 1)) - 1}].")
+        else:
+            if i >= (1 << length):
+                raise bitstring.CreationError(f"{i} is too large an unsigned integer for a bitstring of length {length}. "
+                                    f"The allowed range is [0, {(1 << length) - 1}].")
+            if i < 0:
+                raise bitstring.CreationError("uint cannot be initialised with a negative number.")
+        raise e
+    return x
+
+
+def intle2bitstore(i: int, length: int, signed: bool) -> BitStore:
+    x = int2bitstore(i, length, signed).tobytes()
+    return BitStore.frombytes(x[::-1])
+
+
+def float2bitstore(f: Union[str, float], length: int, big_endian: bool) -> BitStore:
+    f = float(f)
+    fmt = {16: '>e', 32: '>f', 64: '>d'}[length] if big_endian else {16: '<e', 32: '<f', 64: '<d'}[length]
+    try:
+        b = struct.pack(fmt, f)
+    except OverflowError:
+        # If float64 doesn't fit it automatically goes to 'inf'. This reproduces that behaviour for other types.
+        b = struct.pack(fmt, float('inf') if f > 0 else float('-inf'))
+    return BitStore.frombytes(b)
+
+
+literal_bit_funcs: Dict[str, Callable[..., BitStore]] = {
+    '0x': hex2bitstore,
+    '0X': hex2bitstore,
+    '0b': bin2bitstore,
+    '0B': bin2bitstore,
+    '0o': oct2bitstore,
+    '0O': oct2bitstore,
+}
+
+
+def bitstore_from_token(name: str, token_length: Optional[int], value: Optional[str]) -> BitStore:
+    if name in literal_bit_funcs:
+        return literal_bit_funcs[name](value)
+    try:
+        d = bitstring.dtypes.Dtype(name, token_length)
+    except ValueError as e:
+        raise bitstring.CreationError(f"Can't parse token: {e}")
+    if value is None and name != 'pad':
+        raise ValueError(f"Token {name} requires a value.")
+    bs = d.build(value)._bitstore
+    if token_length is not None and len(bs) != d.bitlength:
+        raise bitstring.CreationError(f"Token with length {token_length} packed with value of length {len(bs)} "
+                                      f"({name}:{token_length}={value}).")
+    return bs
```

### Comparing `bitstring-4.2.1/bitstring/bitstream.py` & `bitstring-4.2.2/bitstring/bitstream.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,714 +1,714 @@
-from __future__ import annotations
-
-import bitstring
-from bitstring.bits import Bits, BitsType
-from bitstring.dtypes import Dtype
-from typing import Union, List, Any, Optional, overload, TypeVar, Tuple
-import copy
-import numbers
-
-TConstBitStream = TypeVar("TConstBitStream", bound='ConstBitStream')
-
-
-class ConstBitStream(Bits):
-    """A container or stream holding an immutable sequence of bits.
-
-    For a mutable container use the BitStream class instead.
-
-    Methods inherited from Bits:
-
-    all() -- Check if all specified bits are set to 1 or 0.
-    any() -- Check if any of specified bits are set to 1 or 0.
-    copy() -- Return a copy of the bitstring.
-    count() -- Count the number of bits set to 1 or 0.
-    cut() -- Create generator of constant sized chunks.
-    endswith() -- Return whether the bitstring ends with a sub-string.
-    find() -- Find a sub-bitstring in the current bitstring.
-    findall() -- Find all occurrences of a sub-bitstring in the current bitstring.
-    fromstring() -- Create a bitstring from a formatted string.
-    join() -- Join bitstrings together using current bitstring.
-    pp() -- Pretty print the bitstring.
-    rfind() -- Seek backwards to find a sub-bitstring.
-    split() -- Create generator of chunks split by a delimiter.
-    startswith() -- Return whether the bitstring starts with a sub-bitstring.
-    tobitarray() -- Return bitstring as a bitarray from the bitarray package.
-    tobytes() -- Return bitstring as bytes, padding if needed.
-    tofile() -- Write bitstring to file, padding if needed.
-    unpack() -- Interpret bits using format string.
-
-    Other methods:
-
-    bytealign() -- Align to next byte boundary.
-    peek() -- Peek at and interpret next bits as a single item.
-    peeklist() -- Peek at and interpret next bits as a list of items.
-    read() -- Read and interpret next bits as a single item.
-    readlist() -- Read and interpret next bits as a list of items.
-    readto() -- Read up to and including next occurrence of a bitstring.
-
-    Special methods:
-
-    Also available are the operators [], ==, !=, +, *, ~, <<, >>, &, |, ^.
-
-    Properties:
-
-    [GENERATED_PROPERTY_DESCRIPTIONS]
-
-    len -- Length of the bitstring in bits.
-    pos -- The current bit position in the bitstring.
-    """
-
-    __slots__ = ('_pos')
-
-    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,
-                 offset: Optional[int] = None, pos: int = 0, **kwargs) -> None:
-        """Either specify an 'auto' initialiser:
-        A string of comma separated tokens, an integer, a file object,
-        a bytearray, a boolean iterable or another bitstring.
-
-        Or initialise via **kwargs with one (and only one) of:
-        bin -- binary string representation, e.g. '0b001010'.
-        hex -- hexadecimal string representation, e.g. '0x2ef'
-        oct -- octal string representation, e.g. '0o777'.
-        bytes -- raw data as a bytes object, for example read from a binary file.
-        int -- a signed integer.
-        uint -- an unsigned integer.
-        float / floatbe -- a big-endian floating point number.
-        bool -- a boolean (True or False).
-        se -- a signed exponential-Golomb code.
-        ue -- an unsigned exponential-Golomb code.
-        sie -- a signed interleaved exponential-Golomb code.
-        uie -- an unsigned interleaved exponential-Golomb code.
-        floatle -- a little-endian floating point number.
-        floatne -- a native-endian floating point number.
-        bfloat / bfloatbe - a big-endian bfloat format 16-bit floating point number.
-        bfloatle -- a little-endian bfloat format 16-bit floating point number.
-        bfloatne -- a native-endian bfloat format 16-bit floating point number.
-        intbe -- a signed big-endian whole byte integer.
-        intle -- a signed little-endian whole byte integer.
-        intne -- a signed native-endian whole byte integer.
-        uintbe -- an unsigned big-endian whole byte integer.
-        uintle -- an unsigned little-endian whole byte integer.
-        uintne -- an unsigned native-endian whole byte integer.
-        filename -- the path of a file which will be opened in binary read-only mode.
-
-        Other keyword arguments:
-        length -- length of the bitstring in bits, if needed and appropriate.
-                  It must be supplied for all integer and float initialisers.
-        offset -- bit offset to the data. These offset bits are
-                  ignored and this is mainly intended for use when
-                  initialising using 'bytes' or 'filename'.
-        pos -- Initial bit position, defaults to 0.
-
-        """
-        if pos < 0:
-            pos += len(self._bitstore)
-        if pos < 0 or pos > len(self._bitstore):
-            raise bitstring.CreationError(f"Cannot set pos to {pos} when length is {len(self._bitstore)}.")
-        self._pos = pos
-        self._bitstore.immutable = True
-
-    def _setbytepos(self, bytepos: int) -> None:
-        """Move to absolute byte-aligned position in stream."""
-        self._setbitpos(bytepos * 8)
-
-    def _getbytepos(self) -> int:
-        """Return the current position in the stream in bytes. Must be byte aligned."""
-        if self._pos % 8:
-            raise bitstring.ByteAlignError("Not byte aligned when using bytepos property.")
-        return self._pos // 8
-
-    def _setbitpos(self, pos: int) -> None:
-        """Move to absolute position bit in bitstream."""
-        if pos < 0:
-            raise ValueError("Bit position cannot be negative.")
-        if pos > len(self):
-            raise ValueError("Cannot seek past the end of the data.")
-        self._pos = pos
-
-    def _getbitpos(self) -> int:
-        """Return the current position in the stream in bits."""
-        return self._pos
-
-    def _clear(self) -> None:
-        Bits._clear(self)
-        self._pos = 0
-
-    def __copy__(self: TConstBitStream) -> TConstBitStream:
-        """Return a new copy of the ConstBitStream for the copy module."""
-        # Note that if you want a new copy (different ID), use _copy instead.
-        # The copy can use the same datastore as it's immutable.
-        s = self.__class__()
-        s._bitstore = self._bitstore
-        # Reset the bit position, don't copy it.
-        s._pos = 0
-        return s
-
-    def __and__(self: TConstBitStream, bs: BitsType, /) -> TConstBitStream:
-        """Bit-wise 'and' between two bitstrings. Returns new bitstring.
-
-        bs -- The bitstring to '&' with.
-
-        Raises ValueError if the two bitstrings have differing lengths.
-
-        """
-        s = Bits.__and__(self, bs)
-        s._pos = 0
-        return s
-
-    def __or__(self: TConstBitStream, bs: BitsType, /) -> TConstBitStream:
-        """Bit-wise 'or' between two bitstrings. Returns new bitstring.
-
-        bs -- The bitstring to '|' with.
-
-        Raises ValueError if the two bitstrings have differing lengths.
-
-        """
-        s = Bits.__or__(self, bs)
-        s._pos = 0
-        return s
-
-    def __xor__(self: TConstBitStream, bs: BitsType, /) -> TConstBitStream:
-        """Bit-wise 'xor' between two bitstrings. Returns new bitstring.
-
-        bs -- The bitstring to '^' with.
-
-        Raises ValueError if the two bitstrings have differing lengths.
-
-        """
-        s = Bits.__xor__(self, bs)
-        s._pos = 0
-        return s
-
-    def __add__(self: TConstBitStream, bs: BitsType, /) -> TConstBitStream:
-        """Concatenate bitstrings and return new bitstring.
-
-        bs -- the bitstring to append.
-
-        """
-        s = Bits.__add__(self, bs)
-        s._pos = 0
-        return s
-
-    def append(self, bs: BitsType, /) -> None:
-        """Append a bitstring to the current bitstring.
-
-        bs -- The bitstring to append.
-
-        The current bit position will be moved to the end of the BitStream.
-
-        """
-        self._append(bs)
-        self._pos = len(self)
-
-    def __repr__(self) -> str:
-        """Return representation that could be used to recreate the bitstring.
-
-        If the returned string is too long it will be truncated. See __str__().
-
-        """
-        return self._repr(self.__class__.__name__, len(self), self._pos)
-
-    def overwrite(self, bs: BitsType, /, pos: Optional[int] = None) -> None:
-        """Overwrite with bitstring at bit position pos.
-
-        bs -- The bitstring to overwrite with.
-        pos -- The bit position to begin overwriting from.
-
-        The current bit position will be moved to the end of the overwritten section.
-        Raises ValueError if pos < 0 or pos > len(self).
-
-        """
-        bs = Bits._create_from_bitstype(bs)
-        if len(bs) == 0:
-            return
-        if pos is None:
-            pos = self._pos
-        if pos < 0:
-            pos += len(self)
-        if pos < 0 or pos > len(self):
-            raise ValueError("Overwrite starts outside boundary of bitstring.")
-        self._overwrite(bs, pos)
-        self._pos = pos + len(bs)
-
-    def find(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,
-             bytealigned: Optional[bool] = None) -> Union[Tuple[int], Tuple[()]]:
-        """Find first occurrence of substring bs.
-
-        Returns a single item tuple with the bit position if found, or an
-        empty tuple if not found. The bit position (pos property) will
-        also be set to the start of the substring if it is found.
-
-        bs -- The bitstring to find.
-        start -- The bit position to start the search. Defaults to 0.
-        end -- The bit position one past the last bit to search.
-               Defaults to len(self).
-        bytealigned -- If True the bitstring will only be
-                       found on byte boundaries.
-
-        Raises ValueError if bs is empty, if start < 0, if end > len(self) or
-        if end < start.
-
-        >>> BitStream('0xc3e').find('0b1111')
-        (6,)
-
-        """
-
-        p = super().find(bs, start, end, bytealigned)
-        if p:
-            self._pos = p[0]
-        return p
-
-    def rfind(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,
-              bytealigned: Optional[bool] = None) -> Union[Tuple[int], Tuple[()]]:
-        """Find final occurrence of substring bs.
-
-        Returns a single item tuple with the bit position if found, or an
-        empty tuple if not found. The bit position (pos property) will
-        also be set to the start of the substring if it is found.
-
-        bs -- The bitstring to find.
-        start -- The bit position to end the reverse search. Defaults to 0.
-        end -- The bit position one past the first bit to reverse search.
-               Defaults to len(self).
-        bytealigned -- If True the bitstring will only be found on byte
-                       boundaries.
-
-        Raises ValueError if bs is empty, if start < 0, if end > len(self) or
-        if end < start.
-
-        """
-        p = super().rfind(bs, start, end, bytealigned)
-        if p:
-            self._pos = p[0]
-        return p
-
-    @overload
-    def read(self, fmt: int) -> Bits:
-        ...
-
-    @overload
-    def read(self, fmt: str) -> Any:
-        ...
-
-    def read(self, fmt: Union[int, str, Dtype]) -> Union[int, float, str, Bits, bool, bytes, None]:
-        """Interpret next bits according to the format string and return result.
-
-        fmt -- Token string describing how to interpret the next bits.
-
-        Token examples: 'int:12'    : 12 bits as a signed integer
-                        'uint:8'    : 8 bits as an unsigned integer
-                        'float:64'  : 8 bytes as a big-endian float
-                        'intbe:16'  : 2 bytes as a big-endian signed integer
-                        'uintbe:16' : 2 bytes as a big-endian unsigned integer
-                        'intle:32'  : 4 bytes as a little-endian signed integer
-                        'uintle:32' : 4 bytes as a little-endian unsigned integer
-                        'floatle:64': 8 bytes as a little-endian float
-                        'intne:24'  : 3 bytes as a native-endian signed integer
-                        'uintne:24' : 3 bytes as a native-endian unsigned integer
-                        'floatne:32': 4 bytes as a native-endian float
-                        'hex:80'    : 80 bits as a hex string
-                        'oct:9'     : 9 bits as an octal string
-                        'bin:1'     : single bit binary string
-                        'ue'        : next bits as unsigned exp-Golomb code
-                        'se'        : next bits as signed exp-Golomb code
-                        'uie'       : next bits as unsigned interleaved exp-Golomb code
-                        'sie'       : next bits as signed interleaved exp-Golomb code
-                        'bits:5'    : 5 bits as a bitstring
-                        'bytes:10'  : 10 bytes as a bytes object
-                        'bool'      : 1 bit as a bool
-                        'pad:3'     : 3 bits of padding to ignore - returns None
-
-        fmt may also be an integer, which will be treated like the 'bits' token.
-
-        The position in the bitstring is advanced to after the read items.
-
-        Raises ReadError if not enough bits are available.
-        Raises ValueError if the format is not understood.
-
-        """
-        p = self._pos
-        if isinstance(fmt, numbers.Integral):
-            if fmt < 0:
-                raise ValueError("Cannot read negative amount.")
-            if fmt > len(self) - self._pos:
-                raise bitstring.ReadError(f"Cannot read {fmt} bits, only {len(self) - self._pos} available.")
-            bs = self._slice(self._pos, self._pos + fmt)
-            self._pos += fmt
-            return bs
-        dtype = bitstring.dtypes.Dtype(fmt)
-        if dtype.bitlength is None and not dtype.variable_length:
-            # No length specified? Try again, but read to end.
-            bitlength = len(self) - self._pos
-            items, remainder = divmod(bitlength, dtype.bits_per_item)
-            if remainder != 0:
-                raise ValueError(
-                    f"The '{dtype.name}' type must have a bit length that is a multiple of {dtype.bits_per_item}"
-                    f" so cannot be read from the {bitlength} bits that are available.")
-            dtype = bitstring.dtypes.Dtype(fmt, items)
-        if dtype.bitlength is not None:
-            val = dtype.read_fn(self, self._pos)
-            self._pos += dtype.bitlength
-        else:
-            val, self._pos = dtype.read_fn(self, self._pos)
-
-        if self._pos > len(self):
-            self._pos = p
-            raise bitstring.ReadError(f"Reading off end of bitstring with fmt '{fmt}'. Only {len(self) - p} bits available.")
-        return val
-
-    def readlist(self, fmt: Union[str, List[Union[int, str, Dtype]]], **kwargs) \
-            -> List[Union[int, float, str, Bits, bool, bytes, None]]:
-        """Interpret next bits according to format string(s) and return list.
-
-        fmt -- A single string or list of strings with comma separated tokens
-               describing how to interpret the next bits in the bitstring. Items
-               can also be integers, for reading new bitstring of the given length.
-        kwargs -- A dictionary or keyword-value pairs - the keywords used in the
-                  format string will be replaced with their given value.
-
-        The position in the bitstring is advanced to after the read items.
-
-        Raises ReadError is not enough bits are available.
-        Raises ValueError if the format is not understood.
-
-        See the docstring for 'read' for token examples. 'pad' tokens are skipped
-        and not added to the returned list.
-
-        >>> h, b1, b2 = s.readlist('hex:20, bin:5, bin:3')
-        >>> i, bs1, bs2 = s.readlist(['uint:12', 10, 10])
-
-        """
-        value, self._pos = self._readlist(fmt, self._pos, **kwargs)
-        return value
-
-    def readto(self: TConstBitStream, bs: BitsType, /, bytealigned: Optional[bool] = None) -> TConstBitStream:
-        """Read up to and including next occurrence of bs and return result.
-
-        bs -- The bitstring to find.
-        bytealigned -- If True the bitstring will only be
-                       found on byte boundaries.
-
-        Raises ValueError if bs is empty.
-        Raises ReadError if bs is not found.
-
-        """
-        if isinstance(bs, numbers.Integral):
-            raise ValueError("Integers cannot be searched for")
-        bs = Bits._create_from_bitstype(bs)
-        oldpos = self._pos
-        p = self.find(bs, self._pos, bytealigned=bytealigned)
-        if not p:
-            raise bitstring.ReadError("Substring not found")
-        self._pos += len(bs)
-        return self._slice(oldpos, self._pos)
-
-    @overload
-    def peek(self: TConstBitStream, fmt: int) -> TConstBitStream:
-        ...
-
-    @overload
-    def peek(self, fmt: str) -> Union[int, float, str, TConstBitStream, bool, bytes, None]:
-        ...
-
-    def peek(self: TConstBitStream, fmt: Union[int, str]) -> Union[int, float, str, TConstBitStream, bool, bytes, None]:
-        """Interpret next bits according to format string and return result.
-
-        fmt -- Token string describing how to interpret the next bits.
-
-        The position in the bitstring is not changed. If not enough bits are
-        available then all bits to the end of the bitstring will be used.
-
-        Raises ReadError if not enough bits are available.
-        Raises ValueError if the format is not understood.
-
-        See the docstring for 'read' for token examples.
-
-        """
-        pos_before = self._pos
-        value = self.read(fmt)
-        self._pos = pos_before
-        return value
-
-    def peeklist(self, fmt: Union[str, List[Union[int, str]]], **kwargs) \
-            -> List[Union[int, float, str, Bits, None]]:
-        """Interpret next bits according to format string(s) and return list.
-
-        fmt -- One or more integers or strings with comma separated tokens describing
-               how to interpret the next bits in the bitstring.
-        kwargs -- A dictionary or keyword-value pairs - the keywords used in the
-                  format string will be replaced with their given value.
-
-        The position in the bitstring is not changed. If not enough bits are
-        available then all bits to the end of the bitstring will be used.
-
-        Raises ReadError if not enough bits are available.
-        Raises ValueError if the format is not understood.
-
-        See the docstring for 'read' for token examples.
-
-        """
-        pos = self._pos
-        return_values = self.readlist(fmt, **kwargs)
-        self._pos = pos
-        return return_values
-
-    def bytealign(self) -> int:
-        """Align to next byte and return number of skipped bits.
-
-        Raises ValueError if the end of the bitstring is reached before
-        aligning to the next byte.
-
-        """
-        skipped = (8 - (self._pos % 8)) % 8
-        self.pos += skipped
-        return skipped
-
-    @classmethod
-    def fromstring(cls: TBits, s: str, /) -> TBits:
-        x = super().fromstring(s)
-        x._pos = 0
-        x._bitstore.immutable = True
-        return x
-
-    @overload
-    def __getitem__(self: TBits, key: slice, /) -> TBits:
-        ...
-
-    @overload
-    def __getitem__(self: TBits, key: int, /) -> bool:
-        ...
-
-    def __getitem__(self: TBits, key: Union[slice, int], /) -> Union[TBits, bool]:
-        """Return a new bitstring representing a slice of the current bitstring."""
-        if isinstance(key, numbers.Integral):
-            return bool(self._bitstore.getindex(key))
-        bs = super().__new__(self.__class__)
-        bs._bitstore = self._bitstore.getslice_withstep(key)
-        bs._pos = 0
-        return bs
-
-    pos = property(_getbitpos, _setbitpos,
-                   doc="""The position in the bitstring in bits. Read and write.
-                      """)
-    bitpos = property(_getbitpos, _setbitpos,
-                      doc="""The position in the bitstring in bits. Read and write.
-                      """)
-    bytepos = property(_getbytepos, _setbytepos,
-                       doc="""The position in the bitstring in bytes. Read and write.
-                      """)
-
-
-class BitStream(ConstBitStream, bitstring.BitArray):
-    """A container or stream holding a mutable sequence of bits
-
-    Subclass of the ConstBitStream and BitArray classes. Inherits all of
-    their methods.
-
-    Methods:
-
-    all() -- Check if all specified bits are set to 1 or 0.
-    any() -- Check if any of specified bits are set to 1 or 0.
-    append() -- Append a bitstring.
-    bytealign() -- Align to next byte boundary.
-    byteswap() -- Change byte endianness in-place.
-    clear() -- Remove all bits from the bitstring.
-    copy() -- Return a copy of the bitstring.
-    count() -- Count the number of bits set to 1 or 0.
-    cut() -- Create generator of constant sized chunks.
-    endswith() -- Return whether the bitstring ends with a sub-string.
-    find() -- Find a sub-bitstring in the current bitstring.
-    findall() -- Find all occurrences of a sub-bitstring in the current bitstring.
-    fromstring() -- Create a bitstring from a formatted string.
-    insert() -- Insert a bitstring.
-    invert() -- Flip bit(s) between one and zero.
-    join() -- Join bitstrings together using current bitstring.
-    overwrite() -- Overwrite a section with a new bitstring.
-    peek() -- Peek at and interpret next bits as a single item.
-    peeklist() -- Peek at and interpret next bits as a list of items.
-    pp() -- Pretty print the bitstring.
-    prepend() -- Prepend a bitstring.
-    read() -- Read and interpret next bits as a single item.
-    readlist() -- Read and interpret next bits as a list of items.
-    readto() -- Read up to and including next occurrence of a bitstring.
-    replace() -- Replace occurrences of one bitstring with another.
-    reverse() -- Reverse bits in-place.
-    rfind() -- Seek backwards to find a sub-bitstring.
-    rol() -- Rotate bits to the left.
-    ror() -- Rotate bits to the right.
-    set() -- Set bit(s) to 1 or 0.
-    split() -- Create generator of chunks split by a delimiter.
-    startswith() -- Return whether the bitstring starts with a sub-bitstring.
-    tobitarray() -- Return bitstring as a bitarray from the bitarray package.
-    tobytes() -- Return bitstring as bytes, padding if needed.
-    tofile() -- Write bitstring to file, padding if needed.
-    unpack() -- Interpret bits using format string.
-
-    Special methods:
-
-    Mutating operators are available: [], <<=, >>=, +=, *=, &=, |= and ^=
-    in addition to [], ==, !=, +, *, ~, <<, >>, &, | and ^.
-
-    Properties:
-
-    [GENERATED_PROPERTY_DESCRIPTIONS]
-
-    len -- Length of the bitstring in bits.
-    pos -- The current bit position in the bitstring.
-    """
-
-    __slots__ = ()
-
-    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,
-                 offset: Optional[int] = None, pos: int = 0, **kwargs) -> None:
-        """Either specify an 'auto' initialiser:
-        A string of comma separated tokens, an integer, a file object,
-        a bytearray, a boolean iterable or another bitstring.
-
-        Or initialise via **kwargs with one (and only one) of:
-        bin -- binary string representation, e.g. '0b001010'.
-        hex -- hexadecimal string representation, e.g. '0x2ef'
-        oct -- octal string representation, e.g. '0o777'.
-        bytes -- raw data as a bytes object, for example read from a binary file.
-        int -- a signed integer.
-        uint -- an unsigned integer.
-        float / floatbe -- a big-endian floating point number.
-        bool -- a boolean (True or False).
-        se -- a signed exponential-Golomb code.
-        ue -- an unsigned exponential-Golomb code.
-        sie -- a signed interleaved exponential-Golomb code.
-        uie -- an unsigned interleaved exponential-Golomb code.
-        floatle -- a little-endian floating point number.
-        floatne -- a native-endian floating point number.
-        bfloat / bfloatbe - a big-endian bfloat format 16-bit floating point number.
-        bfloatle -- a little-endian bfloat format 16-bit floating point number.
-        bfloatne -- a native-endian bfloat format 16-bit floating point number.
-        intbe -- a signed big-endian whole byte integer.
-        intle -- a signed little-endian whole byte integer.
-        intne -- a signed native-endian whole byte integer.
-        uintbe -- an unsigned big-endian whole byte integer.
-        uintle -- an unsigned little-endian whole byte integer.
-        uintne -- an unsigned native-endian whole byte integer.
-        filename -- the path of a file which will be opened in binary read-only mode.
-
-        Other keyword arguments:
-        length -- length of the bitstring in bits, if needed and appropriate.
-                  It must be supplied for all integer and float initialisers.
-        offset -- bit offset to the data. These offset bits are
-                  ignored and this is intended for use when
-                  initialising using 'bytes' or 'filename'.
-        pos -- Initial bit position, defaults to 0.
-
-        """
-        ConstBitStream.__init__(self, auto, length, offset, pos, **kwargs)
-        if self._bitstore.immutable:
-            self._bitstore = self._bitstore._copy()
-            self._bitstore.immutable = False
-
-    def __copy__(self) -> BitStream:
-        """Return a new copy of the BitStream."""
-        s_copy = object.__new__(BitStream)
-        s_copy._pos = 0
-        s_copy._bitstore = self._bitstore.copy()
-        return s_copy
-
-    def __iadd__(self, bs: BitsType, /) -> BitStream:
-        """Append to current bitstring. Return self.
-
-        bs -- the bitstring to append.
-
-        The current bit position will be moved to the end of the BitStream.
-        """
-        self._append(bs)
-        self._pos = len(self)
-        return self
-
-    def prepend(self, bs: BitsType, /) -> None:
-        """Prepend a bitstring to the current bitstring.
-
-        bs -- The bitstring to prepend.
-
-        """
-        bs = Bits._create_from_bitstype(bs)
-        super().prepend(bs)
-        self._pos = 0
-
-    def __setitem__(self, /, key: Union[slice, int], value: BitsType) -> None:
-        length_before = len(self)
-        super().__setitem__(key, value)
-        if len(self) != length_before:
-            self._pos = 0
-        return
-
-    def __delitem__(self, /, key: Union[slice, int]) -> None:
-        """Delete item or range.
-
-        >>> a = BitStream('0x001122')
-        >>> del a[8:16]
-        >>> print a
-        0x0022
-
-        """
-        length_before = len(self)
-        self._bitstore.__delitem__(key)
-        if len(self) != length_before:
-            self._pos = 0
-
-    def insert(self, bs: BitsType, /, pos: Optional[int] = None) -> None:
-        """Insert bitstring at bit position pos.
-
-        bs -- The bitstring to insert.
-        pos -- The bit position to insert at.
-
-        The current bit position will be moved to the end of the inserted section.
-        Raises ValueError if pos < 0 or pos > len(self).
-
-        """
-        bs = Bits._create_from_bitstype(bs)
-        if len(bs) == 0:
-            return
-        if bs is self:
-            bs = self._copy()
-        if pos is None:
-            pos = self._pos
-        if pos < 0:
-            pos += len(self)
-        if not 0 <= pos <= len(self):
-            raise ValueError("Invalid insert position.")
-        self._insert(bs, pos)
-        self._pos = pos + len(bs)
-
-    def replace(self, old: BitsType, new: BitsType, start: Optional[int] = None, end: Optional[int] = None,
-                count: Optional[int] = None, bytealigned: Optional[bool] = None) -> int:
-        """Replace all occurrences of old with new in place.
-
-        Returns number of replacements made.
-
-        old -- The bitstring to replace.
-        new -- The replacement bitstring.
-        start -- Any occurrences that start before this will not be replaced.
-                 Defaults to 0.
-        end -- Any occurrences that finish after this will not be replaced.
-               Defaults to len(self).
-        count -- The maximum number of replacements to make. Defaults to
-                 replace all occurrences.
-        bytealigned -- If True replacements will only be made on byte
-                       boundaries.
-
-        Raises ValueError if old is empty or if start or end are
-        out of range.
-
-        """
-        if count == 0:
-            return 0
-        if len(old := Bits._create_from_bitstype(old)) == 0:
-            raise ValueError("Empty bitstring cannot be replaced.")
-        start, end = self._validate_slice(start, end)
-        new = Bits._create_from_bitstype(new)
-        if new is self:
-            # Prevent self assignment woes
-            new = copy.copy(self)
-        length_before = len(self)
-        replacement_count = self._replace(old, new, start, end, 0 if count is None else count, bytealigned)
-        if len(self) != length_before:
-            self._pos = 0
+from __future__ import annotations
+
+import bitstring
+from bitstring.bits import Bits, BitsType
+from bitstring.dtypes import Dtype
+from typing import Union, List, Any, Optional, overload, TypeVar, Tuple
+import copy
+import numbers
+
+TConstBitStream = TypeVar("TConstBitStream", bound='ConstBitStream')
+
+
+class ConstBitStream(Bits):
+    """A container or stream holding an immutable sequence of bits.
+
+    For a mutable container use the BitStream class instead.
+
+    Methods inherited from Bits:
+
+    all() -- Check if all specified bits are set to 1 or 0.
+    any() -- Check if any of specified bits are set to 1 or 0.
+    copy() -- Return a copy of the bitstring.
+    count() -- Count the number of bits set to 1 or 0.
+    cut() -- Create generator of constant sized chunks.
+    endswith() -- Return whether the bitstring ends with a sub-string.
+    find() -- Find a sub-bitstring in the current bitstring.
+    findall() -- Find all occurrences of a sub-bitstring in the current bitstring.
+    fromstring() -- Create a bitstring from a formatted string.
+    join() -- Join bitstrings together using current bitstring.
+    pp() -- Pretty print the bitstring.
+    rfind() -- Seek backwards to find a sub-bitstring.
+    split() -- Create generator of chunks split by a delimiter.
+    startswith() -- Return whether the bitstring starts with a sub-bitstring.
+    tobitarray() -- Return bitstring as a bitarray from the bitarray package.
+    tobytes() -- Return bitstring as bytes, padding if needed.
+    tofile() -- Write bitstring to file, padding if needed.
+    unpack() -- Interpret bits using format string.
+
+    Other methods:
+
+    bytealign() -- Align to next byte boundary.
+    peek() -- Peek at and interpret next bits as a single item.
+    peeklist() -- Peek at and interpret next bits as a list of items.
+    read() -- Read and interpret next bits as a single item.
+    readlist() -- Read and interpret next bits as a list of items.
+    readto() -- Read up to and including next occurrence of a bitstring.
+
+    Special methods:
+
+    Also available are the operators [], ==, !=, +, *, ~, <<, >>, &, |, ^.
+
+    Properties:
+
+    [GENERATED_PROPERTY_DESCRIPTIONS]
+
+    len -- Length of the bitstring in bits.
+    pos -- The current bit position in the bitstring.
+    """
+
+    __slots__ = ('_pos')
+
+    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,
+                 offset: Optional[int] = None, pos: int = 0, **kwargs) -> None:
+        """Either specify an 'auto' initialiser:
+        A string of comma separated tokens, an integer, a file object,
+        a bytearray, a boolean iterable or another bitstring.
+
+        Or initialise via **kwargs with one (and only one) of:
+        bin -- binary string representation, e.g. '0b001010'.
+        hex -- hexadecimal string representation, e.g. '0x2ef'
+        oct -- octal string representation, e.g. '0o777'.
+        bytes -- raw data as a bytes object, for example read from a binary file.
+        int -- a signed integer.
+        uint -- an unsigned integer.
+        float / floatbe -- a big-endian floating point number.
+        bool -- a boolean (True or False).
+        se -- a signed exponential-Golomb code.
+        ue -- an unsigned exponential-Golomb code.
+        sie -- a signed interleaved exponential-Golomb code.
+        uie -- an unsigned interleaved exponential-Golomb code.
+        floatle -- a little-endian floating point number.
+        floatne -- a native-endian floating point number.
+        bfloat / bfloatbe - a big-endian bfloat format 16-bit floating point number.
+        bfloatle -- a little-endian bfloat format 16-bit floating point number.
+        bfloatne -- a native-endian bfloat format 16-bit floating point number.
+        intbe -- a signed big-endian whole byte integer.
+        intle -- a signed little-endian whole byte integer.
+        intne -- a signed native-endian whole byte integer.
+        uintbe -- an unsigned big-endian whole byte integer.
+        uintle -- an unsigned little-endian whole byte integer.
+        uintne -- an unsigned native-endian whole byte integer.
+        filename -- the path of a file which will be opened in binary read-only mode.
+
+        Other keyword arguments:
+        length -- length of the bitstring in bits, if needed and appropriate.
+                  It must be supplied for all integer and float initialisers.
+        offset -- bit offset to the data. These offset bits are
+                  ignored and this is mainly intended for use when
+                  initialising using 'bytes' or 'filename'.
+        pos -- Initial bit position, defaults to 0.
+
+        """
+        if pos < 0:
+            pos += len(self._bitstore)
+        if pos < 0 or pos > len(self._bitstore):
+            raise bitstring.CreationError(f"Cannot set pos to {pos} when length is {len(self._bitstore)}.")
+        self._pos = pos
+        self._bitstore.immutable = True
+
+    def _setbytepos(self, bytepos: int) -> None:
+        """Move to absolute byte-aligned position in stream."""
+        self._setbitpos(bytepos * 8)
+
+    def _getbytepos(self) -> int:
+        """Return the current position in the stream in bytes. Must be byte aligned."""
+        if self._pos % 8:
+            raise bitstring.ByteAlignError("Not byte aligned when using bytepos property.")
+        return self._pos // 8
+
+    def _setbitpos(self, pos: int) -> None:
+        """Move to absolute position bit in bitstream."""
+        if pos < 0:
+            raise ValueError("Bit position cannot be negative.")
+        if pos > len(self):
+            raise ValueError("Cannot seek past the end of the data.")
+        self._pos = pos
+
+    def _getbitpos(self) -> int:
+        """Return the current position in the stream in bits."""
+        return self._pos
+
+    def _clear(self) -> None:
+        Bits._clear(self)
+        self._pos = 0
+
+    def __copy__(self: TConstBitStream) -> TConstBitStream:
+        """Return a new copy of the ConstBitStream for the copy module."""
+        # Note that if you want a new copy (different ID), use _copy instead.
+        # The copy can use the same datastore as it's immutable.
+        s = self.__class__()
+        s._bitstore = self._bitstore
+        # Reset the bit position, don't copy it.
+        s._pos = 0
+        return s
+
+    def __and__(self: TConstBitStream, bs: BitsType, /) -> TConstBitStream:
+        """Bit-wise 'and' between two bitstrings. Returns new bitstring.
+
+        bs -- The bitstring to '&' with.
+
+        Raises ValueError if the two bitstrings have differing lengths.
+
+        """
+        s = Bits.__and__(self, bs)
+        s._pos = 0
+        return s
+
+    def __or__(self: TConstBitStream, bs: BitsType, /) -> TConstBitStream:
+        """Bit-wise 'or' between two bitstrings. Returns new bitstring.
+
+        bs -- The bitstring to '|' with.
+
+        Raises ValueError if the two bitstrings have differing lengths.
+
+        """
+        s = Bits.__or__(self, bs)
+        s._pos = 0
+        return s
+
+    def __xor__(self: TConstBitStream, bs: BitsType, /) -> TConstBitStream:
+        """Bit-wise 'xor' between two bitstrings. Returns new bitstring.
+
+        bs -- The bitstring to '^' with.
+
+        Raises ValueError if the two bitstrings have differing lengths.
+
+        """
+        s = Bits.__xor__(self, bs)
+        s._pos = 0
+        return s
+
+    def __add__(self: TConstBitStream, bs: BitsType, /) -> TConstBitStream:
+        """Concatenate bitstrings and return new bitstring.
+
+        bs -- the bitstring to append.
+
+        """
+        s = Bits.__add__(self, bs)
+        s._pos = 0
+        return s
+
+    def append(self, bs: BitsType, /) -> None:
+        """Append a bitstring to the current bitstring.
+
+        bs -- The bitstring to append.
+
+        The current bit position will be moved to the end of the BitStream.
+
+        """
+        self._append(bs)
+        self._pos = len(self)
+
+    def __repr__(self) -> str:
+        """Return representation that could be used to recreate the bitstring.
+
+        If the returned string is too long it will be truncated. See __str__().
+
+        """
+        return self._repr(self.__class__.__name__, len(self), self._pos)
+
+    def overwrite(self, bs: BitsType, /, pos: Optional[int] = None) -> None:
+        """Overwrite with bitstring at bit position pos.
+
+        bs -- The bitstring to overwrite with.
+        pos -- The bit position to begin overwriting from.
+
+        The current bit position will be moved to the end of the overwritten section.
+        Raises ValueError if pos < 0 or pos > len(self).
+
+        """
+        bs = Bits._create_from_bitstype(bs)
+        if len(bs) == 0:
+            return
+        if pos is None:
+            pos = self._pos
+        if pos < 0:
+            pos += len(self)
+        if pos < 0 or pos > len(self):
+            raise ValueError("Overwrite starts outside boundary of bitstring.")
+        self._overwrite(bs, pos)
+        self._pos = pos + len(bs)
+
+    def find(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,
+             bytealigned: Optional[bool] = None) -> Union[Tuple[int], Tuple[()]]:
+        """Find first occurrence of substring bs.
+
+        Returns a single item tuple with the bit position if found, or an
+        empty tuple if not found. The bit position (pos property) will
+        also be set to the start of the substring if it is found.
+
+        bs -- The bitstring to find.
+        start -- The bit position to start the search. Defaults to 0.
+        end -- The bit position one past the last bit to search.
+               Defaults to len(self).
+        bytealigned -- If True the bitstring will only be
+                       found on byte boundaries.
+
+        Raises ValueError if bs is empty, if start < 0, if end > len(self) or
+        if end < start.
+
+        >>> BitStream('0xc3e').find('0b1111')
+        (6,)
+
+        """
+
+        p = super().find(bs, start, end, bytealigned)
+        if p:
+            self._pos = p[0]
+        return p
+
+    def rfind(self, bs: BitsType, /, start: Optional[int] = None, end: Optional[int] = None,
+              bytealigned: Optional[bool] = None) -> Union[Tuple[int], Tuple[()]]:
+        """Find final occurrence of substring bs.
+
+        Returns a single item tuple with the bit position if found, or an
+        empty tuple if not found. The bit position (pos property) will
+        also be set to the start of the substring if it is found.
+
+        bs -- The bitstring to find.
+        start -- The bit position to end the reverse search. Defaults to 0.
+        end -- The bit position one past the first bit to reverse search.
+               Defaults to len(self).
+        bytealigned -- If True the bitstring will only be found on byte
+                       boundaries.
+
+        Raises ValueError if bs is empty, if start < 0, if end > len(self) or
+        if end < start.
+
+        """
+        p = super().rfind(bs, start, end, bytealigned)
+        if p:
+            self._pos = p[0]
+        return p
+
+    @overload
+    def read(self, fmt: int) -> Bits:
+        ...
+
+    @overload
+    def read(self, fmt: str) -> Any:
+        ...
+
+    def read(self, fmt: Union[int, str, Dtype]) -> Union[int, float, str, Bits, bool, bytes, None]:
+        """Interpret next bits according to the format string and return result.
+
+        fmt -- Token string describing how to interpret the next bits.
+
+        Token examples: 'int:12'    : 12 bits as a signed integer
+                        'uint:8'    : 8 bits as an unsigned integer
+                        'float:64'  : 8 bytes as a big-endian float
+                        'intbe:16'  : 2 bytes as a big-endian signed integer
+                        'uintbe:16' : 2 bytes as a big-endian unsigned integer
+                        'intle:32'  : 4 bytes as a little-endian signed integer
+                        'uintle:32' : 4 bytes as a little-endian unsigned integer
+                        'floatle:64': 8 bytes as a little-endian float
+                        'intne:24'  : 3 bytes as a native-endian signed integer
+                        'uintne:24' : 3 bytes as a native-endian unsigned integer
+                        'floatne:32': 4 bytes as a native-endian float
+                        'hex:80'    : 80 bits as a hex string
+                        'oct:9'     : 9 bits as an octal string
+                        'bin:1'     : single bit binary string
+                        'ue'        : next bits as unsigned exp-Golomb code
+                        'se'        : next bits as signed exp-Golomb code
+                        'uie'       : next bits as unsigned interleaved exp-Golomb code
+                        'sie'       : next bits as signed interleaved exp-Golomb code
+                        'bits:5'    : 5 bits as a bitstring
+                        'bytes:10'  : 10 bytes as a bytes object
+                        'bool'      : 1 bit as a bool
+                        'pad:3'     : 3 bits of padding to ignore - returns None
+
+        fmt may also be an integer, which will be treated like the 'bits' token.
+
+        The position in the bitstring is advanced to after the read items.
+
+        Raises ReadError if not enough bits are available.
+        Raises ValueError if the format is not understood.
+
+        """
+        p = self._pos
+        if isinstance(fmt, numbers.Integral):
+            if fmt < 0:
+                raise ValueError("Cannot read negative amount.")
+            if fmt > len(self) - self._pos:
+                raise bitstring.ReadError(f"Cannot read {fmt} bits, only {len(self) - self._pos} available.")
+            bs = self._slice(self._pos, self._pos + fmt)
+            self._pos += fmt
+            return bs
+        dtype = bitstring.dtypes.Dtype(fmt)
+        if dtype.bitlength is None and not dtype.variable_length:
+            # No length specified? Try again, but read to end.
+            bitlength = len(self) - self._pos
+            items, remainder = divmod(bitlength, dtype.bits_per_item)
+            if remainder != 0:
+                raise ValueError(
+                    f"The '{dtype.name}' type must have a bit length that is a multiple of {dtype.bits_per_item}"
+                    f" so cannot be read from the {bitlength} bits that are available.")
+            dtype = bitstring.dtypes.Dtype(fmt, items)
+        if dtype.bitlength is not None:
+            val = dtype.read_fn(self, self._pos)
+            self._pos += dtype.bitlength
+        else:
+            val, self._pos = dtype.read_fn(self, self._pos)
+
+        if self._pos > len(self):
+            self._pos = p
+            raise bitstring.ReadError(f"Reading off end of bitstring with fmt '{fmt}'. Only {len(self) - p} bits available.")
+        return val
+
+    def readlist(self, fmt: Union[str, List[Union[int, str, Dtype]]], **kwargs) \
+            -> List[Union[int, float, str, Bits, bool, bytes, None]]:
+        """Interpret next bits according to format string(s) and return list.
+
+        fmt -- A single string or list of strings with comma separated tokens
+               describing how to interpret the next bits in the bitstring. Items
+               can also be integers, for reading new bitstring of the given length.
+        kwargs -- A dictionary or keyword-value pairs - the keywords used in the
+                  format string will be replaced with their given value.
+
+        The position in the bitstring is advanced to after the read items.
+
+        Raises ReadError is not enough bits are available.
+        Raises ValueError if the format is not understood.
+
+        See the docstring for 'read' for token examples. 'pad' tokens are skipped
+        and not added to the returned list.
+
+        >>> h, b1, b2 = s.readlist('hex:20, bin:5, bin:3')
+        >>> i, bs1, bs2 = s.readlist(['uint:12', 10, 10])
+
+        """
+        value, self._pos = self._readlist(fmt, self._pos, **kwargs)
+        return value
+
+    def readto(self: TConstBitStream, bs: BitsType, /, bytealigned: Optional[bool] = None) -> TConstBitStream:
+        """Read up to and including next occurrence of bs and return result.
+
+        bs -- The bitstring to find.
+        bytealigned -- If True the bitstring will only be
+                       found on byte boundaries.
+
+        Raises ValueError if bs is empty.
+        Raises ReadError if bs is not found.
+
+        """
+        if isinstance(bs, numbers.Integral):
+            raise ValueError("Integers cannot be searched for")
+        bs = Bits._create_from_bitstype(bs)
+        oldpos = self._pos
+        p = self.find(bs, self._pos, bytealigned=bytealigned)
+        if not p:
+            raise bitstring.ReadError("Substring not found")
+        self._pos += len(bs)
+        return self._slice(oldpos, self._pos)
+
+    @overload
+    def peek(self: TConstBitStream, fmt: int) -> TConstBitStream:
+        ...
+
+    @overload
+    def peek(self, fmt: str) -> Union[int, float, str, TConstBitStream, bool, bytes, None]:
+        ...
+
+    def peek(self: TConstBitStream, fmt: Union[int, str]) -> Union[int, float, str, TConstBitStream, bool, bytes, None]:
+        """Interpret next bits according to format string and return result.
+
+        fmt -- Token string describing how to interpret the next bits.
+
+        The position in the bitstring is not changed. If not enough bits are
+        available then all bits to the end of the bitstring will be used.
+
+        Raises ReadError if not enough bits are available.
+        Raises ValueError if the format is not understood.
+
+        See the docstring for 'read' for token examples.
+
+        """
+        pos_before = self._pos
+        value = self.read(fmt)
+        self._pos = pos_before
+        return value
+
+    def peeklist(self, fmt: Union[str, List[Union[int, str]]], **kwargs) \
+            -> List[Union[int, float, str, Bits, None]]:
+        """Interpret next bits according to format string(s) and return list.
+
+        fmt -- One or more integers or strings with comma separated tokens describing
+               how to interpret the next bits in the bitstring.
+        kwargs -- A dictionary or keyword-value pairs - the keywords used in the
+                  format string will be replaced with their given value.
+
+        The position in the bitstring is not changed. If not enough bits are
+        available then all bits to the end of the bitstring will be used.
+
+        Raises ReadError if not enough bits are available.
+        Raises ValueError if the format is not understood.
+
+        See the docstring for 'read' for token examples.
+
+        """
+        pos = self._pos
+        return_values = self.readlist(fmt, **kwargs)
+        self._pos = pos
+        return return_values
+
+    def bytealign(self) -> int:
+        """Align to next byte and return number of skipped bits.
+
+        Raises ValueError if the end of the bitstring is reached before
+        aligning to the next byte.
+
+        """
+        skipped = (8 - (self._pos % 8)) % 8
+        self.pos += skipped
+        return skipped
+
+    @classmethod
+    def fromstring(cls: TBits, s: str, /) -> TBits:
+        x = super().fromstring(s)
+        x._pos = 0
+        x._bitstore.immutable = True
+        return x
+
+    @overload
+    def __getitem__(self: TBits, key: slice, /) -> TBits:
+        ...
+
+    @overload
+    def __getitem__(self: TBits, key: int, /) -> bool:
+        ...
+
+    def __getitem__(self: TBits, key: Union[slice, int], /) -> Union[TBits, bool]:
+        """Return a new bitstring representing a slice of the current bitstring."""
+        if isinstance(key, numbers.Integral):
+            return bool(self._bitstore.getindex(key))
+        bs = super().__new__(self.__class__)
+        bs._bitstore = self._bitstore.getslice_withstep(key)
+        bs._pos = 0
+        return bs
+
+    pos = property(_getbitpos, _setbitpos,
+                   doc="""The position in the bitstring in bits. Read and write.
+                      """)
+    bitpos = property(_getbitpos, _setbitpos,
+                      doc="""The position in the bitstring in bits. Read and write.
+                      """)
+    bytepos = property(_getbytepos, _setbytepos,
+                       doc="""The position in the bitstring in bytes. Read and write.
+                      """)
+
+
+class BitStream(ConstBitStream, bitstring.BitArray):
+    """A container or stream holding a mutable sequence of bits
+
+    Subclass of the ConstBitStream and BitArray classes. Inherits all of
+    their methods.
+
+    Methods:
+
+    all() -- Check if all specified bits are set to 1 or 0.
+    any() -- Check if any of specified bits are set to 1 or 0.
+    append() -- Append a bitstring.
+    bytealign() -- Align to next byte boundary.
+    byteswap() -- Change byte endianness in-place.
+    clear() -- Remove all bits from the bitstring.
+    copy() -- Return a copy of the bitstring.
+    count() -- Count the number of bits set to 1 or 0.
+    cut() -- Create generator of constant sized chunks.
+    endswith() -- Return whether the bitstring ends with a sub-string.
+    find() -- Find a sub-bitstring in the current bitstring.
+    findall() -- Find all occurrences of a sub-bitstring in the current bitstring.
+    fromstring() -- Create a bitstring from a formatted string.
+    insert() -- Insert a bitstring.
+    invert() -- Flip bit(s) between one and zero.
+    join() -- Join bitstrings together using current bitstring.
+    overwrite() -- Overwrite a section with a new bitstring.
+    peek() -- Peek at and interpret next bits as a single item.
+    peeklist() -- Peek at and interpret next bits as a list of items.
+    pp() -- Pretty print the bitstring.
+    prepend() -- Prepend a bitstring.
+    read() -- Read and interpret next bits as a single item.
+    readlist() -- Read and interpret next bits as a list of items.
+    readto() -- Read up to and including next occurrence of a bitstring.
+    replace() -- Replace occurrences of one bitstring with another.
+    reverse() -- Reverse bits in-place.
+    rfind() -- Seek backwards to find a sub-bitstring.
+    rol() -- Rotate bits to the left.
+    ror() -- Rotate bits to the right.
+    set() -- Set bit(s) to 1 or 0.
+    split() -- Create generator of chunks split by a delimiter.
+    startswith() -- Return whether the bitstring starts with a sub-bitstring.
+    tobitarray() -- Return bitstring as a bitarray from the bitarray package.
+    tobytes() -- Return bitstring as bytes, padding if needed.
+    tofile() -- Write bitstring to file, padding if needed.
+    unpack() -- Interpret bits using format string.
+
+    Special methods:
+
+    Mutating operators are available: [], <<=, >>=, +=, *=, &=, |= and ^=
+    in addition to [], ==, !=, +, *, ~, <<, >>, &, | and ^.
+
+    Properties:
+
+    [GENERATED_PROPERTY_DESCRIPTIONS]
+
+    len -- Length of the bitstring in bits.
+    pos -- The current bit position in the bitstring.
+    """
+
+    __slots__ = ()
+
+    def __init__(self, auto: Optional[Union[BitsType, int]] = None, /, length: Optional[int] = None,
+                 offset: Optional[int] = None, pos: int = 0, **kwargs) -> None:
+        """Either specify an 'auto' initialiser:
+        A string of comma separated tokens, an integer, a file object,
+        a bytearray, a boolean iterable or another bitstring.
+
+        Or initialise via **kwargs with one (and only one) of:
+        bin -- binary string representation, e.g. '0b001010'.
+        hex -- hexadecimal string representation, e.g. '0x2ef'
+        oct -- octal string representation, e.g. '0o777'.
+        bytes -- raw data as a bytes object, for example read from a binary file.
+        int -- a signed integer.
+        uint -- an unsigned integer.
+        float / floatbe -- a big-endian floating point number.
+        bool -- a boolean (True or False).
+        se -- a signed exponential-Golomb code.
+        ue -- an unsigned exponential-Golomb code.
+        sie -- a signed interleaved exponential-Golomb code.
+        uie -- an unsigned interleaved exponential-Golomb code.
+        floatle -- a little-endian floating point number.
+        floatne -- a native-endian floating point number.
+        bfloat / bfloatbe - a big-endian bfloat format 16-bit floating point number.
+        bfloatle -- a little-endian bfloat format 16-bit floating point number.
+        bfloatne -- a native-endian bfloat format 16-bit floating point number.
+        intbe -- a signed big-endian whole byte integer.
+        intle -- a signed little-endian whole byte integer.
+        intne -- a signed native-endian whole byte integer.
+        uintbe -- an unsigned big-endian whole byte integer.
+        uintle -- an unsigned little-endian whole byte integer.
+        uintne -- an unsigned native-endian whole byte integer.
+        filename -- the path of a file which will be opened in binary read-only mode.
+
+        Other keyword arguments:
+        length -- length of the bitstring in bits, if needed and appropriate.
+                  It must be supplied for all integer and float initialisers.
+        offset -- bit offset to the data. These offset bits are
+                  ignored and this is intended for use when
+                  initialising using 'bytes' or 'filename'.
+        pos -- Initial bit position, defaults to 0.
+
+        """
+        ConstBitStream.__init__(self, auto, length, offset, pos, **kwargs)
+        if self._bitstore.immutable:
+            self._bitstore = self._bitstore._copy()
+            self._bitstore.immutable = False
+
+    def __copy__(self) -> BitStream:
+        """Return a new copy of the BitStream."""
+        s_copy = object.__new__(BitStream)
+        s_copy._pos = 0
+        s_copy._bitstore = self._bitstore.copy()
+        return s_copy
+
+    def __iadd__(self, bs: BitsType, /) -> BitStream:
+        """Append to current bitstring. Return self.
+
+        bs -- the bitstring to append.
+
+        The current bit position will be moved to the end of the BitStream.
+        """
+        self._append(bs)
+        self._pos = len(self)
+        return self
+
+    def prepend(self, bs: BitsType, /) -> None:
+        """Prepend a bitstring to the current bitstring.
+
+        bs -- The bitstring to prepend.
+
+        """
+        bs = Bits._create_from_bitstype(bs)
+        super().prepend(bs)
+        self._pos = 0
+
+    def __setitem__(self, /, key: Union[slice, int], value: BitsType) -> None:
+        length_before = len(self)
+        super().__setitem__(key, value)
+        if len(self) != length_before:
+            self._pos = 0
+        return
+
+    def __delitem__(self, /, key: Union[slice, int]) -> None:
+        """Delete item or range.
+
+        >>> a = BitStream('0x001122')
+        >>> del a[8:16]
+        >>> print a
+        0x0022
+
+        """
+        length_before = len(self)
+        self._bitstore.__delitem__(key)
+        if len(self) != length_before:
+            self._pos = 0
+
+    def insert(self, bs: BitsType, /, pos: Optional[int] = None) -> None:
+        """Insert bitstring at bit position pos.
+
+        bs -- The bitstring to insert.
+        pos -- The bit position to insert at.
+
+        The current bit position will be moved to the end of the inserted section.
+        Raises ValueError if pos < 0 or pos > len(self).
+
+        """
+        bs = Bits._create_from_bitstype(bs)
+        if len(bs) == 0:
+            return
+        if bs is self:
+            bs = self._copy()
+        if pos is None:
+            pos = self._pos
+        if pos < 0:
+            pos += len(self)
+        if not 0 <= pos <= len(self):
+            raise ValueError("Invalid insert position.")
+        self._insert(bs, pos)
+        self._pos = pos + len(bs)
+
+    def replace(self, old: BitsType, new: BitsType, start: Optional[int] = None, end: Optional[int] = None,
+                count: Optional[int] = None, bytealigned: Optional[bool] = None) -> int:
+        """Replace all occurrences of old with new in place.
+
+        Returns number of replacements made.
+
+        old -- The bitstring to replace.
+        new -- The replacement bitstring.
+        start -- Any occurrences that start before this will not be replaced.
+                 Defaults to 0.
+        end -- Any occurrences that finish after this will not be replaced.
+               Defaults to len(self).
+        count -- The maximum number of replacements to make. Defaults to
+                 replace all occurrences.
+        bytealigned -- If True replacements will only be made on byte
+                       boundaries.
+
+        Raises ValueError if old is empty or if start or end are
+        out of range.
+
+        """
+        if count == 0:
+            return 0
+        if len(old := Bits._create_from_bitstype(old)) == 0:
+            raise ValueError("Empty bitstring cannot be replaced.")
+        start, end = self._validate_slice(start, end)
+        new = Bits._create_from_bitstype(new)
+        if new is self:
+            # Prevent self assignment woes
+            new = copy.copy(self)
+        length_before = len(self)
+        replacement_count = self._replace(old, new, start, end, 0 if count is None else count, bytealigned)
+        if len(self) != length_before:
+            self._pos = 0
         return replacement_count
```

### Comparing `bitstring-4.2.1/bitstring/bitstring_options.py` & `bitstring-4.2.2/bitstring/bitstring_options.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,94 +1,94 @@
-from __future__ import annotations
-
-import bitstring
-import os
-
-class Options:
-    """Internal class to create singleton module options instance."""
-
-    _instance = None
-
-    def __init__(self):
-        self.set_lsb0(False)
-        self._bytealigned = False
-        self.mxfp_overflow = 'saturate'
-
-        self.no_color = False
-        no_color = os.getenv('NO_COLOR')
-        self.no_color = True if no_color else False
-
-    @property
-    def mxfp_overflow(self) -> str:
-        return self._mxfp_overflow
-
-    @mxfp_overflow.setter
-    def mxfp_overflow(self, value: str) -> None:
-        allowed_values = ('saturate', 'overflow')
-        if value not in allowed_values:
-            raise ValueError(f"mxfp_overflow must be one of {allowed_values}, not {value}.")
-        self._mxfp_overflow = value
-
-    def __repr__(self) -> str:
-        attributes = {attr: getattr(self, attr) for attr in dir(self) if not attr.startswith('_') and not callable(getattr(self, attr))}
-        return '\n'.join(f"{attr}: {value!r}" for attr, value in attributes.items())
-
-    @property
-    def lsb0(self) -> bool:
-        return self._lsb0
-
-    @lsb0.setter
-    def lsb0(self, value: bool) -> None:
-        self.set_lsb0(value)
-
-    def set_lsb0(self, value: bool) -> None:
-        self._lsb0 = bool(value)
-        Bits = bitstring.bits.Bits
-        BitArray = bitstring.bitarray_.BitArray
-        BitStore = bitstring.bitstore.BitStore
-
-        lsb0_methods = {
-            Bits: {'_find': Bits._find_lsb0, '_rfind': Bits._rfind_lsb0, '_findall': Bits._findall_lsb0},
-            BitArray: {'_ror': BitArray._rol_msb0, '_rol': BitArray._ror_msb0, '_append': BitArray._append_lsb0,
-                       '_prepend': BitArray._append_msb0},
-            BitStore: {'__setitem__': BitStore.setitem_lsb0, '__delitem__': BitStore.delitem_lsb0,
-                       'getindex': BitStore.getindex_lsb0, 'getslice': BitStore.getslice_lsb0,
-                       'getslice_withstep': BitStore.getslice_withstep_lsb0, 'invert': BitStore.invert_lsb0}
-        }
-        msb0_methods = {
-            Bits: {'_find': Bits._find_msb0, '_rfind': Bits._rfind_msb0, '_findall': Bits._findall_msb0},
-            BitArray: {'_ror': BitArray._ror_msb0, '_rol': BitArray._rol_msb0, '_append': BitArray._append_msb0,
-                       '_prepend': BitArray._append_lsb0},
-            BitStore: {'__setitem__': BitStore.setitem_msb0, '__delitem__': BitStore.delitem_msb0,
-                       'getindex': BitStore.getindex_msb0, 'getslice': BitStore.getslice_msb0,
-                       'getslice_withstep': BitStore.getslice_withstep_msb0, 'invert': BitStore.invert_msb0}
-        }
-        methods = lsb0_methods if self._lsb0 else msb0_methods
-        for cls, method_dict in methods.items():
-            for attr, method in method_dict.items():
-                setattr(cls, attr, method)
-
-    @property
-    def bytealigned(self) -> bool:
-        return self._bytealigned
-
-    @bytealigned.setter
-    def bytealigned(self, value: bool) -> None:
-        self._bytealigned = bool(value)
-
-    def __new__(cls):
-        if cls._instance is None:
-            cls._instance = super(Options, cls).__new__(cls)
-        return cls._instance
-
-
-class Colour:
-    def __new__(cls, use_colour: bool) -> Colour:
-        x = super().__new__(cls)
-        if use_colour:
-            cls.blue = '\033[34m'
-            cls.purple = '\033[35m'
-            cls.green = '\033[32m'
-            cls.off = '\033[0m'
-        else:
-            cls.blue = cls.purple = cls.green = cls.off = ''
+from __future__ import annotations
+
+import bitstring
+import os
+
+class Options:
+    """Internal class to create singleton module options instance."""
+
+    _instance = None
+
+    def __init__(self):
+        self.set_lsb0(False)
+        self._bytealigned = False
+        self.mxfp_overflow = 'saturate'
+
+        self.no_color = False
+        no_color = os.getenv('NO_COLOR')
+        self.no_color = True if no_color else False
+
+    @property
+    def mxfp_overflow(self) -> str:
+        return self._mxfp_overflow
+
+    @mxfp_overflow.setter
+    def mxfp_overflow(self, value: str) -> None:
+        allowed_values = ('saturate', 'overflow')
+        if value not in allowed_values:
+            raise ValueError(f"mxfp_overflow must be one of {allowed_values}, not {value}.")
+        self._mxfp_overflow = value
+
+    def __repr__(self) -> str:
+        attributes = {attr: getattr(self, attr) for attr in dir(self) if not attr.startswith('_') and not callable(getattr(self, attr))}
+        return '\n'.join(f"{attr}: {value!r}" for attr, value in attributes.items())
+
+    @property
+    def lsb0(self) -> bool:
+        return self._lsb0
+
+    @lsb0.setter
+    def lsb0(self, value: bool) -> None:
+        self.set_lsb0(value)
+
+    def set_lsb0(self, value: bool) -> None:
+        self._lsb0 = bool(value)
+        Bits = bitstring.bits.Bits
+        BitArray = bitstring.bitarray_.BitArray
+        BitStore = bitstring.bitstore.BitStore
+
+        lsb0_methods = {
+            Bits: {'_find': Bits._find_lsb0, '_rfind': Bits._rfind_lsb0, '_findall': Bits._findall_lsb0},
+            BitArray: {'_ror': BitArray._rol_msb0, '_rol': BitArray._ror_msb0, '_append': BitArray._append_lsb0,
+                       '_prepend': BitArray._append_msb0},
+            BitStore: {'__setitem__': BitStore.setitem_lsb0, '__delitem__': BitStore.delitem_lsb0,
+                       'getindex': BitStore.getindex_lsb0, 'getslice': BitStore.getslice_lsb0,
+                       'getslice_withstep': BitStore.getslice_withstep_lsb0, 'invert': BitStore.invert_lsb0}
+        }
+        msb0_methods = {
+            Bits: {'_find': Bits._find_msb0, '_rfind': Bits._rfind_msb0, '_findall': Bits._findall_msb0},
+            BitArray: {'_ror': BitArray._ror_msb0, '_rol': BitArray._rol_msb0, '_append': BitArray._append_msb0,
+                       '_prepend': BitArray._append_lsb0},
+            BitStore: {'__setitem__': BitStore.setitem_msb0, '__delitem__': BitStore.delitem_msb0,
+                       'getindex': BitStore.getindex_msb0, 'getslice': BitStore.getslice_msb0,
+                       'getslice_withstep': BitStore.getslice_withstep_msb0, 'invert': BitStore.invert_msb0}
+        }
+        methods = lsb0_methods if self._lsb0 else msb0_methods
+        for cls, method_dict in methods.items():
+            for attr, method in method_dict.items():
+                setattr(cls, attr, method)
+
+    @property
+    def bytealigned(self) -> bool:
+        return self._bytealigned
+
+    @bytealigned.setter
+    def bytealigned(self, value: bool) -> None:
+        self._bytealigned = bool(value)
+
+    def __new__(cls):
+        if cls._instance is None:
+            cls._instance = super(Options, cls).__new__(cls)
+        return cls._instance
+
+
+class Colour:
+    def __new__(cls, use_colour: bool) -> Colour:
+        x = super().__new__(cls)
+        if use_colour:
+            cls.blue = '\033[34m'
+            cls.purple = '\033[35m'
+            cls.green = '\033[32m'
+            cls.off = '\033[0m'
+        else:
+            cls.blue = cls.purple = cls.green = cls.off = ''
         return x
```

### Comparing `bitstring-4.2.1/bitstring/dtypes.py` & `bitstring-4.2.2/bitstring/dtypes.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,400 +1,404 @@
-from __future__ import annotations
-
-import functools
-from typing import Optional, Dict, Any, Union, Tuple, Callable
-import inspect
-import bitstring
-from bitstring import utils
-
-CACHE_SIZE = 256
-
-
-def scaled_get_fn(get_fn, s: Union[int, float]):
-    def wrapper(*args, scale=s, **kwargs):
-        return get_fn(*args, **kwargs) * scale
-    return wrapper
-
-
-def scaled_set_fn(set_fn, s: Union[int, float]):
-    def wrapper(bs, value, *args, scale=s, **kwargs):
-        return set_fn(bs, value / scale, *args, **kwargs)
-    return wrapper
-
-
-def scaled_read_fn(read_fn, s: Union[int, float]):
-    def wrapper(*args, scale=s, **kwargs):
-        val = read_fn(*args, **kwargs)
-        if isinstance(val, tuple):
-            val, pos = val
-            return val * scale, pos
-        return val * scale
-    return wrapper
-
-
-class Dtype:
-    """A data type class, representing a concrete interpretation of binary data.
-
-    Dtype instances are immutable. They are often created implicitly elsewhere via a token string.
-
-    >>> u12 = Dtype('uint', 12)  # length separate from token string.
-    >>> float16 = Dtype('float16')  # length part of token string.
-    >>> mxfp = Dtype('e3m2mxfp', scale=2 ** 6)  # dtype with scaling factor
-
-    """
-
-    _name: str
-    _read_fn: Callable
-    _set_fn: Callable
-    _get_fn: Callable
-    _return_type: Any
-    _is_signed: bool
-    _set_fn_needs_length: bool
-    _variable_length: bool
-    _bitlength: Optional[int]
-    _bits_per_item: int
-    _length: Optional[int]
-    _scale: Union[None, float, int]
-
-
-    def __new__(cls, token: Union[str, Dtype], /, length: Optional[int] = None, scale: Union[None, float, int] = None) -> Dtype:
-        if isinstance(token, cls):
-            return token
-        if length is None:
-            x = cls._new_from_token(token, scale)
-            return x
-        else:
-            x = dtype_register.get_dtype(token, length, scale)
-            return x
-
-    @property
-    def scale(self) -> Union[int, float, None]:
-        """The multiplicative scale applied when interpreting the data."""
-        return self._scale
-
-    @property
-    def name(self) -> str:
-        """A string giving the name of the data type."""
-        return self._name
-
-    @property
-    def length(self) -> int:
-        """The length of the data type in units of bits_per_item. Set to None for variable length dtypes."""
-        return self._length
-
-    @property
-    def bitlength(self) -> Optional[int]:
-        """The number of bits needed to represent a single instance of the data type. Set to None for variable length dtypes."""
-        return self._bitlength
-
-    @property
-    def bits_per_item(self) -> int:
-        """The number of bits for each unit of length. Usually 1, but equals 8 for bytes type."""
-        return self._bits_per_item
-
-    @property
-    def variable_length(self) -> bool:
-        """If True then the length of the data type depends on the data being interpreted, and must not be specified."""
-        return self._variable_length
-
-    @property
-    def return_type(self) -> Any:
-        """The type of the value returned by the parse method, such as int, float or str."""
-        return self._return_type
-
-    @property
-    def is_signed(self) -> bool:
-        """If True then the data type represents a signed quantity."""
-        return self._is_signed
-
-    @property
-    def set_fn(self) -> Optional[Callable]:
-        """A function to set the value of the data type."""
-        return self._set_fn
-
-    @property
-    def get_fn(self) -> Callable:
-        """A function to get the value of the data type."""
-        return self._get_fn
-
-    @property
-    def read_fn(self) -> Callable:
-        """A function to read the value of the data type."""
-        return self._read_fn
-
-    def _set_scale(self, value: Union[None, float, int]) -> None:
-        self._scale = value
-        if self._scale is None:
-            return
-        if self._scale == 0:
-            raise ValueError("A Dtype's scale factor must not be zero.")
-        if not hasattr(self, 'unscaled_get_fn'):
-            self.unscaled_get_fn = self._get_fn
-            self.unscaled_set_fn = self._set_fn
-            self.unscaled_read_fn = self._read_fn
-        self._get_fn = scaled_get_fn(self.unscaled_get_fn, self._scale)
-        self._set_fn = scaled_set_fn(self.unscaled_set_fn, self._scale)
-        self._read_fn = scaled_read_fn(self.unscaled_read_fn, self._scale)
-
-    @classmethod
-    @functools.lru_cache(CACHE_SIZE)
-    def _new_from_token(cls, token: str, scale: Union[None, float, int] = None) -> Dtype:
-        token = ''.join(token.split())
-        return dtype_register.get_dtype(*utils.parse_name_length_token(token), scale=scale)
-
-    def __hash__(self) -> int:
-        return hash((self._name, self._length))
-
-    @classmethod
-    @functools.lru_cache(CACHE_SIZE)
-    def _create(cls, definition: DtypeDefinition, length: Optional[int], scale: Union[None, float, int]) -> Dtype:
-        x = super().__new__(cls)
-        x._name = definition.name
-        x._bitlength = x._length = length
-        x._bits_per_item = definition.multiplier
-        if x._bitlength is not None:
-            x._bitlength *= x._bits_per_item
-        x._set_fn_needs_length = definition.set_fn_needs_length
-        x._variable_length = definition.variable_length
-        if x._variable_length or dtype_register.names[x._name].allowed_lengths.only_one_value():
-            x._read_fn = definition.read_fn
-        else:
-            x._read_fn = functools.partial(definition.read_fn, length=x._bitlength)
-        if definition.set_fn is None:
-            x._set_fn = None
-        else:
-            if x._set_fn_needs_length:
-                x._set_fn = functools.partial(definition.set_fn, length=x._bitlength)
-            else:
-                x._set_fn = definition.set_fn
-        x._get_fn = definition.get_fn
-        x._return_type = definition.return_type
-        x._is_signed = definition.is_signed
-        x._set_scale(scale)
-        return x
-
-    def build(self, value: Any, /) -> bitstring.Bits:
-        """Create a bitstring from a value.
-
-        The value parameter should be of a type appropriate to the dtype.
-        """
-        b = bitstring.Bits()
-        self._set_fn(b, value)
-        return b
-
-    def parse(self, b: BitsType, /) -> Any:
-        """Parse a bitstring to find its value.
-
-        The b parameter should be a bitstring of the appropriate length, or an object that can be converted to a bitstring."""
-        b = bitstring.Bits._create_from_bitstype(b)
-        return self._get_fn(bitstring.Bits(b))
-
-    def __str__(self) -> str:
-        if self._scale is not None:
-            return self.__repr__()
-        hide_length = self._variable_length or dtype_register.names[self._name].allowed_lengths.only_one_value() or self._length is None
-        length_str = '' if hide_length else str(self._length)
-        return f"{self._name}{length_str}"
-
-    def __repr__(self) -> str:
-        hide_length = self._variable_length or dtype_register.names[self._name].allowed_lengths.only_one_value() or self._length is None
-        length_str = '' if hide_length else ', ' + str(self._length)
-        if self._scale is None:
-            scale_str = ''
-        else:
-            try:
-                # This will only succeed for powers of two from -127 to 127.
-                e8m0 = bitstring.Bits(e8m0mxfp=self._scale)
-            except ValueError:
-                scale_str = f', scale={self._scale}'
-            else:
-                power_of_two = e8m0.uint - 127
-                if power_of_two in [0, 1]:
-                    scale_str = f', scale={self._scale}'
-                else:
-                    scale_str = f', scale=2 ** {power_of_two}'
-        return f"{self.__class__.__name__}('{self._name}'{length_str}{scale_str})"
-
-    def __eq__(self, other: Any) -> bool:
-        if isinstance(other, Dtype):
-            return self._name == other._name and self._length == other._length
-        return False
-
-
-class AllowedLengths:
-    def __init__(self, value: Tuple[int, ...] = tuple()) -> None:
-        if len(value) >= 3 and value[-1] is Ellipsis:
-            step = value[1] - value[0]
-            for i in range(1, len(value) - 1):
-                if value[i] - value[i - 1] != step:
-                    raise ValueError(f"Allowed length tuples must be equally spaced when final element is Ellipsis, but got {value}.")
-            self.values = (value[0], value[1], Ellipsis)
-        else:
-            self.values = value
-
-    def __str__(self) -> str:
-        if self.values and self.values[-1] is Ellipsis:
-            return f"({self.values[0]}, {self.values[1]}, ...)"
-        return str(self.values)
-
-    def __contains__(self, other: Any) -> bool:
-        if not self.values:
-            return True
-        if self.values[-1] is Ellipsis:
-            return (other - self.values[0]) % (self.values[1] - self.values[0]) == 0
-        return other in self.values
-
-    def only_one_value(self) -> bool:
-        return self.values and len(self.values) == 1
-
-
-class DtypeDefinition:
-    """Represents a class of dtypes, such as uint or float, rather than a concrete dtype such as uint8.
-    Not (yet) part of the public interface."""
-
-    def __init__(self, name: str, set_fn, get_fn, return_type: Any = Any, is_signed: bool = False, bitlength2chars_fn = None,
-                 variable_length: bool = False, allowed_lengths: Tuple[int, ...] = tuple(), multiplier: int = 1, description: str = ''):
-
-        # Consistency checks
-        if int(multiplier) != multiplier or multiplier <= 0:
-            raise ValueError("multiplier must be an positive integer")
-        if variable_length and allowed_lengths:
-            raise ValueError("A variable length dtype can't have allowed lengths.")
-        if variable_length and set_fn is not None and 'length' in inspect.signature(set_fn).parameters:
-            raise ValueError("A variable length dtype can't have a set_fn which takes a length.")
-
-        self.name = name
-        self.description = description
-        self.return_type = return_type
-        self.is_signed = is_signed
-        self.variable_length = variable_length
-        self.allowed_lengths = AllowedLengths(allowed_lengths)
-
-        self.multiplier = multiplier
-
-        # Can work out if set_fn needs length based on its signature.
-        self.set_fn_needs_length = set_fn is not None and 'length' in inspect.signature(set_fn).parameters
-        self.set_fn = set_fn
-
-        if self.allowed_lengths:
-            def allowed_length_checked_get_fn(bs):
-                if len(bs) not in self.allowed_lengths:
-                    if self.allowed_lengths.only_one_value():
-                        raise bitstring.InterpretError(f"'{self.name}' dtypes must have a length of {self.allowed_lengths.values[0]}, but received a length of {len(bs)}.")
-                    else:
-                        raise bitstring.InterpretError(f"'{self.name}' dtypes must have a length in {self.allowed_lengths}, but received a length of {len(bs)}.")
-                return get_fn(bs)
-            self.get_fn = allowed_length_checked_get_fn  # Interpret everything and check the length
-        else:
-            self.get_fn = get_fn  # Interpret everything
-
-        # Create a reading function from the get_fn.
-        if not self.variable_length:
-            if self.allowed_lengths.only_one_value():
-                def read_fn(bs, start):
-                    return self.get_fn(bs[start:start + self.allowed_lengths.values[0]])
-            else:
-                def read_fn(bs, start, length):
-                    return self.get_fn(bs[start:start + length])
-            self.read_fn = read_fn
-        else:
-            # We only find out the length when we read/get.
-            def length_checked_get_fn(bs):
-                x, length = get_fn(bs)
-                if length != len(bs):
-                    raise ValueError
-                return x
-            self.get_fn = length_checked_get_fn
-
-            def read_fn(bs, start):
-                try:
-                    x, length = get_fn(bs[start:])
-                except bitstring.InterpretError:
-                    raise bitstring.ReadError
-                return x, start + length
-            self.read_fn = read_fn
-        self.bitlength2chars_fn = bitlength2chars_fn
-
-    def get_dtype(self, length: Optional[int] = None, scale: Union[None, float, int] = None) -> Dtype:
-        if self.allowed_lengths:
-            if length is None:
-                if self.allowed_lengths.only_one_value():
-                    length = self.allowed_lengths.values[0]
-            else:
-                if length not in self.allowed_lengths:
-                    if self.allowed_lengths.only_one_value():
-                        raise ValueError(f"A length of {length} was supplied for the '{self.name}' dtype, but its only allowed length is {self.allowed_lengths.values[0]}.")
-                    else:
-                        raise ValueError(f"A length of {length} was supplied for the '{self.name}' dtype which is not one of its possible lengths (must be one of {self.allowed_lengths}).")
-        if length is None:
-            d = Dtype._create(self, None, scale)
-            return d
-        if self.variable_length:
-            raise ValueError(f"A length ({length}) shouldn't be supplied for the variable length dtype '{self.name}'.")
-        d = Dtype._create(self, length, scale)
-        return d
-
-    def __repr__(self) -> str:
-        s = f"{self.__class__.__name__}(name='{self.name}', description='{self.description}', return_type={self.return_type.__name__}, "
-        s += f"is_signed={self.is_signed}, set_fn_needs_length={self.set_fn_needs_length}, allowed_lengths={self.allowed_lengths!s}, multiplier={self.multiplier})"
-        return s
-
-
-class Register:
-    """A singleton class that holds all the DtypeDefinitions. Not (yet) part of the public interface."""
-
-    _instance: Optional[Register] = None
-    names: Dict[str, DtypeDefinition] = {}
-
-    def __new__(cls) -> Register:
-        # Singleton. Only one Register instance can ever exist.
-        if cls._instance is None:
-            cls._instance = super(Register, cls).__new__(cls)
-        return cls._instance
-
-    @classmethod
-    def add_dtype(cls, definition: DtypeDefinition):
-        cls.names[definition.name] = definition
-        if definition.get_fn is not None:
-            setattr(bitstring.bits.Bits, definition.name, property(fget=definition.get_fn, doc=f"The bitstring as {definition.description}. Read only."))
-        if definition.set_fn is not None:
-            setattr(bitstring.bitarray_.BitArray, definition.name, property(fget=definition.get_fn, fset=definition.set_fn, doc=f"The bitstring as {definition.description}. Read and write."))
-
-    @classmethod
-    def add_dtype_alias(cls, name: str, alias: str):
-        cls.names[alias] = cls.names[name]
-        definition = cls.names[alias]
-        if definition.get_fn is not None:
-            setattr(bitstring.bits.Bits, alias, property(fget=definition.get_fn, doc=f"An alias for '{name}'. Read only."))
-        if definition.set_fn is not None:
-            setattr(bitstring.bitarray_.BitArray, alias, property(fget=definition.get_fn, fset=definition.set_fn, doc=f"An alias for '{name}'. Read and write."))
-
-    @classmethod
-    def get_dtype(cls, name: str, length: Optional[int], scale: Union[None, float, int] = None) -> Dtype:
-        try:
-            definition = cls.names[name]
-        except KeyError:
-            raise ValueError(f"Unknown Dtype name '{name}'. Names available: {list(cls.names.keys())}.")
-        else:
-            return definition.get_dtype(length, scale)
-
-    @classmethod
-    def __getitem__(cls, name: str) -> DtypeDefinition:
-        return cls.names[name]
-
-    @classmethod
-    def __delitem__(cls, name: str) -> None:
-        del cls.names[name]
-
-    def __repr__(self) -> str:
-        s = [f"{'key':<12}:{'name':^12}{'signed':^8}{'set_fn_needs_length':^23}{'allowed_lengths':^16}{'multiplier':^12}{'return_type':<13}"]
-        s.append('-' * 85)
-        for key in self.names:
-            m = self.names[key]
-            allowed = '' if not m.allowed_lengths else m.allowed_lengths
-            ret = 'None' if m.return_type is None else m.return_type.__name__
-            s.append(f"{key:<12}:{m.name:>12}{m.is_signed:^8}{m.set_fn_needs_length:^16}{allowed!s:^16}{m.multiplier:^12}{ret:<13} # {m.description}")
-        return '\n'.join(s)
-
-
-# Create the Register singleton
+from __future__ import annotations
+
+import functools
+from typing import Optional, Dict, Any, Union, Tuple, Callable
+import inspect
+import bitstring
+from bitstring import utils
+
+CACHE_SIZE = 256
+
+
+def scaled_get_fn(get_fn, s: Union[int, float]):
+    def wrapper(*args, scale=s, **kwargs):
+        return get_fn(*args, **kwargs) * scale
+    return wrapper
+
+
+def scaled_set_fn(set_fn, s: Union[int, float]):
+    def wrapper(bs, value, *args, scale=s, **kwargs):
+        return set_fn(bs, value / scale, *args, **kwargs)
+    return wrapper
+
+
+def scaled_read_fn(read_fn, s: Union[int, float]):
+    def wrapper(*args, scale=s, **kwargs):
+        val = read_fn(*args, **kwargs)
+        if isinstance(val, tuple):
+            val, pos = val
+            return val * scale, pos
+        return val * scale
+    return wrapper
+
+
+class Dtype:
+    """A data type class, representing a concrete interpretation of binary data.
+
+    Dtype instances are immutable. They are often created implicitly elsewhere via a token string.
+
+    >>> u12 = Dtype('uint', 12)  # length separate from token string.
+    >>> float16 = Dtype('float16')  # length part of token string.
+    >>> mxfp = Dtype('e3m2mxfp', scale=2 ** 6)  # dtype with scaling factor
+
+    """
+
+    _name: str
+    _read_fn: Callable
+    _set_fn: Callable
+    _get_fn: Callable
+    _return_type: Any
+    _is_signed: bool
+    _set_fn_needs_length: bool
+    _variable_length: bool
+    _bitlength: Optional[int]
+    _bits_per_item: int
+    _length: Optional[int]
+    _scale: Union[None, float, int]
+
+
+    def __new__(cls, token: Union[str, Dtype], /, length: Optional[int] = None, scale: Union[None, float, int] = None) -> Dtype:
+        if isinstance(token, cls):
+            return token
+        if length is None:
+            x = cls._new_from_token(token, scale)
+            return x
+        else:
+            x = dtype_register.get_dtype(token, length, scale)
+            return x
+
+    @property
+    def scale(self) -> Union[int, float, None]:
+        """The multiplicative scale applied when interpreting the data."""
+        return self._scale
+
+    @property
+    def name(self) -> str:
+        """A string giving the name of the data type."""
+        return self._name
+
+    @property
+    def length(self) -> int:
+        """The length of the data type in units of bits_per_item. Set to None for variable length dtypes."""
+        return self._length
+
+    @property
+    def bitlength(self) -> Optional[int]:
+        """The number of bits needed to represent a single instance of the data type. Set to None for variable length dtypes."""
+        return self._bitlength
+
+    @property
+    def bits_per_item(self) -> int:
+        """The number of bits for each unit of length. Usually 1, but equals 8 for bytes type."""
+        return self._bits_per_item
+
+    @property
+    def variable_length(self) -> bool:
+        """If True then the length of the data type depends on the data being interpreted, and must not be specified."""
+        return self._variable_length
+
+    @property
+    def return_type(self) -> Any:
+        """The type of the value returned by the parse method, such as int, float or str."""
+        return self._return_type
+
+    @property
+    def is_signed(self) -> bool:
+        """If True then the data type represents a signed quantity."""
+        return self._is_signed
+
+    @property
+    def set_fn(self) -> Optional[Callable]:
+        """A function to set the value of the data type."""
+        return self._set_fn
+
+    @property
+    def get_fn(self) -> Callable:
+        """A function to get the value of the data type."""
+        return self._get_fn
+
+    @property
+    def read_fn(self) -> Callable:
+        """A function to read the value of the data type."""
+        return self._read_fn
+
+    def _set_scale(self, value: Union[None, float, int]) -> None:
+        self._scale = value
+        if self._scale is None:
+            return
+        if self._scale == 0:
+            raise ValueError("A Dtype's scale factor must not be zero.")
+        if not hasattr(self, 'unscaled_get_fn'):
+            self.unscaled_get_fn = self._get_fn
+            self.unscaled_set_fn = self._set_fn
+            self.unscaled_read_fn = self._read_fn
+        self._get_fn = scaled_get_fn(self.unscaled_get_fn, self._scale)
+        self._set_fn = scaled_set_fn(self.unscaled_set_fn, self._scale)
+        self._read_fn = scaled_read_fn(self.unscaled_read_fn, self._scale)
+
+    @classmethod
+    @functools.lru_cache(CACHE_SIZE)
+    def _new_from_token(cls, token: str, scale: Union[None, float, int] = None) -> Dtype:
+        token = ''.join(token.split())
+        return dtype_register.get_dtype(*utils.parse_name_length_token(token), scale=scale)
+
+    def __hash__(self) -> int:
+        return hash((self._name, self._length))
+
+    @classmethod
+    @functools.lru_cache(CACHE_SIZE)
+    def _create(cls, definition: DtypeDefinition, length: Optional[int], scale: Union[None, float, int]) -> Dtype:
+        x = super().__new__(cls)
+        x._name = definition.name
+        x._bitlength = x._length = length
+        x._bits_per_item = definition.multiplier
+        if x._bitlength is not None:
+            x._bitlength *= x._bits_per_item
+        x._set_fn_needs_length = definition.set_fn_needs_length
+        x._variable_length = definition.variable_length
+        if x._variable_length or dtype_register.names[x._name].allowed_lengths.only_one_value():
+            x._read_fn = definition.read_fn
+        else:
+            x._read_fn = functools.partial(definition.read_fn, length=x._bitlength)
+        if definition.set_fn is None:
+            x._set_fn = None
+        else:
+            if x._set_fn_needs_length:
+                x._set_fn = functools.partial(definition.set_fn, length=x._bitlength)
+            else:
+                x._set_fn = definition.set_fn
+        x._get_fn = definition.get_fn
+        x._return_type = definition.return_type
+        x._is_signed = definition.is_signed
+        x._set_scale(scale)
+        return x
+
+    def build(self, value: Any, /) -> bitstring.Bits:
+        """Create a bitstring from a value.
+
+        The value parameter should be of a type appropriate to the dtype.
+        """
+        b = bitstring.Bits()
+        self._set_fn(b, value)
+        if self.bitlength is not None and len(b) != self.bitlength:
+            raise ValueError(f"Dtype has a length of {self.bitlength} bits, but value '{value}' has {len(b)} bits.")
+        return b
+
+    def parse(self, b: BitsType, /) -> Any:
+        """Parse a bitstring to find its value.
+
+        The b parameter should be a bitstring of the appropriate length, or an object that can be converted to a bitstring."""
+        b = bitstring.Bits._create_from_bitstype(b)
+        return self._get_fn(bitstring.Bits(b))
+
+    def __str__(self) -> str:
+        if self._scale is not None:
+            return self.__repr__()
+        hide_length = self._variable_length or dtype_register.names[self._name].allowed_lengths.only_one_value() or self._length is None
+        length_str = '' if hide_length else str(self._length)
+        return f"{self._name}{length_str}"
+
+    def __repr__(self) -> str:
+        hide_length = self._variable_length or dtype_register.names[self._name].allowed_lengths.only_one_value() or self._length is None
+        length_str = '' if hide_length else ', ' + str(self._length)
+        if self._scale is None:
+            scale_str = ''
+        else:
+            try:
+                # This will only succeed for powers of two from -127 to 127.
+                e8m0 = bitstring.Bits(e8m0mxfp=self._scale)
+            except ValueError:
+                scale_str = f', scale={self._scale}'
+            else:
+                power_of_two = e8m0.uint - 127
+                if power_of_two in [0, 1]:
+                    scale_str = f', scale={self._scale}'
+                else:
+                    scale_str = f', scale=2 ** {power_of_two}'
+        return f"{self.__class__.__name__}('{self._name}'{length_str}{scale_str})"
+
+    def __eq__(self, other: Any) -> bool:
+        if isinstance(other, Dtype):
+            return self._name == other._name and self._length == other._length
+        return False
+
+
+class AllowedLengths:
+    def __init__(self, value: Tuple[int, ...] = tuple()) -> None:
+        if len(value) >= 3 and value[-1] is Ellipsis:
+            step = value[1] - value[0]
+            for i in range(1, len(value) - 1):
+                if value[i] - value[i - 1] != step:
+                    raise ValueError(f"Allowed length tuples must be equally spaced when final element is Ellipsis, but got {value}.")
+            self.values = (value[0], value[1], Ellipsis)
+        else:
+            self.values = value
+
+    def __str__(self) -> str:
+        if self.values and self.values[-1] is Ellipsis:
+            return f"({self.values[0]}, {self.values[1]}, ...)"
+        return str(self.values)
+
+    def __contains__(self, other: Any) -> bool:
+        if not self.values:
+            return True
+        if self.values[-1] is Ellipsis:
+            return (other - self.values[0]) % (self.values[1] - self.values[0]) == 0
+        return other in self.values
+
+    def only_one_value(self) -> bool:
+        return self.values and len(self.values) == 1
+
+
+class DtypeDefinition:
+    """Represents a class of dtypes, such as uint or float, rather than a concrete dtype such as uint8.
+    Not (yet) part of the public interface."""
+
+    def __init__(self, name: str, set_fn, get_fn, return_type: Any = Any, is_signed: bool = False, bitlength2chars_fn = None,
+                 variable_length: bool = False, allowed_lengths: Tuple[int, ...] = tuple(), multiplier: int = 1, description: str = ''):
+
+        # Consistency checks
+        if int(multiplier) != multiplier or multiplier <= 0:
+            raise ValueError("multiplier must be an positive integer")
+        if variable_length and allowed_lengths:
+            raise ValueError("A variable length dtype can't have allowed lengths.")
+        if variable_length and set_fn is not None and 'length' in inspect.signature(set_fn).parameters:
+            raise ValueError("A variable length dtype can't have a set_fn which takes a length.")
+
+        self.name = name
+        self.description = description
+        self.return_type = return_type
+        self.is_signed = is_signed
+        self.variable_length = variable_length
+        self.allowed_lengths = AllowedLengths(allowed_lengths)
+
+        self.multiplier = multiplier
+
+        # Can work out if set_fn needs length based on its signature.
+        self.set_fn_needs_length = set_fn is not None and 'length' in inspect.signature(set_fn).parameters
+        self.set_fn = set_fn
+
+        if self.allowed_lengths:
+            def allowed_length_checked_get_fn(bs):
+                if len(bs) not in self.allowed_lengths:
+                    if self.allowed_lengths.only_one_value():
+                        raise bitstring.InterpretError(f"'{self.name}' dtypes must have a length of {self.allowed_lengths.values[0]}, but received a length of {len(bs)}.")
+                    else:
+                        raise bitstring.InterpretError(f"'{self.name}' dtypes must have a length in {self.allowed_lengths}, but received a length of {len(bs)}.")
+                return get_fn(bs)
+            self.get_fn = allowed_length_checked_get_fn  # Interpret everything and check the length
+        else:
+            self.get_fn = get_fn  # Interpret everything
+
+        # Create a reading function from the get_fn.
+        if not self.variable_length:
+            if self.allowed_lengths.only_one_value():
+                def read_fn(bs, start):
+                    return self.get_fn(bs[start:start + self.allowed_lengths.values[0]])
+            else:
+                def read_fn(bs, start, length):
+                    if len(bs) < start + length:
+                        raise bitstring.ReadError(f"Needed a length of at least {length} bits, but only {len(bs) - start} bits were available.")
+                    return self.get_fn(bs[start:start + length])
+            self.read_fn = read_fn
+        else:
+            # We only find out the length when we read/get.
+            def length_checked_get_fn(bs):
+                x, length = get_fn(bs)
+                if length != len(bs):
+                    raise ValueError
+                return x
+            self.get_fn = length_checked_get_fn
+
+            def read_fn(bs, start):
+                try:
+                    x, length = get_fn(bs[start:])
+                except bitstring.InterpretError:
+                    raise bitstring.ReadError
+                return x, start + length
+            self.read_fn = read_fn
+        self.bitlength2chars_fn = bitlength2chars_fn
+
+    def get_dtype(self, length: Optional[int] = None, scale: Union[None, float, int] = None) -> Dtype:
+        if self.allowed_lengths:
+            if length is None:
+                if self.allowed_lengths.only_one_value():
+                    length = self.allowed_lengths.values[0]
+            else:
+                if length not in self.allowed_lengths:
+                    if self.allowed_lengths.only_one_value():
+                        raise ValueError(f"A length of {length} was supplied for the '{self.name}' dtype, but its only allowed length is {self.allowed_lengths.values[0]}.")
+                    else:
+                        raise ValueError(f"A length of {length} was supplied for the '{self.name}' dtype which is not one of its possible lengths (must be one of {self.allowed_lengths}).")
+        if length is None:
+            d = Dtype._create(self, None, scale)
+            return d
+        if self.variable_length:
+            raise ValueError(f"A length ({length}) shouldn't be supplied for the variable length dtype '{self.name}'.")
+        d = Dtype._create(self, length, scale)
+        return d
+
+    def __repr__(self) -> str:
+        s = f"{self.__class__.__name__}(name='{self.name}', description='{self.description}', return_type={self.return_type.__name__}, "
+        s += f"is_signed={self.is_signed}, set_fn_needs_length={self.set_fn_needs_length}, allowed_lengths={self.allowed_lengths!s}, multiplier={self.multiplier})"
+        return s
+
+
+class Register:
+    """A singleton class that holds all the DtypeDefinitions. Not (yet) part of the public interface."""
+
+    _instance: Optional[Register] = None
+    names: Dict[str, DtypeDefinition] = {}
+
+    def __new__(cls) -> Register:
+        # Singleton. Only one Register instance can ever exist.
+        if cls._instance is None:
+            cls._instance = super(Register, cls).__new__(cls)
+        return cls._instance
+
+    @classmethod
+    def add_dtype(cls, definition: DtypeDefinition):
+        cls.names[definition.name] = definition
+        if definition.get_fn is not None:
+            setattr(bitstring.bits.Bits, definition.name, property(fget=definition.get_fn, doc=f"The bitstring as {definition.description}. Read only."))
+        if definition.set_fn is not None:
+            setattr(bitstring.bitarray_.BitArray, definition.name, property(fget=definition.get_fn, fset=definition.set_fn, doc=f"The bitstring as {definition.description}. Read and write."))
+
+    @classmethod
+    def add_dtype_alias(cls, name: str, alias: str):
+        cls.names[alias] = cls.names[name]
+        definition = cls.names[alias]
+        if definition.get_fn is not None:
+            setattr(bitstring.bits.Bits, alias, property(fget=definition.get_fn, doc=f"An alias for '{name}'. Read only."))
+        if definition.set_fn is not None:
+            setattr(bitstring.bitarray_.BitArray, alias, property(fget=definition.get_fn, fset=definition.set_fn, doc=f"An alias for '{name}'. Read and write."))
+
+    @classmethod
+    def get_dtype(cls, name: str, length: Optional[int], scale: Union[None, float, int] = None) -> Dtype:
+        try:
+            definition = cls.names[name]
+        except KeyError:
+            raise ValueError(f"Unknown Dtype name '{name}'. Names available: {list(cls.names.keys())}.")
+        else:
+            return definition.get_dtype(length, scale)
+
+    @classmethod
+    def __getitem__(cls, name: str) -> DtypeDefinition:
+        return cls.names[name]
+
+    @classmethod
+    def __delitem__(cls, name: str) -> None:
+        del cls.names[name]
+
+    def __repr__(self) -> str:
+        s = [f"{'key':<12}:{'name':^12}{'signed':^8}{'set_fn_needs_length':^23}{'allowed_lengths':^16}{'multiplier':^12}{'return_type':<13}"]
+        s.append('-' * 85)
+        for key in self.names:
+            m = self.names[key]
+            allowed = '' if not m.allowed_lengths else m.allowed_lengths
+            ret = 'None' if m.return_type is None else m.return_type.__name__
+            s.append(f"{key:<12}:{m.name:>12}{m.is_signed:^8}{m.set_fn_needs_length:^16}{allowed!s:^16}{m.multiplier:^12}{ret:<13} # {m.description}")
+        return '\n'.join(s)
+
+
+# Create the Register singleton
 dtype_register = Register()
```

### Comparing `bitstring-4.2.1/bitstring/exceptions.py` & `bitstring-4.2.2/bitstring/exceptions.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-
-class Error(Exception):
-    """Base class for errors in the bitstring module."""
-
-    def __init__(self, *params: object) -> None:
-        self.msg = params[0] if params else ''
-        self.params = params[1:]
-
-
-class ReadError(Error, IndexError):
-    """Reading or peeking past the end of a bitstring."""
-
-
-InterpretError = ValueError
-"""Inappropriate interpretation of binary data."""
-
-
-class ByteAlignError(Error):
-    """Whole-byte position or length needed."""
-
-
-CreationError = ValueError
-"""Inappropriate argument during bitstring creation."""
-
+
+class Error(Exception):
+    """Base class for errors in the bitstring module."""
+
+    def __init__(self, *params: object) -> None:
+        self.msg = params[0] if params else ''
+        self.params = params[1:]
+
+
+class ReadError(Error, IndexError):
+    """Reading or peeking past the end of a bitstring."""
+
+
+InterpretError = ValueError
+"""Inappropriate interpretation of binary data."""
+
+
+class ByteAlignError(Error):
+    """Whole-byte position or length needed."""
+
+
+CreationError = ValueError
+"""Inappropriate argument during bitstring creation."""
+
```

### Comparing `bitstring-4.2.1/bitstring/luts.py` & `bitstring-4.2.2/bitstring/luts.py`

 * *Ordering differences only*

 * *Files 6% similar despite different names*

```diff
@@ -1,248 +1,248 @@
-#
-# This file is generated by generate_luts.py. DO NOT EDIT.
-#
-
-mxfp_luts_compressed = \
-{(2, 1, 1, 'saturate'): (b'x\x01\x1d\xc9\xc1\r\xc00\x00\xc2@o\xd6\x8c\xc6f\xf5h\xb1\x828\xf1\x00^>X\x0c\xa7f1,\x7f'
-                         b'\x13\x83\xfdY\xf4\x027\xf1\x0c\xfb',
-                         b'x\x01\xed\xdd\t\r\xc0\x00\x08\x04A\xfa\xa7\xbf\x7f\xb5\xad\r\x92\x9bU\x00#\x00\xaaD\x80\x00'
-                         b'\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
-                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @'
-                         b'\x80@[\x81A\x04\x08\x10 \x90(0\x8a@\xb2\xc0\xa4d\x81Y\xd9\x02\x8b\x92\x05Ve\x0bl"@\x80'
-                         b'\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10'
-                         b' @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
-                         b'@\x80\x00\x01\x02\r\x05>\x11 \x90*\xd0\xf6.\x99\xc1\x08\x10 @\x80\x00\x01\x02\x04\x08\x10'
-                         b' @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
-                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10\xa8\xdaE\x80\x00\x01\x02'
-                         b'\x89\x02\x87\x08$\x0b\x9cJ\x16\xb8\x94-p+Y\xe0Q\xb6\xc0+\x02\x04\x08\x10 @\x80\x00'
-                         b'\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
-                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04'
-                         b'\x08\x10 \xd0P \xf5\xf1\xb9\xbd\t\x10\xf8~uJ\x98\xcc'),
- (2, 3, 1, 'saturate'): (b'x\x01\x1d\xcdQ\r\xc30\x10\x03\xd0\x830\x08\x85P\x04[ \x14B \x0cB \x04B \x14\xc1v\x10'
-                         b'\x02!\x10\x02aO\xb3\xf4\xe4?;\xe2\x9fgD#\x89W\xc4A\xa1\xd2\xe8\x0cn\x92\xc9b\x13%\xe2\xc1'
-                         b'\xc1I\xe1\xa2\xf2\xa6\xd1\x19\xdc$\x93\xc5&\x1a\x1fE\x12_[\x14*\x8d\xce\xe0&\x99,6\x91\xfe98'
-                         b')\\T\xde4:\x83\x9bd\xb2\xd8\xf9\x03~S=\xdd',
-                         b'x\x01\xed\xdd\x85q\x03\x01\x0cE\xc1\x0b8\xcc\xcc\x9e0sb;\xdc\x7fUN\x15\x9e?7\xdaW\x81\xb4'
-                         b'\x05HM#\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @'
-                         b'\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04Z#0&\x02'
-                         b'\x04\x08\x10\xa8(0.\x02\x95\x05&TY`RY\x81N\xed\xa6\xaa7]\xbb\x99\xb67\x9bm.\xdd|'
-                         b'\xb6\x85t\x8b\xd9\x96\xd2-g[I\xb7\x9am-\xddz\xb6\x8dt\x9b\xd9\xb6\xd2mg\xdbI\xb7\x9bm/'
-                         b'\xdd~\xb6\x83t\x87\xd9\x8e\xd2uE\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
-                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @'
-                         b'\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x81\x11\t\x0cE\x80@U\x81\xd6\xdc)5(\x01\x02\x04'
-                         b'\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00'
-                         b'\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02Ms,\x02\x04\x08\x10\xa8'
-                         b'(p"\x02\x95\x05NUY\xe0LY\x81\xf3\xda]T\xef\xb2vWm\xef:\xdbM\xba\xdblw\xe9\xee\xb3=\xa4{'
-                         b'\xcc\xf6\x94\xee9\xdbK\xba\xd7lo\xe9\xde\xb3\xf5\xd2\xf5\xb3\r\xd2}d\xfbL\xf7\x95\xed;'
-                         b'\xddO\xb6\xdft\x7f"@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00'
-                         b'\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
-                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\xc0\x88\x04\xaa>>\xb77\x01\x02\xc3\x7f3K\xcb\x81'),
- (3, 2, 3, 'saturate'): (b'x\x01\x15\xcbA\x15BQ\x08\x05@\xa2XD\xc5&/\nQ(\xa2\xf2\x9b\x10\xc5\x91\xc3\xc0\xe2B\xc4\xbf'
-                         b'\xean<"\x92\xa2\x19\x96xF\xdcH\x0eE3,\x91r\x92C\xd1\x0cK\xbc\xe4$\x87\xa2\x19\x96(\xfd'
-                         b'\xb6?n(\x9aa\x89\xaf\x7f\x92C\xd1\x0cK\x8c\x9c\xe4P4\xc3\x12\x97\x9c\xe4P4\xc3^?\xc7\x8a;c',
-                         b"x\x01\xed\xdd\xd7Q\x15\x00\x10@\xd1'H\x16D\xa2H\x1a\t\x92\xa3\xe4\xa0\xfdW\xf5h\x81"
-                         b'?\x86\xb9\xe7V\xb0{\n\xd8\x1d\x0cD\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10'
-                         b' @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08|:'
-                         b'\x81/"@\x80\x00\x81\xa2\xc0\x88\x08\x94\x05FU\x16\xf8\xaa\x8f\x15\x18k7^o\xa2\xddd'
-                         b'\xbd\xa9v\xd3\xf5f\xda}\xab7\xdbn\xae\xde\xf7v\xf3\xf5~\xb4[\xa8\xb7\xd8n\xa9\xder'
-                         b'\xbb\x95z\xab\xed~\xd6[k\xf7\xab\xdez\xbb\x8dz\x9b\xed\xb6\xeam\x8b\x00\x01\x02\x04\x08\x10'
-                         b' @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
-                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\xde%0\x14\x01\x02U\x81Ow\xaf\xd8\xc0'
-                         b'\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80'
-                         b'\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\xc0`\xf0[\x04\x08\x10 P\x14'
-                         b'\xd8\x11\x81\xb2\xc0\xae\xca\x02{\xfaX\x81\xfdv\x7f\xea\x1d\xb4;\xacw\xd4\xee\xb8'
-                         b'\xdeI\xbb\xd3zg\xed\xce\xeb]\xb4\xbb\xacw\xd5\xee\xba\xde\xdfv7\xf5n\xdb\xdd\xd5\xbbo'
-                         b'\xf7P\xef\xb1\xddS\xbd\xe7v/\xf5^\xdb\xfd\xab\xf7_\x04\x08\x10 @\x80\x00\x01\x02\x04\x08'
-                         b'\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01'
-                         b'\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 \xf0.\x81\xea\xe3s{\x13 0|\x03\xb3O;\x10'),
- (4, 3, 7, 'saturate'): (b'x\x01\x1d\xcd[\xb5\x90!\x10\x80Q"\x18\x81\x08\xbc{C-@\x04"\xd0\xe0\x10\x81\x08D\xe0\xdd\x1bj'
-                         b'\x01"\x10\xe1o\xa0\xfb\xc8Z{\xcd\xbc|C\x08\xff\xdf\xdb\x10:\x9b\xf0.\x84H\xa6\xd2\x19'
-                         b'L\x16\x9b\xc3\xe5!\xbc\x0f\xe1\r\x91D\xa6Pit\x06\x93\xc5\xe6py\x08\x1f\xf4D\x12\x99'
-                         b'B\xa5\xd1\x19L\x16\x9b\xc3\xe5!|\xd4\x13Id\n\x95Fg0Yl\x0e\x97\x87\x90\xf5D\x12\x99B\xa5'
-                         b'\xd1\x19L\x16\x9b\xc3\xe5!|\xd2\x13Id\n\x95Fg0Yl\x0e\x97\x87\xf0YO$\x91)T\x1a\x9d\xc1d\xb19'
-                         b'\\\x1e\xc2\x17=\x91D\xa6Pit\x06\x93\xc5\xe6p_\xf7\x17}\xe7\xab\xc1&|s\x8bL\xa53\x98,'
-                         b'6\x87\xcbC\xf8\xee\x7f"\x89L\xa1\xd2\xe8\x0c&\x8b\xcd\xe1\xf2\x10~\xe8\x89$2\x85J\xa33\x98,6'
-                         b"\x87\xcbC\xf8\xa9'\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0fa\xeb\x89$2\x85J\xa33\x98,6\x87\xcb"
-                         b'C\xf8\xa5\'\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0f\xe1\xb7\x9eH"S\xa84:\x83\xc9bs\xb8<\x84'
-                         b'?z"\x89L\xa1\xd2\xe8\x0c&\x8b\xcd\xe1\xbe\xee\x7f\xff\x01!\xba\xf7\x9b',
-                         b'x\x01\xed\xdde\xb6\x96\x05\x00E\xe1\x0f\x01iD\xba\x11\xe9\x90n\x90\x12\xa4\xbb\xbb[\xbaA'
-                         b'X\x8bF\xa5\x94\x94\xee\xee.iP:\x94\x96FA\xe9N\xbd\xfc`\x10{]\xde\xfd\xcc\xe0\xec\t\x9cP'
-                         b'H\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\xc0\x07['
-                         b' \x82,`\x01\x0bX \x88\x05>\x92\x05\x82\\ \xa2\x82\\ \x92\xd8\x02\x91\x83\xed\xe3\xa0'
-                         b'\x8b\x12lQ\xc3\xbbh\xac\xe8\xb4\x18\xac\x98\xb4X\xac\xd8\xb4OXqh\x9f\xb2\xe2\xd2\xe2\xb1'
-                         b'\xe2\xd3\x12\xb0\x12\xd2\x12\xb1\x12\xd3\x92\xb0\x92\xd2\x92\xb1\x92\xd3R\xb0R\xd2R\xb1'
-                         b'>\xa3\xa5f}NK\xc3JKK\xc7JO\xcb\xc0\xcaH\xcb\xc4\xcaL\xcb\xc2\xcaJ\xfb\x82\x95\x8d\x96\x9d'
-                         b'\x95\x83\x96\x93\x95\x8b\x96\x9b\x95\x87\x96\x97\x95\x8f\x96\x9fU\x80V\x90U\x88V\x98'
-                         b'U\x84\xf6%\xab(\xad\x18\xab8\xad\x04\xab$\xed+V)Zi\xd6\xd7\xb42\xac\xb2\xb4r\xac\xf2\xb4\n'
-                         b'\xac\x8a\xb4J\xac\xca\xb4*\xac\xaa\xb4j\xac\xea\xb4\x1a\xac\x9a\xb4Z\xac\xda\xb4:'
-                         b'\xac\xba\xb4z\xac\xfa\xb4\x06\xac\x86\xb4F\xac\xc6\xb4&\xac\xa6\xb4f\xac\xe6\xb4\x16'
-                         b'\xac\x96\xb4V\xac\xd6\xb46\xac\xb6\xb4v\xac\xf6\xb4\x0e\xacoh\x1dY\x9dh\x9dY]h]Y\xddh\xdd'
-                         b'Y=h=Y\xbdh\xbdY}h}Y\xfdh\xfdY\xdf\xd2\x06\xb0\x06\xca\x02\x16\xb0\x80\x05,`\x01\x0b'
-                         b'X\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80'
-                         b'\x05\xde\x17\x08\x93\x05,\x10\xd4\x02\x1f\xec\xaf\x99\xc3,`\x01\x0bX\xc0\x02\x16\xb0'
-                         b'\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x81Ph\x90,`\x01\x0bX \x88\x05\x06\xcb\x02A.'
-                         b'0DA.0Tl\x81a\xc16<\xe8F\x04\xdb\xc8\xf0\xee;\xd6\xf7\xb4\x1fX\xa3h\xa3YchcY\xe3h?'
-                         b'\xb2~\xa2\x8dgM\xa0MdM\xa2MfM\xa1\xfd\xcc\x9aJ\x9b\xc6\x9aN\x9b\xc1\x9aI\x9b\xc5\x9aM\x9b'
-                         b'\xc3\x9aK\x9b\xc7\x9aO[\xc0ZH[\xc4ZL[\xc2ZJ[\xc6ZN[\xc1ZI[\xc5ZM[\xc3ZK[\xc7ZO\xdb'
-                         b'\xc0\xdaH\xdb\xc4\xdaL\xdb\xc2\xdaJ\xdb\xc6\xdaN\xfb\x85\xb5\x83\xb6\x93\xb5\x8b\xb6'
-                         b'\x9b\xb5\x87\xb6\x97\xb5\x8f\xb6\x9fu\x80\xf6+\xeb7\xdaA\xd6!\xdaa\xd6\x11\xdaQ\xd61\xda'
-                         b'q\xd6\t\xdaI\xd6)\xda\xef\xac?h\xa7YghgY\xe7h\xe7Y\x17h\x17Y\x7f\xd2.\xb1.\xd3'
-                         b'\xae\xb0\xae\xd2\xae\xb1\xae\xd3n\xb0n\xd2\xfeb\xfdM\xbb\xc5\xbaM\xfb\x87\xf5/\xed\x0e\xeb.'
-                         b'\xed\x1e\xeb>\xed\x01\xeb!\xed\x11\xeb1\xed\t\xeb)\xed\x19\xeb9\xed\x05\xeb%\xed\x15\xeb5'
-                         b'\xed\r\xeb-\xed?\xd6\xff\xb2\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0'
-                         b'\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x81\xf7\x05\x82z|\xeen\x0bX'
-                         b' \xec\x1d\xdd\xb0\xc7z'),
- (5, 2, 15, 'saturate'): (b'x\x01M\xcb\xd9\x11\x10T\x0c@\xd1\x94B\x17 \x08\x06Dh#\x9d\x90R\xd2\x05\xca\x1a\x17'
-                          b'\xa0\x8dt\x02\xc7\x1f\xc7\xcc\x9c\xf7\xf1n\x12\xf1\xef\xf4C\xcf\xa3\x88\xa4\x19\x96#~\x8ax@'
-                          b"R4\xc3r\xc4c\x9d\xa4h\x86\xe5\x88':I\xd1\x0c\xcb\x11?\xeb$E3,G<\xd5I\x8afX\x8ex\xa6\x93"
-                          b'\x14\xcd\xb0\x1c\xf1\x8bNR4\xc3rD\xea$E3,G<\xd7I\x8afX\x8ex\xa1\x93\x14\xcd\xb0\x1c'
-                          b'\xf1\xabNR4\xc3r\xc4K\x9d\xa4h\x86\xe5\x88\xdft\x92\xa2\x19\x96#^\xe9$E3,G\xbc\xd6I'
-                          b'\x8a~\xa3\xfdO\xb4\xbf\xb7\xf6~\xb7C3,G\xfc\xe1\x9e\xa4h\x86\xe5\x88w:I\xd1\x0c'
-                          b'\xcb\x11\xefu\x92\xa2\x19\x96#>\xe8$E3,G|\xd4I\x8afX\x8e\xf8\xa4\x93\x14\xcd\xb0\x1c\xf1Y'
-                          b"')\x9aa9bu\x92\xa2\x19\x96#\xfe\xd4I\x8afX\x8e\xf8K')\x9aa9\xe2o\x9d\xa4h\x86\xe5\x88\x7ft"
-                          b'\x92\xa2\x19\x96#\xbe\xe8$E3,G|\xd5I\x8afX\x8e\xf8\xa6\x93\x14\xfd]\xfb\xcf\x0f'
-                          b'\xd2\x15\xf0\xcf',
-                          b"x\x01\xed\xddC\x82\x1d\x00\x00D\xc1\x89m\xdb\xb6m\xdb\xb6m'\xab\xd8\xb6m\xdb\xb6m\xdb"
-                          b'v\xb2H\x8e1\x8b\xfau\x83~\x17\xe8\xa0\xa0`\x16\xc2\x16R\x17\xca\x16Z\x17\xc6\x16V\x17'
-                          b'\xce\x16^\x17\xc1\x16Q\x17\xc9\x16Y\x17\xc5\x16U\x17\xcd\x16]\x17\xc3\x16S\x17\xcb\x16[\x17'
-                          b'\xc7\x16W\x17\xcf\x16_\x97\xc0\x96P\x97\xc8\x96X\x97\xc4\x96T\x97\xcc\x96\\\x97'
-                          b'\xc2\x96R\x97\xca\x96Z\x97\xc6\x96V\x97\xce\x96^\x97\xc1\x96Q\x97\xc9\x96Y\x97\xc5\x96U\x97'
-                          b'\xcd\x96]\x97\xc3\x96S\x97\xcb\x96[\x97\xc7\x96W\x97\xcf\x96_W\xc0VPW\xc8VXW\xc4VTW\xccV\\W'
-                          b'\xc2VRW\xcaVZW\xc6VVW\xceV^W\xc1VQW\xc9VYW\xc5VUW\xcdV]W\xc3VSW\xcbV[W\xc7VWW\xcfV_\xd7'
-                          b'\xc0\xd6P\xd7\xc8\xd6X\xd7\xc4\xd6T\xd7\xcc\xd6\\\xd7\xc2\xd6R\xd7\xca\xd6Z\xd7'
-                          b'\xc6\xd6V\xd7\xce\xd6^\xd7\xc1\xd6Q\xd7\xc9\xd6Y\xd7\xc5\xd6U\xd7\xcd\xd6]\xd7\xc3\xd6S\xd7'
-                          b'\xcb\xd6[\xd7\xc7\xd6W\xd7\xcf\xd6_7\xc06P7( X\x0b\xfc\x0b\x08\x14\x08\x14P\x0b'
-                          b'\x04\x05\xb7\xc1\xb6!\xba\xa1\xb6a\xba\xe1\xb6\x11\xba\x91\xb6Q\xba\xd1\xb61\xba\xb1'
-                          b'\xb6q\xba\xf1\xb6\t\xba\x89\xb6I\xba\xc9\xb6)\xba\xa9\xb6i\xba\xe9\xb6\x19\xba\x99'
-                          b'\xb6Y\xba\xd9\xb69\xba\xb9\xb6y\xba\xf9\xb6\x05\xba\x85\xb6E\xba\xc5\xb6%\xba\xa5'
-                          b'\xb6e\xba\xe5\xb6\x15\xba\x95\xb6U\xba\xd5\xb65\xba\xb5\xb6u\xba\xf5\xb6\r\xba\x8d'
-                          b'\xb6M\xba\xcd\xb6-\xba\xad\xb6m\xba\xed\xb6\x1d\xba\x9d\xb6]\xba\xdd\xb6=\xba\xbd'
-                          b'\xb6}\xba\xfd\xb6\x03\xba\x83\xb6C\xba\xc3\xb6#\xba\xa3\xb6c\xba\xe3\xb6\x13\xba\x93'
-                          b'\xb6S\xba\xd3\xb63\xba\xb3\xb6s\xba\xf3\xb6\x0b\xba\x8b\xb6K\xba\xcb\xb6+\xba\xab'
-                          b'\xb6k\xba\xeb\xb6\x1b\xba\x9b\xb6[\xba\xdb\xb6;\xba\xbb\xb6{\xba\xfb\xb6\x07\xba\x87'
-                          b"\xb6G\xba\xc7\xb6'\xba\xa7\xb6g\xba\xe7\xb6\x17\xba\x97\xb6W\xba\xd7\xb67\xba\xb7"
-                          b'\xb6w\xba\xf7\xb6\x0f\xba\x8f\xb6O\xba\xcf\xb6/\xba\xaf\xb6o\xba\xef\xb6\x1f\xba\x9f'
-                          b'\xb6_\xba\xdf\xb6?\xba\xbf\x01\xc1Z@=>\x0f\xec\x0e\x14\x08\x14\xf8\xf7\x1f$\x1d\xcd\x0c'),
- (4, 3, 7, 'overflow'): (b'x\x01\x1d\xcd[\xb5\x90!\x10\x80Q"\x18\x81\x08\xbc{C-@\x04"\xd0\xe0\x10\x81\x08D\xe0\xdd\x1bj'
-                         b'\x01"\x10\xe1o\xa0\xfb\xc8Z{\xcd\xbc|C\x08\xff\xdf\xdb\x10:\x9b\xf0.\x84H\xa6\xd2\x19'
-                         b'L\x16\x9b\xc3\xe5!\xbc\x0f\xe1\r\x91D\xa6Pit\x06\x93\xc5\xe6py\x08\x1f\xf4D\x12\x99'
-                         b'B\xa5\xd1\x19L\x16\x9b\xc3\xe5!|\xd4\x13Id\n\x95Fg0Yl\x0e\x97\x87\x90\xf5D\x12\x99B\xa5'
-                         b'\xd1\x19L\x16\x9b\xc3\xe5!|\xd2\x13Id\n\x95Fg0Yl\x0e\x97\x87\xf0YO$\x91)T\x1a\x9d\xc1d\xb19'
-                         b'\\\x1e\xc2\x17=\x91D\xa6Pit\x06\x93\xc5\xe6p_\xf7\x17}\xe7\xab\xc1&|s\x8bL\xa53\x98,'
-                         b'6\x87\xcbC\xf8\xee\x7f"\x89L\xa1\xd2\xe8\x0c&\x8b\xcd\xe1\xf2\x10~\xe8\x89$2\x85J\xa33\x98,6'
-                         b"\x87\xcbC\xf8\xa9'\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0fa\xeb\x89$2\x85J\xa33\x98,6\x87\xcb"
-                         b'C\xf8\xa5\'\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0f\xe1\xb7\x9eH"S\xa84:\x83\xc9bs\xb8<\x84'
-                         b'?z"\x89L\xa1\xd2\xe8\x0c&\x8b\xcd\xe1\xbe\xee\x7f\xff\x01!\xba\xf7\x9b',
-                         b'x\x01\xed\xdd\x85\xb2\x90\x05\x10@\xe1K\x87t\x83\x94tI\x83\xd2\x1d\xd2\xd2 \xdd\x8dt3C\xa74*'
-                         b'\xdd\x12\x06\x9d"JwHwww\xc3\xe51\xce\\\xfe\xf3\xbd\xc0\xce\x9e\x07\xd8\r\t\x91\x05,`\x01\x0b'
-                         b"X\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,\xf0\xd9\x16\x08'\x0bX\xc0\x02"
-                         b'\x16\x08b\x81\xf0\xb2@\x90\x0bDP\x90\x0bD\x14[ R\xb0E\x0e\xba(\xc1\x165\xac\x8b\xc6\x8aN\xfb'
-                         b'\x82\x15\x83\x16\x93\x15\x8b\x16\x9b\x15\x87\x16\x97\x15\x8f\x16\x9f\x95\x80\x96'
-                         b'\x90\x95\x88\x96\x98\x95\x84\x96\x94\x95\x8c\xf6%+9-\x05+%-\x15+5\xed+V\x1aZZV:ZzV\x06ZFV&Z'
-                         b'fV\x16ZVV6\xda\xd7\xac\xec\xb4\x1c\xac\x9c\xb4\\\xac\xdc\xb4<\xac\xbc\xb4|\xac\xfc\xb4'
-                         b'oX\xdf\xd2\n\xb0\n\xd2\n\xb1\n\xd3\x8a\xb0\x8a\xd2\x8a\xb1\x8a\xd3J\xb0J\xd2J\xb1J\xd3'
-                         b'\xca\xb0\xca\xd2\xca\xb1\xca\xd3\xbecU\xa0UdU\xa2UfU\xa1UeU\xa3}\xcf\xaaN\xab\xc1\xaaI'
-                         b'\xab\xc5\xaaM\xab\xc3\xaaK\xab\xc7\xaaO\xfb\x81\xd5\x80\xd6\x90\xd5\x88\xd6\x98\xd5\x84'
-                         b'\xd6\x94\xd5\x8c\xd6\x9c\xd5\x82\xd6\x92\xd5\x8a\xd6\x9a\xd5\x86\xd6\x96\xd5\x8e'
-                         b"\xd6\x9e\xd5\x81\xd6\x91\xd5\x89\xd6\x99\xf5#\xad\x0b\xab+\xad\x1b\xab;\xad\x07\xab'"
-                         b'\xad\x17\xab7\xad\x0f\xab/\xad\x1f\xab?m\x00k -T\x16\xb0\x80\x05,`\x01\x0bX\xc0'
-                         b'\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,'
-                         b'`\x01\x0bX\x80-\xf0\xd9\xfe5s1\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16'
-                         b'\xb0\x80\x05,`\x01\x0bX $d\x90,`\x01\x0bX \x88\x05\x06\xcb\x02A.0DA.0Tl\x81a\xc16<\xe8F\x04'
-                         b"\xdb\xc8\xb0n\x14k4m\x0ck,\xed'\xd68\xdax\xd6\x04\xdaD\xd6$\xdad\xd6\x14\xdaT\xd6\xcf\xb4"
-                         b'_X\xbf\xd2\xa6\xb1\xa6\xd3f\xb0f\xd2f\xb1f\xd3\xe6\xb0\xe6\xd2\xe6\xb1\xe6\xd3'
-                         b"\x16\xb0\x16\xd2\x16\xb1~\xa3-f-\xa1-e-\xa3\xfd\xce\xfa\x83\xf6'\xeb/\xdar\xd6\n\xdaJ\xd6*"
-                         b'\xdaj\xd6\x1a\xdaZ\xd6:\xdaz\xd6\x06\xdaF\xd6&\xda\xdf\xac\xcd\xb4\x7fX[h\xff\xb2\xfe\xa3mem'
-                         b'\xa3mg\xed\xa0\xedd\xed\xa2\xedf\xed\xa1\xede\xed\xa3\xedg\x1d\xa0\x1dd\x1d\xa2\x1df\x1d'
-                         b'\xa1\xfd\xcf:J;\xc6:N;\xc1:I;\xc5:M;\xc3:K;\xc7:O\xbb\xc0\xbaH\xbb\xc4\xbaL\xbb\xc2\xba'
-                         b'J\xbb\xc6\xbaN\xbb\xc1\xbaI\xbb\xc5\xbaM\xbb\xc3\xbaK\xbb\xc7\xbaO{\xc0zH{\xc4zL{\xc2z'
-                         b'J{\xc6zN{\xc1zI{\xc5zM{\xc3zK{\xc7zO\xfb\xc0\xfaHc\xcf\xf7;\xdd\x02\x16\xb0\x80\x05,'
-                         b'`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02'
-                         b'\x16\xb0\x80\x05,`\x01\x0b\x84~\x02\x87va\xdb'),
- (5, 2, 15, 'overflow'): (b'x\x01M\xcb\xd9\x11\x10T\x0c@\xd1\x94B\x17 \x08\x06Dh#\x9d\x90R\xd2\x05\xca\x1a\x17'
-                          b'\xa0\x8dt\x02\xc7\x1f\xc7\xcc\x9c\xf7\xf1n\x12\xf1\xef\xf4C\xcf\xa3\x88\xa4\x19\x96#~\x8ax@'
-                          b"R4\xc3r\xc4c\x9d\xa4h\x86\xe5\x88':I\xd1\x0c\xcb\x11?\xeb$E3,G<\xd5I\x8afX\x8ex\xa6\x93"
-                          b'\x14\xcd\xb0\x1c\xf1\x8bNR4\xc3rD\xea$E3,G<\xd7I\x8afX\x8ex\xa1\x93\x14\xcd\xb0\x1c'
-                          b'\xf1\xabNR4\xc3r\xc4K\x9d\xa4h\x86\xe5\x88\xdft\x92\xa2\x19\x96#^\xe9$E3,G\xbc\xd6I'
-                          b'\x8a~\xa3\xfdO\xb4\xbf\xb7\xf6~\xb7C3,G\xfc\xe1\x9e\xa4h\x86\xe5\x88w:I\xd1\x0c'
-                          b'\xcb\x11\xefu\x92\xa2\x19\x96#>\xe8$E3,G|\xd4I\x8afX\x8e\xf8\xa4\x93\x14\xcd\xb0\x1c\xf1Y'
-                          b"')\x9aa9bu\x92\xa2\x19\x96#\xfe\xd4I\x8afX\x8e\xf8K')\x9aa9\xe2o\x9d\xa4h\x86\xe5\x88\x7ft"
-                          b'\x92\xa2\x19\x96#\xbe\xe8$E3,G|\xd5I\x8afX\x8e\xf8\xa6\x93\x14\xfd]\xfb\xcf\x0f'
-                          b'\xd2\x15\xf0\xcf',
-                          b'x\x01\xed\xddS\xd6\x1d\x06\x00\x85\xd1?\xb6m[\r\x1a\xdb\xb6\xd94nl\xbe\xc4\xb6m\xdb'
-                          b'v\xd2\xd8n\xd0\xd8\xb6\xd6J\x86q\x1f\xf6\xdd38\xdf\x04NHH\x80\x85\xb2\x85\xd6\x85\xb1'
-                          b'\x85\xd5\x85\xb3\x85\xd7E\xb0E\xd4E\xb2E\xd6E\xb1E\xd5E\xb3E\xd7\xc5\xb0\xc5\xd4\xc5\xb2'
-                          b'\xc5\xd6\xc5\xb1\xc5\xd5\xc5\xb3\xc5\xd7%\xb0%\xd4%\xb2%\xd6%\xb1%\xd5%\xb3%\xd7\xa5\xb0'
-                          b'\xa5\xd4\xa5\xb2\xa5\xd6\xa5\xb1\xa5\xd5\xa5\xb3\xa5\xd7e\xb0e\xd4e\xb2e\xd6e\xb1e\xd5e\xb3'
-                          b'e\xd7\xe5\xb0\xfd\xa1\xcbi\xcb\xa5\xcbm\xcb\xa3\xfb\xd3\x96W\x97\xcf\x96_W\xc0VPW\xc8'
-                          b'VXW\xc4VTW\xccV\\W\xc2VRW\xcaVZW\xc6VVW\xceV^W\xc1VQW\xc9VYW\xc5VUW\xcdV]W\xc3VSW\xcb'
-                          b'V[W\xc7VWW\xcfV_\xd7\xc0\xd6P\xd7\xc8\xd6X\xd7\xc4\xd6T\xd7\xcc\xf6\x97\xae\xb9\xedo]\x0b'
-                          b'[K]+[k]\x1b[[];\xdb?\xba\xf6\xb6\x0e\xba\x8e\xb6N\xba\xce\xb6.\xba\xae\xb6n\xba\xee'
-                          b'\xb6\x1e\xba\x9e\xb6^\xba\xde\xb6>\xba\xbe\xb6~\xba\xfe\xb6\x01\x81\xf6+(X X@-\x10'
-                          b'\x12h\x03m\x83t\x83mCtCm\xc3t\xc3m#t#m\xa3t\xa3mctcm\xe3t\xe3m\x13t\x13m\x93t\x93mStSm'
-                          b'\xd3t\xd3m3t3m\xb3t\xb3mstsm\xf3t\xf3m\x0bt\x0bm\x8bt\x8bmKtKm\xcbt\xcbm+t+m\xabt\xabmktkm'
-                          b'\xebt\xebm\x1bt\x1bm\x9bt\x9bm[t[m\xdbt\xdbm;t;m\xbbt\xbbm{t{m\xfbt\xfbm\x07t\x07m'
-                          b'\x87t\x87mGtGm\xff\xea\x8e\xd9\x8e\xebN\xd8N\xeaN\xd9N\xeb\xce\xd8\xce\xea\xce\xd9'
-                          b'\xce\xeb.\xd8.\xea.\xd9.\xeb\xae\xd8\xae\xea\xae\xd9\xae\xebn\xd8\xfe\xd3\xdd\xb4'
-                          b'\xdd\xd2\xdd\xb6\xdd\xd1\xfdo\xbb\xab\xbbg\xbb\xaf{`{\xa8{d{\xac{b{\xaa{f{\xae{a{\xa9{e'
-                          b'{\xad{c{\xab{g{\xaf\xfb`\xfb\xa8\xfbd\xfb\xac\xfbb\xfb\xaa\xfbf\xfb\xae\xfba\xfb\x19h\xea'
-                          b'\xf1ypw\xb0@\xb0\xc0\xaf\xdf\xf0\x99\xce\x0e')}
-
-
-binary8_luts_compressed = \
-{(4, 8): (b'x\x01\x15\xcb[\xd5P!\x10\x80Q"\x18\x81\x08<{E-@\x04"\xd0@"\x10\x81\x08<{E\xff\x02\'\x02\x11h\xa0\xdbY'
-          b'k\xcf\xcb\xcc\x17\xc2\xff\xe9\xaf\xad7!d:\x93\xcd!\xbc\r\xe1\x15\x91D\xa6Pit\x06\x93\xc5\xe6\xe1p\t\xef\xf4'
-          b'D\x12\x99B\xa5\xd1\x19L\x16\x9b\x87\xc3%\xbc\xd7\x13Id\n\x95Fg0Yl\x1e\x0e\x97\xf0AO$\x91)T\x1a\x9d\xc1d\xb1'
-          b"y8\\B\xd6\x13Id\n\x95Fg0Yl\x1e\x0e\x97\xf0QO$\x91)T\x1a\x9d\xc1d\xb1y8\\\xc2'=\x91D\xa6Pit\x06\x93"
-          b'\xc5\xe6\xe1p\t\x9f\xf5D\x12\x99B\xa5\x7f\xf1O\xff\xea\xef\x9b\x1b\x9d\xc9\xe6\x10\xbe\xeb\x89$2\x85J\xa3'
-          b'3\x98,6\x0f\x87K\xf8\xa1\'\x92\xc8\x14*\x8d\xce`\xb2\xd8<\x1c.\xe1\xa7\x9eH"S\xa84:\x83\xc9b\xf3p\xb8\x84_z'
-          b'"\x89L\xa1\xd2\xe8\x0c&\x8b\xcd\xc3\xe1\x12\xb6\x9eH"S\xa84:\x83\xc9b\xf3p\xb8\x84\xdfz"\x89L\xa1\xd2\xe8'
-          b'\x0c&\x8b\xcd\xc3\xe1\x12\xfe\xe8\x89$2\x85J\xa33\x98,6\x0f\x87Kx\xd1\x13Id\n\x95\xfe\xf7\x1f[)\xf3`',
-          b'x\x01\xed\xdd\x05\xba\x96\x05\x00\x05\xe1\x9f\xee\x06\xe9FZA\xa4\xbb\xbb;\xa4SB\xba\xeb\xd2\xdd\x8dt\x97'
-          b'\x92J(\xa14\xa2\x84\x92\x8a\xa4\x82\xd2\x1d\x12.c\x9e\xcb7\xef\x0e\xcel\xe0\x84B\xb2\x80\x05,`\x01'
-          b'\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xe0\xbd/\x10A\x16\xb0\x80\x05,\x10\xc4\x02\x11e\x81 \x17\x88'
-          b'\xa4 \x17\x88,\xb6@\x94`\x8b\x1at\xd1\x82-zx\x17\x83\x15\x93\x16\x8b\x15\x9b\x16\x87\x15\x97\x16\x8f\x15'
-          b'\x9f\x96\x80\x95\x90\x96\x88\x95\x98\x96\x84\xf5\x01-)+\x19-9+\x05-%+\x15-5+\r--+\x1d-=+\x03-#+\x13\xedCV'
-          b'fZ\x16VVZ6VvZ\x0eVN\xdaG\xac\x8fi\xb9X\xb9i\x9f\xb0\xf2\xd0>e\xe5\xa5\xe5c\xe5\xa7\x15`\x15\xa4\x15b'
-          b'\x15\xa6\x15a\x15\xa5\x15c\x15\xa7\x95`\x95\xa4\x95b\x95\xa6\x95a\x95\xa5\x95c\x95\xa7U`U\xa4UbU\xa6Ua'
-          b'U\xa5UcU\xa7\xd5`\xd5\xa4\xd5b\xd5\xa6\xd5a\xd5\xa5\xd5c\xd5\xa75`5\xa45b5\xa65a}Fk\xcajFk\xcejAk\xc9'
-          b"jEk\xcdjCk\xcbjGk\xcf\xea@\xfb\x9c\xd5\x91\xd6\x89\xd5\x99\xd6\x85\xf5\x05\xad+\xab\x1b\xad;\xab\x07\xad'"
-          b'\xab\x17\xad7\xab\x0f\xad/\xab\x1f\xad?k\x00m k\x10m0k\x08m\xa8,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,'
-          b'`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x00\\'
-          b' L\x16\xb0@P\x0b\xbc\xf7\xff\x86\x0e\xb4\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX '
-          b'\x14\x1a&\x0bX\xc0\x02\x16\x08b\x81\xe1\xb2@\x90\x0b\x8cP\x90\x0b\x8c\x14[`T\xb0\x8d\x0e\xba1\xc16'
-          b'6\xbc\x1b\xc7\x1aO\x9b\xc0\x9aH\x9b\xc4\x9aL\x9b\xc2\x9aJ\x9b\xc6\x9aN\x9b\xc1\x9aI\x9b\xc5\x9aM\x9b\xc3'
-          b'\x9aK\x9b\xc7\x9aO\xfb\x92\xb5\x80\xb6\x90\xb5\x88\xb6\x98\xb5\x84\xb6\x94\xb5\x8c\xb6\x9c\xb5\x82\xb6\x92'
-          b'\xb5\x8a\xb6\x9a\xb5\x86\xb6\x96\xb5\x8e\xb6\x9e\xb5\x81\xf6\x15\xebk\xdaF\xd6&\xdaf\xd6\x16\xdaV\xd66\xda7'
-          b'\xacoi\xdbY;h;Y\xbbh\xdf\xb1\xbe\xa7\xedf\xed\xa1\xede\xed\xa3\xfd\xc0\xfa\x91\xb6\x9fu\x80v\x90u\x88v'
-          b'\x98u\x84v\x94u\x8c\xf6\x13\xeb8\xedg\xd6/\xb4\x13\xac\x93\xb4S\xac\xd3\xb4_Y\xbf\xd1\xce\xb0\xce\xd2'
-          b'\xce\xb1\xce\xd3.\xb0.\xd2~g\xfdA\xbb\xc4\xfa\x93v\x99u\x85v\x95u\x8dv\x9du\x83\xf6\x17\xebo\xdaM\xd6-'
-          b'\xda?\xac\x7fi\xb7YwhwY\xf7h\xf7Y\x0fh\x0fY\x8fh\x8fYOhOY\xcfh\xcfY/h/Y\xafh\xff\xb1^\xd3\xde\xb0\xde'
-          b'\xd2\xde\xc9\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`'
-          b'\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0b\xc0\x05\x82z|\xeen\x0bX \xec\x7f\xc6\xe4\x02%'),
- (5, 16): (b'x\x01\x1d\xc9\x89\r\x10\x04\x0c\x86\xd1\x8e\xc2\x16 \x97\x059\xd6\xe8&t\x94n\xa1\\RQ`\x8dn\x02/6yI'
-           b"\xf3\x7f\x11\xff\xdf\xc3\x88f\x89G\x11\x0fH\x8afX\x8e\xf8M')\x9aa9\xe2\xb1NR4\xc3r\xc4\x13\x9d\xa4h"
-           b'\x86\xe5\x88\xa7:I\xd1\x0c\xcb\x11\xcft\x92\xa2\x19\x96#\x9e\xeb$E3,G\xfc\xae\x93\x14\xcd\xb0\x1c\x91'
-           b":I\xd1\x0c\xcb\x11/t\x92\xa2\x19\x96#^\xea$E3,G\xfc\xa1\x93\x14\xcd\xb0\x1c\xf1J')\x9aa9\xe2\xb5NR4\xc3"
-           b'r\xc4\x1b\x9d\xa4h\x86\xe5\x88\xb7:I\xbf\xb3\x13\x7f\xfaY\xe2/\x9d\xa4h\x86\xe5\x88\xf7:I\xd1\x0c\xcb'
-           b'\x11\x1ft\x92\xa2\x19\x96#>\xea$E3,G|\xd2I\x8afX\x8e\xf8\xac\x93\x14\xcd\xb0\x1c\xf1\xb7NR4\xc3r'
-           b"\xc4\x17\x9d\xa4h\x86\xe5\x88\xd5I\x8afX\x8e\xf8G')\x9aa9\xe2\xabNR4\xc3r\xc4\xbf:I\xd1\x0c\xcb\x11"
-           b"\xff\xe9$E3,G|\xd3I\x8afX\x8e\xf8\xae\x93\x14\xcd\xb0\x1c\xf1C'\xe9\x9f\xbf\x00Gi\xed\x02",
-           b'x\x01\xed\xddU\xd6\x96\x05\x00\x85\xd1\x9f\x16\xa4\x14\x04\xe9P\xa4K\x1a\xe9\x14\x10\t\xe9\x0eQ'
-           b'\xba\xc1\xa0\xbb\xbb\xa5\x1b)%\xa5;%\xa5\xbb;%\x94\x8eAp\xf1.\xd6\xfe\xf6\x0c\xce3\x81\x13\x16\xf6'
-           b'\x8e\xc2\x05+|\xd0"\x04+b\xd0"\x05+r\xd0\xa2\x04\xeb\x83\xf7]T[4\xdd\x87\xb6\xe8\xba\x18\xb6\x98\xbaX\xb6'
-           b'\xd8\xba\x8fl\x1f\xeb\xe2\xd8\xe2\xea>\xb1\xc5\xd3\xc5\xb7}\xaaK`K\xa8KdK\xacKbK\xaaKfK\xaeKaK\xa9\xfb\xcc'
-           b'\xf6\xb9.\x95\xed\x0b]j[\x1a]Z[:]z[\x06]F[&]f[\x16]V\xdb\x97\xbal\xb6\xec\xba\x1c\xb6\x9c\xba\\'
-           b'\xb6\xdc\xba<\xb6\xbc\xba\xafl\xf9t\xf9m\x05t\x05m\x85t\x85mEtEm\xc5t\xc5m%t%m_\xebJ\xd9J\xeb\xca'
-           b'\xd8\xbe\xd1\x95\xb5}\xab+g+\xaf\xab`\xab\xa8\xfb\xceVIW\xd9VEW\xd5VMW\xddVCW\xd3VKW\xdbVGW\xd7VOW'
-           b'\xdf\xd6@\xd7\xd0\xf6\xbd\xae\x91\xed\x07\xdd\x8f\xb6\xc6\xba&\xb6\xa6\xbaf\xb6\xe6\xba\x16\xb6\x96\xba'
-           b'V\xb6\xd6\xba6\xb6\xb6\xbav\xb6\xf6\xba\x0e\xb6\x8e\xba\x9fl?\xeb~\xb1\xfd\xaa\xebd\xeb\xac\xebb\xeb\xaa'
-           b"\xeb\x16\x12h\x81\xee!\xa1\x02\xa1\x02j\x81\xb0w\xd5#X=\x83\xd6+X\xbd\x83\xd6'X}\x83\xd6/X\xfd\xdfw"
-           b'\x03l\x03u\x83l\x83uClCu\xc3l\xc3u#l#u\xa3l\xa3uclcu\xe3l\xe3u\x13l\xbf\xe9&\xda&\xe9&\xdb\xa6\xe8'
-           b'\xa6\xda\xa6\xe9\xa6\xdbf\xe8f\xdaf\xe9f\xdb\xe6\xe8\xe6\xda\xe6\xe9~\xb7\xcd\xd7-\xb0-\xd4-\xb2-\xd6'
-           b'\xfda\xfbS\xb7\xc4\xb6T\xb7\xcc\xb6\\\xb7\xc2\xb6R\xf7\x97m\x95n\xb5m\x8dn\xadm\x9dn\xbdm\x83n\xa3m\x93'
-           b'n\xb3m\x8bn\xabm\x9bn\xbbm\x87n\xa7m\x97n\xb7\xedo\xdd\x1e\xdb^\xdd>\xdb~\xdd\x01\xdbA\xdd?\xb6C'
-           b'\xba\xc3\xb6#\xba\xa3\xb6c\xba\xe3\xb6\x13\xba\x93\xb6S\xba\xd3\xb63\xba\xb3\xb6s\xba\xf3\xb6\x0b'
-           b'\xba\x8b\xb6K\xba\xcb\xb6+\xba\xab\xb6k\xba\xeb\xb6\x1b\xba\x9b\xb6[\xba\xdb\xb6;\xba\xbb\xb6{'
-           b'\xba\xfb\xb6\x7fu\x0fl\x0fu\x8fl\x8fu\xff\xd9\xfe\xd7=\xb1=\xd5=\xb3=\xd7\xbd\xb0\xbd\xd4\xbd\xb2\xbd'
-           b'\xd6\xbd\t\t\xb4\x80z|\x1e\xda\x1d*\x10*\xd0\xfd-\x8c\x93\xc6\x0e')}
+#
+# This file is generated by generate_luts.py. DO NOT EDIT.
+#
+
+mxfp_luts_compressed = \
+{(2, 1, 1, 'saturate'): (b'x\x01\x1d\xc9\xc1\r\xc00\x00\xc2@o\xd6\x8c\xc6f\xf5h\xb1\x828\xf1\x00^>X\x0c\xa7f1,\x7f'
+                         b'\x13\x83\xfdY\xf4\x027\xf1\x0c\xfb',
+                         b'x\x01\xed\xdd\t\r\xc0\x00\x08\x04A\xfa\xa7\xbf\x7f\xb5\xad\r\x92\x9bU\x00#\x00\xaaD\x80\x00'
+                         b'\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
+                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @'
+                         b'\x80@[\x81A\x04\x08\x10 \x90(0\x8a@\xb2\xc0\xa4d\x81Y\xd9\x02\x8b\x92\x05Ve\x0bl"@\x80'
+                         b'\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10'
+                         b' @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
+                         b'@\x80\x00\x01\x02\r\x05>\x11 \x90*\xd0\xf6.\x99\xc1\x08\x10 @\x80\x00\x01\x02\x04\x08\x10'
+                         b' @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
+                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10\xa8\xdaE\x80\x00\x01\x02'
+                         b'\x89\x02\x87\x08$\x0b\x9cJ\x16\xb8\x94-p+Y\xe0Q\xb6\xc0+\x02\x04\x08\x10 @\x80\x00'
+                         b'\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
+                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04'
+                         b'\x08\x10 \xd0P \xf5\xf1\xb9\xbd\t\x10\xf8~uJ\x98\xcc'),
+ (2, 3, 1, 'saturate'): (b'x\x01\x1d\xcdQ\r\xc30\x10\x03\xd0\x830\x08\x85P\x04[ \x14B \x0cB \x04B \x14\xc1v\x10'
+                         b'\x02!\x10\x02aO\xb3\xf4\xe4?;\xe2\x9fgD#\x89W\xc4A\xa1\xd2\xe8\x0cn\x92\xc9b\x13%\xe2\xc1'
+                         b'\xc1I\xe1\xa2\xf2\xa6\xd1\x19\xdc$\x93\xc5&\x1a\x1fE\x12_[\x14*\x8d\xce\xe0&\x99,6\x91\xfe98'
+                         b')\\T\xde4:\x83\x9bd\xb2\xd8\xf9\x03~S=\xdd',
+                         b'x\x01\xed\xdd\x85q\x03\x01\x0cE\xc1\x0b8\xcc\xcc\x9e0sb;\xdc\x7fUN\x15\x9e?7\xdaW\x81\xb4'
+                         b'\x05HM#\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @'
+                         b'\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04Z#0&\x02'
+                         b'\x04\x08\x10\xa8(0.\x02\x95\x05&TY`RY\x81N\xed\xa6\xaa7]\xbb\x99\xb67\x9bm.\xdd|'
+                         b'\xb6\x85t\x8b\xd9\x96\xd2-g[I\xb7\x9am-\xddz\xb6\x8dt\x9b\xd9\xb6\xd2mg\xdbI\xb7\x9bm/'
+                         b'\xdd~\xb6\x83t\x87\xd9\x8e\xd2uE\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
+                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @'
+                         b'\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x81\x11\t\x0cE\x80@U\x81\xd6\xdc)5(\x01\x02\x04'
+                         b'\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00'
+                         b'\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02Ms,\x02\x04\x08\x10\xa8'
+                         b'(p"\x02\x95\x05NUY\xe0LY\x81\xf3\xda]T\xef\xb2vWm\xef:\xdbM\xba\xdblw\xe9\xee\xb3=\xa4{'
+                         b'\xcc\xf6\x94\xee9\xdbK\xba\xd7lo\xe9\xde\xb3\xf5\xd2\xf5\xb3\r\xd2}d\xfbL\xf7\x95\xed;'
+                         b'\xddO\xb6\xdft\x7f"@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00'
+                         b'\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
+                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\xc0\x88\x04\xaa>>\xb77\x01\x02\xc3\x7f3K\xcb\x81'),
+ (3, 2, 3, 'saturate'): (b'x\x01\x15\xcbA\x15BQ\x08\x05@\xa2XD\xc5&/\nQ(\xa2\xf2\x9b\x10\xc5\x91\xc3\xc0\xe2B\xc4\xbf'
+                         b'\xean<"\x92\xa2\x19\x96xF\xdcH\x0eE3,\x91r\x92C\xd1\x0cK\xbc\xe4$\x87\xa2\x19\x96(\xfd'
+                         b'\xb6?n(\x9aa\x89\xaf\x7f\x92C\xd1\x0cK\x8c\x9c\xe4P4\xc3\x12\x97\x9c\xe4P4\xc3^?\xc7\x8a;c',
+                         b"x\x01\xed\xdd\xd7Q\x15\x00\x10@\xd1'H\x16D\xa2H\x1a\t\x92\xa3\xe4\xa0\xfdW\xf5h\x81"
+                         b'?\x86\xb9\xe7V\xb0{\n\xd8\x1d\x0cD\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10'
+                         b' @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08|:'
+                         b'\x81/"@\x80\x00\x81\xa2\xc0\x88\x08\x94\x05FU\x16\xf8\xaa\x8f\x15\x18k7^o\xa2\xddd'
+                         b'\xbd\xa9v\xd3\xf5f\xda}\xab7\xdbn\xae\xde\xf7v\xf3\xf5~\xb4[\xa8\xb7\xd8n\xa9\xder'
+                         b'\xbb\x95z\xab\xed~\xd6[k\xf7\xab\xdez\xbb\x8dz\x9b\xed\xb6\xeam\x8b\x00\x01\x02\x04\x08\x10'
+                         b' @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 '
+                         b'@\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\xde%0\x14\x01\x02U\x81Ow\xaf\xd8\xc0'
+                         b'\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80'
+                         b'\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\xc0`\xf0[\x04\x08\x10 P\x14'
+                         b'\xd8\x11\x81\xb2\xc0\xae\xca\x02{\xfaX\x81\xfdv\x7f\xea\x1d\xb4;\xacw\xd4\xee\xb8'
+                         b'\xdeI\xbb\xd3zg\xed\xce\xeb]\xb4\xbb\xacw\xd5\xee\xba\xde\xdfv7\xf5n\xdb\xdd\xd5\xbbo'
+                         b'\xf7P\xef\xb1\xddS\xbd\xe7v/\xf5^\xdb\xfd\xab\xf7_\x04\x08\x10 @\x80\x00\x01\x02\x04\x08'
+                         b'\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 @\x80\x00\x01'
+                         b'\x02\x04\x08\x10 @\x80\x00\x01\x02\x04\x08\x10 \xf0.\x81\xea\xe3s{\x13 0|\x03\xb3O;\x10'),
+ (4, 3, 7, 'saturate'): (b'x\x01\x1d\xcd[\xb5\x90!\x10\x80Q"\x18\x81\x08\xbc{C-@\x04"\xd0\xe0\x10\x81\x08D\xe0\xdd\x1bj'
+                         b'\x01"\x10\xe1o\xa0\xfb\xc8Z{\xcd\xbc|C\x08\xff\xdf\xdb\x10:\x9b\xf0.\x84H\xa6\xd2\x19'
+                         b'L\x16\x9b\xc3\xe5!\xbc\x0f\xe1\r\x91D\xa6Pit\x06\x93\xc5\xe6py\x08\x1f\xf4D\x12\x99'
+                         b'B\xa5\xd1\x19L\x16\x9b\xc3\xe5!|\xd4\x13Id\n\x95Fg0Yl\x0e\x97\x87\x90\xf5D\x12\x99B\xa5'
+                         b'\xd1\x19L\x16\x9b\xc3\xe5!|\xd2\x13Id\n\x95Fg0Yl\x0e\x97\x87\xf0YO$\x91)T\x1a\x9d\xc1d\xb19'
+                         b'\\\x1e\xc2\x17=\x91D\xa6Pit\x06\x93\xc5\xe6p_\xf7\x17}\xe7\xab\xc1&|s\x8bL\xa53\x98,'
+                         b'6\x87\xcbC\xf8\xee\x7f"\x89L\xa1\xd2\xe8\x0c&\x8b\xcd\xe1\xf2\x10~\xe8\x89$2\x85J\xa33\x98,6'
+                         b"\x87\xcbC\xf8\xa9'\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0fa\xeb\x89$2\x85J\xa33\x98,6\x87\xcb"
+                         b'C\xf8\xa5\'\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0f\xe1\xb7\x9eH"S\xa84:\x83\xc9bs\xb8<\x84'
+                         b'?z"\x89L\xa1\xd2\xe8\x0c&\x8b\xcd\xe1\xbe\xee\x7f\xff\x01!\xba\xf7\x9b',
+                         b'x\x01\xed\xdde\xb6\x96\x05\x00E\xe1\x0f\x01iD\xba\x11\xe9\x90n\x90\x12\xa4\xbb\xbb[\xbaA'
+                         b'X\x8bF\xa5\x94\x94\xee\xee.iP:\x94\x96FA\xe9N\xbd\xfc`\x10{]\xde\xfd\xcc\xe0\xec\t\x9cP'
+                         b'H\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\xc0\x07['
+                         b' \x82,`\x01\x0bX \x88\x05>\x92\x05\x82\\ \xa2\x82\\ \x92\xd8\x02\x91\x83\xed\xe3\xa0'
+                         b'\x8b\x12lQ\xc3\xbbh\xac\xe8\xb4\x18\xac\x98\xb4X\xac\xd8\xb4OXqh\x9f\xb2\xe2\xd2\xe2\xb1'
+                         b'\xe2\xd3\x12\xb0\x12\xd2\x12\xb1\x12\xd3\x92\xb0\x92\xd2\x92\xb1\x92\xd3R\xb0R\xd2R\xb1'
+                         b'>\xa3\xa5f}NK\xc3JKK\xc7JO\xcb\xc0\xcaH\xcb\xc4\xcaL\xcb\xc2\xcaJ\xfb\x82\x95\x8d\x96\x9d'
+                         b'\x95\x83\x96\x93\x95\x8b\x96\x9b\x95\x87\x96\x97\x95\x8f\x96\x9fU\x80V\x90U\x88V\x98'
+                         b'U\x84\xf6%\xab(\xad\x18\xab8\xad\x04\xab$\xed+V)Zi\xd6\xd7\xb42\xac\xb2\xb4r\xac\xf2\xb4\n'
+                         b'\xac\x8a\xb4J\xac\xca\xb4*\xac\xaa\xb4j\xac\xea\xb4\x1a\xac\x9a\xb4Z\xac\xda\xb4:'
+                         b'\xac\xba\xb4z\xac\xfa\xb4\x06\xac\x86\xb4F\xac\xc6\xb4&\xac\xa6\xb4f\xac\xe6\xb4\x16'
+                         b'\xac\x96\xb4V\xac\xd6\xb46\xac\xb6\xb4v\xac\xf6\xb4\x0e\xacoh\x1dY\x9dh\x9dY]h]Y\xddh\xdd'
+                         b'Y=h=Y\xbdh\xbdY}h}Y\xfdh\xfdY\xdf\xd2\x06\xb0\x06\xca\x02\x16\xb0\x80\x05,`\x01\x0b'
+                         b'X\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80'
+                         b'\x05\xde\x17\x08\x93\x05,\x10\xd4\x02\x1f\xec\xaf\x99\xc3,`\x01\x0bX\xc0\x02\x16\xb0'
+                         b'\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x81Ph\x90,`\x01\x0bX \x88\x05\x06\xcb\x02A.'
+                         b'0DA.0Tl\x81a\xc16<\xe8F\x04\xdb\xc8\xf0\xee;\xd6\xf7\xb4\x1fX\xa3h\xa3YchcY\xe3h?'
+                         b'\xb2~\xa2\x8dgM\xa0MdM\xa2MfM\xa1\xfd\xcc\x9aJ\x9b\xc6\x9aN\x9b\xc1\x9aI\x9b\xc5\x9aM\x9b'
+                         b'\xc3\x9aK\x9b\xc7\x9aO[\xc0ZH[\xc4ZL[\xc2ZJ[\xc6ZN[\xc1ZI[\xc5ZM[\xc3ZK[\xc7ZO\xdb'
+                         b'\xc0\xdaH\xdb\xc4\xdaL\xdb\xc2\xdaJ\xdb\xc6\xdaN\xfb\x85\xb5\x83\xb6\x93\xb5\x8b\xb6'
+                         b'\x9b\xb5\x87\xb6\x97\xb5\x8f\xb6\x9fu\x80\xf6+\xeb7\xdaA\xd6!\xdaa\xd6\x11\xdaQ\xd61\xda'
+                         b'q\xd6\t\xdaI\xd6)\xda\xef\xac?h\xa7YghgY\xe7h\xe7Y\x17h\x17Y\x7f\xd2.\xb1.\xd3'
+                         b'\xae\xb0\xae\xd2\xae\xb1\xae\xd3n\xb0n\xd2\xfeb\xfdM\xbb\xc5\xbaM\xfb\x87\xf5/\xed\x0e\xeb.'
+                         b'\xed\x1e\xeb>\xed\x01\xeb!\xed\x11\xeb1\xed\t\xeb)\xed\x19\xeb9\xed\x05\xeb%\xed\x15\xeb5'
+                         b'\xed\r\xeb-\xed?\xd6\xff\xb2\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0'
+                         b'\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x81\xf7\x05\x82z|\xeen\x0bX'
+                         b' \xec\x1d\xdd\xb0\xc7z'),
+ (5, 2, 15, 'saturate'): (b'x\x01M\xcb\xd9\x11\x10T\x0c@\xd1\x94B\x17 \x08\x06Dh#\x9d\x90R\xd2\x05\xca\x1a\x17'
+                          b'\xa0\x8dt\x02\xc7\x1f\xc7\xcc\x9c\xf7\xf1n\x12\xf1\xef\xf4C\xcf\xa3\x88\xa4\x19\x96#~\x8ax@'
+                          b"R4\xc3r\xc4c\x9d\xa4h\x86\xe5\x88':I\xd1\x0c\xcb\x11?\xeb$E3,G<\xd5I\x8afX\x8ex\xa6\x93"
+                          b'\x14\xcd\xb0\x1c\xf1\x8bNR4\xc3rD\xea$E3,G<\xd7I\x8afX\x8ex\xa1\x93\x14\xcd\xb0\x1c'
+                          b'\xf1\xabNR4\xc3r\xc4K\x9d\xa4h\x86\xe5\x88\xdft\x92\xa2\x19\x96#^\xe9$E3,G\xbc\xd6I'
+                          b'\x8a~\xa3\xfdO\xb4\xbf\xb7\xf6~\xb7C3,G\xfc\xe1\x9e\xa4h\x86\xe5\x88w:I\xd1\x0c'
+                          b'\xcb\x11\xefu\x92\xa2\x19\x96#>\xe8$E3,G|\xd4I\x8afX\x8e\xf8\xa4\x93\x14\xcd\xb0\x1c\xf1Y'
+                          b"')\x9aa9bu\x92\xa2\x19\x96#\xfe\xd4I\x8afX\x8e\xf8K')\x9aa9\xe2o\x9d\xa4h\x86\xe5\x88\x7ft"
+                          b'\x92\xa2\x19\x96#\xbe\xe8$E3,G|\xd5I\x8afX\x8e\xf8\xa6\x93\x14\xfd]\xfb\xcf\x0f'
+                          b'\xd2\x15\xf0\xcf',
+                          b"x\x01\xed\xddC\x82\x1d\x00\x00D\xc1\x89m\xdb\xb6m\xdb\xb6m'\xab\xd8\xb6m\xdb\xb6m\xdb"
+                          b'v\xb2H\x8e1\x8b\xfau\x83~\x17\xe8\xa0\xa0`\x16\xc2\x16R\x17\xca\x16Z\x17\xc6\x16V\x17'
+                          b'\xce\x16^\x17\xc1\x16Q\x17\xc9\x16Y\x17\xc5\x16U\x17\xcd\x16]\x17\xc3\x16S\x17\xcb\x16[\x17'
+                          b'\xc7\x16W\x17\xcf\x16_\x97\xc0\x96P\x97\xc8\x96X\x97\xc4\x96T\x97\xcc\x96\\\x97'
+                          b'\xc2\x96R\x97\xca\x96Z\x97\xc6\x96V\x97\xce\x96^\x97\xc1\x96Q\x97\xc9\x96Y\x97\xc5\x96U\x97'
+                          b'\xcd\x96]\x97\xc3\x96S\x97\xcb\x96[\x97\xc7\x96W\x97\xcf\x96_W\xc0VPW\xc8VXW\xc4VTW\xccV\\W'
+                          b'\xc2VRW\xcaVZW\xc6VVW\xceV^W\xc1VQW\xc9VYW\xc5VUW\xcdV]W\xc3VSW\xcbV[W\xc7VWW\xcfV_\xd7'
+                          b'\xc0\xd6P\xd7\xc8\xd6X\xd7\xc4\xd6T\xd7\xcc\xd6\\\xd7\xc2\xd6R\xd7\xca\xd6Z\xd7'
+                          b'\xc6\xd6V\xd7\xce\xd6^\xd7\xc1\xd6Q\xd7\xc9\xd6Y\xd7\xc5\xd6U\xd7\xcd\xd6]\xd7\xc3\xd6S\xd7'
+                          b'\xcb\xd6[\xd7\xc7\xd6W\xd7\xcf\xd6_7\xc06P7( X\x0b\xfc\x0b\x08\x14\x08\x14P\x0b'
+                          b'\x04\x05\xb7\xc1\xb6!\xba\xa1\xb6a\xba\xe1\xb6\x11\xba\x91\xb6Q\xba\xd1\xb61\xba\xb1'
+                          b'\xb6q\xba\xf1\xb6\t\xba\x89\xb6I\xba\xc9\xb6)\xba\xa9\xb6i\xba\xe9\xb6\x19\xba\x99'
+                          b'\xb6Y\xba\xd9\xb69\xba\xb9\xb6y\xba\xf9\xb6\x05\xba\x85\xb6E\xba\xc5\xb6%\xba\xa5'
+                          b'\xb6e\xba\xe5\xb6\x15\xba\x95\xb6U\xba\xd5\xb65\xba\xb5\xb6u\xba\xf5\xb6\r\xba\x8d'
+                          b'\xb6M\xba\xcd\xb6-\xba\xad\xb6m\xba\xed\xb6\x1d\xba\x9d\xb6]\xba\xdd\xb6=\xba\xbd'
+                          b'\xb6}\xba\xfd\xb6\x03\xba\x83\xb6C\xba\xc3\xb6#\xba\xa3\xb6c\xba\xe3\xb6\x13\xba\x93'
+                          b'\xb6S\xba\xd3\xb63\xba\xb3\xb6s\xba\xf3\xb6\x0b\xba\x8b\xb6K\xba\xcb\xb6+\xba\xab'
+                          b'\xb6k\xba\xeb\xb6\x1b\xba\x9b\xb6[\xba\xdb\xb6;\xba\xbb\xb6{\xba\xfb\xb6\x07\xba\x87'
+                          b"\xb6G\xba\xc7\xb6'\xba\xa7\xb6g\xba\xe7\xb6\x17\xba\x97\xb6W\xba\xd7\xb67\xba\xb7"
+                          b'\xb6w\xba\xf7\xb6\x0f\xba\x8f\xb6O\xba\xcf\xb6/\xba\xaf\xb6o\xba\xef\xb6\x1f\xba\x9f'
+                          b'\xb6_\xba\xdf\xb6?\xba\xbf\x01\xc1Z@=>\x0f\xec\x0e\x14\x08\x14\xf8\xf7\x1f$\x1d\xcd\x0c'),
+ (4, 3, 7, 'overflow'): (b'x\x01\x1d\xcd[\xb5\x90!\x10\x80Q"\x18\x81\x08\xbc{C-@\x04"\xd0\xe0\x10\x81\x08D\xe0\xdd\x1bj'
+                         b'\x01"\x10\xe1o\xa0\xfb\xc8Z{\xcd\xbc|C\x08\xff\xdf\xdb\x10:\x9b\xf0.\x84H\xa6\xd2\x19'
+                         b'L\x16\x9b\xc3\xe5!\xbc\x0f\xe1\r\x91D\xa6Pit\x06\x93\xc5\xe6py\x08\x1f\xf4D\x12\x99'
+                         b'B\xa5\xd1\x19L\x16\x9b\xc3\xe5!|\xd4\x13Id\n\x95Fg0Yl\x0e\x97\x87\x90\xf5D\x12\x99B\xa5'
+                         b'\xd1\x19L\x16\x9b\xc3\xe5!|\xd2\x13Id\n\x95Fg0Yl\x0e\x97\x87\xf0YO$\x91)T\x1a\x9d\xc1d\xb19'
+                         b'\\\x1e\xc2\x17=\x91D\xa6Pit\x06\x93\xc5\xe6p_\xf7\x17}\xe7\xab\xc1&|s\x8bL\xa53\x98,'
+                         b'6\x87\xcbC\xf8\xee\x7f"\x89L\xa1\xd2\xe8\x0c&\x8b\xcd\xe1\xf2\x10~\xe8\x89$2\x85J\xa33\x98,6'
+                         b"\x87\xcbC\xf8\xa9'\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0fa\xeb\x89$2\x85J\xa33\x98,6\x87\xcb"
+                         b'C\xf8\xa5\'\x92\xc8\x14*\x8d\xce`\xb2\xd8\x1c.\x0f\xe1\xb7\x9eH"S\xa84:\x83\xc9bs\xb8<\x84'
+                         b'?z"\x89L\xa1\xd2\xe8\x0c&\x8b\xcd\xe1\xbe\xee\x7f\xff\x01!\xba\xf7\x9b',
+                         b'x\x01\xed\xdd\x85\xb2\x90\x05\x10@\xe1K\x87t\x83\x94tI\x83\xd2\x1d\xd2\xd2 \xdd\x8dt3C\xa74*'
+                         b'\xdd\x12\x06\x9d"JwHwww\xc3\xe51\xce\\\xfe\xf3\xbd\xc0\xce\x9e\x07\xd8\r\t\x91\x05,`\x01\x0b'
+                         b"X\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,\xf0\xd9\x16\x08'\x0bX\xc0\x02"
+                         b'\x16\x08b\x81\xf0\xb2@\x90\x0bDP\x90\x0bD\x14[ R\xb0E\x0e\xba(\xc1\x165\xac\x8b\xc6\x8aN\xfb'
+                         b'\x82\x15\x83\x16\x93\x15\x8b\x16\x9b\x15\x87\x16\x97\x15\x8f\x16\x9f\x95\x80\x96'
+                         b'\x90\x95\x88\x96\x98\x95\x84\x96\x94\x95\x8c\xf6%+9-\x05+%-\x15+5\xed+V\x1aZZV:ZzV\x06ZFV&Z'
+                         b'fV\x16ZVV6\xda\xd7\xac\xec\xb4\x1c\xac\x9c\xb4\\\xac\xdc\xb4<\xac\xbc\xb4|\xac\xfc\xb4'
+                         b'oX\xdf\xd2\n\xb0\n\xd2\n\xb1\n\xd3\x8a\xb0\x8a\xd2\x8a\xb1\x8a\xd3J\xb0J\xd2J\xb1J\xd3'
+                         b'\xca\xb0\xca\xd2\xca\xb1\xca\xd3\xbecU\xa0UdU\xa2UfU\xa1UeU\xa3}\xcf\xaaN\xab\xc1\xaaI'
+                         b'\xab\xc5\xaaM\xab\xc3\xaaK\xab\xc7\xaaO\xfb\x81\xd5\x80\xd6\x90\xd5\x88\xd6\x98\xd5\x84'
+                         b'\xd6\x94\xd5\x8c\xd6\x9c\xd5\x82\xd6\x92\xd5\x8a\xd6\x9a\xd5\x86\xd6\x96\xd5\x8e'
+                         b"\xd6\x9e\xd5\x81\xd6\x91\xd5\x89\xd6\x99\xf5#\xad\x0b\xab+\xad\x1b\xab;\xad\x07\xab'"
+                         b'\xad\x17\xab7\xad\x0f\xab/\xad\x1f\xab?m\x00k -T\x16\xb0\x80\x05,`\x01\x0bX\xc0'
+                         b'\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,'
+                         b'`\x01\x0bX\x80-\xf0\xd9\xfe5s1\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16'
+                         b'\xb0\x80\x05,`\x01\x0bX $d\x90,`\x01\x0bX \x88\x05\x06\xcb\x02A.0DA.0Tl\x81a\xc16<\xe8F\x04'
+                         b"\xdb\xc8\xb0n\x14k4m\x0ck,\xed'\xd68\xdax\xd6\x04\xdaD\xd6$\xdad\xd6\x14\xdaT\xd6\xcf\xb4"
+                         b'_X\xbf\xd2\xa6\xb1\xa6\xd3f\xb0f\xd2f\xb1f\xd3\xe6\xb0\xe6\xd2\xe6\xb1\xe6\xd3'
+                         b"\x16\xb0\x16\xd2\x16\xb1~\xa3-f-\xa1-e-\xa3\xfd\xce\xfa\x83\xf6'\xeb/\xdar\xd6\n\xdaJ\xd6*"
+                         b'\xdaj\xd6\x1a\xdaZ\xd6:\xdaz\xd6\x06\xdaF\xd6&\xda\xdf\xac\xcd\xb4\x7fX[h\xff\xb2\xfe\xa3mem'
+                         b'\xa3mg\xed\xa0\xedd\xed\xa2\xedf\xed\xa1\xede\xed\xa3\xedg\x1d\xa0\x1dd\x1d\xa2\x1df\x1d'
+                         b'\xa1\xfd\xcf:J;\xc6:N;\xc1:I;\xc5:M;\xc3:K;\xc7:O\xbb\xc0\xbaH\xbb\xc4\xbaL\xbb\xc2\xba'
+                         b'J\xbb\xc6\xbaN\xbb\xc1\xbaI\xbb\xc5\xbaM\xbb\xc3\xbaK\xbb\xc7\xbaO{\xc0zH{\xc4zL{\xc2z'
+                         b'J{\xc6zN{\xc1zI{\xc5zM{\xc3zK{\xc7zO\xfb\xc0\xfaHc\xcf\xf7;\xdd\x02\x16\xb0\x80\x05,'
+                         b'`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02'
+                         b'\x16\xb0\x80\x05,`\x01\x0b\x84~\x02\x87va\xdb'),
+ (5, 2, 15, 'overflow'): (b'x\x01M\xcb\xd9\x11\x10T\x0c@\xd1\x94B\x17 \x08\x06Dh#\x9d\x90R\xd2\x05\xca\x1a\x17'
+                          b'\xa0\x8dt\x02\xc7\x1f\xc7\xcc\x9c\xf7\xf1n\x12\xf1\xef\xf4C\xcf\xa3\x88\xa4\x19\x96#~\x8ax@'
+                          b"R4\xc3r\xc4c\x9d\xa4h\x86\xe5\x88':I\xd1\x0c\xcb\x11?\xeb$E3,G<\xd5I\x8afX\x8ex\xa6\x93"
+                          b'\x14\xcd\xb0\x1c\xf1\x8bNR4\xc3rD\xea$E3,G<\xd7I\x8afX\x8ex\xa1\x93\x14\xcd\xb0\x1c'
+                          b'\xf1\xabNR4\xc3r\xc4K\x9d\xa4h\x86\xe5\x88\xdft\x92\xa2\x19\x96#^\xe9$E3,G\xbc\xd6I'
+                          b'\x8a~\xa3\xfdO\xb4\xbf\xb7\xf6~\xb7C3,G\xfc\xe1\x9e\xa4h\x86\xe5\x88w:I\xd1\x0c'
+                          b'\xcb\x11\xefu\x92\xa2\x19\x96#>\xe8$E3,G|\xd4I\x8afX\x8e\xf8\xa4\x93\x14\xcd\xb0\x1c\xf1Y'
+                          b"')\x9aa9bu\x92\xa2\x19\x96#\xfe\xd4I\x8afX\x8e\xf8K')\x9aa9\xe2o\x9d\xa4h\x86\xe5\x88\x7ft"
+                          b'\x92\xa2\x19\x96#\xbe\xe8$E3,G|\xd5I\x8afX\x8e\xf8\xa6\x93\x14\xfd]\xfb\xcf\x0f'
+                          b'\xd2\x15\xf0\xcf',
+                          b'x\x01\xed\xddS\xd6\x1d\x06\x00\x85\xd1?\xb6m[\r\x1a\xdb\xb6\xd94nl\xbe\xc4\xb6m\xdb'
+                          b'v\xd2\xd8n\xd0\xd8\xb6\xd6J\x86q\x1f\xf6\xdd38\xdf\x04NHH\x80\x85\xb2\x85\xd6\x85\xb1'
+                          b'\x85\xd5\x85\xb3\x85\xd7E\xb0E\xd4E\xb2E\xd6E\xb1E\xd5E\xb3E\xd7\xc5\xb0\xc5\xd4\xc5\xb2'
+                          b'\xc5\xd6\xc5\xb1\xc5\xd5\xc5\xb3\xc5\xd7%\xb0%\xd4%\xb2%\xd6%\xb1%\xd5%\xb3%\xd7\xa5\xb0'
+                          b'\xa5\xd4\xa5\xb2\xa5\xd6\xa5\xb1\xa5\xd5\xa5\xb3\xa5\xd7e\xb0e\xd4e\xb2e\xd6e\xb1e\xd5e\xb3'
+                          b'e\xd7\xe5\xb0\xfd\xa1\xcbi\xcb\xa5\xcbm\xcb\xa3\xfb\xd3\x96W\x97\xcf\x96_W\xc0VPW\xc8'
+                          b'VXW\xc4VTW\xccV\\W\xc2VRW\xcaVZW\xc6VVW\xceV^W\xc1VQW\xc9VYW\xc5VUW\xcdV]W\xc3VSW\xcb'
+                          b'V[W\xc7VWW\xcfV_\xd7\xc0\xd6P\xd7\xc8\xd6X\xd7\xc4\xd6T\xd7\xcc\xf6\x97\xae\xb9\xedo]\x0b'
+                          b'[K]+[k]\x1b[[];\xdb?\xba\xf6\xb6\x0e\xba\x8e\xb6N\xba\xce\xb6.\xba\xae\xb6n\xba\xee'
+                          b'\xb6\x1e\xba\x9e\xb6^\xba\xde\xb6>\xba\xbe\xb6~\xba\xfe\xb6\x01\x81\xf6+(X X@-\x10'
+                          b'\x12h\x03m\x83t\x83mCtCm\xc3t\xc3m#t#m\xa3t\xa3mctcm\xe3t\xe3m\x13t\x13m\x93t\x93mStSm'
+                          b'\xd3t\xd3m3t3m\xb3t\xb3mstsm\xf3t\xf3m\x0bt\x0bm\x8bt\x8bmKtKm\xcbt\xcbm+t+m\xabt\xabmktkm'
+                          b'\xebt\xebm\x1bt\x1bm\x9bt\x9bm[t[m\xdbt\xdbm;t;m\xbbt\xbbm{t{m\xfbt\xfbm\x07t\x07m'
+                          b'\x87t\x87mGtGm\xff\xea\x8e\xd9\x8e\xebN\xd8N\xeaN\xd9N\xeb\xce\xd8\xce\xea\xce\xd9'
+                          b'\xce\xeb.\xd8.\xea.\xd9.\xeb\xae\xd8\xae\xea\xae\xd9\xae\xebn\xd8\xfe\xd3\xdd\xb4'
+                          b'\xdd\xd2\xdd\xb6\xdd\xd1\xfdo\xbb\xab\xbbg\xbb\xaf{`{\xa8{d{\xac{b{\xaa{f{\xae{a{\xa9{e'
+                          b'{\xad{c{\xab{g{\xaf\xfb`\xfb\xa8\xfbd\xfb\xac\xfbb\xfb\xaa\xfbf\xfb\xae\xfba\xfb\x19h\xea'
+                          b'\xf1ypw\xb0@\xb0\xc0\xaf\xdf\xf0\x99\xce\x0e')}
+
+
+binary8_luts_compressed = \
+{(4, 8): (b'x\x01\x15\xcb[\xd5P!\x10\x80Q"\x18\x81\x08<{E-@\x04"\xd0@"\x10\x81\x08<{E\xff\x02\'\x02\x11h\xa0\xdbY'
+          b'k\xcf\xcb\xcc\x17\xc2\xff\xe9\xaf\xad7!d:\x93\xcd!\xbc\r\xe1\x15\x91D\xa6Pit\x06\x93\xc5\xe6\xe1p\t\xef\xf4'
+          b'D\x12\x99B\xa5\xd1\x19L\x16\x9b\x87\xc3%\xbc\xd7\x13Id\n\x95Fg0Yl\x1e\x0e\x97\xf0AO$\x91)T\x1a\x9d\xc1d\xb1'
+          b"y8\\B\xd6\x13Id\n\x95Fg0Yl\x1e\x0e\x97\xf0QO$\x91)T\x1a\x9d\xc1d\xb1y8\\\xc2'=\x91D\xa6Pit\x06\x93"
+          b'\xc5\xe6\xe1p\t\x9f\xf5D\x12\x99B\xa5\x7f\xf1O\xff\xea\xef\x9b\x1b\x9d\xc9\xe6\x10\xbe\xeb\x89$2\x85J\xa3'
+          b'3\x98,6\x0f\x87K\xf8\xa1\'\x92\xc8\x14*\x8d\xce`\xb2\xd8<\x1c.\xe1\xa7\x9eH"S\xa84:\x83\xc9b\xf3p\xb8\x84_z'
+          b'"\x89L\xa1\xd2\xe8\x0c&\x8b\xcd\xc3\xe1\x12\xb6\x9eH"S\xa84:\x83\xc9b\xf3p\xb8\x84\xdfz"\x89L\xa1\xd2\xe8'
+          b'\x0c&\x8b\xcd\xc3\xe1\x12\xfe\xe8\x89$2\x85J\xa33\x98,6\x0f\x87Kx\xd1\x13Id\n\x95\xfe\xf7\x1f[)\xf3`',
+          b'x\x01\xed\xdd\x05\xba\x96\x05\x00\x05\xe1\x9f\xee\x06\xe9FZA\xa4\xbb\xbb;\xa4SB\xba\xeb\xd2\xdd\x8dt\x97'
+          b'\x92J(\xa14\xa2\x84\x92\x8a\xa4\x82\xd2\x1d\x12.c\x9e\xcb7\xef\x0e\xcel\xe0\x84B\xb2\x80\x05,`\x01'
+          b'\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xe0\xbd/\x10A\x16\xb0\x80\x05,\x10\xc4\x02\x11e\x81 \x17\x88'
+          b'\xa4 \x17\x88,\xb6@\x94`\x8b\x1at\xd1\x82-zx\x17\x83\x15\x93\x16\x8b\x15\x9b\x16\x87\x15\x97\x16\x8f\x15'
+          b'\x9f\x96\x80\x95\x90\x96\x88\x95\x98\x96\x84\xf5\x01-)+\x19-9+\x05-%+\x15-5+\r--+\x1d-=+\x03-#+\x13\xedCV'
+          b'fZ\x16VVZ6VvZ\x0eVN\xdaG\xac\x8fi\xb9X\xb9i\x9f\xb0\xf2\xd0>e\xe5\xa5\xe5c\xe5\xa7\x15`\x15\xa4\x15b'
+          b'\x15\xa6\x15a\x15\xa5\x15c\x15\xa7\x95`\x95\xa4\x95b\x95\xa6\x95a\x95\xa5\x95c\x95\xa7U`U\xa4UbU\xa6Ua'
+          b'U\xa5UcU\xa7\xd5`\xd5\xa4\xd5b\xd5\xa6\xd5a\xd5\xa5\xd5c\xd5\xa75`5\xa45b5\xa65a}Fk\xcajFk\xcejAk\xc9'
+          b"jEk\xcdjCk\xcbjGk\xcf\xea@\xfb\x9c\xd5\x91\xd6\x89\xd5\x99\xd6\x85\xf5\x05\xad+\xab\x1b\xad;\xab\x07\xad'"
+          b'\xab\x17\xad7\xab\x0f\xad/\xab\x1f\xad?k\x00m k\x10m0k\x08m\xa8,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,'
+          b'`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x00\\'
+          b' L\x16\xb0@P\x0b\xbc\xf7\xff\x86\x0e\xb4\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX '
+          b'\x14\x1a&\x0bX\xc0\x02\x16\x08b\x81\xe1\xb2@\x90\x0b\x8cP\x90\x0b\x8c\x14[`T\xb0\x8d\x0e\xba1\xc16'
+          b'6\xbc\x1b\xc7\x1aO\x9b\xc0\x9aH\x9b\xc4\x9aL\x9b\xc2\x9aJ\x9b\xc6\x9aN\x9b\xc1\x9aI\x9b\xc5\x9aM\x9b\xc3'
+          b'\x9aK\x9b\xc7\x9aO\xfb\x92\xb5\x80\xb6\x90\xb5\x88\xb6\x98\xb5\x84\xb6\x94\xb5\x8c\xb6\x9c\xb5\x82\xb6\x92'
+          b'\xb5\x8a\xb6\x9a\xb5\x86\xb6\x96\xb5\x8e\xb6\x9e\xb5\x81\xf6\x15\xebk\xdaF\xd6&\xdaf\xd6\x16\xdaV\xd66\xda7'
+          b'\xacoi\xdbY;h;Y\xbbh\xdf\xb1\xbe\xa7\xedf\xed\xa1\xede\xed\xa3\xfd\xc0\xfa\x91\xb6\x9fu\x80v\x90u\x88v'
+          b'\x98u\x84v\x94u\x8c\xf6\x13\xeb8\xedg\xd6/\xb4\x13\xac\x93\xb4S\xac\xd3\xb4_Y\xbf\xd1\xce\xb0\xce\xd2'
+          b'\xce\xb1\xce\xd3.\xb0.\xd2~g\xfdA\xbb\xc4\xfa\x93v\x99u\x85v\x95u\x8dv\x9du\x83\xf6\x17\xebo\xdaM\xd6-'
+          b'\xda?\xac\x7fi\xb7YwhwY\xf7h\xf7Y\x0fh\x0fY\x8fh\x8fYOhOY\xcfh\xcfY/h/Y\xafh\xff\xb1^\xd3\xde\xb0\xde'
+          b'\xd2\xde\xc9\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`'
+          b'\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0b\xc0\x05\x82z|\xeen\x0bX \xec\x7f\xc6\xe4\x02%'),
+ (5, 16): (b'x\x01\x1d\xc9\x89\r\x10\x04\x0c\x86\xd1\x8e\xc2\x16 \x97\x059\xd6\xe8&t\x94n\xa1\\RQ`\x8dn\x02/6yI'
+           b"\xf3\x7f\x11\xff\xdf\xc3\x88f\x89G\x11\x0fH\x8afX\x8e\xf8M')\x9aa9\xe2\xb1NR4\xc3r\xc4\x13\x9d\xa4h"
+           b'\x86\xe5\x88\xa7:I\xd1\x0c\xcb\x11\xcft\x92\xa2\x19\x96#\x9e\xeb$E3,G\xfc\xae\x93\x14\xcd\xb0\x1c\x91'
+           b":I\xd1\x0c\xcb\x11/t\x92\xa2\x19\x96#^\xea$E3,G\xfc\xa1\x93\x14\xcd\xb0\x1c\xf1J')\x9aa9\xe2\xb5NR4\xc3"
+           b'r\xc4\x1b\x9d\xa4h\x86\xe5\x88\xb7:I\xbf\xb3\x13\x7f\xfaY\xe2/\x9d\xa4h\x86\xe5\x88\xf7:I\xd1\x0c\xcb'
+           b'\x11\x1ft\x92\xa2\x19\x96#>\xea$E3,G|\xd2I\x8afX\x8e\xf8\xac\x93\x14\xcd\xb0\x1c\xf1\xb7NR4\xc3r'
+           b"\xc4\x17\x9d\xa4h\x86\xe5\x88\xd5I\x8afX\x8e\xf8G')\x9aa9\xe2\xabNR4\xc3r\xc4\xbf:I\xd1\x0c\xcb\x11"
+           b"\xff\xe9$E3,G|\xd3I\x8afX\x8e\xf8\xae\x93\x14\xcd\xb0\x1c\xf1C'\xe9\x9f\xbf\x00Gi\xed\x02",
+           b'x\x01\xed\xddU\xd6\x96\x05\x00\x85\xd1\x9f\x16\xa4\x14\x04\xe9P\xa4K\x1a\xe9\x14\x10\t\xe9\x0eQ'
+           b'\xba\xc1\xa0\xbb\xbb\xa5\x1b)%\xa5;%\xa5\xbb;%\x94\x8eAp\xf1.\xd6\xfe\xf6\x0c\xce3\x81\x13\x16\xf6'
+           b'\x8e\xc2\x05+|\xd0"\x04+b\xd0"\x05+r\xd0\xa2\x04\xeb\x83\xf7]T[4\xdd\x87\xb6\xe8\xba\x18\xb6\x98\xbaX\xb6'
+           b'\xd8\xba\x8fl\x1f\xeb\xe2\xd8\xe2\xea>\xb1\xc5\xd3\xc5\xb7}\xaaK`K\xa8KdK\xacKbK\xaaKfK\xaeKaK\xa9\xfb\xcc'
+           b'\xf6\xb9.\x95\xed\x0b]j[\x1a]Z[:]z[\x06]F[&]f[\x16]V\xdb\x97\xbal\xb6\xec\xba\x1c\xb6\x9c\xba\\'
+           b'\xb6\xdc\xba<\xb6\xbc\xba\xafl\xf9t\xf9m\x05t\x05m\x85t\x85mEtEm\xc5t\xc5m%t%m_\xebJ\xd9J\xeb\xca'
+           b'\xd8\xbe\xd1\x95\xb5}\xab+g+\xaf\xab`\xab\xa8\xfb\xceVIW\xd9VEW\xd5VMW\xddVCW\xd3VKW\xdbVGW\xd7VOW'
+           b'\xdf\xd6@\xd7\xd0\xf6\xbd\xae\x91\xed\x07\xdd\x8f\xb6\xc6\xba&\xb6\xa6\xbaf\xb6\xe6\xba\x16\xb6\x96\xba'
+           b'V\xb6\xd6\xba6\xb6\xb6\xbav\xb6\xf6\xba\x0e\xb6\x8e\xba\x9fl?\xeb~\xb1\xfd\xaa\xebd\xeb\xac\xebb\xeb\xaa'
+           b"\xeb\x16\x12h\x81\xee!\xa1\x02\xa1\x02j\x81\xb0w\xd5#X=\x83\xd6+X\xbd\x83\xd6'X}\x83\xd6/X\xfd\xdfw"
+           b'\x03l\x03u\x83l\x83uClCu\xc3l\xc3u#l#u\xa3l\xa3uclcu\xe3l\xe3u\x13l\xbf\xe9&\xda&\xe9&\xdb\xa6\xe8'
+           b'\xa6\xda\xa6\xe9\xa6\xdbf\xe8f\xdaf\xe9f\xdb\xe6\xe8\xe6\xda\xe6\xe9~\xb7\xcd\xd7-\xb0-\xd4-\xb2-\xd6'
+           b'\xfda\xfbS\xb7\xc4\xb6T\xb7\xcc\xb6\\\xb7\xc2\xb6R\xf7\x97m\x95n\xb5m\x8dn\xadm\x9dn\xbdm\x83n\xa3m\x93'
+           b'n\xb3m\x8bn\xabm\x9bn\xbbm\x87n\xa7m\x97n\xb7\xedo\xdd\x1e\xdb^\xdd>\xdb~\xdd\x01\xdbA\xdd?\xb6C'
+           b'\xba\xc3\xb6#\xba\xa3\xb6c\xba\xe3\xb6\x13\xba\x93\xb6S\xba\xd3\xb63\xba\xb3\xb6s\xba\xf3\xb6\x0b'
+           b'\xba\x8b\xb6K\xba\xcb\xb6+\xba\xab\xb6k\xba\xeb\xb6\x1b\xba\x9b\xb6[\xba\xdb\xb6;\xba\xbb\xb6{'
+           b'\xba\xfb\xb6\x7fu\x0fl\x0fu\x8fl\x8fu\xff\xd9\xfe\xd7=\xb1=\xd5=\xb3=\xd7\xbd\xb0\xbd\xd4\xbd\xb2\xbd'
+           b'\xd6\xbd\t\t\xb4\x80z|\x1e\xda\x1d*\x10*\xd0\xfd-\x8c\x93\xc6\x0e')}
```

### Comparing `bitstring-4.2.1/bitstring/methods.py` & `bitstring-4.2.2/bitstring/methods.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,95 +1,95 @@
-from __future__ import annotations
-
-import bitstring
-from bitstring.bitstream import BitStream
-from bitstring.utils import tokenparser
-from bitstring.exceptions import CreationError
-from typing import Union, List
-from bitstring.bitstore import BitStore
-from bitstring.bitstore_helpers import bitstore_from_token
-
-
-def pack(fmt: Union[str, List[str]], *values, **kwargs) -> BitStream:
-    """Pack the values according to the format string and return a new BitStream.
-
-    fmt -- A single string or a list of strings with comma separated tokens
-           describing how to create the BitStream.
-    values -- Zero or more values to pack according to the format.
-    kwargs -- A dictionary or keyword-value pairs - the keywords used in the
-              format string will be replaced with their given value.
-
-    Token examples: 'int:12'    : 12 bits as a signed integer
-                    'uint:8'    : 8 bits as an unsigned integer
-                    'float:64'  : 8 bytes as a big-endian float
-                    'intbe:16'  : 2 bytes as a big-endian signed integer
-                    'uintbe:16' : 2 bytes as a big-endian unsigned integer
-                    'intle:32'  : 4 bytes as a little-endian signed integer
-                    'uintle:32' : 4 bytes as a little-endian unsigned integer
-                    'floatle:64': 8 bytes as a little-endian float
-                    'intne:24'  : 3 bytes as a native-endian signed integer
-                    'uintne:24' : 3 bytes as a native-endian unsigned integer
-                    'floatne:32': 4 bytes as a native-endian float
-                    'hex:80'    : 80 bits as a hex string
-                    'oct:9'     : 9 bits as an octal string
-                    'bin:1'     : single bit binary string
-                    'ue' / 'uie': next bits as unsigned exp-Golomb code
-                    'se' / 'sie': next bits as signed exp-Golomb code
-                    'bits:5'    : 5 bits as a bitstring object
-                    'bytes:10'  : 10 bytes as a bytes object
-                    'bool'      : 1 bit as a bool
-                    'pad:3'     : 3 zero bits as padding
-
-    >>> s = pack('uint:12, bits', 100, '0xffe')
-    >>> t = pack(['bits', 'bin:3'], s, '111')
-    >>> u = pack('uint:8=a, uint:8=b, uint:55=a', a=6, b=44)
-
-    """
-    tokens = []
-    if isinstance(fmt, str):
-        fmt = [fmt]
-    try:
-        for f_item in fmt:
-            _, tkns = tokenparser(f_item, tuple(sorted(kwargs.keys())))
-            tokens.extend(tkns)
-    except ValueError as e:
-        raise CreationError(*e.args)
-    value_iter = iter(values)
-    bsl: List[BitStore] = []
-    try:
-        for name, length, value in tokens:
-            # If the value is in the kwd dictionary then it takes precedence.
-            value = kwargs.get(value, value)
-            # If the length is in the kwd dictionary then use that too.
-            length = kwargs.get(length, length)
-            # Also if we just have a dictionary name then we want to use it
-            if name in kwargs and length is None and value is None:
-                bsl.append(BitStream(kwargs[name])._bitstore)
-                continue
-            if length is not None:
-                length = int(length)
-            if value is None and name != 'pad':
-                # Take the next value from the ones provided
-                value = next(value_iter)
-            if name == 'bits':
-                value = bitstring.bits.Bits(value)
-                if length is not None and length != len(value):
-                    raise CreationError(f"Token with length {length} packed with value of length {len(value)}.")
-                bsl.append(value._bitstore)
-                continue
-            bsl.append(bitstore_from_token(name, length, value))
-    except StopIteration:
-        raise CreationError(f"Not enough parameters present to pack according to the "
-                            f"format. {len(tokens)} values are needed.")
-
-    try:
-        next(value_iter)
-    except StopIteration:
-        # Good, we've used up all the *values.
-        s = BitStream()
-        if bitstring.options.lsb0:
-            bsl.reverse()
-        for b in bsl:
-            s._bitstore += b
-        return s
-
-    raise CreationError(f"Too many parameters present to pack according to the format. Only {len(tokens)} values were expected.")
+from __future__ import annotations
+
+import bitstring
+from bitstring.bitstream import BitStream
+from bitstring.utils import tokenparser
+from bitstring.exceptions import CreationError
+from typing import Union, List
+from bitstring.bitstore import BitStore
+from bitstring.bitstore_helpers import bitstore_from_token
+
+
+def pack(fmt: Union[str, List[str]], *values, **kwargs) -> BitStream:
+    """Pack the values according to the format string and return a new BitStream.
+
+    fmt -- A single string or a list of strings with comma separated tokens
+           describing how to create the BitStream.
+    values -- Zero or more values to pack according to the format.
+    kwargs -- A dictionary or keyword-value pairs - the keywords used in the
+              format string will be replaced with their given value.
+
+    Token examples: 'int:12'    : 12 bits as a signed integer
+                    'uint:8'    : 8 bits as an unsigned integer
+                    'float:64'  : 8 bytes as a big-endian float
+                    'intbe:16'  : 2 bytes as a big-endian signed integer
+                    'uintbe:16' : 2 bytes as a big-endian unsigned integer
+                    'intle:32'  : 4 bytes as a little-endian signed integer
+                    'uintle:32' : 4 bytes as a little-endian unsigned integer
+                    'floatle:64': 8 bytes as a little-endian float
+                    'intne:24'  : 3 bytes as a native-endian signed integer
+                    'uintne:24' : 3 bytes as a native-endian unsigned integer
+                    'floatne:32': 4 bytes as a native-endian float
+                    'hex:80'    : 80 bits as a hex string
+                    'oct:9'     : 9 bits as an octal string
+                    'bin:1'     : single bit binary string
+                    'ue' / 'uie': next bits as unsigned exp-Golomb code
+                    'se' / 'sie': next bits as signed exp-Golomb code
+                    'bits:5'    : 5 bits as a bitstring object
+                    'bytes:10'  : 10 bytes as a bytes object
+                    'bool'      : 1 bit as a bool
+                    'pad:3'     : 3 zero bits as padding
+
+    >>> s = pack('uint:12, bits', 100, '0xffe')
+    >>> t = pack(['bits', 'bin:3'], s, '111')
+    >>> u = pack('uint:8=a, uint:8=b, uint:55=a', a=6, b=44)
+
+    """
+    tokens = []
+    if isinstance(fmt, str):
+        fmt = [fmt]
+    try:
+        for f_item in fmt:
+            _, tkns = tokenparser(f_item, tuple(sorted(kwargs.keys())))
+            tokens.extend(tkns)
+    except ValueError as e:
+        raise CreationError(*e.args)
+    value_iter = iter(values)
+    bsl: List[BitStore] = []
+    try:
+        for name, length, value in tokens:
+            # If the value is in the kwd dictionary then it takes precedence.
+            value = kwargs.get(value, value)
+            # If the length is in the kwd dictionary then use that too.
+            length = kwargs.get(length, length)
+            # Also if we just have a dictionary name then we want to use it
+            if name in kwargs and length is None and value is None:
+                bsl.append(BitStream(kwargs[name])._bitstore)
+                continue
+            if length is not None:
+                length = int(length)
+            if value is None and name != 'pad':
+                # Take the next value from the ones provided
+                value = next(value_iter)
+            if name == 'bits':
+                value = bitstring.bits.Bits(value)
+                if length is not None and length != len(value):
+                    raise CreationError(f"Token with length {length} packed with value of length {len(value)}.")
+                bsl.append(value._bitstore)
+                continue
+            bsl.append(bitstore_from_token(name, length, value))
+    except StopIteration:
+        raise CreationError(f"Not enough parameters present to pack according to the "
+                            f"format. {len(tokens)} values are needed.")
+
+    try:
+        next(value_iter)
+    except StopIteration:
+        # Good, we've used up all the *values.
+        s = BitStream()
+        if bitstring.options.lsb0:
+            bsl.reverse()
+        for b in bsl:
+            s._bitstore += b
+        return s
+
+    raise CreationError(f"Too many parameters present to pack according to the format. Only {len(tokens)} values were expected.")
```

### Comparing `bitstring-4.2.1/bitstring/utils.py` & `bitstring-4.2.2/bitstring/utils.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,233 +1,233 @@
-from __future__ import annotations
-
-import functools
-import re
-from typing import Tuple, List, Optional, Pattern, Dict, Union, Match
-
-
-# A token name followed by optional : then an integer number
-NAME_INT_RE: Pattern[str] = re.compile(r'^([a-zA-Z][a-zA-Z0-9_]*?):?(\d*)$')
-
-# A token name followed by optional : then an arbitrary keyword
-NAME_KWARG_RE: Pattern[str] = re.compile(r'^([a-zA-Z][a-zA-Z0-9_]*?):?([a-zA-Z0-9_]+)$')
-
-CACHE_SIZE = 256
-
-DEFAULT_BITS: Pattern[str] = re.compile(r'^(?P<len>[^=]+)?(=(?P<value>.*))?$', re.IGNORECASE)
-
-MULTIPLICATIVE_RE: Pattern[str] = re.compile(r'^(?P<factor>.*)\*(?P<token>.+)')
-
-# Hex, oct or binary literals
-LITERAL_RE: Pattern[str] = re.compile(r'^(?P<name>0([xob]))(?P<value>.+)', re.IGNORECASE)
-
-# An endianness indicator followed by one or more struct.pack codes
-STRUCT_PACK_RE: Pattern[str] = re.compile(r'^(?P<endian>[<>@=]){1}(?P<fmt>(?:\d*[bBhHlLqQefd])+)$')
-# The same as above, but it doesn't insist on an endianness as it's byteswapping anyway.
-BYTESWAP_STRUCT_PACK_RE: Pattern[str] = re.compile(r'^(?P<endian>[<>@=])?(?P<fmt>(?:\d*[bBhHlLqQefd])+)$')
-# An endianness indicator followed by exactly one struct.pack codes
-SINGLE_STRUCT_PACK_RE: Pattern[str] = re.compile(r'^(?P<endian>[<>@=]){1}(?P<fmt>[bBhHlLqQefd])$')
-
-# A number followed by a single character struct.pack code
-STRUCT_SPLIT_RE: Pattern[str] = re.compile(r'\d*[bBhHlLqQefd]')
-
-# These replicate the struct.pack codes
-# Big-endian
-REPLACEMENTS_BE: Dict[str, str] = {'b': 'int8', 'B': 'uint8',
-                                   'h': 'intbe16', 'H': 'uintbe16',
-                                   'l': 'intbe32', 'L': 'uintbe32',
-                                   'q': 'intbe64', 'Q': 'uintbe64',
-                                   'e': 'floatbe16', 'f': 'floatbe32', 'd': 'floatbe64'}
-# Little-endian
-REPLACEMENTS_LE: Dict[str, str] = {'b': 'int8', 'B': 'uint8',
-                                   'h': 'intle16', 'H': 'uintle16',
-                                   'l': 'intle32', 'L': 'uintle32',
-                                   'q': 'intle64', 'Q': 'uintle64',
-                                   'e': 'floatle16', 'f': 'floatle32', 'd': 'floatle64'}
-
-# Native-endian
-REPLACEMENTS_NE: Dict[str, str] = {'b': 'int8', 'B': 'uint8',
-                                   'h': 'intne16', 'H': 'uintne16',
-                                   'l': 'intne32', 'L': 'uintne32',
-                                   'q': 'intne64', 'Q': 'uintne64',
-                                   'e': 'floatne16', 'f': 'floatne32', 'd': 'floatne64'}
-
-# Size in bytes of all the pack codes.
-PACK_CODE_SIZE: Dict[str, int] = {'b': 1, 'B': 1, 'h': 2, 'H': 2, 'l': 4, 'L': 4,
-                                  'q': 8, 'Q': 8, 'e': 2, 'f': 4, 'd': 8}
-
-
-def structparser(m: Match[str]) -> List[str]:
-    """Parse struct-like format string token into sub-token list."""
-    endian = m.group('endian')
-    # Split the format string into a list of 'q', '4h' etc.
-    formatlist = re.findall(STRUCT_SPLIT_RE, m.group('fmt'))
-    # Now deal with multiplicative factors, 4h -> hhhh etc.
-    fmt = ''.join([f[-1] * int(f[:-1]) if len(f) != 1 else
-                   f for f in formatlist])
-    if endian in '@=':
-        # Native endianness
-        tokens = [REPLACEMENTS_NE[c] for c in fmt]
-    elif endian == '<':
-        tokens = [REPLACEMENTS_LE[c] for c in fmt]
-    else:
-        assert endian == '>'
-        tokens = [REPLACEMENTS_BE[c] for c in fmt]
-    return tokens
-
-@functools.lru_cache(CACHE_SIZE)
-def parse_name_length_token(fmt: str, **kwargs) -> Tuple[str, Optional[int]]:
-    # Any single token with just a name and length
-    if m2 := NAME_INT_RE.match(fmt):
-        name = m2.group(1)
-        length_str = m2.group(2)
-        length = None if length_str == '' else int(length_str)
-    else:
-        # Maybe the length is in the kwargs?
-        if m := NAME_KWARG_RE.match(fmt):
-            name = m.group(1)
-            try:
-                length_str = kwargs[m.group(2)]
-            except KeyError:
-                raise ValueError(f"Can't parse 'name[:]length' token '{fmt}'.")
-            length = int(length_str)
-        else:
-            raise ValueError(f"Can't parse 'name[:]length' token '{fmt}'.")
-    return name, length
-
-@functools.lru_cache(CACHE_SIZE)
-def parse_single_struct_token(fmt: str) -> Optional[Tuple[str, Optional[int]]]:
-    if m := SINGLE_STRUCT_PACK_RE.match(fmt):
-        endian = m.group('endian')
-        f = m.group('fmt')
-        if endian == '>':
-            fmt = REPLACEMENTS_BE[f]
-        elif endian == '<':
-            fmt = REPLACEMENTS_LE[f]
-        else:
-            assert endian in '=@'
-            fmt = REPLACEMENTS_NE[f]
-        return parse_name_length_token(fmt)
-    else:
-        return None
-
-@functools.lru_cache(CACHE_SIZE)
-def parse_single_token(token: str) -> Tuple[str, str, Optional[str]]:
-    if (equals_pos := token.find('=')) == -1:
-        value = None
-    else:
-        value = token[equals_pos + 1:]
-        token = token[:equals_pos]
-
-    if m2 := NAME_INT_RE.match(token):
-        name = m2.group(1)
-        length_str = m2.group(2)
-        length = None if length_str == '' else length_str
-    elif m3 := NAME_KWARG_RE.match(token):
-        # name then a keyword for a length
-        name = m3.group(1)
-        length = m3.group(2)
-    else:
-        # If you don't specify a 'name' then the default is 'bits'
-        name = 'bits'
-        length = token
-    return name, length, value
-
-@functools.lru_cache(CACHE_SIZE)
-def preprocess_tokens(fmt: str) -> List[str]:
-    # Remove whitespace and expand brackets
-    fmt = expand_brackets(''.join(fmt.split()))
-
-    # Split tokens by ',' and remove whitespace
-    # The meta_tokens can either be ordinary single tokens or multiple struct-format token strings.
-    meta_tokens = [f.strip() for f in fmt.split(',')]
-    final_tokens = []
-
-    for meta_token in meta_tokens:
-        if  meta_token == '':
-            continue
-        # Extract factor and actual token if a multiplicative factor exists
-        factor = 1
-        if m := MULTIPLICATIVE_RE.match(meta_token):
-            factor = int(m.group('factor'))
-            meta_token = m.group('token')
-
-        # Parse struct-like format into sub-tokens or treat as single token
-        tokens = structparser(m) if (m := STRUCT_PACK_RE.match(meta_token)) else [meta_token]
-
-        # Extend final tokens list with parsed tokens, repeated by the factor
-        final_tokens.extend(tokens * factor)
-    return final_tokens
-
-
-@functools.lru_cache(CACHE_SIZE)
-def tokenparser(fmt: str, keys: Tuple[str, ...] = ()) -> \
-        Tuple[bool, List[Tuple[str, Union[int, str, None], Optional[str]]]]:
-    """Divide the format string into tokens and parse them.
-
-    Return stretchy token and list of [initialiser, length, value]
-    initialiser is one of: hex, oct, bin, uint, int, se, ue, 0x, 0o, 0b etc.
-    length is None if not known, as is value.
-
-    If the token is in the keyword dictionary (keys) then it counts as a
-    special case and isn't messed with.
-
-    tokens must be of the form: [factor*][initialiser][:][length][=value]
-
-    """
-    tokens = preprocess_tokens(fmt)
-    stretchy_token = False
-    ret_vals: List[Tuple[str, Union[str, int, None], Optional[str]]] = []
-    for token in tokens:
-        if keys and token in keys:
-            # Don't bother parsing it, it's a keyword argument
-            ret_vals.append((token, None, None))
-            continue
-        if token == '':
-            continue
-        # Match literal tokens of the form 0x... 0o... and 0b...
-        if m := LITERAL_RE.match(token):
-            ret_vals.append((m.group('name'), None, m.group('value')))
-            continue
-        name, length, value = parse_single_token(token)
-        if length is None:
-            stretchy_token = True
-        if length is not None:
-            # Try converting length to int, otherwise check it's a key.
-            try:
-                length = int(length)
-            except ValueError:
-                if not keys or length not in keys:
-                    raise ValueError(f"Don't understand length '{length}' of token.")
-        ret_vals.append((name, length, value))
-    return stretchy_token, ret_vals
-
-
-BRACKET_RE = re.compile(r'(?P<factor>\d+)\*\(')
-
-def expand_brackets(s: str) -> str:
-    """Expand all brackets."""
-    while True:
-        start = s.find('(')
-        if start == -1:
-            break
-        count = 1  # Number of hanging open brackets
-        p = start + 1
-        while p < len(s):
-            count += (s[p] == '(') - (s[p] == ')')
-            if count == 0:
-                break
-            p += 1
-        if count != 0:
-            raise ValueError(f"Unbalanced parenthesis in '{s}'.")
-        if start == 0 or s[start - 1] != '*':
-            s = s[0:start] + s[start + 1:p] + s[p + 1:]
-        else:
-            # Looks for first number*(
-            m = BRACKET_RE.search(s)
-            if m:
-                factor = int(m.group('factor'))
-                matchstart = m.start('factor')
-                s = s[0:matchstart] + (factor - 1) * (s[start + 1:p] + ',') + s[start + 1:p] + s[p + 1:]
-            else:
-                raise ValueError(f"Failed to parse '{s}'.")
-    return s
+from __future__ import annotations
+
+import functools
+import re
+from typing import Tuple, List, Optional, Pattern, Dict, Union, Match
+
+
+# A token name followed by optional : then an integer number
+NAME_INT_RE: Pattern[str] = re.compile(r'^([a-zA-Z][a-zA-Z0-9_]*?):?(\d*)$')
+
+# A token name followed by optional : then an arbitrary keyword
+NAME_KWARG_RE: Pattern[str] = re.compile(r'^([a-zA-Z][a-zA-Z0-9_]*?):?([a-zA-Z0-9_]+)$')
+
+CACHE_SIZE = 256
+
+DEFAULT_BITS: Pattern[str] = re.compile(r'^(?P<len>[^=]+)?(=(?P<value>.*))?$', re.IGNORECASE)
+
+MULTIPLICATIVE_RE: Pattern[str] = re.compile(r'^(?P<factor>.*)\*(?P<token>.+)')
+
+# Hex, oct or binary literals
+LITERAL_RE: Pattern[str] = re.compile(r'^(?P<name>0([xob]))(?P<value>.+)', re.IGNORECASE)
+
+# An endianness indicator followed by one or more struct.pack codes
+STRUCT_PACK_RE: Pattern[str] = re.compile(r'^(?P<endian>[<>@=]){1}(?P<fmt>(?:\d*[bBhHlLqQefd])+)$')
+# The same as above, but it doesn't insist on an endianness as it's byteswapping anyway.
+BYTESWAP_STRUCT_PACK_RE: Pattern[str] = re.compile(r'^(?P<endian>[<>@=])?(?P<fmt>(?:\d*[bBhHlLqQefd])+)$')
+# An endianness indicator followed by exactly one struct.pack codes
+SINGLE_STRUCT_PACK_RE: Pattern[str] = re.compile(r'^(?P<endian>[<>@=]){1}(?P<fmt>[bBhHlLqQefd])$')
+
+# A number followed by a single character struct.pack code
+STRUCT_SPLIT_RE: Pattern[str] = re.compile(r'\d*[bBhHlLqQefd]')
+
+# These replicate the struct.pack codes
+# Big-endian
+REPLACEMENTS_BE: Dict[str, str] = {'b': 'int8', 'B': 'uint8',
+                                   'h': 'intbe16', 'H': 'uintbe16',
+                                   'l': 'intbe32', 'L': 'uintbe32',
+                                   'q': 'intbe64', 'Q': 'uintbe64',
+                                   'e': 'floatbe16', 'f': 'floatbe32', 'd': 'floatbe64'}
+# Little-endian
+REPLACEMENTS_LE: Dict[str, str] = {'b': 'int8', 'B': 'uint8',
+                                   'h': 'intle16', 'H': 'uintle16',
+                                   'l': 'intle32', 'L': 'uintle32',
+                                   'q': 'intle64', 'Q': 'uintle64',
+                                   'e': 'floatle16', 'f': 'floatle32', 'd': 'floatle64'}
+
+# Native-endian
+REPLACEMENTS_NE: Dict[str, str] = {'b': 'int8', 'B': 'uint8',
+                                   'h': 'intne16', 'H': 'uintne16',
+                                   'l': 'intne32', 'L': 'uintne32',
+                                   'q': 'intne64', 'Q': 'uintne64',
+                                   'e': 'floatne16', 'f': 'floatne32', 'd': 'floatne64'}
+
+# Size in bytes of all the pack codes.
+PACK_CODE_SIZE: Dict[str, int] = {'b': 1, 'B': 1, 'h': 2, 'H': 2, 'l': 4, 'L': 4,
+                                  'q': 8, 'Q': 8, 'e': 2, 'f': 4, 'd': 8}
+
+
+def structparser(m: Match[str]) -> List[str]:
+    """Parse struct-like format string token into sub-token list."""
+    endian = m.group('endian')
+    # Split the format string into a list of 'q', '4h' etc.
+    formatlist = re.findall(STRUCT_SPLIT_RE, m.group('fmt'))
+    # Now deal with multiplicative factors, 4h -> hhhh etc.
+    fmt = ''.join([f[-1] * int(f[:-1]) if len(f) != 1 else
+                   f for f in formatlist])
+    if endian in '@=':
+        # Native endianness
+        tokens = [REPLACEMENTS_NE[c] for c in fmt]
+    elif endian == '<':
+        tokens = [REPLACEMENTS_LE[c] for c in fmt]
+    else:
+        assert endian == '>'
+        tokens = [REPLACEMENTS_BE[c] for c in fmt]
+    return tokens
+
+@functools.lru_cache(CACHE_SIZE)
+def parse_name_length_token(fmt: str, **kwargs) -> Tuple[str, Optional[int]]:
+    # Any single token with just a name and length
+    if m2 := NAME_INT_RE.match(fmt):
+        name = m2.group(1)
+        length_str = m2.group(2)
+        length = None if length_str == '' else int(length_str)
+    else:
+        # Maybe the length is in the kwargs?
+        if m := NAME_KWARG_RE.match(fmt):
+            name = m.group(1)
+            try:
+                length_str = kwargs[m.group(2)]
+            except KeyError:
+                raise ValueError(f"Can't parse 'name[:]length' token '{fmt}'.")
+            length = int(length_str)
+        else:
+            raise ValueError(f"Can't parse 'name[:]length' token '{fmt}'.")
+    return name, length
+
+@functools.lru_cache(CACHE_SIZE)
+def parse_single_struct_token(fmt: str) -> Optional[Tuple[str, Optional[int]]]:
+    if m := SINGLE_STRUCT_PACK_RE.match(fmt):
+        endian = m.group('endian')
+        f = m.group('fmt')
+        if endian == '>':
+            fmt = REPLACEMENTS_BE[f]
+        elif endian == '<':
+            fmt = REPLACEMENTS_LE[f]
+        else:
+            assert endian in '=@'
+            fmt = REPLACEMENTS_NE[f]
+        return parse_name_length_token(fmt)
+    else:
+        return None
+
+@functools.lru_cache(CACHE_SIZE)
+def parse_single_token(token: str) -> Tuple[str, str, Optional[str]]:
+    if (equals_pos := token.find('=')) == -1:
+        value = None
+    else:
+        value = token[equals_pos + 1:]
+        token = token[:equals_pos]
+
+    if m2 := NAME_INT_RE.match(token):
+        name = m2.group(1)
+        length_str = m2.group(2)
+        length = None if length_str == '' else length_str
+    elif m3 := NAME_KWARG_RE.match(token):
+        # name then a keyword for a length
+        name = m3.group(1)
+        length = m3.group(2)
+    else:
+        # If you don't specify a 'name' then the default is 'bits'
+        name = 'bits'
+        length = token
+    return name, length, value
+
+@functools.lru_cache(CACHE_SIZE)
+def preprocess_tokens(fmt: str) -> List[str]:
+    # Remove whitespace and expand brackets
+    fmt = expand_brackets(''.join(fmt.split()))
+
+    # Split tokens by ',' and remove whitespace
+    # The meta_tokens can either be ordinary single tokens or multiple struct-format token strings.
+    meta_tokens = [f.strip() for f in fmt.split(',')]
+    final_tokens = []
+
+    for meta_token in meta_tokens:
+        if  meta_token == '':
+            continue
+        # Extract factor and actual token if a multiplicative factor exists
+        factor = 1
+        if m := MULTIPLICATIVE_RE.match(meta_token):
+            factor = int(m.group('factor'))
+            meta_token = m.group('token')
+
+        # Parse struct-like format into sub-tokens or treat as single token
+        tokens = structparser(m) if (m := STRUCT_PACK_RE.match(meta_token)) else [meta_token]
+
+        # Extend final tokens list with parsed tokens, repeated by the factor
+        final_tokens.extend(tokens * factor)
+    return final_tokens
+
+
+@functools.lru_cache(CACHE_SIZE)
+def tokenparser(fmt: str, keys: Tuple[str, ...] = ()) -> \
+        Tuple[bool, List[Tuple[str, Union[int, str, None], Optional[str]]]]:
+    """Divide the format string into tokens and parse them.
+
+    Return stretchy token and list of [initialiser, length, value]
+    initialiser is one of: hex, oct, bin, uint, int, se, ue, 0x, 0o, 0b etc.
+    length is None if not known, as is value.
+
+    If the token is in the keyword dictionary (keys) then it counts as a
+    special case and isn't messed with.
+
+    tokens must be of the form: [factor*][initialiser][:][length][=value]
+
+    """
+    tokens = preprocess_tokens(fmt)
+    stretchy_token = False
+    ret_vals: List[Tuple[str, Union[str, int, None], Optional[str]]] = []
+    for token in tokens:
+        if keys and token in keys:
+            # Don't bother parsing it, it's a keyword argument
+            ret_vals.append((token, None, None))
+            continue
+        if token == '':
+            continue
+        # Match literal tokens of the form 0x... 0o... and 0b...
+        if m := LITERAL_RE.match(token):
+            ret_vals.append((m.group('name'), None, m.group('value')))
+            continue
+        name, length, value = parse_single_token(token)
+        if length is None:
+            stretchy_token = True
+        if length is not None:
+            # Try converting length to int, otherwise check it's a key.
+            try:
+                length = int(length)
+            except ValueError:
+                if not keys or length not in keys:
+                    raise ValueError(f"Don't understand length '{length}' of token.")
+        ret_vals.append((name, length, value))
+    return stretchy_token, ret_vals
+
+
+BRACKET_RE = re.compile(r'(?P<factor>\d+)\*\(')
+
+def expand_brackets(s: str) -> str:
+    """Expand all brackets."""
+    while True:
+        start = s.find('(')
+        if start == -1:
+            break
+        count = 1  # Number of hanging open brackets
+        p = start + 1
+        while p < len(s):
+            count += (s[p] == '(') - (s[p] == ')')
+            if count == 0:
+                break
+            p += 1
+        if count != 0:
+            raise ValueError(f"Unbalanced parenthesis in '{s}'.")
+        if start == 0 or s[start - 1] != '*':
+            s = s[0:start] + s[start + 1:p] + s[p + 1:]
+        else:
+            # Looks for first number*(
+            m = BRACKET_RE.search(s)
+            if m:
+                factor = int(m.group('factor'))
+                matchstart = m.start('factor')
+                s = s[0:matchstart] + (factor - 1) * (s[start + 1:p] + ',') + s[start + 1:p] + s[p + 1:]
+            else:
+                raise ValueError(f"Failed to parse '{s}'.")
+    return s
```

### Comparing `bitstring-4.2.1/bitstring.egg-info/PKG-INFO` & `bitstring-4.2.2/bitstring.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: bitstring
-Version: 4.2.1
+Version: 4.2.2
 Summary: Simple construction, analysis and modification of binary data.
 Author-email: Scott Griffiths <dr.scottgriffiths@gmail.com>
 Project-URL: homepage, https://github.com/scott-griffiths/bitstring
 Project-URL: documentation, https://bitstring.readthedocs.io/
 Keywords: binary,bitarray,bitvector,bitfield
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
@@ -39,15 +39,15 @@
 &nbsp; &nbsp;
 [![Pepy Total Downlods](https://img.shields.io/pepy/dt/bitstring?logo=python&logoColor=white&labelColor=blue&color=blue)](https://www.pepy.tech/projects/bitstring)
 [![PyPI - Downloads](https://img.shields.io/pypi/dm/bitstring?label=%40&labelColor=blue&color=blue)](https://pypistats.org/packages/bitstring)
 
 
 News
 ----
-**April 2024**: bitstring 4.2.1 released.
+**May 2024**: bitstring 4.2.2 released.
  
 New in version 4.2:
 
 * Dropped support for Python 3.7. Minimum version is now 3.8.
 * A new `Dtype` class can be optionally used to specify types.
 * The `bitstring.options` object is now the preferred method for changing module options.
 * New `fromstring` method as another way to create bitstrings from formatted strings.
```

### Comparing `bitstring-4.2.1/bitstring.egg-info/SOURCES.txt` & `bitstring-4.2.2/bitstring.egg-info/SOURCES.txt`

 * *Files identical despite different names*

### Comparing `bitstring-4.2.1/release_notes.txt` & `bitstring-4.2.2/release_notes.txt`

 * *Files 11% similar despite different names*

```diff
@@ -1,1919 +1,1930 @@
---------------------------------
-bitstring module version history
---------------------------------
-
--------------------------
-April 2024: version 4.2.1
--------------------------
-Fixing a few regressions introduced in 4.2.0.
-
-* Module crashes on import with 32-bit Python. Bug #317.
-* Lists of integers not converted to bytes when using the bytes constructor. Bug #318.
-* Empty comma separated tokens not handled correctly. Bug #319.
-* Crash on import when docstrings not present due to optimize flag. Bug #321.
-
--------------------------
-April 2024: version 4.2.0
--------------------------
-
-This release contains a fairly large refactor of how different types are managed. This
-shouldn't affect the end user, and the main noticeable change should be the new Dtype
-class, which is optional to use.
-
-Support for 8-bit and smaller floats has been reworked and expanded. These are still
-a 'beta' feature.
-
-Backwardly incompatible changes:
-
-* Dropped support for Python 3.7. Minimum version is now 3.8.
-* For tokens that use a non-numeric length, a ':' is now compulsory rather than
-  recommended. For example use 'uint:foo' instead of 'uintfoo'.
-* The previous e4m3float and e5m2float formats have become the slightly modified
-  p4binary8 and p3binary8 formats.
-* Some parameters are now enforced as positional only, such as `auto` in constructors.
-
-Other changes:
-
-* The Array class is no longer 'beta'.
-
-* A new Dtype class can be optionally used to specify types.
-
-* The bitstring.options object is now the preferred method for changing module options.
-  The `bitstring.lsb0` and `bitstring.bytealigned` variables are now deprecated, use
-  `bitstring.options.lsb0` and `bitstring.options.bytealigned` instead.
-
-* New fromstring method as another way to create bitstrings from formatted strings.
-  Instead of relying on the `auto` parameter you can now optionally use `fromstring`.
-  >>> s1 = BitArray('u24=1000')  # This is still fine
-  >>> s2 = BitArray.fromstring('u24=1000')  # This may be clearer and more efficient.
-
-* More types can now be pretty printed. For example integer and float formats can be used.
-  >>> s.pp('u15, bin')
-
-* Pretty printing is now prettier - optional terminal colours added.
-
-* A range of 8-bit, 6-bit and even 4-bit float formats added (beta):
-  p3binary8: IEEE 8-bit floating point with 3 bit precision.
-  p4binary8: IEEE 8-bit floating point with 4 bit precision.
-  e5m2mxfp: OCP 8-bit floating point with 3 bit precision.
-  e4m3mxfp: OCP 8-bit floating point with 4 bit precision.
-  e2m3mxfp: OCP 6-bit floating point with 4 bit precision.
-  e3m2mxfp: OCP 6-bit floating point with 3 bit precision.
-  e2m1mxfp: OCP 4-bit floating point with 2 bit precision.
-  e8m0mxfp: OCP 8-bit unsigned floating point designed to scale the other formats.
-  mxint: OCP 8-bit floating point that is a scaled integer representation.
-
-* Performance improvements.
-
-----------------------------
-November 2023: version 4.1.4
-----------------------------
-Fixing a regression introduced in 4.1.3
-
-* 'bytes' token can't be used without explicit length. Bug #303.
-
-----------------------------
-November 2023: version 4.1.3
-----------------------------
-A maintenance release, with some changes to the beta features introduced in 4.1.
-
-* Removed a couple of files that accidentally got included in the previous release. Bug #293.
-* The 8-bit float formats have been renamed 'e4m3float' and 'e5m2float'.
-* Some refactoring and performance optimizations.
-
---------------------------------------
-September 2023: version 4.1.2 released
---------------------------------------
-Another maintenance release. Once again some small changes to the 'beta' Array class,
-plus new Array functionality.
-
-* Fix for the module command-line usage. Bug #290.
-* Fix for when creating bitstrings from memoryview objects.
-* Renamed the 'fmt' parameter for Arrays to 'dtype'.
-* More Array operator coverage.
-* Added operators that act on two Arrays of the same size.
-* Added comparison operators for Arrays that return an Array of bools.
-* Added Array.equals method as == will now return an Array (see above item).
-* Added astype() method for Arrays to easily cast to a new dtype.
-
------------------------------------
-August 2023: version 4.1.1 released
------------------------------------
-A maintenance release, with some changes to the Array class which is still in 'beta'.
-
-* bitarray dependency now pinned to ">=2.8.0, <3.0.0" rather than a specific version. Bug #283.
-* Fix for using numpy integers as integer parameters. Bug #286.
-* Removed ability to extend an Array with the '+' operator. Use the 'extend' method instead.
-* Improvements when pretty-printing the Array.
-* Array.count() can now count 'nan' values for floating point types.
-
------------------------------------
-August 2023: version 4.1.0 released
------------------------------------
-
-This has turned into a surprisingly big release, with a major refactor and a brand new
-class (the first for 12 years!) There are also a couple of small possibly breaking changes
-detailed below, in particular 'auto' initialising bitstrings from integers is now disallowed.
-
-* Speed increased with bitarray dependency.
-
-The major weakness of bitstring has been its poor performance for computationally
-intensive tasks relative to lower level alternatives. This was principally due to
-relying on pure Python code to achieve things that the base language often didn't have
-fast ways of doing.
-
-This release starts to address that problem with a fairly extensive rewrite to replace
-much of the pure Python low-level bit operations with methods from the bitarray package.
-This is a package that does many of the same things as bitstring, and the two packages
-have co-existed for a long time. While bitarray doesn't have all of the options and
-facilities of bitstring it has the advantage of being very fast as it is implemented in C.
-By replacing the internal datatypes I can speed up bitstring's operations while keeping
-the same API.
-
-Huge kudos to Ilan Schnell for all his work on bitarray.
-
-* New Array class for homogeneous data (beta)
-
-If your data is all of the same type you can make use of the new Array class, which
-mirrors much of the functionality of the standard array.array type, but doesn't restrict
-you to just a dozen formats.
-
-  >>> from bitstring import Array
-  >>> a = Array('uint7', [9, 100, 3, 1])
-  >>> a.data
-  BitArray('0x1390181')
-  >>> b = Array('float16', a.tolist())
-  >>> b.append(0.25)
-  >>> b.tobytes()
-  b'H\x80V@B\x00<\x004\x00'
-  >>> b.tolist()
-  [9.0, 100.0, 3.0, 1.0, 0.25]
-
-The data is stored efficiently in a BitArray object, and you can manipulate both the
-data and the Array format freely. See the main documentation for more details. Note that
-this feature carries the 'beta' flag so may change in future point versions.
-
-Other changes:
-
-* Added two new floating point interpretations: float8_143 and float8_152. These are 8-bit
-  floating point formats, with very limited range and precision, but useful in some fields,
-  particularly machine learning. This is an experimental feature - the formats haven't
-  even been standardised yet.
-
-  >>> a = Bits(float8_143=16.5)
-  >>> a.bin
-  '01100000'
-  >>> a.float8_143
-  16.0
-
-* Auto initialization from ints has been removed and now raises a TypeError. Creating a
-  bitstring from an int still creates a zeroed bitstring of that length but ints won't
-  be promoted to bitstrings as that has been a constant source of errors and confusion.
-
-  >>> a = BitArray(100)  # Fine - create with 100 zeroed bits
-  >>> a += 0xff   # TypeError - previously this would have appended 0xff (=255) zero bits.
-  >>> a += '0xff'  # Probably what was meant - append eight '1' bits.
-  >>> a += Bits(255)  # Fine, append 255 zero bits.
-
-  This is a breaking change, but it breaks loudly with an exception, it is easily recoded,
-  and it removes a confusing wrinkle.
-
-* Explicitly specifying the 'auto' parameter is now disallowed rather than discouraged.
-  It was always meant to be a positional-only parameter (and will be once I can drop
-  Python 3.7 support) but for now it's renamed to '__auto'. In the unlikely event
-  this breaks code, the fix should be just to delete the 'auto=' if it's already the
-  first parameter.
-
-  >>> s = Bits(auto='0xff')  # Now raises a CreationError
-  >>> s = Bits('0xff')  # Fine, as always
-
-* Deleting, replacing or inserting into a bitstring resets the bit position to 0 if the
-  bitstring's length has been changed. Previously the bit position was adjusted but
-  this was not well defined.
-
-* Only empty bitstring are now considered False in a boolean sense. Previously s was
-  False is no bits in s were set to 1, but this goes against what it means to be a
-  container in Python so I consider this to be a bug, even if it was documented. I'm
-  guessing it's related to __nonzero__ in Python 2 becoming __bool__ in Python 3, and
-  it's never been fixed before now.
-
-* Casting to bytes now behaves as expected, so that bytes(s) gives the same result as
-  s.tobytes(). Previously it created a byte per bit.
-
-* Pretty printing with the 'bytes' format now uses characters from the 'Latin Extended-A'
-  unicode block for non-ASCII and unprintable characters instead of replacing them with '.'
-
-* When using struct-like codes you can now use '=' instead of '@' to signify native-
-  endianness. They behave identically, but the new '=' is now preferred.
-
-* More fixes for LSB0 mode. There are now no known issues with this feature.
-
-----------------------------------
-April 2023: version 4.0.2 released
-----------------------------------
-A maintenance release.
-
-* Added py.typed file and converted the module to a package to let mypy find type
-  annotations. Bug 248.
-* Fix to shifting operations when using LSB0 mode. Bug 251.
-* A few more fixes for LSB0 mode.
-* Improved LSB0 documentation.
-* Added build-system section to pyproject.toml. Bug 243.
-* Rewrote the walkthrough documentation as a jupyter notebook.
-* Updated the project's logo.
-
--------------------------------------
-November 2022: version 4.0.1 released
--------------------------------------
-
-This is a major release which drops support for Python 2.7 and has a new minimum
-requirement of Python 3.7. Around 95% of downloads satisfy this - users of
-older versions can continue to use bitstring 3.1, which will still be supported
-with fixes, but no new features.
-
-Other breaking changes are minimal, and there are a few cool features added.
-
-Breaking changes:
-
-* Minimum supported Python version is now Python 3.7.
-* Removed ConstBitArray and BitString class aliases. Use Bits and BitStream instead.
-* The cut() method will now also yield the final bits of a bitstring, even if they
-  are shorter than the requested cut size.
-* Removed default uint interpretation. This wasn't being applied uniformly - default
-  is now always to return a bitstring object of the given length and not to interpret
-  it as a uint. Bug 220.
-* If an overwrite goes beyond the end of the bitstring it will now extend the bitstring
-  rather than raise an exception. Bug 148.
-
-New features and improvements:
-
-* Type hints added throughout the code.
-* Underscores are now allowed in strings representing number literals.
-* The copy() method now works on Bits as well as BitArray objects.
-* The experimental command-line feature is now official. Command-line
-  parameters are concatenated and a bitstring created from them. If
-  the final parameter is either an interpretation string or ends with
-  a '.' followed by an interpretation string then that interpretation
-  of the bitstring will be used when printing it.
-
-  $ python -m bitstring int:16=-400
-  0xfe70
-  $ python -m bitstring float:32=0.2 bin
-  00111110010011001100110011001101
-
-* New pp() method that pretty-prints the bitstring in various formats - useful
-  especially in interactive sessions. Thanks to Omer Barak for the suggestion
-  and discussion.
-
-  >>> s.pp()
-    0: 10001000 01110110 10001110 01110110 11111000 01110110 10000111 00101000
-   64: 01110010 11111001 10000111 10011000 11110111 10011110 10000111 11111101
-  128: 11111001 10001100 01111111 10111100 10111111 11011011 11101011 11111011
-  192: 1100
-  >>> s.pp('bin, hex')
-    0: 10001000 01110110 10001110 01110110 11111000 01110110   88 76 8e 76 f8 76
-   48: 10000111 00101000 01110010 11111001 10000111 10011000   87 28 72 f9 87 98
-   96: 11110111 10011110 10000111 11111101 11111001 10001100   f7 9e 87 fd f9 8c
-  144: 01111111 10111100 10111111 11011011 11101011 11111011   7f bc bf db eb fb
-  192: 1100                                                    c
-
-* Shorter and more versatile properties. The bin, oct, hex, float, uint and int
-  properties can now be shortened to just their first letter. They can also have
-  a length in bits after them - allowing Rust-like data types. ::
-
-      >>> s = BitArray('0x44961000')
-      >>> s.h
-      '44961000'
-      >>> s.f32
-      1200.5
-      >>> s.u
-      1150685184
-      >>> s.i7 = -60
-      >>> s.b
-      '1000100'
-      >>> t = Bits('u12=160, u12=120, b=100')
-
-* Other types with bit lengths can also be used as properties ::
-
-      >>> s.floatle64 = 10.511
-
-* A colon is no longer required in format strings before a bit length. So for
-  example `Bits('int:15=-101')` could be written as `Bits('int15=-101')`. This is
-  now the preferred usage in the documentation except where the colon improves
-  readability.
-
-* Support for IEEE 16 bit floats. Floating point types can now be 16 bits long as well
-  as 32 and 64 bits. This is using the 'e' format from the struct module.
-
-* Support for bfloats. This is a specialised 16-bit floating point format
-  mostly used in machine learning. It's essentially a truncated IEEE 32-bit
-  format that keeps its range but only has a couple of signficant figures of
-  accuracy.
-
-
----------------------------------------
-July 20th 2021: version 3.1.9 released
----------------------------------------
-(version 3.1.8 was pulled due to serious issues)
-Another maintenance release.
-
-* Fixed a couple of outdated results in the readme (Issue 214).
-* Some more documentation tidying.
-* Turned off some debug code by default.
-* Fixed a couple of failing tests in different Python versions.
-* Fix for consistent pos initialisation semantics for different types.
-* Change to allow wheels to be uploaded to PyPI.
-* More work for LSB0 mode, but still not finished or documented (sorry).
-
----------------------------------------
-May 5th 2020: version 3.1.7 released
----------------------------------------
-This is a maintenance release with a few bug fixes plus an experimental
-feature to allow bits to be indexed in the opposite direction.
-
-* Fixing del not working correctly when stop value negative (Issue 201)
-* Removed deprecated direct import of ABC from collections module (Issue 196)
-* Tested and added explicit support for Python 3.7 and 3.8. (Issue 193)
-* Fixing a few stale links to documentation. (Issue 194)
-* Allowing initialisation with an io.BytesIO object. (Issue 189)
-
-Experimental LSB0 mode
-----------------------
-This feature allows bitstring to use Least Significant Bit Zero
-(LSB0) bit numbering; that is the final bit in the bitstring will
-be bit 0, and the first bit will be bit (n-1), rather than the
-other way around. LSB0 is a more natural numbering
-system in many fields, but is the opposite to Most Significant Bit
-Zero (MSB0) numbering which is the natural option when thinking of
-bitstrings as standard Python containers.
-
-To switch from the default MSB0, use the module level function
-
-    >>> bitstring.set_lsb0(True)
-
-Getting and setting bits should work in this release, as will some
-other methods. Many other methods are not tested yet and might not
-work as expected. This is mostly a release to get feedback before
-finalising the interface.
-
-Slicing is still done with the start bit smaller than the end bit.
-For example:
-
-    >>> s = Bits('0b000000111')
-    >>> s[0:5]
-    Bits('0b00111')
-    >>> s[0]
-    True
-
-Negative indices work as (hopefully) you'd expect, with the first stored
-bit being `s[-1]` and the final stored bit being `s[-n]`.
-
-See https://github.com/scott-griffiths/bitstring/issues/156 for
-discussions and to add any further comments.
-
----------------------------------------
-July 9th 2019: version 3.1.6 released
----------------------------------------
-A long overdue maintenance release with some fixes.
-
-* Fixed immutability bug. Bug 176. 
-* Fixed failure of `__contains__` in some circumstances. Bug 180.
-* Better handling of open files. Bug 186.
-* Better Python 2/3 check.
-* Making unit tests easier to run.
-* Allowing length of 1 to be specified for bools. (Thanks to LemonPi)
-
----------------------------------------
-May 17th 2016: version 3.1.5 released
----------------------------------------
-
-* Support initialisation from an array.
-* Added a separate LICENSE file.
-
----------------------------------------
-March 19th 2016: version 3.1.4 released
----------------------------------------
-This is another bug fix release.
-
-* Fix for bitstring types when created directly from other bitstring types.
-* Updating contact, website details.
-
----------------------------------------
-March 4th 2014: version 3.1.3 released
----------------------------------------
-This is another bug fix release.
-
-* Fix for problem with prepend for bitstrings with byte offsets in their data store.
-
----------------------------------------
-April 18th 2013: version 3.1.2 released
----------------------------------------
-This is another bug fix release.
-
-* Fix for problem where unpacking bytes would by eight times too long
-
----------------------------------------
-March 21st 2013: version 3.1.1 released
----------------------------------------
-This is a bug fix release.
-
-* Fix for problem where concatenating bitstrings sometimes modified method's arguments
-
-------------------------------------------
-February 26th 2013: version 3.1.0 released
-------------------------------------------
-This is a minor release with a couple of new features and some bug fixes.
-
-New 'pad' token
----------------
-
-This token can be used in reads and when packing/unpacking to indicate that
-you don't care about the contents of these bits. Any padding bits will just
-be skipped over when reading/unpacking or zero-filled when packing.
-
-    >>> a, b = s.readlist('pad:5, uint:3, pad:1, uint:3')
-
-Here only two items are returned in the list - the padding bits are ignored.
-
-New clear and copy convenience methods
---------------------------------------
-
-These methods have been introduced in Python 3.3 for lists and bytearrays,
-as more obvious ways of clearing and copying, and we mirror that change here.
-
-t = s.copy() is equivalent to t = s[:], and s.clear() is equivalent to del s[:].
-
-Other changes
--------------
-
-* Some bug fixes.
-
------------------------------------------
-February 7th 2012: version 3.0.2 released
------------------------------------------
-This is a minor update that fixes a few bugs.
-
-* Fix for subclasses of bitstring classes behaving strangely (Issue 121).
-* Fix for excessive memory usage in rare cases (Issue 120).
-* Fixes for slicing edge cases.
-
-There has also been a reorganisation of the code to return it to a single
-'bitstring.py' file rather than the package that has been used for the past
-several releases. This change shouldn't affect users directly.
-
-------------------------------------------
-November 21st 2011: version 3.0.1 released
-------------------------------------------
-This release fixed a small but very visible bug in bitstring printing.
-
-------------------------------------------
-November 21st 2011: version 3.0.0 released
-------------------------------------------
-This is a major release which breaks backward compatibility in a few places.
-
-Backwardly incompatible changes
-===============================
-
-Hex, oct and bin properties don't have leading 0x, 0o and 0b
-------------------------------------------------------------
-
-If you ask for the hex, octal or binary representations of a bitstring then
-they will no longer be prefixed with '0x', 0o' or '0b'. This was done as it
-was noticed that the first thing a lot of user code does after getting these
-representations was to cut off the first two characters before further
-processing.
-
-    >>> a = BitArray('0x123')
-    >>> a.hex, a.oct, a.bin
-    ('123', '0443', '000100100011')
-
-Previously this would have returned ('0x123', '0o0443', '0b000100100011')
-
-This change might require some recoding, but it should all be simplifications.
-
-ConstBitArray renamed to Bits
------------------------------
-
-Previously Bits was an alias for ConstBitStream (for backward compatibility).
-This has now changed so that Bits and BitArray loosely correspond to the
-built-in types bytes and bytearray.
-
-If you were using streaming/reading methods on a Bits object then you will
-have to change it to a ConstBitStream.
-
-The ConstBitArray name is kept as an alias for Bits.
-
-Stepping in slices has conventional meaning
--------------------------------------------
-
-The step parameter in __getitem__, __setitem__ and __delitem__ used to act
-as a multiplier for the start and stop parameters. No one seemed to use it
-though and so it has now reverted to the conventional meaning for containers.
-
-If you are using step then recoding is simple: s[a:b:c] becomes s[a*c:b*c].
-
-Some examples of the new usage:
-
-    >>> s = BitArray('0x0000')
-    s[::4] = [1, 1, 1, 1]
-    >>> s.hex
-    '8888'
-    >>> del s[8::2]
-    >>> s.hex
-    '880'
-
-
-New features
-============
-
-New readto method
------------------
-
-This method is a mix between a find and a read - it searches for a bitstring
-and then reads up to and including it. For example:
-
-    >>> s = ConstBitStream('0x47000102034704050647')
-    >>> s.readto('0x47', bytealigned=True)
-    BitStream('0x47')
-    >>> s.readto('0x47', bytealigned=True)
-    BitStream('0x0001020347')
-    >>> s.readto('0x47', bytealigned=True)
-    BitStream('0x04050647')
-
-pack function accepts an iterable as its format
------------------------------------------------
-
-Previously only a string was accepted as the format in the pack function.
-This was an oversight as it broke the symmetry between pack and unpack.
-Now you can use formats like this:
-
-    fmt = ['hex:8', 'bin:3']
-    a = pack(fmt, '47', '001')
-    a.unpack(fmt)
-
-
---------------------------------------
-June 18th 2011: version 2.2.0 released
---------------------------------------
-This is a minor upgrade with a couple of new features.
-
-New interleaved exponential-Golomb interpretations
---------------------------------------------------
-
-New bit interpretations for interleaved exponential-Golomb (as used in the
-Dirac video codec) are supplied via 'uie' and 'sie':
-
-    >>> s = BitArray(uie=41)
-    >>> s.uie
-    41
-    >>> s.bin
-    '0b00010001001'
-
-These are pretty similar to the non-interleaved versions - see the manual
-for more details. Credit goes to Paul Sargent for the patch.
-
-New package-level bytealigned variable
---------------------------------------
-
-A number of methods take a 'bytealigned' parameter to indicate that they
-should only work on byte boundaries (e.g. find, replace, split). Previously
-this parameter defaulted to 'False'. Instead it now defaults to
-'bitstring.bytealigned', which itself defaults to 'False', but can be changed
-to modify the default behaviour of the methods. For example:
-
-    >>> a = BitArray('0x00 ff 0f ff')
-    >>> a.find('0x0f')
-    (4,)    # found first not on a byte boundary
-    >>> a.find('0x0f', bytealigned=True)
-    (16,)   # forced looking only on byte boundaries
-    >>> bitstring.bytealigned = True  # Change default behaviour
-    >>> a.find('0x0f')
-    (16,)
-    >>> a.find('0x0f', bytealigned=False)
-    (4,)
-
-If you're only working with bytes then this can help avoid some errors and
-save some typing!
-
-Other changes
--------------
-
-* Fix for Python 3.2, correcting for a change to the binascii module.
-* Fix for bool initialisation from 0 or 1.
-* Efficiency improvements, including interning strategy.
-
-------------------------------------------
-February 23rd 2011: version 2.1.1 released
-------------------------------------------
-This is a release to fix a couple of bugs that were introduced in 2.1.0.
-
-* Bug fix: Reading using the 'bytes' token had been broken (Issue 102).
-* Fixed problem using some methods on ConstBitArrays.
-* Better exception handling for tokens missing values.
-* Some performance improvements.
-
------------------------------------------
-January 23rd 2011: version 2.1.0 released
------------------------------------------
-
-New class hierarchy introduced with simpler classes
----------------------------------------------------
-Previously there were just two classes, the immutable Bits which was the base
-class for the mutable BitString class. Both of these classes have the concept
-of a bit position, from which reads etc. take place so that the bitstring could
-be treated as if it were a file or stream.
-
-Two simpler classes have now been added which are purely bit containers and 
-don't have a bit position. These are called ConstBitArray and BitArray. As you
-can guess the former is an immutable version of the latter.
-
-The other classes have also been renamed to better reflect their capabilities.
-Instead of BitString you can use BitStream, and instead of Bits you can use
-ConstBitStream. The old names are kept as aliases for backward compatibility.
-
-The classes hierarchy is:
-
-        ConstBitArray
-           /    \
-          /      \
-    BitArray   ConstBitStream (formerly Bits)
-          \      /
-           \    /
-          BitStream (formerly BitString)
-
-
-Other changes
--------------
-A lot of internal reorganisation has taken place since the previous version,
-most of which won't be noticed by the end user. Some things you might see are:
-
-* New package structure. Previous versions have been a single file for the
-  module and another for the unit tests. The module is now split into many
-  more files so it can't be used just by copying bitstring.py any more.
-* To run the unit tests there is now a script called runtests.py in the test
-  directory.
-* File based bitstring are now implemented in terms of an mmap. This should
-  be just an implementation detail, but unfortunately for 32-bit versions of
-  Python this creates a limit of 4GB on the files that can be used. The work
-  around is either to get a 64-bit Python, or just stick with version 2.0.
-* The ConstBitArray and ConstBitStream classes no longer copy byte data when
-  a slice or a read takes place, they just take a reference. This is mostly
-  a very nice optimisation, but there are occasions where it could have an
-  adverse effect. For example if a very large bitstring is created, a small
-  slice taken and the original deleted. The byte data from the large
-  bitstring would still be retained in memory.
-* Optimisations. Once again this version should be faster than the last.
-  The module is still pure Python but some of the reorganisation was to make
-  it more feasible to put some of the code into Cython or similar, so
-  hopefully more speed will be on the way.
-
---------------------------------------
-July 26th 2010: version 2.0.3 released
---------------------------------------
-* Bug fix: Using peek and read for a single bit now returns a new bitstring
-           as was intended, rather than the old behaviour of returning a bool.
-* Removed HTML docs from source archive - better to use the online version.
-
---------------------------------------
-July 25th 2010: version 2.0.2 released
---------------------------------------
-This is a major release, with a number of backwardly incompatible changes.
-The main change is the removal of many methods, all of which have simple
-alternatives. Other changes are quite minor but may need some recoding.
-
-There are a few new features, most of which have been made to help the
-stream-lining of the API. As always there are performance improvements and
-some API changes were made purely with future performance in mind.
-
-The backwardly incompatible changes are:
------------------------------------------
-* Methods removed.
-
-About half of the class methods have been removed from the API. They all have
-simple alternatives, so what remains is more powerful and easier to remember.
-The removed methods are listed here on the left, with their equivalent
-replacements on the right:
-
-s.advancebit()              ->   s.pos += 1
-s.advancebits(bits)         ->   s.pos += bits
-s.advancebyte()             ->   s.pos += 8
-s.advancebytes(bytes)       ->   s.pos += 8*bytes
-s.allunset([a, b])          ->   s.all(False, [a, b])
-s.anyunset([a, b])          ->   s.any(False, [a, b])
-s.delete(bits, pos)         ->   del s[pos:pos+bits]
-s.peekbit()                 ->   s.peek(1)
-s.peekbitlist(a, b)         ->   s.peeklist([a, b])
-s.peekbits(bits)            ->   s.peek(bits)
-s.peekbyte()                ->   s.peek(8)
-s.peekbytelist(a, b)        ->   s.peeklist([8*a, 8*b])
-s.peekbytes(bytes)          ->   s.peek(8*bytes)
-s.readbit()                 ->   s.read(1)
-s.readbitlist(a, b)         ->   s.readlist([a, b])
-s.readbits(bits)            ->   s.read(bits)
-s.readbyte()                ->   s.read(8)
-s.readbytelist(a, b)        ->   s.readlist([8*a, 8*b])
-s.readbytes(bytes)          ->   s.read(8*bytes)
-s.retreatbit()              ->   s.pos -= 1
-s.retreatbits(bits)         ->   s.pos -= bits
-s.retreatbyte()             ->   s.pos -= 8
-s.retreatbytes(bytes)       ->   s.pos -= 8*bytes
-s.reversebytes(start, end)  ->   s.byteswap(0, start, end)
-s.seek(pos)                 ->   s.pos = pos
-s.seekbyte(bytepos)         ->   s.bytepos = bytepos
-s.slice(start, end, step)   ->   s[start:end:step]
-s.tell()                    ->   s.pos
-s.tellbyte()                ->   s.bytepos
-s.truncateend(bits)         ->   del s[-bits:]
-s.truncatestart(bits)       ->   del s[:bits]
-s.unset([a, b])             ->   s.set(False, [a, b])
-
-Many of these methods have been deprecated for the last few releases, but
-there are some new removals too. Any recoding needed should be quite
-straightforward, so while I apologise for the hassle, I had to take the
-opportunity to streamline and rationalise what was becoming a bit of an
-overblown API.
-
-* set / unset methods combined.
-
-The set/unset methods have been combined in a single method, which now
-takes a boolean as its first argument:
-
-s.set([a, b])               ->   s.set(1, [a, b])
-s.unset([a, b])             ->   s.set(0, [a, b])
-s.allset([a, b])            ->   s.all(1, [a, b])
-s.allunset([a, b])          ->   s.all(0, [a, b])
-s.anyset([a, b])            ->   s.any(1, [a, b])
-s.anyunset([a, b])          ->   s.any(0, [a, b])
-
-* all / any only accept iterables.
-
-The all and any methods (previously called allset, allunset, anyset and
-anyunset) no longer accept a single bit position. The recommended way of
-testing a single bit is just to index it, for example instead of:
-
->>> if s.all(True, i):
-
-just use
-
->>> if s[i]:
-
-If you really want to you can of course use an iterable with a single
-element, such as 's.any(False, [i])', but it's clearer just to write
-'not s[i]'.
-
-* Exception raised on reading off end of bitstring.
-
-If a read or peek goes beyond the end of the bitstring then a ReadError
-will be raised. The previous behaviour was that the rest of the bitstring
-would be returned and no exception raised.
-
-* BitStringError renamed to Error.
-
-The base class for errors in the bitstring module is now just Error, so
-it will likely appears in your code as bitstring.Error instead of
-the rather repetitive bitstring.BitStringError.
-
-* Single bit slices and reads return a bool.
-
-A single index slice (such as s[5]) will now return a bool (i.e. True or
-False) rather than a single bit bitstring. This is partly to reflect the
-style of the bytearray type, which returns an integer for single items, but
-mostly to avoid common errors like:
-
->>> if s[0]:
-...     do_something()
-
-While the intent of this code snippet is quite clear (i.e. do_something if
-the first bit of s is set) under the old rules s[0] would be true as long
-as s wasn't empty. That's because any one-bit bitstring was true as it was a
-non-empty container. Under the new rule s[0] is True if s starts with a '1'
-bit and False if s starts with a '0' bit.
-
-The change does not affect reads and peeks, so s.peek(1) will still return
-a single bit bitstring, which leads on to the next item...
-
-* Empty bitstrings or bitstrings with only zero bits are considered False.
-
-Previously a bitstring was False if it had no elements, otherwise it was True.
-This is standard behaviour for containers, but wasn't very useful for a container
-of just 0s and 1s. The new behaviour means that the bitstring is False if it
-has no 1 bits. This means that code like this:
-
->>> if s.peek(1):
-...     do_something()
-
-should work as you'd expect. It also means that Bits(1000), Bits(0x00) and
-Bits('uint:12=0') are all also False. If you need to check for the emptiness of
-a bitstring then instead check the len property:
-
-if s                ->   if s.len
-if not s            ->   if not s.len
-
-* Length and offset disallowed for some initialisers.
-
-Previously you could create bitstring using expressions like:
-
->>> s = Bits(hex='0xabcde', offset=4, length=13)
-
-This has now been disallowed, and the offset and length parameters may only
-be used when initialising with bytes or a file. To replace the old behaviour
-you could instead use
-
->>> s = Bits(hex='0xabcde')[4:17]
-
-* Renamed 'format' parameter 'fmt'.
-
-Methods with a 'format' parameter have had it renamed to 'fmt', to prevent
-hiding the built-in 'format'. Affects methods unpack, read, peek, readlist,
-peeklist and byteswap and the pack function. 
-
-* Iterables instead of *format accepted for some methods.
-
-This means that for the affected methods (unpack, readlist and peeklist) you
-will need to use an iterable to specify multiple items. This is easier to
-show than to describe, so instead of
-
->>> a, b, c, d = s.readlist('uint:12', 'hex:4', 'bin:7')
-
-you would instead write
-
->>> a, b, c, d = s.readlist(['uint:12', 'hex:4', 'bin:7'])
-
-Note that you could still use the single string 'uint:12, hex:4, bin:7' if
-you preferred.
-
-* Bool auto-initialisation removed.
-
-You can no longer use True and False to initialise single bit bitstrings.
-The reasoning behind this is that as bool is a subclass of int, it really is
-bad practice to have Bits(False) be different to Bits(0) and to have Bits(True)
-different to Bits(1).
-
-If you have used bool auto-initialisation then you will have to be careful to
-replace it as the bools will now be interpreted as ints, so Bits(False) will
-be empty (a bitstring of length 0), and Bits(True) will be a single zero bit
-(a bitstring of length 1). Sorry for the confusion, but I think this will
-prevent bigger problems in the future.
-
-There are a few alternatives for creating a single bit bitstring. My favourite
-it to use a list with a single item:
-
-Bits(False)            ->   Bits([0])
-Bits(True)             ->   Bits([1])
-
-* New creation from file strategy
-
-Previously if you created a bitstring from a file, either by auto-initialising
-with a file object or using the filename parameter, the file would not be read
-into memory unless you tried to modify it, at which point the whole file would
-be read.
-
-The new behaviour depends on whether you create a Bits or a BitString from the
-file. If you create a Bits (which is immutable) then the file will never be
-read into memory. This allows very large files to be opened for examination
-even if they could never fit in memory.
-
-If however you create a BitString, the whole of the referenced file will be read
-to store in memory. If the file is very big this could take a long time, or fail,
-but the idea is that in saying you want the mutable BitString you are implicitly
-saying that you want to make changes and so (for now) we need to load it into
-memory.
-
-The new strategy is a bit more predictable in terms of performance than the old.
-The main point to remember is that if you want to open a file and don't plan to
-alter the bitstring then use the Bits class rather than BitString.
-
-Just to be clear, in neither case will the contents of the file ever be changed -
-if you want to output the modified BitString then use the tofile method, for
-example.
-
-* find and rfind return a tuple instead of a bool.
-
-If a find is unsuccessful then an empty tuple is returned (which is False in a
-boolean sense) otherwise a single item tuple with the bit position is returned
-(which is True in a boolean sense). You shouldn't need to recode unless you
-explicitly compared the result of a find to True or False, for example this
-snippet doesn't need to be altered:
-
->>> if s.find('0x23'):
-...     print(s.bitpos)
-        
-but you could now instead use
-
->>> found = s.find('0x23')
->>> if found:
-...     print(found[0])
-
-The reason for returning the bit position in a tuple is so that finding at
-position zero can still be True - it's the tuple (0,) - whereas not found can
-be False - the empty tuple ().
-
-The new features in this release are:
--------------------------------------
-* New count method.
-
-This method just counts the number of 1 or 0 bits in the bitstring.
-
->>> s = Bits('0x31fff4')
->>> s.count(1)
-16
-
-* read and peek methods accept integers.
-
-The read, readlist, peek and peeklist methods now accept integers as parameters
-to mean "read this many bits and return a bitstring". This has allowed a number
-of methods to be removed from this release, so for example instead of:
-
->>> a, b, c = s.readbits(5, 6, 7)
->>> if s.peekbit():
-...     do_something()
-
-you should write:
-
->>> a, b, c = s.readlist([5, 6, 7])
->>> if s.peek(1):
-...     do_something()
-
-* byteswap used to reverse all bytes.
-
-The byteswap method now allows a format specifier of 0 (the default) to signify
-that all of the whole bytes should be reversed. This means that calling just
-byteswap() is almost equivalent to the now removed bytereverse() method (a small
-difference is that byteswap won't raise an exception if the bitstring isn't a
-whole number of bytes long).
-
-* Auto initialise with bytearray or (for Python 3 only) bytes.
-
-So rather than writing:
-
->>> a = Bits(bytes=some_bytearray)
-
-you can just write
-
->>> a = Bits(some_bytearray)
-
-This also works for the bytes type, but only if you're using Python 3.
-For Python 2 it's not possible to distinguish between a bytes object and a
-str. For this reason this method should be used with some caution as it will
-make you code behave differently with the different major Python versions.
-
->>> b = Bits(b'abcd\x23\x00') # Only Python 3! 
-  
-* set, invert, all and any default to whole bitstring.
-
-This means that you can for example write:
-
->>> a = BitString(100)       # 100 zero bits
->>> a.set(1)                 # set all bits to 1
->>> a.all(1)                 # are all bits set to 1?
-True
->>> a.any(0)                 # are any set to 0?
-False
->>> a.invert()               # invert every bit
-  
-* New exception types.
-
-As well as renaming BitStringError to just Error 
-there are also new exceptions which use Error as a base class.
-
-These can be caught in preference to Error if you need finer control.
-The new exceptions sometimes also derive from built-in exceptions:
-
-ByteAlignError(Error) - whole byte position or length needed.
-
-ReadError(Error, IndexError) - reading or peeking off the end of
-the bitstring.
-
-CreationError(Error, ValueError) - inappropriate argument during
-bitstring creation.
-
-InterpretError(Error, ValueError) - inappropriate interpretation of
-binary data.
-
-
---------------------------------------------------------------
-March 18th 2010: version 1.3.0 for Python 2.6 and 3.x released
---------------------------------------------------------------
-New features:
-
-* byteswap method for changing endianness.
-
-Changes the endianness in-place according to a format string or
-integer(s) giving the byte pattern. See the manual for details.
-
->>> s = BitString('0x00112233445566')
->>> s.byteswap(2)
-3
->>> s
-BitString('0x11003322554466')
->>> s.byteswap('h')
-3
->>> s
-BitString('0x00112233445566')
->>> s.byteswap([2, 5])
-1
->>> s
-BitString('0x11006655443322')
-
-* Multiplicative factors in bitstring creation and reading.
-
-For example:
-
->>> s = Bits('100*0x123')
-
-* Token grouping using parenthesis.
-
-For example:
-
->>> s = Bits('3*(uint:6=3, 0b1)')
-
-* Negative slice indices allowed.
-
-The start and end parameters of many methods may now be negative, with the
-same meaning as for negative slice indices. Affects all methods with these
-parameters.
-
-* Sequence ABCs used.
-
-The Bits class now derives from collections.Sequence, while the BitString
-class derives from collections.MutableSequence.
-
-* Keywords allowed in readlist, peeklist and unpack.
-
-Keywords for token lengths are now permitted when reading. So for example,
-you can write
-
->>> s = bitstring.pack('4*(uint:n)', 2, 3, 4, 5, n=7)
->>> s.unpack('4*(uint:n)', n=7)
-[2, 3, 4, 5]
-
-* start and end parameters added to rol and ror.
-
-* join function accepts other iterables.
-
-Also its parameter has changed from 'bitstringlist' to 'sequence'. This is
-technically a backward incompatibility in the unlikely event that you are
-referring to the parameter by name.
-
-* __init__ method accepts keywords.
-
-Rather than a long list of initialisers the __init__ methods now use a
-**kwargs dictionary for all initialisers except 'auto'. This should have no
-effect, except that this is a small backward incompatibility if you use
-positional arguments when initialising with anything other than auto
-(which would be rather unusual).
-
-* More optimisations.
-
-* Bug fixed in replace method (it could fail if start != 0).
-
-----------------------------------------------------------------
-January 19th 2010: version 1.2.0 for Python 2.6 and 3.x released
-----------------------------------------------------------------
-
-* New 'Bits' class.
-
-Introducing a brand new class, Bits, representing an immutable sequence of
-bits.
-
-The Bits class is the base class for the mutable BitString. The differences
-between Bits and BitStrings are:
-
-1) Bits are immutable, so once they have been created their value cannot change.
-This of course means that mutating methods (append, replace, del etc.) are not
-available for Bits.
-
-2) Bits are hashable, so they can be used in sets and as keys in dictionaries.
-
-3) Bits are potentially more efficient than BitStrings, both in terms of
-computation and memory. The current implementation is only marginally
-more efficient though - this should improve in future versions.
-
-You can switch from Bits to a BitString or vice versa by constructing a new
-object from the old.
-
->>> s = Bits('0xabcd')
->>> t = BitString(s)
->>> t.append('0xe')
->>> u = Bits(t)
-
-The relationship between Bits and BitString is supposed to loosely mirror that
-between bytes and bytearray in Python 3.
-
-* Deprecation messages turned on.
-
-A number of methods have been flagged for removal in version 2. Deprecation
-warnings will now be given, which include an alternative way to do the same
-thing. All of the deprecated methods have simpler equivalent alternatives.
-
->>> t = s.slice(0, 2)
-__main__:1: DeprecationWarning: Call to deprecated function slice.
-Instead of 's.slice(a, b, c)' use 's[a:b:c]'.
-
-The deprecated methods are: advancebit, advancebits, advancebyte, advancebytes,
-retreatbit, retreatbits, retreatbyte, retreatbytes, tell, seek, slice, delete,
-tellbyte, seekbyte, truncatestart and truncateend.
-
-* Initialise from bool.
-
-Booleans have been added to the list of types that can 'auto'
-initialise a bitstring.
-
->>> zerobit = BitString(False)
->>> onebit = BitString(True)
-
-* Improved efficiency.
-
-More methods have been speeded up, in particular some deletions and insertions.
-
-* Bug fixes.
-
-A rare problem with truncating the start of bitstrings was fixed.
-
-A possible problem outputting the final byte in tofile() was fixed.
-
------------------------------------------------------------------
-December 22nd 2009: version 1.1.3 for Python 2.6 and 3.x released
------------------------------------------------------------------
-
-This version hopefully fixes an installation problem for platforms with
-case-sensitive file systems. There are no new features or other bug fixes.
-
------------------------------------------------------------------
-December 18th 2009: version 1.1.2 for Python 2.6 and 3.x released
------------------------------------------------------------------
-
-This is a minor update with (almost) no new features.
-
-* Improved efficiency.
-
-The speed of many typical operations has been increased, some substantially.
-
-* Initialise from integer.
-
-A BitString of '0' bits can be created using just an integer to give the length
-in bits. So instead of
-
->>> s = BitString(length=100)
-
-you can write just
-
->>> s = BitString(100)
-
-This matches the behaviour of bytearrays and (in Python 3) bytes.
-
-* A defect related to using the set / unset functions on BitStrings initialised
-from a file has been fixed.
-
------------------------------------------------------------------
-November 24th 2009: version 1.1.0 for Python 2.6 and 3.x released
------------------------------------------------------------------
-Note that this version will not work for Python 2.4 or 2.5. There may be an
-update for these Python versions some time next year, but it's not a priority
-quite yet. Also note that only one version is now provided, which works for
-Python 2.6 and 3.x (done with the minimum of hackery!)
-
-* Improved efficiency.
-
-A fair number of functions have improved efficiency, some quite dramatically.
-
-* New bit setting and checking functions.
-
-Although these functions don't do anything that couldn't be done before, they
-do make some common use cases much more efficient. If you need to set or check
-single bits then these are the functions you need.
-
-set / unset : Set bit(s) to 1 or 0 respectively.
-allset / allunset : Check if all bits are 1 or all 0.
-anyset / anyunset : Check if any bits are 1 or any 0.
-
->>> s = BitString(length=1000)
->>> s.set((10, 100, 44, 12, 1))
->>> s.allunset((2, 22, 222))
-True
->>> s.anyset(range(7, 77))
-True
-
-* New rotate functions.
-
-ror / rol : Rotate bits to the right or left respectively.
-
->>> s = BitString('0b100000000')
->>> s.ror(2)
->>> s.bin
-'0b001000000'
->>> s.rol(5)
->>> s.bin
-'0b000000100'
-
-* Floating point interpretations.
-
-New float initialisations and interpretations are available. These only work
-for BitStrings of length 32 or 64 bits.
-
->>> s = BitString(float=0.2, length=64)
->>> s.float
-0.200000000000000001
->>> t = bitstring.pack('<3f', -0.4, 1e34, 17.0)
->>> t.hex
-'0xcdccccbedf84f67700008841'
-
-* 'bytes' token reintroduced.
-
-This token returns a bytes object (equivalent to a str in Python 2.6).
-
->>> s = BitString('0x010203')
->>> s.unpack('bytes:2, bytes:1')
-['\x01\x02', '\x03']
-
-* 'uint' is now the default token type.
-
-So for example these are equivalent:
-
-a, b = s.readlist('uint:12, uint:12')
-a, b = s.readlist('12, 12')
-
---------------------------------------------------------
-October 10th 2009: version 1.0.1 for Python 3.x released
---------------------------------------------------------
-This is a straight port of version 1.0.0 to Python 3.
-
-For changes since the last Python 3 release read all the way down in this
-document to version 0.4.3.
-
-This version will also work for Python 2.6, but there's no advantage to using
-it over the 1.0.0 release. It won't work for anything before 2.6.
-
--------------------------------------------------------
-October 9th 2009: version 1.0.0 for Python 2.x released
--------------------------------------------------------
-Version 1 is here!
-
-This is the first release not to carry the 'beta' tag. It contains a couple of
-minor new features but is principally a release to fix the API. If you've been
-using an older version then you almost certainly will have to recode a bit. If
-you're not ready to do that then you may wish to delay updating.
-
-So the bad news is that there are lots of small changes to the API. The good
-news is that all the changes are pretty trivial, the new API is cleaner and
-more 'Pythonic', and that by making it version 1.0 I'm promising not to
-tweak it again for some time.
-
-** API Changes **
-
-* New read / peek functions for returning multiple items.
-
-The functions read, readbits, readbytes, peek, peekbits and peekbytes now only
-ever return a single item, never a list.
-
-The new functions readlist, readbitlist, readbytelist, peeklist, peekbitlist
-and peekbytelist can be used to read multiple items and will always return a
-list.
-
-So a line like:
-
->>> a, b = s.read('uint:12, hex:32')
-
-becomes
-
->>> a, b = s.readlist('uint:12, hex:32')
-
-* Renaming / removing functions.
-
-Functions have been renamed as follows:
-
-seekbit -> seek
-tellbit -> tell
-reversebits -> reverse
-deletebits -> delete
-tostring -> tobytes
-
-and a couple have been removed altogether:
-
-deletebytes - use delete instead.
-empty - use 'not s' rather than 's.empty()'.
-
-* Renaming parameters.
-
-The parameters 'startbit' and 'endbit' have been renamed 'start' and 'end'.
-This affects the functions slice, find, findall, rfind, reverse, cut and split.
-
-The parameter 'bitpos' has been renamed to 'pos'. The affects the functions
-seek, tell, insert, overwrite and delete.
-
-* Mutating methods return None rather than self.
-
-This means that you can't chain functions together so
-
->>> s.append('0x00').prepend('0xff')
->>> t = s.reverse()
-
-Needs to be rewritten
-
->>> s.append('0x00')
->>> s.prepend('0xff)
->>> s.reverse()
->>> t = s
-
-Affects truncatestart, truncateend, insert, overwrite, delete, append,
-prepend, reverse and reversebytes.
-
-* Properties renamed.
-
-The 'data' property has been renamed to 'bytes'. Also if the BitString is not a
-whole number of bytes then a ValueError exception will be raised when using
-'bytes' as a 'getter'.
-
-Properties 'len' and 'pos' have been added to replace 'length' and 'bitpos',
-although the longer names have not been removed so you can continue to use them
-if you prefer.
-
-* Other changes.
-
-The unpack function now always returns a list, never a single item.
-
-BitStrings are now 'unhashable', so calling hash on one or making a set will
-fail.
-
-The colon separating the token name from its length is now mandatory. So for
-example BitString('uint12=100') becomes BitString('uint:12=100').
-
-Removed support for the 'bytes' token in format strings. Instead of
-s.read('bytes:4') use s.read('bits:32').
-
-** New features **
-
-* Added endswith and startswith functions.
-
-These do much as you'd expect; they return True or False depending on whether
-the BitString starts or ends with the parameter.
-
->>> BitString('0xef342').startswith('0b11101')
-True
-
-----------------------------------------------------------
-September 11th 2009: version 0.5.2 for Python 2.x released
-----------------------------------------------------------
-Finally some tools for dealing with endianness!
-
-* New interpretations are now available for whole-byte BitStrings that treat
-them as big, little, or native-endian.
-
->>> big = BitString(intbe=1, length=16) # or BitString('intbe:16=1') if you prefer.
->>> little = BitString(intle=1, length=16)
->>> print big.hex, little.hex
-0x0001 0x0100
->>> print big.intbe, little.intle
-1 1
-
-* 'Struct'-like compact format codes
-
-To save some typing when using pack, unpack, read and peek, compact format
-codes based on those used in the struct and array modules have been added.
-These must start with a character indicating the endianness (>, < or @ for
-big, little and native-endian), followed by characters giving the format:
-
-b 	1-byte signed int
-B 	1-byte unsigned int
-h 	2-byte signed int
-H 	2-byte unsigned int
-l 	4-byte signed int
-L 	4-byte unsigned int
-q 	8-byte signed int
-Q 	8-byte unsigned int
-
-For example:
-
->>> s = bitstring.pack('<4h', 0, 1, 2, 3)
-
-creates a BitString with four little-endian 2-byte integers. While
-
->>> x, y, z = s.read('>hhl')
-
-reads them back as two big-endian two-byte integers and one four-byte big
-endian integer.
-
-Of course you can combine this new format with the old ones however you like:
-
->>> s.unpack('<h, intle:24, uint:5, bin')
-[0, 131073, 0, '0b0000000001100000000']
-
--------------------------------------------------------
-August 26th 2009: version 0.5.1 for Python 2.x released
--------------------------------------------------------
-
-This update introduces pack and unpack functions for creating and dissembling
-BitStrings.
-
-* New pack() and unpack() functions.
-
-The module level pack function provides a flexible new method for creating
-BitStrings. Tokens for BitString 'literals' can be used in the same way as in
-the constructor.
-
->>> from bitstring import BitString, pack
->>> a = pack('0b11, 0xff, 0o77, int:5=-1, se=33')
-
-You can also leave placeholders in the format, which will be filled in by
-the values provided.
-
->>> b = pack('uint:10, hex:4', 33, 'f')
-
-Finally you can use a dictionary or keywords.
-
->>> c = pack('bin=a, hex=b, bin=a', a='010', b='ef')
-
-The unpack function is similar to the read function except that it always
-unpacks from the start of the BitString.
-
->>> x, y = b.unpack('uint:10, hex')
-
-If a token is given without a length (as above) then it will expand to fill the
-remaining bits in the BitString. This also now works with read() and peek().
-
-* New tostring() and tofile() functions.
-
-The tostring() function just returns the data as a string, with up to seven
-zero bits appended to byte align. The tofile() function does the same except
-writes to a file object.
-
->>> f = open('myfile', 'wb')
->>> BitString('0x1234ff').tofile(f)
-
-* Other changes.
-
-The use of '=' is now mandatory in 'auto' initialisers. Tokens like 'uint12 100' will
-no longer work. Also the use of a ':' before the length is encouraged, but not yet
-mandated. So the previous example should be written as 'uint:12=100'.
-
-The 'auto' initialiser will now take a file object.
-
->>> f = open('myfile', 'rb')
->>> s = BitString(f)
-
------------------------------------------------------
-July 19th 2009: version 0.5.0 for Python 2.x released
------------------------------------------------------
-
-This update breaks backward compatibility in a couple of areas. The only one
-you probably need to be concerned about is the change to the default for
-bytealigned in find, replace, split, etc.
-
-See the user manual for more details on each of these items.
-
-* Expanded abilities of 'auto' initialiser.
-
-More types can be initialised through the 'auto' initialiser. For example
-instead of
-
->>> a = BitString(uint=44, length=16)
-
-you can write
-
->>> a = BitString('uint16=44')
-
-Also, different comma-separated tokens will be joined together, e.g.
-
->>> b = BitString('0xff') + 'int8=-5'
-
-can be written
-
->>> b = BitString('0xff, int8=-5')
-
-* New formatted read() and peek() functions.
-
-These takes a format string similar to that used in the auto initialiser.
-If only one token is provided then a single value is returned, otherwise a
-list of values is returned.
-
->>> start_code, width, height = s.read('hex32, uint12, uint12')
-
-is equivalent to
-
->>> start_code = s.readbits(32).hex
->>> width = s.readbits(12).uint
->>> height = s.readbits(12).uint
-
-The tokens are:
-
-  int n   : n bits as an unsigned integer.
-  uint n  : n bits as a signed integer.
-  hex n   : n bits as a hexadecimal string.
-  oct n   : n bits as an octal string.
-  bin n   : n bits as a binary string.
-  ue      : next bits as an unsigned exp-Golomb.
-  se      : next bits as a signed exp-Golomb.
-  bits n  : n bits as a new BitString.
-  bytes n : n bytes as a new BitString.
-
-See the user manual for more details.
-
-* hex() and oct() functions removed.
-
-The special functions for hex() and oct() have been removed. Please use the
-hex and oct properties instead.
-
->>> hex(s)
-
-becomes
-
->>> s.hex
-
-* join made a member function.
-
-The join function must now be called on a BitString object, which will be
-used to join the list together. You may need to recode slightly:
-
->>> s = bitstring.join('0x34', '0b1001', '0b1')
-
-becomes
-
->>> s = BitString().join('0x34', '0b1001', '0b1')
-
-* More than one value allowed in readbits, readbytes, peekbits and peekbytes
-
-If you specify more than one bit or byte length then a list of BitStrings will
-be returned.
-
->>> a, b, c = s.readbits(10, 5, 5)
-
-is equivalent to
-
->>> a = readbits(10)
->>> b = readbits(5)
->>> c = readbits(5)
-
-* bytealigned defaults to False, and is at the end of the parameter list
-
-Functions that have a bytealigned parameter have changed so that it now
-defaults to False rather than True. Also its position in the parameter list
-has changed to be at the end. You may need to recode slightly (sorry!)
-
-* readue and readse functions have been removed
-
-Instead you should use the new read function with a 'ue' or 'se' token:
-
->>> i = s.readue()
-
-becomes
-
->>> i = s.read('ue')
-
-This is more flexible as you can read multiple items in one go, plus you can
-now also use the peek function with ue and se.
-
-* Minor bugs fixed.
-
-See the issue tracker for more details.
-
------------------------------------------------------
-June 15th 2009: version 0.4.3 for Python 2.x released
------------------------------------------------------
-
-This is a minor update. This release is the first to bundle the bitstring
-manual. This is a PDF and you can find it in the docs directory.
-
-Changes in version 0.4.3
-
-* New 'cut' function
-
-This function returns a generator for constant sized chunks of a BitString.
-
->>> for byte in s.cut(8):
-...     do_something_with(byte)
-
-You can also specify a startbit and endbit, as well as a count, which limits
-the number of items generated:
-
->>> first100TSPackets = list(s.cut(188*8, count=100))
-
-* 'slice' function now equivalent to __getitem__.
-
-This means that a step can also be given to the slice function so that the
-following are now the same thing, and it's just a personal preference which
-to use:
-
->>> s1 = s[a:b:c]
->>> s2 = s.slice(a, b, c)
-
-* findall gets a 'count' parameter.
-
-So now
-
->>> list(a.findall(s, count=n))
-
-is equivalent to
-
->>> list(a.findall(s))[:n]
-
-except that it won't need to generate the whole list and so is much more
-efficient.
-
-* Changes to 'split'.
-
-The split function now has a 'count' parameter rather than 'maxsplit'. This
-makes the interface closer to that for cut, replace and findall. The final item
-generated is now no longer the whole of the rest of the BitString.
-
-* A couple of minor bugs were fixed. See the issue tracker for details.
-
-----------------------------------------------------
-May 25th 2009: version 0.4.2 for Python 2.x released
-----------------------------------------------------
-
-This is a minor update, and almost doesn't break compatibility with version
-0.4.0, but with the slight exception of findall() returning a generator,
-detailed below.
-
-Changes in version 0.4.2
-
-* Stepping in slices
-
-The use of the step parameter (also known as the stride) in slices has been
-added. Its use is a little non-standard as it effectively gives a multiplicative
-factor to apply to the start and stop parameters, rather than skipping over
-bits.
-
-For example this makes it much more convenient if you want to give slices in
-terms of bytes instead of bits. Instead of writing s[a*8:b*8] you can use
-s[a:b:8].
-
-When using a step the BitString is effectively truncated to a multiple of the
-step, so s[::8] is equal to s if s is an integer number of bytes, otherwise it
-is truncated by up to 7 bits. So the final seven complete 16-bit words could be
-written as s[-7::16]
-
-Negative slices are also allowed, and should do what you'd expect. So for
-example s[::-1] returns a bit-reversed copy of s (which is similar to
-s.reversebits(), which does the same operation on s in-place). As another
-example, to get the first 10 bytes in reverse byte order you could use
-s_bytereversed = s[0:10:-8].
-
-* Removed restrictions on offset
-
-You can now specify an offset of greater than 7 bits when creating a BitString,
-and the use of offset is also now permitted when using the filename initialiser.
-This is useful when you want to create a BitString from the middle of a file
-without having to read the file into memory.
-
->>> f = BitString(filename='reallybigfile', offset=8000000, length=32)
-
-* Integers can be assigned to slices
-
-You can now assign an integer to a slice of a BitString. If the integer doesn't
-fit in the size of slice given then a ValueError exception is raised. So this
-is now allowed and works as expected:
-
->>> s[8:16] = 106
-
-and is equivalent to
-
->>> s[8:16] = BitString(uint=106, length=8)
-
-* Less exceptions raised
-
-Some changes have been made to slicing so that less exceptions are raised,
-bringing the interface closer to that for lists. So for example trying to delete
-past the end of the BitString will now just delete to the end, rather than
-raising a ValueError.
-
-* Initialisation from lists and tuples
-
-A new option for the auto initialiser is to pass it a list or tuple. The items
-in the list or tuple are evaluated as booleans and the bits in the BitString are
-set to 1 for True items and 0 for False items. This can be used anywhere the
-auto initialiser can currently be used. For example:
-
->>> a = BitString([True, 7, False, 0, ()])     # 0b11000
->>> b = a + ['Yes', '']                        # Adds '0b10'
->>> (True, True, False) in a
-True
-
-* Miscellany
-
-reversebits() now has optional startbit and endbit parameters.
-
-As an optimisation findall() will return a generator, rather than a list. If you
-still want the whole list then of course you can just call list() on the
-generator.
-
-Improved efficiency of rfind().
-
-A couple of minor bugs were fixed. See the issue tracker for details.
-
------------------------------------------------------
-April 23rd 2009: Python 3 only version 0.4.1 released
------------------------------------------------------
-
-This version is just a port of version 0.4.0 to Python 3. All the unit tests
-pass, but beyond that only limited ad hoc testing has been done and so it
-should be considered an experimental release. That said, the unit test
-coverage is very good - I'm just not sure if anyone even wants a Python 3
-version!
-
----------------------------------------
-April 11th 2009: version 0.4.0 released
----------------------------------------
-Changes in version 0.4.0
-
-* New functions
-
-Added rfind(), findall(), replace(). These do pretty much what you'd expect -
-see the docstrings or the wiki for more information.
-
-* More special functions
-
-Some missing functions were added: __repr__, __contains__, __rand__,
-__ror__, _rxor__ and __delitem__.
-
-* Miscellany
-
-A couple of small bugs were fixed (see the issue tracker).
-
-----
-
-There are some small backward incompatibilities relative to version 0.3.2:
-
-* Combined find() and findbytealigned()
-
-findbytealigned() has been removed, and becomes part of find(). The default
-start position has changed on both find() and split() to be the start of the
-BitString. You may need to recode:
-
->>> s1.find(bs)
->>> s2.findbytealigned(bs)
->>> s2.split(bs)
-
-becomes
-
->>> s1.find(bs, bytealigned=False, startbit=s1.bitpos)
->>> s2.find(bs, startbit=s1.bitpos)  # bytealigned defaults to True
->>> s2.split(bs, startbit=s2.bitpos)
-
-* Reading off end of BitString no longer raises exception.
-
-Previously a read or peek function that encountered the end of the BitString
-would raise a ValueError. It will now instead return the remainder of the
-BitString, which could be an empty BitString. This is closer to the file
-object interface.
-
-* Removed visibility of offset.
-
-The offset property was previously read-only, and has now been removed from
-public view altogether. As it is used internally for efficiency reasons you
-shouldn't really have needed to use it. If you do then use the _offset parameter
-instead (with caution).
-
----------------------------------------
-March 11th 2009: version 0.3.2 released
----------------------------------------
-Changes in version 0.3.2
-
-* Better performance
-
-A number of functions (especially find() and findbytealigned()) have been sped
-up considerably.
-
-* Bit-wise operations
-
-Added support for bit-wise AND (&), OR (|) and XOR (^). For example:
-
->>> a = BitString('0b00111')
->>> print a & '0b10101'
-0b00101
-
-* Miscellany
-
-Added seekbit() and seekbyte() functions. These complement the 'advance' and
-'retreat' functions, although you can still just use bitpos and bytepos
-properties directly.
-
->>> a.seekbit(100)                   # Equivalent to a.bitpos = 100
-
-Allowed comparisons between BitString objects and strings. For example this
-will now work:
-
->>> a = BitString('0b00001111')
->>> a == '0x0f'
-True
-
-------------------------------------------
-February 26th 2009: version 0.3.1 released
-------------------------------------------
-Changes in version 0.3.1
-
-This version only adds features and fixes bugs relative to 0.3.0, and doesn't
-break backwards compatibility.
-
-* Octal interpretation and initialisation
-
-The oct property now joins bin and hex. Just prefix octal numbers with '0o'.
-
->>> a = BitString('0o755')
->>> print a.bin
-0b111101101
-
-* Simpler copying
-
-Rather than using b = copy.copy(a) to create a copy of a BitString, now you
-can just use b = BitString(a).
-
-* More special methods
-
-Lots of new special methods added, for example bit-shifting via << and >>,
-equality testing via == and !=, bit inversion (~) and concatenation using *.
-
-Also __setitem__ is now supported so BitString objects can be modified using
-standard index notation.
-
-* Proper installer
-
-Finally got round to writing the distutils script. To install just
-python setup.py install.
-
-------------------------------------------
-February 15th 2009: version 0.3.0 released
-------------------------------------------
-Changes in version 0.3.0
-
-* Simpler initialisation from binary and hexadecimal
-
-The first argument in the BitString constructor is now called auto and will
-attempt to interpret the type of a string. Prefix binary numbers with '0b'
-and hexadecimals with '0x'.
-
->>> a = BitString('0b0')         # single zero bit
->>> b = BitString('0xffff')      # two bytes
-
-Previously the first argument was data, so if you relied on this then you
-will need to recode:
-
->>> a = BitString('\x00\x00\x01\xb3')   # Don't do this any more!
-
-becomes
-
->>> a = BitString(data='\x00\x00\x01\xb3')
-
-or just
-
->>> a = BitString('0x000001b3')
-
-This new notation can also be used in functions that take a BitString as an
-argument. For example:
-
->>> a = BitString('0x0011') + '0xff'
->>> a.insert('0b001', 6)
->>> a.find('0b1111')
-
-* BitString made more mutable
-
-The functions append, deletebits, insert, overwrite, truncatestart and
-truncateend now modify the BitString that they act upon. This allows for
-cleaner and more efficient code, but you may need to rewrite slightly if you
-depended upon the old behaviour:
-
->>> a = BitString(hex='0xffff')
->>> a = a.append(BitString(hex='0x00'))
->>> b = a.deletebits(10, 10)
-
-becomes:
-
->>> a = BitString('0xffff')
->>> a.append('0x00')
->>> b = copy.copy(a)
->>> b.deletebits(10, 10)
-
-Thanks to Frank Aune for suggestions in this and other areas.
-
-* Changes to printing
-
-The binary interpretation of a BitString is now prepended with '0b'. This is
-in keeping with the Python 2.6 (and 3.0) bin function. The prefix is optional
-when initialising using 'bin='.
-
-Also, if you just print a BitString with no interpretation it will pick
-something appropriate - hex if it is an integer number of bytes, otherwise
-binary. If the BitString representation is very long it will be truncated
-by '...' so it is only an approximate interpretation.
-
->>> a = BitString('0b0011111')
->>> print a
-0b0011111
->>> a += '0b0'
->>> print a
-0x3e
-
-* More convenience functions
-
-Some missing functions such as advancebit and deletebytes have been added. Also
-a number of peek functions make an appearance as have prepend and reversebits.
-See the Tutorial for more details.
-
------------------------------------------
-January 13th 2009: version 0.2.0 released
------------------------------------------
-Some fairly minor updates, not really deserving of a whole version point update.
-------------------------------------------
-December 29th 2008: version 0.1.0 released
-------------------------------------------
-First release!
+--------------------------------
+bitstring module version history
+--------------------------------
+
+-----------------------
+May 2024: version 4.2.2
+-----------------------
+A couple more minor bug fixes.
+
+* Sometimes a ValueError was being raised instead of a ReadError. Bug #325.
+* Initialising a bitstring from None now raises a TypeError rather than generating
+  an empty bitstring. Bug #323.
+* Fixed performance regression for find/findall in some situations. Bug #326.
+* Fix for AttributeError bug when combining Bits with BitStream. Bug #329.
+
+-------------------------
+April 2024: version 4.2.1
+-------------------------
+Fixing a few regressions introduced in 4.2.0.
+
+* Module crashes on import with 32-bit Python. Bug #317.
+* Lists of integers not converted to bytes when using the bytes constructor. Bug #318.
+* Empty comma separated tokens not handled correctly. Bug #319.
+* Crash on import when docstrings not present due to optimize flag. Bug #321.
+
+-------------------------
+April 2024: version 4.2.0
+-------------------------
+
+This release contains a fairly large refactor of how different types are managed. This
+shouldn't affect the end user, and the main noticeable change should be the new Dtype
+class, which is optional to use.
+
+Support for 8-bit and smaller floats has been reworked and expanded. These are still
+a 'beta' feature.
+
+Backwardly incompatible changes:
+
+* Dropped support for Python 3.7. Minimum version is now 3.8.
+* For tokens that use a non-numeric length, a ':' is now compulsory rather than
+  recommended. For example use 'uint:foo' instead of 'uintfoo'.
+* The previous e4m3float and e5m2float formats have become the slightly modified
+  p4binary8 and p3binary8 formats.
+* Some parameters are now enforced as positional only, such as `auto` in constructors.
+
+Other changes:
+
+* The Array class is no longer 'beta'.
+
+* A new Dtype class can be optionally used to specify types.
+
+* The bitstring.options object is now the preferred method for changing module options.
+  The `bitstring.lsb0` and `bitstring.bytealigned` variables are now deprecated, use
+  `bitstring.options.lsb0` and `bitstring.options.bytealigned` instead.
+
+* New fromstring method as another way to create bitstrings from formatted strings.
+  Instead of relying on the `auto` parameter you can now optionally use `fromstring`.
+  >>> s1 = BitArray('u24=1000')             # This is still fine.
+  >>> s2 = BitArray.fromstring('u24=1000')  # This may be clearer and more efficient.
+
+* More types can now be pretty printed. For example integer and float formats can be used.
+  >>> s.pp('u15, bin')
+
+* Pretty printing is now prettier - optional terminal colours added.
+
+* A range of 8-bit, 6-bit and even 4-bit float formats added (beta):
+  p3binary8: IEEE 8-bit floating point with 3 bit precision.
+  p4binary8: IEEE 8-bit floating point with 4 bit precision.
+  e5m2mxfp: OCP 8-bit floating point with 3 bit precision.
+  e4m3mxfp: OCP 8-bit floating point with 4 bit precision.
+  e2m3mxfp: OCP 6-bit floating point with 4 bit precision.
+  e3m2mxfp: OCP 6-bit floating point with 3 bit precision.
+  e2m1mxfp: OCP 4-bit floating point with 2 bit precision.
+  e8m0mxfp: OCP 8-bit unsigned floating point designed to scale the other formats.
+  mxint: OCP 8-bit floating point that is a scaled integer representation.
+
+* Performance improvements.
+
+----------------------------
+November 2023: version 4.1.4
+----------------------------
+Fixing a regression introduced in 4.1.3
+
+* 'bytes' token can't be used without explicit length. Bug #303.
+
+----------------------------
+November 2023: version 4.1.3
+----------------------------
+A maintenance release, with some changes to the beta features introduced in 4.1.
+
+* Removed a couple of files that accidentally got included in the previous release. Bug #293.
+* The 8-bit float formats have been renamed 'e4m3float' and 'e5m2float'.
+* Some refactoring and performance optimizations.
+
+--------------------------------------
+September 2023: version 4.1.2 released
+--------------------------------------
+Another maintenance release. Once again some small changes to the 'beta' Array class,
+plus new Array functionality.
+
+* Fix for the module command-line usage. Bug #290.
+* Fix for when creating bitstrings from memoryview objects.
+* Renamed the 'fmt' parameter for Arrays to 'dtype'.
+* More Array operator coverage.
+* Added operators that act on two Arrays of the same size.
+* Added comparison operators for Arrays that return an Array of bools.
+* Added Array.equals method as == will now return an Array (see above item).
+* Added astype() method for Arrays to easily cast to a new dtype.
+
+-----------------------------------
+August 2023: version 4.1.1 released
+-----------------------------------
+A maintenance release, with some changes to the Array class which is still in 'beta'.
+
+* bitarray dependency now pinned to ">=2.8.0, <3.0.0" rather than a specific version. Bug #283.
+* Fix for using numpy integers as integer parameters. Bug #286.
+* Removed ability to extend an Array with the '+' operator. Use the 'extend' method instead.
+* Improvements when pretty-printing the Array.
+* Array.count() can now count 'nan' values for floating point types.
+
+-----------------------------------
+August 2023: version 4.1.0 released
+-----------------------------------
+
+This has turned into a surprisingly big release, with a major refactor and a brand new
+class (the first for 12 years!) There are also a couple of small possibly breaking changes
+detailed below, in particular 'auto' initialising bitstrings from integers is now disallowed.
+
+* Speed increased with bitarray dependency.
+
+The major weakness of bitstring has been its poor performance for computationally
+intensive tasks relative to lower level alternatives. This was principally due to
+relying on pure Python code to achieve things that the base language often didn't have
+fast ways of doing.
+
+This release starts to address that problem with a fairly extensive rewrite to replace
+much of the pure Python low-level bit operations with methods from the bitarray package.
+This is a package that does many of the same things as bitstring, and the two packages
+have co-existed for a long time. While bitarray doesn't have all of the options and
+facilities of bitstring it has the advantage of being very fast as it is implemented in C.
+By replacing the internal datatypes I can speed up bitstring's operations while keeping
+the same API.
+
+Huge kudos to Ilan Schnell for all his work on bitarray.
+
+* New Array class for homogeneous data (beta)
+
+If your data is all of the same type you can make use of the new Array class, which
+mirrors much of the functionality of the standard array.array type, but doesn't restrict
+you to just a dozen formats.
+
+  >>> from bitstring import Array
+  >>> a = Array('uint7', [9, 100, 3, 1])
+  >>> a.data
+  BitArray('0x1390181')
+  >>> b = Array('float16', a.tolist())
+  >>> b.append(0.25)
+  >>> b.tobytes()
+  b'H\x80V@B\x00<\x004\x00'
+  >>> b.tolist()
+  [9.0, 100.0, 3.0, 1.0, 0.25]
+
+The data is stored efficiently in a BitArray object, and you can manipulate both the
+data and the Array format freely. See the main documentation for more details. Note that
+this feature carries the 'beta' flag so may change in future point versions.
+
+Other changes:
+
+* Added two new floating point interpretations: float8_143 and float8_152. These are 8-bit
+  floating point formats, with very limited range and precision, but useful in some fields,
+  particularly machine learning. This is an experimental feature - the formats haven't
+  even been standardised yet.
+
+  >>> a = Bits(float8_143=16.5)
+  >>> a.bin
+  '01100000'
+  >>> a.float8_143
+  16.0
+
+* Auto initialization from ints has been removed and now raises a TypeError. Creating a
+  bitstring from an int still creates a zeroed bitstring of that length but ints won't
+  be promoted to bitstrings as that has been a constant source of errors and confusion.
+
+  >>> a = BitArray(100)  # Fine - create with 100 zeroed bits
+  >>> a += 0xff   # TypeError - previously this would have appended 0xff (=255) zero bits.
+  >>> a += '0xff'  # Probably what was meant - append eight '1' bits.
+  >>> a += Bits(255)  # Fine, append 255 zero bits.
+
+  This is a breaking change, but it breaks loudly with an exception, it is easily recoded,
+  and it removes a confusing wrinkle.
+
+* Explicitly specifying the 'auto' parameter is now disallowed rather than discouraged.
+  It was always meant to be a positional-only parameter (and will be once I can drop
+  Python 3.7 support) but for now it's renamed to '__auto'. In the unlikely event
+  this breaks code, the fix should be just to delete the 'auto=' if it's already the
+  first parameter.
+
+  >>> s = Bits(auto='0xff')  # Now raises a CreationError
+  >>> s = Bits('0xff')  # Fine, as always
+
+* Deleting, replacing or inserting into a bitstring resets the bit position to 0 if the
+  bitstring's length has been changed. Previously the bit position was adjusted but
+  this was not well defined.
+
+* Only empty bitstring are now considered False in a boolean sense. Previously s was
+  False is no bits in s were set to 1, but this goes against what it means to be a
+  container in Python so I consider this to be a bug, even if it was documented. I'm
+  guessing it's related to __nonzero__ in Python 2 becoming __bool__ in Python 3, and
+  it's never been fixed before now.
+
+* Casting to bytes now behaves as expected, so that bytes(s) gives the same result as
+  s.tobytes(). Previously it created a byte per bit.
+
+* Pretty printing with the 'bytes' format now uses characters from the 'Latin Extended-A'
+  unicode block for non-ASCII and unprintable characters instead of replacing them with '.'
+
+* When using struct-like codes you can now use '=' instead of '@' to signify native-
+  endianness. They behave identically, but the new '=' is now preferred.
+
+* More fixes for LSB0 mode. There are now no known issues with this feature.
+
+----------------------------------
+April 2023: version 4.0.2 released
+----------------------------------
+A maintenance release.
+
+* Added py.typed file and converted the module to a package to let mypy find type
+  annotations. Bug 248.
+* Fix to shifting operations when using LSB0 mode. Bug 251.
+* A few more fixes for LSB0 mode.
+* Improved LSB0 documentation.
+* Added build-system section to pyproject.toml. Bug 243.
+* Rewrote the walkthrough documentation as a jupyter notebook.
+* Updated the project's logo.
+
+-------------------------------------
+November 2022: version 4.0.1 released
+-------------------------------------
+
+This is a major release which drops support for Python 2.7 and has a new minimum
+requirement of Python 3.7. Around 95% of downloads satisfy this - users of
+older versions can continue to use bitstring 3.1, which will still be supported
+with fixes, but no new features.
+
+Other breaking changes are minimal, and there are a few cool features added.
+
+Breaking changes:
+
+* Minimum supported Python version is now Python 3.7.
+* Removed ConstBitArray and BitString class aliases. Use Bits and BitStream instead.
+* The cut() method will now also yield the final bits of a bitstring, even if they
+  are shorter than the requested cut size.
+* Removed default uint interpretation. This wasn't being applied uniformly - default
+  is now always to return a bitstring object of the given length and not to interpret
+  it as a uint. Bug 220.
+* If an overwrite goes beyond the end of the bitstring it will now extend the bitstring
+  rather than raise an exception. Bug 148.
+
+New features and improvements:
+
+* Type hints added throughout the code.
+* Underscores are now allowed in strings representing number literals.
+* The copy() method now works on Bits as well as BitArray objects.
+* The experimental command-line feature is now official. Command-line
+  parameters are concatenated and a bitstring created from them. If
+  the final parameter is either an interpretation string or ends with
+  a '.' followed by an interpretation string then that interpretation
+  of the bitstring will be used when printing it.
+
+  $ python -m bitstring int:16=-400
+  0xfe70
+  $ python -m bitstring float:32=0.2 bin
+  00111110010011001100110011001101
+
+* New pp() method that pretty-prints the bitstring in various formats - useful
+  especially in interactive sessions. Thanks to Omer Barak for the suggestion
+  and discussion.
+
+  >>> s.pp()
+    0: 10001000 01110110 10001110 01110110 11111000 01110110 10000111 00101000
+   64: 01110010 11111001 10000111 10011000 11110111 10011110 10000111 11111101
+  128: 11111001 10001100 01111111 10111100 10111111 11011011 11101011 11111011
+  192: 1100
+  >>> s.pp('bin, hex')
+    0: 10001000 01110110 10001110 01110110 11111000 01110110   88 76 8e 76 f8 76
+   48: 10000111 00101000 01110010 11111001 10000111 10011000   87 28 72 f9 87 98
+   96: 11110111 10011110 10000111 11111101 11111001 10001100   f7 9e 87 fd f9 8c
+  144: 01111111 10111100 10111111 11011011 11101011 11111011   7f bc bf db eb fb
+  192: 1100                                                    c
+
+* Shorter and more versatile properties. The bin, oct, hex, float, uint and int
+  properties can now be shortened to just their first letter. They can also have
+  a length in bits after them - allowing Rust-like data types. ::
+
+      >>> s = BitArray('0x44961000')
+      >>> s.h
+      '44961000'
+      >>> s.f32
+      1200.5
+      >>> s.u
+      1150685184
+      >>> s.i7 = -60
+      >>> s.b
+      '1000100'
+      >>> t = Bits('u12=160, u12=120, b=100')
+
+* Other types with bit lengths can also be used as properties ::
+
+      >>> s.floatle64 = 10.511
+
+* A colon is no longer required in format strings before a bit length. So for
+  example `Bits('int:15=-101')` could be written as `Bits('int15=-101')`. This is
+  now the preferred usage in the documentation except where the colon improves
+  readability.
+
+* Support for IEEE 16 bit floats. Floating point types can now be 16 bits long as well
+  as 32 and 64 bits. This is using the 'e' format from the struct module.
+
+* Support for bfloats. This is a specialised 16-bit floating point format
+  mostly used in machine learning. It's essentially a truncated IEEE 32-bit
+  format that keeps its range but only has a couple of signficant figures of
+  accuracy.
+
+
+---------------------------------------
+July 20th 2021: version 3.1.9 released
+---------------------------------------
+(version 3.1.8 was pulled due to serious issues)
+Another maintenance release.
+
+* Fixed a couple of outdated results in the readme (Issue 214).
+* Some more documentation tidying.
+* Turned off some debug code by default.
+* Fixed a couple of failing tests in different Python versions.
+* Fix for consistent pos initialisation semantics for different types.
+* Change to allow wheels to be uploaded to PyPI.
+* More work for LSB0 mode, but still not finished or documented (sorry).
+
+---------------------------------------
+May 5th 2020: version 3.1.7 released
+---------------------------------------
+This is a maintenance release with a few bug fixes plus an experimental
+feature to allow bits to be indexed in the opposite direction.
+
+* Fixing del not working correctly when stop value negative (Issue 201)
+* Removed deprecated direct import of ABC from collections module (Issue 196)
+* Tested and added explicit support for Python 3.7 and 3.8. (Issue 193)
+* Fixing a few stale links to documentation. (Issue 194)
+* Allowing initialisation with an io.BytesIO object. (Issue 189)
+
+Experimental LSB0 mode
+----------------------
+This feature allows bitstring to use Least Significant Bit Zero
+(LSB0) bit numbering; that is the final bit in the bitstring will
+be bit 0, and the first bit will be bit (n-1), rather than the
+other way around. LSB0 is a more natural numbering
+system in many fields, but is the opposite to Most Significant Bit
+Zero (MSB0) numbering which is the natural option when thinking of
+bitstrings as standard Python containers.
+
+To switch from the default MSB0, use the module level function
+
+    >>> bitstring.set_lsb0(True)
+
+Getting and setting bits should work in this release, as will some
+other methods. Many other methods are not tested yet and might not
+work as expected. This is mostly a release to get feedback before
+finalising the interface.
+
+Slicing is still done with the start bit smaller than the end bit.
+For example:
+
+    >>> s = Bits('0b000000111')
+    >>> s[0:5]
+    Bits('0b00111')
+    >>> s[0]
+    True
+
+Negative indices work as (hopefully) you'd expect, with the first stored
+bit being `s[-1]` and the final stored bit being `s[-n]`.
+
+See https://github.com/scott-griffiths/bitstring/issues/156 for
+discussions and to add any further comments.
+
+---------------------------------------
+July 9th 2019: version 3.1.6 released
+---------------------------------------
+A long overdue maintenance release with some fixes.
+
+* Fixed immutability bug. Bug 176. 
+* Fixed failure of `__contains__` in some circumstances. Bug 180.
+* Better handling of open files. Bug 186.
+* Better Python 2/3 check.
+* Making unit tests easier to run.
+* Allowing length of 1 to be specified for bools. (Thanks to LemonPi)
+
+---------------------------------------
+May 17th 2016: version 3.1.5 released
+---------------------------------------
+
+* Support initialisation from an array.
+* Added a separate LICENSE file.
+
+---------------------------------------
+March 19th 2016: version 3.1.4 released
+---------------------------------------
+This is another bug fix release.
+
+* Fix for bitstring types when created directly from other bitstring types.
+* Updating contact, website details.
+
+---------------------------------------
+March 4th 2014: version 3.1.3 released
+---------------------------------------
+This is another bug fix release.
+
+* Fix for problem with prepend for bitstrings with byte offsets in their data store.
+
+---------------------------------------
+April 18th 2013: version 3.1.2 released
+---------------------------------------
+This is another bug fix release.
+
+* Fix for problem where unpacking bytes would by eight times too long
+
+---------------------------------------
+March 21st 2013: version 3.1.1 released
+---------------------------------------
+This is a bug fix release.
+
+* Fix for problem where concatenating bitstrings sometimes modified method's arguments
+
+------------------------------------------
+February 26th 2013: version 3.1.0 released
+------------------------------------------
+This is a minor release with a couple of new features and some bug fixes.
+
+New 'pad' token
+---------------
+
+This token can be used in reads and when packing/unpacking to indicate that
+you don't care about the contents of these bits. Any padding bits will just
+be skipped over when reading/unpacking or zero-filled when packing.
+
+    >>> a, b = s.readlist('pad:5, uint:3, pad:1, uint:3')
+
+Here only two items are returned in the list - the padding bits are ignored.
+
+New clear and copy convenience methods
+--------------------------------------
+
+These methods have been introduced in Python 3.3 for lists and bytearrays,
+as more obvious ways of clearing and copying, and we mirror that change here.
+
+t = s.copy() is equivalent to t = s[:], and s.clear() is equivalent to del s[:].
+
+Other changes
+-------------
+
+* Some bug fixes.
+
+-----------------------------------------
+February 7th 2012: version 3.0.2 released
+-----------------------------------------
+This is a minor update that fixes a few bugs.
+
+* Fix for subclasses of bitstring classes behaving strangely (Issue 121).
+* Fix for excessive memory usage in rare cases (Issue 120).
+* Fixes for slicing edge cases.
+
+There has also been a reorganisation of the code to return it to a single
+'bitstring.py' file rather than the package that has been used for the past
+several releases. This change shouldn't affect users directly.
+
+------------------------------------------
+November 21st 2011: version 3.0.1 released
+------------------------------------------
+This release fixed a small but very visible bug in bitstring printing.
+
+------------------------------------------
+November 21st 2011: version 3.0.0 released
+------------------------------------------
+This is a major release which breaks backward compatibility in a few places.
+
+Backwardly incompatible changes
+===============================
+
+Hex, oct and bin properties don't have leading 0x, 0o and 0b
+------------------------------------------------------------
+
+If you ask for the hex, octal or binary representations of a bitstring then
+they will no longer be prefixed with '0x', 0o' or '0b'. This was done as it
+was noticed that the first thing a lot of user code does after getting these
+representations was to cut off the first two characters before further
+processing.
+
+    >>> a = BitArray('0x123')
+    >>> a.hex, a.oct, a.bin
+    ('123', '0443', '000100100011')
+
+Previously this would have returned ('0x123', '0o0443', '0b000100100011')
+
+This change might require some recoding, but it should all be simplifications.
+
+ConstBitArray renamed to Bits
+-----------------------------
+
+Previously Bits was an alias for ConstBitStream (for backward compatibility).
+This has now changed so that Bits and BitArray loosely correspond to the
+built-in types bytes and bytearray.
+
+If you were using streaming/reading methods on a Bits object then you will
+have to change it to a ConstBitStream.
+
+The ConstBitArray name is kept as an alias for Bits.
+
+Stepping in slices has conventional meaning
+-------------------------------------------
+
+The step parameter in __getitem__, __setitem__ and __delitem__ used to act
+as a multiplier for the start and stop parameters. No one seemed to use it
+though and so it has now reverted to the conventional meaning for containers.
+
+If you are using step then recoding is simple: s[a:b:c] becomes s[a*c:b*c].
+
+Some examples of the new usage:
+
+    >>> s = BitArray('0x0000')
+    s[::4] = [1, 1, 1, 1]
+    >>> s.hex
+    '8888'
+    >>> del s[8::2]
+    >>> s.hex
+    '880'
+
+
+New features
+============
+
+New readto method
+-----------------
+
+This method is a mix between a find and a read - it searches for a bitstring
+and then reads up to and including it. For example:
+
+    >>> s = ConstBitStream('0x47000102034704050647')
+    >>> s.readto('0x47', bytealigned=True)
+    BitStream('0x47')
+    >>> s.readto('0x47', bytealigned=True)
+    BitStream('0x0001020347')
+    >>> s.readto('0x47', bytealigned=True)
+    BitStream('0x04050647')
+
+pack function accepts an iterable as its format
+-----------------------------------------------
+
+Previously only a string was accepted as the format in the pack function.
+This was an oversight as it broke the symmetry between pack and unpack.
+Now you can use formats like this:
+
+    fmt = ['hex:8', 'bin:3']
+    a = pack(fmt, '47', '001')
+    a.unpack(fmt)
+
+
+--------------------------------------
+June 18th 2011: version 2.2.0 released
+--------------------------------------
+This is a minor upgrade with a couple of new features.
+
+New interleaved exponential-Golomb interpretations
+--------------------------------------------------
+
+New bit interpretations for interleaved exponential-Golomb (as used in the
+Dirac video codec) are supplied via 'uie' and 'sie':
+
+    >>> s = BitArray(uie=41)
+    >>> s.uie
+    41
+    >>> s.bin
+    '0b00010001001'
+
+These are pretty similar to the non-interleaved versions - see the manual
+for more details. Credit goes to Paul Sargent for the patch.
+
+New package-level bytealigned variable
+--------------------------------------
+
+A number of methods take a 'bytealigned' parameter to indicate that they
+should only work on byte boundaries (e.g. find, replace, split). Previously
+this parameter defaulted to 'False'. Instead it now defaults to
+'bitstring.bytealigned', which itself defaults to 'False', but can be changed
+to modify the default behaviour of the methods. For example:
+
+    >>> a = BitArray('0x00 ff 0f ff')
+    >>> a.find('0x0f')
+    (4,)    # found first not on a byte boundary
+    >>> a.find('0x0f', bytealigned=True)
+    (16,)   # forced looking only on byte boundaries
+    >>> bitstring.bytealigned = True  # Change default behaviour
+    >>> a.find('0x0f')
+    (16,)
+    >>> a.find('0x0f', bytealigned=False)
+    (4,)
+
+If you're only working with bytes then this can help avoid some errors and
+save some typing!
+
+Other changes
+-------------
+
+* Fix for Python 3.2, correcting for a change to the binascii module.
+* Fix for bool initialisation from 0 or 1.
+* Efficiency improvements, including interning strategy.
+
+------------------------------------------
+February 23rd 2011: version 2.1.1 released
+------------------------------------------
+This is a release to fix a couple of bugs that were introduced in 2.1.0.
+
+* Bug fix: Reading using the 'bytes' token had been broken (Issue 102).
+* Fixed problem using some methods on ConstBitArrays.
+* Better exception handling for tokens missing values.
+* Some performance improvements.
+
+-----------------------------------------
+January 23rd 2011: version 2.1.0 released
+-----------------------------------------
+
+New class hierarchy introduced with simpler classes
+---------------------------------------------------
+Previously there were just two classes, the immutable Bits which was the base
+class for the mutable BitString class. Both of these classes have the concept
+of a bit position, from which reads etc. take place so that the bitstring could
+be treated as if it were a file or stream.
+
+Two simpler classes have now been added which are purely bit containers and 
+don't have a bit position. These are called ConstBitArray and BitArray. As you
+can guess the former is an immutable version of the latter.
+
+The other classes have also been renamed to better reflect their capabilities.
+Instead of BitString you can use BitStream, and instead of Bits you can use
+ConstBitStream. The old names are kept as aliases for backward compatibility.
+
+The classes hierarchy is:
+
+        ConstBitArray
+           /    \
+          /      \
+    BitArray   ConstBitStream (formerly Bits)
+          \      /
+           \    /
+          BitStream (formerly BitString)
+
+
+Other changes
+-------------
+A lot of internal reorganisation has taken place since the previous version,
+most of which won't be noticed by the end user. Some things you might see are:
+
+* New package structure. Previous versions have been a single file for the
+  module and another for the unit tests. The module is now split into many
+  more files so it can't be used just by copying bitstring.py any more.
+* To run the unit tests there is now a script called runtests.py in the test
+  directory.
+* File based bitstring are now implemented in terms of an mmap. This should
+  be just an implementation detail, but unfortunately for 32-bit versions of
+  Python this creates a limit of 4GB on the files that can be used. The work
+  around is either to get a 64-bit Python, or just stick with version 2.0.
+* The ConstBitArray and ConstBitStream classes no longer copy byte data when
+  a slice or a read takes place, they just take a reference. This is mostly
+  a very nice optimisation, but there are occasions where it could have an
+  adverse effect. For example if a very large bitstring is created, a small
+  slice taken and the original deleted. The byte data from the large
+  bitstring would still be retained in memory.
+* Optimisations. Once again this version should be faster than the last.
+  The module is still pure Python but some of the reorganisation was to make
+  it more feasible to put some of the code into Cython or similar, so
+  hopefully more speed will be on the way.
+
+--------------------------------------
+July 26th 2010: version 2.0.3 released
+--------------------------------------
+* Bug fix: Using peek and read for a single bit now returns a new bitstring
+           as was intended, rather than the old behaviour of returning a bool.
+* Removed HTML docs from source archive - better to use the online version.
+
+--------------------------------------
+July 25th 2010: version 2.0.2 released
+--------------------------------------
+This is a major release, with a number of backwardly incompatible changes.
+The main change is the removal of many methods, all of which have simple
+alternatives. Other changes are quite minor but may need some recoding.
+
+There are a few new features, most of which have been made to help the
+stream-lining of the API. As always there are performance improvements and
+some API changes were made purely with future performance in mind.
+
+The backwardly incompatible changes are:
+-----------------------------------------
+* Methods removed.
+
+About half of the class methods have been removed from the API. They all have
+simple alternatives, so what remains is more powerful and easier to remember.
+The removed methods are listed here on the left, with their equivalent
+replacements on the right:
+
+s.advancebit()              ->   s.pos += 1
+s.advancebits(bits)         ->   s.pos += bits
+s.advancebyte()             ->   s.pos += 8
+s.advancebytes(bytes)       ->   s.pos += 8*bytes
+s.allunset([a, b])          ->   s.all(False, [a, b])
+s.anyunset([a, b])          ->   s.any(False, [a, b])
+s.delete(bits, pos)         ->   del s[pos:pos+bits]
+s.peekbit()                 ->   s.peek(1)
+s.peekbitlist(a, b)         ->   s.peeklist([a, b])
+s.peekbits(bits)            ->   s.peek(bits)
+s.peekbyte()                ->   s.peek(8)
+s.peekbytelist(a, b)        ->   s.peeklist([8*a, 8*b])
+s.peekbytes(bytes)          ->   s.peek(8*bytes)
+s.readbit()                 ->   s.read(1)
+s.readbitlist(a, b)         ->   s.readlist([a, b])
+s.readbits(bits)            ->   s.read(bits)
+s.readbyte()                ->   s.read(8)
+s.readbytelist(a, b)        ->   s.readlist([8*a, 8*b])
+s.readbytes(bytes)          ->   s.read(8*bytes)
+s.retreatbit()              ->   s.pos -= 1
+s.retreatbits(bits)         ->   s.pos -= bits
+s.retreatbyte()             ->   s.pos -= 8
+s.retreatbytes(bytes)       ->   s.pos -= 8*bytes
+s.reversebytes(start, end)  ->   s.byteswap(0, start, end)
+s.seek(pos)                 ->   s.pos = pos
+s.seekbyte(bytepos)         ->   s.bytepos = bytepos
+s.slice(start, end, step)   ->   s[start:end:step]
+s.tell()                    ->   s.pos
+s.tellbyte()                ->   s.bytepos
+s.truncateend(bits)         ->   del s[-bits:]
+s.truncatestart(bits)       ->   del s[:bits]
+s.unset([a, b])             ->   s.set(False, [a, b])
+
+Many of these methods have been deprecated for the last few releases, but
+there are some new removals too. Any recoding needed should be quite
+straightforward, so while I apologise for the hassle, I had to take the
+opportunity to streamline and rationalise what was becoming a bit of an
+overblown API.
+
+* set / unset methods combined.
+
+The set/unset methods have been combined in a single method, which now
+takes a boolean as its first argument:
+
+s.set([a, b])               ->   s.set(1, [a, b])
+s.unset([a, b])             ->   s.set(0, [a, b])
+s.allset([a, b])            ->   s.all(1, [a, b])
+s.allunset([a, b])          ->   s.all(0, [a, b])
+s.anyset([a, b])            ->   s.any(1, [a, b])
+s.anyunset([a, b])          ->   s.any(0, [a, b])
+
+* all / any only accept iterables.
+
+The all and any methods (previously called allset, allunset, anyset and
+anyunset) no longer accept a single bit position. The recommended way of
+testing a single bit is just to index it, for example instead of:
+
+>>> if s.all(True, i):
+
+just use
+
+>>> if s[i]:
+
+If you really want to you can of course use an iterable with a single
+element, such as 's.any(False, [i])', but it's clearer just to write
+'not s[i]'.
+
+* Exception raised on reading off end of bitstring.
+
+If a read or peek goes beyond the end of the bitstring then a ReadError
+will be raised. The previous behaviour was that the rest of the bitstring
+would be returned and no exception raised.
+
+* BitStringError renamed to Error.
+
+The base class for errors in the bitstring module is now just Error, so
+it will likely appears in your code as bitstring.Error instead of
+the rather repetitive bitstring.BitStringError.
+
+* Single bit slices and reads return a bool.
+
+A single index slice (such as s[5]) will now return a bool (i.e. True or
+False) rather than a single bit bitstring. This is partly to reflect the
+style of the bytearray type, which returns an integer for single items, but
+mostly to avoid common errors like:
+
+>>> if s[0]:
+...     do_something()
+
+While the intent of this code snippet is quite clear (i.e. do_something if
+the first bit of s is set) under the old rules s[0] would be true as long
+as s wasn't empty. That's because any one-bit bitstring was true as it was a
+non-empty container. Under the new rule s[0] is True if s starts with a '1'
+bit and False if s starts with a '0' bit.
+
+The change does not affect reads and peeks, so s.peek(1) will still return
+a single bit bitstring, which leads on to the next item...
+
+* Empty bitstrings or bitstrings with only zero bits are considered False.
+
+Previously a bitstring was False if it had no elements, otherwise it was True.
+This is standard behaviour for containers, but wasn't very useful for a container
+of just 0s and 1s. The new behaviour means that the bitstring is False if it
+has no 1 bits. This means that code like this:
+
+>>> if s.peek(1):
+...     do_something()
+
+should work as you'd expect. It also means that Bits(1000), Bits(0x00) and
+Bits('uint:12=0') are all also False. If you need to check for the emptiness of
+a bitstring then instead check the len property:
+
+if s                ->   if s.len
+if not s            ->   if not s.len
+
+* Length and offset disallowed for some initialisers.
+
+Previously you could create bitstring using expressions like:
+
+>>> s = Bits(hex='0xabcde', offset=4, length=13)
+
+This has now been disallowed, and the offset and length parameters may only
+be used when initialising with bytes or a file. To replace the old behaviour
+you could instead use
+
+>>> s = Bits(hex='0xabcde')[4:17]
+
+* Renamed 'format' parameter 'fmt'.
+
+Methods with a 'format' parameter have had it renamed to 'fmt', to prevent
+hiding the built-in 'format'. Affects methods unpack, read, peek, readlist,
+peeklist and byteswap and the pack function. 
+
+* Iterables instead of *format accepted for some methods.
+
+This means that for the affected methods (unpack, readlist and peeklist) you
+will need to use an iterable to specify multiple items. This is easier to
+show than to describe, so instead of
+
+>>> a, b, c, d = s.readlist('uint:12', 'hex:4', 'bin:7')
+
+you would instead write
+
+>>> a, b, c, d = s.readlist(['uint:12', 'hex:4', 'bin:7'])
+
+Note that you could still use the single string 'uint:12, hex:4, bin:7' if
+you preferred.
+
+* Bool auto-initialisation removed.
+
+You can no longer use True and False to initialise single bit bitstrings.
+The reasoning behind this is that as bool is a subclass of int, it really is
+bad practice to have Bits(False) be different to Bits(0) and to have Bits(True)
+different to Bits(1).
+
+If you have used bool auto-initialisation then you will have to be careful to
+replace it as the bools will now be interpreted as ints, so Bits(False) will
+be empty (a bitstring of length 0), and Bits(True) will be a single zero bit
+(a bitstring of length 1). Sorry for the confusion, but I think this will
+prevent bigger problems in the future.
+
+There are a few alternatives for creating a single bit bitstring. My favourite
+it to use a list with a single item:
+
+Bits(False)            ->   Bits([0])
+Bits(True)             ->   Bits([1])
+
+* New creation from file strategy
+
+Previously if you created a bitstring from a file, either by auto-initialising
+with a file object or using the filename parameter, the file would not be read
+into memory unless you tried to modify it, at which point the whole file would
+be read.
+
+The new behaviour depends on whether you create a Bits or a BitString from the
+file. If you create a Bits (which is immutable) then the file will never be
+read into memory. This allows very large files to be opened for examination
+even if they could never fit in memory.
+
+If however you create a BitString, the whole of the referenced file will be read
+to store in memory. If the file is very big this could take a long time, or fail,
+but the idea is that in saying you want the mutable BitString you are implicitly
+saying that you want to make changes and so (for now) we need to load it into
+memory.
+
+The new strategy is a bit more predictable in terms of performance than the old.
+The main point to remember is that if you want to open a file and don't plan to
+alter the bitstring then use the Bits class rather than BitString.
+
+Just to be clear, in neither case will the contents of the file ever be changed -
+if you want to output the modified BitString then use the tofile method, for
+example.
+
+* find and rfind return a tuple instead of a bool.
+
+If a find is unsuccessful then an empty tuple is returned (which is False in a
+boolean sense) otherwise a single item tuple with the bit position is returned
+(which is True in a boolean sense). You shouldn't need to recode unless you
+explicitly compared the result of a find to True or False, for example this
+snippet doesn't need to be altered:
+
+>>> if s.find('0x23'):
+...     print(s.bitpos)
+        
+but you could now instead use
+
+>>> found = s.find('0x23')
+>>> if found:
+...     print(found[0])
+
+The reason for returning the bit position in a tuple is so that finding at
+position zero can still be True - it's the tuple (0,) - whereas not found can
+be False - the empty tuple ().
+
+The new features in this release are:
+-------------------------------------
+* New count method.
+
+This method just counts the number of 1 or 0 bits in the bitstring.
+
+>>> s = Bits('0x31fff4')
+>>> s.count(1)
+16
+
+* read and peek methods accept integers.
+
+The read, readlist, peek and peeklist methods now accept integers as parameters
+to mean "read this many bits and return a bitstring". This has allowed a number
+of methods to be removed from this release, so for example instead of:
+
+>>> a, b, c = s.readbits(5, 6, 7)
+>>> if s.peekbit():
+...     do_something()
+
+you should write:
+
+>>> a, b, c = s.readlist([5, 6, 7])
+>>> if s.peek(1):
+...     do_something()
+
+* byteswap used to reverse all bytes.
+
+The byteswap method now allows a format specifier of 0 (the default) to signify
+that all of the whole bytes should be reversed. This means that calling just
+byteswap() is almost equivalent to the now removed bytereverse() method (a small
+difference is that byteswap won't raise an exception if the bitstring isn't a
+whole number of bytes long).
+
+* Auto initialise with bytearray or (for Python 3 only) bytes.
+
+So rather than writing:
+
+>>> a = Bits(bytes=some_bytearray)
+
+you can just write
+
+>>> a = Bits(some_bytearray)
+
+This also works for the bytes type, but only if you're using Python 3.
+For Python 2 it's not possible to distinguish between a bytes object and a
+str. For this reason this method should be used with some caution as it will
+make you code behave differently with the different major Python versions.
+
+>>> b = Bits(b'abcd\x23\x00') # Only Python 3! 
+  
+* set, invert, all and any default to whole bitstring.
+
+This means that you can for example write:
+
+>>> a = BitString(100)       # 100 zero bits
+>>> a.set(1)                 # set all bits to 1
+>>> a.all(1)                 # are all bits set to 1?
+True
+>>> a.any(0)                 # are any set to 0?
+False
+>>> a.invert()               # invert every bit
+  
+* New exception types.
+
+As well as renaming BitStringError to just Error 
+there are also new exceptions which use Error as a base class.
+
+These can be caught in preference to Error if you need finer control.
+The new exceptions sometimes also derive from built-in exceptions:
+
+ByteAlignError(Error) - whole byte position or length needed.
+
+ReadError(Error, IndexError) - reading or peeking off the end of
+the bitstring.
+
+CreationError(Error, ValueError) - inappropriate argument during
+bitstring creation.
+
+InterpretError(Error, ValueError) - inappropriate interpretation of
+binary data.
+
+
+--------------------------------------------------------------
+March 18th 2010: version 1.3.0 for Python 2.6 and 3.x released
+--------------------------------------------------------------
+New features:
+
+* byteswap method for changing endianness.
+
+Changes the endianness in-place according to a format string or
+integer(s) giving the byte pattern. See the manual for details.
+
+>>> s = BitString('0x00112233445566')
+>>> s.byteswap(2)
+3
+>>> s
+BitString('0x11003322554466')
+>>> s.byteswap('h')
+3
+>>> s
+BitString('0x00112233445566')
+>>> s.byteswap([2, 5])
+1
+>>> s
+BitString('0x11006655443322')
+
+* Multiplicative factors in bitstring creation and reading.
+
+For example:
+
+>>> s = Bits('100*0x123')
+
+* Token grouping using parenthesis.
+
+For example:
+
+>>> s = Bits('3*(uint:6=3, 0b1)')
+
+* Negative slice indices allowed.
+
+The start and end parameters of many methods may now be negative, with the
+same meaning as for negative slice indices. Affects all methods with these
+parameters.
+
+* Sequence ABCs used.
+
+The Bits class now derives from collections.Sequence, while the BitString
+class derives from collections.MutableSequence.
+
+* Keywords allowed in readlist, peeklist and unpack.
+
+Keywords for token lengths are now permitted when reading. So for example,
+you can write
+
+>>> s = bitstring.pack('4*(uint:n)', 2, 3, 4, 5, n=7)
+>>> s.unpack('4*(uint:n)', n=7)
+[2, 3, 4, 5]
+
+* start and end parameters added to rol and ror.
+
+* join function accepts other iterables.
+
+Also its parameter has changed from 'bitstringlist' to 'sequence'. This is
+technically a backward incompatibility in the unlikely event that you are
+referring to the parameter by name.
+
+* __init__ method accepts keywords.
+
+Rather than a long list of initialisers the __init__ methods now use a
+**kwargs dictionary for all initialisers except 'auto'. This should have no
+effect, except that this is a small backward incompatibility if you use
+positional arguments when initialising with anything other than auto
+(which would be rather unusual).
+
+* More optimisations.
+
+* Bug fixed in replace method (it could fail if start != 0).
+
+----------------------------------------------------------------
+January 19th 2010: version 1.2.0 for Python 2.6 and 3.x released
+----------------------------------------------------------------
+
+* New 'Bits' class.
+
+Introducing a brand new class, Bits, representing an immutable sequence of
+bits.
+
+The Bits class is the base class for the mutable BitString. The differences
+between Bits and BitStrings are:
+
+1) Bits are immutable, so once they have been created their value cannot change.
+This of course means that mutating methods (append, replace, del etc.) are not
+available for Bits.
+
+2) Bits are hashable, so they can be used in sets and as keys in dictionaries.
+
+3) Bits are potentially more efficient than BitStrings, both in terms of
+computation and memory. The current implementation is only marginally
+more efficient though - this should improve in future versions.
+
+You can switch from Bits to a BitString or vice versa by constructing a new
+object from the old.
+
+>>> s = Bits('0xabcd')
+>>> t = BitString(s)
+>>> t.append('0xe')
+>>> u = Bits(t)
+
+The relationship between Bits and BitString is supposed to loosely mirror that
+between bytes and bytearray in Python 3.
+
+* Deprecation messages turned on.
+
+A number of methods have been flagged for removal in version 2. Deprecation
+warnings will now be given, which include an alternative way to do the same
+thing. All of the deprecated methods have simpler equivalent alternatives.
+
+>>> t = s.slice(0, 2)
+__main__:1: DeprecationWarning: Call to deprecated function slice.
+Instead of 's.slice(a, b, c)' use 's[a:b:c]'.
+
+The deprecated methods are: advancebit, advancebits, advancebyte, advancebytes,
+retreatbit, retreatbits, retreatbyte, retreatbytes, tell, seek, slice, delete,
+tellbyte, seekbyte, truncatestart and truncateend.
+
+* Initialise from bool.
+
+Booleans have been added to the list of types that can 'auto'
+initialise a bitstring.
+
+>>> zerobit = BitString(False)
+>>> onebit = BitString(True)
+
+* Improved efficiency.
+
+More methods have been speeded up, in particular some deletions and insertions.
+
+* Bug fixes.
+
+A rare problem with truncating the start of bitstrings was fixed.
+
+A possible problem outputting the final byte in tofile() was fixed.
+
+-----------------------------------------------------------------
+December 22nd 2009: version 1.1.3 for Python 2.6 and 3.x released
+-----------------------------------------------------------------
+
+This version hopefully fixes an installation problem for platforms with
+case-sensitive file systems. There are no new features or other bug fixes.
+
+-----------------------------------------------------------------
+December 18th 2009: version 1.1.2 for Python 2.6 and 3.x released
+-----------------------------------------------------------------
+
+This is a minor update with (almost) no new features.
+
+* Improved efficiency.
+
+The speed of many typical operations has been increased, some substantially.
+
+* Initialise from integer.
+
+A BitString of '0' bits can be created using just an integer to give the length
+in bits. So instead of
+
+>>> s = BitString(length=100)
+
+you can write just
+
+>>> s = BitString(100)
+
+This matches the behaviour of bytearrays and (in Python 3) bytes.
+
+* A defect related to using the set / unset functions on BitStrings initialised
+from a file has been fixed.
+
+-----------------------------------------------------------------
+November 24th 2009: version 1.1.0 for Python 2.6 and 3.x released
+-----------------------------------------------------------------
+Note that this version will not work for Python 2.4 or 2.5. There may be an
+update for these Python versions some time next year, but it's not a priority
+quite yet. Also note that only one version is now provided, which works for
+Python 2.6 and 3.x (done with the minimum of hackery!)
+
+* Improved efficiency.
+
+A fair number of functions have improved efficiency, some quite dramatically.
+
+* New bit setting and checking functions.
+
+Although these functions don't do anything that couldn't be done before, they
+do make some common use cases much more efficient. If you need to set or check
+single bits then these are the functions you need.
+
+set / unset : Set bit(s) to 1 or 0 respectively.
+allset / allunset : Check if all bits are 1 or all 0.
+anyset / anyunset : Check if any bits are 1 or any 0.
+
+>>> s = BitString(length=1000)
+>>> s.set((10, 100, 44, 12, 1))
+>>> s.allunset((2, 22, 222))
+True
+>>> s.anyset(range(7, 77))
+True
+
+* New rotate functions.
+
+ror / rol : Rotate bits to the right or left respectively.
+
+>>> s = BitString('0b100000000')
+>>> s.ror(2)
+>>> s.bin
+'0b001000000'
+>>> s.rol(5)
+>>> s.bin
+'0b000000100'
+
+* Floating point interpretations.
+
+New float initialisations and interpretations are available. These only work
+for BitStrings of length 32 or 64 bits.
+
+>>> s = BitString(float=0.2, length=64)
+>>> s.float
+0.200000000000000001
+>>> t = bitstring.pack('<3f', -0.4, 1e34, 17.0)
+>>> t.hex
+'0xcdccccbedf84f67700008841'
+
+* 'bytes' token reintroduced.
+
+This token returns a bytes object (equivalent to a str in Python 2.6).
+
+>>> s = BitString('0x010203')
+>>> s.unpack('bytes:2, bytes:1')
+['\x01\x02', '\x03']
+
+* 'uint' is now the default token type.
+
+So for example these are equivalent:
+
+a, b = s.readlist('uint:12, uint:12')
+a, b = s.readlist('12, 12')
+
+--------------------------------------------------------
+October 10th 2009: version 1.0.1 for Python 3.x released
+--------------------------------------------------------
+This is a straight port of version 1.0.0 to Python 3.
+
+For changes since the last Python 3 release read all the way down in this
+document to version 0.4.3.
+
+This version will also work for Python 2.6, but there's no advantage to using
+it over the 1.0.0 release. It won't work for anything before 2.6.
+
+-------------------------------------------------------
+October 9th 2009: version 1.0.0 for Python 2.x released
+-------------------------------------------------------
+Version 1 is here!
+
+This is the first release not to carry the 'beta' tag. It contains a couple of
+minor new features but is principally a release to fix the API. If you've been
+using an older version then you almost certainly will have to recode a bit. If
+you're not ready to do that then you may wish to delay updating.
+
+So the bad news is that there are lots of small changes to the API. The good
+news is that all the changes are pretty trivial, the new API is cleaner and
+more 'Pythonic', and that by making it version 1.0 I'm promising not to
+tweak it again for some time.
+
+** API Changes **
+
+* New read / peek functions for returning multiple items.
+
+The functions read, readbits, readbytes, peek, peekbits and peekbytes now only
+ever return a single item, never a list.
+
+The new functions readlist, readbitlist, readbytelist, peeklist, peekbitlist
+and peekbytelist can be used to read multiple items and will always return a
+list.
+
+So a line like:
+
+>>> a, b = s.read('uint:12, hex:32')
+
+becomes
+
+>>> a, b = s.readlist('uint:12, hex:32')
+
+* Renaming / removing functions.
+
+Functions have been renamed as follows:
+
+seekbit -> seek
+tellbit -> tell
+reversebits -> reverse
+deletebits -> delete
+tostring -> tobytes
+
+and a couple have been removed altogether:
+
+deletebytes - use delete instead.
+empty - use 'not s' rather than 's.empty()'.
+
+* Renaming parameters.
+
+The parameters 'startbit' and 'endbit' have been renamed 'start' and 'end'.
+This affects the functions slice, find, findall, rfind, reverse, cut and split.
+
+The parameter 'bitpos' has been renamed to 'pos'. The affects the functions
+seek, tell, insert, overwrite and delete.
+
+* Mutating methods return None rather than self.
+
+This means that you can't chain functions together so
+
+>>> s.append('0x00').prepend('0xff')
+>>> t = s.reverse()
+
+Needs to be rewritten
+
+>>> s.append('0x00')
+>>> s.prepend('0xff)
+>>> s.reverse()
+>>> t = s
+
+Affects truncatestart, truncateend, insert, overwrite, delete, append,
+prepend, reverse and reversebytes.
+
+* Properties renamed.
+
+The 'data' property has been renamed to 'bytes'. Also if the BitString is not a
+whole number of bytes then a ValueError exception will be raised when using
+'bytes' as a 'getter'.
+
+Properties 'len' and 'pos' have been added to replace 'length' and 'bitpos',
+although the longer names have not been removed so you can continue to use them
+if you prefer.
+
+* Other changes.
+
+The unpack function now always returns a list, never a single item.
+
+BitStrings are now 'unhashable', so calling hash on one or making a set will
+fail.
+
+The colon separating the token name from its length is now mandatory. So for
+example BitString('uint12=100') becomes BitString('uint:12=100').
+
+Removed support for the 'bytes' token in format strings. Instead of
+s.read('bytes:4') use s.read('bits:32').
+
+** New features **
+
+* Added endswith and startswith functions.
+
+These do much as you'd expect; they return True or False depending on whether
+the BitString starts or ends with the parameter.
+
+>>> BitString('0xef342').startswith('0b11101')
+True
+
+----------------------------------------------------------
+September 11th 2009: version 0.5.2 for Python 2.x released
+----------------------------------------------------------
+Finally some tools for dealing with endianness!
+
+* New interpretations are now available for whole-byte BitStrings that treat
+them as big, little, or native-endian.
+
+>>> big = BitString(intbe=1, length=16) # or BitString('intbe:16=1') if you prefer.
+>>> little = BitString(intle=1, length=16)
+>>> print big.hex, little.hex
+0x0001 0x0100
+>>> print big.intbe, little.intle
+1 1
+
+* 'Struct'-like compact format codes
+
+To save some typing when using pack, unpack, read and peek, compact format
+codes based on those used in the struct and array modules have been added.
+These must start with a character indicating the endianness (>, < or @ for
+big, little and native-endian), followed by characters giving the format:
+
+b 	1-byte signed int
+B 	1-byte unsigned int
+h 	2-byte signed int
+H 	2-byte unsigned int
+l 	4-byte signed int
+L 	4-byte unsigned int
+q 	8-byte signed int
+Q 	8-byte unsigned int
+
+For example:
+
+>>> s = bitstring.pack('<4h', 0, 1, 2, 3)
+
+creates a BitString with four little-endian 2-byte integers. While
+
+>>> x, y, z = s.read('>hhl')
+
+reads them back as two big-endian two-byte integers and one four-byte big
+endian integer.
+
+Of course you can combine this new format with the old ones however you like:
+
+>>> s.unpack('<h, intle:24, uint:5, bin')
+[0, 131073, 0, '0b0000000001100000000']
+
+-------------------------------------------------------
+August 26th 2009: version 0.5.1 for Python 2.x released
+-------------------------------------------------------
+
+This update introduces pack and unpack functions for creating and dissembling
+BitStrings.
+
+* New pack() and unpack() functions.
+
+The module level pack function provides a flexible new method for creating
+BitStrings. Tokens for BitString 'literals' can be used in the same way as in
+the constructor.
+
+>>> from bitstring import BitString, pack
+>>> a = pack('0b11, 0xff, 0o77, int:5=-1, se=33')
+
+You can also leave placeholders in the format, which will be filled in by
+the values provided.
+
+>>> b = pack('uint:10, hex:4', 33, 'f')
+
+Finally you can use a dictionary or keywords.
+
+>>> c = pack('bin=a, hex=b, bin=a', a='010', b='ef')
+
+The unpack function is similar to the read function except that it always
+unpacks from the start of the BitString.
+
+>>> x, y = b.unpack('uint:10, hex')
+
+If a token is given without a length (as above) then it will expand to fill the
+remaining bits in the BitString. This also now works with read() and peek().
+
+* New tostring() and tofile() functions.
+
+The tostring() function just returns the data as a string, with up to seven
+zero bits appended to byte align. The tofile() function does the same except
+writes to a file object.
+
+>>> f = open('myfile', 'wb')
+>>> BitString('0x1234ff').tofile(f)
+
+* Other changes.
+
+The use of '=' is now mandatory in 'auto' initialisers. Tokens like 'uint12 100' will
+no longer work. Also the use of a ':' before the length is encouraged, but not yet
+mandated. So the previous example should be written as 'uint:12=100'.
+
+The 'auto' initialiser will now take a file object.
+
+>>> f = open('myfile', 'rb')
+>>> s = BitString(f)
+
+-----------------------------------------------------
+July 19th 2009: version 0.5.0 for Python 2.x released
+-----------------------------------------------------
+
+This update breaks backward compatibility in a couple of areas. The only one
+you probably need to be concerned about is the change to the default for
+bytealigned in find, replace, split, etc.
+
+See the user manual for more details on each of these items.
+
+* Expanded abilities of 'auto' initialiser.
+
+More types can be initialised through the 'auto' initialiser. For example
+instead of
+
+>>> a = BitString(uint=44, length=16)
+
+you can write
+
+>>> a = BitString('uint16=44')
+
+Also, different comma-separated tokens will be joined together, e.g.
+
+>>> b = BitString('0xff') + 'int8=-5'
+
+can be written
+
+>>> b = BitString('0xff, int8=-5')
+
+* New formatted read() and peek() functions.
+
+These takes a format string similar to that used in the auto initialiser.
+If only one token is provided then a single value is returned, otherwise a
+list of values is returned.
+
+>>> start_code, width, height = s.read('hex32, uint12, uint12')
+
+is equivalent to
+
+>>> start_code = s.readbits(32).hex
+>>> width = s.readbits(12).uint
+>>> height = s.readbits(12).uint
+
+The tokens are:
+
+  int n   : n bits as an unsigned integer.
+  uint n  : n bits as a signed integer.
+  hex n   : n bits as a hexadecimal string.
+  oct n   : n bits as an octal string.
+  bin n   : n bits as a binary string.
+  ue      : next bits as an unsigned exp-Golomb.
+  se      : next bits as a signed exp-Golomb.
+  bits n  : n bits as a new BitString.
+  bytes n : n bytes as a new BitString.
+
+See the user manual for more details.
+
+* hex() and oct() functions removed.
+
+The special functions for hex() and oct() have been removed. Please use the
+hex and oct properties instead.
+
+>>> hex(s)
+
+becomes
+
+>>> s.hex
+
+* join made a member function.
+
+The join function must now be called on a BitString object, which will be
+used to join the list together. You may need to recode slightly:
+
+>>> s = bitstring.join('0x34', '0b1001', '0b1')
+
+becomes
+
+>>> s = BitString().join('0x34', '0b1001', '0b1')
+
+* More than one value allowed in readbits, readbytes, peekbits and peekbytes
+
+If you specify more than one bit or byte length then a list of BitStrings will
+be returned.
+
+>>> a, b, c = s.readbits(10, 5, 5)
+
+is equivalent to
+
+>>> a = readbits(10)
+>>> b = readbits(5)
+>>> c = readbits(5)
+
+* bytealigned defaults to False, and is at the end of the parameter list
+
+Functions that have a bytealigned parameter have changed so that it now
+defaults to False rather than True. Also its position in the parameter list
+has changed to be at the end. You may need to recode slightly (sorry!)
+
+* readue and readse functions have been removed
+
+Instead you should use the new read function with a 'ue' or 'se' token:
+
+>>> i = s.readue()
+
+becomes
+
+>>> i = s.read('ue')
+
+This is more flexible as you can read multiple items in one go, plus you can
+now also use the peek function with ue and se.
+
+* Minor bugs fixed.
+
+See the issue tracker for more details.
+
+-----------------------------------------------------
+June 15th 2009: version 0.4.3 for Python 2.x released
+-----------------------------------------------------
+
+This is a minor update. This release is the first to bundle the bitstring
+manual. This is a PDF and you can find it in the docs directory.
+
+Changes in version 0.4.3
+
+* New 'cut' function
+
+This function returns a generator for constant sized chunks of a BitString.
+
+>>> for byte in s.cut(8):
+...     do_something_with(byte)
+
+You can also specify a startbit and endbit, as well as a count, which limits
+the number of items generated:
+
+>>> first100TSPackets = list(s.cut(188*8, count=100))
+
+* 'slice' function now equivalent to __getitem__.
+
+This means that a step can also be given to the slice function so that the
+following are now the same thing, and it's just a personal preference which
+to use:
+
+>>> s1 = s[a:b:c]
+>>> s2 = s.slice(a, b, c)
+
+* findall gets a 'count' parameter.
+
+So now
+
+>>> list(a.findall(s, count=n))
+
+is equivalent to
+
+>>> list(a.findall(s))[:n]
+
+except that it won't need to generate the whole list and so is much more
+efficient.
+
+* Changes to 'split'.
+
+The split function now has a 'count' parameter rather than 'maxsplit'. This
+makes the interface closer to that for cut, replace and findall. The final item
+generated is now no longer the whole of the rest of the BitString.
+
+* A couple of minor bugs were fixed. See the issue tracker for details.
+
+----------------------------------------------------
+May 25th 2009: version 0.4.2 for Python 2.x released
+----------------------------------------------------
+
+This is a minor update, and almost doesn't break compatibility with version
+0.4.0, but with the slight exception of findall() returning a generator,
+detailed below.
+
+Changes in version 0.4.2
+
+* Stepping in slices
+
+The use of the step parameter (also known as the stride) in slices has been
+added. Its use is a little non-standard as it effectively gives a multiplicative
+factor to apply to the start and stop parameters, rather than skipping over
+bits.
+
+For example this makes it much more convenient if you want to give slices in
+terms of bytes instead of bits. Instead of writing s[a*8:b*8] you can use
+s[a:b:8].
+
+When using a step the BitString is effectively truncated to a multiple of the
+step, so s[::8] is equal to s if s is an integer number of bytes, otherwise it
+is truncated by up to 7 bits. So the final seven complete 16-bit words could be
+written as s[-7::16]
+
+Negative slices are also allowed, and should do what you'd expect. So for
+example s[::-1] returns a bit-reversed copy of s (which is similar to
+s.reversebits(), which does the same operation on s in-place). As another
+example, to get the first 10 bytes in reverse byte order you could use
+s_bytereversed = s[0:10:-8].
+
+* Removed restrictions on offset
+
+You can now specify an offset of greater than 7 bits when creating a BitString,
+and the use of offset is also now permitted when using the filename initialiser.
+This is useful when you want to create a BitString from the middle of a file
+without having to read the file into memory.
+
+>>> f = BitString(filename='reallybigfile', offset=8000000, length=32)
+
+* Integers can be assigned to slices
+
+You can now assign an integer to a slice of a BitString. If the integer doesn't
+fit in the size of slice given then a ValueError exception is raised. So this
+is now allowed and works as expected:
+
+>>> s[8:16] = 106
+
+and is equivalent to
+
+>>> s[8:16] = BitString(uint=106, length=8)
+
+* Less exceptions raised
+
+Some changes have been made to slicing so that less exceptions are raised,
+bringing the interface closer to that for lists. So for example trying to delete
+past the end of the BitString will now just delete to the end, rather than
+raising a ValueError.
+
+* Initialisation from lists and tuples
+
+A new option for the auto initialiser is to pass it a list or tuple. The items
+in the list or tuple are evaluated as booleans and the bits in the BitString are
+set to 1 for True items and 0 for False items. This can be used anywhere the
+auto initialiser can currently be used. For example:
+
+>>> a = BitString([True, 7, False, 0, ()])     # 0b11000
+>>> b = a + ['Yes', '']                        # Adds '0b10'
+>>> (True, True, False) in a
+True
+
+* Miscellany
+
+reversebits() now has optional startbit and endbit parameters.
+
+As an optimisation findall() will return a generator, rather than a list. If you
+still want the whole list then of course you can just call list() on the
+generator.
+
+Improved efficiency of rfind().
+
+A couple of minor bugs were fixed. See the issue tracker for details.
+
+-----------------------------------------------------
+April 23rd 2009: Python 3 only version 0.4.1 released
+-----------------------------------------------------
+
+This version is just a port of version 0.4.0 to Python 3. All the unit tests
+pass, but beyond that only limited ad hoc testing has been done and so it
+should be considered an experimental release. That said, the unit test
+coverage is very good - I'm just not sure if anyone even wants a Python 3
+version!
+
+---------------------------------------
+April 11th 2009: version 0.4.0 released
+---------------------------------------
+Changes in version 0.4.0
+
+* New functions
+
+Added rfind(), findall(), replace(). These do pretty much what you'd expect -
+see the docstrings or the wiki for more information.
+
+* More special functions
+
+Some missing functions were added: __repr__, __contains__, __rand__,
+__ror__, _rxor__ and __delitem__.
+
+* Miscellany
+
+A couple of small bugs were fixed (see the issue tracker).
+
+----
+
+There are some small backward incompatibilities relative to version 0.3.2:
+
+* Combined find() and findbytealigned()
+
+findbytealigned() has been removed, and becomes part of find(). The default
+start position has changed on both find() and split() to be the start of the
+BitString. You may need to recode:
+
+>>> s1.find(bs)
+>>> s2.findbytealigned(bs)
+>>> s2.split(bs)
+
+becomes
+
+>>> s1.find(bs, bytealigned=False, startbit=s1.bitpos)
+>>> s2.find(bs, startbit=s1.bitpos)  # bytealigned defaults to True
+>>> s2.split(bs, startbit=s2.bitpos)
+
+* Reading off end of BitString no longer raises exception.
+
+Previously a read or peek function that encountered the end of the BitString
+would raise a ValueError. It will now instead return the remainder of the
+BitString, which could be an empty BitString. This is closer to the file
+object interface.
+
+* Removed visibility of offset.
+
+The offset property was previously read-only, and has now been removed from
+public view altogether. As it is used internally for efficiency reasons you
+shouldn't really have needed to use it. If you do then use the _offset parameter
+instead (with caution).
+
+---------------------------------------
+March 11th 2009: version 0.3.2 released
+---------------------------------------
+Changes in version 0.3.2
+
+* Better performance
+
+A number of functions (especially find() and findbytealigned()) have been sped
+up considerably.
+
+* Bit-wise operations
+
+Added support for bit-wise AND (&), OR (|) and XOR (^). For example:
+
+>>> a = BitString('0b00111')
+>>> print a & '0b10101'
+0b00101
+
+* Miscellany
+
+Added seekbit() and seekbyte() functions. These complement the 'advance' and
+'retreat' functions, although you can still just use bitpos and bytepos
+properties directly.
+
+>>> a.seekbit(100)                   # Equivalent to a.bitpos = 100
+
+Allowed comparisons between BitString objects and strings. For example this
+will now work:
+
+>>> a = BitString('0b00001111')
+>>> a == '0x0f'
+True
+
+------------------------------------------
+February 26th 2009: version 0.3.1 released
+------------------------------------------
+Changes in version 0.3.1
+
+This version only adds features and fixes bugs relative to 0.3.0, and doesn't
+break backwards compatibility.
+
+* Octal interpretation and initialisation
+
+The oct property now joins bin and hex. Just prefix octal numbers with '0o'.
+
+>>> a = BitString('0o755')
+>>> print a.bin
+0b111101101
+
+* Simpler copying
+
+Rather than using b = copy.copy(a) to create a copy of a BitString, now you
+can just use b = BitString(a).
+
+* More special methods
+
+Lots of new special methods added, for example bit-shifting via << and >>,
+equality testing via == and !=, bit inversion (~) and concatenation using *.
+
+Also __setitem__ is now supported so BitString objects can be modified using
+standard index notation.
+
+* Proper installer
+
+Finally got round to writing the distutils script. To install just
+python setup.py install.
+
+------------------------------------------
+February 15th 2009: version 0.3.0 released
+------------------------------------------
+Changes in version 0.3.0
+
+* Simpler initialisation from binary and hexadecimal
+
+The first argument in the BitString constructor is now called auto and will
+attempt to interpret the type of a string. Prefix binary numbers with '0b'
+and hexadecimals with '0x'.
+
+>>> a = BitString('0b0')         # single zero bit
+>>> b = BitString('0xffff')      # two bytes
+
+Previously the first argument was data, so if you relied on this then you
+will need to recode:
+
+>>> a = BitString('\x00\x00\x01\xb3')   # Don't do this any more!
+
+becomes
+
+>>> a = BitString(data='\x00\x00\x01\xb3')
+
+or just
+
+>>> a = BitString('0x000001b3')
+
+This new notation can also be used in functions that take a BitString as an
+argument. For example:
+
+>>> a = BitString('0x0011') + '0xff'
+>>> a.insert('0b001', 6)
+>>> a.find('0b1111')
+
+* BitString made more mutable
+
+The functions append, deletebits, insert, overwrite, truncatestart and
+truncateend now modify the BitString that they act upon. This allows for
+cleaner and more efficient code, but you may need to rewrite slightly if you
+depended upon the old behaviour:
+
+>>> a = BitString(hex='0xffff')
+>>> a = a.append(BitString(hex='0x00'))
+>>> b = a.deletebits(10, 10)
+
+becomes:
+
+>>> a = BitString('0xffff')
+>>> a.append('0x00')
+>>> b = copy.copy(a)
+>>> b.deletebits(10, 10)
+
+Thanks to Frank Aune for suggestions in this and other areas.
+
+* Changes to printing
+
+The binary interpretation of a BitString is now prepended with '0b'. This is
+in keeping with the Python 2.6 (and 3.0) bin function. The prefix is optional
+when initialising using 'bin='.
+
+Also, if you just print a BitString with no interpretation it will pick
+something appropriate - hex if it is an integer number of bytes, otherwise
+binary. If the BitString representation is very long it will be truncated
+by '...' so it is only an approximate interpretation.
+
+>>> a = BitString('0b0011111')
+>>> print a
+0b0011111
+>>> a += '0b0'
+>>> print a
+0x3e
+
+* More convenience functions
+
+Some missing functions such as advancebit and deletebytes have been added. Also
+a number of peek functions make an appearance as have prepend and reversebits.
+See the Tutorial for more details.
+
+-----------------------------------------
+January 13th 2009: version 0.2.0 released
+-----------------------------------------
+Some fairly minor updates, not really deserving of a whole version point update.
+------------------------------------------
+December 29th 2008: version 0.1.0 released
+------------------------------------------
+First release!
```

### Comparing `bitstring-4.2.1/tests/test.m1v` & `bitstring-4.2.2/tests/test.m1v`

 * *Files identical despite different names*

### Comparing `bitstring-4.2.1/tests/test_array.py` & `bitstring-4.2.2/tests/test_array.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,929 +1,929 @@
-#!/usr/bin/env python
-import pytest
-import sys
-import bitstring
-import array
-import os
-from bitstring import Array, Bits, BitArray
-import copy
-import itertools
-import io
-from bitstring.dtypes import Dtype
-import re
-
-sys.path.insert(0, '..')
-
-
-THIS_DIR = os.path.dirname(os.path.abspath(__file__))
-
-def remove_unprintable(s: str) -> str:
-    colour_escape = re.compile(r'(?:\x1B[@-_])[0-?]*[ -/]*[@-~]')
-    return colour_escape.sub('', s)
-
-class TestCreation:
-
-    def test_creation_from_int(self):
-        a = Array('u12', 20)
-        assert len(a) == 20
-        assert a[19] == 0
-        with pytest.raises(IndexError):
-            _ = a[20]
-
-    def test_creation_from_int_list(self):
-        a = Array('i4', [-3, -2, -1, 0, 7])
-        assert len(a) == 5
-        assert a[2] == -1
-        assert a[-1] == 7
-
-    def test_creation_from_bytes_explicit(self):
-        a = Array('hex:8')
-        a.data.bytes = b'ABCD'
-        assert a[0] == '41'
-        assert a[1] == '42'
-        assert a[2] == '43'
-        assert a[3] == '44'
-
-    def test_creation_from_bits_format(self):
-        a = Bits('0x000102030405')
-        b = Array('bits:8', a)
-        c = Array('bits:8', [Bits('0x00'), Bits('0x01'), Bits('0x02'), Bits('0x03'), Bits('0x04'), Bits('0x05')])
-        assert b.equals(c)
-
-    def test_creation_from_float8(self):
-        a = Array('p4binary')
-        a.data.bytes = b'\x7f\x00'
-        assert a[0] == float('inf')
-        assert a[1] == 0.0
-        b = Array('p4binary', [100000, -0.0])
-        assert a.equals(b)
-
-    def test_creation_from_multiple(self):
-        with pytest.raises(ValueError):
-            _ = Array('2*float16')
-
-    def test_changing_fmt(self):
-        d = Dtype('u', 8)
-        a = Array(d, [255]*100)
-        assert len(a) == 100
-        a.dtype = Dtype('int', 4)
-        assert len(a) == 200
-        assert a.count(-1) == 200
-        a.append(5)
-        assert len(a) == 201
-        assert a.count(-1) == 200
-
-        a = Array('>d', [0, 0, 1])
-        with pytest.raises(ValueError):
-            a.dtype = 'se'
-        assert a[-1] == 1.0
-        assert a.dtype == Dtype('float64')
-
-    def test_changing_format_with_trailing_bits(self):
-        a = Array('bool', 803)
-        assert len(a) == 803
-        a.dtype = '>e'
-        assert len(a) == 803 // 16
-        b = Array('>f', [0])
-        b.dtype = 'i3'
-        assert b.tolist() == [0]*10
-
-    def test_creation_with_trailing_bits(self):
-        a = Array('bool', trailing_bits='0xf')
-        assert a.data == '0b1111'
-        assert len(a) == 4
-
-        b = Array('bin:3', ['111', '000', '111'])
-        assert len(b) == 3
-        assert b.data == '0b111000111'
-        b.dtype = 'h4'
-        assert len(b) == 2
-        with pytest.raises(ValueError):
-            b.append('f')
-        del b.data[0]
-        b.append('f')
-        assert len(b) == 3
-
-        c = Array('>e', trailing_bits='0x0000, 0b1')
-        assert c[0] == 0.0
-        assert c.tolist() == [0.0]
-
-    def test_creation_with_array_code(self):
-        a = Array('<f')
-        assert a.itemsize == 32
-
-    def test_creation_from_bytes(self):
-        a = Array('u8', b'ABC')
-        assert len(a) == 3
-        assert a[0] == 65
-        assert not a.trailing_bits
-
-    def test_creation_from_bytearray(self):
-        a = Array('u7', bytearray(range(70)))
-        assert len(a) == 80
-        assert not a.trailing_bits
-
-    def test_creation_from_memoryview(self):
-        x = b'1234567890'
-        m = memoryview(x[2:5])
-        assert m == b'345'
-        a = Array('u8', m)
-        assert a.tolist() == [ord('3'), ord('4'), ord('5')]
-
-    def test_creation_from_bits(self):
-        a = bitstring.pack('20*i19', *range(-10, 10))
-        b = Array('i19', a)
-        assert b.tolist() == list(range(-10, 10))
-
-    def test_creation_from_array_array(self):
-        a = array.array('H', [10, 20, 30, 40])
-        b = Array('uintne16', a)
-        assert a.tolist() == b.tolist()
-        assert a.tobytes() == b.tobytes()
-        with pytest.raises(ValueError):
-            _ = Array('float16', a)
-
-    def test_creation_from_file(self):
-        filename = os.path.join(THIS_DIR, 'test.m1v')
-        with open(filename, 'rb') as f:
-            a = Array('uint8', f)
-            assert a[0:4].tobytes() == b'\x00\x00\x01\xb3'
-
-    def test_different_type_codes(self):
-        a = Array('>H', [10, 20])
-        assert a.data.unpack('2*uint16') == a.tolist()
-        a = Array('<h', [-10, 20])
-        assert a.data.unpack('2*intle16') == a.tolist()
-        a = Array('<e', [0.25, -1000])
-        assert a.data.unpack('2*floatle16') == a.tolist()
-
-    def test_format_changes(self):
-        a = Array('uint8', [5, 4, 3])
-        with pytest.raises(ValueError):
-            a.dtype = 'ue3'
-        b = a[:]
-        b.dtype = 'int8'
-        assert a.tolist() == b.tolist()
-        assert not a.equals(b)
-        with pytest.raises(ValueError):
-            b.dtype = 'hello_everyone'
-        with pytest.raises(ValueError):
-            b.dtype = 'float'
-        with pytest.raises(ValueError):
-            b.dtype = 'uintle12'
-            _ = b[0]
-        with pytest.raises(ValueError):
-            b.dtype = 'float17'
-
-
-class TestArrayMethods:
-
-    def test_count(self):
-        a = Array('u9', [0, 4, 3, 2, 3, 4, 2, 3, 2, 1, 2, 11, 2, 1])
-        assert a.count(0) == 1
-        assert a.count(-1) == 0
-        assert a.count(2) == 5
-
-    def test_count_nan(self):
-        a = Array('uint8', [0, 10, 128, 128, 4, 2, 1])
-        a.dtype = 'p3binary'
-        assert a.count(float('nan')) == 2
-
-    def test_from_bytes(self):
-        a = Array('i16')
-        assert len(a) == 0
-        a.data += bytearray([0, 0, 0, 55])
-        assert len(a) == 2
-        assert a[0] == 0
-        assert a[1] == 55
-        a.data += b'\x01\x00'
-        assert len(a) == 3
-        assert a[-1] == 256
-        a.data += bytearray()
-        assert len(a) == 3
-
-    def test_equals(self):
-        a = Array('hex:40')
-        b = Array('h40')
-        assert a.equals(b)
-        c = Array('bin:40')
-        assert not a.equals(c)
-        v = ['1234567890']
-        a.extend(v)
-        b.extend(v)
-        assert a.equals(b)
-        b.extend(v)
-        assert not a.equals(b)
-
-        a = Array('uint20', [16, 32, 64, 128])
-        b = Array('uint10', [0, 16, 0, 32, 0, 64, 0, 128])
-        assert not b.equals(a)
-        b.dtype = 'u20'
-        assert a.equals(b)
-        a.data += '0b1'
-        assert not a.equals(b)
-        b.data += '0b1'
-        assert a.equals(b)
-
-        c = Array('uint8', [1, 2])
-        assert not c.equals('hello')
-        assert not c.equals(array.array('B', [1, 3]))
-
-    def test_equals_with_trailing_bits(self):
-        a = Array('hex4', ['a', 'b', 'c', 'd', 'e', 'f'])
-        c = Array('hex4')
-        c.data = BitArray('0xabcdef, 0b11')
-        assert a.tolist() == c.tolist()
-        assert a != c
-        a.data.append('0b11')
-        assert a.tolist() == c.tolist()
-        assert a.equals(c)
-
-    def test_setting(self):
-        a = Array('bool')
-        a.data += b'\x00'
-        a[0] = 1
-        assert a[0] == True
-
-        b = Array('h12')
-        with pytest.raises(ValueError):
-            b.append('12')
-        b.append('123')
-        with pytest.raises(ValueError):
-            b.extend(['3456'])
-        b.extend(['345'])
-        assert b.tolist() == ['123', '345']
-        with pytest.raises(ValueError):
-            b[0] = 'abcd'
-        with pytest.raises(ValueError):
-            b[0] = 12
-        with pytest.raises(ValueError):
-            b[0] = Bits('0xfff')
-        b[0] = 'fff'
-        assert b.data.hex == 'fff345'
-
-    def test_setting_from_iterable(self):
-        a = Array('uint99', range(100))
-        x = itertools.chain([1, 2, 3], [4, 5])
-        a[10:15] = x
-        assert a[10:15].tolist() == list(range(1, 6))
-        x = itertools.chain([1, 2, 3], [4, 5])
-        a[50:60:2] = x
-        assert a[50:60:2].tolist() == list(range(1, 6))
-
-    def test_equivalence(self):
-        a = Array('floatne32', [54.2, -998, 411.9])
-        b = Array('floatne32')
-        b.extend(a.tolist())
-        assert a.data == b.data
-
-        b = array.array('f', [54.2, -998, 411.9])
-        assert a.equals(b)
-        a.dtype = 'bool'
-        assert not a.equals(b)
-        a.dtype = 'floatne16'
-        assert not a.equals(b)
-        a.dtype = 'floatne32'
-        a.data += '0x0'
-        assert not a.equals(b)
-        a.data += '0x0000000'
-        assert not a.equals(b)
-        b.append(0.0)
-        assert a.equals(b)
-
-    def test_extend(self):
-        a = Array('uint:3', (1, 2, 3))
-        a.extend([4, 5, 6])
-        assert a.tolist() == [1, 2, 3, 4, 5, 6]
-        a.extend([])
-        assert a.tolist() == [1, 2, 3, 4, 5, 6]
-        a.extend(a)
-        assert a.tolist() == [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]
-        b = Array('int:3', [0])
-        with pytest.raises(TypeError):
-            a.extend(b)
-        del a.data[0]
-        with pytest.raises(ValueError):
-            a.extend([1, 0])
-        del a.data[-2:]
-        with pytest.raises(TypeError):
-            a.extend('uint:3=3')  # Can't extend with a str even though it's iterable
-
-    def test_extend_with_mixed_classes(self):
-        a = Array('uint8', [1, 2, 3])
-        b = array.array('B', [4, 5, 6])
-        ap = Array('uint8', a[:])
-        bp = array.array('B', b[:])
-        a.extend(b)
-        bp.extend(ap)
-        assert a.tolist() == [1, 2, 3, 4, 5, 6]
-        assert bp.tolist() == [4, 5, 6, 1, 2, 3]
-
-        a.dtype = 'int8'
-        ap = Array('uint8', a.tolist())
-        assert not a.equals(ap)
-        assert a.tolist() == ap.tolist()
-
-    def test_insert(self):
-        a = Array('hex:12', ['abc', 'def'])
-        assert a.data.hex == 'abcdef'
-        a.insert(0, '000')
-        assert a.data.hex == '000abcdef'
-        a.insert(-1, '111')
-        assert a[-1] == 'def'
-        assert a[-2] == '111'
-        a.data += '0b1'
-        assert a[-1] == 'def'
-        a.insert(1, '111')
-        assert a.tolist() == ['000', '111', 'abc', '111', 'def']
-
-        with pytest.raises(ValueError):
-            a.insert(2, 'hello')
-        with pytest.raises(ValueError):
-            a.insert(2, 'ab')
-
-    def test_pop(self):
-        a = Array('oct:6', ['33', '21', '11', '76'])
-        with pytest.raises(IndexError):
-            _ = a.pop(4)
-        assert len(a) == 4
-        x = a.pop()
-        assert len(a) == 3
-        assert x == '76'
-        with pytest.raises(IndexError):
-            _ = a.pop(3)
-        x = a.pop(2)
-        assert x == '11'
-        x = a.pop(0)
-        assert x == '33'
-        x = a.pop()
-        assert x == '21'
-        with pytest.raises(IndexError):
-            _ = a.pop()
-
-    def test_reverse(self):
-        a = Array('int30', [])
-        a.reverse()
-        assert a.tolist() == []
-        a.append(2)
-        a.reverse()
-        assert a.tolist() == [2]
-        a.append(3)
-        a.reverse()
-        assert a.tolist() == [3, 2]
-        a.data.clear()
-        a.extend(list(range(1000)))
-        a.reverse()
-        assert a.tolist() == list(range(999, -1, -1))
-        x = a.pop(0)
-        assert x == 999
-        a.reverse()
-        assert a.tolist() == list(range(0, 999))
-        a.data += '0b1'
-        with pytest.raises(ValueError):
-            a.reverse()
-
-    def test_byteswap(self):
-        a = Array('float16')
-        a.byteswap()
-        assert a.tolist() == []
-        b = Array('uint17')
-        with pytest.raises(ValueError):
-            b.byteswap()
-        a.extend([0.25, 104, -6])
-        a.byteswap()
-        assert a.data.unpack('3*floatle16') == [0.25, 104, -6]
-        a.byteswap()
-        assert a.tolist() == [0.25, 104, -6]
-
-    def test_to_file(self):
-        filename = os.path.join(THIS_DIR, 'temp_bitstring_unit_testing_file')
-        a = Array('uint5', [0, 1, 2, 3, 4, 5])
-        with open(filename, 'wb') as f:
-            a.tofile(f)
-        with open(filename, 'rb') as f:
-            b = Array('u5')
-            b.fromfile(f, 1)
-        assert b.tolist() == [0]
-
-    def test_getting(self):
-        a = Array('int17')
-        with pytest.raises(IndexError):
-            _ = a[0]
-        a.extend([1, 2, 3, 4])
-        assert a[:].equals(Array('i17', [1, 2, 3, 4]))
-        assert a[:1].equals(Array('i17', [1]))
-        assert a[1:3].equals(Array('i17', [2, 3]))
-        assert a[-2:].equals(Array('i17', [3, 4]))
-        assert a[::2].equals(Array('i17', [1, 3]))
-        assert a[::-2].equals(Array('i17', [4, 2]))
-
-    def test_more_setting(self):
-        a = Array('i1', [0, -1, -1, 0, 0, -1, 0])
-        a[0] = -1
-        assert a[0] == -1
-        a[0:3] = [0, 0]
-        assert a.tolist() == [0, 0, 0, 0, -1, 0]
-        b = Array('i20', a.tolist())
-        with pytest.raises(TypeError):
-            b[::2] = 9
-        b[::2] = [9]*3
-        assert b.tolist() == [9, 0, 9, 0, 9, 0]
-        b[1:4] = a[-2:]
-        assert b.tolist() == [9, -1, 0, 9, 0]
-
-    def test_deleting(self):
-        a = Array('u99', list(range(1000)))
-        del a[::2]
-        assert len(a) == 500
-        del a[-100:]
-        assert len(a) == 400
-        assert a[:10].tolist() == [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
-        with pytest.raises(IndexError):
-            del a[len(a)]
-        with pytest.raises(IndexError):
-            del a[-len(a) - 1]
-
-    def test_deleting_more_ranges(self):
-        a = Array('uint:18', [1, 2, 3, 4, 5, 6])
-        del a[3:1:-1]
-        assert a.tolist() == [1, 2, 5, 6]
-
-
-    def test_repr(self):
-        a = Array('int5')
-        b = eval(a.__repr__())
-        assert a.equals(b)
-        a.data += '0b11'
-
-        b = eval(a.__repr__())
-        assert a.equals(b)
-
-        a.data += '0b000'
-        b = eval(a.__repr__())
-        assert a.equals(b)
-
-        a.extend([1]*9)
-        b = eval(a.__repr__())
-        assert a.equals(b)
-
-        a.extend([-4]*100)
-        b = eval(a.__repr__())
-        assert a.equals(b)
-
-        a.dtype = 'float32'
-        b = eval(a.__repr__())
-        assert a.equals(b)
-
-    def test__add__(self):
-        a = Array('=B', [1, 2, 3])
-        b = Array('u8', [3, 4])
-        c = a[:]
-        c.extend(b)
-        assert a.equals(Array('=B', [1, 2, 3]))
-        assert c.equals(Array('=B', [1, 2, 3, 3, 4]))
-        d = a[:]
-        d.extend([10, 11, 12])
-        assert d.equals(Array('uint:8', [1, 2, 3, 10, 11, 12]))
-
-    def test__contains__(self):
-        a = Array('i9', [-1, 88, 3])
-        assert 88 in a
-        assert not 89 in a
-
-    def test__copy__(self):
-        a = Array('i4')
-        a.data += '0x123451234561'
-        b = copy.copy(a)
-        assert a.equals(b)
-        a.data += '0b1010'
-        assert not a.equals(b)
-
-    def test__iadd__(self):
-        a = Array('uint999')
-        a.extend([4])
-        assert a.tolist() == [4]
-        a += 5
-        a.extend(a)
-        assert a.tolist() == [9, 9]
-
-    def test_float8_bug(self):
-        a = Array('p3binary', [0.0, 1.5])
-        b = Array('p4binary')
-        b[:] = a[:]
-        assert b[:].equals(Array('p4binary', [0.0, 1.5]))
-
-    def test_pp(self):
-        a = Array('bfloat', [-3, 1, 2])
-        s = io.StringIO()
-        a.pp('hex', stream=s)
-        assert remove_unprintable(s.getvalue()) ==  "<Array fmt='hex', length=3, itemsize=16 bits, total data size=6 bytes> [\n" \
-                                        " 0: c040 3f80 4000\n" \
-                                        "]\n"
-        a.data += '0b110'
-        a.dtype='hex16'
-        s = io.StringIO()
-        a.pp(stream=s)
-        assert remove_unprintable(s.getvalue()) ==  """<Array dtype='hex16', length=3, itemsize=16 bits, total data size=7 bytes> [
- 0: c040 3f80 4000
-] + trailing_bits = 0b110\n"""
-
-    def test_pp_uint(self):
-        a = Array('uint32', [12, 100, 99])
-        s = io.StringIO()
-        a.pp(stream=s)
-        assert remove_unprintable(s.getvalue()) == """<Array dtype='uint32', length=3, itemsize=32 bits, total data size=12 bytes> [
- 0:         12        100         99
-]\n"""
-
-    def test_pp_bits(self):
-        a = Array('bits2', b'89')
-        s = io.StringIO()
-        a.pp(stream=s, width=0, show_offset=True)
-        assert remove_unprintable(s.getvalue()) == """<Array dtype='bits2', length=8, itemsize=2 bits, total data size=2 bytes> [
- 0: 0b00
- 1: 0b11
- 2: 0b10
- 3: 0b00
- 4: 0b00
- 5: 0b11
- 6: 0b10
- 7: 0b01
-]\n"""
-
-    def test_pp_two_formats(self):
-        a = Array('float16', bytearray(20))
-        s = io.StringIO()
-        a.pp(stream=s, fmt='p3binary, bin', show_offset=False)
-        assert remove_unprintable(s.getvalue()) == """<Array fmt='p3binary, bin', length=20, itemsize=8 bits, total data size=20 bytes> [
-                0.0                 0.0                 0.0                 0.0 : 00000000 00000000 00000000 00000000
-                0.0                 0.0                 0.0                 0.0 : 00000000 00000000 00000000 00000000
-                0.0                 0.0                 0.0                 0.0 : 00000000 00000000 00000000 00000000
-                0.0                 0.0                 0.0                 0.0 : 00000000 00000000 00000000 00000000
-                0.0                 0.0                 0.0                 0.0 : 00000000 00000000 00000000 00000000
-]\n"""
-
-    def test_pp_two_formats_no_length(self):
-        a = Array('float16', bytearray(range(50, 56)))
-        s = io.StringIO()
-        a.pp(stream=s, fmt='u, b')
-        assert remove_unprintable(s.getvalue()) == """<Array fmt='uint, bin', length=3, itemsize=16 bits, total data size=6 bytes> [
- 0: 12851 13365 13879 : 0011001000110011 0011010000110101 0011011000110111
-]\n"""
-
-
-class TestArrayOperations:
-
-    def test_in_place_add(self):
-        a = Array('i7', [-9, 4, 0])
-        a += 9
-        assert a.tolist() == [0, 13, 9]
-        assert len(a.data) == 21
-
-    def test_add(self):
-        a = Array('>d')
-        a.extend([1.0, -2.0, 100.5])
-        b = a + 2
-        assert a.equals(Array('>d', [1.0, -2.0, 100.5]))
-        assert b.equals(Array('>d', [3.0, 0.0, 102.5]))
-
-    def test_sub(self):
-        a = Array('uint44', [3, 7, 10])
-        b = a - 3
-        assert b.equals(Array('u44', [0, 4, 7]))
-        with pytest.raises(ValueError):
-            _ = a - 4
-
-    def test_in_place_sub(self):
-        a = Array('float16', [-9, -10.5])
-        a -= -1.5
-        assert a.tolist() == [-7.5, -9.0]
-
-    def test_mul(self):
-        a = Array('i21', [-5, -4, 0, 2, 100])
-        b = a * 2
-        assert b.tolist() == [-10, -8, 0, 4, 200]
-        a = Array('int9', [-1, 0, 3])
-        b = a * 2
-        assert a.tolist() == [-1, 0, 3]
-        assert b.tolist() == [-2, 0, 6]
-        c = a * 2.5
-        assert c.tolist() == [-2, 0, 7]
-
-    def test_in_place_mul(self):
-        a = Array('i21', [-5, -4, 0, 2, 100])
-        a *= 0.5
-        assert a.tolist() == [-2, -2, 0, 1, 50]
-
-    def test_div(self):
-        a = Array('i32', [-2, -1, 0, 1, 2])
-        b = a // 2
-        assert a.tolist() == [-2, -1, 0, 1, 2]
-        assert b.tolist() == [-1, -1, 0, 0, 1]
-
-    def test_in_place_div(self):
-        a = Array('i10', [-4, -3, -2, -1, 0, 1, 2])
-        a //= 2
-        assert a.equals(Array('i10', [-2, -2, -1, -1, 0, 0, 1]))
-
-    def test_true_div(self):
-        a = Array('float16', [5, 10, -6])
-        b = a / 4
-        assert a.equals(Array('float16', [5.0, 10.0, -6.0]))
-        assert b.equals(Array('float16', [1.25, 2.5, -1.5]))
-
-    def test_in_place_true_div(self):
-        a = Array('int71', [-4, -3, -2, -1, 0, 1, 2])
-        a /= 2
-        assert a.equals(Array('int71', [-2, -1, -1, 0, 0, 0, 1]))
-
-    def test_and(self):
-        a = Array('int16', [-1, 100, 9])
-        with pytest.raises(TypeError):
-            _ = a & 0
-        b = a & '0x0001'
-        assert b.tolist() == [1, 0, 1]
-        b = a & '0xffff'
-        assert b.dtype == Dtype('int16')
-        assert b.tolist() == [-1, 100, 9]
-
-    def test_in_place_and(self):
-        a = Array('bool', [True, False, True])
-        with pytest.raises(TypeError):
-            a &= 0b1
-        a = Array('uint10', a.tolist())
-        a <<= 3
-        assert a.tolist() == [8, 0, 8]
-        a += 1
-        assert a.tolist() == [9, 1, 9]
-        with pytest.raises(ValueError):
-            a &= '0b111'
-        a &= '0b0000000111'
-        assert a.data == '0b 0000000001 0000000001 0000000001'
-
-    def test_or(self):
-        a = Array('p4binary', [-4, 2.5, -9, 0.25])
-        b = a | '0b10000000'
-        assert a.tolist() == [-4,  2.5, -9,  0.25]
-        assert b.tolist() == [-4, -2.5, -9, -0.25]
-
-    def test_in_place_or(self):
-        a = Array('hex:12')
-        a.append('f0f')
-        a.extend(['000', '111'])
-        a |= '0x00f'
-        assert a.tolist() == ['f0f', '00f', '11f']
-        with pytest.raises(TypeError):
-            a |= 12
-
-    def test_xor(self):
-        a = Array('hex8', ['00', 'ff', 'aa'])
-        b = a ^ '0xff'
-        assert a.tolist() == ['00', 'ff', 'aa']
-        assert b.tolist() == ['ff', '00', '55']
-
-    def test_in_place_xor(self):
-        a = Array('u10', [0, 0xf, 0x1f])
-        a ^= '0b00, 0x0f'
-
-    def test_rshift(self):
-        a = Array(dtype='u8')
-        a.data = Bits('0x00010206')
-        b = a >> 1
-        assert a.tolist() == [0, 1, 2, 6]
-        assert b.tolist() == [0, 0, 1, 3]
-
-        a = Array('i10', [-1, 0, -20, 10])
-        b = a >> 1
-        assert b.tolist() == [-1, 0, -10, 5]
-        c = a >> 0
-        assert c.tolist() == [-1, 0, -20, 10]
-        with pytest.raises(ValueError):
-            _ = a >> -1
-
-    def test_in_place_rshift(self):
-        a = Array('i8', [-8, -1, 0, 1, 100])
-        a >>= 1
-        assert a.tolist() == [-4, -1, 0, 0, 50]
-        a >>= 100000
-        assert a.tolist() == [-1, -1, 0, 0, 0]
-
-    def test_lshift(self):
-        a = Array('p3binary', [0.3, 1.2])
-        with pytest.raises(TypeError):
-            _ = a << 3
-        a = Array('int16', [-2, -1, 0, 128])
-        b = a << 4
-        assert a.tolist() == [-2, -1, 0, 128]
-        assert b.tolist() == [-32, -16, 0, 2048]
-        with pytest.raises(ValueError):
-            _ = a << 1000
-
-    def test_in_place_lshift(self):
-        a = Array('u11', [0, 5, 10, 1, 2, 3])
-        a <<= 2
-        assert a.tolist() == [0, 20, 40, 4, 8, 12]
-        a <<= 0
-        assert a.tolist() == [0, 20, 40, 4, 8, 12]
-        with pytest.raises(ValueError):
-            a <<= -1
-
-    def test_neg(self):
-        a = Array('i92', [-1, 1, 0, 100, -100])
-        b = -a
-        assert b.tolist() == [1, -1, 0, -100, 100]
-        assert str(b.dtype) == 'int92'
-
-    def test_abs(self):
-        a = Array('float16', [-2.0, 0, -0, 100, -5.5])
-        b = abs(a)
-        assert b.equals(Array('float16', [2.0, 0, 0, 100, 5.5]))
-
-
-class TestCreationFromBits:
-
-    def test_appending_auto(self):
-        a = Array('bits8')
-        a.append('0xff')
-        assert len(a) == 1
-        assert a[0] == Bits('0xff')
-        with pytest.raises(TypeError):
-            a += 8
-        a.append(Bits(8))
-        assert a[:].equals(Array('bits:8', ['0b1111 1111', Bits('0x00')]))
-        a.extend(['0b10101011'])
-        assert a[-1].hex == 'ab'
-
-
-class TestSameSizeArrayOperations:
-
-    def test_adding_same_types(self):
-        a = Array('u8', [1, 2, 3, 4])
-        b = Array('u8', [5, 5, 5, 4])
-        c = a + b
-        assert c.tolist() == [6, 7, 8, 8]
-        assert c.dtype == Dtype('uint8')
-
-    def test_adding_different_types(self):
-        a = Array('u8', [1, 2, 3, 4])
-        b = Array('i6', [5, 5, 5, 4])
-        c = a + b
-        assert c.tolist() == [6, 7, 8, 8]
-        assert c.dtype == Dtype('int6')
-        d = Array('float16', [-10, 0, 5, 2])
-        e = d + a
-        assert e.tolist() == [-9.0, 2.0, 8.0, 6.0]
-        assert e.dtype == Dtype('float16')
-        e = a + d
-        assert e.tolist() == [-9.0, 2.0, 8.0, 6.0]
-        assert e.dtype == Dtype('float16')
-        x1 = a[:]
-        x2 = a[:]
-        x1.dtype = 'p3binary'
-        x2.dtype = 'p4binary'
-        y = x1 + x2
-        assert y.dtype == x1.dtype
-
-    def test_adding_errors(self):
-        a = Array('float16', [10, 100, 1000])
-        b = Array('i3', [-1, 2])
-        with pytest.raises(ValueError):
-            _ = a + b
-        b.append(0)
-        c = a + b
-        assert c.tolist() == [9, 102, 1000]
-        a.dtype='hex16'
-        with pytest.raises(ValueError):
-            _ = a + b
-
-
-class TestComparisonOperators:
-
-    def test_less_than_with_scalar(self):
-        a = Array('u16', [14, 16, 100, 2, 100])
-        b = a < 80
-        assert b.tolist() == [True, True, False, True, False]
-        assert b.dtype == Dtype('bool')
-
-    def test_less_than_with_array(self):
-        a = Array('u16', [14, 16, 100, 2, 100])
-        b = Array('bfloat', [1000, -54, 0.2, 55, 9])
-        c = a < b
-        assert c.tolist() == [True, False, False, True, False]
-        assert c.dtype == Dtype('bool')
-
-    def test_array_equals(self):
-        a = Array('i12', [1, 2, -3, 4, -5, 6])
-        b = Array('i12', [6, 5, 4, 3, 2, 1])
-        assert abs(a).equals(b[::-1])
-        assert (a == b) == [False, False, False, False, False, False]
-        assert (a != b) == [True, True, True, True, True, True]
-        with pytest.raises(ValueError):
-            _ = a == b[:-1]
-        with pytest.raises(ValueError):
-            _ = a == [1, 2, 3]
-        with pytest.raises(ValueError):
-            _ = [1, 2, 3] == a
-        with pytest.raises(ValueError):
-            _ = a == [1, 2, 3, 4, 5, 6, 7]
-
-class TestAsType:
-
-    def test_switching_int_types(self):
-        a = Array('u8', [15, 42, 1])
-        b = a.astype('i8')
-        assert a.tolist() == b.tolist()
-        assert b.dtype == Dtype('i8')
-
-    def test_switching_float_types(self):
-        a = Array('float64', [-990, 34, 1, 0.25])
-        b = a.astype('float16')
-        assert a.tolist() == b.tolist()
-        assert b.dtype == Dtype('float16')
-
-
-class TestReverseMethods:
-
-    def test_radd(self):
-        a = Array('u6', [1,2,3])
-        b = 5 + a
-        assert b.equals(Array('uint:6', [6, 7, 8]))
-
-    def test_rmul(self):
-        a = Array('bfloat', [4, 2, 8])
-        b = 0.5 * a
-        assert b.equals(Array('bfloat16', [2.0, 1.0, 4.0]))
-
-    def test_rsub(self):
-        a = Array('i90', [-1, -10, -100])
-        b = 100 - a
-        assert b.equals(Array('int90', [101, 110, 200]))
-
-    def test_rmod(self):
-        a = Array('i8', [1, 2, 4, 8, 10])
-        with pytest.raises(TypeError):
-            _ = 15 % a
-
-    def test_rfloordiv(self):
-        a = Array('>H', [1, 2, 3, 4, 5])
-        with pytest.raises(TypeError):
-            _ = 100 // a
-
-    def test_rtruediv(self):
-        a = Array('>H', [1, 2, 3, 4, 5])
-        with pytest.raises(TypeError):
-            _ = 100 / a
-
-    def test_rand(self):
-        a = Array('u8', [255, 8, 4, 2, 1, 0])
-        b = '0x0f' & a
-        assert b.tolist() == [15, 8, 4, 2, 1, 0]
-
-    def test_ror(self):
-        a = Array('u8', [255, 8, 4, 2, 1, 0])
-        b = '0x0f' | a
-        assert b.tolist() == [255, 15, 15, 15, 15, 15]
-
-    def test_rxor(self):
-        a = Array('u8', [255, 8, 4, 2, 1, 0])
-        b = '0x01' ^ a
-        assert b.tolist() == [254, 9, 5, 3, 0, 1]
-
-
-class TestMisc:
-
-    def test_invalid_type_assignment(self):
-        a = Array('u8', [1,2,3])
-        with pytest.raises(ValueError):
-            a.dtype = 'penguin'
-
-    def test_set_extended_slice(self):
-        a = Array('bool', [0,1,1,1,0])
-        with pytest.raises(ValueError):
-            a[0:5:2] = [1, 0]
-
-    def test_set_out_of_range_element(self):
-        a = Array(Dtype('float', 16), [1, 2, 3, 4.5])
-        a[3] = 100.0
-        a[-4] = 100.0
-        with pytest.raises(IndexError):
-            a[4] = 100.0
-        with pytest.raises(IndexError):
-            a[-5] = 100.0
-
-    def test_bytes(self):
-        a = Array('bytes8', 5)
-        assert a.data == b'\x00'*40
-
-        b = Array('bytes1', 5)
-        assert b.data == b'\x00'*5
-
-    def test_bytes_trailing_bits(self):
-        b = Bits('0x000000, 0b111')
-        a = Array('bytes1', b)
-        assert a.trailing_bits == '0b111'
-
-    def test_operation_with_bool(self):
-        x = Array('int4', [1, 2, 3, 4])
-        y = Array('float16', [100, 2.0, 0.0, 4])
-        x = x + (y == 0.0)
+#!/usr/bin/env python
+import pytest
+import sys
+import bitstring
+import array
+import os
+from bitstring import Array, Bits, BitArray
+import copy
+import itertools
+import io
+from bitstring.dtypes import Dtype
+import re
+
+sys.path.insert(0, '..')
+
+
+THIS_DIR = os.path.dirname(os.path.abspath(__file__))
+
+def remove_unprintable(s: str) -> str:
+    colour_escape = re.compile(r'(?:\x1B[@-_])[0-?]*[ -/]*[@-~]')
+    return colour_escape.sub('', s)
+
+class TestCreation:
+
+    def test_creation_from_int(self):
+        a = Array('u12', 20)
+        assert len(a) == 20
+        assert a[19] == 0
+        with pytest.raises(IndexError):
+            _ = a[20]
+
+    def test_creation_from_int_list(self):
+        a = Array('i4', [-3, -2, -1, 0, 7])
+        assert len(a) == 5
+        assert a[2] == -1
+        assert a[-1] == 7
+
+    def test_creation_from_bytes_explicit(self):
+        a = Array('hex:8')
+        a.data.bytes = b'ABCD'
+        assert a[0] == '41'
+        assert a[1] == '42'
+        assert a[2] == '43'
+        assert a[3] == '44'
+
+    def test_creation_from_bits_format(self):
+        a = Bits('0x000102030405')
+        b = Array('bits:8', a)
+        c = Array('bits:8', [Bits('0x00'), Bits('0x01'), Bits('0x02'), Bits('0x03'), Bits('0x04'), Bits('0x05')])
+        assert b.equals(c)
+
+    def test_creation_from_float8(self):
+        a = Array('p4binary')
+        a.data.bytes = b'\x7f\x00'
+        assert a[0] == float('inf')
+        assert a[1] == 0.0
+        b = Array('p4binary', [100000, -0.0])
+        assert a.equals(b)
+
+    def test_creation_from_multiple(self):
+        with pytest.raises(ValueError):
+            _ = Array('2*float16')
+
+    def test_changing_fmt(self):
+        d = Dtype('u', 8)
+        a = Array(d, [255]*100)
+        assert len(a) == 100
+        a.dtype = Dtype('int', 4)
+        assert len(a) == 200
+        assert a.count(-1) == 200
+        a.append(5)
+        assert len(a) == 201
+        assert a.count(-1) == 200
+
+        a = Array('>d', [0, 0, 1])
+        with pytest.raises(ValueError):
+            a.dtype = 'se'
+        assert a[-1] == 1.0
+        assert a.dtype == Dtype('float64')
+
+    def test_changing_format_with_trailing_bits(self):
+        a = Array('bool', 803)
+        assert len(a) == 803
+        a.dtype = '>e'
+        assert len(a) == 803 // 16
+        b = Array('>f', [0])
+        b.dtype = 'i3'
+        assert b.tolist() == [0]*10
+
+    def test_creation_with_trailing_bits(self):
+        a = Array('bool', trailing_bits='0xf')
+        assert a.data == '0b1111'
+        assert len(a) == 4
+
+        b = Array('bin:3', ['111', '000', '111'])
+        assert len(b) == 3
+        assert b.data == '0b111000111'
+        b.dtype = 'h4'
+        assert len(b) == 2
+        with pytest.raises(ValueError):
+            b.append('f')
+        del b.data[0]
+        b.append('f')
+        assert len(b) == 3
+
+        c = Array('>e', trailing_bits='0x0000, 0b1')
+        assert c[0] == 0.0
+        assert c.tolist() == [0.0]
+
+    def test_creation_with_array_code(self):
+        a = Array('<f')
+        assert a.itemsize == 32
+
+    def test_creation_from_bytes(self):
+        a = Array('u8', b'ABC')
+        assert len(a) == 3
+        assert a[0] == 65
+        assert not a.trailing_bits
+
+    def test_creation_from_bytearray(self):
+        a = Array('u7', bytearray(range(70)))
+        assert len(a) == 80
+        assert not a.trailing_bits
+
+    def test_creation_from_memoryview(self):
+        x = b'1234567890'
+        m = memoryview(x[2:5])
+        assert m == b'345'
+        a = Array('u8', m)
+        assert a.tolist() == [ord('3'), ord('4'), ord('5')]
+
+    def test_creation_from_bits(self):
+        a = bitstring.pack('20*i19', *range(-10, 10))
+        b = Array('i19', a)
+        assert b.tolist() == list(range(-10, 10))
+
+    def test_creation_from_array_array(self):
+        a = array.array('H', [10, 20, 30, 40])
+        b = Array('uintne16', a)
+        assert a.tolist() == b.tolist()
+        assert a.tobytes() == b.tobytes()
+        with pytest.raises(ValueError):
+            _ = Array('float16', a)
+
+    def test_creation_from_file(self):
+        filename = os.path.join(THIS_DIR, 'test.m1v')
+        with open(filename, 'rb') as f:
+            a = Array('uint8', f)
+            assert a[0:4].tobytes() == b'\x00\x00\x01\xb3'
+
+    def test_different_type_codes(self):
+        a = Array('>H', [10, 20])
+        assert a.data.unpack('2*uint16') == a.tolist()
+        a = Array('<h', [-10, 20])
+        assert a.data.unpack('2*intle16') == a.tolist()
+        a = Array('<e', [0.25, -1000])
+        assert a.data.unpack('2*floatle16') == a.tolist()
+
+    def test_format_changes(self):
+        a = Array('uint8', [5, 4, 3])
+        with pytest.raises(ValueError):
+            a.dtype = 'ue3'
+        b = a[:]
+        b.dtype = 'int8'
+        assert a.tolist() == b.tolist()
+        assert not a.equals(b)
+        with pytest.raises(ValueError):
+            b.dtype = 'hello_everyone'
+        with pytest.raises(ValueError):
+            b.dtype = 'float'
+        with pytest.raises(ValueError):
+            b.dtype = 'uintle12'
+            _ = b[0]
+        with pytest.raises(ValueError):
+            b.dtype = 'float17'
+
+
+class TestArrayMethods:
+
+    def test_count(self):
+        a = Array('u9', [0, 4, 3, 2, 3, 4, 2, 3, 2, 1, 2, 11, 2, 1])
+        assert a.count(0) == 1
+        assert a.count(-1) == 0
+        assert a.count(2) == 5
+
+    def test_count_nan(self):
+        a = Array('uint8', [0, 10, 128, 128, 4, 2, 1])
+        a.dtype = 'p3binary'
+        assert a.count(float('nan')) == 2
+
+    def test_from_bytes(self):
+        a = Array('i16')
+        assert len(a) == 0
+        a.data += bytearray([0, 0, 0, 55])
+        assert len(a) == 2
+        assert a[0] == 0
+        assert a[1] == 55
+        a.data += b'\x01\x00'
+        assert len(a) == 3
+        assert a[-1] == 256
+        a.data += bytearray()
+        assert len(a) == 3
+
+    def test_equals(self):
+        a = Array('hex:40')
+        b = Array('h40')
+        assert a.equals(b)
+        c = Array('bin:40')
+        assert not a.equals(c)
+        v = ['1234567890']
+        a.extend(v)
+        b.extend(v)
+        assert a.equals(b)
+        b.extend(v)
+        assert not a.equals(b)
+
+        a = Array('uint20', [16, 32, 64, 128])
+        b = Array('uint10', [0, 16, 0, 32, 0, 64, 0, 128])
+        assert not b.equals(a)
+        b.dtype = 'u20'
+        assert a.equals(b)
+        a.data += '0b1'
+        assert not a.equals(b)
+        b.data += '0b1'
+        assert a.equals(b)
+
+        c = Array('uint8', [1, 2])
+        assert not c.equals('hello')
+        assert not c.equals(array.array('B', [1, 3]))
+
+    def test_equals_with_trailing_bits(self):
+        a = Array('hex4', ['a', 'b', 'c', 'd', 'e', 'f'])
+        c = Array('hex4')
+        c.data = BitArray('0xabcdef, 0b11')
+        assert a.tolist() == c.tolist()
+        assert a != c
+        a.data.append('0b11')
+        assert a.tolist() == c.tolist()
+        assert a.equals(c)
+
+    def test_setting(self):
+        a = Array('bool')
+        a.data += b'\x00'
+        a[0] = 1
+        assert a[0] == True
+
+        b = Array('h12')
+        with pytest.raises(ValueError):
+            b.append('12')
+        b.append('123')
+        with pytest.raises(ValueError):
+            b.extend(['3456'])
+        b.extend(['345'])
+        assert b.tolist() == ['123', '345']
+        with pytest.raises(ValueError):
+            b[0] = 'abcd'
+        with pytest.raises(ValueError):
+            b[0] = 12
+        with pytest.raises(ValueError):
+            b[0] = Bits('0xfff')
+        b[0] = 'fff'
+        assert b.data.hex == 'fff345'
+
+    def test_setting_from_iterable(self):
+        a = Array('uint99', range(100))
+        x = itertools.chain([1, 2, 3], [4, 5])
+        a[10:15] = x
+        assert a[10:15].tolist() == list(range(1, 6))
+        x = itertools.chain([1, 2, 3], [4, 5])
+        a[50:60:2] = x
+        assert a[50:60:2].tolist() == list(range(1, 6))
+
+    def test_equivalence(self):
+        a = Array('floatne32', [54.2, -998, 411.9])
+        b = Array('floatne32')
+        b.extend(a.tolist())
+        assert a.data == b.data
+
+        b = array.array('f', [54.2, -998, 411.9])
+        assert a.equals(b)
+        a.dtype = 'bool'
+        assert not a.equals(b)
+        a.dtype = 'floatne16'
+        assert not a.equals(b)
+        a.dtype = 'floatne32'
+        a.data += '0x0'
+        assert not a.equals(b)
+        a.data += '0x0000000'
+        assert not a.equals(b)
+        b.append(0.0)
+        assert a.equals(b)
+
+    def test_extend(self):
+        a = Array('uint:3', (1, 2, 3))
+        a.extend([4, 5, 6])
+        assert a.tolist() == [1, 2, 3, 4, 5, 6]
+        a.extend([])
+        assert a.tolist() == [1, 2, 3, 4, 5, 6]
+        a.extend(a)
+        assert a.tolist() == [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]
+        b = Array('int:3', [0])
+        with pytest.raises(TypeError):
+            a.extend(b)
+        del a.data[0]
+        with pytest.raises(ValueError):
+            a.extend([1, 0])
+        del a.data[-2:]
+        with pytest.raises(TypeError):
+            a.extend('uint:3=3')  # Can't extend with a str even though it's iterable
+
+    def test_extend_with_mixed_classes(self):
+        a = Array('uint8', [1, 2, 3])
+        b = array.array('B', [4, 5, 6])
+        ap = Array('uint8', a[:])
+        bp = array.array('B', b[:])
+        a.extend(b)
+        bp.extend(ap)
+        assert a.tolist() == [1, 2, 3, 4, 5, 6]
+        assert bp.tolist() == [4, 5, 6, 1, 2, 3]
+
+        a.dtype = 'int8'
+        ap = Array('uint8', a.tolist())
+        assert not a.equals(ap)
+        assert a.tolist() == ap.tolist()
+
+    def test_insert(self):
+        a = Array('hex:12', ['abc', 'def'])
+        assert a.data.hex == 'abcdef'
+        a.insert(0, '000')
+        assert a.data.hex == '000abcdef'
+        a.insert(-1, '111')
+        assert a[-1] == 'def'
+        assert a[-2] == '111'
+        a.data += '0b1'
+        assert a[-1] == 'def'
+        a.insert(1, '111')
+        assert a.tolist() == ['000', '111', 'abc', '111', 'def']
+
+        with pytest.raises(ValueError):
+            a.insert(2, 'hello')
+        with pytest.raises(ValueError):
+            a.insert(2, 'ab')
+
+    def test_pop(self):
+        a = Array('oct:6', ['33', '21', '11', '76'])
+        with pytest.raises(IndexError):
+            _ = a.pop(4)
+        assert len(a) == 4
+        x = a.pop()
+        assert len(a) == 3
+        assert x == '76'
+        with pytest.raises(IndexError):
+            _ = a.pop(3)
+        x = a.pop(2)
+        assert x == '11'
+        x = a.pop(0)
+        assert x == '33'
+        x = a.pop()
+        assert x == '21'
+        with pytest.raises(IndexError):
+            _ = a.pop()
+
+    def test_reverse(self):
+        a = Array('int30', [])
+        a.reverse()
+        assert a.tolist() == []
+        a.append(2)
+        a.reverse()
+        assert a.tolist() == [2]
+        a.append(3)
+        a.reverse()
+        assert a.tolist() == [3, 2]
+        a.data.clear()
+        a.extend(list(range(1000)))
+        a.reverse()
+        assert a.tolist() == list(range(999, -1, -1))
+        x = a.pop(0)
+        assert x == 999
+        a.reverse()
+        assert a.tolist() == list(range(0, 999))
+        a.data += '0b1'
+        with pytest.raises(ValueError):
+            a.reverse()
+
+    def test_byteswap(self):
+        a = Array('float16')
+        a.byteswap()
+        assert a.tolist() == []
+        b = Array('uint17')
+        with pytest.raises(ValueError):
+            b.byteswap()
+        a.extend([0.25, 104, -6])
+        a.byteswap()
+        assert a.data.unpack('3*floatle16') == [0.25, 104, -6]
+        a.byteswap()
+        assert a.tolist() == [0.25, 104, -6]
+
+    def test_to_file(self):
+        filename = os.path.join(THIS_DIR, 'temp_bitstring_unit_testing_file')
+        a = Array('uint5', [0, 1, 2, 3, 4, 5])
+        with open(filename, 'wb') as f:
+            a.tofile(f)
+        with open(filename, 'rb') as f:
+            b = Array('u5')
+            b.fromfile(f, 1)
+        assert b.tolist() == [0]
+
+    def test_getting(self):
+        a = Array('int17')
+        with pytest.raises(IndexError):
+            _ = a[0]
+        a.extend([1, 2, 3, 4])
+        assert a[:].equals(Array('i17', [1, 2, 3, 4]))
+        assert a[:1].equals(Array('i17', [1]))
+        assert a[1:3].equals(Array('i17', [2, 3]))
+        assert a[-2:].equals(Array('i17', [3, 4]))
+        assert a[::2].equals(Array('i17', [1, 3]))
+        assert a[::-2].equals(Array('i17', [4, 2]))
+
+    def test_more_setting(self):
+        a = Array('i1', [0, -1, -1, 0, 0, -1, 0])
+        a[0] = -1
+        assert a[0] == -1
+        a[0:3] = [0, 0]
+        assert a.tolist() == [0, 0, 0, 0, -1, 0]
+        b = Array('i20', a.tolist())
+        with pytest.raises(TypeError):
+            b[::2] = 9
+        b[::2] = [9]*3
+        assert b.tolist() == [9, 0, 9, 0, 9, 0]
+        b[1:4] = a[-2:]
+        assert b.tolist() == [9, -1, 0, 9, 0]
+
+    def test_deleting(self):
+        a = Array('u99', list(range(1000)))
+        del a[::2]
+        assert len(a) == 500
+        del a[-100:]
+        assert len(a) == 400
+        assert a[:10].tolist() == [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
+        with pytest.raises(IndexError):
+            del a[len(a)]
+        with pytest.raises(IndexError):
+            del a[-len(a) - 1]
+
+    def test_deleting_more_ranges(self):
+        a = Array('uint:18', [1, 2, 3, 4, 5, 6])
+        del a[3:1:-1]
+        assert a.tolist() == [1, 2, 5, 6]
+
+
+    def test_repr(self):
+        a = Array('int5')
+        b = eval(a.__repr__())
+        assert a.equals(b)
+        a.data += '0b11'
+
+        b = eval(a.__repr__())
+        assert a.equals(b)
+
+        a.data += '0b000'
+        b = eval(a.__repr__())
+        assert a.equals(b)
+
+        a.extend([1]*9)
+        b = eval(a.__repr__())
+        assert a.equals(b)
+
+        a.extend([-4]*100)
+        b = eval(a.__repr__())
+        assert a.equals(b)
+
+        a.dtype = 'float32'
+        b = eval(a.__repr__())
+        assert a.equals(b)
+
+    def test__add__(self):
+        a = Array('=B', [1, 2, 3])
+        b = Array('u8', [3, 4])
+        c = a[:]
+        c.extend(b)
+        assert a.equals(Array('=B', [1, 2, 3]))
+        assert c.equals(Array('=B', [1, 2, 3, 3, 4]))
+        d = a[:]
+        d.extend([10, 11, 12])
+        assert d.equals(Array('uint:8', [1, 2, 3, 10, 11, 12]))
+
+    def test__contains__(self):
+        a = Array('i9', [-1, 88, 3])
+        assert 88 in a
+        assert not 89 in a
+
+    def test__copy__(self):
+        a = Array('i4')
+        a.data += '0x123451234561'
+        b = copy.copy(a)
+        assert a.equals(b)
+        a.data += '0b1010'
+        assert not a.equals(b)
+
+    def test__iadd__(self):
+        a = Array('uint999')
+        a.extend([4])
+        assert a.tolist() == [4]
+        a += 5
+        a.extend(a)
+        assert a.tolist() == [9, 9]
+
+    def test_float8_bug(self):
+        a = Array('p3binary', [0.0, 1.5])
+        b = Array('p4binary')
+        b[:] = a[:]
+        assert b[:].equals(Array('p4binary', [0.0, 1.5]))
+
+    def test_pp(self):
+        a = Array('bfloat', [-3, 1, 2])
+        s = io.StringIO()
+        a.pp('hex', stream=s)
+        assert remove_unprintable(s.getvalue()) ==  "<Array fmt='hex', length=3, itemsize=16 bits, total data size=6 bytes> [\n" \
+                                        " 0: c040 3f80 4000\n" \
+                                        "]\n"
+        a.data += '0b110'
+        a.dtype='hex16'
+        s = io.StringIO()
+        a.pp(stream=s)
+        assert remove_unprintable(s.getvalue()) ==  """<Array dtype='hex16', length=3, itemsize=16 bits, total data size=7 bytes> [
+ 0: c040 3f80 4000
+] + trailing_bits = 0b110\n"""
+
+    def test_pp_uint(self):
+        a = Array('uint32', [12, 100, 99])
+        s = io.StringIO()
+        a.pp(stream=s)
+        assert remove_unprintable(s.getvalue()) == """<Array dtype='uint32', length=3, itemsize=32 bits, total data size=12 bytes> [
+ 0:         12        100         99
+]\n"""
+
+    def test_pp_bits(self):
+        a = Array('bits2', b'89')
+        s = io.StringIO()
+        a.pp(stream=s, width=0, show_offset=True)
+        assert remove_unprintable(s.getvalue()) == """<Array dtype='bits2', length=8, itemsize=2 bits, total data size=2 bytes> [
+ 0: 0b00
+ 1: 0b11
+ 2: 0b10
+ 3: 0b00
+ 4: 0b00
+ 5: 0b11
+ 6: 0b10
+ 7: 0b01
+]\n"""
+
+    def test_pp_two_formats(self):
+        a = Array('float16', bytearray(20))
+        s = io.StringIO()
+        a.pp(stream=s, fmt='p3binary, bin', show_offset=False)
+        assert remove_unprintable(s.getvalue()) == """<Array fmt='p3binary, bin', length=20, itemsize=8 bits, total data size=20 bytes> [
+                0.0                 0.0                 0.0                 0.0 : 00000000 00000000 00000000 00000000
+                0.0                 0.0                 0.0                 0.0 : 00000000 00000000 00000000 00000000
+                0.0                 0.0                 0.0                 0.0 : 00000000 00000000 00000000 00000000
+                0.0                 0.0                 0.0                 0.0 : 00000000 00000000 00000000 00000000
+                0.0                 0.0                 0.0                 0.0 : 00000000 00000000 00000000 00000000
+]\n"""
+
+    def test_pp_two_formats_no_length(self):
+        a = Array('float16', bytearray(range(50, 56)))
+        s = io.StringIO()
+        a.pp(stream=s, fmt='u, b')
+        assert remove_unprintable(s.getvalue()) == """<Array fmt='uint, bin', length=3, itemsize=16 bits, total data size=6 bytes> [
+ 0: 12851 13365 13879 : 0011001000110011 0011010000110101 0011011000110111
+]\n"""
+
+
+class TestArrayOperations:
+
+    def test_in_place_add(self):
+        a = Array('i7', [-9, 4, 0])
+        a += 9
+        assert a.tolist() == [0, 13, 9]
+        assert len(a.data) == 21
+
+    def test_add(self):
+        a = Array('>d')
+        a.extend([1.0, -2.0, 100.5])
+        b = a + 2
+        assert a.equals(Array('>d', [1.0, -2.0, 100.5]))
+        assert b.equals(Array('>d', [3.0, 0.0, 102.5]))
+
+    def test_sub(self):
+        a = Array('uint44', [3, 7, 10])
+        b = a - 3
+        assert b.equals(Array('u44', [0, 4, 7]))
+        with pytest.raises(ValueError):
+            _ = a - 4
+
+    def test_in_place_sub(self):
+        a = Array('float16', [-9, -10.5])
+        a -= -1.5
+        assert a.tolist() == [-7.5, -9.0]
+
+    def test_mul(self):
+        a = Array('i21', [-5, -4, 0, 2, 100])
+        b = a * 2
+        assert b.tolist() == [-10, -8, 0, 4, 200]
+        a = Array('int9', [-1, 0, 3])
+        b = a * 2
+        assert a.tolist() == [-1, 0, 3]
+        assert b.tolist() == [-2, 0, 6]
+        c = a * 2.5
+        assert c.tolist() == [-2, 0, 7]
+
+    def test_in_place_mul(self):
+        a = Array('i21', [-5, -4, 0, 2, 100])
+        a *= 0.5
+        assert a.tolist() == [-2, -2, 0, 1, 50]
+
+    def test_div(self):
+        a = Array('i32', [-2, -1, 0, 1, 2])
+        b = a // 2
+        assert a.tolist() == [-2, -1, 0, 1, 2]
+        assert b.tolist() == [-1, -1, 0, 0, 1]
+
+    def test_in_place_div(self):
+        a = Array('i10', [-4, -3, -2, -1, 0, 1, 2])
+        a //= 2
+        assert a.equals(Array('i10', [-2, -2, -1, -1, 0, 0, 1]))
+
+    def test_true_div(self):
+        a = Array('float16', [5, 10, -6])
+        b = a / 4
+        assert a.equals(Array('float16', [5.0, 10.0, -6.0]))
+        assert b.equals(Array('float16', [1.25, 2.5, -1.5]))
+
+    def test_in_place_true_div(self):
+        a = Array('int71', [-4, -3, -2, -1, 0, 1, 2])
+        a /= 2
+        assert a.equals(Array('int71', [-2, -1, -1, 0, 0, 0, 1]))
+
+    def test_and(self):
+        a = Array('int16', [-1, 100, 9])
+        with pytest.raises(TypeError):
+            _ = a & 0
+        b = a & '0x0001'
+        assert b.tolist() == [1, 0, 1]
+        b = a & '0xffff'
+        assert b.dtype == Dtype('int16')
+        assert b.tolist() == [-1, 100, 9]
+
+    def test_in_place_and(self):
+        a = Array('bool', [True, False, True])
+        with pytest.raises(TypeError):
+            a &= 0b1
+        a = Array('uint10', a.tolist())
+        a <<= 3
+        assert a.tolist() == [8, 0, 8]
+        a += 1
+        assert a.tolist() == [9, 1, 9]
+        with pytest.raises(ValueError):
+            a &= '0b111'
+        a &= '0b0000000111'
+        assert a.data == '0b 0000000001 0000000001 0000000001'
+
+    def test_or(self):
+        a = Array('p4binary', [-4, 2.5, -9, 0.25])
+        b = a | '0b10000000'
+        assert a.tolist() == [-4,  2.5, -9,  0.25]
+        assert b.tolist() == [-4, -2.5, -9, -0.25]
+
+    def test_in_place_or(self):
+        a = Array('hex:12')
+        a.append('f0f')
+        a.extend(['000', '111'])
+        a |= '0x00f'
+        assert a.tolist() == ['f0f', '00f', '11f']
+        with pytest.raises(TypeError):
+            a |= 12
+
+    def test_xor(self):
+        a = Array('hex8', ['00', 'ff', 'aa'])
+        b = a ^ '0xff'
+        assert a.tolist() == ['00', 'ff', 'aa']
+        assert b.tolist() == ['ff', '00', '55']
+
+    def test_in_place_xor(self):
+        a = Array('u10', [0, 0xf, 0x1f])
+        a ^= '0b00, 0x0f'
+
+    def test_rshift(self):
+        a = Array(dtype='u8')
+        a.data = Bits('0x00010206')
+        b = a >> 1
+        assert a.tolist() == [0, 1, 2, 6]
+        assert b.tolist() == [0, 0, 1, 3]
+
+        a = Array('i10', [-1, 0, -20, 10])
+        b = a >> 1
+        assert b.tolist() == [-1, 0, -10, 5]
+        c = a >> 0
+        assert c.tolist() == [-1, 0, -20, 10]
+        with pytest.raises(ValueError):
+            _ = a >> -1
+
+    def test_in_place_rshift(self):
+        a = Array('i8', [-8, -1, 0, 1, 100])
+        a >>= 1
+        assert a.tolist() == [-4, -1, 0, 0, 50]
+        a >>= 100000
+        assert a.tolist() == [-1, -1, 0, 0, 0]
+
+    def test_lshift(self):
+        a = Array('p3binary', [0.3, 1.2])
+        with pytest.raises(TypeError):
+            _ = a << 3
+        a = Array('int16', [-2, -1, 0, 128])
+        b = a << 4
+        assert a.tolist() == [-2, -1, 0, 128]
+        assert b.tolist() == [-32, -16, 0, 2048]
+        with pytest.raises(ValueError):
+            _ = a << 1000
+
+    def test_in_place_lshift(self):
+        a = Array('u11', [0, 5, 10, 1, 2, 3])
+        a <<= 2
+        assert a.tolist() == [0, 20, 40, 4, 8, 12]
+        a <<= 0
+        assert a.tolist() == [0, 20, 40, 4, 8, 12]
+        with pytest.raises(ValueError):
+            a <<= -1
+
+    def test_neg(self):
+        a = Array('i92', [-1, 1, 0, 100, -100])
+        b = -a
+        assert b.tolist() == [1, -1, 0, -100, 100]
+        assert str(b.dtype) == 'int92'
+
+    def test_abs(self):
+        a = Array('float16', [-2.0, 0, -0, 100, -5.5])
+        b = abs(a)
+        assert b.equals(Array('float16', [2.0, 0, 0, 100, 5.5]))
+
+
+class TestCreationFromBits:
+
+    def test_appending_auto(self):
+        a = Array('bits8')
+        a.append('0xff')
+        assert len(a) == 1
+        assert a[0] == Bits('0xff')
+        with pytest.raises(TypeError):
+            a += 8
+        a.append(Bits(8))
+        assert a[:].equals(Array('bits:8', ['0b1111 1111', Bits('0x00')]))
+        a.extend(['0b10101011'])
+        assert a[-1].hex == 'ab'
+
+
+class TestSameSizeArrayOperations:
+
+    def test_adding_same_types(self):
+        a = Array('u8', [1, 2, 3, 4])
+        b = Array('u8', [5, 5, 5, 4])
+        c = a + b
+        assert c.tolist() == [6, 7, 8, 8]
+        assert c.dtype == Dtype('uint8')
+
+    def test_adding_different_types(self):
+        a = Array('u8', [1, 2, 3, 4])
+        b = Array('i6', [5, 5, 5, 4])
+        c = a + b
+        assert c.tolist() == [6, 7, 8, 8]
+        assert c.dtype == Dtype('int6')
+        d = Array('float16', [-10, 0, 5, 2])
+        e = d + a
+        assert e.tolist() == [-9.0, 2.0, 8.0, 6.0]
+        assert e.dtype == Dtype('float16')
+        e = a + d
+        assert e.tolist() == [-9.0, 2.0, 8.0, 6.0]
+        assert e.dtype == Dtype('float16')
+        x1 = a[:]
+        x2 = a[:]
+        x1.dtype = 'p3binary'
+        x2.dtype = 'p4binary'
+        y = x1 + x2
+        assert y.dtype == x1.dtype
+
+    def test_adding_errors(self):
+        a = Array('float16', [10, 100, 1000])
+        b = Array('i3', [-1, 2])
+        with pytest.raises(ValueError):
+            _ = a + b
+        b.append(0)
+        c = a + b
+        assert c.tolist() == [9, 102, 1000]
+        a.dtype='hex16'
+        with pytest.raises(ValueError):
+            _ = a + b
+
+
+class TestComparisonOperators:
+
+    def test_less_than_with_scalar(self):
+        a = Array('u16', [14, 16, 100, 2, 100])
+        b = a < 80
+        assert b.tolist() == [True, True, False, True, False]
+        assert b.dtype == Dtype('bool')
+
+    def test_less_than_with_array(self):
+        a = Array('u16', [14, 16, 100, 2, 100])
+        b = Array('bfloat', [1000, -54, 0.2, 55, 9])
+        c = a < b
+        assert c.tolist() == [True, False, False, True, False]
+        assert c.dtype == Dtype('bool')
+
+    def test_array_equals(self):
+        a = Array('i12', [1, 2, -3, 4, -5, 6])
+        b = Array('i12', [6, 5, 4, 3, 2, 1])
+        assert abs(a).equals(b[::-1])
+        assert (a == b) == [False, False, False, False, False, False]
+        assert (a != b) == [True, True, True, True, True, True]
+        with pytest.raises(ValueError):
+            _ = a == b[:-1]
+        with pytest.raises(ValueError):
+            _ = a == [1, 2, 3]
+        with pytest.raises(ValueError):
+            _ = [1, 2, 3] == a
+        with pytest.raises(ValueError):
+            _ = a == [1, 2, 3, 4, 5, 6, 7]
+
+class TestAsType:
+
+    def test_switching_int_types(self):
+        a = Array('u8', [15, 42, 1])
+        b = a.astype('i8')
+        assert a.tolist() == b.tolist()
+        assert b.dtype == Dtype('i8')
+
+    def test_switching_float_types(self):
+        a = Array('float64', [-990, 34, 1, 0.25])
+        b = a.astype('float16')
+        assert a.tolist() == b.tolist()
+        assert b.dtype == Dtype('float16')
+
+
+class TestReverseMethods:
+
+    def test_radd(self):
+        a = Array('u6', [1,2,3])
+        b = 5 + a
+        assert b.equals(Array('uint:6', [6, 7, 8]))
+
+    def test_rmul(self):
+        a = Array('bfloat', [4, 2, 8])
+        b = 0.5 * a
+        assert b.equals(Array('bfloat16', [2.0, 1.0, 4.0]))
+
+    def test_rsub(self):
+        a = Array('i90', [-1, -10, -100])
+        b = 100 - a
+        assert b.equals(Array('int90', [101, 110, 200]))
+
+    def test_rmod(self):
+        a = Array('i8', [1, 2, 4, 8, 10])
+        with pytest.raises(TypeError):
+            _ = 15 % a
+
+    def test_rfloordiv(self):
+        a = Array('>H', [1, 2, 3, 4, 5])
+        with pytest.raises(TypeError):
+            _ = 100 // a
+
+    def test_rtruediv(self):
+        a = Array('>H', [1, 2, 3, 4, 5])
+        with pytest.raises(TypeError):
+            _ = 100 / a
+
+    def test_rand(self):
+        a = Array('u8', [255, 8, 4, 2, 1, 0])
+        b = '0x0f' & a
+        assert b.tolist() == [15, 8, 4, 2, 1, 0]
+
+    def test_ror(self):
+        a = Array('u8', [255, 8, 4, 2, 1, 0])
+        b = '0x0f' | a
+        assert b.tolist() == [255, 15, 15, 15, 15, 15]
+
+    def test_rxor(self):
+        a = Array('u8', [255, 8, 4, 2, 1, 0])
+        b = '0x01' ^ a
+        assert b.tolist() == [254, 9, 5, 3, 0, 1]
+
+
+class TestMisc:
+
+    def test_invalid_type_assignment(self):
+        a = Array('u8', [1,2,3])
+        with pytest.raises(ValueError):
+            a.dtype = 'penguin'
+
+    def test_set_extended_slice(self):
+        a = Array('bool', [0,1,1,1,0])
+        with pytest.raises(ValueError):
+            a[0:5:2] = [1, 0]
+
+    def test_set_out_of_range_element(self):
+        a = Array(Dtype('float', 16), [1, 2, 3, 4.5])
+        a[3] = 100.0
+        a[-4] = 100.0
+        with pytest.raises(IndexError):
+            a[4] = 100.0
+        with pytest.raises(IndexError):
+            a[-5] = 100.0
+
+    def test_bytes(self):
+        a = Array('bytes8', 5)
+        assert a.data == b'\x00'*40
+
+        b = Array('bytes1', 5)
+        assert b.data == b'\x00'*5
+
+    def test_bytes_trailing_bits(self):
+        b = Bits('0x000000, 0b111')
+        a = Array('bytes1', b)
+        assert a.trailing_bits == '0b111'
+
+    def test_operation_with_bool(self):
+        x = Array('int4', [1, 2, 3, 4])
+        y = Array('float16', [100, 2.0, 0.0, 4])
+        x = x + (y == 0.0)
         assert x.tolist() == [1, 2, 4, 4]
```

### Comparing `bitstring-4.2.1/tests/test_bitarray.py` & `bitstring-4.2.2/tests/test_bitarray.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,992 +1,992 @@
-#!/usr/bin/env python
-"""
-Unit tests for the bitarray module.
-"""
-
-import pytest
-import sys
-import os
-import bitarray
-import bitstring
-from bitstring import BitArray, Bits
-
-sys.path.insert(0, '..')
-
-
-class TestAll:
-    def test_creation_from_uint(self):
-        s = BitArray(uint=15, length=6)
-        assert s.bin == '001111'
-        s = BitArray(uint=0, length=1)
-        assert s.bin == '0'
-        s.u = 1
-        assert s.uint == 1
-        s = BitArray(length=8)
-        s.uint = 0
-        assert s.uint == 0
-        s.u8 = 255
-        assert s.uint == 255
-        assert s.len == 8
-        with pytest.raises(bitstring.CreationError):
-            s.uint = 256
-        with pytest.raises(bitstring.CreationError):
-            s.uint = -1
-
-    def test_creation_from_oct(self):
-        s = BitArray(oct='7')
-        assert s.oct == '7'
-        assert s.bin == '111'
-        s.append('0o1')
-        assert s.bin == '111001'
-        s.oct = '12345670'
-        assert s.length == 24
-        assert s.bin == '001010011100101110111000'
-        s = BitArray('0o123')
-        assert s.oct == '123'
-
-
-class TestNoPosAttribute:
-    def test_replace(self):
-        s = BitArray('0b01')
-        s.replace('0b1', '0b11')
-        assert s == '0b011'
-
-    def test_delete(self):
-        s = BitArray('0b000000001')
-        del s[-1:]
-        assert s == '0b00000000'
-
-    def test_insert(self):
-        s = BitArray('0b00')
-        s.insert('0xf', 1)
-        assert s == '0b011110'
-
-    def test_insert_self(self):
-        b = BitArray('0b10')
-        b.insert(b, 0)
-        assert b == '0b1010'
-        c = BitArray('0x00ff')
-        c.insert(c, 8)
-        assert c == '0x0000ffff'
-        a = BitArray('0b11100')
-        a.insert(a, 3)
-        assert a == '0b1111110000'
-
-    def test_no_bit_pos_for_insert(self):
-        s = BitArray(100)
-        with pytest.raises(TypeError):
-            s.insert('0xabc')
-
-    def test_insert_parameters(self):
-        s = BitArray('0b111')
-        with pytest.raises(TypeError):
-            s.insert('0x4')
-
-    def test_overwrite(self):
-        s = BitArray('0b01110')
-        s.overwrite('0b000', 1)
-        assert s == '0b00000'
-
-    def test_overwrite_no_pos(self):
-        s = BitArray('0x01234')
-        with pytest.raises(TypeError):
-            s.overwrite('0xf')
-
-    def test_overwrite_parameters(self):
-        s = BitArray('0b0000')
-        with pytest.raises(TypeError):
-            s.overwrite('0b111')
-
-    def test_prepend(self):
-        s = BitArray('0b0')
-        s.prepend([1])
-        assert s == [1, 0]
-
-    def test_rol(self):
-        s = BitArray('0b0001')
-        s.rol(1)
-        assert s == '0b0010'
-
-    def test_ror(self):
-        s = BitArray('0b1000')
-        s.ror(1)
-        assert s == '0b0100'
-
-    def test_set_item(self):
-        s = BitArray('0b000100')
-        s[4:5] = '0xf'
-        assert s == '0b000111110'
-        s[0:1] = [1]
-        assert s == '0b100111110'
-        s[5:5] = BitArray()
-        assert s == '0b100111110'
-
-
-class TestBugs:
-    def test_adding_nonsense(self):
-        a = BitArray([0])
-        with pytest.raises(ValueError):
-            a += '3'
-        with pytest.raises(ValueError):
-            a += 'se'
-        with pytest.raises(ValueError):
-            a += 'float:32'
-
-    def test_prepend_after_creation_from_data_with_offset(self):
-        s1 = BitArray(bytes=b'\x00\x00\x07\xff\xf0\x00', offset=21, length=15)
-        assert not s1.any(0)
-        b = s1.tobytes()
-        assert b == b'\xff\xfe'
-        s1.prepend('0b0')
-        assert s1.bin == '0111111111111111'
-        s1.prepend('0b0')
-        assert s1.bin == '00111111111111111'
-
-
-class TestByteAligned:
-
-    def test_changing_it(self):
-        bitstring.bytealigned = True
-        assert bitstring.bytealigned
-        bitstring.bytealigned = False
-        assert not bitstring.bytealigned
-
-    def test_not_byte_aligned(self):
-        a = BitArray('0x00 ff 0f f')
-        li = list(a.findall('0xff'))
-        assert li == [8, 20]
-        p = a.find('0x0f')[0]
-        assert p == 4
-        p = a.rfind('0xff')[0]
-        assert p == 20
-        s = list(a.split('0xff'))
-        assert s == ['0x00', '0xff0', '0xff']
-        a.replace('0xff', '')
-        assert a == '0x000'
-
-    def test_byte_aligned(self):
-        bitstring.bytealigned = True
-        a = BitArray('0x00 ff 0f f')
-        li = list(a.findall('0xff'))
-        assert li == [8]
-        p = a.find('0x0f')[0]
-        assert p == 16
-        p = a.rfind('0xff')[0]
-        assert p == 8
-        s = list(a.split('0xff'))
-        assert s == ['0x00', '0xff0ff']
-        a.replace('0xff', '')
-        assert a == '0x000ff'
-        bitstring.bytealigned = False
-
-
-class TestSliceAssignment:
-
-    def test_slice_assignment_single_bit(self):
-        a = BitArray('0b000')
-        a[2] = '0b1'
-        assert a.bin == '001'
-        a[0] = BitArray(bin='1')
-        assert a.bin == '101'
-        a[-1] = '0b0'
-        assert a.bin == '100'
-        a[-3] = '0b0'
-        assert a.bin == '000'
-
-    def test_slice_assignment_single_bit_errors(self):
-        a = BitArray('0b000')
-        with pytest.raises(IndexError):
-            a[-4] = '0b1'
-        with pytest.raises(IndexError):
-            a[3] = '0b1'
-        with pytest.raises(TypeError):
-            a[1] = 1.3
-
-    def test_slice_assignment_muliple_bits(self):
-        a = BitArray('0b0')
-        a[0] = '0b110'
-        assert a.bin3 == '110'
-        a[0] = '0b000'
-        assert a.bin5 == '00010'
-        a[0:3] = '0b111'
-        assert a.b5 == '11110'
-        a[-2:] = '0b011'
-        assert a.bin == '111011'
-        a[:] = '0x12345'
-        assert a.hex == '12345'
-        a[:] = ''
-        assert not a
-
-    def test_slice_assignment_multiple_bits_errors(self):
-        a = BitArray()
-        with pytest.raises(IndexError):
-            a[0] = '0b00'
-        a += '0b1'
-        a[0:2] = '0b11'
-        assert a == '0b11'
-
-    def test_del_slice_step(self):
-        a = BitArray(bin='100111101001001110110100101')
-        del a[::2]
-        assert a.bin == '0110010101100'
-        del a[3:9:3]
-        assert a.bin == '01101101100'
-        del a[2:7:1]
-        assert a.bin == '011100'
-        del a[::99]
-        assert a.bin == '11100'
-        del a[::1]
-        assert a.bin == ''
-
-    def test_del_slice_negative_step(self):
-        a = BitArray('0b0001011101101100100110000001')
-        del a[5:23:-3]
-        assert a.bin == '0001011101101100100110000001'
-        del a[25:3:-3]
-        assert a.bin == '00011101010000100001'
-        del a[:6:-7]
-        assert a.bin == '000111010100010000'
-        del a[15::-2]
-        assert a.bin == '0010000000'
-        del a[::-1]
-        assert a.bin == ''
-
-    def test_del_slice_negative_end(self):
-        a = BitArray('0b01001000100001')
-        del a[:-5]
-        assert a == '0b00001'
-        a = BitArray('0b01001000100001')
-        del a[-11:-5]
-        assert a == '0b01000001'
-
-    def test_del_slice_errors(self):
-        a = BitArray(10)
-        del a[5:3]
-        assert a == Bits(10)
-        del a[3:5:-1]
-        assert a == Bits(10)
-
-    def test_del_single_element(self):
-        a = BitArray('0b0010011')
-        del a[-1]
-        assert a.bin == '001001'
-        del a[2]
-        assert a.bin == '00001'
-        with pytest.raises(IndexError):
-            del a[5]
-
-    def test_set_slice_step(self):
-        a = BitArray(bin='0000000000')
-        a[::2] = '0b11111'
-        assert a.bin == '1010101010'
-        a[4:9:3] = [0, 0]
-        assert a.bin == '1010001010'
-        a[7:3:-1] = [1, 1, 1, 0]
-        assert a.bin == '1010011110'
-        a[7:1:-2] = [0, 0, 1]
-        assert a.b == '1011001010'
-        a[::-5] = [1, 1]
-        assert a.bin == '1011101011'
-        a[::-1] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
-        assert a.bin == '1000000000'
-
-    def test_set_slice_step_with_int(self):
-        a = BitArray(9)
-        a[5:8] = -1
-        assert a.bin == '000001110'
-        a[:] = 10
-        assert a.bin == '000001010'
-        a[::-1] = 10
-        assert a.bin == '010100000'
-        a[::2] = True
-        assert a.bin == '111110101'
-
-    def test_set_slice_errors(self):
-        a = BitArray(8)
-        with pytest.raises(ValueError):
-            a[::3] = [1]
-
-        class A(object):
-            pass
-        with pytest.raises(TypeError):
-            a[1:2] = A()
-        with pytest.raises(ValueError):
-            a[1:4:-1] = [1, 2]
-
-
-class TestSubclassing:
-
-    def test_is_instance(self):
-        class SubBits(BitArray):
-            pass
-        a = SubBits()
-        assert isinstance(a, SubBits)
-
-    def test_class_type(self):
-        class SubBits(BitArray):
-            pass
-        assert SubBits().__class__ == SubBits
-
-
-class TestClear:
-
-    def test_clear(self):
-        s = BitArray('0xfff')
-        s.clear()
-        assert s.len == 0
-
-
-class TestCopy:
-
-    def test_copy_method(self):
-        s = BitArray(9)
-        t = s.copy()
-        assert s == t
-        t[0] = True
-        assert t.bin == '100000000'
-        assert s.bin == '000000000'
-
-
-class TestModifiedByAddingBug:
-
-    def test_adding(self):
-        a = BitArray.fromstring('0b0')
-        b = BitArray('0b11')
-        c = a + b
-        assert c == '0b011'
-        assert a == '0b0'
-        assert b == '0b11'
-
-
-class TestLsb0Setting:
-
-    @classmethod
-    def setup_class(cls):
-        bitstring.lsb0 = True
-
-    @classmethod
-    def teardown_class(cls):
-        bitstring.lsb0 = False
-
-    def test_set_single_bit(self):
-        a = BitArray(10)
-        a[0] = True
-        assert a == '0b0000000001'
-        a[1] = True
-        assert a == '0b0000000011'
-        a[0] = False
-        assert a == '0b0000000010'
-        a[9] = True
-        assert a == '0b1000000010'
-        with pytest.raises(IndexError):
-            a[10] = True
-
-    def test_set_single_negative_bit(self):
-        a = BitArray('0o000')
-        a[-1] = True
-        assert a == '0b100000000'
-        a[-2] = True
-        assert a == '0o600'
-        a[-9] = True
-        assert a == '0o601'
-        with pytest.raises(IndexError):
-            a[-10] = True
-
-    def test_invert_bit(self):
-        a = BitArray('0b11110000')
-        a.invert()
-        assert a == '0x0f'
-        a.invert(0)
-        assert a == '0b00001110'
-        a.invert(-1)
-        assert a == '0b10001110'
-
-    def test_deleting_bits(self):
-        a = BitArray('0b11110')
-        del a[0]
-        assert a == '0xf'
-
-    def test_deleting_range(self):
-        a = BitArray('0b101111000')
-        del a[0:1]
-        assert a == '0b10111100'
-        del a[2:6]
-        assert a == '0b1000'
-        a = BitArray('0xabcdef')
-        del a[:8]
-        assert a == '0xabcd'
-        del a[-4:]
-        assert a == '0xbcd'
-        del a[:-4]
-        assert a == '0xb'
-
-    def test_appending_bits(self):
-        a = BitArray('0b111')
-        a.append('0b000')
-        assert a.bin == '000111'
-        a += '0xabc'
-        assert a == '0xabc, 0b000111'
-
-    def test_setting_slice(self):
-        a = BitArray('0x012345678')
-        a[4:12] = '0xfe'
-        assert a == '0x012345fe8'
-        a[0:4] = '0xbeef'
-        assert a == '0x012345febeef'
-
-    def test_truncating_start(self):
-        a = BitArray('0b1110000')
-        a = a[4:]
-        assert a == '0b111'
-
-    def test_truncating_end(self):
-        a = BitArray('0x123456')
-        a = a[:16]
-        assert a == '0x3456'
-
-    def test_all(self):
-        a = BitArray('0b0000101')
-        assert a.all(1, [0, 2])
-        assert a.all(False, [-1, -2, -3, -4])
-
-        b = Bits(bytes=b'\x00\xff\xff', offset=7)
-        assert b.all(1, [1, 2, 3, 4, 5, 6, 7])
-        assert b.all(1, [-2, -3, -4, -5, -6, -7, -8])
-
-    def test_any(self):
-        a = BitArray('0b0001')
-        assert a.any(1, [0, 1, 2])
-
-    def test_endswith(self):
-        a = BitArray('0xdeadbeef')
-        assert a.endswith('0xdead')
-
-    def test_startswith(self):
-        a = BitArray('0xdeadbeef')
-        assert a.startswith('0xbeef')
-
-    def test_cut(self):
-        a = BitArray('0xff00ff1111ff2222')
-        li = list(a.cut(16))
-        assert li == ['0x2222', '0x11ff', '0xff11', '0xff00']
-
-    def test_find(self):
-        t = BitArray('0b10')
-        p, = t.find('0b1')
-        assert p == 1
-        t = BitArray('0b1010')
-        p, = t.find('0b1')
-        assert p == 1
-        a = BitArray('0b10101010, 0xabcd, 0b10101010, 0x0')
-        p, = a.find('0b10101010', bytealigned=False)
-        assert p == 4
-        p, = a.find('0b10101010', start=4, bytealigned=False)
-        assert p == 4
-        p, = a.find('0b10101010', start=5, bytealigned=False)
-        assert p == 22
-
-    def test_find_failing(self):
-        a = BitArray()
-        p = a.find('0b1')
-        assert p == ()
-        a = BitArray('0b11111111111011')
-        p = a.find('0b100')
-        assert not p
-
-    def test_find_failing2(self):
-        s = BitArray('0b101')
-        p, = s.find('0b1', start=2)
-        assert p == 2
-
-    def test_rfind(self):
-        a = BitArray('0b1000000')
-        p = a.rfind('0b1')
-        assert p == (6,)
-        p = a.rfind('0b000')
-        assert p == (3,)
-
-    def test_rfind_with_start_and_end(self):
-        a = BitArray('0b11 0000 11 00')
-        p = a.rfind('0b11', start=8)
-        assert p[0] == 8
-        p = a.rfind('0b110', start=8)
-        assert p == ()
-        p = a.rfind('0b11', end=-1)
-        assert p[0] == 2
-
-    def test_findall(self):
-        a = BitArray('0b001000100001')
-        b = list(a.findall('0b1'))
-        assert b == [0, 5, 9]
-        c = list(a.findall('0b0001'))
-        assert c == [0, 5]
-        d = list(a.findall('0b10'))
-        assert d == [4, 8]
-        e = list(a.findall('0x198273641234'))
-        assert e == []
-
-    def test_find_all_with_start_and_end(self):
-        a = BitArray('0xaabbccaabbccccbb')
-        b = list(a.findall('0xbb', start=0, end=8))
-        assert b == [0]
-        b = list(a.findall('0xbb', start=1, end=8))
-        assert b == []
-        b = list(a.findall('0xbb', start=0, end=7))
-        assert b == []
-        b = list(a.findall('0xbb', start=48))
-        assert b == [48]
-        b = list(a.findall('0xbb', start=47))
-        assert b == [48]
-        b = list(a.findall('0xbb', start=49))
-        assert b == []
-
-    def test_find_all_byte_aligned(self):
-        a = BitArray('0x0550550')
-        b = list(a.findall('0x55', bytealigned=True))
-        assert b == [16]
-
-    def test_find_all_with_count(self):
-        a = BitArray('0b0001111101')
-        b = list(a.findall([1], start=1, count=1))
-        assert b == [2]
-
-    def test_split(self):
-        a = BitArray('0x4700004711472222')
-        li = list(a.split('0x47', bytealigned=True))
-        assert li == ['', '0x472222', '0x4711', '0x470000']
-
-    def test_byte_swap(self):
-        a = BitArray('0xaa00ff00ff00')
-        n = a.byteswap(2, end=32, repeat=True)
-        assert n == 2
-        assert a == '0xaa0000ff00ff'
-
-    def test_insert(self):
-        a = BitArray('0x0123456')
-        a.insert('0xf', 4)
-        assert a == '0x012345f6'
-
-    def test_overwrite(self):
-        a = BitArray('0x00000000')
-        a.overwrite('0xdead', 4)
-        assert a == '0x000dead0'
-
-    def test_replace(self):
-        a = BitArray('0x5551100')
-        n = a.replace('0x1', '0xabc')
-        assert n == 2
-        assert a == '0x555abcabc00'
-        n = a.replace([1], [0], end=12)
-        assert n == 2
-        assert a == '0x555abcab000'
-
-    def test_reverse(self):
-        a = BitArray('0x0011223344')
-        a.reverse()
-        assert a == '0x22cc448800'
-        a.reverse(0, 16)
-        assert a == '0x22cc440011'
-
-    def test_ror(self):
-        a = BitArray('0b111000')
-        a.ror(1)
-        assert a == '0b011100'
-        a = BitArray('0b111000')
-        a.ror(1, start=2, end=6)
-        assert a == '0b011100'
-
-    def test_rol(self):
-        a = BitArray('0b1')
-        a.rol(12)
-        assert a == '0b1'
-        b = BitArray('0b000010')
-        b.rol(3)
-        assert b == '0b010000'
-
-    def test_set(self):
-        a = BitArray(100)
-        a.set(1, [0, 2, 4])
-        assert a[0]
-        assert a.startswith('0b000010101')
-        a = BitArray('0b111')
-        a.set(False, 0)
-        assert a == '0b110'
-
-    def test_failing_repr(self):
-        a = BitArray('0b010')
-        a.find('0b1')
-        assert repr(a) == "BitArray('0b010')"
-
-    def test_left_shift(self):
-        a = BitArray('0b11001')
-        assert (a << 1).b == '10010'
-        assert (a << 5).b == '00000'
-        assert (a << 0).b == '11001'
-
-    def test_right_shift(self):
-        a = BitArray('0b11001')
-        assert (a >> 1).b == '01100'
-        assert (a >> 5).b == '00000'
-        assert (a >> 0).b == '11001'
-
-    # def testConstFileBased(self):
-    #     filename = os.path.join(THIS_DIR, 'test.m1v')
-    #     a = Bits(filename=filename, offset=8)
-    #     self.assertTrue(a[-8])
-    #     self.assertTrue(a.endswith('0x01b3'))
-
-
-class TestRepr:
-
-    def test_standard_repr(self):
-        a = BitArray('0o12345')
-        assert repr(a) == "BitArray('0b001010011100101')"
-
-
-class TestNewProperties:
-
-    def test_aliases(self):
-        a = BitArray('0x1234567890ab')
-        assert a.oct == a.o
-        assert a.hex == a.h
-        assert a.bin == a.b
-        assert a[:32].float == a[:32].f
-        assert a.int == a.i
-        assert a.uint == a.u
-
-    def test_aliases_with_lengths(self):
-        a = BitArray('0x123')
-        h = a.h12
-        assert h == '123'
-        b = a.b12
-        assert b == '000100100011'
-        o = a.o12
-        assert o == '0443'
-        u = a.u12
-        assert u == a.u
-        i = a.i12
-        assert i == a.i
-        x = BitArray('0x12345678')
-        f = x.f32
-        assert f == x.f
-
-    def test_assignments(self):
-        a = BitArray()
-        a.f64 = 0.5
-        assert a.f64 == 0.5
-        a.u88 = 1244322
-        assert a.u88 == 1244322
-        a.i3 = -3
-        assert a.i3 == -3
-        a.h16 = '0x1234'
-        assert a.h16 == '1234'
-        a.o9 = '0o765'
-        assert a.o9 == '765'
-        a.b7 = '0b0001110'
-        assert a.b7 == '0001110'
-
-    def test_assignments_without_length(self):
-        a = BitArray(64)
-        a.f = 1234.5
-        assert a.float == 1234.5
-        assert a.len == 64
-        a.u = 99
-        assert a.uint == 99
-        assert a.len == 64
-        a.i = -999
-        assert a.int == -999
-        assert a.len == 64
-        a.h = 'feedbeef'
-        assert a.hex == 'feedbeef'
-        a.o = '1234567'
-        assert a.oct == '1234567'
-        a.b = '001'
-        assert a.bin == '001'
-
-    def test_getter_length_errors(self):
-        a = BitArray('0x123')
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.h16
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.b3317777766
-        with pytest.raises(AttributeError):
-            _ = a.o2
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.f
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.f32
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.u13
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.i1
-        b = BitArray()
-        with pytest.raises(bitstring.InterpretError):
-            _ = b.u0
-
-    def test_setter_length_errors(self):
-        a = BitArray()
-        a.u8 = 255
-        assert a.len == 8
-        with pytest.raises(ValueError):
-            a.u8 = 256
-        a.f32 = 10
-        a.f64 = 10
-        with pytest.raises(ValueError):
-            a.f256 = 10
-        with pytest.raises(bitstring.CreationError):
-            a.u0 = 2
-        with pytest.raises(bitstring.CreationError):
-            a.hex4 = '0xab'
-        assert len(a) == 64
-        with pytest.raises(bitstring.CreationError):
-            a.o3 = '0xab'
-        with pytest.raises(bitstring.CreationError):
-            a.b4 = '0xab'
-        a.h0 = ''
-        assert a.len == 0
-        a.i8 = 127
-        a.i8 = -128
-        with pytest.raises(ValueError):
-            a.i8 = 128
-        with pytest.raises(ValueError):
-            a.i8 = -129
-        with pytest.raises(bitstring.CreationError):
-            a.froggy16 = '0xabc'
-
-    def test_unpack(self):
-        a = BitArray('0xff160120')
-        b = a.unpack('h8,2*u12')
-        assert b == ['ff', 352, 288]
-
-    def test_reading(self):
-        a = bitstring.BitStream.fromstring('0x01ff')
-        b = a.read('u8')
-        assert b == 1
-        assert a.pos == 8
-        assert a.read('i') == -1
-
-    def test_longer_more_general_names(self):
-        a = BitArray()
-        a.f64 = 0.0
-        assert a.float64 == 0.0
-        a.float32 = 10.5
-        assert a.f32 == 10.5
-
-    def test_bytes_properties(self):
-        a = BitArray()
-        a.bytes = b'hello'
-        assert a.bytes5 == b'hello'
-        a.bytes3 = b'123'
-        assert a.bytes == b'123'
-        with pytest.raises(bitstring.CreationError):
-            a.bytes5 = b'123456789'
-        with pytest.raises(bitstring.CreationError):
-            a.bytes5 = b'123'
-
-    def test_conversion_to_bytes(self):
-        a = BitArray(bytes=b'1234')
-        b = bytes(a)
-        assert b == b'1234'
-        a += [1]
-        assert bytes(a) == b'1234\x80'
-        a = BitArray()
-        assert bytes(a) == b''
-
-
-class TestBFloats:
-
-    def test_creation(self):
-        a = BitArray('bfloat=100.5')
-        assert a.unpack('bfloat')[0] == 100.5
-        b = BitArray(bfloat=20.25)
-        assert b.bfloat == 20.25
-        b.bfloat = -30.5
-        assert b.bfloat == -30.5
-        assert len(b) == 16
-        fs = [0.0, -6.1, 1.52e35, 0.000001]
-        a = bitstring.pack('4*bfloat', *fs)
-        fsp = a.unpack('4*bfloat')
-        assert len(a) == len(fs)*16
-        for f, fp in zip(fs, fsp):
-            assert f == pytest.approx(fp, abs=abs(f/100))
-        a = BitArray(bfloat=13)
-        assert a.bfloat == 13
-        c = BitArray()
-        with pytest.raises(ValueError):
-            _ = c.bfloat
-
-
-    def test_creation_errors(self):
-        a = BitArray(bfloat=-0.25, length=16)
-        assert len(a) == 16
-        with pytest.raises(bitstring.CreationError):
-            _ = BitArray(bfloat=10, length=15)
-        with pytest.raises(bitstring.CreationError):
-            _ = BitArray('bfloat:1=0.5')
-
-    def test_little_endian(self):
-        a = BitArray.fromstring('f32=1000')
-        b = BitArray(bfloat=a.f)
-        assert a[0:16] == b[0:16]
-
-        a = BitArray('floatle:32=1000')
-        b = BitArray(bfloatle=1000)
-        assert a[16:32] == b
-        assert b.bfloatle == 1000.0
-        b.byteswap()
-        assert b.bfloat == 1000.0
-        assert b.bfloatbe == 1000.0
-
-        with pytest.raises(bitstring.CreationError):
-            _ = BitArray(bfloatle=-5, length=15)
-        c = BitArray()
-        with pytest.raises(bitstring.InterpretError):
-            _ = c.bfloatle
-        with pytest.raises(bitstring.InterpretError):
-            _ = c.bfloatne
-
-    def test_more_creation(self):
-        a = BitArray('bfloat:16=1.0, bfloat16=2.0, bfloat=3.0')
-        x, y, z = a.unpack('3*bfloat16')
-        assert (x, y, z) == (1.0, 2.0, 3.0)
-
-    def test_interpret_bug(self):
-        a = BitArray(100)
-        with pytest.raises(bitstring.InterpretError):
-            v = a.bfloat
-
-    def test_overflows(self):
-        s = BitArray()
-        inf16 = BitArray(float=float('inf'), length=16)
-        inf32 = BitArray(float=float('inf'), length=32)
-        inf64 = BitArray(float=float('inf'), length=64)
-        infbfloat = BitArray(bfloat=float('inf'))
-        
-        s.f64 = 1e400
-        assert s == inf64
-        s.f32 = 1e60
-        assert s == inf32
-        s.f16 = 100000
-        assert s == inf16
-        s.bfloat = 1e60
-        assert s == infbfloat
-
-        ninf16 = BitArray(float=float('-inf'), length=16)
-        ninf32 = BitArray(float=float('-inf'), length=32)
-        ninf64 = BitArray(float=float('-inf'), length=64)
-        ninfbfloat = BitArray(bfloat=float('-inf'))
-
-        s.f64 = -1e400
-        assert s == ninf64
-        s.f32 = -1e60
-        assert s == ninf32
-        s.f16 = -100000
-        assert s == ninf16
-        s.bfloat = -1e60
-        assert s == ninfbfloat
-
-    def test_big_endian_string_initialisers(self):
-        a = BitArray('bfloatbe=4.5')
-        b = BitArray('bfloatbe:16=-2.25')
-        assert a.bfloatbe == 4.5
-        assert b.bfloatbe == -2.25
-
-    def test_litte_endian_string_initialisers(self):
-        a = BitArray('bfloatle=4.5')
-        b = BitArray('bfloatle:16=-2.25')
-        assert a.bfloatle == 4.5
-        assert b.bfloatle == -2.25
-
-    def test_native_endian_string_initialisers(self):
-        a = BitArray('bfloatne=4.5')
-        b = BitArray('bfloatne:16=-2.25')
-        assert a.bfloatne == 4.5
-        assert b.bfloatne == -2.25
-
-
-
-THIS_DIR = os.path.dirname(os.path.abspath(__file__))
-
-class TestBitarray:
-
-    def teardown_method(self) -> None:
-        bitstring.lsb0 = False
-
-    def test_to_bitarray(self):
-        a = BitArray('0xff, 0b0')
-        b = a.tobitarray()
-        assert type(b) == bitarray.bitarray
-        assert b == bitarray.bitarray('111111110')
-
-    def test_to_bitarray_lsb0(self):
-        bitstring.lsb0 = True
-        a = bitstring.Bits('0xff, 0b0')
-        b = a.tobitarray()
-        assert type(b) == bitarray.bitarray
-        assert b == bitarray.bitarray('111111110')
-
-    def test_from_file(self):
-        a = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
-        b = a.tobitarray()
-        assert a.bin == b.to01()
-
-    def test_with_offset(self):
-        a = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
-        b = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'), offset=11)
-        assert len(a) == len(b) + 11
-        assert a[11:].tobitarray() == b.tobitarray()
-
-    def test_with_length(self):
-        a = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
-        b = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'), length=11)
-        assert len(b) == 11
-        assert a[:11].tobitarray() == b.tobitarray()
-
-    def test_with_offset_and_length(self):
-        a = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
-        b = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'), offset=17, length=7)
-        assert len(b) == 7
-        assert a[17:24].tobitarray() == b.tobitarray()
-
-
-try:
-    import numpy as np
-    numpy_installed = True
-except ImportError:
-    numpy_installed = False
-
-
-class TestNumpy:
-
-    @pytest.mark.skipif(not numpy_installed, reason="numpy not installed.")
-    def test_getting(self):
-        a = BitArray('0b110')
-        p = np.int_(1)
-        assert a[p] == True
-        p = np.short(0)
-        assert a[p] == True
-
-    @pytest.mark.skipif(not numpy_installed, reason="numpy not installed.")
-    def test_setting(self):
-        a = BitArray('0b110')
-        p = np.int_(1)
-        a[p] = '0b1111'
-        assert a == '0b111110'
-
-    @pytest.mark.skipif(not numpy_installed, reason="numpy not installed.")
-    def test_creation(self):
-        a = BitArray(np.longlong(12))
-        assert a.hex == '000'
-
-
-def test_bytes_from_list():
-    s = Bits(bytes=[1, 2])
-    assert s == '0x0102'
-    s = Bits(bytes=bytearray([1, 2]))
-    assert s == '0x0102'
-    s = BitArray(bytes=[1, 2])
-    assert s == '0x0102'
-    s = BitArray(bytes=bytearray([1, 2]))
-    assert s == '0x0102'
-    s.bytes = [10, 20]
+#!/usr/bin/env python
+"""
+Unit tests for the bitarray module.
+"""
+
+import pytest
+import sys
+import os
+import bitarray
+import bitstring
+from bitstring import BitArray, Bits
+
+sys.path.insert(0, '..')
+
+
+class TestAll:
+    def test_creation_from_uint(self):
+        s = BitArray(uint=15, length=6)
+        assert s.bin == '001111'
+        s = BitArray(uint=0, length=1)
+        assert s.bin == '0'
+        s.u = 1
+        assert s.uint == 1
+        s = BitArray(length=8)
+        s.uint = 0
+        assert s.uint == 0
+        s.u8 = 255
+        assert s.uint == 255
+        assert s.len == 8
+        with pytest.raises(bitstring.CreationError):
+            s.uint = 256
+        with pytest.raises(bitstring.CreationError):
+            s.uint = -1
+
+    def test_creation_from_oct(self):
+        s = BitArray(oct='7')
+        assert s.oct == '7'
+        assert s.bin == '111'
+        s.append('0o1')
+        assert s.bin == '111001'
+        s.oct = '12345670'
+        assert s.length == 24
+        assert s.bin == '001010011100101110111000'
+        s = BitArray('0o123')
+        assert s.oct == '123'
+
+
+class TestNoPosAttribute:
+    def test_replace(self):
+        s = BitArray('0b01')
+        s.replace('0b1', '0b11')
+        assert s == '0b011'
+
+    def test_delete(self):
+        s = BitArray('0b000000001')
+        del s[-1:]
+        assert s == '0b00000000'
+
+    def test_insert(self):
+        s = BitArray('0b00')
+        s.insert('0xf', 1)
+        assert s == '0b011110'
+
+    def test_insert_self(self):
+        b = BitArray('0b10')
+        b.insert(b, 0)
+        assert b == '0b1010'
+        c = BitArray('0x00ff')
+        c.insert(c, 8)
+        assert c == '0x0000ffff'
+        a = BitArray('0b11100')
+        a.insert(a, 3)
+        assert a == '0b1111110000'
+
+    def test_no_bit_pos_for_insert(self):
+        s = BitArray(100)
+        with pytest.raises(TypeError):
+            s.insert('0xabc')
+
+    def test_insert_parameters(self):
+        s = BitArray('0b111')
+        with pytest.raises(TypeError):
+            s.insert('0x4')
+
+    def test_overwrite(self):
+        s = BitArray('0b01110')
+        s.overwrite('0b000', 1)
+        assert s == '0b00000'
+
+    def test_overwrite_no_pos(self):
+        s = BitArray('0x01234')
+        with pytest.raises(TypeError):
+            s.overwrite('0xf')
+
+    def test_overwrite_parameters(self):
+        s = BitArray('0b0000')
+        with pytest.raises(TypeError):
+            s.overwrite('0b111')
+
+    def test_prepend(self):
+        s = BitArray('0b0')
+        s.prepend([1])
+        assert s == [1, 0]
+
+    def test_rol(self):
+        s = BitArray('0b0001')
+        s.rol(1)
+        assert s == '0b0010'
+
+    def test_ror(self):
+        s = BitArray('0b1000')
+        s.ror(1)
+        assert s == '0b0100'
+
+    def test_set_item(self):
+        s = BitArray('0b000100')
+        s[4:5] = '0xf'
+        assert s == '0b000111110'
+        s[0:1] = [1]
+        assert s == '0b100111110'
+        s[5:5] = BitArray()
+        assert s == '0b100111110'
+
+
+class TestBugs:
+    def test_adding_nonsense(self):
+        a = BitArray([0])
+        with pytest.raises(ValueError):
+            a += '3'
+        with pytest.raises(ValueError):
+            a += 'se'
+        with pytest.raises(ValueError):
+            a += 'float:32'
+
+    def test_prepend_after_creation_from_data_with_offset(self):
+        s1 = BitArray(bytes=b'\x00\x00\x07\xff\xf0\x00', offset=21, length=15)
+        assert not s1.any(0)
+        b = s1.tobytes()
+        assert b == b'\xff\xfe'
+        s1.prepend('0b0')
+        assert s1.bin == '0111111111111111'
+        s1.prepend('0b0')
+        assert s1.bin == '00111111111111111'
+
+
+class TestByteAligned:
+
+    def test_changing_it(self):
+        bitstring.bytealigned = True
+        assert bitstring.bytealigned
+        bitstring.bytealigned = False
+        assert not bitstring.bytealigned
+
+    def test_not_byte_aligned(self):
+        a = BitArray('0x00 ff 0f f')
+        li = list(a.findall('0xff'))
+        assert li == [8, 20]
+        p = a.find('0x0f')[0]
+        assert p == 4
+        p = a.rfind('0xff')[0]
+        assert p == 20
+        s = list(a.split('0xff'))
+        assert s == ['0x00', '0xff0', '0xff']
+        a.replace('0xff', '')
+        assert a == '0x000'
+
+    def test_byte_aligned(self):
+        bitstring.bytealigned = True
+        a = BitArray('0x00 ff 0f f')
+        li = list(a.findall('0xff'))
+        assert li == [8]
+        p = a.find('0x0f')[0]
+        assert p == 16
+        p = a.rfind('0xff')[0]
+        assert p == 8
+        s = list(a.split('0xff'))
+        assert s == ['0x00', '0xff0ff']
+        a.replace('0xff', '')
+        assert a == '0x000ff'
+        bitstring.bytealigned = False
+
+
+class TestSliceAssignment:
+
+    def test_slice_assignment_single_bit(self):
+        a = BitArray('0b000')
+        a[2] = '0b1'
+        assert a.bin == '001'
+        a[0] = BitArray(bin='1')
+        assert a.bin == '101'
+        a[-1] = '0b0'
+        assert a.bin == '100'
+        a[-3] = '0b0'
+        assert a.bin == '000'
+
+    def test_slice_assignment_single_bit_errors(self):
+        a = BitArray('0b000')
+        with pytest.raises(IndexError):
+            a[-4] = '0b1'
+        with pytest.raises(IndexError):
+            a[3] = '0b1'
+        with pytest.raises(TypeError):
+            a[1] = 1.3
+
+    def test_slice_assignment_muliple_bits(self):
+        a = BitArray('0b0')
+        a[0] = '0b110'
+        assert a.bin3 == '110'
+        a[0] = '0b000'
+        assert a.bin5 == '00010'
+        a[0:3] = '0b111'
+        assert a.b5 == '11110'
+        a[-2:] = '0b011'
+        assert a.bin == '111011'
+        a[:] = '0x12345'
+        assert a.hex == '12345'
+        a[:] = ''
+        assert not a
+
+    def test_slice_assignment_multiple_bits_errors(self):
+        a = BitArray()
+        with pytest.raises(IndexError):
+            a[0] = '0b00'
+        a += '0b1'
+        a[0:2] = '0b11'
+        assert a == '0b11'
+
+    def test_del_slice_step(self):
+        a = BitArray(bin='100111101001001110110100101')
+        del a[::2]
+        assert a.bin == '0110010101100'
+        del a[3:9:3]
+        assert a.bin == '01101101100'
+        del a[2:7:1]
+        assert a.bin == '011100'
+        del a[::99]
+        assert a.bin == '11100'
+        del a[::1]
+        assert a.bin == ''
+
+    def test_del_slice_negative_step(self):
+        a = BitArray('0b0001011101101100100110000001')
+        del a[5:23:-3]
+        assert a.bin == '0001011101101100100110000001'
+        del a[25:3:-3]
+        assert a.bin == '00011101010000100001'
+        del a[:6:-7]
+        assert a.bin == '000111010100010000'
+        del a[15::-2]
+        assert a.bin == '0010000000'
+        del a[::-1]
+        assert a.bin == ''
+
+    def test_del_slice_negative_end(self):
+        a = BitArray('0b01001000100001')
+        del a[:-5]
+        assert a == '0b00001'
+        a = BitArray('0b01001000100001')
+        del a[-11:-5]
+        assert a == '0b01000001'
+
+    def test_del_slice_errors(self):
+        a = BitArray(10)
+        del a[5:3]
+        assert a == Bits(10)
+        del a[3:5:-1]
+        assert a == Bits(10)
+
+    def test_del_single_element(self):
+        a = BitArray('0b0010011')
+        del a[-1]
+        assert a.bin == '001001'
+        del a[2]
+        assert a.bin == '00001'
+        with pytest.raises(IndexError):
+            del a[5]
+
+    def test_set_slice_step(self):
+        a = BitArray(bin='0000000000')
+        a[::2] = '0b11111'
+        assert a.bin == '1010101010'
+        a[4:9:3] = [0, 0]
+        assert a.bin == '1010001010'
+        a[7:3:-1] = [1, 1, 1, 0]
+        assert a.bin == '1010011110'
+        a[7:1:-2] = [0, 0, 1]
+        assert a.b == '1011001010'
+        a[::-5] = [1, 1]
+        assert a.bin == '1011101011'
+        a[::-1] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
+        assert a.bin == '1000000000'
+
+    def test_set_slice_step_with_int(self):
+        a = BitArray(9)
+        a[5:8] = -1
+        assert a.bin == '000001110'
+        a[:] = 10
+        assert a.bin == '000001010'
+        a[::-1] = 10
+        assert a.bin == '010100000'
+        a[::2] = True
+        assert a.bin == '111110101'
+
+    def test_set_slice_errors(self):
+        a = BitArray(8)
+        with pytest.raises(ValueError):
+            a[::3] = [1]
+
+        class A(object):
+            pass
+        with pytest.raises(TypeError):
+            a[1:2] = A()
+        with pytest.raises(ValueError):
+            a[1:4:-1] = [1, 2]
+
+
+class TestSubclassing:
+
+    def test_is_instance(self):
+        class SubBits(BitArray):
+            pass
+        a = SubBits()
+        assert isinstance(a, SubBits)
+
+    def test_class_type(self):
+        class SubBits(BitArray):
+            pass
+        assert SubBits().__class__ == SubBits
+
+
+class TestClear:
+
+    def test_clear(self):
+        s = BitArray('0xfff')
+        s.clear()
+        assert s.len == 0
+
+
+class TestCopy:
+
+    def test_copy_method(self):
+        s = BitArray(9)
+        t = s.copy()
+        assert s == t
+        t[0] = True
+        assert t.bin == '100000000'
+        assert s.bin == '000000000'
+
+
+class TestModifiedByAddingBug:
+
+    def test_adding(self):
+        a = BitArray.fromstring('0b0')
+        b = BitArray('0b11')
+        c = a + b
+        assert c == '0b011'
+        assert a == '0b0'
+        assert b == '0b11'
+
+
+class TestLsb0Setting:
+
+    @classmethod
+    def setup_class(cls):
+        bitstring.lsb0 = True
+
+    @classmethod
+    def teardown_class(cls):
+        bitstring.lsb0 = False
+
+    def test_set_single_bit(self):
+        a = BitArray(10)
+        a[0] = True
+        assert a == '0b0000000001'
+        a[1] = True
+        assert a == '0b0000000011'
+        a[0] = False
+        assert a == '0b0000000010'
+        a[9] = True
+        assert a == '0b1000000010'
+        with pytest.raises(IndexError):
+            a[10] = True
+
+    def test_set_single_negative_bit(self):
+        a = BitArray('0o000')
+        a[-1] = True
+        assert a == '0b100000000'
+        a[-2] = True
+        assert a == '0o600'
+        a[-9] = True
+        assert a == '0o601'
+        with pytest.raises(IndexError):
+            a[-10] = True
+
+    def test_invert_bit(self):
+        a = BitArray('0b11110000')
+        a.invert()
+        assert a == '0x0f'
+        a.invert(0)
+        assert a == '0b00001110'
+        a.invert(-1)
+        assert a == '0b10001110'
+
+    def test_deleting_bits(self):
+        a = BitArray('0b11110')
+        del a[0]
+        assert a == '0xf'
+
+    def test_deleting_range(self):
+        a = BitArray('0b101111000')
+        del a[0:1]
+        assert a == '0b10111100'
+        del a[2:6]
+        assert a == '0b1000'
+        a = BitArray('0xabcdef')
+        del a[:8]
+        assert a == '0xabcd'
+        del a[-4:]
+        assert a == '0xbcd'
+        del a[:-4]
+        assert a == '0xb'
+
+    def test_appending_bits(self):
+        a = BitArray('0b111')
+        a.append('0b000')
+        assert a.bin == '000111'
+        a += '0xabc'
+        assert a == '0xabc, 0b000111'
+
+    def test_setting_slice(self):
+        a = BitArray('0x012345678')
+        a[4:12] = '0xfe'
+        assert a == '0x012345fe8'
+        a[0:4] = '0xbeef'
+        assert a == '0x012345febeef'
+
+    def test_truncating_start(self):
+        a = BitArray('0b1110000')
+        a = a[4:]
+        assert a == '0b111'
+
+    def test_truncating_end(self):
+        a = BitArray('0x123456')
+        a = a[:16]
+        assert a == '0x3456'
+
+    def test_all(self):
+        a = BitArray('0b0000101')
+        assert a.all(1, [0, 2])
+        assert a.all(False, [-1, -2, -3, -4])
+
+        b = Bits(bytes=b'\x00\xff\xff', offset=7)
+        assert b.all(1, [1, 2, 3, 4, 5, 6, 7])
+        assert b.all(1, [-2, -3, -4, -5, -6, -7, -8])
+
+    def test_any(self):
+        a = BitArray('0b0001')
+        assert a.any(1, [0, 1, 2])
+
+    def test_endswith(self):
+        a = BitArray('0xdeadbeef')
+        assert a.endswith('0xdead')
+
+    def test_startswith(self):
+        a = BitArray('0xdeadbeef')
+        assert a.startswith('0xbeef')
+
+    def test_cut(self):
+        a = BitArray('0xff00ff1111ff2222')
+        li = list(a.cut(16))
+        assert li == ['0x2222', '0x11ff', '0xff11', '0xff00']
+
+    def test_find(self):
+        t = BitArray('0b10')
+        p, = t.find('0b1')
+        assert p == 1
+        t = BitArray('0b1010')
+        p, = t.find('0b1')
+        assert p == 1
+        a = BitArray('0b10101010, 0xabcd, 0b10101010, 0x0')
+        p, = a.find('0b10101010', bytealigned=False)
+        assert p == 4
+        p, = a.find('0b10101010', start=4, bytealigned=False)
+        assert p == 4
+        p, = a.find('0b10101010', start=5, bytealigned=False)
+        assert p == 22
+
+    def test_find_failing(self):
+        a = BitArray()
+        p = a.find('0b1')
+        assert p == ()
+        a = BitArray('0b11111111111011')
+        p = a.find('0b100')
+        assert not p
+
+    def test_find_failing2(self):
+        s = BitArray('0b101')
+        p, = s.find('0b1', start=2)
+        assert p == 2
+
+    def test_rfind(self):
+        a = BitArray('0b1000000')
+        p = a.rfind('0b1')
+        assert p == (6,)
+        p = a.rfind('0b000')
+        assert p == (3,)
+
+    def test_rfind_with_start_and_end(self):
+        a = BitArray('0b11 0000 11 00')
+        p = a.rfind('0b11', start=8)
+        assert p[0] == 8
+        p = a.rfind('0b110', start=8)
+        assert p == ()
+        p = a.rfind('0b11', end=-1)
+        assert p[0] == 2
+
+    def test_findall(self):
+        a = BitArray('0b001000100001')
+        b = list(a.findall('0b1'))
+        assert b == [0, 5, 9]
+        c = list(a.findall('0b0001'))
+        assert c == [0, 5]
+        d = list(a.findall('0b10'))
+        assert d == [4, 8]
+        e = list(a.findall('0x198273641234'))
+        assert e == []
+
+    def test_find_all_with_start_and_end(self):
+        a = BitArray('0xaabbccaabbccccbb')
+        b = list(a.findall('0xbb', start=0, end=8))
+        assert b == [0]
+        b = list(a.findall('0xbb', start=1, end=8))
+        assert b == []
+        b = list(a.findall('0xbb', start=0, end=7))
+        assert b == []
+        b = list(a.findall('0xbb', start=48))
+        assert b == [48]
+        b = list(a.findall('0xbb', start=47))
+        assert b == [48]
+        b = list(a.findall('0xbb', start=49))
+        assert b == []
+
+    def test_find_all_byte_aligned(self):
+        a = BitArray('0x0550550')
+        b = list(a.findall('0x55', bytealigned=True))
+        assert b == [16]
+
+    def test_find_all_with_count(self):
+        a = BitArray('0b0001111101')
+        b = list(a.findall([1], start=1, count=1))
+        assert b == [2]
+
+    def test_split(self):
+        a = BitArray('0x4700004711472222')
+        li = list(a.split('0x47', bytealigned=True))
+        assert li == ['', '0x472222', '0x4711', '0x470000']
+
+    def test_byte_swap(self):
+        a = BitArray('0xaa00ff00ff00')
+        n = a.byteswap(2, end=32, repeat=True)
+        assert n == 2
+        assert a == '0xaa0000ff00ff'
+
+    def test_insert(self):
+        a = BitArray('0x0123456')
+        a.insert('0xf', 4)
+        assert a == '0x012345f6'
+
+    def test_overwrite(self):
+        a = BitArray('0x00000000')
+        a.overwrite('0xdead', 4)
+        assert a == '0x000dead0'
+
+    def test_replace(self):
+        a = BitArray('0x5551100')
+        n = a.replace('0x1', '0xabc')
+        assert n == 2
+        assert a == '0x555abcabc00'
+        n = a.replace([1], [0], end=12)
+        assert n == 2
+        assert a == '0x555abcab000'
+
+    def test_reverse(self):
+        a = BitArray('0x0011223344')
+        a.reverse()
+        assert a == '0x22cc448800'
+        a.reverse(0, 16)
+        assert a == '0x22cc440011'
+
+    def test_ror(self):
+        a = BitArray('0b111000')
+        a.ror(1)
+        assert a == '0b011100'
+        a = BitArray('0b111000')
+        a.ror(1, start=2, end=6)
+        assert a == '0b011100'
+
+    def test_rol(self):
+        a = BitArray('0b1')
+        a.rol(12)
+        assert a == '0b1'
+        b = BitArray('0b000010')
+        b.rol(3)
+        assert b == '0b010000'
+
+    def test_set(self):
+        a = BitArray(100)
+        a.set(1, [0, 2, 4])
+        assert a[0]
+        assert a.startswith('0b000010101')
+        a = BitArray('0b111')
+        a.set(False, 0)
+        assert a == '0b110'
+
+    def test_failing_repr(self):
+        a = BitArray('0b010')
+        a.find('0b1')
+        assert repr(a) == "BitArray('0b010')"
+
+    def test_left_shift(self):
+        a = BitArray('0b11001')
+        assert (a << 1).b == '10010'
+        assert (a << 5).b == '00000'
+        assert (a << 0).b == '11001'
+
+    def test_right_shift(self):
+        a = BitArray('0b11001')
+        assert (a >> 1).b == '01100'
+        assert (a >> 5).b == '00000'
+        assert (a >> 0).b == '11001'
+
+    # def testConstFileBased(self):
+    #     filename = os.path.join(THIS_DIR, 'test.m1v')
+    #     a = Bits(filename=filename, offset=8)
+    #     self.assertTrue(a[-8])
+    #     self.assertTrue(a.endswith('0x01b3'))
+
+
+class TestRepr:
+
+    def test_standard_repr(self):
+        a = BitArray('0o12345')
+        assert repr(a) == "BitArray('0b001010011100101')"
+
+
+class TestNewProperties:
+
+    def test_aliases(self):
+        a = BitArray('0x1234567890ab')
+        assert a.oct == a.o
+        assert a.hex == a.h
+        assert a.bin == a.b
+        assert a[:32].float == a[:32].f
+        assert a.int == a.i
+        assert a.uint == a.u
+
+    def test_aliases_with_lengths(self):
+        a = BitArray('0x123')
+        h = a.h12
+        assert h == '123'
+        b = a.b12
+        assert b == '000100100011'
+        o = a.o12
+        assert o == '0443'
+        u = a.u12
+        assert u == a.u
+        i = a.i12
+        assert i == a.i
+        x = BitArray('0x12345678')
+        f = x.f32
+        assert f == x.f
+
+    def test_assignments(self):
+        a = BitArray()
+        a.f64 = 0.5
+        assert a.f64 == 0.5
+        a.u88 = 1244322
+        assert a.u88 == 1244322
+        a.i3 = -3
+        assert a.i3 == -3
+        a.h16 = '0x1234'
+        assert a.h16 == '1234'
+        a.o9 = '0o765'
+        assert a.o9 == '765'
+        a.b7 = '0b0001110'
+        assert a.b7 == '0001110'
+
+    def test_assignments_without_length(self):
+        a = BitArray(64)
+        a.f = 1234.5
+        assert a.float == 1234.5
+        assert a.len == 64
+        a.u = 99
+        assert a.uint == 99
+        assert a.len == 64
+        a.i = -999
+        assert a.int == -999
+        assert a.len == 64
+        a.h = 'feedbeef'
+        assert a.hex == 'feedbeef'
+        a.o = '1234567'
+        assert a.oct == '1234567'
+        a.b = '001'
+        assert a.bin == '001'
+
+    def test_getter_length_errors(self):
+        a = BitArray('0x123')
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.h16
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.b3317777766
+        with pytest.raises(AttributeError):
+            _ = a.o2
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.f
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.f32
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.u13
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.i1
+        b = BitArray()
+        with pytest.raises(bitstring.InterpretError):
+            _ = b.u0
+
+    def test_setter_length_errors(self):
+        a = BitArray()
+        a.u8 = 255
+        assert a.len == 8
+        with pytest.raises(ValueError):
+            a.u8 = 256
+        a.f32 = 10
+        a.f64 = 10
+        with pytest.raises(ValueError):
+            a.f256 = 10
+        with pytest.raises(bitstring.CreationError):
+            a.u0 = 2
+        with pytest.raises(bitstring.CreationError):
+            a.hex4 = '0xab'
+        assert len(a) == 64
+        with pytest.raises(bitstring.CreationError):
+            a.o3 = '0xab'
+        with pytest.raises(bitstring.CreationError):
+            a.b4 = '0xab'
+        a.h0 = ''
+        assert a.len == 0
+        a.i8 = 127
+        a.i8 = -128
+        with pytest.raises(ValueError):
+            a.i8 = 128
+        with pytest.raises(ValueError):
+            a.i8 = -129
+        with pytest.raises(bitstring.CreationError):
+            a.froggy16 = '0xabc'
+
+    def test_unpack(self):
+        a = BitArray('0xff160120')
+        b = a.unpack('h8,2*u12')
+        assert b == ['ff', 352, 288]
+
+    def test_reading(self):
+        a = bitstring.BitStream.fromstring('0x01ff')
+        b = a.read('u8')
+        assert b == 1
+        assert a.pos == 8
+        assert a.read('i') == -1
+
+    def test_longer_more_general_names(self):
+        a = BitArray()
+        a.f64 = 0.0
+        assert a.float64 == 0.0
+        a.float32 = 10.5
+        assert a.f32 == 10.5
+
+    def test_bytes_properties(self):
+        a = BitArray()
+        a.bytes = b'hello'
+        assert a.bytes5 == b'hello'
+        a.bytes3 = b'123'
+        assert a.bytes == b'123'
+        with pytest.raises(bitstring.CreationError):
+            a.bytes5 = b'123456789'
+        with pytest.raises(bitstring.CreationError):
+            a.bytes5 = b'123'
+
+    def test_conversion_to_bytes(self):
+        a = BitArray(bytes=b'1234')
+        b = bytes(a)
+        assert b == b'1234'
+        a += [1]
+        assert bytes(a) == b'1234\x80'
+        a = BitArray()
+        assert bytes(a) == b''
+
+
+class TestBFloats:
+
+    def test_creation(self):
+        a = BitArray('bfloat=100.5')
+        assert a.unpack('bfloat')[0] == 100.5
+        b = BitArray(bfloat=20.25)
+        assert b.bfloat == 20.25
+        b.bfloat = -30.5
+        assert b.bfloat == -30.5
+        assert len(b) == 16
+        fs = [0.0, -6.1, 1.52e35, 0.000001]
+        a = bitstring.pack('4*bfloat', *fs)
+        fsp = a.unpack('4*bfloat')
+        assert len(a) == len(fs)*16
+        for f, fp in zip(fs, fsp):
+            assert f == pytest.approx(fp, abs=abs(f/100))
+        a = BitArray(bfloat=13)
+        assert a.bfloat == 13
+        c = BitArray()
+        with pytest.raises(ValueError):
+            _ = c.bfloat
+
+
+    def test_creation_errors(self):
+        a = BitArray(bfloat=-0.25, length=16)
+        assert len(a) == 16
+        with pytest.raises(bitstring.CreationError):
+            _ = BitArray(bfloat=10, length=15)
+        with pytest.raises(bitstring.CreationError):
+            _ = BitArray('bfloat:1=0.5')
+
+    def test_little_endian(self):
+        a = BitArray.fromstring('f32=1000')
+        b = BitArray(bfloat=a.f)
+        assert a[0:16] == b[0:16]
+
+        a = BitArray('floatle:32=1000')
+        b = BitArray(bfloatle=1000)
+        assert a[16:32] == b
+        assert b.bfloatle == 1000.0
+        b.byteswap()
+        assert b.bfloat == 1000.0
+        assert b.bfloatbe == 1000.0
+
+        with pytest.raises(bitstring.CreationError):
+            _ = BitArray(bfloatle=-5, length=15)
+        c = BitArray()
+        with pytest.raises(bitstring.InterpretError):
+            _ = c.bfloatle
+        with pytest.raises(bitstring.InterpretError):
+            _ = c.bfloatne
+
+    def test_more_creation(self):
+        a = BitArray('bfloat:16=1.0, bfloat16=2.0, bfloat=3.0')
+        x, y, z = a.unpack('3*bfloat16')
+        assert (x, y, z) == (1.0, 2.0, 3.0)
+
+    def test_interpret_bug(self):
+        a = BitArray(100)
+        with pytest.raises(bitstring.InterpretError):
+            v = a.bfloat
+
+    def test_overflows(self):
+        s = BitArray()
+        inf16 = BitArray(float=float('inf'), length=16)
+        inf32 = BitArray(float=float('inf'), length=32)
+        inf64 = BitArray(float=float('inf'), length=64)
+        infbfloat = BitArray(bfloat=float('inf'))
+        
+        s.f64 = 1e400
+        assert s == inf64
+        s.f32 = 1e60
+        assert s == inf32
+        s.f16 = 100000
+        assert s == inf16
+        s.bfloat = 1e60
+        assert s == infbfloat
+
+        ninf16 = BitArray(float=float('-inf'), length=16)
+        ninf32 = BitArray(float=float('-inf'), length=32)
+        ninf64 = BitArray(float=float('-inf'), length=64)
+        ninfbfloat = BitArray(bfloat=float('-inf'))
+
+        s.f64 = -1e400
+        assert s == ninf64
+        s.f32 = -1e60
+        assert s == ninf32
+        s.f16 = -100000
+        assert s == ninf16
+        s.bfloat = -1e60
+        assert s == ninfbfloat
+
+    def test_big_endian_string_initialisers(self):
+        a = BitArray('bfloatbe=4.5')
+        b = BitArray('bfloatbe:16=-2.25')
+        assert a.bfloatbe == 4.5
+        assert b.bfloatbe == -2.25
+
+    def test_litte_endian_string_initialisers(self):
+        a = BitArray('bfloatle=4.5')
+        b = BitArray('bfloatle:16=-2.25')
+        assert a.bfloatle == 4.5
+        assert b.bfloatle == -2.25
+
+    def test_native_endian_string_initialisers(self):
+        a = BitArray('bfloatne=4.5')
+        b = BitArray('bfloatne:16=-2.25')
+        assert a.bfloatne == 4.5
+        assert b.bfloatne == -2.25
+
+
+
+THIS_DIR = os.path.dirname(os.path.abspath(__file__))
+
+class TestBitarray:
+
+    def teardown_method(self) -> None:
+        bitstring.lsb0 = False
+
+    def test_to_bitarray(self):
+        a = BitArray('0xff, 0b0')
+        b = a.tobitarray()
+        assert type(b) == bitarray.bitarray
+        assert b == bitarray.bitarray('111111110')
+
+    def test_to_bitarray_lsb0(self):
+        bitstring.lsb0 = True
+        a = bitstring.Bits('0xff, 0b0')
+        b = a.tobitarray()
+        assert type(b) == bitarray.bitarray
+        assert b == bitarray.bitarray('111111110')
+
+    def test_from_file(self):
+        a = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
+        b = a.tobitarray()
+        assert a.bin == b.to01()
+
+    def test_with_offset(self):
+        a = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
+        b = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'), offset=11)
+        assert len(a) == len(b) + 11
+        assert a[11:].tobitarray() == b.tobitarray()
+
+    def test_with_length(self):
+        a = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
+        b = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'), length=11)
+        assert len(b) == 11
+        assert a[:11].tobitarray() == b.tobitarray()
+
+    def test_with_offset_and_length(self):
+        a = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
+        b = bitstring.ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'), offset=17, length=7)
+        assert len(b) == 7
+        assert a[17:24].tobitarray() == b.tobitarray()
+
+
+try:
+    import numpy as np
+    numpy_installed = True
+except ImportError:
+    numpy_installed = False
+
+
+class TestNumpy:
+
+    @pytest.mark.skipif(not numpy_installed, reason="numpy not installed.")
+    def test_getting(self):
+        a = BitArray('0b110')
+        p = np.int_(1)
+        assert a[p] == True
+        p = np.short(0)
+        assert a[p] == True
+
+    @pytest.mark.skipif(not numpy_installed, reason="numpy not installed.")
+    def test_setting(self):
+        a = BitArray('0b110')
+        p = np.int_(1)
+        a[p] = '0b1111'
+        assert a == '0b111110'
+
+    @pytest.mark.skipif(not numpy_installed, reason="numpy not installed.")
+    def test_creation(self):
+        a = BitArray(np.longlong(12))
+        assert a.hex == '000'
+
+
+def test_bytes_from_list():
+    s = Bits(bytes=[1, 2])
+    assert s == '0x0102'
+    s = Bits(bytes=bytearray([1, 2]))
+    assert s == '0x0102'
+    s = BitArray(bytes=[1, 2])
+    assert s == '0x0102'
+    s = BitArray(bytes=bytearray([1, 2]))
+    assert s == '0x0102'
+    s.bytes = [10, 20]
     assert s == '0x0a14'
```

### Comparing `bitstring-4.2.1/tests/test_bits.py` & `bitstring-4.2.2/tests/test_bits.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,981 +1,981 @@
-#!/usr/bin/env python
-import pytest
-import io
-import sys
-import bitarray
-import bitstring
-import array
-import os
-import re
-from bitstring import InterpretError, Bits, BitArray
-from hypothesis import given, assume
-import hypothesis.strategies as st
-
-
-sys.path.insert(0, '..')
-
-THIS_DIR = os.path.dirname(os.path.abspath(__file__))
-
-def remove_unprintable(s: str) -> str:
-    colour_escape = re.compile(r'(?:\x1B[@-_])[0-?]*[ -/]*[@-~]')
-    return colour_escape.sub('', s)
-
-class TestCreation:
-    def test_creation_from_bytes(self):
-        s = Bits(bytes=b'\xa0\xff')
-        assert (s.len, s.hex) == (16, 'a0ff')
-        s = Bits(bytes=b'abc', length=0)
-        assert s == ''
-
-    @given(st.binary())
-    def test_creation_from_bytes_roundtrip(self, data):
-        s = Bits(bytes=data)
-        assert s.bytes == data
-
-    def test_creation_from_bytes_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            Bits(bytes=b'abc', length=25)
-
-    def test_creation_from_data_with_offset(self):
-        s1 = Bits(bytes=b'\x0b\x1c\x2f', offset=0, length=20)
-        s2 = Bits(bytes=b'\xa0\xb1\xC2', offset=4)
-        assert (s2.len, s2.hex) == (20, '0b1c2')
-        assert (s1.len, s1.hex) == (20, '0b1c2')
-        assert s1 == s2
-
-    def test_creation_from_hex(self):
-        s = Bits(hex='0xA0ff')
-        assert (s.len, s.hex) == (16, 'a0ff')
-        s = Bits(hex='0x0x0X')
-        assert (s.length, s.hex) == (0, '')
-
-    def test_creation_from_hex_with_whitespace(self):
-        s = Bits(hex='  \n0 X a  4e       \r3  \n')
-        assert s.hex == 'a4e3'
-
-    def test_creation_from_hex_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            Bits(hex='0xx0')
-        with pytest.raises(bitstring.CreationError):
-            Bits(hex='0xX0')
-        with pytest.raises(bitstring.CreationError):
-            Bits(hex='0Xx0')
-        with pytest.raises(bitstring.CreationError):
-            Bits(hex='-2e')
-        with pytest.raises(bitstring.CreationError):
-            Bits('0x2', length=2)
-        with pytest.raises(bitstring.CreationError):
-            Bits('0x3', offset=1)
-
-    def test_creation_from_bin(self):
-        s = Bits(bin='1010000011111111')
-        assert (s.length, s.hex) == (16, 'a0ff')
-        s = Bits(bin='00')[:1]
-        assert s.bin == '0'
-        s = Bits(bin=' 0000 \n 0001\r ')
-        assert s.bin == '00000001'
-
-    def test_creation_from_bin_with_whitespace(self):
-        s = Bits(bin='  \r\r\n0   B    00   1 1 \t0 ')
-        assert s.bin == '00110'
-
-    def test_creation_from_oct_errors(self):
-        s = Bits('0b00011')
-        with pytest.raises(bitstring.InterpretError):
-            _ = s.oct
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits('oct=8')
-
-    def test_creation_from_uint_with_offset(self):
-        with pytest.raises(bitstring.CreationError):
-            Bits(uint=12, length=8, offset=1)
-
-    def test_creation_from_uint_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            Bits(uint=-1, length=10)
-        with pytest.raises(bitstring.CreationError):
-            Bits(uint=12)
-        with pytest.raises(bitstring.CreationError):
-            Bits(uint=4, length=2)
-        with pytest.raises(bitstring.CreationError):
-            Bits(uint=0, length=0)
-        with pytest.raises(bitstring.CreationError):
-            Bits(uint=12, length=-12)
-
-    def test_creation_from_int(self):
-        s = Bits(int=0, length=4)
-        temp = s.hex
-        assert s.bin == '0000'
-        s = Bits(int=1, length=2)
-        assert s.bin == '01'
-        s = Bits(int=-1, length=11)
-        assert s.bin == '11111111111'
-        s = Bits(int=12, length=7)
-        assert s.int == 12
-        s = Bits(int=-243, length=108)
-        assert (s.int, s.length) == (-243, 108)
-        for length in range(6, 10):
-            for value in range(-17, 17):
-                s = Bits(int=value, length=length)
-                assert (s.int, s.length) == (value, length)
-        _ = Bits(int=10, length=8)
-
-    def test_creation_from_int_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(int=-1, length=0)
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(int=12)
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(int=4, length=3)
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(int=-5, length=3)
-
-    def test_creation_from_se(self):
-        for i in range(-100, 10):
-            s = Bits(se=i)
-            assert s.se == i
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(se=10, length=40)
-
-    def test_creation_from_se_with_offset(self):
-        with pytest.raises(bitstring.CreationError):
-            Bits(se=-13, offset=1)
-
-    def test_creation_from_se_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            Bits(se=-5, length=33)
-        with pytest.raises(bitstring.CreationError):
-            Bits('se2=0')
-        s = Bits(bin='001000')
-        with pytest.raises(bitstring.InterpretError):
-            _ = s.se
-
-    def test_creation_from_ue(self):
-        for i in range(0, 20):
-            assert Bits(ue=i).ue == i
-
-    def test_creation_from_ue_with_offset(self):
-        with pytest.raises(bitstring.CreationError):
-            Bits(ue=104, offset=2)
-
-    def test_creation_from_ue_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            Bits(ue=-1)
-        with pytest.raises(bitstring.CreationError):
-            Bits(ue=1, length=12)
-        s = Bits(bin='10')
-        with pytest.raises(bitstring.InterpretError):
-            _ = s.ue
-
-    def test_creation_from_bool(self):
-        a = Bits('bool=1')
-        assert a == 'bool=1'
-        b = Bits('bool:1=0')
-        assert b == [0]
-        c = bitstring.pack('bool=1, 2*bool', 0, 1)
-        assert c == '0b101'
-        d = bitstring.pack('bool:1=1, 2*bool1', 1, 0)
-        assert d == '0b110'
-
-    def test_creation_from_bool_errors(self):
-        with pytest.raises(ValueError):
-            _ = Bits('bool=3')
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(bool=0, length=2)
-
-    def test_creation_keyword_error(self):
-        with pytest.raises(bitstring.CreationError):
-            Bits(squirrel=5)
-
-    def test_creation_from_bitarray(self):
-        ba = bitarray.bitarray('0010')
-        bs = Bits(ba)
-        assert bs.bin == '0010'
-        bs2 = Bits(bitarray=ba)
-        assert bs2.bin == '0010'
-
-    def test_creation_from_frozen_bitarray(self):
-        fba = bitarray.frozenbitarray('111100001')
-        ba = Bits(fba)
-        assert ba.bin == '111100001'
-        bs2 = Bits(bitarray=fba)
-        assert bs2.bin == '111100001'
-        bs3 = Bits(bitarray=fba, offset=4)
-        assert bs3.bin == '00001'
-        bs3 = Bits(bitarray=fba, offset=4, length=4)
-        assert bs3.bin == '0000'
-
-    def test_creation_from_bitarray_errors(self):
-        ba = bitarray.bitarray('0101')
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(bitarray=ba, length=5)
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(bitarray=ba, offset=5)
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(ba, length=-1)
-
-    def test_creation_from_memoryview(self):
-        x = bytes(bytearray(range(20)))
-        m = memoryview(x[10:15])
-        b = Bits(m)
-        assert b.unpack('5*u8') == [10, 11, 12, 13, 14]
-
-
-class TestInitialisation:
-    def test_empty_init(self):
-        a = Bits()
-        assert a == ''
-
-    def test_no_pos(self):
-        a = Bits('0xabcdef')
-        with pytest.raises(AttributeError):
-            _ = a.pos
-
-    def test_find(self):
-        a = Bits('0xabcd')
-        r = a.find('0xbc')
-        assert r[0] == 4
-        r = a.find('0x23462346246', bytealigned=True)
-        assert not r
-
-    def test_rfind(self):
-        a = Bits('0b11101010010010')
-        b = a.rfind('0b010')
-        assert b[0] == 11
-
-    def test_find_all(self):
-        a = Bits('0b0010011')
-        b = list(a.findall([1]))
-        assert b == [2, 5, 6]
-        t = BitArray('0b10')
-        tp = list(t.findall('0b1'))
-        assert tp == [0]
-
-
-class TestCut:
-    def test_cut(self):
-        s = Bits('0b000111'*10)
-        for t in s.cut(6):
-            assert t.bin == '000111'
-
-
-class TestInterleavedExpGolomb:
-    def test_creation(self):
-        s1 = Bits(uie=0)
-        s2 = Bits(uie=1)
-        assert s1 == [1]
-        assert s2 == [0, 0, 1]
-        s1 = Bits(sie=0)
-        s2 = Bits(sie=-1)
-        s3 = Bits(sie=1)
-        assert s1 == [1]
-        assert s2 == [0, 0, 1, 1]
-        assert s3 == [0, 0, 1, 0]
-
-    def test_creation_from_property(self):
-        s = BitArray()
-        s.uie = 45
-        assert s.uie == 45
-        s.sie = -45
-        assert s.sie == -45
-
-    def test_interpretation(self):
-        for x in range(101):
-            assert Bits(uie=x).uie == x
-        for x in range(-100, 100):
-            assert Bits(sie=x).sie == x
-
-    def test_errors(self):
-        for f in ['sie=100, 0b1001', '0b00', 'uie=100, 0b1001']:
-            s = Bits.fromstring(f)
-            with pytest.raises(bitstring.InterpretError):
-                _ = s.sie
-            with pytest.raises(bitstring.InterpretError):
-                _ = s.uie
-        with pytest.raises(ValueError):
-            Bits(uie=-10)
-
-
-class TestFileBased:
-    def setup_method(self):
-        filename = os.path.join(THIS_DIR, 'smalltestfile')
-        self.a = Bits(filename=filename)
-        self.b = Bits(filename=filename, offset=16)
-        self.c = Bits(filename=filename, offset=20, length=16)
-        self.d = Bits(filename=filename, offset=20, length=4)
-
-    def test_creation_with_offset(self):
-        assert str(self.a) == '0x0123456789abcdef'
-        assert str(self.b) == '0x456789abcdef'
-        assert str(self.c) == '0x5678'
-
-    def test_bit_operators(self):
-        x = self.b[4:20]
-        assert x == '0x5678'
-        assert (x & self.c).hex == self.c.hex
-        assert self.c ^ self.b[4:20] == Bits(16)
-        assert self.a[23:36] | self.c[3:] == self.c[3:]
-        y = x & self.b[4:20]
-        assert y == self.c
-        assert repr(y) == repr(self.c)
-
-    def test_addition(self):
-        _ = self.d + '0x1'
-        x = self.a[20:24] + self.c[-4:] + self.c[8:12]
-        assert x == '0x587'
-        x = self.b + x
-        assert x.h == '456789abcdef587'
-        x = BitArray(x)
-        del x[12:24]
-        assert x == '0x456abcdef587'
-
-
-class TestComparisons:
-    def test_unorderable(self):
-        a = Bits(5)
-        b = Bits(5)
-        with pytest.raises(TypeError):
-            _ = a < b
-        with pytest.raises(TypeError):
-            _ = a > b
-        with pytest.raises(TypeError):
-            _ = a <= b
-        with pytest.raises(TypeError):
-            _ = a >= b
-
-
-class TestSubclassing:
-
-    def test_is_instance(self):
-        class SubBits(bitstring.Bits):
-            pass
-        a = SubBits()
-        assert isinstance(a, SubBits)
-
-    def test_class_type(self):
-        class SubBits(bitstring.Bits):
-            pass
-        assert SubBits().__class__ == SubBits
-
-
-class TestLongBoolConversion:
-
-    def test_long_bool(self):
-        a = Bits(1000)
-        b = bool(a)
-        assert b is True
-
-
-class TestPadToken:
-
-    def test_creation(self):
-        a = Bits.fromstring('pad:10')
-        assert a == Bits(10)
-        b = Bits('pad:0')
-        assert b == Bits()
-        c = Bits('0b11, pad:1, 0b111')
-        assert c == Bits('0b110111')
-
-    def test_pack(self):
-        s = bitstring.pack('0b11, pad:3, 0b1')
-        assert s.bin == '110001'
-        d = bitstring.pack('pad:c', c=12)
-        assert d == Bits(12)
-        e = bitstring.pack('0xf, uint12, pad:1, bin, pad4, 0b10', 0, '111')
-        assert e.bin == '11110000000000000111000010'
-
-    def test_unpack(self):
-        s = Bits('0b111000111')
-        x, y = s.unpack('3, pad:3, 3')
-        assert (x, y.u) == ('0b111', 7)
-        x, y = s.unpack('2, pad2, bin')
-        assert (x.u2, y) == (3, '00111')
-        x = s.unpack('pad:1, pad:2, pad:3')
-        assert x == []
-
-    def test_unpack_bug(self):
-        t = Bits('0o755, ue=12, int3=-1')
-        a, b = t.unpack('pad:9, ue, int3')
-        assert (a, b) == (12, -1)
-
-
-class TestModifiedByAddingBug:
-
-    def test_adding(self):
-        a = Bits('0b0')
-        b = Bits('0b11')
-        c = a + b
-        assert c == '0b011'
-        assert a == '0b0'
-        assert b == '0b11'
-
-    def test_adding2(self):
-        a = Bits(100)
-        b = Bits(101)
-        c = a + b
-        assert a == Bits(100)
-        assert b == Bits(101)
-        assert c == Bits(201)
-
-
-class TestWrongTypeBug:
-
-    def test_append_to_bits(self):
-        a = Bits(BitArray())
-        with pytest.raises(AttributeError):
-            a.append('0b1')
-        assert type(a) == Bits
-        b = bitstring.ConstBitStream(bitstring.BitStream())
-        assert type(b) == bitstring.ConstBitStream
-
-
-class TestInitFromArray:
-
-    @given(st.sampled_from(['B', 'H', 'I', 'L', 'Q', 'f', 'd']))
-    def test_empty_array(self, t):
-        a = array.array(t)
-        b = Bits(a)
-        assert b.length == 0
-
-    def test_single_byte(self):
-        a = array.array('B', b'\xff')
-        b = Bits(a)
-        assert b.length == 8
-        assert b.hex == 'ff'
-
-    def test_signed_short(self):
-        a = array.array('h')
-        a.append(10)
-        a.append(-1)
-        b = Bits(a)
-        assert b.length == 32
-        assert b.bytes == a.tobytes()
-
-    def test_double(self):
-        a = array.array('d', [0.0, 1.0, 2.5])
-        b = Bits(a)
-        assert b.length == 192
-        c, d, e = b.unpack('3*floatne:64')
-        assert (c, d, e) == (0.0, 1.0, 2.5)
-
-
-class TestIteration:
-
-    def test_iterate_empty_bits(self):
-        assert list(Bits([])) == []
-        assert list(Bits([1, 0])[1:1]) == []
-
-    def test_iterate_non_empty_bits(self):
-        assert list(Bits([1, 0])) == [True, False]
-        assert list(Bits([1, 0, 0, 1])[1:3]) == [False, False]
-
-    def test_iterate_long_bits(self):
-        assert list(Bits([1, 0]) * 1024) == \
-            [True, False] * 1024
-
-        
-class TestContainsBug:
-
-    def test_contains(self):
-        a = Bits('0b1, 0x0001dead0001')
-        assert '0xdead' in a
-        assert not '0xfeed' in a
-
-        assert '0b1' in Bits('0xf')
-        assert not '0b0' in Bits('0xf')
-
-
-class TestByteStoreImmutablity:
-
-    def test_immutability_bug_append(self):
-        a = Bits('0b111')
-        b = a + '0b000'
-        c = BitArray(b)
-        c[1] = 0
-        assert c.bin == '101000'
-        assert a.b3 == '111'
-        assert b.bin == '111000'
-
-    def test_immutability_bug_prepend(self):
-        a = Bits('0b111')
-        b = '0b000' + a
-        c = BitArray(b)
-        c[1] = 1
-        assert b.bin == '000111'
-        assert c.bin == '010111'
-
-
-class TestLsb0Indexing:
-
-    @classmethod
-    def setup_class(cls):
-        bitstring.lsb0 = True
-
-    @classmethod
-    def teardown_class(cls):
-        bitstring.lsb0 = False
-
-    def test_get_single_bit(self):
-        a = Bits('0b000001111')
-        assert a[0] == True
-        assert a[3] == True
-        assert a[4] == False
-        assert a[8] == False
-        with pytest.raises(IndexError):
-            _ = a[9]
-        assert a[-1] == False
-        assert a[-5] == False
-        assert a[-6] == True
-        assert a[-9] == True
-        with pytest.raises(IndexError):
-            _ = a[-10]
-
-    def test_simple_slicing(self):
-        a = Bits('0xabcdef')
-        assert a[0:4] == '0xf'
-        assert a[4:8] == '0xe'
-        assert a[:] == '0xabcdef'
-        assert a[4:] == '0xabcde'
-        assert a[-4:] == '0xa'
-        assert a[-8:-4] == '0xb'
-        assert a[:-8] == '0xcdef'
-
-    def test_extended_slicing(self):
-        a = Bits('0b100000100100100')
-        assert a[2::3] == '0b10111'
-
-    def test_all(self):
-        a = Bits('0b000111')
-        assert a.all(1, [0, 1, 2])
-        assert a.all(0, [3, 4, 5])
-
-    def test_any(self):
-        a = Bits('0b00000110')
-        assert a.any(1, [0, 1])
-        assert a.any(0, [5, 6])
-
-    def test_startswith(self):
-        a = Bits('0b0000000111')
-        assert a.startswith('0b111')
-        assert not a.startswith('0b0')
-        assert a.startswith('0b011', start=1)
-        assert not a.startswith('0b0111', end=3)
-        assert a.startswith('0b0111', end=4)
-
-    def test_ends_with(self):
-        a = Bits('0x1234abcd')
-        assert a.endswith('0x123')
-        assert not a.endswith('0xabcd')
-
-
-class TestLsb0Interpretations:
-
-    @classmethod
-    def setup_class(cls):
-        bitstring.lsb0 = True
-
-    @classmethod
-    def teardown_class(cls):
-        bitstring.lsb0 = False
-
-    def test_uint(self):
-        a = Bits('0x01')
-        assert a == '0b00000001'
-        assert a.uint == 1
-        assert a[0] == True
-
-    def test_float(self):
-        a = Bits(float=0.25, length=32)
-        try:
-            bitstring.lsb0 = False
-            b = Bits(float=0.25, length=32)
-        finally:
-            bitstring.lsb0 = True
-        assert a.float == 0.25
-        assert b.float == 0.25
-        assert a.bin == b.bin
-
-    def test_golomb(self):
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(ue=2)
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(se=2)
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(uie=2)
-        with pytest.raises(bitstring.CreationError):
-            _ = Bits(sie=2)
-
-    def test_bytes(self):
-        a = Bits.fromstring('0xabcdef')
-        b = a.bytes
-        assert b == b'\xab\xcd\xef'
-        b = a.bytes3
-        assert b == b'\xab\xcd\xef'
-
-
-class TestUnderscoresInLiterals:
-
-    def test_hex_creation(self):
-        a = Bits(hex='ab_cd__ef')
-        assert a.hex == 'abcdef'
-        b = Bits('0x0102_0304')
-        assert b.uint == 0x0102_0304
-
-    def test_binary_creation(self):
-        a = Bits(bin='0000_0001_0010')
-        assert a.bin == '000000010010'
-        b = Bits.fromstring('0b0011_1100_1111_0000')
-        assert b.bin == '0011110011110000'
-        v = 0b1010_0000
-        c = Bits(uint=0b1010_0000, length=8)
-        assert c.uint == v
-
-    def test_octal_creation(self):
-        a = Bits(oct='0011_2233_4455_6677')
-        assert a.uint == 0o001122334455_6677
-        b = Bits('0o123_321_123_321')
-        assert b.uint == 0o123_321_123321
-
-
-class TestPrettyPrinting:
-
-    def test_simplest_cases(self):
-        a = Bits('0b101011110000')
-        s = io.StringIO()
-        a.pp(stream=s)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin', length=12 bits> [
- 0: 10101111 0000    
-]
-"""
-
-        s = io.StringIO()
-        a.pp('hex', stream=s)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='hex', length=12 bits> [
- 0: af 0 
-]
-"""
-
-        s = io.StringIO()
-        a.pp('oct', stream=s)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='oct', length=12 bits> [
- 0: 5360
-]
-"""
-
-    def test_small_width(self):
-        a = Bits(20)
-        s = io.StringIO()
-        a.pp(fmt='b', stream=s, width=5)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin', length=20 bits> [
- 0: 00000000
- 8: 00000000
-16: 0000    
-]
-"""
-
-    def test_separator(self):
-        a = Bits('0x0f0f')*9
-        s = io.StringIO()
-        a.pp('hex:32', sep='!-!', stream=s)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='hex32', length=144 bits> [
-  0: 0f0f0f0f!-!0f0f0f0f!-!0f0f0f0f!-!0f0f0f0f
-] + trailing_bits = 0x0f0f
-"""
-
-    def test_multi_line(self):
-        a = Bits(100)
-        s = io.StringIO()
-        a.pp('bin', sep='', stream=s, width=80)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin', length=100 bits> [
-  0: 000000000000000000000000000000000000000000000000000000000000000000000000
- 72: 0000000000000000000000000000                                            
-]
-"""
-
-    def test_multiformat(self):
-        a = Bits('0b1111000011110000')
-        s = io.StringIO()
-        a.pp(stream=s, fmt='bin, hex')
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin, hex', length=16 bits> [
- 0: 11110000 11110000 : f0 f0
-]
-"""
-        s = io.StringIO()
-        a.pp(stream=s, fmt='hex, bin:12')
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='hex, bin12', length=16 bits> [
- 0: f0f : 111100001111
-] + trailing_bits = 0x0
-"""
-
-    def test_multi_line_multi_format(self):
-        a = Bits(int=-1, length=112)
-        s = io.StringIO()
-        a.pp(stream=s, fmt='bin:8, hex:8', width=42)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin8, hex8', length=112 bits> [
-  0: 11111111 11111111 11111111 : ff ff ff
- 24: 11111111 11111111 11111111 : ff ff ff
- 48: 11111111 11111111 11111111 : ff ff ff
- 72: 11111111 11111111 11111111 : ff ff ff
- 96: 11111111 11111111          : ff ff   
-]
-"""
-        s = io.StringIO()
-        a.pp(stream=s, fmt='bin, hex', width=41)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin, hex', length=112 bits> [
-  0: 11111111 11111111 : ff ff
- 16: 11111111 11111111 : ff ff
- 32: 11111111 11111111 : ff ff
- 48: 11111111 11111111 : ff ff
- 64: 11111111 11111111 : ff ff
- 80: 11111111 11111111 : ff ff
- 96: 11111111 11111111 : ff ff
-]
-"""
-
-        a = bytearray(range(0, 256))
-        b = Bits(bytes=a)
-        s = io.StringIO()
-        b.pp(stream=s, fmt='bytes')
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bytes', length=2048 bits> [
-   0:          !"# $%&' ()*+ ,-./ 0123 4567 89:; <=>? @ABC DEFG HIJK LMNO PQRS TUVW XYZ[
- 736: \]^_ `abc defg hijk lmno pqrs tuvw xyz{ |}~              
-1472:                                           
-]
-"""
-
-    def test_group_size_errors(self):
-        a = Bits(120)
-        with pytest.raises(ValueError):
-            a.pp('hex:3')
-        with pytest.raises(ValueError):
-            a.pp('hex:4, oct')
-
-    def test_zero_group_size(self):
-        a = Bits(600)
-        s = io.StringIO()
-        a.pp('b0', stream=s, show_offset=False)
-        expected_output = """<Bits, fmt='bin0', length=600 bits> [
-000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
-000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
-000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
-000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
-000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
-]
-"""
-        assert remove_unprintable(s.getvalue()) == expected_output
-
-        a = Bits(400)
-        s = io.StringIO()
-        a.pp(stream=s, fmt='hex:0', show_offset=False, width=80)
-        expected_output = """<Bits, fmt='hex0', length=400 bits> [
-00000000000000000000000000000000000000000000000000000000000000000000000000000000
-00000000000000000000                                                            
-]
-"""
-        assert remove_unprintable(s.getvalue()) == expected_output
-
-        s = io.StringIO()
-        a = Bits(uint=10, length=48)
-        a.pp(stream=s, width=20, fmt='hex:0, oct:0', show_offset=False)
-        expected_output = """<Bits, fmt='hex0, oct0', length=48 bits> [
-000000 : 00000000
-00000a : 00000012
-]
-"""
-        assert remove_unprintable(s.getvalue()) == expected_output
-
-    def test_oct(self):
-        a = Bits('0o01234567'*20)
-        s = io.StringIO()
-        a.pp(stream=s, fmt='o', show_offset=False, width=20)
-        expected_output = """<Bits, fmt='oct', length=480 bits> [
-0123 4567 0123 4567
-0123 4567 0123 4567
-0123 4567 0123 4567
-0123 4567 0123 4567
-0123 4567 0123 4567
-0123 4567 0123 4567
-0123 4567 0123 4567
-0123 4567 0123 4567
-0123 4567 0123 4567
-0123 4567 0123 4567
-]
-"""
-        assert remove_unprintable(s.getvalue()) == expected_output
-
-        t = io.StringIO()
-        a.pp('h, oct:0', width=1, show_offset=False, stream=t)
-        expected_output = """<Bits, fmt='hex, oct0', length=480 bits> [
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-053977 : 01234567
-]
-"""
-        assert remove_unprintable(t.getvalue()) == expected_output
-
-    def test_bytes(self):
-        a = Bits(bytes=b'helloworld!!'*5)
-        s = io.StringIO()
-        a.pp(stream=s, fmt='bytes', show_offset=False, width=48)
-        expected_output = (
-"""<Bits, fmt='bytes', length=480 bits> [
-hell owor ld!! hell owor ld!! hell owor ld!!
-hell owor ld!! hell owor ld!!               
-]
-""")
-        assert remove_unprintable(s.getvalue()) == expected_output
-        s = io.StringIO()
-        a.pp(stream=s, fmt='bytes0', show_offset=False, width=40)
-        expected_output = (
-"""<Bits, fmt='bytes0', length=480 bits> [
-helloworld!!helloworld!!helloworld!!hell
-oworld!!helloworld!!                    
-]
-"""
-        )
-        assert remove_unprintable(s.getvalue()) == expected_output
-
-    def test_bool(self):
-        a = Bits('0b1100')
-        s = io.StringIO()
-        a.pp(stream=s, fmt='bool', show_offset=False, width=20)
-        expected_output = """<Bits, fmt='bool', length=4 bits> [
-1 1 0 0
-]
-"""
-        assert remove_unprintable(s.getvalue()) == expected_output
-
-
-class TestPrettyPrintingErrors:
-
-    def test_wrong_formats(self):
-        a = Bits('0x12341234')
-        with pytest.raises(ValueError):
-            a.pp('binary')
-        with pytest.raises(ValueError):
-            a.pp('bin, bin, bin')
-
-    def test_interpret_problems(self):
-        a = Bits(7)
-        with pytest.raises(InterpretError):
-            a.pp('oct')
-        with pytest.raises(InterpretError):
-            a.pp('hex')
-        with pytest.raises(InterpretError):
-            a.pp('bin, bytes')
-
-
-class TestPrettyPrinting_LSB0:
-
-    def setup_method(self) -> None:
-        bitstring.lsb0 = True
-
-    def teardown_method(self) -> None:
-        bitstring.lsb0 = False
-
-    def test_bin(self):
-        a = Bits(bin='1111 0000 0000 1111 1010')
-        s = io.StringIO()
-        a.pp('bin', stream=s, width=5)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin', length=20 bits> [
-11111010 :0 
-00000000 :8 
-    1111 :16
-]
-"""
-
-class TestPrettyPrinting_NewFormats:
-
-    def test_float(self):
-        a = Bits('float32=10.5')
-        s = io.StringIO()
-        a.pp('float32', stream=s)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='float32', length=32 bits> [
- 0:                    10.5
-]
-"""
-        s = io.StringIO()
-        a.pp('float16', stream=s)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='float16', length=32 bits> [
- 0:                2.578125                     0.0
-]
-"""
-
-    def test_uint(self):
-        a = Bits().join([Bits(uint=x, length=12) for x in range(40, 105)])
-        s = io.StringIO()
-        a.pp('uint, h12', stream=s)
-        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='uint, hex12', length=780 bits> [
-  0:   40   41   42   43   44   45   46   47   48   49   50   51 : 028 029 02a 02b 02c 02d 02e 02f 030 031 032 033
-144:   52   53   54   55   56   57   58   59   60   61   62   63 : 034 035 036 037 038 039 03a 03b 03c 03d 03e 03f
-288:   64   65   66   67   68   69   70   71   72   73   74   75 : 040 041 042 043 044 045 046 047 048 049 04a 04b
-432:   76   77   78   79   80   81   82   83   84   85   86   87 : 04c 04d 04e 04f 050 051 052 053 054 055 056 057
-576:   88   89   90   91   92   93   94   95   96   97   98   99 : 058 059 05a 05b 05c 05d 05e 05f 060 061 062 063
-720:  100  101  102  103  104                                    : 064 065 066 067 068                            
-]
-"""
-
-    def test_float(self):
-        a = BitArray(float=76.25, length=64) + '0b11111'
-        s = io.StringIO()
-        a.pp('i64, float', stream=s)
-        assert remove_unprintable(s.getvalue()) == """<BitArray, fmt='int64, float', length=69 bits> [
- 0:  4635066033680416768 :                    76.25
-] + trailing_bits = 0b11111
-"""
-
-class TestCopy:
-
-    def test_copy_method(self):
-        s = Bits('0xc00dee')
-        t = s.copy()
-        assert s == t
-
-
-class TestNativeEndianIntegers:
-
-    def test_uintne(self):
-        s = Bits(uintne=454, length=160)
-        t = Bits('uintne160=454')
-        assert s == t
-
-    def test_intne(self):
-        s = Bits(intne=-1000, length=64)
-        t = Bits('intne:64=-1000')
-        assert s == t
-
-
-class TestNonNativeEndianIntegers:
-
-    def setup_method(self) -> None:
-        bitstring.byteorder = 'little' if bitstring.byteorder == 'big' else 'little'
-
-    def teardown_method(self) -> None:
-        self.setup_method()
-
-    def test_uintne(self):
-        s = Bits(uintne=454, length=160)
-        t = Bits('uintne160=454')
-        assert s == t
-
-    def test_intne(self):
-        s = Bits(intne=-1000, length=64)
-        t = Bits('intne:64=-1000')
-        assert s == t
+#!/usr/bin/env python
+import pytest
+import io
+import sys
+import bitarray
+import bitstring
+import array
+import os
+import re
+from bitstring import InterpretError, Bits, BitArray
+from hypothesis import given, assume
+import hypothesis.strategies as st
+
+
+sys.path.insert(0, '..')
+
+THIS_DIR = os.path.dirname(os.path.abspath(__file__))
+
+def remove_unprintable(s: str) -> str:
+    colour_escape = re.compile(r'(?:\x1B[@-_])[0-?]*[ -/]*[@-~]')
+    return colour_escape.sub('', s)
+
+class TestCreation:
+    def test_creation_from_bytes(self):
+        s = Bits(bytes=b'\xa0\xff')
+        assert (s.len, s.hex) == (16, 'a0ff')
+        s = Bits(bytes=b'abc', length=0)
+        assert s == ''
+
+    @given(st.binary())
+    def test_creation_from_bytes_roundtrip(self, data):
+        s = Bits(bytes=data)
+        assert s.bytes == data
+
+    def test_creation_from_bytes_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            Bits(bytes=b'abc', length=25)
+
+    def test_creation_from_data_with_offset(self):
+        s1 = Bits(bytes=b'\x0b\x1c\x2f', offset=0, length=20)
+        s2 = Bits(bytes=b'\xa0\xb1\xC2', offset=4)
+        assert (s2.len, s2.hex) == (20, '0b1c2')
+        assert (s1.len, s1.hex) == (20, '0b1c2')
+        assert s1 == s2
+
+    def test_creation_from_hex(self):
+        s = Bits(hex='0xA0ff')
+        assert (s.len, s.hex) == (16, 'a0ff')
+        s = Bits(hex='0x0x0X')
+        assert (s.length, s.hex) == (0, '')
+
+    def test_creation_from_hex_with_whitespace(self):
+        s = Bits(hex='  \n0 X a  4e       \r3  \n')
+        assert s.hex == 'a4e3'
+
+    def test_creation_from_hex_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            Bits(hex='0xx0')
+        with pytest.raises(bitstring.CreationError):
+            Bits(hex='0xX0')
+        with pytest.raises(bitstring.CreationError):
+            Bits(hex='0Xx0')
+        with pytest.raises(bitstring.CreationError):
+            Bits(hex='-2e')
+        with pytest.raises(bitstring.CreationError):
+            Bits('0x2', length=2)
+        with pytest.raises(bitstring.CreationError):
+            Bits('0x3', offset=1)
+
+    def test_creation_from_bin(self):
+        s = Bits(bin='1010000011111111')
+        assert (s.length, s.hex) == (16, 'a0ff')
+        s = Bits(bin='00')[:1]
+        assert s.bin == '0'
+        s = Bits(bin=' 0000 \n 0001\r ')
+        assert s.bin == '00000001'
+
+    def test_creation_from_bin_with_whitespace(self):
+        s = Bits(bin='  \r\r\n0   B    00   1 1 \t0 ')
+        assert s.bin == '00110'
+
+    def test_creation_from_oct_errors(self):
+        s = Bits('0b00011')
+        with pytest.raises(bitstring.InterpretError):
+            _ = s.oct
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits('oct=8')
+
+    def test_creation_from_uint_with_offset(self):
+        with pytest.raises(bitstring.CreationError):
+            Bits(uint=12, length=8, offset=1)
+
+    def test_creation_from_uint_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            Bits(uint=-1, length=10)
+        with pytest.raises(bitstring.CreationError):
+            Bits(uint=12)
+        with pytest.raises(bitstring.CreationError):
+            Bits(uint=4, length=2)
+        with pytest.raises(bitstring.CreationError):
+            Bits(uint=0, length=0)
+        with pytest.raises(bitstring.CreationError):
+            Bits(uint=12, length=-12)
+
+    def test_creation_from_int(self):
+        s = Bits(int=0, length=4)
+        temp = s.hex
+        assert s.bin == '0000'
+        s = Bits(int=1, length=2)
+        assert s.bin == '01'
+        s = Bits(int=-1, length=11)
+        assert s.bin == '11111111111'
+        s = Bits(int=12, length=7)
+        assert s.int == 12
+        s = Bits(int=-243, length=108)
+        assert (s.int, s.length) == (-243, 108)
+        for length in range(6, 10):
+            for value in range(-17, 17):
+                s = Bits(int=value, length=length)
+                assert (s.int, s.length) == (value, length)
+        _ = Bits(int=10, length=8)
+
+    def test_creation_from_int_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(int=-1, length=0)
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(int=12)
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(int=4, length=3)
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(int=-5, length=3)
+
+    def test_creation_from_se(self):
+        for i in range(-100, 10):
+            s = Bits(se=i)
+            assert s.se == i
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(se=10, length=40)
+
+    def test_creation_from_se_with_offset(self):
+        with pytest.raises(bitstring.CreationError):
+            Bits(se=-13, offset=1)
+
+    def test_creation_from_se_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            Bits(se=-5, length=33)
+        with pytest.raises(bitstring.CreationError):
+            Bits('se2=0')
+        s = Bits(bin='001000')
+        with pytest.raises(bitstring.InterpretError):
+            _ = s.se
+
+    def test_creation_from_ue(self):
+        for i in range(0, 20):
+            assert Bits(ue=i).ue == i
+
+    def test_creation_from_ue_with_offset(self):
+        with pytest.raises(bitstring.CreationError):
+            Bits(ue=104, offset=2)
+
+    def test_creation_from_ue_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            Bits(ue=-1)
+        with pytest.raises(bitstring.CreationError):
+            Bits(ue=1, length=12)
+        s = Bits(bin='10')
+        with pytest.raises(bitstring.InterpretError):
+            _ = s.ue
+
+    def test_creation_from_bool(self):
+        a = Bits('bool=1')
+        assert a == 'bool=1'
+        b = Bits('bool:1=0')
+        assert b == [0]
+        c = bitstring.pack('bool=1, 2*bool', 0, 1)
+        assert c == '0b101'
+        d = bitstring.pack('bool:1=1, 2*bool1', 1, 0)
+        assert d == '0b110'
+
+    def test_creation_from_bool_errors(self):
+        with pytest.raises(ValueError):
+            _ = Bits('bool=3')
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(bool=0, length=2)
+
+    def test_creation_keyword_error(self):
+        with pytest.raises(bitstring.CreationError):
+            Bits(squirrel=5)
+
+    def test_creation_from_bitarray(self):
+        ba = bitarray.bitarray('0010')
+        bs = Bits(ba)
+        assert bs.bin == '0010'
+        bs2 = Bits(bitarray=ba)
+        assert bs2.bin == '0010'
+
+    def test_creation_from_frozen_bitarray(self):
+        fba = bitarray.frozenbitarray('111100001')
+        ba = Bits(fba)
+        assert ba.bin == '111100001'
+        bs2 = Bits(bitarray=fba)
+        assert bs2.bin == '111100001'
+        bs3 = Bits(bitarray=fba, offset=4)
+        assert bs3.bin == '00001'
+        bs3 = Bits(bitarray=fba, offset=4, length=4)
+        assert bs3.bin == '0000'
+
+    def test_creation_from_bitarray_errors(self):
+        ba = bitarray.bitarray('0101')
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(bitarray=ba, length=5)
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(bitarray=ba, offset=5)
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(ba, length=-1)
+
+    def test_creation_from_memoryview(self):
+        x = bytes(bytearray(range(20)))
+        m = memoryview(x[10:15])
+        b = Bits(m)
+        assert b.unpack('5*u8') == [10, 11, 12, 13, 14]
+
+
+class TestInitialisation:
+    def test_empty_init(self):
+        a = Bits()
+        assert a == ''
+
+    def test_no_pos(self):
+        a = Bits('0xabcdef')
+        with pytest.raises(AttributeError):
+            _ = a.pos
+
+    def test_find(self):
+        a = Bits('0xabcd')
+        r = a.find('0xbc')
+        assert r[0] == 4
+        r = a.find('0x23462346246', bytealigned=True)
+        assert not r
+
+    def test_rfind(self):
+        a = Bits('0b11101010010010')
+        b = a.rfind('0b010')
+        assert b[0] == 11
+
+    def test_find_all(self):
+        a = Bits('0b0010011')
+        b = list(a.findall([1]))
+        assert b == [2, 5, 6]
+        t = BitArray('0b10')
+        tp = list(t.findall('0b1'))
+        assert tp == [0]
+
+
+class TestCut:
+    def test_cut(self):
+        s = Bits('0b000111'*10)
+        for t in s.cut(6):
+            assert t.bin == '000111'
+
+
+class TestInterleavedExpGolomb:
+    def test_creation(self):
+        s1 = Bits(uie=0)
+        s2 = Bits(uie=1)
+        assert s1 == [1]
+        assert s2 == [0, 0, 1]
+        s1 = Bits(sie=0)
+        s2 = Bits(sie=-1)
+        s3 = Bits(sie=1)
+        assert s1 == [1]
+        assert s2 == [0, 0, 1, 1]
+        assert s3 == [0, 0, 1, 0]
+
+    def test_creation_from_property(self):
+        s = BitArray()
+        s.uie = 45
+        assert s.uie == 45
+        s.sie = -45
+        assert s.sie == -45
+
+    def test_interpretation(self):
+        for x in range(101):
+            assert Bits(uie=x).uie == x
+        for x in range(-100, 100):
+            assert Bits(sie=x).sie == x
+
+    def test_errors(self):
+        for f in ['sie=100, 0b1001', '0b00', 'uie=100, 0b1001']:
+            s = Bits.fromstring(f)
+            with pytest.raises(bitstring.InterpretError):
+                _ = s.sie
+            with pytest.raises(bitstring.InterpretError):
+                _ = s.uie
+        with pytest.raises(ValueError):
+            Bits(uie=-10)
+
+
+class TestFileBased:
+    def setup_method(self):
+        filename = os.path.join(THIS_DIR, 'smalltestfile')
+        self.a = Bits(filename=filename)
+        self.b = Bits(filename=filename, offset=16)
+        self.c = Bits(filename=filename, offset=20, length=16)
+        self.d = Bits(filename=filename, offset=20, length=4)
+
+    def test_creation_with_offset(self):
+        assert str(self.a) == '0x0123456789abcdef'
+        assert str(self.b) == '0x456789abcdef'
+        assert str(self.c) == '0x5678'
+
+    def test_bit_operators(self):
+        x = self.b[4:20]
+        assert x == '0x5678'
+        assert (x & self.c).hex == self.c.hex
+        assert self.c ^ self.b[4:20] == Bits(16)
+        assert self.a[23:36] | self.c[3:] == self.c[3:]
+        y = x & self.b[4:20]
+        assert y == self.c
+        assert repr(y) == repr(self.c)
+
+    def test_addition(self):
+        _ = self.d + '0x1'
+        x = self.a[20:24] + self.c[-4:] + self.c[8:12]
+        assert x == '0x587'
+        x = self.b + x
+        assert x.h == '456789abcdef587'
+        x = BitArray(x)
+        del x[12:24]
+        assert x == '0x456abcdef587'
+
+
+class TestComparisons:
+    def test_unorderable(self):
+        a = Bits(5)
+        b = Bits(5)
+        with pytest.raises(TypeError):
+            _ = a < b
+        with pytest.raises(TypeError):
+            _ = a > b
+        with pytest.raises(TypeError):
+            _ = a <= b
+        with pytest.raises(TypeError):
+            _ = a >= b
+
+
+class TestSubclassing:
+
+    def test_is_instance(self):
+        class SubBits(bitstring.Bits):
+            pass
+        a = SubBits()
+        assert isinstance(a, SubBits)
+
+    def test_class_type(self):
+        class SubBits(bitstring.Bits):
+            pass
+        assert SubBits().__class__ == SubBits
+
+
+class TestLongBoolConversion:
+
+    def test_long_bool(self):
+        a = Bits(1000)
+        b = bool(a)
+        assert b is True
+
+
+class TestPadToken:
+
+    def test_creation(self):
+        a = Bits.fromstring('pad:10')
+        assert a == Bits(10)
+        b = Bits('pad:0')
+        assert b == Bits()
+        c = Bits('0b11, pad:1, 0b111')
+        assert c == Bits('0b110111')
+
+    def test_pack(self):
+        s = bitstring.pack('0b11, pad:3, 0b1')
+        assert s.bin == '110001'
+        d = bitstring.pack('pad:c', c=12)
+        assert d == Bits(12)
+        e = bitstring.pack('0xf, uint12, pad:1, bin, pad4, 0b10', 0, '111')
+        assert e.bin == '11110000000000000111000010'
+
+    def test_unpack(self):
+        s = Bits('0b111000111')
+        x, y = s.unpack('3, pad:3, 3')
+        assert (x, y.u) == ('0b111', 7)
+        x, y = s.unpack('2, pad2, bin')
+        assert (x.u2, y) == (3, '00111')
+        x = s.unpack('pad:1, pad:2, pad:3')
+        assert x == []
+
+    def test_unpack_bug(self):
+        t = Bits('0o755, ue=12, int3=-1')
+        a, b = t.unpack('pad:9, ue, int3')
+        assert (a, b) == (12, -1)
+
+
+class TestModifiedByAddingBug:
+
+    def test_adding(self):
+        a = Bits('0b0')
+        b = Bits('0b11')
+        c = a + b
+        assert c == '0b011'
+        assert a == '0b0'
+        assert b == '0b11'
+
+    def test_adding2(self):
+        a = Bits(100)
+        b = Bits(101)
+        c = a + b
+        assert a == Bits(100)
+        assert b == Bits(101)
+        assert c == Bits(201)
+
+
+class TestWrongTypeBug:
+
+    def test_append_to_bits(self):
+        a = Bits(BitArray())
+        with pytest.raises(AttributeError):
+            a.append('0b1')
+        assert type(a) == Bits
+        b = bitstring.ConstBitStream(bitstring.BitStream())
+        assert type(b) == bitstring.ConstBitStream
+
+
+class TestInitFromArray:
+
+    @given(st.sampled_from(['B', 'H', 'I', 'L', 'Q', 'f', 'd']))
+    def test_empty_array(self, t):
+        a = array.array(t)
+        b = Bits(a)
+        assert b.length == 0
+
+    def test_single_byte(self):
+        a = array.array('B', b'\xff')
+        b = Bits(a)
+        assert b.length == 8
+        assert b.hex == 'ff'
+
+    def test_signed_short(self):
+        a = array.array('h')
+        a.append(10)
+        a.append(-1)
+        b = Bits(a)
+        assert b.length == 32
+        assert b.bytes == a.tobytes()
+
+    def test_double(self):
+        a = array.array('d', [0.0, 1.0, 2.5])
+        b = Bits(a)
+        assert b.length == 192
+        c, d, e = b.unpack('3*floatne:64')
+        assert (c, d, e) == (0.0, 1.0, 2.5)
+
+
+class TestIteration:
+
+    def test_iterate_empty_bits(self):
+        assert list(Bits([])) == []
+        assert list(Bits([1, 0])[1:1]) == []
+
+    def test_iterate_non_empty_bits(self):
+        assert list(Bits([1, 0])) == [True, False]
+        assert list(Bits([1, 0, 0, 1])[1:3]) == [False, False]
+
+    def test_iterate_long_bits(self):
+        assert list(Bits([1, 0]) * 1024) == \
+            [True, False] * 1024
+
+        
+class TestContainsBug:
+
+    def test_contains(self):
+        a = Bits('0b1, 0x0001dead0001')
+        assert '0xdead' in a
+        assert not '0xfeed' in a
+
+        assert '0b1' in Bits('0xf')
+        assert not '0b0' in Bits('0xf')
+
+
+class TestByteStoreImmutablity:
+
+    def test_immutability_bug_append(self):
+        a = Bits('0b111')
+        b = a + '0b000'
+        c = BitArray(b)
+        c[1] = 0
+        assert c.bin == '101000'
+        assert a.b3 == '111'
+        assert b.bin == '111000'
+
+    def test_immutability_bug_prepend(self):
+        a = Bits('0b111')
+        b = '0b000' + a
+        c = BitArray(b)
+        c[1] = 1
+        assert b.bin == '000111'
+        assert c.bin == '010111'
+
+
+class TestLsb0Indexing:
+
+    @classmethod
+    def setup_class(cls):
+        bitstring.lsb0 = True
+
+    @classmethod
+    def teardown_class(cls):
+        bitstring.lsb0 = False
+
+    def test_get_single_bit(self):
+        a = Bits('0b000001111')
+        assert a[0] == True
+        assert a[3] == True
+        assert a[4] == False
+        assert a[8] == False
+        with pytest.raises(IndexError):
+            _ = a[9]
+        assert a[-1] == False
+        assert a[-5] == False
+        assert a[-6] == True
+        assert a[-9] == True
+        with pytest.raises(IndexError):
+            _ = a[-10]
+
+    def test_simple_slicing(self):
+        a = Bits('0xabcdef')
+        assert a[0:4] == '0xf'
+        assert a[4:8] == '0xe'
+        assert a[:] == '0xabcdef'
+        assert a[4:] == '0xabcde'
+        assert a[-4:] == '0xa'
+        assert a[-8:-4] == '0xb'
+        assert a[:-8] == '0xcdef'
+
+    def test_extended_slicing(self):
+        a = Bits('0b100000100100100')
+        assert a[2::3] == '0b10111'
+
+    def test_all(self):
+        a = Bits('0b000111')
+        assert a.all(1, [0, 1, 2])
+        assert a.all(0, [3, 4, 5])
+
+    def test_any(self):
+        a = Bits('0b00000110')
+        assert a.any(1, [0, 1])
+        assert a.any(0, [5, 6])
+
+    def test_startswith(self):
+        a = Bits('0b0000000111')
+        assert a.startswith('0b111')
+        assert not a.startswith('0b0')
+        assert a.startswith('0b011', start=1)
+        assert not a.startswith('0b0111', end=3)
+        assert a.startswith('0b0111', end=4)
+
+    def test_ends_with(self):
+        a = Bits('0x1234abcd')
+        assert a.endswith('0x123')
+        assert not a.endswith('0xabcd')
+
+
+class TestLsb0Interpretations:
+
+    @classmethod
+    def setup_class(cls):
+        bitstring.lsb0 = True
+
+    @classmethod
+    def teardown_class(cls):
+        bitstring.lsb0 = False
+
+    def test_uint(self):
+        a = Bits('0x01')
+        assert a == '0b00000001'
+        assert a.uint == 1
+        assert a[0] == True
+
+    def test_float(self):
+        a = Bits(float=0.25, length=32)
+        try:
+            bitstring.lsb0 = False
+            b = Bits(float=0.25, length=32)
+        finally:
+            bitstring.lsb0 = True
+        assert a.float == 0.25
+        assert b.float == 0.25
+        assert a.bin == b.bin
+
+    def test_golomb(self):
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(ue=2)
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(se=2)
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(uie=2)
+        with pytest.raises(bitstring.CreationError):
+            _ = Bits(sie=2)
+
+    def test_bytes(self):
+        a = Bits.fromstring('0xabcdef')
+        b = a.bytes
+        assert b == b'\xab\xcd\xef'
+        b = a.bytes3
+        assert b == b'\xab\xcd\xef'
+
+
+class TestUnderscoresInLiterals:
+
+    def test_hex_creation(self):
+        a = Bits(hex='ab_cd__ef')
+        assert a.hex == 'abcdef'
+        b = Bits('0x0102_0304')
+        assert b.uint == 0x0102_0304
+
+    def test_binary_creation(self):
+        a = Bits(bin='0000_0001_0010')
+        assert a.bin == '000000010010'
+        b = Bits.fromstring('0b0011_1100_1111_0000')
+        assert b.bin == '0011110011110000'
+        v = 0b1010_0000
+        c = Bits(uint=0b1010_0000, length=8)
+        assert c.uint == v
+
+    def test_octal_creation(self):
+        a = Bits(oct='0011_2233_4455_6677')
+        assert a.uint == 0o001122334455_6677
+        b = Bits('0o123_321_123_321')
+        assert b.uint == 0o123_321_123321
+
+
+class TestPrettyPrinting:
+
+    def test_simplest_cases(self):
+        a = Bits('0b101011110000')
+        s = io.StringIO()
+        a.pp(stream=s)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin', length=12 bits> [
+ 0: 10101111 0000    
+]
+"""
+
+        s = io.StringIO()
+        a.pp('hex', stream=s)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='hex', length=12 bits> [
+ 0: af 0 
+]
+"""
+
+        s = io.StringIO()
+        a.pp('oct', stream=s)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='oct', length=12 bits> [
+ 0: 5360
+]
+"""
+
+    def test_small_width(self):
+        a = Bits(20)
+        s = io.StringIO()
+        a.pp(fmt='b', stream=s, width=5)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin', length=20 bits> [
+ 0: 00000000
+ 8: 00000000
+16: 0000    
+]
+"""
+
+    def test_separator(self):
+        a = Bits('0x0f0f')*9
+        s = io.StringIO()
+        a.pp('hex:32', sep='!-!', stream=s)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='hex32', length=144 bits> [
+  0: 0f0f0f0f!-!0f0f0f0f!-!0f0f0f0f!-!0f0f0f0f
+] + trailing_bits = 0x0f0f
+"""
+
+    def test_multi_line(self):
+        a = Bits(100)
+        s = io.StringIO()
+        a.pp('bin', sep='', stream=s, width=80)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin', length=100 bits> [
+  0: 000000000000000000000000000000000000000000000000000000000000000000000000
+ 72: 0000000000000000000000000000                                            
+]
+"""
+
+    def test_multiformat(self):
+        a = Bits('0b1111000011110000')
+        s = io.StringIO()
+        a.pp(stream=s, fmt='bin, hex')
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin, hex', length=16 bits> [
+ 0: 11110000 11110000 : f0 f0
+]
+"""
+        s = io.StringIO()
+        a.pp(stream=s, fmt='hex, bin:12')
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='hex, bin12', length=16 bits> [
+ 0: f0f : 111100001111
+] + trailing_bits = 0x0
+"""
+
+    def test_multi_line_multi_format(self):
+        a = Bits(int=-1, length=112)
+        s = io.StringIO()
+        a.pp(stream=s, fmt='bin:8, hex:8', width=42)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin8, hex8', length=112 bits> [
+  0: 11111111 11111111 11111111 : ff ff ff
+ 24: 11111111 11111111 11111111 : ff ff ff
+ 48: 11111111 11111111 11111111 : ff ff ff
+ 72: 11111111 11111111 11111111 : ff ff ff
+ 96: 11111111 11111111          : ff ff   
+]
+"""
+        s = io.StringIO()
+        a.pp(stream=s, fmt='bin, hex', width=41)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin, hex', length=112 bits> [
+  0: 11111111 11111111 : ff ff
+ 16: 11111111 11111111 : ff ff
+ 32: 11111111 11111111 : ff ff
+ 48: 11111111 11111111 : ff ff
+ 64: 11111111 11111111 : ff ff
+ 80: 11111111 11111111 : ff ff
+ 96: 11111111 11111111 : ff ff
+]
+"""
+
+        a = bytearray(range(0, 256))
+        b = Bits(bytes=a)
+        s = io.StringIO()
+        b.pp(stream=s, fmt='bytes')
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bytes', length=2048 bits> [
+   0:          !"# $%&' ()*+ ,-./ 0123 4567 89:; <=>? @ABC DEFG HIJK LMNO PQRS TUVW XYZ[
+ 736: \]^_ `abc defg hijk lmno pqrs tuvw xyz{ |}~              
+1472:                                           
+]
+"""
+
+    def test_group_size_errors(self):
+        a = Bits(120)
+        with pytest.raises(ValueError):
+            a.pp('hex:3')
+        with pytest.raises(ValueError):
+            a.pp('hex:4, oct')
+
+    def test_zero_group_size(self):
+        a = Bits(600)
+        s = io.StringIO()
+        a.pp('b0', stream=s, show_offset=False)
+        expected_output = """<Bits, fmt='bin0', length=600 bits> [
+000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
+000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
+000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
+000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
+000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
+]
+"""
+        assert remove_unprintable(s.getvalue()) == expected_output
+
+        a = Bits(400)
+        s = io.StringIO()
+        a.pp(stream=s, fmt='hex:0', show_offset=False, width=80)
+        expected_output = """<Bits, fmt='hex0', length=400 bits> [
+00000000000000000000000000000000000000000000000000000000000000000000000000000000
+00000000000000000000                                                            
+]
+"""
+        assert remove_unprintable(s.getvalue()) == expected_output
+
+        s = io.StringIO()
+        a = Bits(uint=10, length=48)
+        a.pp(stream=s, width=20, fmt='hex:0, oct:0', show_offset=False)
+        expected_output = """<Bits, fmt='hex0, oct0', length=48 bits> [
+000000 : 00000000
+00000a : 00000012
+]
+"""
+        assert remove_unprintable(s.getvalue()) == expected_output
+
+    def test_oct(self):
+        a = Bits('0o01234567'*20)
+        s = io.StringIO()
+        a.pp(stream=s, fmt='o', show_offset=False, width=20)
+        expected_output = """<Bits, fmt='oct', length=480 bits> [
+0123 4567 0123 4567
+0123 4567 0123 4567
+0123 4567 0123 4567
+0123 4567 0123 4567
+0123 4567 0123 4567
+0123 4567 0123 4567
+0123 4567 0123 4567
+0123 4567 0123 4567
+0123 4567 0123 4567
+0123 4567 0123 4567
+]
+"""
+        assert remove_unprintable(s.getvalue()) == expected_output
+
+        t = io.StringIO()
+        a.pp('h, oct:0', width=1, show_offset=False, stream=t)
+        expected_output = """<Bits, fmt='hex, oct0', length=480 bits> [
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+053977 : 01234567
+]
+"""
+        assert remove_unprintable(t.getvalue()) == expected_output
+
+    def test_bytes(self):
+        a = Bits(bytes=b'helloworld!!'*5)
+        s = io.StringIO()
+        a.pp(stream=s, fmt='bytes', show_offset=False, width=48)
+        expected_output = (
+"""<Bits, fmt='bytes', length=480 bits> [
+hell owor ld!! hell owor ld!! hell owor ld!!
+hell owor ld!! hell owor ld!!               
+]
+""")
+        assert remove_unprintable(s.getvalue()) == expected_output
+        s = io.StringIO()
+        a.pp(stream=s, fmt='bytes0', show_offset=False, width=40)
+        expected_output = (
+"""<Bits, fmt='bytes0', length=480 bits> [
+helloworld!!helloworld!!helloworld!!hell
+oworld!!helloworld!!                    
+]
+"""
+        )
+        assert remove_unprintable(s.getvalue()) == expected_output
+
+    def test_bool(self):
+        a = Bits('0b1100')
+        s = io.StringIO()
+        a.pp(stream=s, fmt='bool', show_offset=False, width=20)
+        expected_output = """<Bits, fmt='bool', length=4 bits> [
+1 1 0 0
+]
+"""
+        assert remove_unprintable(s.getvalue()) == expected_output
+
+
+class TestPrettyPrintingErrors:
+
+    def test_wrong_formats(self):
+        a = Bits('0x12341234')
+        with pytest.raises(ValueError):
+            a.pp('binary')
+        with pytest.raises(ValueError):
+            a.pp('bin, bin, bin')
+
+    def test_interpret_problems(self):
+        a = Bits(7)
+        with pytest.raises(InterpretError):
+            a.pp('oct')
+        with pytest.raises(InterpretError):
+            a.pp('hex')
+        with pytest.raises(InterpretError):
+            a.pp('bin, bytes')
+
+
+class TestPrettyPrinting_LSB0:
+
+    def setup_method(self) -> None:
+        bitstring.lsb0 = True
+
+    def teardown_method(self) -> None:
+        bitstring.lsb0 = False
+
+    def test_bin(self):
+        a = Bits(bin='1111 0000 0000 1111 1010')
+        s = io.StringIO()
+        a.pp('bin', stream=s, width=5)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='bin', length=20 bits> [
+11111010 :0 
+00000000 :8 
+    1111 :16
+]
+"""
+
+class TestPrettyPrinting_NewFormats:
+
+    def test_float(self):
+        a = Bits('float32=10.5')
+        s = io.StringIO()
+        a.pp('float32', stream=s)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='float32', length=32 bits> [
+ 0:                    10.5
+]
+"""
+        s = io.StringIO()
+        a.pp('float16', stream=s)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='float16', length=32 bits> [
+ 0:                2.578125                     0.0
+]
+"""
+
+    def test_uint(self):
+        a = Bits().join([Bits(uint=x, length=12) for x in range(40, 105)])
+        s = io.StringIO()
+        a.pp('uint, h12', stream=s)
+        assert remove_unprintable(s.getvalue()) == """<Bits, fmt='uint, hex12', length=780 bits> [
+  0:   40   41   42   43   44   45   46   47   48   49   50   51 : 028 029 02a 02b 02c 02d 02e 02f 030 031 032 033
+144:   52   53   54   55   56   57   58   59   60   61   62   63 : 034 035 036 037 038 039 03a 03b 03c 03d 03e 03f
+288:   64   65   66   67   68   69   70   71   72   73   74   75 : 040 041 042 043 044 045 046 047 048 049 04a 04b
+432:   76   77   78   79   80   81   82   83   84   85   86   87 : 04c 04d 04e 04f 050 051 052 053 054 055 056 057
+576:   88   89   90   91   92   93   94   95   96   97   98   99 : 058 059 05a 05b 05c 05d 05e 05f 060 061 062 063
+720:  100  101  102  103  104                                    : 064 065 066 067 068                            
+]
+"""
+
+    def test_float(self):
+        a = BitArray(float=76.25, length=64) + '0b11111'
+        s = io.StringIO()
+        a.pp('i64, float', stream=s)
+        assert remove_unprintable(s.getvalue()) == """<BitArray, fmt='int64, float', length=69 bits> [
+ 0:  4635066033680416768 :                    76.25
+] + trailing_bits = 0b11111
+"""
+
+class TestCopy:
+
+    def test_copy_method(self):
+        s = Bits('0xc00dee')
+        t = s.copy()
+        assert s == t
+
+
+class TestNativeEndianIntegers:
+
+    def test_uintne(self):
+        s = Bits(uintne=454, length=160)
+        t = Bits('uintne160=454')
+        assert s == t
+
+    def test_intne(self):
+        s = Bits(intne=-1000, length=64)
+        t = Bits('intne:64=-1000')
+        assert s == t
+
+
+class TestNonNativeEndianIntegers:
+
+    def setup_method(self) -> None:
+        bitstring.byteorder = 'little' if bitstring.byteorder == 'big' else 'little'
+
+    def teardown_method(self) -> None:
+        self.setup_method()
+
+    def test_uintne(self):
+        s = Bits(uintne=454, length=160)
+        t = Bits('uintne160=454')
+        assert s == t
+
+    def test_intne(self):
+        s = Bits(intne=-1000, length=64)
+        t = Bits('intne:64=-1000')
+        assert s == t
```

### Comparing `bitstring-4.2.1/tests/test_bitstore.py` & `bitstring-4.2.2/tests/test_bitstore.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,94 +1,94 @@
-#!/usr/bin/env python
-
-import pytest
-import sys
-sys.path.insert(0, '..')
-import bitstring
-from bitstring.bitstore import BitStore, offset_slice_indices_lsb0
-import sys
-
-sys.path.insert(0, '..')
-
-
-class TestBasicFunctionality:
-
-    def test_getting_int(self):
-        a = BitStore('001')
-        assert a.getindex(0) == 0
-        assert a.getindex(1) == 0
-        assert a.getindex(2) == 1
-
-        assert a.getindex(-1) == 1
-        assert a.getindex(-2) == 0
-        assert a.getindex(-3) == 0
-
-        with pytest.raises(IndexError):
-            _ = a.getindex(3)
-        with pytest.raises(IndexError):
-            _ = a.getindex(-4)
-
-
-class TestBasicLSB0Functionality:
-
-    @classmethod
-    def setup_class(cls):
-        bitstring.lsb0 = True
-
-    @classmethod
-    def teardown_class(cls):
-        bitstring.lsb0 = False
-
-    def test_getting_int(self):
-        a = BitStore('001')
-        assert a.getindex(0) == 1
-        assert a.getindex(1) == 0
-        assert a.getindex(2) == 0
-
-        assert a.getindex(-1) == 0
-        assert a.getindex(-2) == 0
-        assert a.getindex(-3) == 1
-
-        with pytest.raises(IndexError):
-            _ = a.getindex(3)
-        with pytest.raises(IndexError):
-            _ = a.getindex(-4)
-
-    def test_getting_slice(self):
-        a = BitStore.frombytes(b'12345678')
-        assert a.getslice(None, None).tobytes() == b'12345678'
-        assert a.getslice(None, -8).tobytes() == b'2345678'
-        assert a.getslice(8, None).tobytes() == b'1234567'
-        assert a.getslice(16, 24).tobytes() == b'6'
-
-    def test_setting_int(self):
-        a = BitStore('00000')
-        a[0] = 1
-        assert a.slice_to_bin() == '00001'
-        a[-1] = 1
-        assert a.slice_to_bin() == '10001'
-        with pytest.raises(IndexError):
-            a[5] = 1
-        with pytest.raises(IndexError):
-            a[-6] = 0
-
-
-class TestGettingSlices:
-
-    def teardown_method(self) -> None:
-        bitstring.lsb0 = False
-
-    def test_everything(self):
-        a = BitStore('010010001000110111001111101101001111')
-
-        # Try combination of start and stop for msb0 and get the result.
-        # Convert to start and stop needed for lsb0
-        options = [5, 2, -2, 1, 7, -3, -9, 0, -1, -len(a), len(a), len(a) - 1, -len(a) - 1, -100, 100, None]
-        for start_option in options:
-            for end_option in options:
-                bitstring.lsb0 = True
-                lsb0 = a.getslice(start_option, end_option)
-                bitstring.lsb0 = False
-                msb0 = a.getslice(start_option, end_option)
-                new_slice = offset_slice_indices_lsb0(slice(start_option, end_option, None), len(a))
-                new_start, new_end = new_slice.start, new_slice.stop
-                assert len(msb0) == len(lsb0), f"[{start_option}: {end_option}] -> [{new_start}: {new_end}]  len(msb0)={len(msb0)}, len(lsb0)={len(lsb0)}"
+#!/usr/bin/env python
+
+import pytest
+import sys
+sys.path.insert(0, '..')
+import bitstring
+from bitstring.bitstore import BitStore, offset_slice_indices_lsb0
+import sys
+
+sys.path.insert(0, '..')
+
+
+class TestBasicFunctionality:
+
+    def test_getting_int(self):
+        a = BitStore('001')
+        assert a.getindex(0) == 0
+        assert a.getindex(1) == 0
+        assert a.getindex(2) == 1
+
+        assert a.getindex(-1) == 1
+        assert a.getindex(-2) == 0
+        assert a.getindex(-3) == 0
+
+        with pytest.raises(IndexError):
+            _ = a.getindex(3)
+        with pytest.raises(IndexError):
+            _ = a.getindex(-4)
+
+
+class TestBasicLSB0Functionality:
+
+    @classmethod
+    def setup_class(cls):
+        bitstring.lsb0 = True
+
+    @classmethod
+    def teardown_class(cls):
+        bitstring.lsb0 = False
+
+    def test_getting_int(self):
+        a = BitStore('001')
+        assert a.getindex(0) == 1
+        assert a.getindex(1) == 0
+        assert a.getindex(2) == 0
+
+        assert a.getindex(-1) == 0
+        assert a.getindex(-2) == 0
+        assert a.getindex(-3) == 1
+
+        with pytest.raises(IndexError):
+            _ = a.getindex(3)
+        with pytest.raises(IndexError):
+            _ = a.getindex(-4)
+
+    def test_getting_slice(self):
+        a = BitStore.frombytes(b'12345678')
+        assert a.getslice(None, None).tobytes() == b'12345678'
+        assert a.getslice(None, -8).tobytes() == b'2345678'
+        assert a.getslice(8, None).tobytes() == b'1234567'
+        assert a.getslice(16, 24).tobytes() == b'6'
+
+    def test_setting_int(self):
+        a = BitStore('00000')
+        a[0] = 1
+        assert a.slice_to_bin() == '00001'
+        a[-1] = 1
+        assert a.slice_to_bin() == '10001'
+        with pytest.raises(IndexError):
+            a[5] = 1
+        with pytest.raises(IndexError):
+            a[-6] = 0
+
+
+class TestGettingSlices:
+
+    def teardown_method(self) -> None:
+        bitstring.lsb0 = False
+
+    def test_everything(self):
+        a = BitStore('010010001000110111001111101101001111')
+
+        # Try combination of start and stop for msb0 and get the result.
+        # Convert to start and stop needed for lsb0
+        options = [5, 2, -2, 1, 7, -3, -9, 0, -1, -len(a), len(a), len(a) - 1, -len(a) - 1, -100, 100, None]
+        for start_option in options:
+            for end_option in options:
+                bitstring.lsb0 = True
+                lsb0 = a.getslice(start_option, end_option)
+                bitstring.lsb0 = False
+                msb0 = a.getslice(start_option, end_option)
+                new_slice = offset_slice_indices_lsb0(slice(start_option, end_option, None), len(a))
+                new_start, new_end = new_slice.start, new_slice.stop
+                assert len(msb0) == len(lsb0), f"[{start_option}: {end_option}] -> [{new_start}: {new_end}]  len(msb0)={len(msb0)}, len(lsb0)={len(lsb0)}"
```

### Comparing `bitstring-4.2.1/tests/test_bitstream.py` & `bitstring-4.2.2/tests/test_bitstream.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,4178 +1,4196 @@
-#!/usr/bin/env python
-
-import pytest
-import sys
-sys.path.insert(0, '..')
-import bitstring
-import copy
-import os
-import collections
-from bitstring import Bits, BitStream, ConstBitStream, pack, Dtype
-
-THIS_DIR = os.path.dirname(os.path.abspath(__file__))
-
-
-class TestFlexibleInitialisation:
-    def test_flexible_initialisation(self):
-        a = BitStream('uint:8=12')
-        c = BitStream(' uint : 8 =  12')
-        assert a == c == BitStream(uint=12, length=8)
-        assert a.uint == 12
-        a = BitStream('     int:2=  -1')
-        b = BitStream('int :2   = -1')
-        c = BitStream(' int:  2  =-1  ')
-        assert a == b == c == BitStream(int=-1, length=2)
-
-    def test_flexible_initialisation2(self):
-        h = BitStream('hex=12')
-        o = BitStream('oct=33')
-        b = BitStream('bin=10')
-        assert h == '0x12'
-        assert o == '0o33'
-        assert b == '0b10'
-
-    def test_flexible_initialisation3(self):
-        for s in ['se=-1', ' se = -1 ', 'se = -1']:
-            a = BitStream(s)
-            assert a.se == -1
-        for s in ['ue=23', 'ue =23', 'ue = 23']:
-            a = BitStream(s)
-            assert a.ue == 23
-
-    def test_multiple_string_initialisation(self):
-        a = BitStream('0b1 , 0x1')
-        assert a == '0b10001'
-        a = BitStream('ue=5, ue=1, se=-2')
-        assert a.read('ue') == 5
-        assert a.read('ue') == 1
-        assert a.read('se') == -2
-        b = BitStream('uint:32 = 12, 0b11') + 'int:100=-100, 0o44'
-        assert b.read(32).uint == 12
-        assert b.read(2).bin == '11'
-        assert b.read(100).int == -100
-
-
-class TestReading:
-    def test_read_bits(self):
-        s = BitStream(bytes=b'\x4d\x55')
-        assert s.read(4).hex == '4'
-        assert s.read(8).hex == 'd5'
-        assert s.read(1) == [0]
-        assert s.read(3).bin == '101'
-        assert not s.read(0)
-
-    def test_read_byte(self):
-        s = BitStream(hex='4d55')
-        assert s.read(8).hex == '4d'
-        assert s.read(8).hex == '55'
-
-    def test_read_bytes(self):
-        s = BitStream(hex='0x112233448811')
-        assert s.read(3 * 8).hex == '112233'
-        with pytest.raises(ValueError):
-            s.read(-16)
-        s.bitpos += 1
-        assert s.read(2 * 8).bin == '1000100100010000'
-
-    def test_read_ue(self):
-        with pytest.raises(bitstring.InterpretError):
-            _ = BitStream('').ue
-        # The numbers 0 to 8 as unsigned Exponential-Golomb codes
-        s = BitStream(bin='1 010 011 00100 00101 00110 00111 0001000 0001001')
-        assert s.pos == 0
-        for i in range(9):
-            assert s.read('ue') == i
-        with pytest.raises(bitstring.ReadError):
-            s.read('ue')
-
-    def test_read_se(self):
-        s = BitStream(bin='010 00110 0001010 0001000 00111')
-        assert s.read('se') == 1
-        assert s.read('se') == 3
-        assert s.readlist(3 * ['se']) == [5, 4, -3]
-
-
-class TestFind:
-    def test_find1(self):
-        s = ConstBitStream(bin='0b0000110110000')
-        assert s.find(BitStream(bin='11011'))
-        assert s.bitpos == 4
-        assert s.read(5).bin == '11011'
-        s.bitpos = 0
-        assert not s.find('0b11001', False)
-
-    def test_find2(self):
-        s = BitStream(bin='0')
-        assert s.find(s, False)
-        assert s.pos == 0
-        assert not s.find('0b00', False)
-        with pytest.raises(ValueError):
-            s.find(BitStream())
-
-    def test_find_with_offset(self):
-        s = BitStream(hex='0x112233')[4:]
-        assert s.find('0x23', False)
-        assert s.pos == 8
-
-    def test_find_corner_cases(self):
-        s = BitStream(bin='000111000111')
-        assert s.find('0b000')
-        assert s.pos == 0
-        assert s.find('0b000')
-        assert s.pos == 0
-        assert s.find('0b0111000111')
-        assert s.pos == 2
-        assert s.find('0b000', start=2)
-        assert s.pos == 6
-        assert s.find('0b111', start=6)
-        assert s.pos == 9
-        s.pos += 2
-        assert s.find('0b1', start=s.pos)
-
-    def test_find_bytes(self):
-        s = BitStream.fromstring('0x010203040102ff')
-        assert not s.find('0x05', bytealigned=True)
-        assert s.find('0x02', bytealigned=True)
-        assert s.read(16).hex == '0203'
-        assert s.find('0x02', start=s.bitpos, bytealigned=True)
-        s.read(1)
-        assert not s.find('0x02', start=s.bitpos, bytealigned=True)
-
-    def test_find_bytes_aligned_corner_cases(self):
-        s = BitStream('0xff')
-        assert s.find(s)
-        assert not s.find(BitStream(hex='0x12'))
-        assert not s.find(BitStream(hex='0xffff'))
-
-    def test_find_bytes_bitpos(self):
-        s = BitStream(hex='0x1122334455')
-        s.pos = 2
-        s.find('0x66', bytealigned=True)
-        assert s.pos == 2
-        s.pos = 38
-        s.find('0x66', bytealigned=True)
-        assert s.pos == 38
-
-    def test_find_byte_aligned(self):
-        s = BitStream(hex='0x12345678')
-        assert s.find(BitStream(hex='0x56'), bytealigned=True)
-        assert s.bytepos == 2
-        s.pos = 0
-        assert not s.find(BitStream(hex='0x45'), bytealigned=True)
-        s = BitStream('0x1234')
-        s.find('0x1234')
-        assert s.find('0x1234')
-        s += '0b111'
-        s.pos = 3
-        s.find('0b1', start=17, bytealigned=True)
-        assert not s.find('0b1', start=17, bytealigned=True)
-        assert s.pos == 3
-
-    def test_find_byte_aligned_with_offset(self):
-        s = BitStream(hex='0x112233')[4:]
-        assert s.find(BitStream(hex='0x23'))
-
-    def test_find_byte_aligned_errors(self):
-        s = BitStream(hex='0xffff')
-        with pytest.raises(ValueError):
-            s.find('')
-        with pytest.raises(ValueError):
-            s.find(BitStream())
-
-
-class TestRfind:
-    def test_rfind(self):
-        a = BitStream('0b001001001')
-        b = a.rfind('0b001')
-        assert b == (6,)
-        assert a.pos == 6
-        big = BitStream(length=100000) + '0x12' + BitStream(length=10000)
-        found = big.rfind('0x12', bytealigned=True)
-        assert found == (100000,)
-        assert big.pos == 100000
-
-    def test_rfind_byte_aligned(self):
-        a = BitStream('0x8888')
-        b = a.rfind('0b1', bytealigned=True)
-        assert b == (8,)
-        assert a.pos == 8
-
-    def test_rfind_startbit(self):
-        a = BitStream('0x0000ffffff')
-        b = a.rfind('0x0000', start=1, bytealigned=True)
-        assert b == ()
-        assert a.pos == 0
-        b = a.rfind('0x00', start=1, bytealigned=True)
-        assert b == (8,)
-        assert a.pos == 8
-
-    def test_rfind_endbit(self):
-        a = BitStream('0x000fff')
-        b = a.rfind('0b011', start=0, end=14, bytealigned=False)
-        assert bool(b) == True
-        b = a.rfind('0b011', 0, 13, False)
-        assert b == ()
-
-    def test_rfind_errors(self):
-        a = BitStream('0x43234234')
-        with pytest.raises(ValueError):
-            a.rfind('', bytealigned=True)
-        with pytest.raises(ValueError):
-            a.rfind('0b1', start=-99, bytealigned=True)
-        with pytest.raises(ValueError):
-            a.rfind('0b1', end=33, bytealigned=True)
-        with pytest.raises(ValueError):
-            a.rfind('0b1', start=10, end=9, bytealigned=True)
-
-
-class TestShift:
-    def test_shift_left(self):
-        s = BitStream.fromstring('0b1010')
-        t = s << 1
-        assert s.bin == '1010'
-        assert t.bin == '0100'
-        s = t << 0
-        assert s == '0b0100'
-        t = s << 100
-        assert t.bin == '0000'
-
-    def test_shift_left_errors(self):
-        s = BitStream()
-        with pytest.raises(ValueError):
-            s << 1
-        s = BitStream('0xf')
-        with pytest.raises(ValueError):
-            s << -1
-
-    def test_shift_right(self):
-        s = BitStream('0b1010')
-        t = s >> 1
-        assert s.bin == '1010'
-        assert t.bin == '0101'
-        q = s >> 0
-        assert q == '0b1010'
-        q.replace('0b1010', '')
-        t = s >> 100
-        assert t.bin == '0000'
-
-    def test_shift_right_errors(self):
-        s = BitStream()
-        with pytest.raises(ValueError):
-            s >> 1
-        s = BitStream('0xf')
-        with pytest.raises(ValueError):
-            s >> -1
-
-    def test_shift_right_in_place(self):
-        s = BitStream.fromstring('0xffff')[4:12]
-        s >>= 1
-        assert s == '0b01111111'
-        s = BitStream('0b11011')
-        s >>= 2
-        assert s.bin == '00110'
-        s >>= 100000000000000
-        assert s.bin == '00000'
-        s = BitStream('0xff')
-        s >>= 1
-        assert s == '0x7f'
-        s >>= 0
-        assert s == '0x7f'
-
-    def test_shift_in_place_whole_bitstring(self):
-        s = BitStream('0xabcd')
-        s >>= len(s)
-        assert s == '0x0000'
-
-    def test_shift_right_in_place_errors(self):
-        s = BitStream()
-        with pytest.raises(ValueError):
-            s >>= 1
-        s += '0b11'
-        with pytest.raises(ValueError):
-            s >>= -1
-
-    def test_shift_left_in_place(self):
-        s = BitStream('0xffff')
-        t = s[4:12]
-        t <<= 2
-        assert t == '0b11111100'
-        s = BitStream('0b11011')
-        s <<= 2
-        assert s.bin == '01100'
-        s <<= 100000000000000000000
-        assert s.bin == '00000'
-        s = BitStream('0xff')
-        s <<= 1
-        assert s == '0xfe'
-        s <<= 0
-        assert s == '0xfe'
-
-    def test_shift_left_in_place_errors(self):
-        s = BitStream()
-        with pytest.raises(ValueError):
-            s <<= 1
-        s += '0b11'
-        with pytest.raises(ValueError):
-            s <<= -1
-
-
-class TestReplace:
-    def test_replace1(self):
-        a = BitStream('0b1')
-        n = a.replace('0b1', '0b0', bytealigned=True)
-        assert a.bin == '0'
-        assert n == 1
-        n = a.replace('0b1', '0b0', bytealigned=True)
-        assert n == 0
-
-    def test_replace2(self):
-        a = BitStream('0b00001111111')
-        n = a.replace('0b1', '0b0', bytealigned=True)
-        assert a.bin == '00001111011'
-        assert n == 1
-        n = a.replace('0b1', '0b0', bytealigned=False)
-        assert a.bin == '00000000000'
-        assert n == 6
-
-    def test_replace3(self):
-        a = BitStream('0b0')
-        n = a.replace('0b0', '0b110011111', bytealigned=True)
-        assert n == 1
-        assert a.bin == '110011111'
-        n = a.replace('0b11', '', bytealigned=False)
-        assert n == 3
-        assert a.bin == '001'
-
-    def test_replace4(self):
-        a = BitStream('0x00114723ef4732344700')
-        n = a.replace('0x47', '0x00', bytealigned=True)
-        assert n == 3
-        assert a.hex == '00110023ef0032340000'
-        a.replace('0x00', '', bytealigned=True)
-        assert a.hex == '1123ef3234'
-        a.replace('0x11', '', start=1, bytealigned=True)
-        assert a.hex == '1123ef3234'
-        a.replace('0x11', '0xfff', end=7, bytealigned=True)
-        assert a.hex == '1123ef3234'
-        a.replace('0x11', '0xfff', end=8, bytealigned=True)
-        assert a.hex == 'fff23ef3234'
-
-    def test_replace5(self):
-        a = BitStream.fromstring('0xab')
-        b = BitStream.fromstring('0xcd')
-        c = BitStream.fromstring('0xabef')
-        c.replace(a, b)
-        assert c == '0xcdef'
-        assert a == '0xab'
-        assert b == '0xcd'
-        a = BitStream('0x0011223344')
-        a.pos = 12
-        a.replace('0x11', '0xfff', bytealigned=True)
-        assert a.pos == 0
-        assert a == '0x00fff223344'
-
-    def test_replace_with_self(self):
-        a = BitStream('0b11')
-        a.replace('0b1', a)
-        assert a == '0xf'
-        a.replace(a, a)
-        assert a == '0xf'
-
-    def test_replace_count(self):
-        a = BitStream('0x223344223344223344')
-        n = a.replace('0x2', '0x0', count=0, bytealigned=True)
-        assert n == 0
-        assert a.hex == '223344223344223344'
-        n = a.replace('0x2', '0x0', count=1, bytealigned=True)
-        assert n == 1
-        assert a.hex == '023344223344223344'
-        n = a.replace('0x33', '', count=2, bytealigned=True)
-        assert n == 2
-        assert a.hex == '02442244223344'
-        n = a.replace('0x44', '0x4444', count=1435, bytealigned=True)
-        assert n == 3
-        assert a.hex == '02444422444422334444'
-
-    def test_replace_bitpos(self):
-        a = BitStream('0xff')
-        a.bitpos = 8
-        a.replace('0xff', '', bytealigned=True)
-        assert a.bitpos == 0
-        a = BitStream('0b0011110001')
-        a.bitpos = 4
-        a.replace('0b1', '0b000')
-        assert a.bitpos == 0
-        a = BitStream('0b1')
-        a.bitpos = 1
-        a.replace('0b1', '0b11111', bytealigned=True)
-        assert a.bitpos == 0
-        a.replace('0b11', '0b0', False)
-        assert a.bitpos == 0
-        a.append('0b00')
-        a.pos = 5
-        a.replace('0b00', '0b11')
-        assert a.bitpos == 5
-
-    def test_replace_errors(self):
-        a = BitStream('0o123415')
-        with pytest.raises(ValueError):
-            a.replace('', Bits(0o7), bytealigned=True)
-        with pytest.raises(ValueError):
-            a.replace('0b1', '0b1', start=-100, bytealigned=True)
-        with pytest.raises(ValueError):
-            a.replace('0b1', '0b1', end=19, bytealigned=True)
-
-
-class TestSliceAssignment:
-    def test_set_slice(self):
-        a = BitStream()
-        a[0:0] = '0xabcdef'
-        assert a.bytepos == 0
-        a[4:16] = ''
-        assert a == '0xaef'
-        assert a.bitpos == 0
-        a.pos = 4
-        a[8:] = '0x00'
-        assert a == '0xae00'
-        assert a.bitpos == 0
-        a += '0xf'
-        assert a.bitpos == 20
-        a[8:] = '0xe'
-        assert a == '0xaee'
-        assert a.bitpos == 0
-        b = BitStream()
-        b[0:800] = '0xffee'
-        assert b == '0xffee'
-        b[4:48] = '0xeed123'
-        assert b == '0xfeed123'
-        b[-800:8] = '0x0000'
-        assert b == '0x0000ed123'
-        a = BitStream('0xabcde')
-        assert a[-100:-90] == ''
-        assert a[-100:-16] == '0xa'
-        a[-100:-16] = '0x0'
-        assert a == '0x0bcde'
-
-    def test_inserting_using_set_item(self):
-        a = BitStream()
-        a[0:0] = '0xdeadbeef'
-        assert a == '0xdeadbeef'
-        assert a.bytepos == 0
-        a[16:16] = '0xfeed'
-        assert a == '0xdeadfeedbeef'
-        assert a.bytepos == 0
-        a[0:0] = '0xa'
-        assert a == '0xadeadfeedbeef'
-        assert a.bitpos == 0
-        a.bytepos = 6
-        a[0:8] = '0xff'
-        assert a.bytepos == 6
-        a[8:0] = '0x000'
-        assert a.startswith('0xff000ead')
-
-    def test_slice_assignment_bit_pos(self):
-        a = BitStream('int:64=-1')
-        a.pos = 64
-        a[0:8] = ''
-        assert a.pos == 0
-        a.pos = 52
-        a[-16:] = '0x0000'
-        assert a.pos == 52
-
-
-
-class TestPack:
-    def test_pack1(self):
-        s = bitstring.pack('uint:6, bin, hex, int:6, se, ue, oct', 10, '0b110', 'ff', -1, -6, 6, '54')
-        t = BitStream('uint:6=10, 0b110, 0xff, int:6=-1, se=-6, ue=6, oct=54')
-        assert s == t
-        with pytest.raises(ValueError):
-            pack('tomato', '0')
-        with pytest.raises(ValueError):
-            pack('uint', 12)
-        with pytest.raises(ValueError):
-            pack('int', 12)
-        with pytest.raises(ValueError):
-            pack('hex', 'penguin')
-        with pytest.raises(ValueError):
-            pack('hex12', '0x12')
-
-    def test_pack_with_literals(self):
-        s = bitstring.pack('0xf')
-        assert s == '0xf'
-        assert type(s), BitStream
-        s = pack('0b1')
-        assert s == '0b1'
-        s = pack('0o7')
-        assert s == '0o7'
-        s = pack('int:10=-1')
-        assert s == '0b1111111111'
-        s = pack('uint:10=1')
-        assert s == '0b0000000001'
-        s = pack('ue=12')
-        assert s.ue == 12
-        s = pack('se=-12')
-        assert s.se == -12
-        s = pack('bin=01')
-        assert s.bin == '01'
-        s = pack('hex=01')
-        assert s.hex == '01'
-        s = pack('oct=01')
-        assert s.oct == '01'
-
-    def test_pack_with_dict(self):
-        a = pack('uint:6=width, se=height', height=100, width=12)
-        w, h = a.unpack('uint:6, se')
-        assert w == 12
-        assert h == 100
-        d = {'w': '0xf', '300': 423, 'e': '0b1101'}
-        a = pack('int:100=300, bin=e, uint:12=300', **d)
-        x, y, z = a.unpack('int:100, bin, uint:12')
-        assert x == 423
-        assert y == '1101'
-        assert z == 423
-
-    def test_pack_with_dict2(self):
-        a = pack('int:5, bin:3=b, 0x3, bin=c, se=12', 10, b='0b111', c='0b1')
-        b = BitStream('int:5=10, 0b111, 0x3, 0b1, se=12')
-        assert a == b
-        a = pack('bits:3=b', b=BitStream('0b101'))
-        assert a == '0b101'
-        a = pack('bits:24=b', b=BitStream('0x001122'))
-        assert a == '0x001122'
-
-    def test_pack_with_dict3(self):
-        s = pack('hex:4=e, hex:4=0xe, hex:4=e', e='f')
-        assert s == '0xfef'
-        s = pack('sep', sep='0b00')
-        assert s == '0b00'
-
-    def test_pack_with_dict4(self):
-        s = pack('hello', hello='0xf')
-        assert s == '0xf'
-        s = pack('x, y, x, y, x', x='0b10', y='uint:12=100')
-        t = BitStream('0b10, uint:12=100, 0b10, uint:12=100, 0b10')
-        assert s == t
-        a = [1, 2, 3, 4, 5]
-        s = pack('int:8, div,' * 5, *a, **{'div': '0b1'})
-        t = BitStream('int:8=1, 0b1, int:8=2, 0b1, int:8=3, 0b1, int:8=4, 0b1, int:8=5, 0b1')
-        assert s == t
-
-    def test_pack_with_locals(self):
-        width = 352
-        height = 288
-        s = pack('uint:12=width, uint:12=height', **locals())
-        assert s == '0x160120'
-
-    def test_pack_with_length_restriction(self):
-        _ = pack('bin:3', '0b000')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bin:3', '0b0011')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bin:3', '0b11')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bin:3=0b0011')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bin:3=0b11')
-
-        _ = pack('hex:4', '0xf')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('hex:4', '0b111')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('hex:4', '0b11111')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('hex:8=0xf')
-
-        _ = pack('oct:6', '0o77')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('oct:6', '0o1')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('oct:6', '0o111')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('oct:3', '0b1')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('oct:3=hello', hello='0o12')
-
-        _ = pack('bits:3', BitStream('0b111'))
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bits:3', BitStream('0b11'))
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bits:3', BitStream('0b1111'))
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bits:12=b', b=BitStream('0b11'))
-
-    def test_pack_null(self):
-        s = pack('')
-        assert not s
-        s = pack(',')
-        assert not s
-        s = pack(',,,,,0b1,,,,,,,,,,,,,0b1,,,,,,,,,,')
-        assert s == '0b11'
-        s = pack(',,uint:12,,bin:3,', 100, '100')
-        a, b = s.unpack('uint:12,bin:3')
-        assert a == 100
-        assert b == '100'
-
-    def test_pack_uint(self):
-        s = pack('uint:10, uint:5', 1, 2)
-        a, b = s.unpack('10, 5')
-        assert (a.uint, b.uint) == (1, 2)
-        s = pack('uint:10=150, uint:12=qee', qee=3)
-        assert s == 'uint:10=150, uint:12=3'
-        t = BitStream('uint:100=5')
-        assert t == 'uint:100=5'
-
-    def test_pack_defualt_uint_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream('5=-1')
-
-    def test_packing_long_keyword_bitstring(self):
-        s = pack('bits=b', b=BitStream(128000))
-        assert s == BitStream(128000)
-
-    def test_packing_with_list_format(self):
-        f = ['bin', 'hex', 'uint:10']
-        a = pack(','.join(f), '00', '234', 100)
-        b = pack(f, '00', '234', 100)
-        assert a == b
-
-
-class TestUnpack:
-    def test_unpack1(self):
-        s = BitStream('uint:13=23, hex=e, bin=010, int:41=-554, 0o44332, se=-12, ue=4')
-        s.pos = 11
-        a, b, c, d, e, f, g = s.unpack('uint:13, hex:4, bin:3, int:41, oct:15, se, ue')
-        assert a == 23
-        assert b == 'e'
-        assert c == '010'
-        assert d == -554
-        assert e == '44332'
-        assert f == -12
-        assert g == 4
-        assert s.pos == 11
-
-    def test_unpack2(self):
-        s = BitStream('0xff, 0b000, uint:12=100')
-        a, b, c = s.unpack('bits:8, bits, uint:12')
-        assert type(s) == BitStream
-        assert a == '0xff'
-        assert type(s) == BitStream
-        assert b == '0b000'
-        assert c == 100
-        a, b = s.unpack(['bits:11', 'uint'])
-        assert a == '0xff, 0b000'
-        assert b == 100
-
-
-class TestFromFile:
-    def test_creation_from_file_operations(self):
-        filename = os.path.join(THIS_DIR, 'smalltestfile')
-        s = BitStream(filename=filename)
-        s.append('0xff')
-        assert s.hex == '0123456789abcdefff'
-
-        s = ConstBitStream(filename=filename)
-        t = BitStream('0xff') + s
-        assert t.hex == 'ff0123456789abcdef'
-
-        s = BitStream(filename=filename)
-        del s[:1]
-        assert (BitStream('0b0') + s).hex == '0123456789abcdef'
-
-        s = BitStream(filename=filename)
-        del s[:7 * 8]
-        assert s.hex == 'ef'
-
-        s = BitStream(filename=filename)
-        s.insert('0xc', 4)
-        assert s.hex == '0c123456789abcdef'
-
-        s = BitStream(filename=filename)
-        s.prepend('0xf')
-        assert s.hex == 'f0123456789abcdef'
-
-        s = BitStream(filename=filename)
-        s.overwrite('0xaaa', 12)
-        assert s.hex == '012aaa6789abcdef'
-
-        s = BitStream(filename=filename)
-        s.reverse()
-        assert s.hex == 'f7b3d591e6a2c480'
-
-        s = BitStream(filename=filename)
-        del s[-60:]
-        assert s.hex == '0'
-
-        s = BitStream(filename=filename)
-        del s[:60]
-        assert s.hex == 'f'
-
-    def test_file_properties(self):
-        s = ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
-        assert s.hex == '0123456789abcdef'
-        assert s.uint == 81985529216486895
-        assert s.int == 81985529216486895
-        assert s.bin == '0000000100100011010001010110011110001001101010111100110111101111'
-        assert s[:-1].oct == '002215053170465363367'
-        s.bitpos = 0
-        assert s.read('se') == -72
-        s.bitpos = 0
-        assert s.read('ue') == 144
-        assert s.bytes == b'\x01\x23\x45\x67\x89\xab\xcd\xef'
-        assert s.tobytes() == b'\x01\x23\x45\x67\x89\xab\xcd\xef'
-
-    def test_creation_from_file_with_length(self):
-        test_filename = os.path.join(THIS_DIR, 'test.m1v')
-        s = ConstBitStream(filename=test_filename, length=32)
-        assert s.length == 32
-        assert s.hex == '000001b3'
-        s = ConstBitStream(filename=test_filename, length=0)
-        assert not s
-        small_test_filename = os.path.join(THIS_DIR, 'smalltestfile')
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream(filename=small_test_filename, length=65)
-        with pytest.raises(bitstring.CreationError):
-            _ = ConstBitStream(filename=small_test_filename, length=64, offset=1)
-        with pytest.raises(bitstring.CreationError):
-            _ = ConstBitStream(filename=small_test_filename, offset=65)
-        with open(small_test_filename, 'rb') as f:
-            with pytest.raises(bitstring.CreationError):
-                _ = ConstBitStream(f, offset=65)
-            with pytest.raises(bitstring.CreationError):
-                _ = ConstBitStream(f, length=65)
-            with pytest.raises(bitstring.CreationError):
-                _ = ConstBitStream(f, offset=60, length=5)
-
-    def test_creation_from_file_with_offset(self):
-        filename = os.path.join(THIS_DIR, 'test.m1v')
-        a = BitStream(filename=filename, offset=4)
-        assert a.peek(4 * 8).hex == '00001b31'
-        b = BitStream(filename=filename, offset=28)
-        assert b.peek(8).hex == '31'
-
-    def test_file_slices(self):
-        s = BitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
-        assert s[-16:].hex == 'cdef'
-
-    def test_creataion_from_file_errors(self):
-        with pytest.raises(IOError):
-            _ = BitStream(filename='Idonotexist')
-
-    def test_find_in_file(self):
-        s = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
-        assert s.find('0x160120')
-        assert s.bytepos == 4
-        s3 = s.read(24)
-        assert s3.hex == '160120'
-        s.bytepos = 0
-        assert s._pos == 0
-        assert s.find('0x0001b2')
-        assert s.bytepos == 13
-
-    def test_hex_from_file(self):
-        s = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
-        assert s[0:32].hex == '000001b3'
-        assert s[-32:].hex == '000001b7'
-        s.hex = '0x11'
-        assert s.hex == '11'
-
-    def test_file_operations(self):
-        filename = os.path.join(THIS_DIR, 'test.m1v')
-        s1 = BitStream(filename=filename)
-        s2 = BitStream(filename=filename)
-        assert s1.read(32).hex == '000001b3'
-        assert s2.read(32).hex == '000001b3'
-        s1.bytepos += 4
-        assert s1.read(8).hex == '02'
-        assert s2.read(5 * 8).hex == '1601208302'
-        s1.pos = s1.len
-        with pytest.raises(ValueError):
-            s1.pos += 1
-
-    def test_file_bit_getting(self):
-        s = ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'), offset=16, length=8)
-        b = s[1]
-        assert b
-        b = s.any(0, [-1, -2, -3])
-        assert b
-        b = s.all(0, [0, 1, 2])
-        assert not b
-
-
-class TestCreationErrors:
-    def test_incorrect_bin_assignment(self):
-        s = BitStream()
-        with pytest.raises(bitstring.CreationError):
-            s._setbin_safe('0010020')
-
-    def test_incorrect_hex_assignment(self):
-        s = BitStream()
-        with pytest.raises(bitstring.CreationError):
-            s.hex = '0xabcdefg'
-
-
-class TestLength:
-    def test_length_zero(self):
-        assert BitStream('').len == 0
-
-    def test_length(self):
-        assert BitStream('0x80').len == 8
-
-    def test_offset_length_error(self):
-        with pytest.raises(bitstring.CreationError):
-            BitStream(hex='0xffff', offset=-1)
-
-
-class TestSimpleConversions:
-    def test_convert_to_uint(self):
-        assert BitStream('0x10').uint == 16
-        assert BitStream('0b000111').uint == 7
-
-    def test_convert_to_int(self):
-        assert BitStream('0x10').int == 16
-        assert BitStream('0b11110').int == -2
-
-    def test_convert_to_hex(self):
-        assert BitStream(bytes=b'\x00\x12\x23\xff').hex == '001223ff'
-        s = BitStream('0b11111')
-        with pytest.raises(bitstring.InterpretError):
-            _ = s.hex
-
-
-class TestEmpty:
-    def test_empty_bitstring(self):
-        s = BitStream()
-        with pytest.raises(bitstring.ReadError):
-            s.read(1)
-        assert s.bin == ''
-        assert s.hex == ''
-        with pytest.raises(bitstring.InterpretError):
-            _ = s.int
-        with pytest.raises(bitstring.InterpretError):
-            _ = s.uint
-        assert not s
-
-    def test_non_empty_bit_stream(self):
-        s = BitStream(bin='0')
-        assert not not s.len
-
-
-class TestPosition:
-    def test_bit_position(self):
-        s = BitStream(bytes=b'\x00\x00\x00')
-        assert s.bitpos == 0
-        s.read(5)
-        assert s.pos == 5
-        s.pos = s.len
-        with pytest.raises(bitstring.ReadError):
-            s.read(1)
-
-    def test_byte_position(self):
-        s = BitStream(bytes=b'\x00\x00\x00')
-        assert s.bytepos == 0
-        s.read(10)
-        with pytest.raises(bitstring.ByteAlignError):
-            _ = s.bytepos
-        s.read(6)
-        assert s.bytepos == 2
-
-    def test_seek_to_bit(self):
-        s = BitStream(bytes=b'\x00\x00\x00\x00\x00\x00')
-        s.bitpos = 0
-        assert s.bitpos == 0
-        with pytest.raises(ValueError):
-            s.pos = -1
-        with pytest.raises(ValueError):
-            s.bitpos = 6 * 8 + 1
-        s.bitpos = 6 * 8
-        assert s.bitpos == 6 * 8
-
-    def test_seek_to_byte(self):
-        s = BitStream(bytes=b'\x00\x00\x00\x00\x00\xab')
-        s.bytepos = 5
-        assert s.read(8).hex == 'ab'
-
-    def test_advance_bits_and_bytes(self):
-        s = BitStream(bytes=b'\x00\x00\x00\x00\x00\x00\x00\x00')
-        s.pos += 5
-        assert s.pos == 5
-        s.bitpos += 16
-        assert s.pos == 2 * 8 + 5
-        s.pos -= 8
-        assert s.pos == 8 + 5
-
-    def test_retreat_bits_and_bytes(self):
-        a = BitStream(length=100)
-        a.pos = 80
-        a.bytepos -= 5
-        assert a.bytepos == 5
-        a.pos -= 5
-        assert a.pos == 35
-
-
-class TestAppend:
-    def test_append(self):
-        s1 = BitStream('0b00000')
-        s1.append(BitStream(bool=True))
-        assert s1.bin == '000001'
-        assert (BitStream('0x0102') + BitStream('0x0304')).hex == '01020304'
-
-    def test_append_same_bitstring(self):
-        s1 = BitStream('0xf0')[:6]
-        s1.append(s1)
-        assert s1.bin == '111100111100'
-
-    def test_append_with_offset(self):
-        s = BitStream(bytes=b'\x28\x28', offset=1)
-        s.append('0b0')
-        assert s.hex == '5050'
-
-
-class TestByteAlign:
-    def test_byte_align(self):
-        s = BitStream(hex='0001ff23')
-        s.bytealign()
-        assert s.bytepos == 0
-        s.pos += 11
-        s.bytealign()
-        assert s.bytepos == 2
-        s.pos -= 10
-        s.bytealign()
-        assert s.bytepos == 1
-
-    def test_insert_byte_aligned(self):
-        s = BitStream('0x0011')
-        s.insert(BitStream('0x22'), 8)
-        assert s.hex == '002211'
-        s = BitStream(0)
-        s.insert(BitStream(bin='101'), 0)
-        assert s.bin == '101'
-
-
-class TestTruncate:
-    def test_truncate_start(self):
-        s = BitStream('0b1')
-        del s[0]
-        assert not s
-        s = BitStream(hex='1234')
-        assert s.hex == '1234'
-        del s[:4]
-        assert s.hex == '234'
-        del s[:9]
-        assert s.bin == '100'
-        del s[:2]
-        assert s.bin == '0'
-        assert s.len == 1
-        del s[:1]
-        assert not s
-
-    def test_truncate_end(self):
-        s = BitStream('0b1')
-        del s[-1:]
-        assert not s
-        s = BitStream(bytes=b'\x12\x34')
-        assert s.hex == '1234'
-        del s[-4:]
-        assert s.hex == '123'
-        del s[-9:]
-        assert s.bin == '000'
-        del s[-3:]
-        assert not s
-        s = BitStream('0b001')
-        del s[:2]
-        del s[-1:]
-        assert not s
-
-
-class TestSlice:
-    def test_byte_aligned_slice(self):
-        s = BitStream(hex='0x123456')
-        assert s[8:16].hex == '34'
-        s = s[8:24]
-        assert s.len == 16
-        assert s.hex == '3456'
-        s = s[0:8]
-        assert s.hex == '34'
-        s.hex = '0x123456'
-        assert s[8:24][0:8].hex == '34'
-
-    def test_slice(self):
-        s = BitStream(bin='000001111100000')
-        s1 = s[0:5]
-        s2 = s[5:10]
-        s3 = s[10:15]
-        assert s1.bin == '00000'
-        assert s2.bin == '11111'
-        assert s3.bin == '00000'
-
-
-class TestInsert:
-    def test_insert(self):
-        s1 = BitStream(hex='0x123456')
-        s2 = BitStream(hex='0xff')
-        s1.bytepos = 1
-        s1.insert(s2)
-        assert s1.bytepos == 2
-        assert s1.hex == '12ff3456'
-        s1.insert('0xee', 24)
-        assert s1.hex == '12ff34ee56'
-        assert s1.bitpos == 32
-        with pytest.raises(ValueError):
-            s1.insert('0b1', -1000)
-        with pytest.raises(ValueError):
-            s1.insert('0b1', 1000)
-
-    def test_insert_null(self):
-        s = BitStream(hex='0x123')
-        s.insert(BitStream(), 3)
-        assert s.hex == '123'
-
-    def test_insert_bits(self):
-        one = BitStream(bin='1')
-        zero = BitStream(bin='0')
-        s = BitStream(bin='00')
-        s.insert(one, 0)
-        assert s.bin == '100'
-        s.insert(zero, 0)
-        assert s.bin == '0100'
-        s.insert(one, s.len)
-        assert s.bin == '01001'
-        s.insert(s, 2)
-        assert s.bin == '0101001001'
-
-
-class TestResetting:
-    def test_set_hex(self):
-        s = BitStream()
-        s.hex = '0'
-        assert s.hex == '0'
-        s.hex = '0x010203045'
-        assert s.hex == '010203045'
-        with pytest.raises(bitstring.CreationError):
-            s.hex = '0x002g'
-
-    def test_set_bin(self):
-        s = BitStream(bin="000101101")
-        assert s.bin == '000101101'
-        assert s.len == 9
-        s.bin = '0'
-        assert s.bin == '0'
-        assert s.len == 1
-
-    def test_set_empty_bin(self):
-        s = BitStream(hex='0x000001b3')
-        s.bin = ''
-        assert s.len == 0
-        assert s.bin == ''
-
-    def test_set_invalid_bin(self):
-        s = BitStream()
-        with pytest.raises(bitstring.CreationError):
-            s.bin = '00102'
-
-
-class TestOverwriting:
-    def test_overwrite_bit(self):
-        s = BitStream(bin='0')
-        s.overwrite(BitStream(bin='1'), 0)
-        assert s.bin == '1'
-
-    def test_overwrite_limits(self):
-        s = BitStream(bin='0b11111')
-        s.overwrite(BitStream(bin='000'), 0)
-        assert s.bin == '00011'
-        s.overwrite('0b000', 2)
-        assert s.bin == '00000'
-
-    def test_overwrite_null(self):
-        s = BitStream(hex='342563fedec')
-        s2 = BitStream(s)
-        s.overwrite(BitStream(bin=''), 23)
-        assert s.bin == s2.bin
-
-    def test_overwrite_position(self):
-        s1 = BitStream(hex='0123456')
-        s2 = BitStream(hex='ff')
-        s1.bytepos = 1
-        s1.overwrite(s2)
-        assert (s1.hex, s1.bytepos) == ('01ff456', 2)
-        s1.overwrite('0xff', 0)
-        assert (s1.hex, s1.bytepos) == ('ffff456', 1)
-
-    def test_overwrite_with_self(self):
-        s = BitStream('0x123')
-        s.overwrite(s)
-        assert s == '0x123'
-
-
-class TestSplit:
-    def test_split_byte_aligned_corner_cases(self):
-        s = BitStream()
-        bsl = s.split(BitStream(hex='0xff'))
-        assert next(bsl).hex == ''
-        with pytest.raises(StopIteration):
-            _ = next(bsl)
-        s = BitStream(hex='aabbcceeddff')
-        delimiter = BitStream()
-        bsl = s.split(delimiter)
-        with pytest.raises(ValueError):
-            _ = next(bsl)
-        delimiter = BitStream(hex='11')
-        bsl = s.split(delimiter)
-        assert next(bsl).hex == s.hex
-
-    def test_split_byte_aligned(self):
-        s = BitStream(hex='0x1234aa1234bbcc1234ffff')
-        delimiter = BitStream(hex='1234')
-        bsl = s.split(delimiter)
-        assert [b.hex for b in bsl] == ['', '1234aa', '1234bbcc', '1234ffff']
-        assert s.pos == 0
-
-    def test_split_byte_aligned_with_intial_bytes(self):
-        s = BitStream(hex='aa471234fedc43 47112233 47 4723 472314')
-        delimiter = BitStream(hex='47')
-        s.find(delimiter)
-        assert s.bytepos == 1
-        bsl = s.split(delimiter, start=0)
-        assert [b.hex for b in bsl] == ['aa', '471234fedc43', '47112233',
-                                                '47', '4723', '472314']
-        assert s.bytepos == 1
-
-    def test_split_byte_aligned_with_overlapping_delimiter(self):
-        s = BitStream(hex='aaffaaffaaffaaffaaff')
-        bsl = s.split(BitStream(hex='aaffaa'))
-        assert [b.hex for b in bsl] == ['', 'aaffaaff', 'aaffaaffaaff']
-
-
-class TestAdding:
-    def test_adding(self):
-        s1 = BitStream(hex='0x0102')
-        s2 = BitStream(hex='0x0304')
-        s3 = s1 + s2
-        assert s1.hex == '0102'
-        assert s2.hex == '0304'
-        assert s3.hex == '01020304'
-        s3 += s1
-        assert s3.hex == '010203040102'
-        assert s2[9:16].bin == '0000100'
-        assert s1[0:9].bin == '000000010'
-        s4 = BitStream(bin='000000010') + BitStream(bin='0000100')
-        assert s4.bin == '0000000100000100'
-        s5 = s1[0:9] + s2[9:16]
-        assert s5.bin == '0000000100000100'
-
-    def test_more_adding(self):
-        s = BitStream(bin='00') + BitStream(bin='') + BitStream(bin='11')
-        assert s.bin == '0011'
-        s = '0b01'
-        s += BitStream('0b11')
-        assert s.bin == '0111'
-        s = BitStream('0x00')
-        t = BitStream('0x11')
-        s += t
-        assert s.hex == '0011'
-        assert t.hex == '11'
-        s += s
-        assert s.hex == '00110011'
-
-    def test_radd(self):
-        s = '0xff' + BitStream('0xee')
-        assert s.hex == 'ffee'
-
-    def test_truncate_asserts(self):
-        s = BitStream('0x001122')
-        s.bytepos = 2
-        del s[-s.len:]
-        # self.assertEqual(s.bytepos, 0)
-        s.append('0x00')
-        s.append('0x1122')
-        s.bytepos = 2
-        del s[:s.len]
-        # self.assertEqual(s.bytepos, 0)
-        s.append('0x00')
-
-    def test_overwrite_errors(self):
-        s = BitStream(bin='11111')
-        with pytest.raises(ValueError):
-            s.overwrite(BitStream(bin='1'), -10)
-        with pytest.raises(ValueError):
-            s.overwrite(BitStream(bin='1'), 6)
-        s.overwrite('bin=0', 5)
-        assert s.b == '111110'
-        s.overwrite(BitStream(hex='0x00'), 1)
-        assert s.b == '100000000'
-
-    def test_delete_bits(self):
-        s = BitStream(bin='000111100000')
-        s.bitpos = 4
-        del s[4:8]
-        assert s.bin == '00010000'
-        del s[4:1004]
-        assert s.bin, '0001'
-
-    def test_delete_bits_with_position(self):
-        s = BitStream(bin='000111100000')
-        del s[4:8]
-        assert s.bin == '00010000'
-
-    def test_delete_bytes(self):
-        s = BitStream('0x00112233')
-        del s[8:8]
-        assert s.hex == '00112233'
-        assert s.pos == 0
-        del s[8:16]
-        assert s.hex == '002233'
-        assert s.bytepos == 0
-        del s[:24]
-        assert not s
-        assert s.pos == 0
-
-    def test_get_item_with_positive_position(self):
-        s = BitStream(bin='0b1011')
-        assert s[0] == True
-        assert s[1] == False
-        assert s[2] == True
-        assert s[3] == True
-        with pytest.raises(IndexError):
-            _ = s[4]
-
-    def test_get_item_with_negative_position(self):
-        s = BitStream(bin='1011')
-        assert s[-1] == True
-        assert s[-2] == True
-        assert s[-3] == False
-        assert s[-4] == True
-        with pytest.raises(IndexError):
-            _ = s[-5]
-
-    def test_slicing(self):
-        s = ConstBitStream(hex='0123456789')
-        assert s[0:8].hex == '01'
-        assert not s[0:0]
-        assert not s[23:20]
-        assert s[8:12].bin == '0010'
-        assert s[32:80] == '0x89'
-
-    def test_negative_slicing(self):
-        s = ConstBitStream(hex='012345678')
-        assert s[:-8].hex == '0123456'
-        assert s[-16:-8].hex == '56'
-        assert s[-24:].hex == '345678'
-        assert s[-1000:-24] == '0x012'
-
-    def test_len(self):
-        s = BitStream()
-        assert len(s) == 0
-        s.append(BitStream(bin='001'))
-        assert len(s) == 3
-
-    def test_join(self):
-        s1 = BitStream(bin='0')
-        s2 = BitStream(bin='1')
-        s3 = BitStream(bin='000')
-        s4 = BitStream(bin='111')
-        strings = [s1, s2, s1, s3, s4]
-        s = BitStream().join(strings)
-        assert s.bin == '010000111'
-
-    def test_join2(self):
-        s1 = BitStream(hex='00112233445566778899aabbccddeeff')
-        s2 = BitStream(bin='0b000011')
-        bsl = [s1[0:32], s1[4:12], s2, s2, s2, s2]
-        s = ConstBitStream().join(bsl)
-        assert s.hex == '00112233010c30c3'
-
-        bsl = [BitStream(uint=j, length=12) for j in range(10) for _ in range(10)]
-        s = BitStream().join(bsl)
-        assert s.length == 1200
-
-    def test_join_with_ints(self):
-        with pytest.raises(TypeError):
-            s = BitStream().join([1, 2])
-
-    def test_pos(self):
-        s = BitStream(bin='1')
-        assert s.bitpos == 0
-        s.read(1)
-        assert s.bitpos == 1
-
-    def test_writing_data(self):
-        strings = [BitStream(bin=x) for x in ['0', '001', '0011010010', '010010', '1011']]
-        s = BitStream().join(strings)
-        s2 = BitStream(bytes=s.bytes)
-        assert s2.bin == '000100110100100100101011'
-        s2.append(BitStream(bin='1'))
-        s3 = BitStream(bytes=s2.tobytes())
-        assert s3.bin == '00010011010010010010101110000000'
-
-    def test_writing_data_with_offsets(self):
-        s1 = BitStream(bytes=b'\x10')
-        s2 = BitStream(bytes=b'\x08\x00', length=8, offset=1)
-        s3 = BitStream(bytes=b'\x04\x00', length=8, offset=2)
-        assert s1 == s2
-        assert s2 == s3
-        assert s1.bytes == s2.bytes
-        assert s2.bytes == s3.bytes
-
-    def test_various_things1(self):
-        hexes = ['12345678', '87654321', 'ffffffffff', 'ed', '12ec']
-        bins = ['001010', '1101011', '0010000100101110110110', '11', '011']
-        bsl = []
-        for (hex_, bin_) in list(zip(hexes, bins)) * 5:
-            bsl.append(BitStream(hex=hex_))
-            bsl.append(BitStream(bin=bin_))
-        s = BitStream().join(bsl)
-        for (hex_, bin_) in list(zip(hexes, bins)) * 5:
-            h = s.read(4 * len(hex_))
-            b = s.read(len(bin_))
-            assert h.hex == hex_
-            assert b.bin == bin_
-
-    def test_various_things2(self):
-        s1 = BitStream(hex="0x1f08")[:13]
-        assert s1.bin == '0001111100001'
-        s2 = BitStream(bin='0101')
-        assert s2.bin == '0101'
-        s1.append(s2)
-        assert s1.length == 17
-        assert s1.bin == '00011111000010101'
-        s1 = s1[3:8]
-        assert s1.bin == '11111'
-
-    def test_various_things3(self):
-        s1 = BitStream(hex='0x012480ff')[2:27]
-        s2 = s1 + s1
-        assert s2.length == 50
-        s3 = s2[0:25]
-        s4 = s2[25:50]
-        assert s3.bin == s4.bin
-
-    def test_peek_bit(self):
-        s = BitStream(bin='01')
-        assert s.peek(1) == [0]
-        assert s.peek(1) == [0]
-        assert s.read(1) == [0]
-        assert s.peek(1) == [1]
-        assert s.peek(1) == [1]
-
-        s = BitStream(bytes=b'\x1f', offset=3)
-        assert s.len == 5
-        assert s.peek(5).bin == '11111'
-        assert s.peek(5).bin == '11111'
-        s.pos += 1
-        with pytest.raises(bitstring.ReadError):
-            _ = s.peek(5)
-
-        s = BitStream(hex='001122334455')
-        assert s.peek(8).hex == '00'
-        assert s.read(8).hex == '00'
-        s.pos += 33
-        with pytest.raises(bitstring.ReadError):
-            _ = s.peek(8)
-
-        s = BitStream(hex='001122334455')
-        assert s.peek(8 * 2).hex == '0011'
-        assert s.read(8 * 3).hex == '001122'
-        assert s.peek(8 * 3).hex == '334455'
-        with pytest.raises(bitstring.ReadError):
-            _ = s.peek(25)
-
-    def test_advance_bit(self):
-        s = BitStream(hex='0xff')
-        s.bitpos = 6
-        s.pos += 1
-        assert s.bitpos == 7
-        s.bitpos += 1
-        with pytest.raises(ValueError):
-            s.pos += 1
-
-    def test_advance_byte(self):
-        s = BitStream(hex='0x010203')
-        s.bytepos += 1
-        assert s.bytepos == 1
-        s.bytepos += 1
-        assert s.bytepos == 2
-        s.bytepos += 1
-        with pytest.raises(ValueError):
-            s.bytepos += 1
-
-    def test_retreat_bit(self):
-        s = BitStream(hex='0xff')
-        with pytest.raises(ValueError):
-            s.pos -= 1
-        s.pos = 5
-        s.pos -= 1
-        assert s.pos == 4
-
-    def test_retreat_byte(self):
-        s = BitStream(hex='0x010203')
-        with pytest.raises(ValueError):
-            s.bytepos -= 1
-        s.bytepos = 3
-        s.bytepos -= 1
-        assert s.bytepos == 2
-        assert s.read(8).hex == '03'
-
-    def test_creation_by_auto(self):
-        s = BitStream('0xff')
-        assert s.hex == 'ff'
-        s = BitStream('0b00011')
-        assert s.bin == '00011'
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream('hello')
-        s1 = BitStream(bytes=b'\xf5', length=3, offset=5)
-        with pytest.raises(TypeError):
-            _ = BitStream(1.2)
-
-    def test_creation_by_auto2(self):
-        s = BitStream('bin=001')
-        assert s.bin == '001'
-        s = BitStream('oct=0o007')
-        assert s.oct == '007'
-        s = BitStream('hex=123abc')
-        assert s == '0x123abc'
-
-        s = BitStream('bin2=01')
-        assert s == '0b01'
-        for s in ['bin:1=01', 'bits:4=0b1', 'oct3=000', 'hex4=0x1234']:
-            with pytest.raises(bitstring.CreationError):
-                _ = BitStream(s)
-
-    def test_insert_using_auto(self):
-        s = BitStream('0xff')
-        s.insert('0x00', 4)
-        assert s.hex == 'f00f'
-        with pytest.raises(ValueError):
-            s.insert('ff')
-
-    def test_overwrite_using_auto(self):
-        s = BitStream('0x0110')
-        s.overwrite('0b1')
-        assert s.hex == '8110'
-        s.overwrite('')
-        assert s.hex == '8110'
-        with pytest.raises(ValueError):
-            s.overwrite('0bf')
-
-    def test_find_using_auto(self):
-        s = BitStream('0b000000010100011000')
-        assert s.find('0b101')
-        assert s.pos == 7
-
-    def test_findbytealigned_using_auto(self):
-        s = BitStream('0x00004700')
-        assert s.find('0b01000111', bytealigned=True)
-        assert s.bytepos == 2
-
-    def test_append_using_auto(self):
-        s = BitStream('0b000')
-        s.append('0b111')
-        assert s.bin == '000111'
-        s.append('0b0')
-        assert s.bin == '0001110'
-
-    def test_split_byte_aligned_using_auto(self):
-        s = BitStream('0x000143563200015533000123')
-        sections = s.split('0x0001')
-        assert next(sections).hex == ''
-        assert next(sections).hex == '0001435632'
-        assert next(sections).hex == '00015533'
-        assert next(sections).hex == '000123'
-        pytest.raises(StopIteration, next, sections)
-
-    def test_split_byte_aligned_with_self(self):
-        s = BitStream('0x1234')
-        sections = s.split(s)
-        assert next(sections).hex == ''
-        assert next(sections).hex == '1234'
-        with pytest.raises(StopIteration):
-            next(sections)
-
-    def test_prepend(self):
-        s = BitStream('0b000')
-        s.prepend('0b11')
-        assert s.bin == '11000'
-        s.prepend(s)
-        assert s.bin == '1100011000'
-        s.prepend('')
-        assert s.bin == '1100011000'
-
-    def test_null_slice(self):
-        s = BitStream('0x111')
-        t = s[1:1]
-        assert len(t) == 0
-
-    def test_multiple_autos(self):
-        s = BitStream('0xa')
-        s.prepend('0xf')
-        s.append('0xb')
-        assert s == '0xfab'
-        s.prepend(s)
-        s.append('0x100')
-        s.overwrite('0x5', 4)
-        assert s == '0xf5bfab100'
-
-    def test_reverse(self):
-        s = BitStream('0b0011')
-        s.reverse()
-        assert s.bin == '1100'
-        s = BitStream('0b10')
-        s.reverse()
-        assert s.bin == '01'
-        s = BitStream()
-        s.reverse()
-        assert s.bin == ''
-
-    def test_init_with_concatenated_strings(self):
-        s = BitStream('0xff 0Xee 0xd 0xcc')
-        assert s.hex == 'ffeedcc'
-        s = BitStream('0b0 0B111 0b001')
-        assert s.bin == '0111001'
-        s += '0b1' + '0B1'
-        assert s.bin == '011100111'
-        s = BitStream(hex='ff0xee')
-        assert s.hex == 'ffee'
-        s = BitStream(bin='000b0b11')
-        assert s.bin == '0011'
-        s = BitStream('  0o123 0O 7 0   o1')
-        assert s.oct == '12371'
-        s += '  0 o 332'
-        assert s.oct == '12371332'
-
-    def test_equals(self):
-        s1 = BitStream('0b01010101')
-        s2 = BitStream('0b01010101')
-        assert s1 == s2
-        s3 = BitStream()
-        s4 = BitStream()
-        assert s3 == s4
-        assert not s3 != s4
-        s5 = BitStream(bytes=b'\xff', offset=2, length=3)
-        s6 = BitStream('0b111')
-        assert s5 == s6
-
-        class A(object):
-            pass
-        assert not s5 == A()
-
-    def test_large_equals(self):
-        s1 = BitStream(1000000)
-        s2 = BitStream(1000000)
-        s1.set(True, [-1, 55, 53214, 534211, 999999])
-        s2.set(True, [-1, 55, 53214, 534211, 999999])
-        assert s1 == s2
-        s1.set(True, 800000)
-        assert s1 != s2
-
-    def test_not_equals(self):
-        s1 = BitStream('0b0')
-        s2 = BitStream('0b1')
-        assert s1 != s2
-        assert not s1 != BitStream('0b0')
-
-    def test_equality_with_auto_initialised(self):
-        a = BitStream('0b00110111')
-        assert a == '0b00110111'
-        assert a == '0x37'
-        assert '0b0011 0111' == a
-        assert '0x3 0x7' == a
-        assert not a == '0b11001000'
-        assert not '0x3737' == a
-
-    def test_invert_special_method(self):
-        s = BitStream('0b00011001')
-        assert (~s).bin == '11100110'
-        assert (~BitStream('0b0')).bin == '1'
-        assert (~BitStream('0b1')).bin == '0'
-        assert ~~s == s
-
-    def test_invert_bit_position(self):
-        s = ConstBitStream('0xefef')
-        s.pos = 8
-        t = ~s
-        assert s.pos == 8
-        assert t.pos == 0
-
-    def test_invert_special_method_errors(self):
-        s = BitStream()
-        with pytest.raises(bitstring.Error):
-            _ = ~s
-
-    def test_join_with_auto(self):
-        s = BitStream().join(['0xf', '0b00', BitStream(bin='11')])
-        assert s == '0b11110011'
-
-    def test_auto_bit_string_copy(self):
-        s = BitStream('0xabcdef')
-        t = BitStream(s)
-        assert t.hex == 'abcdef'
-        del s[-8:]
-        assert t.hex == 'abcdef'
-
-
-class TestMultiplication:
-
-    def test_multiplication(self):
-        a = BitStream('0xff')
-        b = a * 8
-        assert b == '0xffffffffffffffff'
-        b = 4 * a
-        assert b == '0xffffffff'
-        assert 1 * a == a * 1 == a
-        c = a * 0
-        assert not c
-        a *= 3
-        assert a == '0xffffff'
-        a *= 0
-        assert not a
-        one = BitStream('0b1')
-        zero = BitStream('0b0')
-        mix = one * 2 + 3 * zero + 2 * one * 2
-        assert mix == '0b110001111'
-        q = BitStream()
-        q *= 143
-        assert not q
-        q += [True, True, False]
-        assert q.bitpos == 3
-        q *= 0
-        assert not q
-        assert q.bitpos == 0
-
-    def test_multiplication_with_files(self):
-        a = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
-        b = a.len
-        a *= 3
-        assert a.len == 3 * b
-
-    def test_multiplication_errors(self):
-        a = BitStream('0b1')
-        b = BitStream('0b0')
-        with pytest.raises(ValueError):
-            _ = a * -1
-        with pytest.raises(ValueError):
-            a *= -1
-        with pytest.raises(ValueError):
-            _ = -1 * a
-        with pytest.raises(TypeError):
-            _ = a * 1.2
-        with pytest.raises(TypeError):
-            _ = b * a
-        with pytest.raises(TypeError):
-            a *= b
-
-
-class TestBitWise:
-
-    def test_bitwise_and(self):
-        a = BitStream('0b01101')
-        b = BitStream('0b00110')
-        assert (a & b).bin == '00100'
-        assert (a & '0b11111') == a
-        with pytest.raises(ValueError):
-            _ = a & '0b1'
-        with pytest.raises(ValueError):
-            _ = b & '0b110111111'
-        c = BitStream('0b0011011')
-        c.pos = 4
-        d = c & '0b1111000'
-        assert d.pos == 0
-        assert d.bin == '0011000'
-        d = '0b1111000' & c
-        assert d.bin == '0011000'
-
-    def test_bitwise_or(self):
-        a = BitStream('0b111001001')
-        b = BitStream('0b011100011')
-        c = a | b
-        assert c.bin == '111101011'
-        assert (a | '0b000000000') == a
-        with pytest.raises(ValueError):
-            _ = a | '0b0000'
-        with pytest.raises(ValueError):
-            _ = b | (a + '0b1')
-        a = '0xff00' | BitStream('0x00f0')
-        assert a.hex == 'fff0'
-
-    def test_bitwise_xor(self):
-        a = BitStream('0b111001001')
-        b = BitStream('0b011100011')
-        c = a ^ b
-        assert c.bin == '100101010'
-        assert (a ^ '0b111100000').bin == '000101001'
-        with pytest.raises(ValueError):
-            _ = a ^ '0b0000'
-        with pytest.raises(ValueError):
-            _ = b ^ (a + '0b1')
-        a = '0o707' ^ BitStream('0o777')
-        assert a.oct == '070'
-
-
-class TestSplit2:
-
-    def test_split(self):
-        a = BitStream('0b0 010100111 010100 0101 010')
-        a.pos = 20
-        subs = [i.bin for i in a.split('0b010')]
-        assert subs == ['0', '010100111', '010100', '0101', '010']
-        assert a.pos == 20
-
-    def test_split_corner_cases(self):
-        a = BitStream('0b000000')
-        bsl = a.split('0b1', False)
-        assert next(bsl) == a
-        with pytest.raises(StopIteration):
-            next(bsl)
-        b = BitStream()
-        bsl = b.split('0b001', False)
-        assert not next(bsl)
-        with pytest.raises(StopIteration):
-            _ = next(bsl)
-
-    def test_split_errors(self):
-        a = BitStream('0b0')
-        b = a.split('', False)
-        with pytest.raises(ValueError):
-            _ = next(b)
-
-    def test_slice_with_offset(self):
-        a = BitStream(bytes=b'\x00\xff\x00', offset=7)
-        b = a[7:12]
-        assert b.bin == '11000'
-
-    def test_split_with_maxsplit(self):
-        a = BitStream('0xaabbccbbccddbbccddee')
-        assert len(list(a.split('0xbb', bytealigned=True))) == 4
-        bsl = list(a.split('0xbb', count=1, bytealigned=True))
-        assert (len(bsl), bsl[0]) == (1, '0xaa')
-        bsl = list(a.split('0xbb', count=2, bytealigned=True))
-        assert len(bsl) == 2
-        assert bsl[0] == '0xaa'
-        assert bsl[1] == '0xbbcc'
-
-    def test_split_more(self):
-        s = BitStream('0b1100011001110110')
-        for i in range(10):
-            a = list(s.split('0b11', False, count=i))
-            b = list(s.split('0b11', False))[:i]
-            assert a == b
-        b = s.split('0b11', count=-1)
-        with pytest.raises(ValueError):
-            _ = next(b)
-
-    def test_split_startbit(self):
-        a = BitStream('0b0010101001000000001111')
-        bsl = a.split('0b001', bytealigned=False, start=1)
-        assert [x.bin for x in bsl] == ['010101', '001000000', '001111']
-        b = a.split('0b001', start=-100)
-        with pytest.raises(ValueError):
-            _ = next(b)
-        b = a.split('0b001', start=23)
-        with pytest.raises(ValueError):
-            _ = next(b)
-        b = a.split('0b1', start=10, end=9)
-        with pytest.raises(ValueError):
-            _ = next(b)
-
-    def test_split_startbit_byte_aligned(self):
-        a = BitStream('0x00ffffee')
-        bsl = list(a.split('0b111', start=9, bytealigned=True))
-        assert [x.bin for x in bsl] == ['1111111', '11111111', '11101110']
-
-    def test_split_endbit(self):
-        a = BitStream('0b000010001001011')
-        bsl = list(a.split('0b1', bytealigned=False, end=14))
-        assert [x.bin for x in bsl] == ['0000', '1000', '100', '10', '1']
-        assert list(a[4:12].split('0b0', False)) == list(a.split('0b0', start=4, end=12))
-        try:
-            list(a.split('0xffee', end=15))
-        except ValueError:
-            pytest.fail("ValueError raised unexpectedly")
-        # Whereas this one will when we call next()
-        bsl = a.split('0xffee', end=16)
-        with pytest.raises(ValueError):
-            _ = next(bsl)
-
-    def test_split_endbit_byte_aligned(self):
-        a = BitStream('0xff00ff')[:22]
-        bsl = list(a.split('0b 0000 0000 111', end=19))
-        assert [x.bin for x in bsl] == ['11111111', '00000000111']
-        bsl = list(a.split('0b 0000 0000 111', end=18))
-        assert [x.bin for x in bsl] == ['111111110000000011']
-
-    def test_split_max_split(self):
-        a = BitStream('0b1' * 20)
-        for i in range(10):
-            bsl = list(a.split('0b1', count=i))
-            assert len(bsl) == i
-
-    #######################
-
-    def test_explicit_auto(self):
-        with pytest.raises(bitstring.CreationError):
-            a = BitStream(auto='0x1')
-
-    def test_position_in_slice(self):
-        a = BitStream('0x00ffff00')
-        a.bytepos = 2
-        b = a[8:24]
-        assert b.bytepos == 0
-
-    def test_find_byte_aligned_with_bits(self):
-        a = BitStream('0x00112233445566778899')
-        a.find('0b0001', bytealigned=True)
-        assert a.bitpos == 8
-
-    def test_find_startbit_not_byte_aligned(self):
-        a = BitStream('0b0010000100')
-        found = a.find('0b1', start=4)
-        assert (found, a.bitpos) == ((7,), 7)
-        found = a.find('0b1', start=2)
-        assert (found, a.bitpos) == ((2,), 2)
-        found = a.find('0b1', bytealigned=False, start=8)
-        assert (found, a.bitpos) == ((), 2)
-
-    def test_find_endbit_not_byte_aligned(self):
-        a = BitStream('0b0010010000')
-        found = a.find('0b1', bytealigned=False, end=2)
-        assert (found, a.bitpos) == ((), 0)
-        found = a.find('0b1', end=3)
-        assert (found, a.bitpos) == ((2,), 2)
-        found = a.find('0b1', bytealigned=False, start=3, end=5)
-        assert (found, a.bitpos) == ((), 2)
-        found = a.find('0b1', start=3, end=6)
-        assert (found[0], a.bitpos) == (5, 5)
-
-    def test_find_startbit_byte_aligned(self):
-        a = BitStream('0xff001122ff0011ff')
-        a.pos = 40
-        found = a.find('0x22', start=23, bytealigned=True)
-        assert (found, a.bytepos) == ((24,), 3)
-        a.bytepos = 4
-        found = a.find('0x22', start=24, bytealigned=True)
-        assert (found, a.bytepos) == ((24,), 3)
-        found = a.find('0x22', start=25, bytealigned=True)
-        assert (found, a.pos) == ((), 24)
-        found = a.find('0b111', start=40, bytealigned=True)
-        assert (found, a.pos) == ((56,), 56)
-
-    def test_find_endbit_byte_aligned(self):
-        a = BitStream('0xff001122ff0011ff')
-        found = a.find('0x22', end=31, bytealigned=True)
-        assert not found
-        assert a.pos == 0
-        found = a.find('0x22', end=32, bytealigned=True)
-        assert found
-        assert a.pos == 24
-        assert found[0] == 24
-
-    def test_find_start_endbit_errors(self):
-        a = BitStream('0b00100')
-        with pytest.raises(ValueError):
-            _ = a.find('0b1', bytealigned=False, start=-100)
-        with pytest.raises(ValueError):
-            _ = a.find('0b1', end=6)
-        with pytest.raises(ValueError):
-            _ = a.find('0b1', start=4, end=3)
-        b = BitStream('0x0011223344')
-        with pytest.raises(ValueError):
-            _ = b.find('0x22', bytealigned=True, start=-100)
-        with pytest.raises(ValueError):
-            _ = b.find('0x22', end=41, bytealigned=True)
-
-    def test_prepend_and_append_again(self):
-        c = BitStream('0x1122334455667788')
-        c.bitpos = 40
-        c.append('0b1')
-        assert c.bitpos == len(c)
-        c = BitStream()
-        c.prepend('0x1234')
-        assert c.bytepos == 0
-        c = BitStream()
-        c.append('0x1234')
-        assert c.bytepos == 2
-        s = BitStream(bytes=b'\xff\xff', offset=2)
-        assert s.length == 14
-        t = BitStream(bytes=b'\x80', offset=1, length=2)
-        s.prepend(t)
-        assert s == '0x3fff'
-
-    def test_find_all(self):
-        a = BitStream('0b11111')
-        p = a.findall('0b1')
-        assert list(p) == [0, 1, 2, 3, 4]
-        p = a.findall('0b11')
-        assert list(p) == [0, 1, 2, 3]
-        p = a.findall('0b10')
-        assert list(p) == []
-        a = BitStream('0x4733eeff66554747335832434547')
-        p = a.findall('0x47', bytealigned=True)
-        assert list(p) == [0, 6 * 8, 7 * 8, 13 * 8]
-        p = a.findall('0x4733', bytealigned=True)
-        assert list(p) == [0, 7 * 8]
-        a = BitStream('0b1001001001001001001')
-        p = a.findall('0b1001', bytealigned=False)
-        assert list(p) == [0, 3, 6, 9, 12, 15]
-        assert a.pos == 0
-
-    def test_find_all_generator(self):
-        a = BitStream('0xff1234512345ff1234ff12ff')
-        p = a.findall('0xff', bytealigned=True)
-        assert next(p) == 0
-        assert next(p) == 6 * 8
-        assert next(p) == 9 * 8
-        assert next(p) == 11 * 8
-        with pytest.raises(StopIteration):
-            _ = next(p)
-
-    def test_find_all_count(self):
-        s = BitStream('0b1') * 100
-        for i in [0, 1, 23]:
-            assert len(list(s.findall('0b1', count=i))) == i
-        with pytest.raises(ValueError):
-            _ = s.findall('0b1', bytealigned=True, count=-1)
-
-    def test_contains(self):
-        a = BitStream('0b1') + '0x0001dead0001'
-        assert '0xdead' in a
-        assert a.pos == 0
-        assert not '0xfeed' in a
-
-    def test_repr(self):
-        max_ = bitstring.bits.MAX_CHARS
-        bls = ['', '0b1', '0o5', '0x43412424f41', '0b00101001010101']
-        for bs in bls:
-            a = BitStream(bs)
-            b = eval(a.__repr__())
-            assert a == b
-        filename = os.path.join(THIS_DIR, 'test.m1v')
-        for f in [ConstBitStream(filename=filename),
-                  ConstBitStream(filename=filename, length=17),
-                  ConstBitStream(filename=filename, length=23, offset=23102)]:
-            f2 = eval(f.__repr__())
-            assert f2.tobytes() == f.tobytes()
-        a = BitStream('0b1')
-        assert repr(a) == "BitStream('0b1')"
-        a += '0b11'
-        a.pos = 2
-        assert repr(a) == "BitStream('0b111', pos=2)"
-        a.pos = 0
-        a += '0b1'
-        assert repr(a) == "BitStream('0xf', pos=4)"
-        a.pos = 0
-        a *= max_
-        assert repr(a) == "BitStream('0x" + "f" * max_ + "')"
-        a += '0xf'
-        assert repr(a) == "BitStream('0x" + "f" * max_ + "...', pos=1004)  # length=%d" % (max_ * 4 + 4)
-
-    def test_print(self):
-        s = BitStream(hex='0x00')
-        assert '0x' + s.hex == s.__str__()
-        s = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
-        assert '0x' + s[0: bitstring.bits.MAX_CHARS * 4].hex + '...' == s.__str__()
-        assert BitStream().__str__() == ''
-        s = BitStream('0b11010')
-        assert '0b' + s.bin == s.__str__()
-        s = BitStream('0x12345678901234567890,0b1')
-        assert '0x12345678901234567890, 0b1' == s.__str__()
-
-    def test_iter(self):
-        a = BitStream('0b001010')
-        b = BitStream()
-        for bit in a:
-            b.append(ConstBitStream(bool=bit))
-        assert a == b
-
-    def test_delitem(self):
-        a = BitStream('0xffee')
-        del a[0:8]
-        assert a.hex == 'ee'
-        del a[0:8]
-        assert not a
-        del a[10:12]
-        assert not a
-
-    def test_non_zero_bits_at_start(self):
-        a = BitStream(bytes=b'\xff', offset=2)
-        b = BitStream('0b00')
-        b += a
-        assert b == '0b0011 1111'
-        assert a.tobytes() == b'\xfc'
-
-    def test_non_zero_bits_at_end(self):
-        a = BitStream(bytes=b'\xff', length=5)
-        b = BitStream('0b00')
-        a += b
-        assert a == '0b1111100'
-        assert a.tobytes() == b'\xf8'
-        with pytest.raises(ValueError):
-            _ = a.bytes
-
-    def test_new_offset_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream(hex='ff', offset=-1)
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream('0xffffffff', offset=33)
-
-    def test_slice_step(self):
-        a = BitStream('0x3')
-        b = a[::1]
-        assert a == b
-        assert a[2:4:1] == '0b11'
-        assert a[0:2:1] == '0b00'
-        assert a[:3] == '0o1'
-
-        a = BitStream('0x0011223344556677')
-        assert a[-8:] == '0x77'
-        assert a[:-24] == '0x0011223344'
-        assert a[-1000:-24] == '0x0011223344'
-
-    def test_interesting_slice_step(self):
-        a = BitStream('0b0011000111')
-        assert a[7:3:-1] == '0b1000'
-        assert a[9:2:-1] == '0b1110001'
-        assert a[8:2:-2] == '0b100'
-        assert a[100:-20:-3] == '0b1010'
-        assert a[100:-20:-1] == '0b1110001100'
-        assert a[10:2:-1] == '0b1110001'
-        assert a[100:2:-1] == '0b1110001'
-
-    def test_insertion_order_and_bitpos(self):
-        b = BitStream()
-        b[0:0] = '0b0'
-        b[0:0] = '0b1'
-        assert b == '0b10'
-        assert b.bitpos == 0
-        a = BitStream()
-        a.insert('0b0')
-        a.insert('0b1')
-        assert a == '0b01'
-        assert a.bitpos == 2
-
-    def test_overwrite_order_and_bitpos(self):
-        a = BitStream('0xff')
-        a.overwrite('0xa')
-        assert a == '0xaf'
-        assert a.bitpos == 4
-        a.overwrite('0xb')
-        assert a == '0xab'
-        assert a.bitpos == 8
-        a.overwrite('0xa', 4)
-        assert a == '0xaa'
-        assert a.bitpos == 8
-        a.overwrite(a, 0)
-        assert a == '0xaa'
-
-    def test_init_slice_with_int(self):
-        a = BitStream(length=8)
-        a[:] = 100
-        assert a.uint == 100
-        a[0] = 1
-        assert a.bin == '11100100'
-        a[1] = 0
-        assert a.bin == '10100100'
-        a[-1] = -1
-        assert a.bin == '10100101'
-        a[-3:] = -2
-        assert a.bin == '10100110'
-
-    def test_init_slice_with_int_errors(self):
-        a = BitStream('0b0000')
-        with pytest.raises(ValueError):
-            a[0:4] = 16
-        with pytest.raises(ValueError):
-            a[0:4] = -9
-        with pytest.raises(ValueError):
-            a[0] = 2
-        with pytest.raises(ValueError):
-            a[0] = -2
-
-    def test_reverse_with_slice(self):
-        a = BitStream('0x0012ff')
-        a.reverse()
-        assert a == '0xff4800'
-        a.reverse(8, 16)
-        assert a == '0xff1200'
-        b = a[8:16]
-        b.reverse()
-        a[8:16] = b
-        assert a == '0xff4800'
-
-    def test_reverse_with_slice_errors(self):
-        a = BitStream('0x123')
-        with pytest.raises(ValueError):
-            a.reverse(-1, 4)
-        with pytest.raises(ValueError):
-            a.reverse(10, 9)
-        with pytest.raises(ValueError):
-            a.reverse(1, 10000)
-
-    def test_initialise_from_list(self):
-        a = BitStream([])
-        assert not a
-        a = BitStream([True, False, [], [0], 'hello'])
-        assert a == '0b10011'
-        a += []
-        assert a == '0b10011'
-        a += [True, False, True]
-        assert a == '0b10011101'
-        a.find([12, 23])
-        assert a.pos == 3
-        assert [1, 0, False, True] == BitStream('0b1001')
-        a = [True] + BitStream('0b1')
-        assert a == '0b11'
-
-    def test_initialise_from_tuple(self):
-        a = BitStream(())
-        assert not a
-        a = BitStream((0, 1, '0', '1'))
-        assert '0b0111' == a
-        a.replace((True, True), [])
-        assert a == (False, True)
-
-    def test_cut(self):
-        a = BitStream('0x00112233445')
-        b = list(a.cut(8))
-        assert b == ['0x00', '0x11', '0x22', '0x33', '0x44', '0x5']
-        b = list(a.cut(4, 8, 16))
-        assert b == ['0x1', '0x1']
-        b = list(a.cut(4, 0, 44, 4))
-        assert b == ['0x0', '0x0', '0x1', '0x1']
-        a = BitStream()
-        b = list(a.cut(10))
-        assert not b
-
-    def test_cut_errors(self):
-        a = BitStream('0b1')
-        b = a.cut(1, 1, 2)
-        with pytest.raises(ValueError):
-            _ = next(b)
-        b = a.cut(1, -2, 1)
-        with pytest.raises(ValueError):
-            _ = next(b)
-        b = a.cut(0)
-        with pytest.raises(ValueError):
-            _ = next(b)
-        b = a.cut(1, count=-1)
-        with pytest.raises(ValueError):
-            _ = next(b)
-
-    def test_cut_problem(self):
-        s = BitStream('0x1234')
-        for n in list(s.cut(4)):
-            s.prepend(n)
-        assert s == '0x43211234'
-
-    def test_join_functions(self):
-        a = BitStream().join(['0xa', '0xb', '0b1111'])
-        assert a == '0xabf'
-        a = BitStream('0b1').join(['0b0' for _ in range(10)])
-        assert a == '0b0101010101010101010'
-        a = BitStream('0xff').join([])
-        assert not a
-        a = BitStream('0xff').join([Bits(5), '0xab', '0xabc'])
-        assert a == '0b00000, 0xffabffabc'
-
-    def test_adding_bitpos(self):
-        a = BitStream('0xff')
-        b = BitStream('0x00')
-        a.bitpos = b.bitpos = 8
-        c = a + b
-        assert c.bitpos == 0
-
-    def test_intelligent_read1(self):
-        a = BitStream(uint=123, length=23)
-        u = a.read('uint:23')
-        assert u == 123
-        assert a.pos == a.len
-        b = BitStream(int=-12, length=44)
-        i = b.read('int:44')
-        assert i == -12
-        assert b.pos == b.len
-        u2, i2 = (a + b).readlist('uint:23, int:44')
-        assert (u2, i2) == (123, -12)
-
-    def test_intelligent_read2(self):
-        a = BitStream(ue=822)
-        u = a.read('ue')
-        assert u == 822
-        assert a.pos == a.len
-        b = BitStream(se=-1001)
-        s = b.read('se')
-        assert s == -1001
-        assert b.pos == b.len
-        s, u1, u2 = (b + 2 * a).readlist('se, ue, ue')
-        assert (s, u1, u2) == (-1001, 822, 822)
-
-    def test_intelligent_read3(self):
-        a = BitStream('0x123') + '0b11101'
-        h = a.read('hex:12')
-        assert h == '123'
-        b = a.read(' bin : 5 ')
-        assert b == '11101'
-        c = '0b' + b + a
-        b, h = c.readlist('bin:5, hex:12')
-        assert (b, h) == ('11101', '123')
-
-    def test_intelligent_read4(self):
-        a = BitStream('0o007')
-        o = a.read('oct:9')
-        assert o == '007'
-        assert a.pos == a.len
-
-    def test_intelligent_read5(self):
-        a = BitStream('0x00112233')
-        c0, c1, c2 = a.readlist('bits:8, bits:8, bits:16')
-        assert (c0, c1, c2) == (BitStream('0x00'), BitStream('0x11'), BitStream('0x2233'))
-        a.pos = 0
-        c = a.read('bits:16')
-        assert c == BitStream('0x0011')
-
-    def test_intelligent_read6(self):
-        a = BitStream('0b000111000')
-        b1, b2, b3 = a.readlist('bin :3, int: 3, int:3')
-        assert b1 == '000'
-        assert b2 == -1
-        assert b3 == 0
-
-    def test_intelligent_read7(self):
-        a = BitStream('0x1234')
-        a1, a2, a3, a4 = a.readlist('bin:0, oct:0, hex:0, bits:0')
-        assert a1 == a2 == a3 == ''
-        assert not a4
-        with pytest.raises(ValueError):
-            _ = a.read('int:0')
-        with pytest.raises(ValueError):
-            _ = a.read('uint:0')
-        assert a.pos == 0
-
-    def test_intelligent_read8(self):
-        a = BitStream('0x123456')
-        for t in ['hex:1', 'oct:1', '-5', 'fred', 'bin:-2',
-                  'uint:p', 'uint:-2', 'int:u', 'int:-3', 'ses', 'uee', '-14']:
-            with pytest.raises(ValueError):
-                _ = a.read(t)
-
-    def test_intelligent_read9(self):
-        a = BitStream('0xff')
-        assert a.read('intle8') == -1
-
-    def test_intelligent_peek(self):
-        a = BitStream('0b01, 0x43, 0o4, uint:23=2, se=5, ue=3')
-        b, c, e = a.peeklist('bin:2, hex:8, oct:3')
-        assert (b, c, e) == ('01', '43', '4')
-        assert a.pos == 0
-        a.pos = 13
-        f, g, h = a.peeklist('uint:23, se, ue')
-        assert (f, g, h) == (2, 5, 3)
-        assert a.pos == 13
-
-    def test_read_multiple_bits(self):
-        s = BitStream('0x123456789abcdef')
-        a, b = s.readlist([4, 4])
-        assert a == '0x1'
-        assert b == '0x2'
-        c, d, e = s.readlist([8, 16, 8])
-        assert c == '0x34'
-        assert d == '0x5678'
-        assert e == '0x9a'
-
-    def test_peek_multiple_bits(self):
-        s = BitStream('0b1101, 0o721, 0x2234567')
-        a, b, c, d = s.peeklist([2, 1, 1, 9])
-        assert a == '0b11'
-        assert bool(b) == True
-        assert bool(c) == True
-        assert d == '0o721'
-        assert s.pos == 0
-        a, b = s.peeklist([4, 9])
-        assert a == '0b1101'
-        assert b == '0o721'
-        s.pos = 13
-        a, b = s.peeklist([16, 8])
-        assert a == '0x2234'
-        assert b == '0x56'
-        assert s.pos == 13
-
-    def test_difficult_prepends(self):
-        a = BitStream('0b1101011')
-        b = BitStream()
-        for i in range(10):
-            b.prepend(a)
-        assert b == a * 10
-
-    def test_packing_wrong_number_of_things(self):
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bin:1')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('', 100)
-
-    def test_pack_with_various_keys(self):
-        a = pack('uint10', uint10='0b1')
-        assert a == '0b1'
-        b = pack('0b110', **{'0b110': '0xfff'})
-        assert b == '0xfff'
-
-    def test_pack_with_variable_length(self):
-        for i in range(1, 11):
-            a = pack('uint:n', 0, n=i)
-            assert a.bin == '0' * i
-
-    def test_to_bytes(self):
-        a = BitStream(bytes=b'\xab\x00')
-        b = a.tobytes()
-        assert a.bytes == b
-        for i in range(7):
-            del a[-1:]
-            assert a.tobytes() == b'\xab\x00'
-        del a[-1:]
-        assert a.tobytes() == b'\xab'
-
-    def test_to_file(self):
-        filename = os.path.join(THIS_DIR, 'temp_bitstring_unit_testing_file')
-        a = BitStream('0x0000ff')[:17]
-        with open(filename, 'wb') as f:
-            a.tofile(f)
-        b = BitStream(filename=filename)
-        assert b == '0x000080'
-
-        a = BitStream('int:1000000=-1')
-        assert a.int == -1
-        with open(filename, 'wb') as f:
-            a.tofile(f)
-        b = BitStream(filename=filename)
-        assert b.int == -1
-        assert b.len == 1000000
-
-    def test_token_parser(self):
-        tp = bitstring.utils.tokenparser
-        assert tp('hex') == (True, [('hex', None, None)])
-        assert tp('hex=14') == (True, [('hex', None, '14')])
-        assert tp('0xef') == (False, [('0x', None, 'ef')])
-        assert tp('uint:12') == (False, [('uint', 12, None)])
-        assert tp('int:30=-1') == (False, [('int', 30, '-1')])
-        assert tp('bits10') == (False, [('bits', 10, None)])
-        assert tp('bits:10') == (False, [('bits', 10, None)])
-        assert tp('123') == (False, [('bits', 123, None)])
-        assert tp('123') == (False, [('bits', 123, None)])
-        assert tp('hex12', ('hex12',)) == (False, [('hex12', None, None)])
-        assert tp('2*bits:6') == (False, [('bits', 6, None), ('bits', 6, None)])
-
-    def test_token_parser_struct_codes(self):
-        tp = bitstring.utils.tokenparser
-        assert tp('>H') == (False, [('uintbe', 16, None)])
-        assert tp('<H') == (False, [('uintle', 16, None)])
-        assert tp('=H') == (False, [('uintne', 16, None)])
-        assert tp('@H') == (False, [('uintne', 16, None)])
-        assert tp('>b') == (False, [('int', 8, None)])
-        assert tp('<b') == (False, [('int', 8, None)])
-
-    def test_auto_from_file_object(self):
-        filename = os.path.join(THIS_DIR, 'test.m1v')
-        with open(filename, 'rb') as f:
-            s = ConstBitStream(f, offset=32, length=12)
-            assert s.uint == 352
-            t = ConstBitStream('0xf') + f
-            assert t.startswith('0xf000001b3160')
-            s2 = ConstBitStream(f)
-            t2 = BitStream('0xc')
-            t2.prepend(s2)
-            assert t2.startswith('0x000001b3')
-            assert t2.endswith('0xc')
-            with open(filename, 'rb') as b:
-                u = BitStream(bytes=b.read())
-                assert u == s2
-
-    def test_file_based_copy(self):
-        with open(os.path.join(THIS_DIR, 'smalltestfile'), 'rb') as f:
-            s = BitStream(f)
-            t = BitStream(s)
-            s.prepend('0b1')
-            assert s[1:] == t
-            s = BitStream(f)
-            t = copy.copy(s)
-            t.append('0b1')
-            assert s == t[:-1]
-
-    def test_big_endian_synonyms(self):
-        s = BitStream('0x12318276ef')
-        assert s.int == s.intbe
-        assert s.uint == s.uintbe
-        s = BitStream(intbe=-100, length=16)
-        assert s == 'int:16=-100'
-        s = BitStream(uintbe=13, length=24)
-        assert s == 'int:24=13'
-        s = BitStream('uintbe:32=1000')
-        assert s == 'uint:32=1000'
-        s = BitStream('intbe:8=2')
-        assert s == 'int:8=2'
-        assert s.read('intbe8') == 2
-        s.pos = 0
-        assert s.read('uintbe8') == 2
-
-    def test_big_endian_synonym_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream(uintbe=100, length=15)
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream(intbe=100, length=15)
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream('uintbe:17=100')
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream('intbe:7=2')
-        s = BitStream('0b1')
-        with pytest.raises(bitstring.InterpretError):
-            _ = s.intbe
-        with pytest.raises(bitstring.InterpretError):
-            _ = s.uintbe
-        with pytest.raises(ValueError):
-            _ = s.read('uintbe')
-        with pytest.raises(ValueError):
-            _ = s.read('intbe')
-
-    def test_little_endian_uint(self):
-        s = BitStream(uint=100, length=16)
-        assert s.uintle == 25600
-        s = BitStream(uintle=100, length=16)
-        assert s.uint == 25600
-        assert s.uintle == 100
-        s.uintle += 5
-        assert s.uintle == 105
-        s = BitStream('uintle:32=999')
-        assert s.uintle == 999
-        s.byteswap()
-        assert s.uint == 999
-        s = pack('uintle:24', 1001)
-        assert s.uintle == 1001
-        assert s.length == 24
-        assert s.read('uintle24') == 1001
-
-    def test_little_endian_int(self):
-        s = BitStream(int=100, length=16)
-        assert s.intle == 25600
-        s = BitStream(intle=100, length=16)
-        assert s.int == 25600
-        assert s.intle == 100
-        s.intle = 105
-        assert s.intle == 105
-        s = BitStream('intle:32=999')
-        assert s.intle == 999
-        s.byteswap()
-        assert s.int == 999
-        s = pack('intle:24', 1001)
-        assert s.intle == 1001
-        assert s.length == 24
-        assert s.read('intle24') == 1001
-
-    def test_little_endian_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream('uintle:15=10')
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream('intle:31=-999')
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream(uintle=100, length=15)
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream(intle=100, length=15)
-        s = BitStream('0xfff')
-        with pytest.raises(bitstring.InterpretError):
-            _ = s.intle
-        with pytest.raises(bitstring.InterpretError):
-            _ = s.uintle
-        with pytest.raises(ValueError):
-            _ = s.read('uintle')
-        with pytest.raises(ValueError):
-            _ = s.read('intle')
-
-    def test_struct_tokens1(self):
-        assert pack('<b', 23) == BitStream('intle:8=23')
-        assert pack('<B', 23) == BitStream('uintle:8=23')
-        assert pack('<h', 23) == BitStream('intle:16=23')
-        assert pack('<H', 23) == BitStream('uintle:16=23')
-        assert pack('<l', 23) == BitStream('intle:32=23')
-        assert pack('<L', 23) == BitStream('uintle:32=23')
-        assert pack('<q', 23) == BitStream('intle:64=23')
-        assert pack('<Q', 23) == BitStream('uintle:64=23')
-        assert pack('>b', 23) == BitStream('intbe:8=23')
-        assert pack('>B', 23) == BitStream('uintbe:8=23')
-        assert pack('>h', 23) == BitStream('intbe:16=23')
-        assert pack('>H', 23) == BitStream('uintbe:16=23')
-        assert pack('>l', 23) == BitStream('intbe:32=23')
-        assert pack('>L', 23) == BitStream('uintbe:32=23')
-        assert pack('>q', 23) == BitStream('intbe:64=23')
-        assert pack('>Q', 23) == BitStream('uintbe:64=23')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('<B', -1)
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('<H', -1)
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('<L', -1)
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('<Q', -1)
-
-    def test_struct_tokens2(self):
-        # I couldn't find a way to test both types of native endianness
-        # on a single machine, so only one set of tests will run.
-        if sys.byteorder == 'little':
-            assert pack('=b', 23) == BitStream('intle:8=23')
-            assert pack('=B', 23) == BitStream('uintle:8=23')
-            assert pack('=h', 23) == BitStream('intle:16=23')
-            assert pack('=H', 23) == BitStream('uintle:16=23')
-            assert pack('@l', 23) == BitStream('intle:32=23')
-            assert pack('@L', 23) == BitStream('uintle:32=23')
-            assert pack('@q', 23) == BitStream('intle:64=23')
-            assert pack('@Q', 23) == BitStream('uintle:64=23')
-        else:
-            assert pack('@b', 23) == BitStream('intbe:8=23')
-            assert pack('@B', 23) == BitStream('uintbe:8=23')
-            assert pack('@h', 23) == BitStream('intbe:16=23')
-            assert pack('@H', 23) == BitStream('uintbe:16=23')
-            assert pack('@l', 23) == BitStream('intbe:32=23')
-            assert pack('@L', 23) == BitStream('uintbe:32=23')
-            assert pack('@q', 23) == BitStream('intbe:64=23')
-            assert pack('@Q', 23) == BitStream('uintbe:64=23')
-
-    def test_native_endianness(self):
-        s = pack('=2L', 40, 40)
-        if sys.byteorder == 'little':
-            assert s == pack('<2L', 40, 40)
-        else:
-            assert sys.byteorder == 'big'
-            assert s == pack('>2L', 40, 40)
-
-    def test_struct_tokens3(self):
-        s = pack('>hhl', 1, 2, 3)
-        a, b, c = s.unpack('>hhl')
-        assert (a, b, c) == (1, 2, 3)
-        s = pack('<QL, >Q \tL', 1001, 43, 21, 9999)
-        assert s.unpack('<QL, >QL') == [1001, 43, 21, 9999]
-
-    def test_struct_tokens_multiplicative_factors(self):
-        s = pack('<2h', 1, 2)
-        a, b = s.unpack('<2h')
-        assert (a, b) == (1, 2)
-        s = pack('<100q', *range(100))
-        assert s.len == 100 * 64
-        assert s[44*64:45*64].uintle == 44
-        s = pack('@L0B2h', 5, 5, 5)
-        assert s.unpack('@Lhh') == [5, 5, 5]
-
-    def test_struct_tokens_errors(self):
-        for f in ['>>q', '<>q', 'q>', '2q', 'q', '>-2q', '@a', '>int:8', '>q2']:
-            with pytest.raises(bitstring.CreationError):
-                _ = pack(f, 100)
-
-    def test_immutable_bit_streams(self):
-        a = ConstBitStream('0x012345')
-        assert a == '0x012345'
-        b = BitStream('0xf') + a
-        assert b == '0xf012345'
-        with pytest.raises(AttributeError):
-            a.append(b)
-        with pytest.raises(AttributeError):
-            a.prepend(b)
-        with pytest.raises(TypeError):
-            a[0] = '0b1'
-        with pytest.raises(TypeError):
-            del a[5]
-        with pytest.raises(AttributeError):
-            a.replace('0b1', '0b0')
-        with pytest.raises(AttributeError):
-            a.insert('0b11', 4)
-        with pytest.raises(AttributeError):
-            a.reverse()
-        with pytest.raises(AttributeError):
-            a.reversebytes()
-        assert a == '0x012345'
-        assert isinstance(a, ConstBitStream)
-
-    def test_reverse_bytes(self):
-        a = BitStream('0x123456')
-        a.byteswap()
-        assert a == '0x563412'
-        b = a + '0b1'
-        b.byteswap()
-        assert '0x123456, 0b1' == b
-        a = BitStream('0x54')
-        a.byteswap()
-        assert a == '0x54'
-        a = BitStream()
-        a.byteswap()
-        assert not a
-
-    def test_reverse_bytes2(self):
-        a = BitStream()
-        a.byteswap()
-        assert not a
-        a = BitStream('0x00112233')
-        a.byteswap(0, 0, 16)
-        assert a == '0x11002233'
-        a.byteswap(0, 4, 28)
-        assert a == '0x12302103'
-        a.byteswap(start=0, end=18)
-        assert a == '0x30122103'
-        with pytest.raises(ValueError):
-            a.byteswap(0, 10, 2)
-        with pytest.raises(ValueError):
-            a.byteswap(0, -4, 4)
-        with pytest.raises(ValueError):
-            a.byteswap(0, 24, 48)
-        a.byteswap(0, 24)
-        assert a == '0x30122103'
-        a.byteswap(0, 11, 11)
-        assert a == '0x30122103'
-
-    def test_capitals_in_pack(self):
-        a = pack('A', A='0b1')
-        assert a == '0b1'
-        format_ = 'bits:4=BL_OFFT, uint:12=width, uint:12=height'
-        d = {'BL_OFFT': '0b1011', 'width': 352, 'height': 288}
-        s = bitstring.pack(format_, **d)
-        assert s == '0b1011, uint:12=352, uint:12=288'
-        a = pack('0X0, uint:8, hex', 45, '0XABcD')
-        assert a == '0x0, uint:8=45, 0xabCD'
-
-    def test_other_capitals(self):
-        a = ConstBitStream('0XABC, 0O0, 0B11')
-        assert a == 'hex=0Xabc, oct=0, bin=0B11'
-
-    def test_efficient_overwrite(self):
-        a = BitStream(100000000)
-        a.overwrite([1], 123456)
-        assert a[123456] == True
-        a.overwrite('0xff', 1)
-        assert a[0:32:1] == '0x7f800000'
-        b = BitStream('0xffff')
-        b.overwrite('0x0000')
-        assert b == '0x0000'
-        assert b.pos == 16
-        c = BitStream(length=1000)
-        c.overwrite('0xaaaaaaaaaaaa', 81)
-        assert c[81:81 + 6 * 8] == '0xaaaaaaaaaaaa'
-        assert len(list(c.findall('0b1'))) == 24
-        s = BitStream(length=1000)
-        s = s[5:]
-        s.overwrite('0xffffff', 500)
-        s.pos = 500
-        assert s.read(4 * 8) == '0xffffff00'
-        s.overwrite('0xff', 502)
-        assert s[502:518] == '0xffff'
-
-    def test_peek_and_read_list_errors(self):
-        a = BitStream('0x123456')
-        with pytest.raises(ValueError):
-            _ = a.read('hex:8, hex:8')
-        with pytest.raises(ValueError):
-            _ = a.peek('hex:8, hex:8')
-        with pytest.raises(TypeError):
-            _ = a.read(10, 12)
-        with pytest.raises(TypeError):
-            _ = a.peek(12, 14)
-        with pytest.raises(TypeError):
-            _ = a.read(8, 8)
-        with pytest.raises(TypeError):
-            _ = a.peek(80, 80)
-
-    def test_startswith(self):
-        a = BitStream()
-        assert a.startswith(BitStream())
-        assert not a.startswith('0b0')
-        a = BitStream('0x12ff')
-        assert a.startswith('0x1')
-        assert a.startswith('0b0001001')
-        assert a.startswith('0x12ff')
-        assert not a.startswith('0x12ff, 0b1')
-        assert not a.startswith('0x2')
-
-    def test_startswith_start_end(self):
-        s = BitStream('0x123456')
-        assert s.startswith('0x234', 4)
-        assert not s.startswith('0x123', end=11)
-        assert s.startswith('0x123', end=12)
-        assert s.startswith('0x34', 8, 16)
-        assert not s.startswith('0x34', 7, 16)
-        assert not s.startswith('0x34', 9, 16)
-        assert not s.startswith('0x34', 8, 15)
-
-    def test_endswith(self):
-        a = BitStream()
-        assert a.endswith('')
-        assert not a.endswith(BitStream('0b1'))
-        a = BitStream('0xf2341')
-        assert a.endswith('0x41')
-        assert a.endswith('0b001')
-        assert a.endswith('0xf2341')
-        assert not a.endswith('0x1f2341')
-        assert not a.endswith('0o34')
-
-    def test_endswith_start_end(self):
-        s = BitStream('0x123456')
-        assert s.endswith('0x234', end=16)
-        assert not s.endswith('0x456', start=13)
-        assert s.endswith('0x456', start=12)
-        assert s.endswith('0x34', 8, 16)
-        assert s.endswith('0x34', 7, 16)
-        assert not s.endswith('0x34', 9, 16)
-        assert not s.endswith('0x34', 8, 15)
-
-    def test_unhashability(self):
-        s = BitStream('0xf')
-        with pytest.raises(TypeError):
-            _ = {s}
-        with pytest.raises(TypeError):
-            _ = hash([s])
-
-    def test_const_bit_stream_set_creation(self):
-        sl = [ConstBitStream(uint=i, length=7) for i in range(15)]
-        s = set(sl)
-        assert len(s) == 15
-        s.add(ConstBitStream('0b0000011'))
-        assert len(s) == 15
-        with pytest.raises(TypeError):
-            s.add(BitStream('0b0000011'))
-
-    def test_const_bit_stream_functions(self):
-        s = ConstBitStream('0xf, 0b1')
-        assert type(s) == ConstBitStream
-        t = copy.copy(s)
-        assert type(t) == ConstBitStream
-        a = s + '0o3'
-        assert type(a) == ConstBitStream
-        b = a[0:4]
-        assert type(b) == ConstBitStream
-        b = a[4:3]
-        assert type(b) == ConstBitStream
-        b = a[5:2:-1]
-        assert type(b) == ConstBitStream
-        b = ~a
-        assert type(b) == ConstBitStream
-        b = a << 2
-        assert type(b) == ConstBitStream
-        b = a >> 2
-        assert type(b) == ConstBitStream
-        b = a * 2
-        assert type(b) == ConstBitStream
-        b = a * 0
-        assert type(b) == ConstBitStream
-        b = a & ~a
-        assert type(b) == ConstBitStream
-        b = a | ~a
-        assert type(b) == ConstBitStream
-        b = a ^ ~a
-        assert type(b) == ConstBitStream
-        b = a._slice(4, 4)
-        assert type(b) == ConstBitStream
-        b = a.read(4)
-        assert type(b) == ConstBitStream
-
-    def test_const_bit_stream_properties(self):
-        a = ConstBitStream('0x123123')
-        with pytest.raises(AttributeError):
-            a.hex = '0x234'
-        with pytest.raises(AttributeError):
-            a.oct = '0o234'
-        with pytest.raises(AttributeError):
-            a.bin = '0b101'
-        with pytest.raises(AttributeError):
-            a.ue = 3453
-        with pytest.raises(AttributeError):
-            a.se = -123
-        with pytest.raises(AttributeError):
-            a.int = 432
-        with pytest.raises(AttributeError):
-            a.uint = 4412
-        with pytest.raises(AttributeError):
-            a.intle = 123
-        with pytest.raises(AttributeError):
-            a.uintle = 4412
-        with pytest.raises(AttributeError):
-            a.intbe = 123
-        with pytest.raises(AttributeError):
-            a.uintbe = 4412
-        with pytest.raises(AttributeError):
-            a.intne = 123
-        with pytest.raises(AttributeError):
-            a.uintne = 4412
-        with pytest.raises(AttributeError):
-            a.bytes = b'hello'
-
-    def test_const_bit_stream_misc(self):
-        a = ConstBitStream('0xf')
-        b = a
-        a += '0xe'
-        assert b == '0xf'
-        assert a == '0xfe'
-        c = BitStream(a)
-        assert a == c
-        a = ConstBitStream('0b1')
-        a += a
-        assert a == '0b11'
-        assert type(a) == ConstBitStream
-        a._addleft(a)
-        assert a == '0b1111'
-        assert type(a) == ConstBitStream
-
-    def test_const_bit_stream_hashibility(self):
-        a = ConstBitStream('0x1')
-        b = ConstBitStream('0x2')
-        c = ConstBitStream('0x1')
-        c.pos = 3
-        s = {a, b, c}
-        assert len(s) == 2
-        assert hash(a) == hash(c)
-
-    def test_const_hashability_again(self):
-        a = ConstBitStream(uint=1 << 300, length=10000)
-        b = ConstBitStream(uint=2 << 300, length=10000)
-        c = ConstBitStream(uint=3 << 300, length=10000)
-        s = {a, b, c}
-        assert len(s) == 3
-
-    def test_hash_edge_cases(self):
-        a = ConstBitStream('0xabcd')
-        b = ConstBitStream('0xabcd')
-        c = b[1:]
-        assert hash(a) == hash(b)
-        assert hash(a) != hash(c)
-
-    def test_const_bit_stream_copy(self):
-        a = ConstBitStream('0xabc')
-        a.pos = 11
-        b = copy.copy(a)
-        b.pos = 4
-        assert id(a._bitstore) == id(b._bitstore)
-        assert a.pos == 11
-        assert b.pos == 4
-
-    def test_python26stuff(self):
-        s = BitStream('0xff')
-        assert isinstance(s.tobytes(), bytes)
-        assert isinstance(s.bytes, bytes)
-
-    def test_read_from_bits(self):
-        a = ConstBitStream('0xaabbccdd')
-        b = a.read(8)
-        assert b == '0xaa'
-        assert a[0:8] == '0xaa'
-        assert a[-1] == True
-        a.pos = 0
-        assert a.read(4).uint == 10
-
-
-class TestSet:
-    def test_set(self):
-        a = BitStream(length=16)
-        a.set(True, 0)
-        assert a == '0b10000000 00000000'
-        a.set(1, 15)
-        assert a == '0b10000000 00000001'
-        b = a[4:12]
-        b.set(True, 1)
-        assert b == '0b01000000'
-        b.set(True, -1)
-        assert b == '0b01000001'
-        b.set(1, -8)
-        assert b == '0b11000001'
-        with pytest.raises(IndexError):
-            b.set(True, -9)
-        with pytest.raises(IndexError):
-            b.set(True, 8)
-
-    def test_set_negative_index(self):
-        a = BitStream(10)
-        a.set(1, -1)
-        assert a.bin == '0000000001'
-        a.set(1, [-1, -10])
-        assert a.bin == '1000000001'
-        with pytest.raises(IndexError):
-            a.set(1, [-11])
-
-    def test_file_based_set_unset(self):
-        filename = os.path.join(THIS_DIR, 'test.m1v')
-        a = BitStream(filename=filename)
-        a.set(True, (0, 1, 2, 3, 4))
-        assert a[0:32] == '0xf80001b3'
-        a = BitStream(filename=filename)
-        a.set(False, (28, 29, 30, 31))
-        assert a.startswith('0x000001b0')
-
-    def test_set_list(self):
-        a = BitStream(length=18)
-        a.set(True, range(18))
-        assert a.int == -1
-        a.set(False, range(18))
-        assert a.int == 0
-
-    def test_unset(self):
-        a = BitStream(length=16, int=-1)
-        a.set(False, 0)
-        assert ~a == '0b10000000 00000000'
-        a.set(0, 15)
-        assert ~a == '0b10000000 00000001'
-        b = a[4:12]
-        b.set(False, 1)
-        assert ~b == '0b01000000'
-        b.set(False, -1)
-        assert ~b == '0b01000001'
-        b.set(False, -8)
-        assert ~b == '0b11000001'
-        with pytest.raises(IndexError):
-            b.set(False, -9)
-        with pytest.raises(IndexError):
-            b.set(False, 8)
-
-    def test_set_whole_bit_stream(self):
-        a = BitStream(10000)
-        a.set(1)
-        assert a.all(1)
-        a.set(0)
-        assert a.all(0)
-
-
-class TestInvert:
-    def test_invert_bits(self):
-        a = BitStream('0b111000')
-        a.invert(range(a.len))
-        assert a == '0b000111'
-        a.invert([0, 1, -1])
-        assert a == '0b110110'
-
-    def test_invert_whole_bit_stream(self):
-        a = BitStream('0b11011')
-        a.invert()
-        assert a == '0b00100'
-
-    def test_invert_single_bit(self):
-        a = BitStream('0b000001')
-        a.invert(0)
-        assert a.bin == '100001'
-        a.invert(-1)
-        assert a.bin == '100000'
-
-    def test_invert_errors(self):
-        a = BitStream(10)
-        with pytest.raises(IndexError):
-            a.invert(10)
-        with pytest.raises(IndexError):
-            a.invert(-11)
-        with pytest.raises(IndexError):
-            a.invert([1, 2, 10])
-
-    def test_ior(self):
-        a = BitStream('0b1101001')
-        a |= '0b1110000'
-        assert a == '0b1111001'
-        b = a[2:]
-        c = a[1:-1]
-        b |= c
-        assert c == '0b11100'
-        assert b == '0b11101'
-
-    def test_iand(self):
-        a = BitStream('0b0101010101000')
-        a &= '0b1111110000000'
-        assert a == '0b0101010000000'
-        s = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'), offset=26, length=24)
-        s &= '0xff00ff'
-        assert s == '0xcc0004'
-
-    def test_ixor(self):
-        a = BitStream('0b11001100110011')
-        a ^= '0b11111100000010'
-        assert a == '0b00110000110001'
-
-    def test_logical_inplace_errors(self):
-        a = BitStream(4)
-        with pytest.raises(ValueError):
-            a |= '0b111'
-        with pytest.raises(ValueError):
-            a &= '0b111'
-        with pytest.raises(ValueError):
-            a ^= '0b111'
-
-
-class TestAllAndAny:
-    def test_all(self):
-        a = BitStream('0b0111')
-        assert a.all(True, (1, 3))
-        assert not a.all(True, (0, 1, 2))
-        assert a.all(True, [-1])
-        assert not a.all(True, [0])
-
-    def test_file_based_all(self):
-        filename = os.path.join(THIS_DIR, 'test.m1v')
-        a = BitStream(filename=filename)
-        assert a.all(True, [31])
-        a = BitStream(filename=filename)
-        assert a.all(False, (0, 1, 2, 3, 4))
-
-    def test_file_based_any(self):
-        filename = os.path.join(THIS_DIR, 'test.m1v')
-        a = BitStream(filename=filename)
-        assert a.any(True, (31, 12))
-        a = BitStream(filename=filename)
-        assert a.any(False, (0, 1, 2, 3, 4))
-        b = ConstBitStream(filename=filename, offset=16)
-        assert b.startswith('0x01')
-        assert not b.any(True, range(0, 7))
-        assert b.any(True, range(0, 8))
-        assert b.any(True)
-
-    def test_any(self):
-        a = BitStream('0b10011011')
-        assert a.any(True, (1, 2, 3, 5))
-        assert not a.any(True, (1, 2, 5))
-        assert a.any(True, (-1,))
-        assert not a.any(True, (1,))
-
-    def test_all_false(self):
-        a = BitStream('0b0010011101')
-        assert a.all(False, (0, 1, 3, 4))
-        assert not a.all(False, (0, 1, 2, 3, 4))
-
-    def test_any_false(self):
-        a = BitStream('0b01001110110111111111111111111')
-        assert a.any(False, (4, 5, 6, 2))
-        assert not a.any(False, (1, 15, 20))
-
-    def test_any_empty_bitstring(self):
-        a = ConstBitStream()
-        assert not a.any(True)
-        assert not a.any(False)
-
-    def test_all_empty_bit_stream(self):
-        a = ConstBitStream()
-        assert a.all(True)
-        assert a.all(False)
-
-    def test_any_whole_bitstring(self):
-        a = ConstBitStream('0xfff')
-        assert a.any(True)
-        assert not a.any(False)
-
-    def test_all_whole_bitstring(self):
-        a = ConstBitStream('0xfff')
-        assert a.all(True)
-        assert not a.all(False)
-
-    def test_errors(self):
-        a = BitStream('0xf')
-        with pytest.raises(IndexError):
-            a.all(True, [5])
-        with pytest.raises(IndexError):
-            a.all(True, [-5])
-        with pytest.raises(IndexError):
-            a.any(True, [5])
-        with pytest.raises(IndexError):
-            a.any(True, [-5])
-
-    ###################
-
-    def test_float_initialisation(self):
-        for f in (0.000001, -1.0, 1.0, 0.2, -3.14159265):
-            a = BitStream(float=f, length=64)
-            a.pos = 6
-            assert a.float == f
-            a = BitStream('float:64=%s' % str(f))
-            a.pos = 6
-            assert a.float == f
-            a = BitStream('floatbe:64=%s' % str(f))
-            a.pos = 6
-            assert a.floatbe == f
-            a = BitStream('floatle:64=%s' % str(f))
-            a.pos = 6
-            assert a.floatle == f
-            a = BitStream('floatne:64=%s' % str(f))
-            a.pos = 6
-            assert a.floatne == f
-
-            b = BitStream(float=f, length=32)
-            b.pos = 6
-            assert b.float / f == pytest.approx(1.0)
-            b = BitStream('float:32=%s' % str(f))
-            b.pos = 6
-            assert b.float / f == pytest.approx(1.0)
-            b = BitStream('floatbe:32=%s' % str(f))
-            b.pos = 6
-            assert b.floatbe / f == pytest.approx(1.0)
-            b = BitStream('floatle:32=%s' % str(f))
-            b.pos = 6
-            assert b.floatle / f == pytest.approx(1.0)
-            b = BitStream('floatne:32=%s' % str(f))
-            b.pos = 6
-            assert b.floatne / f == pytest.approx(1.0)
-
-            a = BitStream(float=f, length=16)
-            a.pos = 6
-            assert a.float == pytest.approx(f, abs=0.01)
-            a = BitStream('float:16=%s' % str(f))
-            a.pos = 6
-            assert a.float == pytest.approx(f, abs=0.01)
-            a = BitStream('floatbe:16=%s' % str(f))
-            a.pos = 6
-            assert a.floatbe == pytest.approx(f, abs=0.01)
-            a = BitStream('floatle:16=%s' % str(f))
-            a.pos = 6
-            assert a.floatle == pytest.approx(f, abs=0.01)
-            a = BitStream('floatne:16=%s' % str(f))
-            a.pos = 6
-            assert a.floatne == pytest.approx(f, abs=0.01)
-
-        a = BitStream('0x12345678')
-        a.pos = 6
-        a.f = 23
-        assert a.f == 23.0
-
-    def test_float_init_strings(self):
-        for s in ('5', '+0.0001', '-1e101', '4.', '.2', '-.65', '43.21E+32'):
-            a = BitStream('float:64=%s' % s)
-            assert a.float == float(s)
-        for s in ('5', '+0.5', '-1e2', '4.', '.25', '-.75'):
-            a = BitStream('float:16=%s' % s)
-            assert a.f == float(s)
-
-    def test_float_packing(self):
-        a = pack('>d', 0.01)
-        assert a.float == 0.01
-        assert a.floatbe == 0.01
-        a.byteswap()
-        assert a.floatle == 0.01
-        b = pack('>f', 1e10)
-        assert b.float / 1e10 == pytest.approx(1.0)
-        c = pack('<f', 10.3)
-        assert c.floatle / 10.3 == pytest.approx(1.0)
-        d = pack('>5d', 10.0, 5.0, 2.5, 1.25, 0.1)
-        assert d.unpack('>5d') == [10.0, 5.0, 2.5, 1.25, 0.1]
-        e = pack('>3e', -100, 100, 0.25)
-        assert e.unpack('>3e') == [-100.0, 100.0, 0.25]
-
-    def test_float_reading(self):
-        a = BitStream('floatle:64=12, floatbe:64=-0.01, floatne:64=3e33')
-        x, y, z = a.readlist('floatle:64, floatbe:64, floatne:64')
-        assert x == 12.0
-        assert y == -0.01
-        assert z == 3e33
-        a = BitStream('floatle:16=12, floatbe:32=-0.01, floatne:32=3e33')
-        x, y, z = a.readlist('floatle:16, floatbe:32, floatne:32')
-        assert x / 12.0 == pytest.approx(1.0)
-        assert y / -0.01 == pytest.approx(1.0)
-        assert z / 3e33 == pytest.approx(1.0)
-        a = BitStream('0b11, floatle:64=12, 0xfffff')
-        a.pos = 2
-        floatle64 = Dtype('floatle64')
-        assert a.read(floatle64) == 12.0
-        b = BitStream(floatle=20, length=32)
-        b.floatle = 10.0
-        b = [0] + b
-        assert b[1:].floatle == 10.0
-
-    def test_non_aligned_float_reading(self):
-        s = BitStream('0b1, float:32 = 10.0')
-        x, y = s.readlist('1, float:32')
-        assert y == 10.0
-        s[1:] = 'floatle:32=20.0'
-        x, y = s.unpack('1, floatle:32')
-        assert y == 20.0
-
-    def test_float_errors(self):
-        a = BitStream('0x3')
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.float
-        with pytest.raises(bitstring.CreationError):
-            a.float = -0.2
-        for le in (8, 10, 12, 18, 30, 128, 200):
-            with pytest.raises(ValueError):
-                _ = BitStream(float=1.0, length=le)
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream(floatle=0.3, length=0)
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream(floatle=0.3, length=1)
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream(float=2)
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.read('floatle:2')
-
-    def test_read_error_changes_pos(self):
-        a = BitStream('0x123123')
-        with pytest.raises(ValueError):
-            a.read('10, 5')
-
-    def test_ror(self):
-        a = BitStream('0b11001')
-        a.ror(0)
-        assert a == '0b11001'
-        a.ror(1)
-        assert a == '0b11100'
-        a.ror(5)
-        assert a == '0b11100'
-        a.ror(101)
-        assert a == '0b01110'
-        a = BitStream('0b1')
-        a.ror(1000000)
-        assert a == '0b1'
-
-    def test_ror_errors(self):
-        a = BitStream()
-        with pytest.raises(bitstring.Error):
-            a.ror(0)
-        a += '0b001'
-        with pytest.raises(ValueError):
-            a.ror(-1)
-
-    def test_rol(self):
-        a = BitStream('0b11001')
-        a.rol(0)
-        assert a == '0b11001'
-        a.rol(1)
-        assert a == '0b10011'
-        a.rol(5)
-        assert a == '0b10011'
-        a.rol(101)
-        assert a == '0b00111'
-        a = BitStream('0b1')
-        a.rol(1000000)
-        assert a == '0b1'
-
-    def test_rol_from_file(self):
-        a = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
-        m = a.len
-        a.rol(1)
-        assert a.startswith('0x000003')
-        assert a.len == m
-        assert a.endswith('0x0036e')
-
-    def test_ror_from_file(self):
-        a = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
-        m = a.len
-        a.ror(1)
-        assert a.startswith('0x800000')
-        assert a.len == m
-        assert a.endswith('0x000db')
-
-    def test_rol_errors(self):
-        a = BitStream()
-        with pytest.raises(bitstring.Error):
-            a.rol(0)
-        a += '0b001'
-        with pytest.raises(ValueError):
-            a.rol(-1)
-
-    def test_bytes_token(self):
-        a = BitStream('0x510203')
-        b = a.read('bytes:1')
-        assert isinstance(b, bytes)
-        assert b == b'\x51'
-        x, y, z = a.unpack('uint:4, bytes:2, uint')
-        assert x == 5
-        assert y == b'\x10\x20'
-        assert z == 3
-        s = pack('bytes:4', b'abcd')
-        assert s.bytes == b'abcd'
-
-    def test_bytes_token_more_thoroughly(self):
-        a = BitStream('0x0123456789abcdef')
-        a.pos += 16
-        assert a.read('bytes:1') == b'\x45'
-        assert a.read('bytes:3') == b'\x67\x89\xab'
-        x, y, z = a.unpack('bits:28, bytes, bits:12')
-        assert y == b'\x78\x9a\xbc'
-
-    def test_dedicated_read_functions(self):
-        a = BitStream('0b11, uint:43=98798798172, 0b11111')
-        x = a[2:45].uint
-        assert x == 98798798172
-        assert a.pos == 0
-        a.pos = 2
-        x = a.read(Dtype('int43'))
-        assert x == 98798798172
-        assert a.pos == 45
-
-        a = BitStream('0b11, uintbe:48=98798798172, 0b11111')
-        a.pos = 2
-        x = a.read(Dtype('uintbe48'))
-        assert x == 98798798172
-        assert a.pos == 50
-
-        a = BitStream('0b111, uintle:40=123516, 0b111')
-        a.pos = 3
-        assert a.read('uintle:40') == 123516
-        b = BitStream('0xff, uintle:800=999, 0xffff')
-        assert b[8:800].uintle == 999
-
-        a = BitStream('0b111, intle:48=999999999, 0b111111111111')
-        a.pos = 3
-        assert a.read('intle48') == 999999999
-        b = BitStream('0xff, intle:200=918019283740918263512351235, 0xfffffff')
-        b.pos = 8
-        assert b.read(Dtype('intle', length=200)) == 918019283740918263512351235
-
-        a = BitStream('0b111, bfloat:16=-5.25, 0xffffffff')
-        a.pos = 3
-        assert a.read('bfloatbe') == -5.25
-
-        a = BitStream('0b111, floatle:64=9.9998, 0b111')
-        a.pos = 3
-        assert a.read('floatle64') == 9.9998
-
-    def test_auto_init_with_int(self):
-        a = BitStream(0)
-        assert not a
-        a = BitStream(1)
-        assert a == '0b0'
-        a = BitStream(1007)
-        assert a == BitStream(length=1007)
-        with pytest.raises(bitstring.CreationError):
-            _ = BitStream(-1)
-
-        assert ConstBitStream(13) == Bits(13)
-        with pytest.raises(TypeError):
-            a += 10
-
-    def test_reading_problems(self):
-        a = BitStream('0x000001')
-        b = a.read('uint:24')
-        assert b == 1
-        a.pos = 0
-        with pytest.raises(bitstring.ReadError):
-            _ = a.read('bytes:4')
-
-    @pytest.mark.skip("Bug #266")
-    def test_pos_reset_bug(self):
-        a = BitStream('0x0120310230123', pos=23)
-        assert a.pos == 23
-        a.u8 = 14
-        assert a.pos == 0
-        a.pos = 5
-        a.u8 = 9
-        assert a.pos == 0
-
-    def test_creation_exception_bug(self):
-        with pytest.raises(ValueError):
-            _ = BitStream(bin=1)
-
-    def test_add_verses_in_place_add(self):
-        a1 = ConstBitStream('0xabc')
-        b1 = a1
-        a1 += '0xdef'
-        assert a1 == '0xabcdef'
-        assert b1 == '0xabc'
-
-        a2 = BitStream('0xabc')
-        b2 = a2
-        c2 = a2 + '0x0'
-        a2 += '0xdef'
-        assert a2 == '0xabcdef'
-        assert b2 == '0xabcdef'
-        assert c2 == '0xabc0'
-
-    def test_and_verses_in_place_and(self):
-        a1 = ConstBitStream('0xabc')
-        b1 = a1
-        a1 &= '0xf0f'
-        assert a1 == '0xa0c'
-        assert b1 == '0xabc'
-
-        a2 = BitStream('0xabc')
-        b2 = a2
-        c2 = a2 & '0x00f'
-        a2 &= '0xf0f'
-        assert a2 == '0xa0c'
-        assert b2 == '0xa0c'
-        assert c2 == '0x00c'
-
-    def test_or_verses_in_place_or(self):
-        a1 = ConstBitStream('0xabc')
-        b1 = a1
-        a1 |= '0xf0f'
-        assert a1 == '0xfbf'
-        assert b1 == '0xabc'
-
-        a2 = BitStream('0xabc')
-        b2 = a2
-        c2 = a2 | '0x00f'
-        a2 |= '0xf0f'
-        assert a2 == '0xfbf'
-        assert b2 == '0xfbf'
-        assert c2 == '0xabf'
-
-    def test_xor_verses_in_place_xor(self):
-        a1 = ConstBitStream('0xabc')
-        b1 = a1
-        a1 ^= '0xf0f'
-        assert a1 == '0x5b3'
-        assert b1 == '0xabc'
-
-        a2 = BitStream('0xabc')
-        b2 = a2
-        c2 = a2 ^ '0x00f'
-        a2 ^= '0xf0f'
-        assert a2 == '0x5b3'
-        assert b2 == '0x5b3'
-        assert c2 == '0xab3'
-
-    def test_mul_verses_in_place_mul(self):
-        a1 = ConstBitStream('0xabc')
-        b1 = a1
-        a1 *= 3
-        assert a1 == '0xabcabcabc'
-        assert b1 == '0xabc'
-
-        a2 = BitStream('0xabc')
-        b2 = a2
-        c2 = a2 * 2
-        a2 *= 3
-        assert a2 == '0xabcabcabc'
-        assert b2 == '0xabcabcabc'
-        assert c2 == '0xabcabc'
-
-    def test_lshift_verses_in_place_lshift(self):
-        a1 = ConstBitStream('0xabc')
-        b1 = a1
-        a1 <<= 4
-        assert a1 == '0xbc0'
-        assert b1 == '0xabc'
-
-        a2 = BitStream('0xabc')
-        b2 = a2
-        c2 = a2 << 8
-        a2 <<= 4
-        assert a2 == '0xbc0'
-        assert b2 == '0xbc0'
-        assert c2 == '0xc00'
-
-    def test_rshift_verses_in_place_rshift(self):
-        a1 = ConstBitStream('0xabc')
-        b1 = a1
-        a1 >>= 4
-        assert a1 == '0x0ab'
-        assert b1 == '0xabc'
-
-        a2 = BitStream('0xabc')
-        b2 = a2
-        c2 = a2 >> 8
-        a2 >>= 4
-        assert a2 == '0x0ab'
-        assert b2 == '0x0ab'
-        assert c2 == '0x00a'
-
-    def test_auto_from_bool(self):
-        with pytest.raises(TypeError):
-            a = ConstBitStream() + True + False + True
-
-
-class TestBugs:
-    def test_bug_in_replace(self):
-        s = BitStream('0x00112233')
-        li = list(s.split('0x22', start=8, bytealigned=True))
-        assert li == ['0x11', '0x2233']
-        s = BitStream('0x00112233')
-        s.replace('0x22', '0xffff', start=8, bytealigned=True)
-        assert s == '0x0011ffff33'
-        s = BitStream('0x0123412341234')
-        s.replace('0x23', '0xf', start=9, bytealigned=True)
-        assert s == '0x012341f41f4'
-
-    def test_truncateleft_bug(self):
-        a = BitStream('0b000000111')[2:]
-        a._truncateleft(6)
-        assert a == '0b1'
-
-    def test_null_bits(self):
-        s = ConstBitStream(bin='')
-        t = ConstBitStream(oct='')
-        u = ConstBitStream(hex='')
-        v = ConstBitStream(bytes=b'')
-        assert not s
-        assert not t
-        assert not u
-        assert not v
-
-    def test_multiplicative_factors_creation(self):
-        s = BitStream('1*0b1')
-        assert s == '0b1'
-        s = BitStream('4*0xc')
-        assert s == '0xcccc'
-        s = BitStream('0b1, 0*0b0')
-        assert s == '0b1'
-        s = BitStream('0b1, 3*uint:8=34, 2*0o755')
-        assert s == '0b1, uint:8=34, uint:8=34, uint:8=34, 0o755755'
-        s = BitStream('0*0b1001010')
-        assert not s
-
-    def test_multiplicative_factors_reading(self):
-        s = BitStream('0xc') * 5
-        a, b, c, d, e = s.readlist('5*uint:4')
-        assert a == b == c == d == e == 12
-        s = ConstBitStream('2*0b101, 4*uint:7=3')
-        a, b, c, d, e = s.readlist('2*bin:3, 3*uint:7')
-        assert a == b == '101'
-        assert c == d == e == 3
-
-    def test_multiplicative_factors_packing(self):
-        s = pack('3*bin', '1', '001', '101')
-        assert s == '0b1001101'
-        s = pack('hex, 2*se=-56, 3*uint:37', '34', 1, 2, 3)
-        a, b, c, d, e, f = s.unpack('hex:8, 2*se, 3*uint:37')
-        assert a == '34'
-        assert b == -56
-        assert c == -56
-        assert (d, e, f) == (1, 2, 3)
-
-    def test_multiplicative_factors_unpacking(self):
-        s = ConstBitStream('0b10111')
-        a, b, c, d = s.unpack('3*bool, bin')
-        assert (a, b, c) == (True, False, True)
-        assert d == '11'
-
-    def test_packing_default_int_with_keyword(self):
-        s = pack('uint:12', 100)
-        assert s.unpack('12')[0].uint == 100
-        s = pack('int:oh_no_not_the_eyes=33', oh_no_not_the_eyes=17)
-        assert s.int == 33
-        assert s.len == 17
-
-    def test_init_from_iterable(self):
-        assert isinstance(range(10), collections.abc.Iterable)
-        s = ConstBitStream(range(12))
-        assert s == '0x7ff'
-
-    def test_function_negative_indices(self):
-        # insert
-        s = BitStream('0b0111')
-        s.insert('0b0', -1)
-        assert s == '0b01101'
-        with pytest.raises(ValueError):
-            s.insert('0b0', -1000)
-
-        # reverse
-        s.reverse(-2)
-        assert s == '0b01110'
-        t = BitStream('0x778899abcdef')
-        t.reverse(-12, -4)
-        assert t == '0x778899abc7bf'
-
-        # reversebytes
-        t.byteswap(0, -40, -16)
-        assert t == '0x77ab9988c7bf'
-
-        # overwrite
-        t.overwrite('0x666', -20)
-        assert t == '0x77ab998666bf'
-
-        # find
-        found = t.find('0x998', bytealigned=True, start=-31)
-        assert not found
-        found = t.find('0x998', bytealigned=True, start=-32)
-        assert found
-        assert t.pos == 16
-        t.pos = 0
-        found = t.find('0x988', bytealigned=True, end=-21)
-        assert not found
-        found = t.find('0x998', bytealigned=True, end=-20)
-        assert found
-        assert t.pos == 16
-
-        # findall
-        s = BitStream('0x1234151f')
-        li = list(s.findall('0x1', bytealigned=True, start=-15))
-        assert li == [24]
-        li = list(s.findall('0x1', bytealigned=True, start=-16))
-        assert li == [16, 24]
-        li = list(s.findall('0x1', bytealigned=True, end=-5))
-        assert li == [0, 16]
-        li = list(s.findall('0x1', bytealigned=True, end=-4))
-        assert li == [0, 16, 24]
-
-        # rfind
-        found = s.rfind('0x1f', end=-1)
-        assert not found
-        found = s.rfind('0x12', start=-31)
-        assert not found
-
-        # cut
-        s = BitStream('0x12345')
-        li = list(s.cut(4, start=-12, end=-4))
-        assert li == ['0x3', '0x4']
-
-        # split
-        s = BitStream('0xfe0012fe1200fe')
-        li = list(s.split('0xfe', bytealigned=True, end=-1))
-        assert li == ['', '0xfe0012', '0xfe1200f, 0b111']
-        li = list(s.split('0xfe', bytealigned=True, start=-8))
-        assert li == ['', '0xfe']
-
-        # startswith
-        assert s.startswith('0x00f', start=-16)
-        assert s.startswith('0xfe00', end=-40)
-        assert not s.startswith('0xfe00', end=-41)
-
-        # endswith
-        assert s.endswith('0x00fe', start=-16)
-        assert not s.endswith('0x00fe', start=-15)
-        assert not s.endswith('0x00fe', end=-1)
-        assert s.endswith('0x00f', end=-4)
-
-        # replace
-        s.replace('0xfe', '', end=-1)
-        assert s == '0x00121200fe'
-        s.replace('0x00', '', start=-24)
-        assert s == '0x001212fe'
-
-    def test_rotate_start_and_end(self):
-        a = BitStream('0b110100001')
-        a.rol(1, 3, 6)
-        assert a == '0b110001001'
-        a.ror(1, start=-4)
-        assert a == '0b110001100'
-        a.rol(202, end=-5)
-        assert a == '0b001101100'
-        a.ror(3, end=4)
-        assert a == '0b011001100'
-        with pytest.raises(ValueError):
-            a.rol(5, start=-4, end=-6)
-
-    def test_byte_swap_int(self):
-        s = pack('5*uintle:16', *range(10, 15))
-        assert list(range(10, 15)) == s.unpack('5*uintle:16')
-        swaps = s.byteswap(2)
-        assert list(range(10, 15)) == s.unpack('5*uintbe:16')
-        assert swaps == 5
-        s = BitStream('0xf234567f')
-        swaps = s.byteswap(1, start=4)
-        assert swaps == 3
-        assert s == '0xf234567f'
-        s.byteswap(2, start=4)
-        assert s == '0xf452367f'
-        s.byteswap(2, start=4, end=-4)
-        assert s == '0xf234567f'
-        s.byteswap(3)
-        assert s == '0x5634f27f'
-        s.byteswap(2, repeat=False)
-        assert s == '0x3456f27f'
-        swaps = s.byteswap(5)
-        assert swaps == 0
-        swaps = s.byteswap(4, repeat=False)
-        assert swaps == 1
-        assert s == '0x7ff25634'
-
-    def test_byte_swap_pack_code(self):
-        s = BitStream('0x0011223344556677')
-        swaps = s.byteswap('b')
-        assert s == '0x0011223344556677'
-        assert swaps == 8
-        swaps = s.byteswap('>3h', repeat=False)
-        assert s == '0x1100332255446677'
-        assert swaps == 1
-
-    def test_byte_swap_iterable(self):
-        s = BitStream('0x0011223344556677')
-        swaps = s.byteswap(range(1, 4), repeat=False)
-        assert swaps == 1
-        assert s == '0x0022115544336677'
-        swaps = s.byteswap([2], start=8)
-        assert s == '0x0011224455663377'
-        assert 3 == swaps
-        swaps = s.byteswap([2, 3], start=4)
-        assert swaps == 1
-        assert s == '0x0120156452463377'
-
-    def test_byte_swap_errors(self):
-        s = BitStream('0x0011223344556677')
-        with pytest.raises(ValueError):
-            s.byteswap('z')
-        with pytest.raises(ValueError):
-            s.byteswap(-1)
-        with pytest.raises(ValueError):
-            s.byteswap([-1])
-        with pytest.raises(ValueError):
-            s.byteswap([1, 'e'])
-        with pytest.raises(ValueError):
-            s.byteswap('!h')
-        with pytest.raises(ValueError):
-            s.byteswap(2, start=-1000)
-        with pytest.raises(TypeError):
-            s.byteswap(5.4)
-
-    def test_byte_swap_from_file(self):
-        s = BitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
-        swaps = s.byteswap('2bh')
-        assert s == '0x0123674589abefcd'
-        assert swaps == 2
-
-    def test_bracket_expander(self):
-        be = bitstring.utils.expand_brackets
-        assert be('hello') == 'hello'
-        assert be('(hello)') == 'hello'
-        assert be('1*(hello)') == 'hello'
-        assert be('2*(hello)') == 'hello,hello'
-        assert be('1*(a,b)') == 'a,b'
-        assert be('2*(a,b)') == 'a,b,a,b'
-        assert be('2*(a),3*(b)') == 'a,a,b,b,b'
-        assert be('2*(a,b,3*(c,d),e)') == 'a,b,c,d,c,d,c,d,e,a,b,c,d,c,d,c,d,e'
-        with pytest.raises(ValueError):
-            _ = be('2*(x,y()')
-
-    def test_bracket_tokens(self):
-        s = BitStream('3*(0x0, 0b1)')
-        assert s == '0x0, 0b1, 0x0, 0b1, 0x0, 0b1'
-        s = pack('2*(uint:12, 3*(uint:7, uint:6))', *range(3, 17))
-        a = s.unpack('12, 7, 6, 7, 6, 7, 6, 12, 7, 6, 7, 6, 7, 6')
-        assert [x.uint for x in a] == list(range(3, 17))
-        b = s.unpack('2*(12,3*(7,6))')
-        assert a == b
-
-    def test_pack_code_dicts(self):
-        assert sorted(bitstring.utils.REPLACEMENTS_BE.keys()) == \
-                         sorted(bitstring.utils.REPLACEMENTS_LE.keys())
-        assert sorted(bitstring.utils.REPLACEMENTS_BE.keys()) == \
-                         sorted(bitstring.utils.PACK_CODE_SIZE.keys())
-        for key in bitstring.utils.PACK_CODE_SIZE:
-            be = pack(bitstring.utils.REPLACEMENTS_BE[key], 0)
-            le = pack(bitstring.utils.REPLACEMENTS_LE[key], 0)
-            assert be.len == bitstring.utils.PACK_CODE_SIZE[key] * 8
-            assert le.len == be.len
-
-    def test_unicode(self):
-        a = ConstBitStream(u'uint:12=34')
-        assert a.uint == 34
-        a += u'0xfe'
-        assert a[12:] == '0xfe'
-        a = BitStream('0x1122')
-        c = a.byteswap(u'h')
-        assert c == 1
-        assert a == u'0x2211'
-
-
-class TestUnpackWithDict:
-    def test_length_keywords(self):
-        a = ConstBitStream('2*int:13=100, 0b111')
-        x, y, z = a.unpack('13, int:m, bin:q', m=13, q=3)
-        assert x == 'uint:13=100'
-        assert y == 100
-        assert z == '111'
-
-    def test_length_keywords_with_stretch(self):
-        a = ConstBitStream('0xff, 0b000, 0xf')
-        x, y, z = a.unpack('hex:a, bin, hex:b', a=8, b=4)
-        assert y == '000'
-
-    def test_unused_keyword(self):
-        a = ConstBitStream('0b110')
-        x, = a.unpack('bin:3', notused=33)
-        assert x == '110'
-
-    def test_length_keyword_errors(self):
-        a = pack('uint:p=33', p=12)
-        with pytest.raises(ValueError):
-            a.unpack('uint:p')
-        with pytest.raises(ValueError):
-            a.unpack('uint:p', p='a_string')
-
-
-class TestReadWithDict:
-    def test_length_keywords(self):
-        s = BitStream('0x0102')
-        x, y = s.readlist('bits8, hex:b', b=4)
-        assert (x, y) == ('0x01', '0')
-        assert s.pos == 12
-
-    def test_bytes_keyword_problem(self):
-        s = BitStream('0x01')
-        x, = s.unpack('bytes:a', a=1)
-        assert x == b'\x01'
-
-        s = BitStream('0x000ff00a')
-        x, y, z = s.unpack('12, bytes:x, bits', x=2)
-        assert (x.int, y, z) == (0, b'\xff\x00', '0xa')
-
-
-class TestPeekWithDict:
-    def test_length_keywords(self):
-        s = BitStream('0x0102')
-        x, y = s.peeklist('8, hex:b', b=4)
-        assert (x, y) == ('0x01', '0')
-        assert s.pos == 0
-
-
-class TestBoolToken:
-    def test_interpretation(self):
-        a = ConstBitStream('0b1')
-        assert a.bool == True
-        assert a.read('bool') == True
-        assert a.unpack('bool')[0] == True
-        b = ConstBitStream('0b0')
-        assert b.bool == False
-        assert b.peek('bool') == False
-        assert b.unpack('bool')[0] == False
-
-    def test_pack(self):
-        a = pack('bool=True')
-        b = pack('bool=False')
-        assert a.bool == True
-        assert b.bool == False
-        c = pack('4*bool', False, True, 'False', 'True')
-        assert c == '0b0101'
-
-    def test_assignment(self):
-        a = BitStream()
-        a.bool = True
-        assert a.bool == True
-        a.hex = 'ee'
-        a.bool = False
-        assert a.bool == False
-        a.bool = 'False'
-        assert a.bool == False
-        a.bool = 'True'
-        assert a.bool == True
-        a.bool = 0
-        assert a.bool == False
-        a.bool = 1
-        assert a.bool == True
-
-    def test_errors(self):
-        with pytest.raises(bitstring.CreationError):
-            pack('bool', 'hello')
-        with pytest.raises(bitstring.CreationError):
-            pack('bool=true')
-        with pytest.raises(bitstring.CreationError):
-            pack('True')
-        with pytest.raises(bitstring.CreationError):
-            pack('bool', 2)
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bool', 'hello')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bool=true')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('True')
-        with pytest.raises(bitstring.CreationError):
-            _ = pack('bool', 2)
-        a = BitStream('0b11')
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.bool
-        b = BitStream()
-        with pytest.raises(bitstring.InterpretError):
-            _ = b.bool
-        with pytest.raises(bitstring.CreationError):
-            b.bool = 'false'
-
-    def test_length_with_bool_read(self):
-        a = ConstBitStream('0xf')
-        with pytest.raises(ValueError):
-            _ = a.read('bool:0')
-        with pytest.raises(ValueError):
-            _ = a.read('bool:2')
-
-
-class TestReadWithIntegers:
-    def test_read_int(self):
-        a = ConstBitStream('0xffeedd')
-        b = a.read(8)
-        assert b.hex == 'ff'
-        assert a.pos == 8
-        b = a.peek(8)
-        assert b.hex == 'ee'
-        assert a.pos == 8
-        b = a.peek(1)
-        assert b == '0b1'
-        b = a.read(1)
-        assert b == '0b1'
-
-    def test_read_int_list(self):
-        a = ConstBitStream('0xab, 0b110')
-        b, c = a.readlist([8, 3])
-        assert b.hex == 'ab'
-        assert c.bin == '110'
-
-
-# class FileReadingStrategy(unittest.TestCase):
-#
-#
-#     def testBitStreamIsAlwaysRead(self):
-#         filename = os.path.join(THIS_DIR, 'smalltestfile')
-#         a = BitStream(filename=filename)
-#         self.assertTrue(isinstance(a._datastore, bitstring.ByteStore))
-#         with open(filename, 'rb') as f:
-#             b = BitStream(f)
-#             self.assertTrue(isinstance(b._datastore, bitstring.ByteStore))
-#
-#
-#     def testBitsIsNeverRead(self):
-#         filename = os.path.join(THIS_DIR, 'smalltestfile')
-#         a = ConstBitStream(filename=filename)
-#         self.assertTrue(isinstance(a._datastore.rawarray, bitstring.MmapByteArray))
-#         with open(filename, 'rb') as f:
-#             b = ConstBitStream(f)
-#             self.assertTrue(isinstance(b._datastore.rawarray, bitstring.MmapByteArray))
-
-
-class TestCount:
-    def test_count(self):
-        a = ConstBitStream('0xf0f')
-        assert a.count(True) == 8
-        assert a.count(False) == 4
-
-        b = BitStream()
-        assert b.count(True) == 0
-        assert b.count(False) == 0
-
-    def test_count_with_offset_data(self):
-        a = ConstBitStream('0xff0120ff')
-        b = a[1:-1]
-        assert b.count(1) == 16
-        assert b.count(0) == 14
-
-
-class TestZeroBitReads:
-    def test_integer(self):
-        a = ConstBitStream('0x123456')
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.read('uint:0')
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.read('float:0')
-
-
-class TestInitialiseFromBytes:
-    def test_bytes_behaviour(self):
-        a = ConstBitStream(b'uint:5=2')
-        b = ConstBitStream(b'')
-        c = ConstBitStream(bytes=b'uint:5=2')
-        assert a.bytes == b'uint:5=2'
-        assert not b
-        assert c == b'uint:5=2'
-
-    def test_bytearray_behaviour(self):
-        a = ConstBitStream(bytearray(b'uint:5=2'))
-        b = ConstBitStream(bytearray(4))
-        c = ConstBitStream(bytes=bytearray(b'uint:5=2'))
-        assert a.bytes == b'uint:5=2'
-        assert b == '0x00000000'
-        assert c.bytes == b'uint:5=2'
-
-
-class TestCoverageCompletion:
-    def test_ue_read_error(self):
-        s = ConstBitStream('0b000000001')
-        with pytest.raises(bitstring.ReadError):
-            _ = s.read('ue')
-
-    def test_overwrite_with_self(self):
-        s = BitStream('0b1101')
-        s.overwrite(s)
-        assert s == '0b1101'
-
-
-class TestSubclassing:
-
-    def test_is_instance(self):
-        b = BitStream()
-        assert isinstance(b, BitStream)
-        class SubBits(BitStream):
-            pass
-        a = SubBits()
-        assert isinstance(a, SubBits)
-
-    def test_class_type(self):
-        class SubBits(BitStream):
-            pass
-        assert SubBits().__class__ == SubBits
-
-
-class TestBytesProblems:
-
-    def test_offset_but_no_length(self):
-        b = BitStream(bytes=b'\x00\xaa', offset=8)
-        assert b.hex == 'aa'
-        b = BitStream(bytes=b'\x00\xaa', offset=4)
-        assert b.hex == '0aa'
-
-    def test_invert(self):
-        b = BitStream(bytes=b'\x00\xaa', offset=8, length=8)
-        assert b.hex == 'aa'
-        b.invert()
-        assert b.hex == '55'
-
-    def test_prepend(self):
-        b = BitStream(bytes=b'\xaa\xbb', offset=8, length=4)
-        assert b.hex == 'b'
-        b.prepend('0xe')
-        assert b.hex == 'eb'
-        b = BitStream(bytes=b'\x00\xaa', offset=8, length=8)
-        b.prepend('0xee')
-        assert b.hex == 'eeaa'
-
-    def test_byte_swap(self):
-        b = BitStream(bytes=b'\x01\x02\x03\x04', offset=8)
-        b.byteswap()
-        assert b == '0x040302'
-
-    def test_bin_property(self):
-        b = BitStream(bytes=b'\x00\xaa', offset=8, length=4)
-        assert b.bin == '1010'
-
-
-class TestLsb0Streaming:
-
-    @classmethod
-    def setup_class(cls):
-        bitstring.lsb0 = True
-
-    @classmethod
-    def teardown_class(cls):
-        bitstring.lsb0 = False
-
-    def test_simple_bit_positions(self):
-        s = BitStream('0x00000f')
-        assert s.pos == 0
-        v = s.read('uint:8')
-        assert v == 15
-        assert s.pos == 8
-        v = s.read(10)
-        assert v == Bits(10)
-        assert s.pos == 18
-
-    def test_bit_pos_after_find(self):
-        s = BitStream('0b01100001000011 0000')
-        s.find('0b11', start=1)
-        assert s.pos == 4
-
-    def test_iter(self):
-        s = BitStream('0b11000')
-        assert list(s) == [False, False, False, True, True]
-
-    def test_bit_pos_after_rfind(self):
-        s = BitStream('0b011 000010000110000')
-        s.rfind('0b11')
-        assert s.pos == 15
-
-    def test_bit_pos_after_findall(self):
-        pass
-
-    def test_bit_pos_after_insert(self):
-        pass
-
-    def test_bit_pos_after_overwrite(self):
-        pass
-
-    def test_bit_pos_after_replace(self):
-        pass
-
-    def test_read_list(self):
-        a = BitStream('0x0123456789abcdef')
-        
-        vals = a.readlist('uint:4, uint:4, uint:24, uint:12, uint:12, uint:8')
-        assert vals == [15, 14, 0x89abcd, 0x567, 0x234, 1]
-
-
-class TestLsb0PackingUnpacking:
-
-    @classmethod
-    def setup_class(cls):
-        bitstring.lsb0 = True
-
-    @classmethod
-    def teardown_class(cls):
-        bitstring.lsb0 = False
-
-    def test_bin(self):
-        lsb0 = bitstring.pack('2*b4', '0b0000', '1111')
-        assert lsb0 == '0b11110000'
-        a, b = lsb0.unpack('2*h4')
-        assert [a, b] == ['0', 'f']
-        a, b = lsb0.unpack('2*bits4')
-        assert [a, b] == ['0x0', '0xf']
-        a, b = lsb0.unpack('2*bin4')
-        assert [a, b] == ['0000', '1111']
-
-    def test_float(self):
-        lsb0 = bitstring.pack('2*bfloat', 0.5, 15)
-        assert lsb0 == '0x4170 3f00'
-        a, b = lsb0.unpack('2*bfloat')
-        assert [a, b] == [0.5, 15]
-
-    def test_simplest(self):
-        lsb0 = bitstring.pack('uint:2', 1)
-        assert lsb0.unpack('uint:2') == [1]
-        lsb0 = bitstring.pack('0xab, 0xc')
-        assert lsb0.unpack('hex8, hex4') == ['ab', 'c']
-
-    def test_slightly_harder(self):
-        lsb0 = bitstring.pack('float:32, hex', 0.25, 'ac')
-        x = lsb0.unpack('float:32, hex')
-        assert x == [0.25, 'ac']
-
-    def test_more_complex(self):
-        lsb0 = bitstring.pack('uint:10, hex, int:13, 0b11', 130, '3d', -23)
-        x = lsb0.unpack('uint:10, hex, int:13, bin:2')
-        assert x == [130, '3d', -23, '11']
-
-    def test_golomb_codes(self):
-        v = [10, 8, 6, 4, 100, -9]
-        # Exp-Golomb codes can only be read in msb0 mode. So also doesn't
-        # make sense for creation with pack
-        with pytest.raises(bitstring.CreationError):
-            _ = bitstring.pack('5*ue, sie', *v)
-        # with self.assertRaises(bitstring.CreationError):
-        #     _ = BitStream('ue=34')
-        lsb0 = BitStream('0b0010010')
-        with pytest.raises(bitstring.ReadError):
-            _ = lsb0.unpack('5*ue, sie')
-        with pytest.raises(bitstring.ReadError):
-            _ = lsb0.read('ue')
-        with pytest.raises(bitstring.ReadError):
-            _ = lsb0.read('uie')
-        with pytest.raises(bitstring.ReadError):
-            _ = lsb0.read('se')
-        with pytest.raises(bitstring.ReadError):
-            _ = lsb0.read('sie')
-
-
-class TestRepr:
-
-    def test_without_pos(self):
-        a = BitStream('0x12345', pos=0)
-        assert repr(a) == "BitStream('0x12345')"
-
-    def test_with_pos(self):
-        a = BitStream('0b00111', pos=-1)
-        assert a.pos == 4
-        assert repr(a) == "BitStream('0b00111', pos=4)"
-
-
-class TestFormat:
-
-    def test_simple_format_strings(self):
-        a = Bits('0xabc')
-        s = f'{a}'
-        assert s == '0xabc'
-        a += '0b0'
-        assert f'{a}' == '0b1010101111000'
-        b = BitStream(10, pos=4)
-        assert f'{b}' == '0b0000000000'
-        c = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
-        assert f'{c}'[0:10] == '0x000001b3'
-
-    def test_format_strings_with_interpretation(self):
-        a = Bits('0xf')
-        assert f'{a.bin}' == '1111'
-
-
-class TestCacheingIssues:
-
-    def test_cache_with_offset(self):
-        y = BitStream('0xdeadbeef1000')
-        with pytest.raises(bitstring.CreationError):
-            x = BitStream('0xdeadbeef1000', offset=8)
-
-    def test_cache_with_pos(self):
-        y = BitStream('0xdeadbeef1001', pos=3)
-        assert y.pos == 3
-        x = BitStream('0xdeadbeef1001', pos=5)
-        assert x.pos == 5
-
-    def test_cache_with_length(self):
-        y = BitStream('0xdeadbeef002')
-        with pytest.raises(bitstring.CreationError):
-            x = BitStream('0xdeadbeef002', length=16)
-
-
-def test_unpack_error():
-    format_with_commas = ',bytes:2,,bytes:1,'
-    dp = BitStream(hex='010203').unpack(fmt=format_with_commas)
-    assert dp == [b'\x01\x02', b'\x03']
+#!/usr/bin/env python
+
+import pytest
+import sys
+sys.path.insert(0, '..')
+import bitstring
+import copy
+import os
+import collections
+from bitstring import Bits, BitStream, ConstBitStream, pack, Dtype
+
+THIS_DIR = os.path.dirname(os.path.abspath(__file__))
+
+
+class TestFlexibleInitialisation:
+    def test_flexible_initialisation(self):
+        a = BitStream('uint:8=12')
+        c = BitStream(' uint : 8 =  12')
+        assert a == c == BitStream(uint=12, length=8)
+        assert a.uint == 12
+        a = BitStream('     int:2=  -1')
+        b = BitStream('int :2   = -1')
+        c = BitStream(' int:  2  =-1  ')
+        assert a == b == c == BitStream(int=-1, length=2)
+
+    def test_flexible_initialisation2(self):
+        h = BitStream('hex=12')
+        o = BitStream('oct=33')
+        b = BitStream('bin=10')
+        assert h == '0x12'
+        assert o == '0o33'
+        assert b == '0b10'
+
+    def test_flexible_initialisation3(self):
+        for s in ['se=-1', ' se = -1 ', 'se = -1']:
+            a = BitStream(s)
+            assert a.se == -1
+        for s in ['ue=23', 'ue =23', 'ue = 23']:
+            a = BitStream(s)
+            assert a.ue == 23
+
+    def test_multiple_string_initialisation(self):
+        a = BitStream('0b1 , 0x1')
+        assert a == '0b10001'
+        a = BitStream('ue=5, ue=1, se=-2')
+        assert a.read('ue') == 5
+        assert a.read('ue') == 1
+        assert a.read('se') == -2
+        b = BitStream('uint:32 = 12, 0b11') + 'int:100=-100, 0o44'
+        assert b.read(32).uint == 12
+        assert b.read(2).bin == '11'
+        assert b.read(100).int == -100
+
+
+class TestReading:
+    def test_read_bits(self):
+        s = BitStream(bytes=b'\x4d\x55')
+        assert s.read(4).hex == '4'
+        assert s.read(8).hex == 'd5'
+        assert s.read(1) == [0]
+        assert s.read(3).bin == '101'
+        assert not s.read(0)
+
+    def test_read_byte(self):
+        s = BitStream(hex='4d55')
+        assert s.read(8).hex == '4d'
+        assert s.read(8).hex == '55'
+
+    def test_read_bytes(self):
+        s = BitStream(hex='0x112233448811')
+        assert s.read(3 * 8).hex == '112233'
+        with pytest.raises(ValueError):
+            s.read(-16)
+        s.bitpos += 1
+        assert s.read(2 * 8).bin == '1000100100010000'
+
+    def test_read_ue(self):
+        with pytest.raises(bitstring.InterpretError):
+            _ = BitStream('').ue
+        # The numbers 0 to 8 as unsigned Exponential-Golomb codes
+        s = BitStream(bin='1 010 011 00100 00101 00110 00111 0001000 0001001')
+        assert s.pos == 0
+        for i in range(9):
+            assert s.read('ue') == i
+        with pytest.raises(bitstring.ReadError):
+            s.read('ue')
+
+    def test_read_se(self):
+        s = BitStream(bin='010 00110 0001010 0001000 00111')
+        assert s.read('se') == 1
+        assert s.read('se') == 3
+        assert s.readlist(3 * ['se']) == [5, 4, -3]
+
+
+class TestFind:
+    def test_find1(self):
+        s = ConstBitStream(bin='0b0000110110000')
+        assert s.find(BitStream(bin='11011'))
+        assert s.bitpos == 4
+        assert s.read(5).bin == '11011'
+        s.bitpos = 0
+        assert not s.find('0b11001', False)
+
+    def test_find2(self):
+        s = BitStream(bin='0')
+        assert s.find(s, False)
+        assert s.pos == 0
+        assert not s.find('0b00', False)
+        with pytest.raises(ValueError):
+            s.find(BitStream())
+
+    def test_find_with_offset(self):
+        s = BitStream(hex='0x112233')[4:]
+        assert s.find('0x23', False)
+        assert s.pos == 8
+
+    def test_find_corner_cases(self):
+        s = BitStream(bin='000111000111')
+        assert s.find('0b000')
+        assert s.pos == 0
+        assert s.find('0b000')
+        assert s.pos == 0
+        assert s.find('0b0111000111')
+        assert s.pos == 2
+        assert s.find('0b000', start=2)
+        assert s.pos == 6
+        assert s.find('0b111', start=6)
+        assert s.pos == 9
+        s.pos += 2
+        assert s.find('0b1', start=s.pos)
+
+    def test_find_bytes(self):
+        s = BitStream.fromstring('0x010203040102ff')
+        assert s.find('0x05', bytealigned=True) ==()
+        assert s.find('0x02', bytealigned=True) == (8,)
+        assert s.read(16).hex == '0203'
+        assert s.find('0x02', start=s.bitpos, bytealigned=True) == (40,)
+        s.read(1)
+        assert not s.find('0x02', start=s.bitpos, bytealigned=True)
+
+    def test_find_bytes_aligned_corner_cases(self):
+        s = BitStream('0xff')
+        assert s.find(s)
+        assert not s.find(BitStream(hex='0x12'))
+        assert not s.find(BitStream(hex='0xffff'))
+
+    def test_find_bytes_bitpos(self):
+        s = BitStream(hex='0x1122334455')
+        s.pos = 2
+        s.find('0x66', bytealigned=True)
+        assert s.pos == 2
+        s.pos = 38
+        s.find('0x66', bytealigned=True)
+        assert s.pos == 38
+
+    def test_find_byte_aligned(self):
+        s = BitStream(hex='0x12345678')
+        assert s.find(BitStream(hex='0x56'), bytealigned=True)
+        assert s.bytepos == 2
+        s.pos = 0
+        assert not s.find(BitStream(hex='0x45'), bytealigned=True)
+        s = BitStream('0x1234')
+        s.find('0x1234')
+        assert s.find('0x1234')
+        s += '0b111'
+        s.pos = 3
+        s.find('0b1', start=17, bytealigned=True)
+        assert not s.find('0b1', start=17, bytealigned=True)
+        assert s.pos == 3
+
+    def test_find_byte_aligned_with_offset(self):
+        s = BitStream(hex='0x112233')[4:]
+        assert s.find(BitStream(hex='0x23'))
+
+    def test_find_byte_aligned_errors(self):
+        s = BitStream(hex='0xffff')
+        with pytest.raises(ValueError):
+            s.find('')
+        with pytest.raises(ValueError):
+            s.find(BitStream())
+
+
+class TestRfind:
+    def test_rfind(self):
+        a = BitStream('0b001001001')
+        b = a.rfind('0b001')
+        assert b == (6,)
+        assert a.pos == 6
+        big = BitStream(length=100000) + '0x12' + BitStream(length=10000)
+        found = big.rfind('0x12', bytealigned=True)
+        assert found == (100000,)
+        assert big.pos == 100000
+
+    def test_rfind_byte_aligned(self):
+        a = BitStream('0x8888')
+        b = a.rfind('0b1', bytealigned=True)
+        assert b == (8,)
+        assert a.pos == 8
+
+    def test_rfind_startbit(self):
+        a = BitStream('0x0000ffffff')
+        b = a.rfind('0x0000', start=1, bytealigned=True)
+        assert b == ()
+        assert a.pos == 0
+        b = a.rfind('0x00', start=1, bytealigned=True)
+        assert b == (8,)
+        assert a.pos == 8
+
+    def test_rfind_endbit(self):
+        a = BitStream('0x000fff')
+        b = a.rfind('0b011', start=0, end=14, bytealigned=False)
+        assert bool(b) == True
+        b = a.rfind('0b011', 0, 13, False)
+        assert b == ()
+
+    def test_rfind_errors(self):
+        a = BitStream('0x43234234')
+        with pytest.raises(ValueError):
+            a.rfind('', bytealigned=True)
+        with pytest.raises(ValueError):
+            a.rfind('0b1', start=-99, bytealigned=True)
+        with pytest.raises(ValueError):
+            a.rfind('0b1', end=33, bytealigned=True)
+        with pytest.raises(ValueError):
+            a.rfind('0b1', start=10, end=9, bytealigned=True)
+
+
+class TestShift:
+    def test_shift_left(self):
+        s = BitStream.fromstring('0b1010')
+        t = s << 1
+        assert s.bin == '1010'
+        assert t.bin == '0100'
+        s = t << 0
+        assert s == '0b0100'
+        t = s << 100
+        assert t.bin == '0000'
+
+    def test_shift_left_errors(self):
+        s = BitStream()
+        with pytest.raises(ValueError):
+            s << 1
+        s = BitStream('0xf')
+        with pytest.raises(ValueError):
+            s << -1
+
+    def test_shift_right(self):
+        s = BitStream('0b1010')
+        t = s >> 1
+        assert s.bin == '1010'
+        assert t.bin == '0101'
+        q = s >> 0
+        assert q == '0b1010'
+        q.replace('0b1010', '')
+        t = s >> 100
+        assert t.bin == '0000'
+
+    def test_shift_right_errors(self):
+        s = BitStream()
+        with pytest.raises(ValueError):
+            s >> 1
+        s = BitStream('0xf')
+        with pytest.raises(ValueError):
+            s >> -1
+
+    def test_shift_right_in_place(self):
+        s = BitStream.fromstring('0xffff')[4:12]
+        s >>= 1
+        assert s == '0b01111111'
+        s = BitStream('0b11011')
+        s >>= 2
+        assert s.bin == '00110'
+        s >>= 100000000000000
+        assert s.bin == '00000'
+        s = BitStream('0xff')
+        s >>= 1
+        assert s == '0x7f'
+        s >>= 0
+        assert s == '0x7f'
+
+    def test_shift_in_place_whole_bitstring(self):
+        s = BitStream('0xabcd')
+        s >>= len(s)
+        assert s == '0x0000'
+
+    def test_shift_right_in_place_errors(self):
+        s = BitStream()
+        with pytest.raises(ValueError):
+            s >>= 1
+        s += '0b11'
+        with pytest.raises(ValueError):
+            s >>= -1
+
+    def test_shift_left_in_place(self):
+        s = BitStream('0xffff')
+        t = s[4:12]
+        t <<= 2
+        assert t == '0b11111100'
+        s = BitStream('0b11011')
+        s <<= 2
+        assert s.bin == '01100'
+        s <<= 100000000000000000000
+        assert s.bin == '00000'
+        s = BitStream('0xff')
+        s <<= 1
+        assert s == '0xfe'
+        s <<= 0
+        assert s == '0xfe'
+
+    def test_shift_left_in_place_errors(self):
+        s = BitStream()
+        with pytest.raises(ValueError):
+            s <<= 1
+        s += '0b11'
+        with pytest.raises(ValueError):
+            s <<= -1
+
+
+class TestReplace:
+    def test_replace1(self):
+        a = BitStream('0b1')
+        n = a.replace('0b1', '0b0', bytealigned=True)
+        assert a.bin == '0'
+        assert n == 1
+        n = a.replace('0b1', '0b0', bytealigned=True)
+        assert n == 0
+
+    def test_replace2(self):
+        a = BitStream('0b00001111111')
+        n = a.replace('0b1', '0b0', bytealigned=True)
+        assert a.bin == '00001111011'
+        assert n == 1
+        n = a.replace('0b1', '0b0', bytealigned=False)
+        assert a.bin == '00000000000'
+        assert n == 6
+
+    def test_replace3(self):
+        a = BitStream('0b0')
+        n = a.replace('0b0', '0b110011111', bytealigned=True)
+        assert n == 1
+        assert a.bin == '110011111'
+        n = a.replace('0b11', '', bytealigned=False)
+        assert n == 3
+        assert a.bin == '001'
+
+    def test_replace4(self):
+        a = BitStream('0x00114723ef4732344700')
+        n = a.replace('0x47', '0x00', bytealigned=True)
+        assert n == 3
+        assert a.hex == '00110023ef0032340000'
+        a.replace('0x00', '', bytealigned=True)
+        assert a.hex == '1123ef3234'
+        a.replace('0x11', '', start=1, bytealigned=True)
+        assert a.hex == '1123ef3234'
+        a.replace('0x11', '0xfff', end=7, bytealigned=True)
+        assert a.hex == '1123ef3234'
+        a.replace('0x11', '0xfff', end=8, bytealigned=True)
+        assert a.hex == 'fff23ef3234'
+
+    def test_replace5(self):
+        a = BitStream.fromstring('0xab')
+        b = BitStream.fromstring('0xcd')
+        c = BitStream.fromstring('0xabef')
+        c.replace(a, b)
+        assert c == '0xcdef'
+        assert a == '0xab'
+        assert b == '0xcd'
+        a = BitStream('0x0011223344')
+        a.pos = 12
+        a.replace('0x11', '0xfff', bytealigned=True)
+        assert a.pos == 0
+        assert a == '0x00fff223344'
+
+    def test_replace_with_self(self):
+        a = BitStream('0b11')
+        a.replace('0b1', a)
+        assert a == '0xf'
+        a.replace(a, a)
+        assert a == '0xf'
+
+    def test_replace_count(self):
+        a = BitStream('0x223344223344223344')
+        n = a.replace('0x2', '0x0', count=0, bytealigned=True)
+        assert n == 0
+        assert a.hex == '223344223344223344'
+        n = a.replace('0x2', '0x0', count=1, bytealigned=True)
+        assert n == 1
+        assert a.hex == '023344223344223344'
+        n = a.replace('0x33', '', count=2, bytealigned=True)
+        assert n == 2
+        assert a.hex == '02442244223344'
+        n = a.replace('0x44', '0x4444', count=1435, bytealigned=True)
+        assert n == 3
+        assert a.hex == '02444422444422334444'
+
+    def test_replace_bitpos(self):
+        a = BitStream('0xff')
+        a.bitpos = 8
+        a.replace('0xff', '', bytealigned=True)
+        assert a.bitpos == 0
+        a = BitStream('0b0011110001')
+        a.bitpos = 4
+        a.replace('0b1', '0b000')
+        assert a.bitpos == 0
+        a = BitStream('0b1')
+        a.bitpos = 1
+        a.replace('0b1', '0b11111', bytealigned=True)
+        assert a.bitpos == 0
+        a.replace('0b11', '0b0', False)
+        assert a.bitpos == 0
+        a.append('0b00')
+        a.pos = 5
+        a.replace('0b00', '0b11')
+        assert a.bitpos == 5
+
+    def test_replace_errors(self):
+        a = BitStream('0o123415')
+        with pytest.raises(ValueError):
+            a.replace('', Bits(0o7), bytealigned=True)
+        with pytest.raises(ValueError):
+            a.replace('0b1', '0b1', start=-100, bytealigned=True)
+        with pytest.raises(ValueError):
+            a.replace('0b1', '0b1', end=19, bytealigned=True)
+
+
+class TestSliceAssignment:
+    def test_set_slice(self):
+        a = BitStream()
+        a[0:0] = '0xabcdef'
+        assert a.bytepos == 0
+        a[4:16] = ''
+        assert a == '0xaef'
+        assert a.bitpos == 0
+        a.pos = 4
+        a[8:] = '0x00'
+        assert a == '0xae00'
+        assert a.bitpos == 0
+        a += '0xf'
+        assert a.bitpos == 20
+        a[8:] = '0xe'
+        assert a == '0xaee'
+        assert a.bitpos == 0
+        b = BitStream()
+        b[0:800] = '0xffee'
+        assert b == '0xffee'
+        b[4:48] = '0xeed123'
+        assert b == '0xfeed123'
+        b[-800:8] = '0x0000'
+        assert b == '0x0000ed123'
+        a = BitStream('0xabcde')
+        assert a[-100:-90] == ''
+        assert a[-100:-16] == '0xa'
+        a[-100:-16] = '0x0'
+        assert a == '0x0bcde'
+
+    def test_inserting_using_set_item(self):
+        a = BitStream()
+        a[0:0] = '0xdeadbeef'
+        assert a == '0xdeadbeef'
+        assert a.bytepos == 0
+        a[16:16] = '0xfeed'
+        assert a == '0xdeadfeedbeef'
+        assert a.bytepos == 0
+        a[0:0] = '0xa'
+        assert a == '0xadeadfeedbeef'
+        assert a.bitpos == 0
+        a.bytepos = 6
+        a[0:8] = '0xff'
+        assert a.bytepos == 6
+        a[8:0] = '0x000'
+        assert a.startswith('0xff000ead')
+
+    def test_slice_assignment_bit_pos(self):
+        a = BitStream('int:64=-1')
+        a.pos = 64
+        a[0:8] = ''
+        assert a.pos == 0
+        a.pos = 52
+        a[-16:] = '0x0000'
+        assert a.pos == 52
+
+
+
+class TestPack:
+    def test_pack1(self):
+        s = bitstring.pack('uint:6, bin, hex, int:6, se, ue, oct', 10, '0b110', 'ff', -1, -6, 6, '54')
+        t = BitStream('uint:6=10, 0b110, 0xff, int:6=-1, se=-6, ue=6, oct=54')
+        assert s == t
+        with pytest.raises(ValueError):
+            pack('tomato', '0')
+        with pytest.raises(ValueError):
+            pack('uint', 12)
+        with pytest.raises(ValueError):
+            pack('int', 12)
+        with pytest.raises(ValueError):
+            pack('hex', 'penguin')
+        with pytest.raises(ValueError):
+            pack('hex12', '0x12')
+
+    def test_pack_with_literals(self):
+        s = bitstring.pack('0xf')
+        assert s == '0xf'
+        assert type(s), BitStream
+        s = pack('0b1')
+        assert s == '0b1'
+        s = pack('0o7')
+        assert s == '0o7'
+        s = pack('int:10=-1')
+        assert s == '0b1111111111'
+        s = pack('uint:10=1')
+        assert s == '0b0000000001'
+        s = pack('ue=12')
+        assert s.ue == 12
+        s = pack('se=-12')
+        assert s.se == -12
+        s = pack('bin=01')
+        assert s.bin == '01'
+        s = pack('hex=01')
+        assert s.hex == '01'
+        s = pack('oct=01')
+        assert s.oct == '01'
+
+    def test_pack_with_dict(self):
+        a = pack('uint:6=width, se=height', height=100, width=12)
+        w, h = a.unpack('uint:6, se')
+        assert w == 12
+        assert h == 100
+        d = {'w': '0xf', '300': 423, 'e': '0b1101'}
+        a = pack('int:100=300, bin=e, uint:12=300', **d)
+        x, y, z = a.unpack('int:100, bin, uint:12')
+        assert x == 423
+        assert y == '1101'
+        assert z == 423
+
+    def test_pack_with_dict2(self):
+        a = pack('int:5, bin:3=b, 0x3, bin=c, se=12', 10, b='0b111', c='0b1')
+        b = BitStream('int:5=10, 0b111, 0x3, 0b1, se=12')
+        assert a == b
+        a = pack('bits:3=b', b=BitStream('0b101'))
+        assert a == '0b101'
+        a = pack('bits:24=b', b=BitStream('0x001122'))
+        assert a == '0x001122'
+
+    def test_pack_with_dict3(self):
+        s = pack('hex:4=e, hex:4=0xe, hex:4=e', e='f')
+        assert s == '0xfef'
+        s = pack('sep', sep='0b00')
+        assert s == '0b00'
+
+    def test_pack_with_dict4(self):
+        s = pack('hello', hello='0xf')
+        assert s == '0xf'
+        s = pack('x, y, x, y, x', x='0b10', y='uint:12=100')
+        t = BitStream('0b10, uint:12=100, 0b10, uint:12=100, 0b10')
+        assert s == t
+        a = [1, 2, 3, 4, 5]
+        s = pack('int:8, div,' * 5, *a, **{'div': '0b1'})
+        t = BitStream('int:8=1, 0b1, int:8=2, 0b1, int:8=3, 0b1, int:8=4, 0b1, int:8=5, 0b1')
+        assert s == t
+
+    def test_pack_with_locals(self):
+        width = 352
+        height = 288
+        s = pack('uint:12=width, uint:12=height', **locals())
+        assert s == '0x160120'
+
+    def test_pack_with_length_restriction(self):
+        _ = pack('bin:3', '0b000')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bin:3', '0b0011')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bin:3', '0b11')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bin:3=0b0011')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bin:3=0b11')
+
+        _ = pack('hex:4', '0xf')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('hex:4', '0b111')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('hex:4', '0b11111')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('hex:8=0xf')
+
+        _ = pack('oct:6', '0o77')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('oct:6', '0o1')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('oct:6', '0o111')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('oct:3', '0b1')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('oct:3=hello', hello='0o12')
+
+        _ = pack('bits:3', BitStream('0b111'))
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bits:3', BitStream('0b11'))
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bits:3', BitStream('0b1111'))
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bits:12=b', b=BitStream('0b11'))
+
+    def test_pack_null(self):
+        s = pack('')
+        assert not s
+        s = pack(',')
+        assert not s
+        s = pack(',,,,,0b1,,,,,,,,,,,,,0b1,,,,,,,,,,')
+        assert s == '0b11'
+        s = pack(',,uint:12,,bin:3,', 100, '100')
+        a, b = s.unpack('uint:12,bin:3')
+        assert a == 100
+        assert b == '100'
+
+    def test_pack_uint(self):
+        s = pack('uint:10, uint:5', 1, 2)
+        a, b = s.unpack('10, 5')
+        assert (a.uint, b.uint) == (1, 2)
+        s = pack('uint:10=150, uint:12=qee', qee=3)
+        assert s == 'uint:10=150, uint:12=3'
+        t = BitStream('uint:100=5')
+        assert t == 'uint:100=5'
+
+    def test_pack_defualt_uint_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream('5=-1')
+
+    def test_packing_long_keyword_bitstring(self):
+        s = pack('bits=b', b=BitStream(128000))
+        assert s == BitStream(128000)
+
+    def test_packing_with_list_format(self):
+        f = ['bin', 'hex', 'uint:10']
+        a = pack(','.join(f), '00', '234', 100)
+        b = pack(f, '00', '234', 100)
+        assert a == b
+
+
+class TestUnpack:
+    def test_unpack1(self):
+        s = BitStream('uint:13=23, hex=e, bin=010, int:41=-554, 0o44332, se=-12, ue=4')
+        s.pos = 11
+        a, b, c, d, e, f, g = s.unpack('uint:13, hex:4, bin:3, int:41, oct:15, se, ue')
+        assert a == 23
+        assert b == 'e'
+        assert c == '010'
+        assert d == -554
+        assert e == '44332'
+        assert f == -12
+        assert g == 4
+        assert s.pos == 11
+
+    def test_unpack2(self):
+        s = BitStream('0xff, 0b000, uint:12=100')
+        a, b, c = s.unpack('bits:8, bits, uint:12')
+        assert type(s) == BitStream
+        assert a == '0xff'
+        assert type(s) == BitStream
+        assert b == '0b000'
+        assert c == 100
+        a, b = s.unpack(['bits:11', 'uint'])
+        assert a == '0xff, 0b000'
+        assert b == 100
+
+
+class TestFromFile:
+    def test_creation_from_file_operations(self):
+        filename = os.path.join(THIS_DIR, 'smalltestfile')
+        s = BitStream(filename=filename)
+        s.append('0xff')
+        assert s.hex == '0123456789abcdefff'
+
+        s = ConstBitStream(filename=filename)
+        t = BitStream('0xff') + s
+        assert t.hex == 'ff0123456789abcdef'
+
+        s = BitStream(filename=filename)
+        del s[:1]
+        assert (BitStream('0b0') + s).hex == '0123456789abcdef'
+
+        s = BitStream(filename=filename)
+        del s[:7 * 8]
+        assert s.hex == 'ef'
+
+        s = BitStream(filename=filename)
+        s.insert('0xc', 4)
+        assert s.hex == '0c123456789abcdef'
+
+        s = BitStream(filename=filename)
+        s.prepend('0xf')
+        assert s.hex == 'f0123456789abcdef'
+
+        s = BitStream(filename=filename)
+        s.overwrite('0xaaa', 12)
+        assert s.hex == '012aaa6789abcdef'
+
+        s = BitStream(filename=filename)
+        s.reverse()
+        assert s.hex == 'f7b3d591e6a2c480'
+
+        s = BitStream(filename=filename)
+        del s[-60:]
+        assert s.hex == '0'
+
+        s = BitStream(filename=filename)
+        del s[:60]
+        assert s.hex == 'f'
+
+    def test_file_properties(self):
+        s = ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
+        assert s.hex == '0123456789abcdef'
+        assert s.uint == 81985529216486895
+        assert s.int == 81985529216486895
+        assert s.bin == '0000000100100011010001010110011110001001101010111100110111101111'
+        assert s[:-1].oct == '002215053170465363367'
+        s.bitpos = 0
+        assert s.read('se') == -72
+        s.bitpos = 0
+        assert s.read('ue') == 144
+        assert s.bytes == b'\x01\x23\x45\x67\x89\xab\xcd\xef'
+        assert s.tobytes() == b'\x01\x23\x45\x67\x89\xab\xcd\xef'
+
+    def test_creation_from_file_with_length(self):
+        test_filename = os.path.join(THIS_DIR, 'test.m1v')
+        s = ConstBitStream(filename=test_filename, length=32)
+        assert s.length == 32
+        assert s.hex == '000001b3'
+        s = ConstBitStream(filename=test_filename, length=0)
+        assert not s
+        small_test_filename = os.path.join(THIS_DIR, 'smalltestfile')
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream(filename=small_test_filename, length=65)
+        with pytest.raises(bitstring.CreationError):
+            _ = ConstBitStream(filename=small_test_filename, length=64, offset=1)
+        with pytest.raises(bitstring.CreationError):
+            _ = ConstBitStream(filename=small_test_filename, offset=65)
+        with open(small_test_filename, 'rb') as f:
+            with pytest.raises(bitstring.CreationError):
+                _ = ConstBitStream(f, offset=65)
+            with pytest.raises(bitstring.CreationError):
+                _ = ConstBitStream(f, length=65)
+            with pytest.raises(bitstring.CreationError):
+                _ = ConstBitStream(f, offset=60, length=5)
+
+    def test_creation_from_file_with_offset(self):
+        filename = os.path.join(THIS_DIR, 'test.m1v')
+        a = BitStream(filename=filename, offset=4)
+        assert a.peek(4 * 8).hex == '00001b31'
+        b = BitStream(filename=filename, offset=28)
+        assert b.peek(8).hex == '31'
+
+    def test_file_slices(self):
+        s = BitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
+        assert s[-16:].hex == 'cdef'
+
+    def test_creataion_from_file_errors(self):
+        with pytest.raises(IOError):
+            _ = BitStream(filename='Idonotexist')
+
+    def test_find_in_file(self):
+        s = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
+        assert s.find('0x160120')
+        assert s.bytepos == 4
+        s3 = s.read(24)
+        assert s3.hex == '160120'
+        s.bytepos = 0
+        assert s._pos == 0
+        assert s.find('0x0001b2')
+        assert s.bytepos == 13
+
+    def test_hex_from_file(self):
+        s = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
+        assert s[0:32].hex == '000001b3'
+        assert s[-32:].hex == '000001b7'
+        s.hex = '0x11'
+        assert s.hex == '11'
+
+    def test_file_operations(self):
+        filename = os.path.join(THIS_DIR, 'test.m1v')
+        s1 = BitStream(filename=filename)
+        s2 = BitStream(filename=filename)
+        assert s1.read(32).hex == '000001b3'
+        assert s2.read(32).hex == '000001b3'
+        s1.bytepos += 4
+        assert s1.read(8).hex == '02'
+        assert s2.read(5 * 8).hex == '1601208302'
+        s1.pos = s1.len
+        with pytest.raises(ValueError):
+            s1.pos += 1
+
+    def test_file_bit_getting(self):
+        s = ConstBitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'), offset=16, length=8)
+        b = s[1]
+        assert b
+        b = s.any(0, [-1, -2, -3])
+        assert b
+        b = s.all(0, [0, 1, 2])
+        assert not b
+
+
+class TestCreationErrors:
+    def test_incorrect_bin_assignment(self):
+        s = BitStream()
+        with pytest.raises(bitstring.CreationError):
+            s._setbin_safe('0010020')
+
+    def test_incorrect_hex_assignment(self):
+        s = BitStream()
+        with pytest.raises(bitstring.CreationError):
+            s.hex = '0xabcdefg'
+
+
+class TestLength:
+    def test_length_zero(self):
+        assert BitStream('').len == 0
+
+    def test_length(self):
+        assert BitStream('0x80').len == 8
+
+    def test_offset_length_error(self):
+        with pytest.raises(bitstring.CreationError):
+            BitStream(hex='0xffff', offset=-1)
+
+
+class TestSimpleConversions:
+    def test_convert_to_uint(self):
+        assert BitStream('0x10').uint == 16
+        assert BitStream('0b000111').uint == 7
+
+    def test_convert_to_int(self):
+        assert BitStream('0x10').int == 16
+        assert BitStream('0b11110').int == -2
+
+    def test_convert_to_hex(self):
+        assert BitStream(bytes=b'\x00\x12\x23\xff').hex == '001223ff'
+        s = BitStream('0b11111')
+        with pytest.raises(bitstring.InterpretError):
+            _ = s.hex
+
+
+class TestEmpty:
+    def test_empty_bitstring(self):
+        s = BitStream()
+        with pytest.raises(bitstring.ReadError):
+            s.read(1)
+        assert s.bin == ''
+        assert s.hex == ''
+        with pytest.raises(bitstring.InterpretError):
+            _ = s.int
+        with pytest.raises(bitstring.InterpretError):
+            _ = s.uint
+        assert not s
+
+    def test_non_empty_bit_stream(self):
+        s = BitStream(bin='0')
+        assert not not s.len
+
+
+class TestPosition:
+    def test_bit_position(self):
+        s = BitStream(bytes=b'\x00\x00\x00')
+        assert s.bitpos == 0
+        s.read(5)
+        assert s.pos == 5
+        s.pos = s.len
+        with pytest.raises(bitstring.ReadError):
+            s.read(1)
+
+    def test_byte_position(self):
+        s = BitStream(bytes=b'\x00\x00\x00')
+        assert s.bytepos == 0
+        s.read(10)
+        with pytest.raises(bitstring.ByteAlignError):
+            _ = s.bytepos
+        s.read(6)
+        assert s.bytepos == 2
+
+    def test_seek_to_bit(self):
+        s = BitStream(bytes=b'\x00\x00\x00\x00\x00\x00')
+        s.bitpos = 0
+        assert s.bitpos == 0
+        with pytest.raises(ValueError):
+            s.pos = -1
+        with pytest.raises(ValueError):
+            s.bitpos = 6 * 8 + 1
+        s.bitpos = 6 * 8
+        assert s.bitpos == 6 * 8
+
+    def test_seek_to_byte(self):
+        s = BitStream(bytes=b'\x00\x00\x00\x00\x00\xab')
+        s.bytepos = 5
+        assert s.read(8).hex == 'ab'
+
+    def test_advance_bits_and_bytes(self):
+        s = BitStream(bytes=b'\x00\x00\x00\x00\x00\x00\x00\x00')
+        s.pos += 5
+        assert s.pos == 5
+        s.bitpos += 16
+        assert s.pos == 2 * 8 + 5
+        s.pos -= 8
+        assert s.pos == 8 + 5
+
+    def test_retreat_bits_and_bytes(self):
+        a = BitStream(length=100)
+        a.pos = 80
+        a.bytepos -= 5
+        assert a.bytepos == 5
+        a.pos -= 5
+        assert a.pos == 35
+
+
+class TestAppend:
+    def test_append(self):
+        s1 = BitStream('0b00000')
+        s1.append(BitStream(bool=True))
+        assert s1.bin == '000001'
+        assert (BitStream('0x0102') + BitStream('0x0304')).hex == '01020304'
+
+    def test_append_same_bitstring(self):
+        s1 = BitStream('0xf0')[:6]
+        s1.append(s1)
+        assert s1.bin == '111100111100'
+
+    def test_append_with_offset(self):
+        s = BitStream(bytes=b'\x28\x28', offset=1)
+        s.append('0b0')
+        assert s.hex == '5050'
+
+
+class TestByteAlign:
+    def test_byte_align(self):
+        s = BitStream(hex='0001ff23')
+        s.bytealign()
+        assert s.bytepos == 0
+        s.pos += 11
+        s.bytealign()
+        assert s.bytepos == 2
+        s.pos -= 10
+        s.bytealign()
+        assert s.bytepos == 1
+
+    def test_insert_byte_aligned(self):
+        s = BitStream('0x0011')
+        s.insert(BitStream('0x22'), 8)
+        assert s.hex == '002211'
+        s = BitStream(0)
+        s.insert(BitStream(bin='101'), 0)
+        assert s.bin == '101'
+
+
+class TestTruncate:
+    def test_truncate_start(self):
+        s = BitStream('0b1')
+        del s[0]
+        assert not s
+        s = BitStream(hex='1234')
+        assert s.hex == '1234'
+        del s[:4]
+        assert s.hex == '234'
+        del s[:9]
+        assert s.bin == '100'
+        del s[:2]
+        assert s.bin == '0'
+        assert s.len == 1
+        del s[:1]
+        assert not s
+
+    def test_truncate_end(self):
+        s = BitStream('0b1')
+        del s[-1:]
+        assert not s
+        s = BitStream(bytes=b'\x12\x34')
+        assert s.hex == '1234'
+        del s[-4:]
+        assert s.hex == '123'
+        del s[-9:]
+        assert s.bin == '000'
+        del s[-3:]
+        assert not s
+        s = BitStream('0b001')
+        del s[:2]
+        del s[-1:]
+        assert not s
+
+
+class TestSlice:
+    def test_byte_aligned_slice(self):
+        s = BitStream(hex='0x123456')
+        assert s[8:16].hex == '34'
+        s = s[8:24]
+        assert s.len == 16
+        assert s.hex == '3456'
+        s = s[0:8]
+        assert s.hex == '34'
+        s.hex = '0x123456'
+        assert s[8:24][0:8].hex == '34'
+
+    def test_slice(self):
+        s = BitStream(bin='000001111100000')
+        s1 = s[0:5]
+        s2 = s[5:10]
+        s3 = s[10:15]
+        assert s1.bin == '00000'
+        assert s2.bin == '11111'
+        assert s3.bin == '00000'
+
+
+class TestInsert:
+    def test_insert(self):
+        s1 = BitStream(hex='0x123456')
+        s2 = BitStream(hex='0xff')
+        s1.bytepos = 1
+        s1.insert(s2)
+        assert s1.bytepos == 2
+        assert s1.hex == '12ff3456'
+        s1.insert('0xee', 24)
+        assert s1.hex == '12ff34ee56'
+        assert s1.bitpos == 32
+        with pytest.raises(ValueError):
+            s1.insert('0b1', -1000)
+        with pytest.raises(ValueError):
+            s1.insert('0b1', 1000)
+
+    def test_insert_null(self):
+        s = BitStream(hex='0x123')
+        s.insert(BitStream(), 3)
+        assert s.hex == '123'
+
+    def test_insert_bits(self):
+        one = BitStream(bin='1')
+        zero = BitStream(bin='0')
+        s = BitStream(bin='00')
+        s.insert(one, 0)
+        assert s.bin == '100'
+        s.insert(zero, 0)
+        assert s.bin == '0100'
+        s.insert(one, s.len)
+        assert s.bin == '01001'
+        s.insert(s, 2)
+        assert s.bin == '0101001001'
+
+
+class TestResetting:
+    def test_set_hex(self):
+        s = BitStream()
+        s.hex = '0'
+        assert s.hex == '0'
+        s.hex = '0x010203045'
+        assert s.hex == '010203045'
+        with pytest.raises(bitstring.CreationError):
+            s.hex = '0x002g'
+
+    def test_set_bin(self):
+        s = BitStream(bin="000101101")
+        assert s.bin == '000101101'
+        assert s.len == 9
+        s.bin = '0'
+        assert s.bin == '0'
+        assert s.len == 1
+
+    def test_set_empty_bin(self):
+        s = BitStream(hex='0x000001b3')
+        s.bin = ''
+        assert s.len == 0
+        assert s.bin == ''
+
+    def test_set_invalid_bin(self):
+        s = BitStream()
+        with pytest.raises(bitstring.CreationError):
+            s.bin = '00102'
+
+
+class TestOverwriting:
+    def test_overwrite_bit(self):
+        s = BitStream(bin='0')
+        s.overwrite(BitStream(bin='1'), 0)
+        assert s.bin == '1'
+
+    def test_overwrite_limits(self):
+        s = BitStream(bin='0b11111')
+        s.overwrite(BitStream(bin='000'), 0)
+        assert s.bin == '00011'
+        s.overwrite('0b000', 2)
+        assert s.bin == '00000'
+
+    def test_overwrite_null(self):
+        s = BitStream(hex='342563fedec')
+        s2 = BitStream(s)
+        s.overwrite(BitStream(bin=''), 23)
+        assert s.bin == s2.bin
+
+    def test_overwrite_position(self):
+        s1 = BitStream(hex='0123456')
+        s2 = BitStream(hex='ff')
+        s1.bytepos = 1
+        s1.overwrite(s2)
+        assert (s1.hex, s1.bytepos) == ('01ff456', 2)
+        s1.overwrite('0xff', 0)
+        assert (s1.hex, s1.bytepos) == ('ffff456', 1)
+
+    def test_overwrite_with_self(self):
+        s = BitStream('0x123')
+        s.overwrite(s)
+        assert s == '0x123'
+
+
+class TestSplit:
+    def test_split_byte_aligned_corner_cases(self):
+        s = BitStream()
+        bsl = s.split(BitStream(hex='0xff'))
+        assert next(bsl).hex == ''
+        with pytest.raises(StopIteration):
+            _ = next(bsl)
+        s = BitStream(hex='aabbcceeddff')
+        delimiter = BitStream()
+        bsl = s.split(delimiter)
+        with pytest.raises(ValueError):
+            _ = next(bsl)
+        delimiter = BitStream(hex='11')
+        bsl = s.split(delimiter)
+        assert next(bsl).hex == s.hex
+
+    def test_split_byte_aligned(self):
+        s = BitStream(hex='0x1234aa1234bbcc1234ffff')
+        delimiter = BitStream(hex='1234')
+        bsl = s.split(delimiter)
+        assert [b.hex for b in bsl] == ['', '1234aa', '1234bbcc', '1234ffff']
+        assert s.pos == 0
+
+    def test_split_byte_aligned_with_intial_bytes(self):
+        s = BitStream(hex='aa471234fedc43 47112233 47 4723 472314')
+        delimiter = BitStream(hex='47')
+        s.find(delimiter)
+        assert s.bytepos == 1
+        bsl = s.split(delimiter, start=0)
+        assert [b.hex for b in bsl] == ['aa', '471234fedc43', '47112233',
+                                                '47', '4723', '472314']
+        assert s.bytepos == 1
+
+    def test_split_byte_aligned_with_overlapping_delimiter(self):
+        s = BitStream(hex='aaffaaffaaffaaffaaff')
+        bsl = s.split(BitStream(hex='aaffaa'))
+        assert [b.hex for b in bsl] == ['', 'aaffaaff', 'aaffaaffaaff']
+
+
+class TestAdding:
+    def test_adding(self):
+        s1 = BitStream(hex='0x0102')
+        s2 = BitStream(hex='0x0304')
+        s3 = s1 + s2
+        assert s1.hex == '0102'
+        assert s2.hex == '0304'
+        assert s3.hex == '01020304'
+        s3 += s1
+        assert s3.hex == '010203040102'
+        assert s2[9:16].bin == '0000100'
+        assert s1[0:9].bin == '000000010'
+        s4 = BitStream(bin='000000010') + BitStream(bin='0000100')
+        assert s4.bin == '0000000100000100'
+        s5 = s1[0:9] + s2[9:16]
+        assert s5.bin == '0000000100000100'
+
+    def test_more_adding(self):
+        s = BitStream(bin='00') + BitStream(bin='') + BitStream(bin='11')
+        assert s.bin == '0011'
+        s = '0b01'
+        s += BitStream('0b11')
+        assert s.bin == '0111'
+        s = BitStream('0x00')
+        t = BitStream('0x11')
+        s += t
+        assert s.hex == '0011'
+        assert t.hex == '11'
+        s += s
+        assert s.hex == '00110011'
+
+    def test_radd(self):
+        s = '0xff' + BitStream('0xee')
+        assert s.hex == 'ffee'
+
+    def test_truncate_asserts(self):
+        s = BitStream('0x001122')
+        s.bytepos = 2
+        del s[-s.len:]
+        # self.assertEqual(s.bytepos, 0)
+        s.append('0x00')
+        s.append('0x1122')
+        s.bytepos = 2
+        del s[:s.len]
+        # self.assertEqual(s.bytepos, 0)
+        s.append('0x00')
+
+    def test_overwrite_errors(self):
+        s = BitStream(bin='11111')
+        with pytest.raises(ValueError):
+            s.overwrite(BitStream(bin='1'), -10)
+        with pytest.raises(ValueError):
+            s.overwrite(BitStream(bin='1'), 6)
+        s.overwrite('bin=0', 5)
+        assert s.b == '111110'
+        s.overwrite(BitStream(hex='0x00'), 1)
+        assert s.b == '100000000'
+
+    def test_delete_bits(self):
+        s = BitStream(bin='000111100000')
+        s.bitpos = 4
+        del s[4:8]
+        assert s.bin == '00010000'
+        del s[4:1004]
+        assert s.bin, '0001'
+
+    def test_delete_bits_with_position(self):
+        s = BitStream(bin='000111100000')
+        del s[4:8]
+        assert s.bin == '00010000'
+
+    def test_delete_bytes(self):
+        s = BitStream('0x00112233')
+        del s[8:8]
+        assert s.hex == '00112233'
+        assert s.pos == 0
+        del s[8:16]
+        assert s.hex == '002233'
+        assert s.bytepos == 0
+        del s[:24]
+        assert not s
+        assert s.pos == 0
+
+    def test_get_item_with_positive_position(self):
+        s = BitStream(bin='0b1011')
+        assert s[0] == True
+        assert s[1] == False
+        assert s[2] == True
+        assert s[3] == True
+        with pytest.raises(IndexError):
+            _ = s[4]
+
+    def test_get_item_with_negative_position(self):
+        s = BitStream(bin='1011')
+        assert s[-1] == True
+        assert s[-2] == True
+        assert s[-3] == False
+        assert s[-4] == True
+        with pytest.raises(IndexError):
+            _ = s[-5]
+
+    def test_slicing(self):
+        s = ConstBitStream(hex='0123456789')
+        assert s[0:8].hex == '01'
+        assert not s[0:0]
+        assert not s[23:20]
+        assert s[8:12].bin == '0010'
+        assert s[32:80] == '0x89'
+
+    def test_negative_slicing(self):
+        s = ConstBitStream(hex='012345678')
+        assert s[:-8].hex == '0123456'
+        assert s[-16:-8].hex == '56'
+        assert s[-24:].hex == '345678'
+        assert s[-1000:-24] == '0x012'
+
+    def test_len(self):
+        s = BitStream()
+        assert len(s) == 0
+        s.append(BitStream(bin='001'))
+        assert len(s) == 3
+
+    def test_join(self):
+        s1 = BitStream(bin='0')
+        s2 = BitStream(bin='1')
+        s3 = BitStream(bin='000')
+        s4 = BitStream(bin='111')
+        strings = [s1, s2, s1, s3, s4]
+        s = BitStream().join(strings)
+        assert s.bin == '010000111'
+
+    def test_join2(self):
+        s1 = BitStream(hex='00112233445566778899aabbccddeeff')
+        s2 = BitStream(bin='0b000011')
+        bsl = [s1[0:32], s1[4:12], s2, s2, s2, s2]
+        s = ConstBitStream().join(bsl)
+        assert s.hex == '00112233010c30c3'
+
+        bsl = [BitStream(uint=j, length=12) for j in range(10) for _ in range(10)]
+        s = BitStream().join(bsl)
+        assert s.length == 1200
+
+    def test_join_with_ints(self):
+        with pytest.raises(TypeError):
+            s = BitStream().join([1, 2])
+
+    def test_pos(self):
+        s = BitStream(bin='1')
+        assert s.bitpos == 0
+        s.read(1)
+        assert s.bitpos == 1
+
+    def test_writing_data(self):
+        strings = [BitStream(bin=x) for x in ['0', '001', '0011010010', '010010', '1011']]
+        s = BitStream().join(strings)
+        s2 = BitStream(bytes=s.bytes)
+        assert s2.bin == '000100110100100100101011'
+        s2.append(BitStream(bin='1'))
+        s3 = BitStream(bytes=s2.tobytes())
+        assert s3.bin == '00010011010010010010101110000000'
+
+    def test_writing_data_with_offsets(self):
+        s1 = BitStream(bytes=b'\x10')
+        s2 = BitStream(bytes=b'\x08\x00', length=8, offset=1)
+        s3 = BitStream(bytes=b'\x04\x00', length=8, offset=2)
+        assert s1 == s2
+        assert s2 == s3
+        assert s1.bytes == s2.bytes
+        assert s2.bytes == s3.bytes
+
+    def test_various_things1(self):
+        hexes = ['12345678', '87654321', 'ffffffffff', 'ed', '12ec']
+        bins = ['001010', '1101011', '0010000100101110110110', '11', '011']
+        bsl = []
+        for (hex_, bin_) in list(zip(hexes, bins)) * 5:
+            bsl.append(BitStream(hex=hex_))
+            bsl.append(BitStream(bin=bin_))
+        s = BitStream().join(bsl)
+        for (hex_, bin_) in list(zip(hexes, bins)) * 5:
+            h = s.read(4 * len(hex_))
+            b = s.read(len(bin_))
+            assert h.hex == hex_
+            assert b.bin == bin_
+
+    def test_various_things2(self):
+        s1 = BitStream(hex="0x1f08")[:13]
+        assert s1.bin == '0001111100001'
+        s2 = BitStream(bin='0101')
+        assert s2.bin == '0101'
+        s1.append(s2)
+        assert s1.length == 17
+        assert s1.bin == '00011111000010101'
+        s1 = s1[3:8]
+        assert s1.bin == '11111'
+
+    def test_various_things3(self):
+        s1 = BitStream(hex='0x012480ff')[2:27]
+        s2 = s1 + s1
+        assert s2.length == 50
+        s3 = s2[0:25]
+        s4 = s2[25:50]
+        assert s3.bin == s4.bin
+
+    def test_peek_bit(self):
+        s = BitStream(bin='01')
+        assert s.peek(1) == [0]
+        assert s.peek(1) == [0]
+        assert s.read(1) == [0]
+        assert s.peek(1) == [1]
+        assert s.peek(1) == [1]
+
+        s = BitStream(bytes=b'\x1f', offset=3)
+        assert s.len == 5
+        assert s.peek(5).bin == '11111'
+        assert s.peek(5).bin == '11111'
+        s.pos += 1
+        with pytest.raises(bitstring.ReadError):
+            _ = s.peek(5)
+
+        s = BitStream(hex='001122334455')
+        assert s.peek(8).hex == '00'
+        assert s.read(8).hex == '00'
+        s.pos += 33
+        with pytest.raises(bitstring.ReadError):
+            _ = s.peek(8)
+
+        s = BitStream(hex='001122334455')
+        assert s.peek(8 * 2).hex == '0011'
+        assert s.read(8 * 3).hex == '001122'
+        assert s.peek(8 * 3).hex == '334455'
+        with pytest.raises(bitstring.ReadError):
+            _ = s.peek(25)
+
+    def test_advance_bit(self):
+        s = BitStream(hex='0xff')
+        s.bitpos = 6
+        s.pos += 1
+        assert s.bitpos == 7
+        s.bitpos += 1
+        with pytest.raises(ValueError):
+            s.pos += 1
+
+    def test_advance_byte(self):
+        s = BitStream(hex='0x010203')
+        s.bytepos += 1
+        assert s.bytepos == 1
+        s.bytepos += 1
+        assert s.bytepos == 2
+        s.bytepos += 1
+        with pytest.raises(ValueError):
+            s.bytepos += 1
+
+    def test_retreat_bit(self):
+        s = BitStream(hex='0xff')
+        with pytest.raises(ValueError):
+            s.pos -= 1
+        s.pos = 5
+        s.pos -= 1
+        assert s.pos == 4
+
+    def test_retreat_byte(self):
+        s = BitStream(hex='0x010203')
+        with pytest.raises(ValueError):
+            s.bytepos -= 1
+        s.bytepos = 3
+        s.bytepos -= 1
+        assert s.bytepos == 2
+        assert s.read(8).hex == '03'
+
+    def test_creation_by_auto(self):
+        s = BitStream('0xff')
+        assert s.hex == 'ff'
+        s = BitStream('0b00011')
+        assert s.bin == '00011'
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream('hello')
+        s1 = BitStream(bytes=b'\xf5', length=3, offset=5)
+        with pytest.raises(TypeError):
+            _ = BitStream(1.2)
+
+    def test_creation_by_auto2(self):
+        s = BitStream('bin=001')
+        assert s.bin == '001'
+        s = BitStream('oct=0o007')
+        assert s.oct == '007'
+        s = BitStream('hex=123abc')
+        assert s == '0x123abc'
+
+        s = BitStream('bin2=01')
+        assert s == '0b01'
+        for s in ['bin:1=01', 'bits:4=0b1', 'oct3=000', 'hex4=0x1234']:
+            with pytest.raises(bitstring.CreationError):
+                _ = BitStream(s)
+
+    def test_insert_using_auto(self):
+        s = BitStream('0xff')
+        s.insert('0x00', 4)
+        assert s.hex == 'f00f'
+        with pytest.raises(ValueError):
+            s.insert('ff')
+
+    def test_overwrite_using_auto(self):
+        s = BitStream('0x0110')
+        s.overwrite('0b1')
+        assert s.hex == '8110'
+        s.overwrite('')
+        assert s.hex == '8110'
+        with pytest.raises(ValueError):
+            s.overwrite('0bf')
+
+    def test_find_using_auto(self):
+        s = BitStream('0b000000010100011000')
+        assert s.find('0b101')
+        assert s.pos == 7
+
+    def test_findbytealigned_using_auto(self):
+        s = BitStream('0x00004700')
+        assert s.find('0b01000111', bytealigned=True)
+        assert s.bytepos == 2
+
+    def test_append_using_auto(self):
+        s = BitStream('0b000')
+        s.append('0b111')
+        assert s.bin == '000111'
+        s.append('0b0')
+        assert s.bin == '0001110'
+
+    def test_split_byte_aligned_using_auto(self):
+        s = BitStream('0x000143563200015533000123')
+        sections = s.split('0x0001')
+        assert next(sections).hex == ''
+        assert next(sections).hex == '0001435632'
+        assert next(sections).hex == '00015533'
+        assert next(sections).hex == '000123'
+        pytest.raises(StopIteration, next, sections)
+
+    def test_split_byte_aligned_with_self(self):
+        s = BitStream('0x1234')
+        sections = s.split(s)
+        assert next(sections).hex == ''
+        assert next(sections).hex == '1234'
+        with pytest.raises(StopIteration):
+            next(sections)
+
+    def test_prepend(self):
+        s = BitStream('0b000')
+        s.prepend('0b11')
+        assert s.bin == '11000'
+        s.prepend(s)
+        assert s.bin == '1100011000'
+        s.prepend('')
+        assert s.bin == '1100011000'
+
+    def test_null_slice(self):
+        s = BitStream('0x111')
+        t = s[1:1]
+        assert len(t) == 0
+
+    def test_multiple_autos(self):
+        s = BitStream('0xa')
+        s.prepend('0xf')
+        s.append('0xb')
+        assert s == '0xfab'
+        s.prepend(s)
+        s.append('0x100')
+        s.overwrite('0x5', 4)
+        assert s == '0xf5bfab100'
+
+    def test_reverse(self):
+        s = BitStream('0b0011')
+        s.reverse()
+        assert s.bin == '1100'
+        s = BitStream('0b10')
+        s.reverse()
+        assert s.bin == '01'
+        s = BitStream()
+        s.reverse()
+        assert s.bin == ''
+
+    def test_init_with_concatenated_strings(self):
+        s = BitStream('0xff 0Xee 0xd 0xcc')
+        assert s.hex == 'ffeedcc'
+        s = BitStream('0b0 0B111 0b001')
+        assert s.bin == '0111001'
+        s += '0b1' + '0B1'
+        assert s.bin == '011100111'
+        s = BitStream(hex='ff0xee')
+        assert s.hex == 'ffee'
+        s = BitStream(bin='000b0b11')
+        assert s.bin == '0011'
+        s = BitStream('  0o123 0O 7 0   o1')
+        assert s.oct == '12371'
+        s += '  0 o 332'
+        assert s.oct == '12371332'
+
+    def test_equals(self):
+        s1 = BitStream('0b01010101')
+        s2 = BitStream('0b01010101')
+        assert s1 == s2
+        s3 = BitStream()
+        s4 = BitStream()
+        assert s3 == s4
+        assert not s3 != s4
+        s5 = BitStream(bytes=b'\xff', offset=2, length=3)
+        s6 = BitStream('0b111')
+        assert s5 == s6
+
+        class A(object):
+            pass
+        assert not s5 == A()
+
+    def test_large_equals(self):
+        s1 = BitStream(1000000)
+        s2 = BitStream(1000000)
+        s1.set(True, [-1, 55, 53214, 534211, 999999])
+        s2.set(True, [-1, 55, 53214, 534211, 999999])
+        assert s1 == s2
+        s1.set(True, 800000)
+        assert s1 != s2
+
+    def test_not_equals(self):
+        s1 = BitStream('0b0')
+        s2 = BitStream('0b1')
+        assert s1 != s2
+        assert not s1 != BitStream('0b0')
+
+    def test_equality_with_auto_initialised(self):
+        a = BitStream('0b00110111')
+        assert a == '0b00110111'
+        assert a == '0x37'
+        assert '0b0011 0111' == a
+        assert '0x3 0x7' == a
+        assert not a == '0b11001000'
+        assert not '0x3737' == a
+
+    def test_invert_special_method(self):
+        s = BitStream('0b00011001')
+        assert (~s).bin == '11100110'
+        assert (~BitStream('0b0')).bin == '1'
+        assert (~BitStream('0b1')).bin == '0'
+        assert ~~s == s
+
+    def test_invert_bit_position(self):
+        s = ConstBitStream('0xefef')
+        s.pos = 8
+        t = ~s
+        assert s.pos == 8
+        assert t.pos == 0
+
+    def test_invert_special_method_errors(self):
+        s = BitStream()
+        with pytest.raises(bitstring.Error):
+            _ = ~s
+
+    def test_join_with_auto(self):
+        s = BitStream().join(['0xf', '0b00', BitStream(bin='11')])
+        assert s == '0b11110011'
+
+    def test_auto_bit_string_copy(self):
+        s = BitStream('0xabcdef')
+        t = BitStream(s)
+        assert t.hex == 'abcdef'
+        del s[-8:]
+        assert t.hex == 'abcdef'
+
+
+class TestMultiplication:
+
+    def test_multiplication(self):
+        a = BitStream('0xff')
+        b = a * 8
+        assert b == '0xffffffffffffffff'
+        b = 4 * a
+        assert b == '0xffffffff'
+        assert 1 * a == a * 1 == a
+        c = a * 0
+        assert not c
+        a *= 3
+        assert a == '0xffffff'
+        a *= 0
+        assert not a
+        one = BitStream('0b1')
+        zero = BitStream('0b0')
+        mix = one * 2 + 3 * zero + 2 * one * 2
+        assert mix == '0b110001111'
+        q = BitStream()
+        q *= 143
+        assert not q
+        q += [True, True, False]
+        assert q.bitpos == 3
+        q *= 0
+        assert not q
+        assert q.bitpos == 0
+
+    def test_multiplication_with_files(self):
+        a = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
+        b = a.len
+        a *= 3
+        assert a.len == 3 * b
+
+    def test_multiplication_errors(self):
+        a = BitStream('0b1')
+        b = BitStream('0b0')
+        with pytest.raises(ValueError):
+            _ = a * -1
+        with pytest.raises(ValueError):
+            a *= -1
+        with pytest.raises(ValueError):
+            _ = -1 * a
+        with pytest.raises(TypeError):
+            _ = a * 1.2
+        with pytest.raises(TypeError):
+            _ = b * a
+        with pytest.raises(TypeError):
+            a *= b
+
+
+class TestBitWise:
+
+    def test_bitwise_and(self):
+        a = BitStream('0b01101')
+        b = BitStream('0b00110')
+        assert (a & b).bin == '00100'
+        assert (a & '0b11111') == a
+        with pytest.raises(ValueError):
+            _ = a & '0b1'
+        with pytest.raises(ValueError):
+            _ = b & '0b110111111'
+        c = BitStream('0b0011011')
+        c.pos = 4
+        d = c & '0b1111000'
+        assert d.pos == 0
+        assert d.bin == '0011000'
+        d = '0b1111000' & c
+        assert d.bin == '0011000'
+
+    def test_bitwise_or(self):
+        a = BitStream('0b111001001')
+        b = BitStream('0b011100011')
+        c = a | b
+        assert c.bin == '111101011'
+        assert (a | '0b000000000') == a
+        with pytest.raises(ValueError):
+            _ = a | '0b0000'
+        with pytest.raises(ValueError):
+            _ = b | (a + '0b1')
+        a = '0xff00' | BitStream('0x00f0')
+        assert a.hex == 'fff0'
+
+    def test_bitwise_xor(self):
+        a = BitStream('0b111001001')
+        b = BitStream('0b011100011')
+        c = a ^ b
+        assert c.bin == '100101010'
+        assert (a ^ '0b111100000').bin == '000101001'
+        with pytest.raises(ValueError):
+            _ = a ^ '0b0000'
+        with pytest.raises(ValueError):
+            _ = b ^ (a + '0b1')
+        a = '0o707' ^ BitStream('0o777')
+        assert a.oct == '070'
+
+
+class TestSplit2:
+
+    def test_split(self):
+        a = BitStream('0b0 010100111 010100 0101 010')
+        a.pos = 20
+        subs = [i.bin for i in a.split('0b010')]
+        assert subs == ['0', '010100111', '010100', '0101', '010']
+        assert a.pos == 20
+
+    def test_split_corner_cases(self):
+        a = BitStream('0b000000')
+        bsl = a.split('0b1', False)
+        assert next(bsl) == a
+        with pytest.raises(StopIteration):
+            next(bsl)
+        b = BitStream()
+        bsl = b.split('0b001', False)
+        assert not next(bsl)
+        with pytest.raises(StopIteration):
+            _ = next(bsl)
+
+    def test_split_errors(self):
+        a = BitStream('0b0')
+        b = a.split('', False)
+        with pytest.raises(ValueError):
+            _ = next(b)
+
+    def test_slice_with_offset(self):
+        a = BitStream(bytes=b'\x00\xff\x00', offset=7)
+        b = a[7:12]
+        assert b.bin == '11000'
+
+    def test_split_with_maxsplit(self):
+        a = BitStream('0xaabbccbbccddbbccddee')
+        assert len(list(a.split('0xbb', bytealigned=True))) == 4
+        bsl = list(a.split('0xbb', count=1, bytealigned=True))
+        assert (len(bsl), bsl[0]) == (1, '0xaa')
+        bsl = list(a.split('0xbb', count=2, bytealigned=True))
+        assert len(bsl) == 2
+        assert bsl[0] == '0xaa'
+        assert bsl[1] == '0xbbcc'
+
+    def test_split_more(self):
+        s = BitStream('0b1100011001110110')
+        for i in range(10):
+            a = list(s.split('0b11', False, count=i))
+            b = list(s.split('0b11', False))[:i]
+            assert a == b
+        b = s.split('0b11', count=-1)
+        with pytest.raises(ValueError):
+            _ = next(b)
+
+    def test_split_startbit(self):
+        a = BitStream('0b0010101001000000001111')
+        bsl = a.split('0b001', bytealigned=False, start=1)
+        assert [x.bin for x in bsl] == ['010101', '001000000', '001111']
+        b = a.split('0b001', start=-100)
+        with pytest.raises(ValueError):
+            _ = next(b)
+        b = a.split('0b001', start=23)
+        with pytest.raises(ValueError):
+            _ = next(b)
+        b = a.split('0b1', start=10, end=9)
+        with pytest.raises(ValueError):
+            _ = next(b)
+
+    def test_split_startbit_byte_aligned(self):
+        a = BitStream('0x00ffffee')
+        bsl = list(a.split('0b111', start=9, bytealigned=True))
+        assert [x.bin for x in bsl] == ['1111111', '11111111', '11101110']
+
+    def test_split_endbit(self):
+        a = BitStream('0b000010001001011')
+        bsl = list(a.split('0b1', bytealigned=False, end=14))
+        assert [x.bin for x in bsl] == ['0000', '1000', '100', '10', '1']
+        assert list(a[4:12].split('0b0', False)) == list(a.split('0b0', start=4, end=12))
+        try:
+            list(a.split('0xffee', end=15))
+        except ValueError:
+            pytest.fail("ValueError raised unexpectedly")
+        # Whereas this one will when we call next()
+        bsl = a.split('0xffee', end=16)
+        with pytest.raises(ValueError):
+            _ = next(bsl)
+
+    def test_split_endbit_byte_aligned(self):
+        a = BitStream('0xff00ff')[:22]
+        bsl = list(a.split('0b 0000 0000 111', end=19))
+        assert [x.bin for x in bsl] == ['11111111', '00000000111']
+        bsl = list(a.split('0b 0000 0000 111', end=18))
+        assert [x.bin for x in bsl] == ['111111110000000011']
+
+    def test_split_max_split(self):
+        a = BitStream('0b1' * 20)
+        for i in range(10):
+            bsl = list(a.split('0b1', count=i))
+            assert len(bsl) == i
+
+    #######################
+
+    def test_explicit_auto(self):
+        with pytest.raises(bitstring.CreationError):
+            a = BitStream(auto='0x1')
+
+    def test_position_in_slice(self):
+        a = BitStream('0x00ffff00')
+        a.bytepos = 2
+        b = a[8:24]
+        assert b.bytepos == 0
+
+    def test_find_byte_aligned_with_bits(self):
+        a = BitStream('0x00112233445566778899')
+        a.find('0b0001', bytealigned=True)
+        assert a.bitpos == 8
+
+    def test_find_startbit_not_byte_aligned(self):
+        a = BitStream('0b0010000100')
+        found = a.find('0b1', start=4)
+        assert (found, a.bitpos) == ((7,), 7)
+        found = a.find('0b1', start=2)
+        assert (found, a.bitpos) == ((2,), 2)
+        found = a.find('0b1', bytealigned=False, start=8)
+        assert (found, a.bitpos) == ((), 2)
+
+    def test_find_endbit_not_byte_aligned(self):
+        a = BitStream('0b0010010000')
+        found = a.find('0b1', bytealigned=False, end=2)
+        assert (found, a.bitpos) == ((), 0)
+        found = a.find('0b1', end=3)
+        assert (found, a.bitpos) == ((2,), 2)
+        found = a.find('0b1', bytealigned=False, start=3, end=5)
+        assert (found, a.bitpos) == ((), 2)
+        found = a.find('0b1', start=3, end=6)
+        assert (found[0], a.bitpos) == (5, 5)
+
+    def test_find_startbit_byte_aligned(self):
+        a = BitStream('0xff001122ff0011ff')
+        a.pos = 40
+        found = a.find('0x22', start=23, bytealigned=True)
+        assert (found, a.bytepos) == ((24,), 3)
+        a.bytepos = 4
+        found = a.find('0x22', start=24, bytealigned=True)
+        assert (found, a.bytepos) == ((24,), 3)
+        found = a.find('0x22', start=25, bytealigned=True)
+        assert (found, a.pos) == ((), 24)
+        found = a.find('0b111', start=40, bytealigned=True)
+        assert (found, a.pos) == ((56,), 56)
+
+    def test_find_endbit_byte_aligned(self):
+        a = BitStream('0xff001122ff0011ff')
+        found = a.find('0x22', end=31, bytealigned=True)
+        assert not found
+        assert a.pos == 0
+        found = a.find('0x22', end=32, bytealigned=True)
+        assert found
+        assert a.pos == 24
+        assert found[0] == 24
+
+    def test_find_start_endbit_errors(self):
+        a = BitStream('0b00100')
+        with pytest.raises(ValueError):
+            _ = a.find('0b1', bytealigned=False, start=-100)
+        with pytest.raises(ValueError):
+            _ = a.find('0b1', end=6)
+        with pytest.raises(ValueError):
+            _ = a.find('0b1', start=4, end=3)
+        b = BitStream('0x0011223344')
+        with pytest.raises(ValueError):
+            _ = b.find('0x22', bytealigned=True, start=-100)
+        with pytest.raises(ValueError):
+            _ = b.find('0x22', end=41, bytealigned=True)
+
+    def test_prepend_and_append_again(self):
+        c = BitStream('0x1122334455667788')
+        c.bitpos = 40
+        c.append('0b1')
+        assert c.bitpos == len(c)
+        c = BitStream()
+        c.prepend('0x1234')
+        assert c.bytepos == 0
+        c = BitStream()
+        c.append('0x1234')
+        assert c.bytepos == 2
+        s = BitStream(bytes=b'\xff\xff', offset=2)
+        assert s.length == 14
+        t = BitStream(bytes=b'\x80', offset=1, length=2)
+        s.prepend(t)
+        assert s == '0x3fff'
+
+    def test_find_all(self):
+        a = BitStream('0b11111')
+        p = a.findall('0b1')
+        assert list(p) == [0, 1, 2, 3, 4]
+        p = a.findall('0b11')
+        assert list(p) == [0, 1, 2, 3]
+        p = a.findall('0b10')
+        assert list(p) == []
+        a = BitStream('0x4733eeff66554747335832434547')
+        p = a.findall('0x47', bytealigned=True)
+        assert list(p) == [0, 6 * 8, 7 * 8, 13 * 8]
+        p = a.findall('0x4733', bytealigned=True)
+        assert list(p) == [0, 7 * 8]
+        a = BitStream('0b1001001001001001001')
+        p = a.findall('0b1001', bytealigned=False)
+        assert list(p) == [0, 3, 6, 9, 12, 15]
+        assert a.pos == 0
+
+    def test_find_all_generator(self):
+        a = BitStream('0xff1234512345ff1234ff12ff')
+        p = a.findall('0xff', bytealigned=True)
+        assert next(p) == 0
+        assert next(p) == 6 * 8
+        assert next(p) == 9 * 8
+        assert next(p) == 11 * 8
+        with pytest.raises(StopIteration):
+            _ = next(p)
+
+    def test_find_all_count(self):
+        s = BitStream('0b1') * 100
+        for i in [0, 1, 23]:
+            assert len(list(s.findall('0b1', count=i))) == i
+        with pytest.raises(ValueError):
+            _ = s.findall('0b1', bytealigned=True, count=-1)
+
+    def test_contains(self):
+        a = BitStream('0b1') + '0x0001dead0001'
+        assert '0xdead' in a
+        assert a.pos == 0
+        assert not '0xfeed' in a
+
+    def test_repr(self):
+        max_ = bitstring.bits.MAX_CHARS
+        bls = ['', '0b1', '0o5', '0x43412424f41', '0b00101001010101']
+        for bs in bls:
+            a = BitStream(bs)
+            b = eval(a.__repr__())
+            assert a == b
+        filename = os.path.join(THIS_DIR, 'test.m1v')
+        for f in [ConstBitStream(filename=filename),
+                  ConstBitStream(filename=filename, length=17),
+                  ConstBitStream(filename=filename, length=23, offset=23102)]:
+            f2 = eval(f.__repr__())
+            assert f2.tobytes() == f.tobytes()
+        a = BitStream('0b1')
+        assert repr(a) == "BitStream('0b1')"
+        a += '0b11'
+        a.pos = 2
+        assert repr(a) == "BitStream('0b111', pos=2)"
+        a.pos = 0
+        a += '0b1'
+        assert repr(a) == "BitStream('0xf', pos=4)"
+        a.pos = 0
+        a *= max_
+        assert repr(a) == "BitStream('0x" + "f" * max_ + "')"
+        a += '0xf'
+        assert repr(a) == "BitStream('0x" + "f" * max_ + "...', pos=1004)  # length=%d" % (max_ * 4 + 4)
+
+    def test_print(self):
+        s = BitStream(hex='0x00')
+        assert '0x' + s.hex == s.__str__()
+        s = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
+        assert '0x' + s[0: bitstring.bits.MAX_CHARS * 4].hex + '...' == s.__str__()
+        assert BitStream().__str__() == ''
+        s = BitStream('0b11010')
+        assert '0b' + s.bin == s.__str__()
+        s = BitStream('0x12345678901234567890,0b1')
+        assert '0x12345678901234567890, 0b1' == s.__str__()
+
+    def test_iter(self):
+        a = BitStream('0b001010')
+        b = BitStream()
+        for bit in a:
+            b.append(ConstBitStream(bool=bit))
+        assert a == b
+
+    def test_delitem(self):
+        a = BitStream('0xffee')
+        del a[0:8]
+        assert a.hex == 'ee'
+        del a[0:8]
+        assert not a
+        del a[10:12]
+        assert not a
+
+    def test_non_zero_bits_at_start(self):
+        a = BitStream(bytes=b'\xff', offset=2)
+        b = BitStream('0b00')
+        b += a
+        assert b == '0b0011 1111'
+        assert a.tobytes() == b'\xfc'
+
+    def test_non_zero_bits_at_end(self):
+        a = BitStream(bytes=b'\xff', length=5)
+        b = BitStream('0b00')
+        a += b
+        assert a == '0b1111100'
+        assert a.tobytes() == b'\xf8'
+        with pytest.raises(ValueError):
+            _ = a.bytes
+
+    def test_new_offset_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream(hex='ff', offset=-1)
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream('0xffffffff', offset=33)
+
+    def test_slice_step(self):
+        a = BitStream('0x3')
+        b = a[::1]
+        assert a == b
+        assert a[2:4:1] == '0b11'
+        assert a[0:2:1] == '0b00'
+        assert a[:3] == '0o1'
+
+        a = BitStream('0x0011223344556677')
+        assert a[-8:] == '0x77'
+        assert a[:-24] == '0x0011223344'
+        assert a[-1000:-24] == '0x0011223344'
+
+    def test_interesting_slice_step(self):
+        a = BitStream('0b0011000111')
+        assert a[7:3:-1] == '0b1000'
+        assert a[9:2:-1] == '0b1110001'
+        assert a[8:2:-2] == '0b100'
+        assert a[100:-20:-3] == '0b1010'
+        assert a[100:-20:-1] == '0b1110001100'
+        assert a[10:2:-1] == '0b1110001'
+        assert a[100:2:-1] == '0b1110001'
+
+    def test_insertion_order_and_bitpos(self):
+        b = BitStream()
+        b[0:0] = '0b0'
+        b[0:0] = '0b1'
+        assert b == '0b10'
+        assert b.bitpos == 0
+        a = BitStream()
+        a.insert('0b0')
+        a.insert('0b1')
+        assert a == '0b01'
+        assert a.bitpos == 2
+
+    def test_overwrite_order_and_bitpos(self):
+        a = BitStream('0xff')
+        a.overwrite('0xa')
+        assert a == '0xaf'
+        assert a.bitpos == 4
+        a.overwrite('0xb')
+        assert a == '0xab'
+        assert a.bitpos == 8
+        a.overwrite('0xa', 4)
+        assert a == '0xaa'
+        assert a.bitpos == 8
+        a.overwrite(a, 0)
+        assert a == '0xaa'
+
+    def test_init_slice_with_int(self):
+        a = BitStream(length=8)
+        a[:] = 100
+        assert a.uint == 100
+        a[0] = 1
+        assert a.bin == '11100100'
+        a[1] = 0
+        assert a.bin == '10100100'
+        a[-1] = -1
+        assert a.bin == '10100101'
+        a[-3:] = -2
+        assert a.bin == '10100110'
+
+    def test_init_slice_with_int_errors(self):
+        a = BitStream('0b0000')
+        with pytest.raises(ValueError):
+            a[0:4] = 16
+        with pytest.raises(ValueError):
+            a[0:4] = -9
+        with pytest.raises(ValueError):
+            a[0] = 2
+        with pytest.raises(ValueError):
+            a[0] = -2
+
+    def test_reverse_with_slice(self):
+        a = BitStream('0x0012ff')
+        a.reverse()
+        assert a == '0xff4800'
+        a.reverse(8, 16)
+        assert a == '0xff1200'
+        b = a[8:16]
+        b.reverse()
+        a[8:16] = b
+        assert a == '0xff4800'
+
+    def test_reverse_with_slice_errors(self):
+        a = BitStream('0x123')
+        with pytest.raises(ValueError):
+            a.reverse(-1, 4)
+        with pytest.raises(ValueError):
+            a.reverse(10, 9)
+        with pytest.raises(ValueError):
+            a.reverse(1, 10000)
+
+    def test_initialise_from_list(self):
+        a = BitStream([])
+        assert not a
+        a = BitStream([True, False, [], [0], 'hello'])
+        assert a == '0b10011'
+        a += []
+        assert a == '0b10011'
+        a += [True, False, True]
+        assert a == '0b10011101'
+        a.find([12, 23])
+        assert a.pos == 3
+        assert [1, 0, False, True] == BitStream('0b1001')
+        a = [True] + BitStream('0b1')
+        assert a == '0b11'
+
+    def test_initialise_from_tuple(self):
+        a = BitStream(())
+        assert not a
+        a = BitStream((0, 1, '0', '1'))
+        assert '0b0111' == a
+        a.replace((True, True), [])
+        assert a == (False, True)
+
+    def test_cut(self):
+        a = BitStream('0x00112233445')
+        b = list(a.cut(8))
+        assert b == ['0x00', '0x11', '0x22', '0x33', '0x44', '0x5']
+        b = list(a.cut(4, 8, 16))
+        assert b == ['0x1', '0x1']
+        b = list(a.cut(4, 0, 44, 4))
+        assert b == ['0x0', '0x0', '0x1', '0x1']
+        a = BitStream()
+        b = list(a.cut(10))
+        assert not b
+
+    def test_cut_errors(self):
+        a = BitStream('0b1')
+        b = a.cut(1, 1, 2)
+        with pytest.raises(ValueError):
+            _ = next(b)
+        b = a.cut(1, -2, 1)
+        with pytest.raises(ValueError):
+            _ = next(b)
+        b = a.cut(0)
+        with pytest.raises(ValueError):
+            _ = next(b)
+        b = a.cut(1, count=-1)
+        with pytest.raises(ValueError):
+            _ = next(b)
+
+    def test_cut_problem(self):
+        s = BitStream('0x1234')
+        for n in list(s.cut(4)):
+            s.prepend(n)
+        assert s == '0x43211234'
+
+    def test_join_functions(self):
+        a = BitStream().join(['0xa', '0xb', '0b1111'])
+        assert a == '0xabf'
+        a = BitStream('0b1').join(['0b0' for _ in range(10)])
+        assert a == '0b0101010101010101010'
+        a = BitStream('0xff').join([])
+        assert not a
+        a = BitStream('0xff').join([Bits(5), '0xab', '0xabc'])
+        assert a == '0b00000, 0xffabffabc'
+
+    def test_adding_bitpos(self):
+        a = BitStream('0xff')
+        b = BitStream('0x00')
+        a.bitpos = b.bitpos = 8
+        c = a + b
+        assert c.bitpos == 0
+
+    def test_intelligent_read1(self):
+        a = BitStream(uint=123, length=23)
+        u = a.read('uint:23')
+        assert u == 123
+        assert a.pos == a.len
+        b = BitStream(int=-12, length=44)
+        i = b.read('int:44')
+        assert i == -12
+        assert b.pos == b.len
+        u2, i2 = (a + b).readlist('uint:23, int:44')
+        assert (u2, i2) == (123, -12)
+
+    def test_intelligent_read2(self):
+        a = BitStream(ue=822)
+        u = a.read('ue')
+        assert u == 822
+        assert a.pos == a.len
+        b = BitStream(se=-1001)
+        s = b.read('se')
+        assert s == -1001
+        assert b.pos == b.len
+        s, u1, u2 = (b + 2 * a).readlist('se, ue, ue')
+        assert (s, u1, u2) == (-1001, 822, 822)
+
+    def test_intelligent_read3(self):
+        a = BitStream('0x123') + '0b11101'
+        h = a.read('hex:12')
+        assert h == '123'
+        b = a.read(' bin : 5 ')
+        assert b == '11101'
+        c = '0b' + b + a
+        b, h = c.readlist('bin:5, hex:12')
+        assert (b, h) == ('11101', '123')
+
+    def test_intelligent_read4(self):
+        a = BitStream('0o007')
+        o = a.read('oct:9')
+        assert o == '007'
+        assert a.pos == a.len
+
+    def test_intelligent_read5(self):
+        a = BitStream('0x00112233')
+        c0, c1, c2 = a.readlist('bits:8, bits:8, bits:16')
+        assert (c0, c1, c2) == (BitStream('0x00'), BitStream('0x11'), BitStream('0x2233'))
+        a.pos = 0
+        c = a.read('bits:16')
+        assert c == BitStream('0x0011')
+
+    def test_intelligent_read6(self):
+        a = BitStream('0b000111000')
+        b1, b2, b3 = a.readlist('bin :3, int: 3, int:3')
+        assert b1 == '000'
+        assert b2 == -1
+        assert b3 == 0
+
+    def test_intelligent_read7(self):
+        a = BitStream('0x1234')
+        a1, a2, a3, a4 = a.readlist('bin:0, oct:0, hex:0, bits:0')
+        assert a1 == a2 == a3 == ''
+        assert not a4
+        with pytest.raises(ValueError):
+            _ = a.read('int:0')
+        with pytest.raises(ValueError):
+            _ = a.read('uint:0')
+        assert a.pos == 0
+
+    def test_intelligent_read8(self):
+        a = BitStream('0x123456')
+        for t in ['hex:1', 'oct:1', '-5', 'fred', 'bin:-2',
+                  'uint:p', 'uint:-2', 'int:u', 'int:-3', 'ses', 'uee', '-14']:
+            with pytest.raises(ValueError):
+                _ = a.read(t)
+
+    def test_intelligent_read9(self):
+        a = BitStream('0xff')
+        assert a.read('intle8') == -1
+
+    def test_intelligent_peek(self):
+        a = BitStream('0b01, 0x43, 0o4, uint:23=2, se=5, ue=3')
+        b, c, e = a.peeklist('bin:2, hex:8, oct:3')
+        assert (b, c, e) == ('01', '43', '4')
+        assert a.pos == 0
+        a.pos = 13
+        f, g, h = a.peeklist('uint:23, se, ue')
+        assert (f, g, h) == (2, 5, 3)
+        assert a.pos == 13
+
+    def test_read_multiple_bits(self):
+        s = BitStream('0x123456789abcdef')
+        a, b = s.readlist([4, 4])
+        assert a == '0x1'
+        assert b == '0x2'
+        c, d, e = s.readlist([8, 16, 8])
+        assert c == '0x34'
+        assert d == '0x5678'
+        assert e == '0x9a'
+
+    def test_peek_multiple_bits(self):
+        s = BitStream('0b1101, 0o721, 0x2234567')
+        a, b, c, d = s.peeklist([2, 1, 1, 9])
+        assert a == '0b11'
+        assert bool(b) == True
+        assert bool(c) == True
+        assert d == '0o721'
+        assert s.pos == 0
+        a, b = s.peeklist([4, 9])
+        assert a == '0b1101'
+        assert b == '0o721'
+        s.pos = 13
+        a, b = s.peeklist([16, 8])
+        assert a == '0x2234'
+        assert b == '0x56'
+        assert s.pos == 13
+
+    def test_difficult_prepends(self):
+        a = BitStream('0b1101011')
+        b = BitStream()
+        for i in range(10):
+            b.prepend(a)
+        assert b == a * 10
+
+    def test_packing_wrong_number_of_things(self):
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bin:1')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('', 100)
+
+    def test_pack_with_various_keys(self):
+        a = pack('uint10', uint10='0b1')
+        assert a == '0b1'
+        b = pack('0b110', **{'0b110': '0xfff'})
+        assert b == '0xfff'
+
+    def test_pack_with_variable_length(self):
+        for i in range(1, 11):
+            a = pack('uint:n', 0, n=i)
+            assert a.bin == '0' * i
+
+    def test_to_bytes(self):
+        a = BitStream(bytes=b'\xab\x00')
+        b = a.tobytes()
+        assert a.bytes == b
+        for i in range(7):
+            del a[-1:]
+            assert a.tobytes() == b'\xab\x00'
+        del a[-1:]
+        assert a.tobytes() == b'\xab'
+
+    def test_to_file(self):
+        filename = os.path.join(THIS_DIR, 'temp_bitstring_unit_testing_file')
+        a = BitStream('0x0000ff')[:17]
+        with open(filename, 'wb') as f:
+            a.tofile(f)
+        b = BitStream(filename=filename)
+        assert b == '0x000080'
+
+        a = BitStream('int:1000000=-1')
+        assert a.int == -1
+        with open(filename, 'wb') as f:
+            a.tofile(f)
+        b = BitStream(filename=filename)
+        assert b.int == -1
+        assert b.len == 1000000
+
+    def test_token_parser(self):
+        tp = bitstring.utils.tokenparser
+        assert tp('hex') == (True, [('hex', None, None)])
+        assert tp('hex=14') == (True, [('hex', None, '14')])
+        assert tp('0xef') == (False, [('0x', None, 'ef')])
+        assert tp('uint:12') == (False, [('uint', 12, None)])
+        assert tp('int:30=-1') == (False, [('int', 30, '-1')])
+        assert tp('bits10') == (False, [('bits', 10, None)])
+        assert tp('bits:10') == (False, [('bits', 10, None)])
+        assert tp('123') == (False, [('bits', 123, None)])
+        assert tp('123') == (False, [('bits', 123, None)])
+        assert tp('hex12', ('hex12',)) == (False, [('hex12', None, None)])
+        assert tp('2*bits:6') == (False, [('bits', 6, None), ('bits', 6, None)])
+
+    def test_token_parser_struct_codes(self):
+        tp = bitstring.utils.tokenparser
+        assert tp('>H') == (False, [('uintbe', 16, None)])
+        assert tp('<H') == (False, [('uintle', 16, None)])
+        assert tp('=H') == (False, [('uintne', 16, None)])
+        assert tp('@H') == (False, [('uintne', 16, None)])
+        assert tp('>b') == (False, [('int', 8, None)])
+        assert tp('<b') == (False, [('int', 8, None)])
+
+    def test_auto_from_file_object(self):
+        filename = os.path.join(THIS_DIR, 'test.m1v')
+        with open(filename, 'rb') as f:
+            s = ConstBitStream(f, offset=32, length=12)
+            assert s.uint == 352
+            t = ConstBitStream('0xf') + f
+            assert t.startswith('0xf000001b3160')
+            s2 = ConstBitStream(f)
+            t2 = BitStream('0xc')
+            t2.prepend(s2)
+            assert t2.startswith('0x000001b3')
+            assert t2.endswith('0xc')
+            with open(filename, 'rb') as b:
+                u = BitStream(bytes=b.read())
+                assert u == s2
+
+    def test_file_based_copy(self):
+        with open(os.path.join(THIS_DIR, 'smalltestfile'), 'rb') as f:
+            s = BitStream(f)
+            t = BitStream(s)
+            s.prepend('0b1')
+            assert s[1:] == t
+            s = BitStream(f)
+            t = copy.copy(s)
+            t.append('0b1')
+            assert s == t[:-1]
+
+    def test_big_endian_synonyms(self):
+        s = BitStream('0x12318276ef')
+        assert s.int == s.intbe
+        assert s.uint == s.uintbe
+        s = BitStream(intbe=-100, length=16)
+        assert s == 'int:16=-100'
+        s = BitStream(uintbe=13, length=24)
+        assert s == 'int:24=13'
+        s = BitStream('uintbe:32=1000')
+        assert s == 'uint:32=1000'
+        s = BitStream('intbe:8=2')
+        assert s == 'int:8=2'
+        assert s.read('intbe8') == 2
+        s.pos = 0
+        assert s.read('uintbe8') == 2
+
+    def test_big_endian_synonym_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream(uintbe=100, length=15)
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream(intbe=100, length=15)
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream('uintbe:17=100')
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream('intbe:7=2')
+        s = BitStream('0b1')
+        with pytest.raises(bitstring.InterpretError):
+            _ = s.intbe
+        with pytest.raises(bitstring.InterpretError):
+            _ = s.uintbe
+        with pytest.raises(ValueError):
+            _ = s.read('uintbe')
+        with pytest.raises(ValueError):
+            _ = s.read('intbe')
+
+    def test_little_endian_uint(self):
+        s = BitStream(uint=100, length=16)
+        assert s.uintle == 25600
+        s = BitStream(uintle=100, length=16)
+        assert s.uint == 25600
+        assert s.uintle == 100
+        s.uintle += 5
+        assert s.uintle == 105
+        s = BitStream('uintle:32=999')
+        assert s.uintle == 999
+        s.byteswap()
+        assert s.uint == 999
+        s = pack('uintle:24', 1001)
+        assert s.uintle == 1001
+        assert s.length == 24
+        assert s.read('uintle24') == 1001
+
+    def test_little_endian_int(self):
+        s = BitStream(int=100, length=16)
+        assert s.intle == 25600
+        s = BitStream(intle=100, length=16)
+        assert s.int == 25600
+        assert s.intle == 100
+        s.intle = 105
+        assert s.intle == 105
+        s = BitStream('intle:32=999')
+        assert s.intle == 999
+        s.byteswap()
+        assert s.int == 999
+        s = pack('intle:24', 1001)
+        assert s.intle == 1001
+        assert s.length == 24
+        assert s.read('intle24') == 1001
+
+    def test_little_endian_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream('uintle:15=10')
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream('intle:31=-999')
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream(uintle=100, length=15)
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream(intle=100, length=15)
+        s = BitStream('0xfff')
+        with pytest.raises(bitstring.InterpretError):
+            _ = s.intle
+        with pytest.raises(bitstring.InterpretError):
+            _ = s.uintle
+        with pytest.raises(ValueError):
+            _ = s.read('uintle')
+        with pytest.raises(ValueError):
+            _ = s.read('intle')
+
+    def test_struct_tokens1(self):
+        assert pack('<b', 23) == BitStream('intle:8=23')
+        assert pack('<B', 23) == BitStream('uintle:8=23')
+        assert pack('<h', 23) == BitStream('intle:16=23')
+        assert pack('<H', 23) == BitStream('uintle:16=23')
+        assert pack('<l', 23) == BitStream('intle:32=23')
+        assert pack('<L', 23) == BitStream('uintle:32=23')
+        assert pack('<q', 23) == BitStream('intle:64=23')
+        assert pack('<Q', 23) == BitStream('uintle:64=23')
+        assert pack('>b', 23) == BitStream('intbe:8=23')
+        assert pack('>B', 23) == BitStream('uintbe:8=23')
+        assert pack('>h', 23) == BitStream('intbe:16=23')
+        assert pack('>H', 23) == BitStream('uintbe:16=23')
+        assert pack('>l', 23) == BitStream('intbe:32=23')
+        assert pack('>L', 23) == BitStream('uintbe:32=23')
+        assert pack('>q', 23) == BitStream('intbe:64=23')
+        assert pack('>Q', 23) == BitStream('uintbe:64=23')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('<B', -1)
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('<H', -1)
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('<L', -1)
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('<Q', -1)
+
+    def test_struct_tokens2(self):
+        # I couldn't find a way to test both types of native endianness
+        # on a single machine, so only one set of tests will run.
+        if sys.byteorder == 'little':
+            assert pack('=b', 23) == BitStream('intle:8=23')
+            assert pack('=B', 23) == BitStream('uintle:8=23')
+            assert pack('=h', 23) == BitStream('intle:16=23')
+            assert pack('=H', 23) == BitStream('uintle:16=23')
+            assert pack('@l', 23) == BitStream('intle:32=23')
+            assert pack('@L', 23) == BitStream('uintle:32=23')
+            assert pack('@q', 23) == BitStream('intle:64=23')
+            assert pack('@Q', 23) == BitStream('uintle:64=23')
+        else:
+            assert pack('@b', 23) == BitStream('intbe:8=23')
+            assert pack('@B', 23) == BitStream('uintbe:8=23')
+            assert pack('@h', 23) == BitStream('intbe:16=23')
+            assert pack('@H', 23) == BitStream('uintbe:16=23')
+            assert pack('@l', 23) == BitStream('intbe:32=23')
+            assert pack('@L', 23) == BitStream('uintbe:32=23')
+            assert pack('@q', 23) == BitStream('intbe:64=23')
+            assert pack('@Q', 23) == BitStream('uintbe:64=23')
+
+    def test_native_endianness(self):
+        s = pack('=2L', 40, 40)
+        if sys.byteorder == 'little':
+            assert s == pack('<2L', 40, 40)
+        else:
+            assert sys.byteorder == 'big'
+            assert s == pack('>2L', 40, 40)
+
+    def test_struct_tokens3(self):
+        s = pack('>hhl', 1, 2, 3)
+        a, b, c = s.unpack('>hhl')
+        assert (a, b, c) == (1, 2, 3)
+        s = pack('<QL, >Q \tL', 1001, 43, 21, 9999)
+        assert s.unpack('<QL, >QL') == [1001, 43, 21, 9999]
+
+    def test_struct_tokens_multiplicative_factors(self):
+        s = pack('<2h', 1, 2)
+        a, b = s.unpack('<2h')
+        assert (a, b) == (1, 2)
+        s = pack('<100q', *range(100))
+        assert s.len == 100 * 64
+        assert s[44*64:45*64].uintle == 44
+        s = pack('@L0B2h', 5, 5, 5)
+        assert s.unpack('@Lhh') == [5, 5, 5]
+
+    def test_struct_tokens_errors(self):
+        for f in ['>>q', '<>q', 'q>', '2q', 'q', '>-2q', '@a', '>int:8', '>q2']:
+            with pytest.raises(bitstring.CreationError):
+                _ = pack(f, 100)
+
+    def test_immutable_bit_streams(self):
+        a = ConstBitStream('0x012345')
+        assert a == '0x012345'
+        b = BitStream('0xf') + a
+        assert b == '0xf012345'
+        with pytest.raises(AttributeError):
+            a.append(b)
+        with pytest.raises(AttributeError):
+            a.prepend(b)
+        with pytest.raises(TypeError):
+            a[0] = '0b1'
+        with pytest.raises(TypeError):
+            del a[5]
+        with pytest.raises(AttributeError):
+            a.replace('0b1', '0b0')
+        with pytest.raises(AttributeError):
+            a.insert('0b11', 4)
+        with pytest.raises(AttributeError):
+            a.reverse()
+        with pytest.raises(AttributeError):
+            a.reversebytes()
+        assert a == '0x012345'
+        assert isinstance(a, ConstBitStream)
+
+    def test_reverse_bytes(self):
+        a = BitStream('0x123456')
+        a.byteswap()
+        assert a == '0x563412'
+        b = a + '0b1'
+        b.byteswap()
+        assert '0x123456, 0b1' == b
+        a = BitStream('0x54')
+        a.byteswap()
+        assert a == '0x54'
+        a = BitStream()
+        a.byteswap()
+        assert not a
+
+    def test_reverse_bytes2(self):
+        a = BitStream()
+        a.byteswap()
+        assert not a
+        a = BitStream('0x00112233')
+        a.byteswap(0, 0, 16)
+        assert a == '0x11002233'
+        a.byteswap(0, 4, 28)
+        assert a == '0x12302103'
+        a.byteswap(start=0, end=18)
+        assert a == '0x30122103'
+        with pytest.raises(ValueError):
+            a.byteswap(0, 10, 2)
+        with pytest.raises(ValueError):
+            a.byteswap(0, -4, 4)
+        with pytest.raises(ValueError):
+            a.byteswap(0, 24, 48)
+        a.byteswap(0, 24)
+        assert a == '0x30122103'
+        a.byteswap(0, 11, 11)
+        assert a == '0x30122103'
+
+    def test_capitals_in_pack(self):
+        a = pack('A', A='0b1')
+        assert a == '0b1'
+        format_ = 'bits:4=BL_OFFT, uint:12=width, uint:12=height'
+        d = {'BL_OFFT': '0b1011', 'width': 352, 'height': 288}
+        s = bitstring.pack(format_, **d)
+        assert s == '0b1011, uint:12=352, uint:12=288'
+        a = pack('0X0, uint:8, hex', 45, '0XABcD')
+        assert a == '0x0, uint:8=45, 0xabCD'
+
+    def test_other_capitals(self):
+        a = ConstBitStream('0XABC, 0O0, 0B11')
+        assert a == 'hex=0Xabc, oct=0, bin=0B11'
+
+    def test_efficient_overwrite(self):
+        a = BitStream(100000000)
+        a.overwrite([1], 123456)
+        assert a[123456] == True
+        a.overwrite('0xff', 1)
+        assert a[0:32:1] == '0x7f800000'
+        b = BitStream('0xffff')
+        b.overwrite('0x0000')
+        assert b == '0x0000'
+        assert b.pos == 16
+        c = BitStream(length=1000)
+        c.overwrite('0xaaaaaaaaaaaa', 81)
+        assert c[81:81 + 6 * 8] == '0xaaaaaaaaaaaa'
+        assert len(list(c.findall('0b1'))) == 24
+        s = BitStream(length=1000)
+        s = s[5:]
+        s.overwrite('0xffffff', 500)
+        s.pos = 500
+        assert s.read(4 * 8) == '0xffffff00'
+        s.overwrite('0xff', 502)
+        assert s[502:518] == '0xffff'
+
+    def test_peek_and_read_list_errors(self):
+        a = BitStream('0x123456')
+        with pytest.raises(ValueError):
+            _ = a.read('hex:8, hex:8')
+        with pytest.raises(ValueError):
+            _ = a.peek('hex:8, hex:8')
+        with pytest.raises(TypeError):
+            _ = a.read(10, 12)
+        with pytest.raises(TypeError):
+            _ = a.peek(12, 14)
+        with pytest.raises(TypeError):
+            _ = a.read(8, 8)
+        with pytest.raises(TypeError):
+            _ = a.peek(80, 80)
+
+    def test_startswith(self):
+        a = BitStream()
+        assert a.startswith(BitStream())
+        assert not a.startswith('0b0')
+        a = BitStream('0x12ff')
+        assert a.startswith('0x1')
+        assert a.startswith('0b0001001')
+        assert a.startswith('0x12ff')
+        assert not a.startswith('0x12ff, 0b1')
+        assert not a.startswith('0x2')
+
+    def test_startswith_start_end(self):
+        s = BitStream('0x123456')
+        assert s.startswith('0x234', 4)
+        assert not s.startswith('0x123', end=11)
+        assert s.startswith('0x123', end=12)
+        assert s.startswith('0x34', 8, 16)
+        assert not s.startswith('0x34', 7, 16)
+        assert not s.startswith('0x34', 9, 16)
+        assert not s.startswith('0x34', 8, 15)
+
+    def test_endswith(self):
+        a = BitStream()
+        assert a.endswith('')
+        assert not a.endswith(BitStream('0b1'))
+        a = BitStream('0xf2341')
+        assert a.endswith('0x41')
+        assert a.endswith('0b001')
+        assert a.endswith('0xf2341')
+        assert not a.endswith('0x1f2341')
+        assert not a.endswith('0o34')
+
+    def test_endswith_start_end(self):
+        s = BitStream('0x123456')
+        assert s.endswith('0x234', end=16)
+        assert not s.endswith('0x456', start=13)
+        assert s.endswith('0x456', start=12)
+        assert s.endswith('0x34', 8, 16)
+        assert s.endswith('0x34', 7, 16)
+        assert not s.endswith('0x34', 9, 16)
+        assert not s.endswith('0x34', 8, 15)
+
+    def test_unhashability(self):
+        s = BitStream('0xf')
+        with pytest.raises(TypeError):
+            _ = {s}
+        with pytest.raises(TypeError):
+            _ = hash([s])
+
+    def test_const_bit_stream_set_creation(self):
+        sl = [ConstBitStream(uint=i, length=7) for i in range(15)]
+        s = set(sl)
+        assert len(s) == 15
+        s.add(ConstBitStream('0b0000011'))
+        assert len(s) == 15
+        with pytest.raises(TypeError):
+            s.add(BitStream('0b0000011'))
+
+    def test_const_bit_stream_functions(self):
+        s = ConstBitStream('0xf, 0b1')
+        assert type(s) == ConstBitStream
+        t = copy.copy(s)
+        assert type(t) == ConstBitStream
+        a = s + '0o3'
+        assert type(a) == ConstBitStream
+        b = a[0:4]
+        assert type(b) == ConstBitStream
+        b = a[4:3]
+        assert type(b) == ConstBitStream
+        b = a[5:2:-1]
+        assert type(b) == ConstBitStream
+        b = ~a
+        assert type(b) == ConstBitStream
+        b = a << 2
+        assert type(b) == ConstBitStream
+        b = a >> 2
+        assert type(b) == ConstBitStream
+        b = a * 2
+        assert type(b) == ConstBitStream
+        b = a * 0
+        assert type(b) == ConstBitStream
+        b = a & ~a
+        assert type(b) == ConstBitStream
+        b = a | ~a
+        assert type(b) == ConstBitStream
+        b = a ^ ~a
+        assert type(b) == ConstBitStream
+        b = a._slice(4, 4)
+        assert type(b) == ConstBitStream
+        b = a.read(4)
+        assert type(b) == ConstBitStream
+
+    def test_const_bit_stream_properties(self):
+        a = ConstBitStream('0x123123')
+        with pytest.raises(AttributeError):
+            a.hex = '0x234'
+        with pytest.raises(AttributeError):
+            a.oct = '0o234'
+        with pytest.raises(AttributeError):
+            a.bin = '0b101'
+        with pytest.raises(AttributeError):
+            a.ue = 3453
+        with pytest.raises(AttributeError):
+            a.se = -123
+        with pytest.raises(AttributeError):
+            a.int = 432
+        with pytest.raises(AttributeError):
+            a.uint = 4412
+        with pytest.raises(AttributeError):
+            a.intle = 123
+        with pytest.raises(AttributeError):
+            a.uintle = 4412
+        with pytest.raises(AttributeError):
+            a.intbe = 123
+        with pytest.raises(AttributeError):
+            a.uintbe = 4412
+        with pytest.raises(AttributeError):
+            a.intne = 123
+        with pytest.raises(AttributeError):
+            a.uintne = 4412
+        with pytest.raises(AttributeError):
+            a.bytes = b'hello'
+
+    def test_const_bit_stream_misc(self):
+        a = ConstBitStream('0xf')
+        b = a
+        a += '0xe'
+        assert b == '0xf'
+        assert a == '0xfe'
+        c = BitStream(a)
+        assert a == c
+        a = ConstBitStream('0b1')
+        a += a
+        assert a == '0b11'
+        assert type(a) == ConstBitStream
+        a._addleft(a)
+        assert a == '0b1111'
+        assert type(a) == ConstBitStream
+
+    def test_const_bit_stream_hashibility(self):
+        a = ConstBitStream('0x1')
+        b = ConstBitStream('0x2')
+        c = ConstBitStream('0x1')
+        c.pos = 3
+        s = {a, b, c}
+        assert len(s) == 2
+        assert hash(a) == hash(c)
+
+    def test_const_hashability_again(self):
+        a = ConstBitStream(uint=1 << 300, length=10000)
+        b = ConstBitStream(uint=2 << 300, length=10000)
+        c = ConstBitStream(uint=3 << 300, length=10000)
+        s = {a, b, c}
+        assert len(s) == 3
+
+    def test_hash_edge_cases(self):
+        a = ConstBitStream('0xabcd')
+        b = ConstBitStream('0xabcd')
+        c = b[1:]
+        assert hash(a) == hash(b)
+        assert hash(a) != hash(c)
+
+    def test_const_bit_stream_copy(self):
+        a = ConstBitStream('0xabc')
+        a.pos = 11
+        b = copy.copy(a)
+        b.pos = 4
+        assert id(a._bitstore) == id(b._bitstore)
+        assert a.pos == 11
+        assert b.pos == 4
+
+    def test_python26stuff(self):
+        s = BitStream('0xff')
+        assert isinstance(s.tobytes(), bytes)
+        assert isinstance(s.bytes, bytes)
+
+    def test_read_from_bits(self):
+        a = ConstBitStream('0xaabbccdd')
+        b = a.read(8)
+        assert b == '0xaa'
+        assert a[0:8] == '0xaa'
+        assert a[-1] == True
+        a.pos = 0
+        assert a.read(4).uint == 10
+
+
+class TestSet:
+    def test_set(self):
+        a = BitStream(length=16)
+        a.set(True, 0)
+        assert a == '0b10000000 00000000'
+        a.set(1, 15)
+        assert a == '0b10000000 00000001'
+        b = a[4:12]
+        b.set(True, 1)
+        assert b == '0b01000000'
+        b.set(True, -1)
+        assert b == '0b01000001'
+        b.set(1, -8)
+        assert b == '0b11000001'
+        with pytest.raises(IndexError):
+            b.set(True, -9)
+        with pytest.raises(IndexError):
+            b.set(True, 8)
+
+    def test_set_negative_index(self):
+        a = BitStream(10)
+        a.set(1, -1)
+        assert a.bin == '0000000001'
+        a.set(1, [-1, -10])
+        assert a.bin == '1000000001'
+        with pytest.raises(IndexError):
+            a.set(1, [-11])
+
+    def test_file_based_set_unset(self):
+        filename = os.path.join(THIS_DIR, 'test.m1v')
+        a = BitStream(filename=filename)
+        a.set(True, (0, 1, 2, 3, 4))
+        assert a[0:32] == '0xf80001b3'
+        a = BitStream(filename=filename)
+        a.set(False, (28, 29, 30, 31))
+        assert a.startswith('0x000001b0')
+
+    def test_set_list(self):
+        a = BitStream(length=18)
+        a.set(True, range(18))
+        assert a.int == -1
+        a.set(False, range(18))
+        assert a.int == 0
+
+    def test_unset(self):
+        a = BitStream(length=16, int=-1)
+        a.set(False, 0)
+        assert ~a == '0b10000000 00000000'
+        a.set(0, 15)
+        assert ~a == '0b10000000 00000001'
+        b = a[4:12]
+        b.set(False, 1)
+        assert ~b == '0b01000000'
+        b.set(False, -1)
+        assert ~b == '0b01000001'
+        b.set(False, -8)
+        assert ~b == '0b11000001'
+        with pytest.raises(IndexError):
+            b.set(False, -9)
+        with pytest.raises(IndexError):
+            b.set(False, 8)
+
+    def test_set_whole_bit_stream(self):
+        a = BitStream(10000)
+        a.set(1)
+        assert a.all(1)
+        a.set(0)
+        assert a.all(0)
+
+
+class TestInvert:
+    def test_invert_bits(self):
+        a = BitStream('0b111000')
+        a.invert(range(a.len))
+        assert a == '0b000111'
+        a.invert([0, 1, -1])
+        assert a == '0b110110'
+
+    def test_invert_whole_bit_stream(self):
+        a = BitStream('0b11011')
+        a.invert()
+        assert a == '0b00100'
+
+    def test_invert_single_bit(self):
+        a = BitStream('0b000001')
+        a.invert(0)
+        assert a.bin == '100001'
+        a.invert(-1)
+        assert a.bin == '100000'
+
+    def test_invert_errors(self):
+        a = BitStream(10)
+        with pytest.raises(IndexError):
+            a.invert(10)
+        with pytest.raises(IndexError):
+            a.invert(-11)
+        with pytest.raises(IndexError):
+            a.invert([1, 2, 10])
+
+    def test_ior(self):
+        a = BitStream('0b1101001')
+        a |= '0b1110000'
+        assert a == '0b1111001'
+        b = a[2:]
+        c = a[1:-1]
+        b |= c
+        assert c == '0b11100'
+        assert b == '0b11101'
+
+    def test_iand(self):
+        a = BitStream('0b0101010101000')
+        a &= '0b1111110000000'
+        assert a == '0b0101010000000'
+        s = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'), offset=26, length=24)
+        s &= '0xff00ff'
+        assert s == '0xcc0004'
+
+    def test_ixor(self):
+        a = BitStream('0b11001100110011')
+        a ^= '0b11111100000010'
+        assert a == '0b00110000110001'
+
+    def test_logical_inplace_errors(self):
+        a = BitStream(4)
+        with pytest.raises(ValueError):
+            a |= '0b111'
+        with pytest.raises(ValueError):
+            a &= '0b111'
+        with pytest.raises(ValueError):
+            a ^= '0b111'
+
+
+class TestAllAndAny:
+    def test_all(self):
+        a = BitStream('0b0111')
+        assert a.all(True, (1, 3))
+        assert not a.all(True, (0, 1, 2))
+        assert a.all(True, [-1])
+        assert not a.all(True, [0])
+
+    def test_file_based_all(self):
+        filename = os.path.join(THIS_DIR, 'test.m1v')
+        a = BitStream(filename=filename)
+        assert a.all(True, [31])
+        a = BitStream(filename=filename)
+        assert a.all(False, (0, 1, 2, 3, 4))
+
+    def test_file_based_any(self):
+        filename = os.path.join(THIS_DIR, 'test.m1v')
+        a = BitStream(filename=filename)
+        assert a.any(True, (31, 12))
+        a = BitStream(filename=filename)
+        assert a.any(False, (0, 1, 2, 3, 4))
+        b = ConstBitStream(filename=filename, offset=16)
+        assert b.startswith('0x01')
+        assert not b.any(True, range(0, 7))
+        assert b.any(True, range(0, 8))
+        assert b.any(True)
+
+    def test_any(self):
+        a = BitStream('0b10011011')
+        assert a.any(True, (1, 2, 3, 5))
+        assert not a.any(True, (1, 2, 5))
+        assert a.any(True, (-1,))
+        assert not a.any(True, (1,))
+
+    def test_all_false(self):
+        a = BitStream('0b0010011101')
+        assert a.all(False, (0, 1, 3, 4))
+        assert not a.all(False, (0, 1, 2, 3, 4))
+
+    def test_any_false(self):
+        a = BitStream('0b01001110110111111111111111111')
+        assert a.any(False, (4, 5, 6, 2))
+        assert not a.any(False, (1, 15, 20))
+
+    def test_any_empty_bitstring(self):
+        a = ConstBitStream()
+        assert not a.any(True)
+        assert not a.any(False)
+
+    def test_all_empty_bit_stream(self):
+        a = ConstBitStream()
+        assert a.all(True)
+        assert a.all(False)
+
+    def test_any_whole_bitstring(self):
+        a = ConstBitStream('0xfff')
+        assert a.any(True)
+        assert not a.any(False)
+
+    def test_all_whole_bitstring(self):
+        a = ConstBitStream('0xfff')
+        assert a.all(True)
+        assert not a.all(False)
+
+    def test_errors(self):
+        a = BitStream('0xf')
+        with pytest.raises(IndexError):
+            a.all(True, [5])
+        with pytest.raises(IndexError):
+            a.all(True, [-5])
+        with pytest.raises(IndexError):
+            a.any(True, [5])
+        with pytest.raises(IndexError):
+            a.any(True, [-5])
+
+    ###################
+
+    def test_float_initialisation(self):
+        for f in (0.000001, -1.0, 1.0, 0.2, -3.14159265):
+            a = BitStream(float=f, length=64)
+            a.pos = 6
+            assert a.float == f
+            a = BitStream('float:64=%s' % str(f))
+            a.pos = 6
+            assert a.float == f
+            a = BitStream('floatbe:64=%s' % str(f))
+            a.pos = 6
+            assert a.floatbe == f
+            a = BitStream('floatle:64=%s' % str(f))
+            a.pos = 6
+            assert a.floatle == f
+            a = BitStream('floatne:64=%s' % str(f))
+            a.pos = 6
+            assert a.floatne == f
+
+            b = BitStream(float=f, length=32)
+            b.pos = 6
+            assert b.float / f == pytest.approx(1.0)
+            b = BitStream('float:32=%s' % str(f))
+            b.pos = 6
+            assert b.float / f == pytest.approx(1.0)
+            b = BitStream('floatbe:32=%s' % str(f))
+            b.pos = 6
+            assert b.floatbe / f == pytest.approx(1.0)
+            b = BitStream('floatle:32=%s' % str(f))
+            b.pos = 6
+            assert b.floatle / f == pytest.approx(1.0)
+            b = BitStream('floatne:32=%s' % str(f))
+            b.pos = 6
+            assert b.floatne / f == pytest.approx(1.0)
+
+            a = BitStream(float=f, length=16)
+            a.pos = 6
+            assert a.float == pytest.approx(f, abs=0.01)
+            a = BitStream('float:16=%s' % str(f))
+            a.pos = 6
+            assert a.float == pytest.approx(f, abs=0.01)
+            a = BitStream('floatbe:16=%s' % str(f))
+            a.pos = 6
+            assert a.floatbe == pytest.approx(f, abs=0.01)
+            a = BitStream('floatle:16=%s' % str(f))
+            a.pos = 6
+            assert a.floatle == pytest.approx(f, abs=0.01)
+            a = BitStream('floatne:16=%s' % str(f))
+            a.pos = 6
+            assert a.floatne == pytest.approx(f, abs=0.01)
+
+        a = BitStream('0x12345678')
+        a.pos = 6
+        a.f = 23
+        assert a.f == 23.0
+
+    def test_float_init_strings(self):
+        for s in ('5', '+0.0001', '-1e101', '4.', '.2', '-.65', '43.21E+32'):
+            a = BitStream('float:64=%s' % s)
+            assert a.float == float(s)
+        for s in ('5', '+0.5', '-1e2', '4.', '.25', '-.75'):
+            a = BitStream('float:16=%s' % s)
+            assert a.f == float(s)
+
+    def test_float_packing(self):
+        a = pack('>d', 0.01)
+        assert a.float == 0.01
+        assert a.floatbe == 0.01
+        a.byteswap()
+        assert a.floatle == 0.01
+        b = pack('>f', 1e10)
+        assert b.float / 1e10 == pytest.approx(1.0)
+        c = pack('<f', 10.3)
+        assert c.floatle / 10.3 == pytest.approx(1.0)
+        d = pack('>5d', 10.0, 5.0, 2.5, 1.25, 0.1)
+        assert d.unpack('>5d') == [10.0, 5.0, 2.5, 1.25, 0.1]
+        e = pack('>3e', -100, 100, 0.25)
+        assert e.unpack('>3e') == [-100.0, 100.0, 0.25]
+
+    def test_float_reading(self):
+        a = BitStream('floatle:64=12, floatbe:64=-0.01, floatne:64=3e33')
+        x, y, z = a.readlist('floatle:64, floatbe:64, floatne:64')
+        assert x == 12.0
+        assert y == -0.01
+        assert z == 3e33
+        a = BitStream('floatle:16=12, floatbe:32=-0.01, floatne:32=3e33')
+        x, y, z = a.readlist('floatle:16, floatbe:32, floatne:32')
+        assert x / 12.0 == pytest.approx(1.0)
+        assert y / -0.01 == pytest.approx(1.0)
+        assert z / 3e33 == pytest.approx(1.0)
+        a = BitStream('0b11, floatle:64=12, 0xfffff')
+        a.pos = 2
+        floatle64 = Dtype('floatle64')
+        assert a.read(floatle64) == 12.0
+        b = BitStream(floatle=20, length=32)
+        b.floatle = 10.0
+        b = [0] + b
+        assert b[1:].floatle == 10.0
+
+    def test_non_aligned_float_reading(self):
+        s = BitStream('0b1, float:32 = 10.0')
+        x, y = s.readlist('1, float:32')
+        assert y == 10.0
+        s[1:] = 'floatle:32=20.0'
+        x, y = s.unpack('1, floatle:32')
+        assert y == 20.0
+
+    def test_float_errors(self):
+        a = BitStream('0x3')
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.float
+        with pytest.raises(bitstring.CreationError):
+            a.float = -0.2
+        for le in (8, 10, 12, 18, 30, 128, 200):
+            with pytest.raises(ValueError):
+                _ = BitStream(float=1.0, length=le)
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream(floatle=0.3, length=0)
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream(floatle=0.3, length=1)
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream(float=2)
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.read('floatle:2')
+
+    def test_read_error_changes_pos(self):
+        a = BitStream('0x123123')
+        with pytest.raises(ValueError):
+            a.read('10, 5')
+
+    def test_ror(self):
+        a = BitStream('0b11001')
+        a.ror(0)
+        assert a == '0b11001'
+        a.ror(1)
+        assert a == '0b11100'
+        a.ror(5)
+        assert a == '0b11100'
+        a.ror(101)
+        assert a == '0b01110'
+        a = BitStream('0b1')
+        a.ror(1000000)
+        assert a == '0b1'
+
+    def test_ror_errors(self):
+        a = BitStream()
+        with pytest.raises(bitstring.Error):
+            a.ror(0)
+        a += '0b001'
+        with pytest.raises(ValueError):
+            a.ror(-1)
+
+    def test_rol(self):
+        a = BitStream('0b11001')
+        a.rol(0)
+        assert a == '0b11001'
+        a.rol(1)
+        assert a == '0b10011'
+        a.rol(5)
+        assert a == '0b10011'
+        a.rol(101)
+        assert a == '0b00111'
+        a = BitStream('0b1')
+        a.rol(1000000)
+        assert a == '0b1'
+
+    def test_rol_from_file(self):
+        a = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
+        m = a.len
+        a.rol(1)
+        assert a.startswith('0x000003')
+        assert a.len == m
+        assert a.endswith('0x0036e')
+
+    def test_ror_from_file(self):
+        a = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
+        m = a.len
+        a.ror(1)
+        assert a.startswith('0x800000')
+        assert a.len == m
+        assert a.endswith('0x000db')
+
+    def test_rol_errors(self):
+        a = BitStream()
+        with pytest.raises(bitstring.Error):
+            a.rol(0)
+        a += '0b001'
+        with pytest.raises(ValueError):
+            a.rol(-1)
+
+    def test_bytes_token(self):
+        a = BitStream('0x510203')
+        b = a.read('bytes:1')
+        assert isinstance(b, bytes)
+        assert b == b'\x51'
+        x, y, z = a.unpack('uint:4, bytes:2, uint')
+        assert x == 5
+        assert y == b'\x10\x20'
+        assert z == 3
+        s = pack('bytes:4', b'abcd')
+        assert s.bytes == b'abcd'
+
+    def test_bytes_token_more_thoroughly(self):
+        a = BitStream('0x0123456789abcdef')
+        a.pos += 16
+        assert a.read('bytes:1') == b'\x45'
+        assert a.read('bytes:3') == b'\x67\x89\xab'
+        x, y, z = a.unpack('bits:28, bytes, bits:12')
+        assert y == b'\x78\x9a\xbc'
+
+    def test_dedicated_read_functions(self):
+        a = BitStream('0b11, uint:43=98798798172, 0b11111')
+        x = a[2:45].uint
+        assert x == 98798798172
+        assert a.pos == 0
+        a.pos = 2
+        x = a.read(Dtype('int43'))
+        assert x == 98798798172
+        assert a.pos == 45
+
+        a = BitStream('0b11, uintbe:48=98798798172, 0b11111')
+        a.pos = 2
+        x = a.read(Dtype('uintbe48'))
+        assert x == 98798798172
+        assert a.pos == 50
+
+        a = BitStream('0b111, uintle:40=123516, 0b111')
+        a.pos = 3
+        assert a.read('uintle:40') == 123516
+        b = BitStream('0xff, uintle:800=999, 0xffff')
+        assert b[8:800].uintle == 999
+
+        a = BitStream('0b111, intle:48=999999999, 0b111111111111')
+        a.pos = 3
+        assert a.read('intle48') == 999999999
+        b = BitStream('0xff, intle:200=918019283740918263512351235, 0xfffffff')
+        b.pos = 8
+        assert b.read(Dtype('intle', length=200)) == 918019283740918263512351235
+
+        a = BitStream('0b111, bfloat:16=-5.25, 0xffffffff')
+        a.pos = 3
+        assert a.read('bfloatbe') == -5.25
+
+        a = BitStream('0b111, floatle:64=9.9998, 0b111')
+        a.pos = 3
+        assert a.read('floatle64') == 9.9998
+
+    def test_auto_init_with_int(self):
+        a = BitStream(0)
+        assert not a
+        a = BitStream(1)
+        assert a == '0b0'
+        a = BitStream(1007)
+        assert a == BitStream(length=1007)
+        with pytest.raises(bitstring.CreationError):
+            _ = BitStream(-1)
+
+        assert ConstBitStream(13) == Bits(13)
+        with pytest.raises(TypeError):
+            a += 10
+
+    def test_reading_problems(self):
+        a = BitStream('0x000001')
+        b = a.read('uint:24')
+        assert b == 1
+        a.pos = 0
+        with pytest.raises(bitstring.ReadError):
+            _ = a.read('bytes:4')
+
+    @pytest.mark.skip("Bug #266")
+    def test_pos_reset_bug(self):
+        a = BitStream('0x0120310230123', pos=23)
+        assert a.pos == 23
+        a.u8 = 14
+        assert a.pos == 0
+        a.pos = 5
+        a.u8 = 9
+        assert a.pos == 0
+
+    def test_creation_exception_bug(self):
+        with pytest.raises(ValueError):
+            _ = BitStream(bin=1)
+
+    def test_add_verses_in_place_add(self):
+        a1 = ConstBitStream('0xabc')
+        b1 = a1
+        a1 += '0xdef'
+        assert a1 == '0xabcdef'
+        assert b1 == '0xabc'
+
+        a2 = BitStream('0xabc')
+        b2 = a2
+        c2 = a2 + '0x0'
+        a2 += '0xdef'
+        assert a2 == '0xabcdef'
+        assert b2 == '0xabcdef'
+        assert c2 == '0xabc0'
+
+    def test_and_verses_in_place_and(self):
+        a1 = ConstBitStream('0xabc')
+        b1 = a1
+        a1 &= '0xf0f'
+        assert a1 == '0xa0c'
+        assert b1 == '0xabc'
+
+        a2 = BitStream('0xabc')
+        b2 = a2
+        c2 = a2 & '0x00f'
+        a2 &= '0xf0f'
+        assert a2 == '0xa0c'
+        assert b2 == '0xa0c'
+        assert c2 == '0x00c'
+
+    def test_or_verses_in_place_or(self):
+        a1 = ConstBitStream('0xabc')
+        b1 = a1
+        a1 |= '0xf0f'
+        assert a1 == '0xfbf'
+        assert b1 == '0xabc'
+
+        a2 = BitStream('0xabc')
+        b2 = a2
+        c2 = a2 | '0x00f'
+        a2 |= '0xf0f'
+        assert a2 == '0xfbf'
+        assert b2 == '0xfbf'
+        assert c2 == '0xabf'
+
+    def test_xor_verses_in_place_xor(self):
+        a1 = ConstBitStream('0xabc')
+        b1 = a1
+        a1 ^= '0xf0f'
+        assert a1 == '0x5b3'
+        assert b1 == '0xabc'
+
+        a2 = BitStream('0xabc')
+        b2 = a2
+        c2 = a2 ^ '0x00f'
+        a2 ^= '0xf0f'
+        assert a2 == '0x5b3'
+        assert b2 == '0x5b3'
+        assert c2 == '0xab3'
+
+    def test_mul_verses_in_place_mul(self):
+        a1 = ConstBitStream('0xabc')
+        b1 = a1
+        a1 *= 3
+        assert a1 == '0xabcabcabc'
+        assert b1 == '0xabc'
+
+        a2 = BitStream('0xabc')
+        b2 = a2
+        c2 = a2 * 2
+        a2 *= 3
+        assert a2 == '0xabcabcabc'
+        assert b2 == '0xabcabcabc'
+        assert c2 == '0xabcabc'
+
+    def test_lshift_verses_in_place_lshift(self):
+        a1 = ConstBitStream('0xabc')
+        b1 = a1
+        a1 <<= 4
+        assert a1 == '0xbc0'
+        assert b1 == '0xabc'
+
+        a2 = BitStream('0xabc')
+        b2 = a2
+        c2 = a2 << 8
+        a2 <<= 4
+        assert a2 == '0xbc0'
+        assert b2 == '0xbc0'
+        assert c2 == '0xc00'
+
+    def test_rshift_verses_in_place_rshift(self):
+        a1 = ConstBitStream('0xabc')
+        b1 = a1
+        a1 >>= 4
+        assert a1 == '0x0ab'
+        assert b1 == '0xabc'
+
+        a2 = BitStream('0xabc')
+        b2 = a2
+        c2 = a2 >> 8
+        a2 >>= 4
+        assert a2 == '0x0ab'
+        assert b2 == '0x0ab'
+        assert c2 == '0x00a'
+
+    def test_auto_from_bool(self):
+        with pytest.raises(TypeError):
+            a = ConstBitStream() + True + False + True
+
+
+class TestBugs:
+    def test_bug_in_replace(self):
+        s = BitStream('0x00112233')
+        li = list(s.split('0x22', start=8, bytealigned=True))
+        assert li == ['0x11', '0x2233']
+        s = BitStream('0x00112233')
+        s.replace('0x22', '0xffff', start=8, bytealigned=True)
+        assert s == '0x0011ffff33'
+        s = BitStream('0x0123412341234')
+        s.replace('0x23', '0xf', start=9, bytealigned=True)
+        assert s == '0x012341f41f4'
+
+    def test_truncateleft_bug(self):
+        a = BitStream('0b000000111')[2:]
+        a._truncateleft(6)
+        assert a == '0b1'
+
+    def test_null_bits(self):
+        s = ConstBitStream(bin='')
+        t = ConstBitStream(oct='')
+        u = ConstBitStream(hex='')
+        v = ConstBitStream(bytes=b'')
+        assert not s
+        assert not t
+        assert not u
+        assert not v
+
+    def test_multiplicative_factors_creation(self):
+        s = BitStream('1*0b1')
+        assert s == '0b1'
+        s = BitStream('4*0xc')
+        assert s == '0xcccc'
+        s = BitStream('0b1, 0*0b0')
+        assert s == '0b1'
+        s = BitStream('0b1, 3*uint:8=34, 2*0o755')
+        assert s == '0b1, uint:8=34, uint:8=34, uint:8=34, 0o755755'
+        s = BitStream('0*0b1001010')
+        assert not s
+
+    def test_multiplicative_factors_reading(self):
+        s = BitStream('0xc') * 5
+        a, b, c, d, e = s.readlist('5*uint:4')
+        assert a == b == c == d == e == 12
+        s = ConstBitStream('2*0b101, 4*uint:7=3')
+        a, b, c, d, e = s.readlist('2*bin:3, 3*uint:7')
+        assert a == b == '101'
+        assert c == d == e == 3
+
+    def test_multiplicative_factors_packing(self):
+        s = pack('3*bin', '1', '001', '101')
+        assert s == '0b1001101'
+        s = pack('hex, 2*se=-56, 3*uint:37', '34', 1, 2, 3)
+        a, b, c, d, e, f = s.unpack('hex:8, 2*se, 3*uint:37')
+        assert a == '34'
+        assert b == -56
+        assert c == -56
+        assert (d, e, f) == (1, 2, 3)
+
+    def test_multiplicative_factors_unpacking(self):
+        s = ConstBitStream('0b10111')
+        a, b, c, d = s.unpack('3*bool, bin')
+        assert (a, b, c) == (True, False, True)
+        assert d == '11'
+
+    def test_packing_default_int_with_keyword(self):
+        s = pack('uint:12', 100)
+        assert s.unpack('12')[0].uint == 100
+        s = pack('int:oh_no_not_the_eyes=33', oh_no_not_the_eyes=17)
+        assert s.int == 33
+        assert s.len == 17
+
+    def test_init_from_iterable(self):
+        assert isinstance(range(10), collections.abc.Iterable)
+        s = ConstBitStream(range(12))
+        assert s == '0x7ff'
+
+    def test_function_negative_indices(self):
+        # insert
+        s = BitStream('0b0111')
+        s.insert('0b0', -1)
+        assert s == '0b01101'
+        with pytest.raises(ValueError):
+            s.insert('0b0', -1000)
+
+        # reverse
+        s.reverse(-2)
+        assert s == '0b01110'
+        t = BitStream('0x778899abcdef')
+        t.reverse(-12, -4)
+        assert t == '0x778899abc7bf'
+
+        # reversebytes
+        t.byteswap(0, -40, -16)
+        assert t == '0x77ab9988c7bf'
+
+        # overwrite
+        t.overwrite('0x666', -20)
+        assert t == '0x77ab998666bf'
+
+        # find
+        found = t.find('0x998', bytealigned=True, start=-31)
+        assert not found
+        found = t.find('0x998', bytealigned=True, start=-32)
+        assert found
+        assert t.pos == 16
+        t.pos = 0
+        found = t.find('0x988', bytealigned=True, end=-21)
+        assert not found
+        found = t.find('0x998', bytealigned=True, end=-20)
+        assert found
+        assert t.pos == 16
+
+        # findall
+        s = BitStream('0x1234151f')
+        li = list(s.findall('0x1', bytealigned=True, start=-15))
+        assert li == [24]
+        li = list(s.findall('0x1', bytealigned=True, start=-16))
+        assert li == [16, 24]
+        li = list(s.findall('0x1', bytealigned=True, end=-5))
+        assert li == [0, 16]
+        li = list(s.findall('0x1', bytealigned=True, end=-4))
+        assert li == [0, 16, 24]
+
+        # rfind
+        found = s.rfind('0x1f', end=-1)
+        assert not found
+        found = s.rfind('0x12', start=-31)
+        assert not found
+
+        # cut
+        s = BitStream('0x12345')
+        li = list(s.cut(4, start=-12, end=-4))
+        assert li == ['0x3', '0x4']
+
+        # split
+        s = BitStream('0xfe0012fe1200fe')
+        li = list(s.split('0xfe', bytealigned=True, end=-1))
+        assert li == ['', '0xfe0012', '0xfe1200f, 0b111']
+        li = list(s.split('0xfe', bytealigned=True, start=-8))
+        assert li == ['', '0xfe']
+
+        # startswith
+        assert s.startswith('0x00f', start=-16)
+        assert s.startswith('0xfe00', end=-40)
+        assert not s.startswith('0xfe00', end=-41)
+
+        # endswith
+        assert s.endswith('0x00fe', start=-16)
+        assert not s.endswith('0x00fe', start=-15)
+        assert not s.endswith('0x00fe', end=-1)
+        assert s.endswith('0x00f', end=-4)
+
+        # replace
+        s.replace('0xfe', '', end=-1)
+        assert s == '0x00121200fe'
+        s.replace('0x00', '', start=-24)
+        assert s == '0x001212fe'
+
+    def test_rotate_start_and_end(self):
+        a = BitStream('0b110100001')
+        a.rol(1, 3, 6)
+        assert a == '0b110001001'
+        a.ror(1, start=-4)
+        assert a == '0b110001100'
+        a.rol(202, end=-5)
+        assert a == '0b001101100'
+        a.ror(3, end=4)
+        assert a == '0b011001100'
+        with pytest.raises(ValueError):
+            a.rol(5, start=-4, end=-6)
+
+    def test_byte_swap_int(self):
+        s = pack('5*uintle:16', *range(10, 15))
+        assert list(range(10, 15)) == s.unpack('5*uintle:16')
+        swaps = s.byteswap(2)
+        assert list(range(10, 15)) == s.unpack('5*uintbe:16')
+        assert swaps == 5
+        s = BitStream('0xf234567f')
+        swaps = s.byteswap(1, start=4)
+        assert swaps == 3
+        assert s == '0xf234567f'
+        s.byteswap(2, start=4)
+        assert s == '0xf452367f'
+        s.byteswap(2, start=4, end=-4)
+        assert s == '0xf234567f'
+        s.byteswap(3)
+        assert s == '0x5634f27f'
+        s.byteswap(2, repeat=False)
+        assert s == '0x3456f27f'
+        swaps = s.byteswap(5)
+        assert swaps == 0
+        swaps = s.byteswap(4, repeat=False)
+        assert swaps == 1
+        assert s == '0x7ff25634'
+
+    def test_byte_swap_pack_code(self):
+        s = BitStream('0x0011223344556677')
+        swaps = s.byteswap('b')
+        assert s == '0x0011223344556677'
+        assert swaps == 8
+        swaps = s.byteswap('>3h', repeat=False)
+        assert s == '0x1100332255446677'
+        assert swaps == 1
+
+    def test_byte_swap_iterable(self):
+        s = BitStream('0x0011223344556677')
+        swaps = s.byteswap(range(1, 4), repeat=False)
+        assert swaps == 1
+        assert s == '0x0022115544336677'
+        swaps = s.byteswap([2], start=8)
+        assert s == '0x0011224455663377'
+        assert 3 == swaps
+        swaps = s.byteswap([2, 3], start=4)
+        assert swaps == 1
+        assert s == '0x0120156452463377'
+
+    def test_byte_swap_errors(self):
+        s = BitStream('0x0011223344556677')
+        with pytest.raises(ValueError):
+            s.byteswap('z')
+        with pytest.raises(ValueError):
+            s.byteswap(-1)
+        with pytest.raises(ValueError):
+            s.byteswap([-1])
+        with pytest.raises(ValueError):
+            s.byteswap([1, 'e'])
+        with pytest.raises(ValueError):
+            s.byteswap('!h')
+        with pytest.raises(ValueError):
+            s.byteswap(2, start=-1000)
+        with pytest.raises(TypeError):
+            s.byteswap(5.4)
+
+    def test_byte_swap_from_file(self):
+        s = BitStream(filename=os.path.join(THIS_DIR, 'smalltestfile'))
+        swaps = s.byteswap('2bh')
+        assert s == '0x0123674589abefcd'
+        assert swaps == 2
+
+    def test_bracket_expander(self):
+        be = bitstring.utils.expand_brackets
+        assert be('hello') == 'hello'
+        assert be('(hello)') == 'hello'
+        assert be('1*(hello)') == 'hello'
+        assert be('2*(hello)') == 'hello,hello'
+        assert be('1*(a,b)') == 'a,b'
+        assert be('2*(a,b)') == 'a,b,a,b'
+        assert be('2*(a),3*(b)') == 'a,a,b,b,b'
+        assert be('2*(a,b,3*(c,d),e)') == 'a,b,c,d,c,d,c,d,e,a,b,c,d,c,d,c,d,e'
+        with pytest.raises(ValueError):
+            _ = be('2*(x,y()')
+
+    def test_bracket_tokens(self):
+        s = BitStream('3*(0x0, 0b1)')
+        assert s == '0x0, 0b1, 0x0, 0b1, 0x0, 0b1'
+        s = pack('2*(uint:12, 3*(uint:7, uint:6))', *range(3, 17))
+        a = s.unpack('12, 7, 6, 7, 6, 7, 6, 12, 7, 6, 7, 6, 7, 6')
+        assert [x.uint for x in a] == list(range(3, 17))
+        b = s.unpack('2*(12,3*(7,6))')
+        assert a == b
+
+    def test_pack_code_dicts(self):
+        assert sorted(bitstring.utils.REPLACEMENTS_BE.keys()) == \
+                         sorted(bitstring.utils.REPLACEMENTS_LE.keys())
+        assert sorted(bitstring.utils.REPLACEMENTS_BE.keys()) == \
+                         sorted(bitstring.utils.PACK_CODE_SIZE.keys())
+        for key in bitstring.utils.PACK_CODE_SIZE:
+            be = pack(bitstring.utils.REPLACEMENTS_BE[key], 0)
+            le = pack(bitstring.utils.REPLACEMENTS_LE[key], 0)
+            assert be.len == bitstring.utils.PACK_CODE_SIZE[key] * 8
+            assert le.len == be.len
+
+    def test_unicode(self):
+        a = ConstBitStream(u'uint:12=34')
+        assert a.uint == 34
+        a += u'0xfe'
+        assert a[12:] == '0xfe'
+        a = BitStream('0x1122')
+        c = a.byteswap(u'h')
+        assert c == 1
+        assert a == u'0x2211'
+
+
+class TestUnpackWithDict:
+    def test_length_keywords(self):
+        a = ConstBitStream('2*int:13=100, 0b111')
+        x, y, z = a.unpack('13, int:m, bin:q', m=13, q=3)
+        assert x == 'uint:13=100'
+        assert y == 100
+        assert z == '111'
+
+    def test_length_keywords_with_stretch(self):
+        a = ConstBitStream('0xff, 0b000, 0xf')
+        x, y, z = a.unpack('hex:a, bin, hex:b', a=8, b=4)
+        assert y == '000'
+
+    def test_unused_keyword(self):
+        a = ConstBitStream('0b110')
+        x, = a.unpack('bin:3', notused=33)
+        assert x == '110'
+
+    def test_length_keyword_errors(self):
+        a = pack('uint:p=33', p=12)
+        with pytest.raises(ValueError):
+            a.unpack('uint:p')
+        with pytest.raises(ValueError):
+            a.unpack('uint:p', p='a_string')
+
+
+class TestReadWithDict:
+    def test_length_keywords(self):
+        s = BitStream('0x0102')
+        x, y = s.readlist('bits8, hex:b', b=4)
+        assert (x, y) == ('0x01', '0')
+        assert s.pos == 12
+
+    def test_bytes_keyword_problem(self):
+        s = BitStream('0x01')
+        x, = s.unpack('bytes:a', a=1)
+        assert x == b'\x01'
+
+        s = BitStream('0x000ff00a')
+        x, y, z = s.unpack('12, bytes:x, bits', x=2)
+        assert (x.int, y, z) == (0, b'\xff\x00', '0xa')
+
+
+class TestPeekWithDict:
+    def test_length_keywords(self):
+        s = BitStream('0x0102')
+        x, y = s.peeklist('8, hex:b', b=4)
+        assert (x, y) == ('0x01', '0')
+        assert s.pos == 0
+
+
+class TestBoolToken:
+    def test_interpretation(self):
+        a = ConstBitStream('0b1')
+        assert a.bool == True
+        assert a.read('bool') == True
+        assert a.unpack('bool')[0] == True
+        b = ConstBitStream('0b0')
+        assert b.bool == False
+        assert b.peek('bool') == False
+        assert b.unpack('bool')[0] == False
+
+    def test_pack(self):
+        a = pack('bool=True')
+        b = pack('bool=False')
+        assert a.bool == True
+        assert b.bool == False
+        c = pack('4*bool', False, True, 'False', 'True')
+        assert c == '0b0101'
+
+    def test_assignment(self):
+        a = BitStream()
+        a.bool = True
+        assert a.bool == True
+        a.hex = 'ee'
+        a.bool = False
+        assert a.bool == False
+        a.bool = 'False'
+        assert a.bool == False
+        a.bool = 'True'
+        assert a.bool == True
+        a.bool = 0
+        assert a.bool == False
+        a.bool = 1
+        assert a.bool == True
+
+    def test_errors(self):
+        with pytest.raises(bitstring.CreationError):
+            pack('bool', 'hello')
+        with pytest.raises(bitstring.CreationError):
+            pack('bool=true')
+        with pytest.raises(bitstring.CreationError):
+            pack('True')
+        with pytest.raises(bitstring.CreationError):
+            pack('bool', 2)
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bool', 'hello')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bool=true')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('True')
+        with pytest.raises(bitstring.CreationError):
+            _ = pack('bool', 2)
+        a = BitStream('0b11')
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.bool
+        b = BitStream()
+        with pytest.raises(bitstring.InterpretError):
+            _ = b.bool
+        with pytest.raises(bitstring.CreationError):
+            b.bool = 'false'
+
+    def test_length_with_bool_read(self):
+        a = ConstBitStream('0xf')
+        with pytest.raises(ValueError):
+            _ = a.read('bool:0')
+        with pytest.raises(ValueError):
+            _ = a.read('bool:2')
+
+
+class TestReadWithIntegers:
+    def test_read_int(self):
+        a = ConstBitStream('0xffeedd')
+        b = a.read(8)
+        assert b.hex == 'ff'
+        assert a.pos == 8
+        b = a.peek(8)
+        assert b.hex == 'ee'
+        assert a.pos == 8
+        b = a.peek(1)
+        assert b == '0b1'
+        b = a.read(1)
+        assert b == '0b1'
+
+    def test_read_int_list(self):
+        a = ConstBitStream('0xab, 0b110')
+        b, c = a.readlist([8, 3])
+        assert b.hex == 'ab'
+        assert c.bin == '110'
+
+
+# class FileReadingStrategy(unittest.TestCase):
+#
+#
+#     def testBitStreamIsAlwaysRead(self):
+#         filename = os.path.join(THIS_DIR, 'smalltestfile')
+#         a = BitStream(filename=filename)
+#         self.assertTrue(isinstance(a._datastore, bitstring.ByteStore))
+#         with open(filename, 'rb') as f:
+#             b = BitStream(f)
+#             self.assertTrue(isinstance(b._datastore, bitstring.ByteStore))
+#
+#
+#     def testBitsIsNeverRead(self):
+#         filename = os.path.join(THIS_DIR, 'smalltestfile')
+#         a = ConstBitStream(filename=filename)
+#         self.assertTrue(isinstance(a._datastore.rawarray, bitstring.MmapByteArray))
+#         with open(filename, 'rb') as f:
+#             b = ConstBitStream(f)
+#             self.assertTrue(isinstance(b._datastore.rawarray, bitstring.MmapByteArray))
+
+
+class TestCount:
+    def test_count(self):
+        a = ConstBitStream('0xf0f')
+        assert a.count(True) == 8
+        assert a.count(False) == 4
+
+        b = BitStream()
+        assert b.count(True) == 0
+        assert b.count(False) == 0
+
+    def test_count_with_offset_data(self):
+        a = ConstBitStream('0xff0120ff')
+        b = a[1:-1]
+        assert b.count(1) == 16
+        assert b.count(0) == 14
+
+
+class TestZeroBitReads:
+    def test_integer(self):
+        a = ConstBitStream('0x123456')
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.read('uint:0')
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.read('float:0')
+
+
+class TestInitialiseFromBytes:
+    def test_bytes_behaviour(self):
+        a = ConstBitStream(b'uint:5=2')
+        b = ConstBitStream(b'')
+        c = ConstBitStream(bytes=b'uint:5=2')
+        assert a.bytes == b'uint:5=2'
+        assert not b
+        assert c == b'uint:5=2'
+
+    def test_bytearray_behaviour(self):
+        a = ConstBitStream(bytearray(b'uint:5=2'))
+        b = ConstBitStream(bytearray(4))
+        c = ConstBitStream(bytes=bytearray(b'uint:5=2'))
+        assert a.bytes == b'uint:5=2'
+        assert b == '0x00000000'
+        assert c.bytes == b'uint:5=2'
+
+
+class TestCoverageCompletion:
+    def test_ue_read_error(self):
+        s = ConstBitStream('0b000000001')
+        with pytest.raises(bitstring.ReadError):
+            _ = s.read('ue')
+
+    def test_overwrite_with_self(self):
+        s = BitStream('0b1101')
+        s.overwrite(s)
+        assert s == '0b1101'
+
+
+class TestSubclassing:
+
+    def test_is_instance(self):
+        b = BitStream()
+        assert isinstance(b, BitStream)
+        class SubBits(BitStream):
+            pass
+        a = SubBits()
+        assert isinstance(a, SubBits)
+
+    def test_class_type(self):
+        class SubBits(BitStream):
+            pass
+        assert SubBits().__class__ == SubBits
+
+
+class TestBytesProblems:
+
+    def test_offset_but_no_length(self):
+        b = BitStream(bytes=b'\x00\xaa', offset=8)
+        assert b.hex == 'aa'
+        b = BitStream(bytes=b'\x00\xaa', offset=4)
+        assert b.hex == '0aa'
+
+    def test_invert(self):
+        b = BitStream(bytes=b'\x00\xaa', offset=8, length=8)
+        assert b.hex == 'aa'
+        b.invert()
+        assert b.hex == '55'
+
+    def test_prepend(self):
+        b = BitStream(bytes=b'\xaa\xbb', offset=8, length=4)
+        assert b.hex == 'b'
+        b.prepend('0xe')
+        assert b.hex == 'eb'
+        b = BitStream(bytes=b'\x00\xaa', offset=8, length=8)
+        b.prepend('0xee')
+        assert b.hex == 'eeaa'
+
+    def test_byte_swap(self):
+        b = BitStream(bytes=b'\x01\x02\x03\x04', offset=8)
+        b.byteswap()
+        assert b == '0x040302'
+
+    def test_bin_property(self):
+        b = BitStream(bytes=b'\x00\xaa', offset=8, length=4)
+        assert b.bin == '1010'
+
+
+class TestLsb0Streaming:
+
+    @classmethod
+    def setup_class(cls):
+        bitstring.lsb0 = True
+
+    @classmethod
+    def teardown_class(cls):
+        bitstring.lsb0 = False
+
+    def test_simple_bit_positions(self):
+        s = BitStream('0x00000f')
+        assert s.pos == 0
+        v = s.read('uint:8')
+        assert v == 15
+        assert s.pos == 8
+        v = s.read(10)
+        assert v == Bits(10)
+        assert s.pos == 18
+
+    def test_bit_pos_after_find(self):
+        s = BitStream('0b01100001000011 0000')
+        s.find('0b11', start=1)
+        assert s.pos == 4
+
+    def test_iter(self):
+        s = BitStream('0b11000')
+        assert list(s) == [False, False, False, True, True]
+
+    def test_bit_pos_after_rfind(self):
+        s = BitStream('0b011 000010000110000')
+        s.rfind('0b11')
+        assert s.pos == 15
+
+    def test_bit_pos_after_findall(self):
+        pass
+
+    def test_bit_pos_after_insert(self):
+        pass
+
+    def test_bit_pos_after_overwrite(self):
+        pass
+
+    def test_bit_pos_after_replace(self):
+        pass
+
+    def test_read_list(self):
+        a = BitStream('0x0123456789abcdef')
+        
+        vals = a.readlist('uint:4, uint:4, uint:24, uint:12, uint:12, uint:8')
+        assert vals == [15, 14, 0x89abcd, 0x567, 0x234, 1]
+
+
+class TestLsb0PackingUnpacking:
+
+    @classmethod
+    def setup_class(cls):
+        bitstring.lsb0 = True
+
+    @classmethod
+    def teardown_class(cls):
+        bitstring.lsb0 = False
+
+    def test_bin(self):
+        lsb0 = bitstring.pack('2*b4', '0b0000', '1111')
+        assert lsb0 == '0b11110000'
+        a, b = lsb0.unpack('2*h4')
+        assert [a, b] == ['0', 'f']
+        a, b = lsb0.unpack('2*bits4')
+        assert [a, b] == ['0x0', '0xf']
+        a, b = lsb0.unpack('2*bin4')
+        assert [a, b] == ['0000', '1111']
+
+    def test_float(self):
+        lsb0 = bitstring.pack('2*bfloat', 0.5, 15)
+        assert lsb0 == '0x4170 3f00'
+        a, b = lsb0.unpack('2*bfloat')
+        assert [a, b] == [0.5, 15]
+
+    def test_simplest(self):
+        lsb0 = bitstring.pack('uint:2', 1)
+        assert lsb0.unpack('uint:2') == [1]
+        lsb0 = bitstring.pack('0xab, 0xc')
+        assert lsb0.unpack('hex8, hex4') == ['ab', 'c']
+
+    def test_slightly_harder(self):
+        lsb0 = bitstring.pack('float:32, hex', 0.25, 'ac')
+        x = lsb0.unpack('float:32, hex')
+        assert x == [0.25, 'ac']
+
+    def test_more_complex(self):
+        lsb0 = bitstring.pack('uint:10, hex, int:13, 0b11', 130, '3d', -23)
+        x = lsb0.unpack('uint:10, hex, int:13, bin:2')
+        assert x == [130, '3d', -23, '11']
+
+    def test_golomb_codes(self):
+        v = [10, 8, 6, 4, 100, -9]
+        # Exp-Golomb codes can only be read in msb0 mode. So also doesn't
+        # make sense for creation with pack
+        with pytest.raises(bitstring.CreationError):
+            _ = bitstring.pack('5*ue, sie', *v)
+        # with self.assertRaises(bitstring.CreationError):
+        #     _ = BitStream('ue=34')
+        lsb0 = BitStream('0b0010010')
+        with pytest.raises(bitstring.ReadError):
+            _ = lsb0.unpack('5*ue, sie')
+        with pytest.raises(bitstring.ReadError):
+            _ = lsb0.read('ue')
+        with pytest.raises(bitstring.ReadError):
+            _ = lsb0.read('uie')
+        with pytest.raises(bitstring.ReadError):
+            _ = lsb0.read('se')
+        with pytest.raises(bitstring.ReadError):
+            _ = lsb0.read('sie')
+
+
+class TestRepr:
+
+    def test_without_pos(self):
+        a = BitStream('0x12345', pos=0)
+        assert repr(a) == "BitStream('0x12345')"
+
+    def test_with_pos(self):
+        a = BitStream('0b00111', pos=-1)
+        assert a.pos == 4
+        assert repr(a) == "BitStream('0b00111', pos=4)"
+
+
+class TestFormat:
+
+    def test_simple_format_strings(self):
+        a = Bits('0xabc')
+        s = f'{a}'
+        assert s == '0xabc'
+        a += '0b0'
+        assert f'{a}' == '0b1010101111000'
+        b = BitStream(10, pos=4)
+        assert f'{b}' == '0b0000000000'
+        c = BitStream(filename=os.path.join(THIS_DIR, 'test.m1v'))
+        assert f'{c}'[0:10] == '0x000001b3'
+
+    def test_format_strings_with_interpretation(self):
+        a = Bits('0xf')
+        assert f'{a.bin}' == '1111'
+
+
+class TestCacheingIssues:
+
+    def test_cache_with_offset(self):
+        y = BitStream('0xdeadbeef1000')
+        with pytest.raises(bitstring.CreationError):
+            x = BitStream('0xdeadbeef1000', offset=8)
+
+    def test_cache_with_pos(self):
+        y = BitStream('0xdeadbeef1001', pos=3)
+        assert y.pos == 3
+        x = BitStream('0xdeadbeef1001', pos=5)
+        assert x.pos == 5
+
+    def test_cache_with_length(self):
+        y = BitStream('0xdeadbeef002')
+        with pytest.raises(bitstring.CreationError):
+            x = BitStream('0xdeadbeef002', length=16)
+
+
+def test_unpack_error():
+    format_with_commas = ',bytes:2,,bytes:1,'
+    dp = BitStream(hex='010203').unpack(fmt=format_with_commas)
+    assert dp == [b'\x01\x02', b'\x03']
+
+
+def test_add_pos_issue():
+    x = BitStream()
+    y = x + Bits('0xff')
+    assert x.pos == 0
+    assert y == '0xff'
+    z = x + bitstring.BitArray('0xff')
+    assert z == '0xff'
+    q = x + ConstBitStream('0xff')
+    assert q == '0xff'
+
+    xx = ConstBitStream()
+    yy = xx + Bits('0xff')
+    zz = xx + bitstring.BitArray('0xff')
+    qq = xx + BitStream('0xff')
+    assert yy == zz == qq == '0xff'
+
```

### Comparing `bitstring-4.2.1/tests/test_bitstring.py` & `bitstring-4.2.2/tests/test_bitstring.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,200 +1,200 @@
-#!/usr/bin/env python
-"""
-Module-level unit tests.
-"""
-import io
-from unittest import mock
-from contextlib import redirect_stdout
-import bitstring
-import copy
-from collections import abc
-import sys
-import os
-from bitstring import __main__
-
-
-sys.path.insert(0, '..')
-THIS_DIR = os.path.dirname(os.path.abspath(__file__))
-
-
-class TestModuleData:
-
-    def test_all(self):
-        exported = ['ConstBitStream', 'BitStream', 'BitArray',
-                    'Bits', 'pack', 'Error', 'ReadError', 'Array',
-                    'InterpretError', 'ByteAlignError', 'CreationError', 'bytealigned', 'lsb0', 'Dtype', 'options']
-        assert set(bitstring.__all__) == set(exported)
-
-    def test_pyproject_version(self):
-        filename = os.path.join(THIS_DIR, '../pyproject.toml')
-        try:
-            with open(filename, 'r') as pyprojectfile:
-                found = False
-                for line in pyprojectfile.readlines():
-                    if line.startswith("version"):
-                        assert not found
-                        assert bitstring.__version__ in line
-                        found = True
-            assert found
-        except FileNotFoundError:
-            pass  # Doesn't run on CI.
-
-
-class TestCopy:
-    def test_const_bit_array_copy(self):
-        cba = bitstring.Bits(100)
-        cba_copy = copy.copy(cba)
-        assert cba is cba_copy
-
-    def test_bit_array_copy(self):
-        ba = bitstring.BitArray(100)
-        ba_copy = copy.copy(ba)
-        assert not ba is ba_copy
-        assert not ba._bitstore is ba_copy._bitstore
-        assert ba == ba_copy
-
-    def test_const_bit_stream_copy(self):
-        cbs = bitstring.ConstBitStream(100)
-        cbs.pos = 50
-        cbs_copy = copy.copy(cbs)
-        assert cbs_copy.pos == 0
-        assert cbs._bitstore is cbs_copy._bitstore
-        assert cbs == cbs_copy
-
-    def test_bit_stream_copy(self):
-        bs = bitstring.BitStream(100)
-        bs.pos = 50
-        bs_copy = copy.copy(bs)
-        assert bs_copy.pos == 0
-        assert not bs._bitstore is bs_copy._bitstore
-        assert bs == bs_copy
-
-
-class TestInterning:
-    def test_bits(self):
-        a = bitstring.Bits('0xf')
-        b = bitstring.Bits('0xf')
-        assert a._bitstore is b._bitstore
-        c = bitstring.Bits('0b1111')
-        assert not a is c
-
-    def test_cbs(self):
-        a = bitstring.ConstBitStream('0b11000')
-        b = bitstring.ConstBitStream('0b11000')
-        assert a._bitstore is b._bitstore
-        assert not a is b
-
-
-class TestLSB0:
-    def test_getting_and_setting(self):
-        assert bitstring.lsb0 == False
-        bitstring.lsb0 = True
-        assert bitstring.lsb0 == True
-        bitstring.lsb0 = False
-        assert bitstring.lsb0 == False
-
-
-class TestMain:
-    def test_running_module_directly_help(self):
-        with redirect_stdout(io.StringIO()) as f:
-            with mock.patch('sys.argv', ['bitstring.py', '-h']):
-                bitstring.__main__.main()
-        s = f.getvalue()
-        assert s.find("command-line parameters") >= 0
-
-        with redirect_stdout(io.StringIO()) as f:
-            with mock.patch('sys.argv', ['renamed.py']):
-                bitstring.__main__.main()
-        s = f.getvalue()
-        assert s.find("command-line parameters") >= 0
-
-    def test_running_module_with_single_parameter(self):
-        with redirect_stdout(io.StringIO()) as f:
-            with mock.patch('sys.argv', ['', 'uint:12=352']):
-                bitstring.__main__.main()
-        s = f.getvalue()
-        assert s == '0x160\n'
-
-    def test_running_module_with_single_parameter_and_interpretation(self):
-        with redirect_stdout(io.StringIO()) as f:
-            with mock.patch('sys.argv', ['ignored', 'u12=352', 'i']):
-                bitstring.__main__.main()
-        s = f.getvalue()
-        assert s == '352\n'
-
-    def test_running_module_with_multiple_parameters(self):
-        with redirect_stdout(io.StringIO()) as f:
-            with mock.patch('sys.argv', ['b.py', 'uint12=352', '0b101', '0o321', 'f32=51', 'bool=1']):
-                bitstring.__main__.main()
-        s = f.getvalue()
-        assert s == '0x160ad1424c0000, 0b1\n'
-
-    def test_running_module_with_multiple_parameters_and_interpretation(self):
-        with redirect_stdout(io.StringIO()) as f:
-            with mock.patch('sys.argv', ['b.py', 'ue=1000', '0xff.bin']):
-                bitstring.__main__.main()
-        s = f.getvalue()
-        assert s == '000000000111110100111111111\n'
-
-    def test_short_interpretations(self):
-        with redirect_stdout(io.StringIO()) as f:
-            with mock.patch('sys.argv', ['b.py', 'bin=001.b']):
-                bitstring.__main__.main()
-        s = f.getvalue()
-        assert s == '001\n'
-
-
-class TestABCs:
-    def test_base_classes(self):
-        # The classes deliberately do not conform to the sequence ABCs.
-        # see https://github.com/scott-griffiths/bitstring/issues/261
-        bits = bitstring.Bits()
-        assert not isinstance(bits, abc.Sequence)
-        assert not isinstance(bits, abc.MutableSequence)
-
-        bitarray = bitstring.BitArray()
-        assert not isinstance(bitarray, abc.MutableSequence)
-        assert not isinstance(bitarray, abc.Sequence)
-
-        constbitstream = bitstring.ConstBitStream()
-        assert not isinstance(constbitstream, abc.Sequence)
-        assert not isinstance(constbitstream, abc.MutableSequence)
-
-        bitstream = bitstring.BitArray()
-        assert not isinstance(bitstream, abc.MutableSequence)
-        assert not isinstance(bitstream, abc.Sequence)
-
-
-class TestNoFixedLengthPackingBug:
-
-    def test_packing_bytes_with_no_length(self):
-        a = bitstring.pack('bytes', b'abcd')
-        assert a.bytes == b'abcd'
-
-    def test_packing_bin_with_no_length(self):
-        a = bitstring.pack('bin', '0001')
-        assert a.bin == '0001'
-
-    def test_packing_hex_with_no_length(self):
-        a = bitstring.pack('hex', 'abcd')
-        assert a.hex == 'abcd'
-
-    def test_reading_bytes_with_no_length(self):
-        a = bitstring.BitStream(b'hello')
-        b = a.read('bytes')
-        assert b == b'hello'
-
-    def test_reading_bin_with_no_length(self):
-        a = bitstring.BitStream('0b1101')
-        b = a.read('bin')
-        assert b == '1101'
-
-    def test_reading_uint_with_no_length(self):
-        a = bitstring.BitStream('0b1101')
-        b = a.read('uint')
-        assert b == 13
-
-    def test_reading_float_with_no_length(self):
-        a = bitstring.BitStream(float=14, length=16)
-        b = a.read('float')
-        assert b == 14.0
+#!/usr/bin/env python
+"""
+Module-level unit tests.
+"""
+import io
+from unittest import mock
+from contextlib import redirect_stdout
+import bitstring
+import copy
+from collections import abc
+import sys
+import os
+from bitstring import __main__
+
+
+sys.path.insert(0, '..')
+THIS_DIR = os.path.dirname(os.path.abspath(__file__))
+
+
+class TestModuleData:
+
+    def test_all(self):
+        exported = ['ConstBitStream', 'BitStream', 'BitArray',
+                    'Bits', 'pack', 'Error', 'ReadError', 'Array',
+                    'InterpretError', 'ByteAlignError', 'CreationError', 'bytealigned', 'lsb0', 'Dtype', 'options']
+        assert set(bitstring.__all__) == set(exported)
+
+    def test_pyproject_version(self):
+        filename = os.path.join(THIS_DIR, '../pyproject.toml')
+        try:
+            with open(filename, 'r') as pyprojectfile:
+                found = False
+                for line in pyprojectfile.readlines():
+                    if line.startswith("version"):
+                        assert not found
+                        assert bitstring.__version__ in line
+                        found = True
+            assert found
+        except FileNotFoundError:
+            pass  # Doesn't run on CI.
+
+
+class TestCopy:
+    def test_const_bit_array_copy(self):
+        cba = bitstring.Bits(100)
+        cba_copy = copy.copy(cba)
+        assert cba is cba_copy
+
+    def test_bit_array_copy(self):
+        ba = bitstring.BitArray(100)
+        ba_copy = copy.copy(ba)
+        assert not ba is ba_copy
+        assert not ba._bitstore is ba_copy._bitstore
+        assert ba == ba_copy
+
+    def test_const_bit_stream_copy(self):
+        cbs = bitstring.ConstBitStream(100)
+        cbs.pos = 50
+        cbs_copy = copy.copy(cbs)
+        assert cbs_copy.pos == 0
+        assert cbs._bitstore is cbs_copy._bitstore
+        assert cbs == cbs_copy
+
+    def test_bit_stream_copy(self):
+        bs = bitstring.BitStream(100)
+        bs.pos = 50
+        bs_copy = copy.copy(bs)
+        assert bs_copy.pos == 0
+        assert not bs._bitstore is bs_copy._bitstore
+        assert bs == bs_copy
+
+
+class TestInterning:
+    def test_bits(self):
+        a = bitstring.Bits('0xf')
+        b = bitstring.Bits('0xf')
+        assert a._bitstore is b._bitstore
+        c = bitstring.Bits('0b1111')
+        assert not a is c
+
+    def test_cbs(self):
+        a = bitstring.ConstBitStream('0b11000')
+        b = bitstring.ConstBitStream('0b11000')
+        assert a._bitstore is b._bitstore
+        assert not a is b
+
+
+class TestLSB0:
+    def test_getting_and_setting(self):
+        assert bitstring.lsb0 == False
+        bitstring.lsb0 = True
+        assert bitstring.lsb0 == True
+        bitstring.lsb0 = False
+        assert bitstring.lsb0 == False
+
+
+class TestMain:
+    def test_running_module_directly_help(self):
+        with redirect_stdout(io.StringIO()) as f:
+            with mock.patch('sys.argv', ['bitstring.py', '-h']):
+                bitstring.__main__.main()
+        s = f.getvalue()
+        assert s.find("command-line parameters") >= 0
+
+        with redirect_stdout(io.StringIO()) as f:
+            with mock.patch('sys.argv', ['renamed.py']):
+                bitstring.__main__.main()
+        s = f.getvalue()
+        assert s.find("command-line parameters") >= 0
+
+    def test_running_module_with_single_parameter(self):
+        with redirect_stdout(io.StringIO()) as f:
+            with mock.patch('sys.argv', ['', 'uint:12=352']):
+                bitstring.__main__.main()
+        s = f.getvalue()
+        assert s == '0x160\n'
+
+    def test_running_module_with_single_parameter_and_interpretation(self):
+        with redirect_stdout(io.StringIO()) as f:
+            with mock.patch('sys.argv', ['ignored', 'u12=352', 'i']):
+                bitstring.__main__.main()
+        s = f.getvalue()
+        assert s == '352\n'
+
+    def test_running_module_with_multiple_parameters(self):
+        with redirect_stdout(io.StringIO()) as f:
+            with mock.patch('sys.argv', ['b.py', 'uint12=352', '0b101', '0o321', 'f32=51', 'bool=1']):
+                bitstring.__main__.main()
+        s = f.getvalue()
+        assert s == '0x160ad1424c0000, 0b1\n'
+
+    def test_running_module_with_multiple_parameters_and_interpretation(self):
+        with redirect_stdout(io.StringIO()) as f:
+            with mock.patch('sys.argv', ['b.py', 'ue=1000', '0xff.bin']):
+                bitstring.__main__.main()
+        s = f.getvalue()
+        assert s == '000000000111110100111111111\n'
+
+    def test_short_interpretations(self):
+        with redirect_stdout(io.StringIO()) as f:
+            with mock.patch('sys.argv', ['b.py', 'bin=001.b']):
+                bitstring.__main__.main()
+        s = f.getvalue()
+        assert s == '001\n'
+
+
+class TestABCs:
+    def test_base_classes(self):
+        # The classes deliberately do not conform to the sequence ABCs.
+        # see https://github.com/scott-griffiths/bitstring/issues/261
+        bits = bitstring.Bits()
+        assert not isinstance(bits, abc.Sequence)
+        assert not isinstance(bits, abc.MutableSequence)
+
+        bitarray = bitstring.BitArray()
+        assert not isinstance(bitarray, abc.MutableSequence)
+        assert not isinstance(bitarray, abc.Sequence)
+
+        constbitstream = bitstring.ConstBitStream()
+        assert not isinstance(constbitstream, abc.Sequence)
+        assert not isinstance(constbitstream, abc.MutableSequence)
+
+        bitstream = bitstring.BitArray()
+        assert not isinstance(bitstream, abc.MutableSequence)
+        assert not isinstance(bitstream, abc.Sequence)
+
+
+class TestNoFixedLengthPackingBug:
+
+    def test_packing_bytes_with_no_length(self):
+        a = bitstring.pack('bytes', b'abcd')
+        assert a.bytes == b'abcd'
+
+    def test_packing_bin_with_no_length(self):
+        a = bitstring.pack('bin', '0001')
+        assert a.bin == '0001'
+
+    def test_packing_hex_with_no_length(self):
+        a = bitstring.pack('hex', 'abcd')
+        assert a.hex == 'abcd'
+
+    def test_reading_bytes_with_no_length(self):
+        a = bitstring.BitStream(b'hello')
+        b = a.read('bytes')
+        assert b == b'hello'
+
+    def test_reading_bin_with_no_length(self):
+        a = bitstring.BitStream('0b1101')
+        b = a.read('bin')
+        assert b == '1101'
+
+    def test_reading_uint_with_no_length(self):
+        a = bitstring.BitStream('0b1101')
+        b = a.read('uint')
+        assert b == 13
+
+    def test_reading_float_with_no_length(self):
+        a = bitstring.BitStream(float=14, length=16)
+        b = a.read('float')
+        assert b == 14.0
```

### Comparing `bitstring-4.2.1/tests/test_constbitstream.py` & `bitstring-4.2.2/tests/test_constbitstream.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,265 +1,274 @@
-#!/usr/bin/env python
-
-import pytest
-import sys
-import bitstring
-import io
-import os
-from bitstring import ConstBitStream as CBS
-import platform
-
-sys.path.insert(0, '..')
-
-
-THIS_DIR = os.path.dirname(os.path.abspath(__file__))
-
-class TestAll:
-    def test_from_file(self):
-        s = CBS(filename=os.path.join(THIS_DIR, 'test.m1v'))
-        assert s[0:32].hex == '000001b3'
-        assert s.read(8 * 4).hex == '000001b3'
-        width = s.read(12).uint
-        height = s.read(12).uint
-        assert (width, height) == (352, 288)
-
-    def test_from_file_with_offset_and_length(self):
-        s = CBS(filename=os.path.join(THIS_DIR, 'test.m1v'), offset=24, length=8)
-        assert s.h == 'b3'
-        reconstructed = ''
-        for bit in s:
-            reconstructed += '1' if bit is True else '0'
-        assert reconstructed == s.bin
-
-
-class TestInterleavedExpGolomb:
-    def test_reading(self):
-        s = CBS(uie=333)
-        a = s.read('uie')
-        assert a == 333
-        s = CBS('uie=12, sie=-9, sie=9, uie=1000000')
-        u = s.unpack('uie, 2*sie, uie')
-        assert u == [12, -9, 9, 1000000]
-
-    def test_reading_errors(self):
-        s = CBS(10)
-        with pytest.raises(bitstring.ReadError):
-            s.read('uie')
-        assert s.pos == 0
-        with pytest.raises(bitstring.ReadError):
-            s.read('sie')
-        assert s.pos == 0
-
-
-class TestReadTo:
-    def test_byte_aligned(self):
-        a = CBS('0xaabb00aa00bb')
-        b = a.readto('0x00', bytealigned=True)
-        assert b == '0xaabb00'
-        assert a.bytepos == 3
-        b = a.readto('0xaa', bytealigned=True)
-        assert b == '0xaa'
-        with pytest.raises(bitstring.ReadError):
-            b.readto('0xcc', bytealigned=True)
-
-    def test_not_aligned(self):
-        a = CBS('0b00111001001010011011')
-        a.pos = 1
-        assert a.readto('0b00') == '0b011100'
-        assert a.readto('0b110') == '0b10010100110'
-        with pytest.raises(ValueError):
-            a.readto('')
-
-    def test_disallow_integers(self):
-        a = CBS('0x0f')
-        with pytest.raises(ValueError):
-            a.readto(4)
-
-    def test_reading_lines(self):
-        s = b"This is a test\nof reading lines\nof text\n"
-        b = CBS(bytes=s)
-        n = bitstring.Bits(bytes=b'\n')
-        assert b.readto(n).bytes == b'This is a test\n'
-        assert b.readto(n).bytes == b'of reading lines\n'
-        assert b.readto(n).bytes == b'of text\n'
-
-
-class TestSubclassing:
-
-    def test_is_instance(self):
-        class SubBits(CBS):
-            pass
-        a = SubBits()
-        assert isinstance(a, SubBits)
-
-    def test_class_type(self):
-        class SubBits(CBS):
-            pass
-        assert SubBits().__class__ == SubBits
-
-
-class TestPadToken:
-
-    def test_read(self):
-        s = CBS('0b100011110001')
-        a = s.read('pad:1')
-        assert a == None
-        assert s.pos == 1
-        a = s.read(3)
-        assert a == CBS('0b000')
-        a = s.read('pad:1')
-        assert a == None
-        assert s.pos == 5
-
-    def test_read_list(self):
-        s = CBS.fromstring('0b10001111001')
-        t = s.readlist('pad:1, uint:3, pad:4, uint:3')
-        assert t == [0, 1]
-        s.pos = 0
-        t = s.readlist('pad:1, pad:5')
-        assert t == []
-        assert s.pos == 6
-        s.pos = 0
-        t = s.readlist('pad:1, bin, pad:4, uint:3')
-        assert t == ['000', 1]
-        s.pos = 0
-        t = s.readlist('pad, bin:3, pad:4, uint:3')
-        assert t == ['000', 1]
-
-
-class TestReadingBytes:
-
-    def test_unpacking_bytes(self):
-        s = CBS(80)
-        t = s.unpack('bytes:1')
-        assert t[0] == b'\x00'
-        a, b, c = s.unpack('bytes:1, bytes, bytes2')
-        assert a == b'\x00'
-        assert b == b'\x00'*7
-        assert c == b'\x00'*2
-
-    def test_unpacking_bytes_with_keywords(self):
-        s = CBS('0x55'*10)
-        t = s.unpack('pad:a, bytes:b, bytes, pad:a', a=4, b=6)
-        assert t == [b'\x55'*6, b'\x55'*3]
-
-
-class TestReadingBitsAsDefault:
-
-    def test_read_bits(self):
-        s = CBS('uint:31=14')
-        v = s.read(31)
-        assert v.uint == 14
-        s.pos = 0
-
-    def test_read_list_bits(self):
-        s = CBS('uint:5=3, uint:3=0, uint:11=999')
-        v = s.readlist([5, 3, 11])
-        assert [x.uint for x in v] == [3, 0, 999]
-        s.pos = 0
-        v = s.readlist(['5', '3', 11])
-        assert [x.uint for x in v] == [3, 0, 999]
-
-
-class TestLsb0Reading:
-
-    @classmethod
-    def setup_class(cls):
-        bitstring.lsb0 = True
-
-    @classmethod
-    def teardown_class(cls):
-        bitstring.lsb0 = False
-
-    def test_reading_hex(self):
-        s = CBS('0xabcdef')
-        assert s.read('hex:4') == 'f'
-        assert s.read(4) == '0xe'
-        assert s.pos == 8
-
-    def test_reading_oct(self):
-        s = CBS('0o123456')
-        assert s.read('o6') == '56'
-        assert s.pos == 6
-
-    def test_reading_bin(self):
-        s = CBS('0b00011')
-        assert s.read('bin:3') == '011'
-        assert s.pos == 3
-
-    def test_reading_bytes(self):
-        s = CBS(bytes=b'54321')
-        assert s.pos == 0
-        s.pos = 8
-        assert s.read('bytes:2') == b'32'
-
-
-class TestBytesIOCreation:
-
-    def test_simple_creation(self):
-        f = io.BytesIO(b"\x12\xff\x77helloworld")
-        s = CBS(f)
-        assert s[0:8] == '0x12'
-        assert len(s) == 13 * 8
-        s = CBS(f, offset=8, length=12)
-        assert s == '0xff7'
-
-    def test_exceptions(self):
-        f = io.BytesIO(b"123456789")
-        _ = CBS(f, length=9*8)
-        with pytest.raises(bitstring.CreationError):
-            _ = CBS(f, length=9*8 + 1)
-        with pytest.raises(bitstring.CreationError):
-            _ = CBS(f, length=9*8, offset=1)
-
-
-class TestCreationWithPos:
-
-    def test_default_creation(self):
-        s = CBS('0xabc')
-        assert s.pos == 0
-
-    def test_positive_pos(self):
-        s = CBS('0xabc', pos=0)
-        assert s.pos == 0
-        s = CBS('0xabc', pos=1)
-        assert s.pos == 1
-        s = CBS('0xabc', pos=12)
-        assert s.pos == 12
-        with pytest.raises(bitstring.CreationError):
-            _ = CBS('0xabc', pos=13)
-
-    def test_negative_pos(self):
-        s = CBS('0xabc', pos=-1)
-        assert s.pos == 11
-        s = CBS('0xabc', pos=-12)
-        assert s.pos == 0
-        with pytest.raises(bitstring.CreationError):
-            _ = CBS('0xabc', pos=-13)
-
-    def test_string_representation(self):
-        s = CBS('0b110', pos=2)
-        assert s.__repr__() == "ConstBitStream('0b110', pos=2)"
-
-    def test_string_representation_from_file(self):
-        filename = os.path.join(THIS_DIR, 'test.m1v')
-        s = CBS(filename=filename, pos=2001)
-        assert s.__repr__() == f"ConstBitStream(filename={repr(str(filename))}, length=1002400, pos=2001)"
-        s.pos = 0
-        assert s.__repr__() == f"ConstBitStream(filename={repr(str(filename))}, length=1002400)"
-
-
-def test_windows_file_lock_bug():
-    path = os.path.join(THIS_DIR, 'temp_unit_test_file')
-    # Create the file
-    with open(path, mode='w') as f:
-        f.write('Hello')
-    # Will this lock it?
-    _ = CBS(filename=path)
-
-    try:
-        with open(path, mode='w') as _:
-            pass
-    except OSError:
-        if platform.system() == 'Windows':
-            # Expected failure. See bug #308
-            pass
+#!/usr/bin/env python
+
+import pytest
+import sys
+import bitstring
+import io
+import os
+from bitstring import ConstBitStream as CBS
+import platform
+
+sys.path.insert(0, '..')
+
+
+THIS_DIR = os.path.dirname(os.path.abspath(__file__))
+
+class TestAll:
+    def test_from_file(self):
+        s = CBS(filename=os.path.join(THIS_DIR, 'test.m1v'))
+        assert s[0:32].hex == '000001b3'
+        assert s.read(8 * 4).hex == '000001b3'
+        width = s.read(12).uint
+        height = s.read(12).uint
+        assert (width, height) == (352, 288)
+
+    def test_from_file_with_offset_and_length(self):
+        s = CBS(filename=os.path.join(THIS_DIR, 'test.m1v'), offset=24, length=8)
+        assert s.h == 'b3'
+        reconstructed = ''
+        for bit in s:
+            reconstructed += '1' if bit is True else '0'
+        assert reconstructed == s.bin
+
+
+class TestInterleavedExpGolomb:
+    def test_reading(self):
+        s = CBS(uie=333)
+        a = s.read('uie')
+        assert a == 333
+        s = CBS('uie=12, sie=-9, sie=9, uie=1000000')
+        u = s.unpack('uie, 2*sie, uie')
+        assert u == [12, -9, 9, 1000000]
+
+    def test_reading_errors(self):
+        s = CBS(10)
+        with pytest.raises(bitstring.ReadError):
+            s.read('uie')
+        assert s.pos == 0
+        with pytest.raises(bitstring.ReadError):
+            s.read('sie')
+        assert s.pos == 0
+
+
+class TestReadTo:
+    def test_byte_aligned(self):
+        a = CBS('0xaabb00aa00bb')
+        b = a.readto('0x00', bytealigned=True)
+        assert b == '0xaabb00'
+        assert a.bytepos == 3
+        b = a.readto('0xaa', bytealigned=True)
+        assert b == '0xaa'
+        with pytest.raises(bitstring.ReadError):
+            b.readto('0xcc', bytealigned=True)
+
+    def test_not_aligned(self):
+        a = CBS('0b00111001001010011011')
+        a.pos = 1
+        assert a.readto('0b00') == '0b011100'
+        assert a.readto('0b110') == '0b10010100110'
+        with pytest.raises(ValueError):
+            a.readto('')
+
+    def test_disallow_integers(self):
+        a = CBS('0x0f')
+        with pytest.raises(ValueError):
+            a.readto(4)
+
+    def test_reading_lines(self):
+        s = b"This is a test\nof reading lines\nof text\n"
+        b = CBS(bytes=s)
+        n = bitstring.Bits(bytes=b'\n')
+        assert b.readto(n).bytes == b'This is a test\n'
+        assert b.readto(n).bytes == b'of reading lines\n'
+        assert b.readto(n).bytes == b'of text\n'
+
+
+class TestSubclassing:
+
+    def test_is_instance(self):
+        class SubBits(CBS):
+            pass
+        a = SubBits()
+        assert isinstance(a, SubBits)
+
+    def test_class_type(self):
+        class SubBits(CBS):
+            pass
+        assert SubBits().__class__ == SubBits
+
+
+class TestPadToken:
+
+    def test_read(self):
+        s = CBS('0b100011110001')
+        a = s.read('pad:1')
+        assert a == None
+        assert s.pos == 1
+        a = s.read(3)
+        assert a == CBS('0b000')
+        a = s.read('pad:1')
+        assert a == None
+        assert s.pos == 5
+
+    def test_read_list(self):
+        s = CBS.fromstring('0b10001111001')
+        t = s.readlist('pad:1, uint:3, pad:4, uint:3')
+        assert t == [0, 1]
+        s.pos = 0
+        t = s.readlist('pad:1, pad:5')
+        assert t == []
+        assert s.pos == 6
+        s.pos = 0
+        t = s.readlist('pad:1, bin, pad:4, uint:3')
+        assert t == ['000', 1]
+        s.pos = 0
+        t = s.readlist('pad, bin:3, pad:4, uint:3')
+        assert t == ['000', 1]
+
+
+class TestReadingBytes:
+
+    def test_unpacking_bytes(self):
+        s = CBS(80)
+        t = s.unpack('bytes:1')
+        assert t[0] == b'\x00'
+        a, b, c = s.unpack('bytes:1, bytes, bytes2')
+        assert a == b'\x00'
+        assert b == b'\x00'*7
+        assert c == b'\x00'*2
+
+    def test_unpacking_bytes_with_keywords(self):
+        s = CBS('0x55'*10)
+        t = s.unpack('pad:a, bytes:b, bytes, pad:a', a=4, b=6)
+        assert t == [b'\x55'*6, b'\x55'*3]
+
+
+class TestReadingBitsAsDefault:
+
+    def test_read_bits(self):
+        s = CBS('uint:31=14')
+        v = s.read(31)
+        assert v.uint == 14
+        s.pos = 0
+
+    def test_read_list_bits(self):
+        s = CBS('uint:5=3, uint:3=0, uint:11=999')
+        v = s.readlist([5, 3, 11])
+        assert [x.uint for x in v] == [3, 0, 999]
+        s.pos = 0
+        v = s.readlist(['5', '3', 11])
+        assert [x.uint for x in v] == [3, 0, 999]
+
+
+class TestLsb0Reading:
+
+    @classmethod
+    def setup_class(cls):
+        bitstring.lsb0 = True
+
+    @classmethod
+    def teardown_class(cls):
+        bitstring.lsb0 = False
+
+    def test_reading_hex(self):
+        s = CBS('0xabcdef')
+        assert s.read('hex:4') == 'f'
+        assert s.read(4) == '0xe'
+        assert s.pos == 8
+
+    def test_reading_oct(self):
+        s = CBS('0o123456')
+        assert s.read('o6') == '56'
+        assert s.pos == 6
+
+    def test_reading_bin(self):
+        s = CBS('0b00011')
+        assert s.read('bin:3') == '011'
+        assert s.pos == 3
+
+    def test_reading_bytes(self):
+        s = CBS(bytes=b'54321')
+        assert s.pos == 0
+        s.pos = 8
+        assert s.read('bytes:2') == b'32'
+
+
+class TestBytesIOCreation:
+
+    def test_simple_creation(self):
+        f = io.BytesIO(b"\x12\xff\x77helloworld")
+        s = CBS(f)
+        assert s[0:8] == '0x12'
+        assert len(s) == 13 * 8
+        s = CBS(f, offset=8, length=12)
+        assert s == '0xff7'
+
+    def test_exceptions(self):
+        f = io.BytesIO(b"123456789")
+        _ = CBS(f, length=9*8)
+        with pytest.raises(bitstring.CreationError):
+            _ = CBS(f, length=9*8 + 1)
+        with pytest.raises(bitstring.CreationError):
+            _ = CBS(f, length=9*8, offset=1)
+
+
+class TestCreationWithPos:
+
+    def test_default_creation(self):
+        s = CBS('0xabc')
+        assert s.pos == 0
+
+    def test_positive_pos(self):
+        s = CBS('0xabc', pos=0)
+        assert s.pos == 0
+        s = CBS('0xabc', pos=1)
+        assert s.pos == 1
+        s = CBS('0xabc', pos=12)
+        assert s.pos == 12
+        with pytest.raises(bitstring.CreationError):
+            _ = CBS('0xabc', pos=13)
+
+    def test_negative_pos(self):
+        s = CBS('0xabc', pos=-1)
+        assert s.pos == 11
+        s = CBS('0xabc', pos=-12)
+        assert s.pos == 0
+        with pytest.raises(bitstring.CreationError):
+            _ = CBS('0xabc', pos=-13)
+
+    def test_string_representation(self):
+        s = CBS('0b110', pos=2)
+        assert s.__repr__() == "ConstBitStream('0b110', pos=2)"
+
+    def test_string_representation_from_file(self):
+        filename = os.path.join(THIS_DIR, 'test.m1v')
+        s = CBS(filename=filename, pos=2001)
+        assert s.__repr__() == f"ConstBitStream(filename={repr(str(filename))}, length=1002400, pos=2001)"
+        s.pos = 0
+        assert s.__repr__() == f"ConstBitStream(filename={repr(str(filename))}, length=1002400)"
+
+
+def test_windows_file_lock_bug():
+    path = os.path.join(THIS_DIR, 'temp_unit_test_file')
+    # Create the file
+    with open(path, mode='w') as f:
+        f.write('Hello')
+    # Will this lock it?
+    _ = CBS(filename=path)
+
+    try:
+        with open(path, mode='w') as _:
+            pass
+    except OSError:
+        if platform.system() == 'Windows':
+            # Expected failure. See bug #308
+            pass
+
+def test_readerrors():
+    s = CBS('0b110')
+    s.read(3)
+    with pytest.raises(bitstring.ReadError):
+        _ = s.read(1)
+    s.pos = 1
+    with pytest.raises(bitstring.ReadError):
+        _ = s.read('u3')
```

### Comparing `bitstring-4.2.1/tests/test_fp8.py` & `bitstring-4.2.2/tests/test_fp8.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,295 +1,335 @@
-from __future__ import annotations
-
-import pytest
-import sys
-import array
-import struct
-import math
-import bitstring
-from bitstring import Bits, BitArray, BitStream, Dtype, options
-from bitstring.fp8 import p4binary_fmt, p3binary_fmt
-from bitstring.mxfp import e4m3mxfp_saturate_fmt, e5m2mxfp_saturate_fmt
-import gfloat
-
-sys.path.insert(0, '..')
-
-
-class TestFp8:
-
-    def test_creation(self):
-        a = Bits(p4binary=-14.0)
-        assert a.p4binary == -14.0
-        b = Bits('p3binary=3.0')
-        assert b.p3binary == 3.0
-        assert len(b) == 8
-        c = Bits('p4binary=1000000000')
-        assert c.hex == '7f'
-        d = Bits('p3binary=-1e15774')
-        assert d.hex == 'ff'
-        e = Bits(p3binary=float('nan'))
-        assert math.isnan(e.p3binary)
-        assert e.hex == '80'
-
-    def test_reassignment(self):
-        a = BitArray()
-        a.p4binary = -0.25
-        assert a.p4binary == -0.25
-        a.p3binary = float('inf')
-        assert a.hex == '7f'
-        assert a.p4binary == float('inf')
-        a.p4binary = -9000.0
-        assert a.p4binary == float('-inf')
-        a.p3binary = -0.00000000001
-        assert a.p3binary == 0.0
-
-    def test_reading(self):
-        a = BitStream('0x00fff')
-        x = a.read('p3binary')
-        assert x == 0.0
-        assert a.pos == 8
-        x = a.read('p4binary')
-        assert x == -float('inf')
-        assert a.pos == 16
-
-    def test_read_list(self):
-        v = [-6, -2, 0.125, 7, 10]
-        a = bitstring.pack('5*p4binary', *v)
-        vp = a.readlist('5*p4binary')
-        assert v == vp
-
-    def test_interpretations(self):
-        a = BitArray('0x00')
-        assert a.p4binary == 0.0
-        assert a.p3binary == 0.0
-        a += '0b1'
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.p4binary
-        with pytest.raises(bitstring.InterpretError):
-            _ = a.p3binary
-
-
-def createLUT_for_int8_to_float(exp_bits, bias) -> array.array[float]:
-    """Create a LUT to convert an int in range 0-255 representing a float8 into a Python float"""
-    i2f = []
-    for i in range(256):
-        b = BitArray(uint=i, length=8)
-        sign = b[0]
-        exponent = b[1:1 + exp_bits].u
-        significand = b[1 + exp_bits:]
-        if exponent == 0:
-            significand.prepend([0])
-            exponent = -bias + 1
-        else:
-            significand.prepend([1])
-            exponent -= bias
-        f = float(significand.u) / (2.0 ** (7 - exp_bits))
-        f *= 2 ** exponent
-        i2f.append(f if not sign else -f)
-    # One special case for minus zero
-    i2f[0b10000000] = float('nan')
-    # and for positive and negative infinity
-    i2f[0b01111111] = float('inf')
-    i2f[0b11111111] = float('-inf')
-    return array.array('f', i2f)
-
-
-class TestCheckLUTs:
-
-    def test_lut_int8_to_p4binary(self):
-        lut_stored = p4binary_fmt.lut_binary8_to_float
-        assert len(lut_stored) == 256
-        lut_calculated = createLUT_for_int8_to_float(4, 8)
-        for i in range(len(lut_stored)):
-            if lut_stored[i] != lut_calculated[i]:
-                # Either they're equal or they're both nan (which doesn't compare as equal).
-                assert math.isnan(lut_stored[i])
-                assert math.isnan(lut_calculated[i])
-
-    def test_lut_int8_to_p3binary(self):
-        lut_stored = p3binary_fmt.lut_binary8_to_float
-        assert len(lut_stored) == 256
-        lut_calculated = createLUT_for_int8_to_float(5, 16)
-        for i in range(len(lut_stored)):
-            if lut_stored[i] != lut_calculated[i]:
-                # Either they're equal or they're both nan (which doesn't compare as equal).
-                assert math.isnan(lut_stored[i])
-                assert math.isnan(lut_calculated[i])
-
-# def test_strange_failure():
-#
-#     x = (b'x\x01\xed\xdd\x05\xba\x96\x05\x00\x05\xe1\x9f\xee\x06\xe9FZA\xa4\xbb'
-#          b'\xbb;\xa4SB\xba\xeb\xd2\xdd\x8dt\x97\x92J(\xa14\xa2\x84\x92\x8a\xa4\x82\xd2'
-#          b'\x1d\x12.c\x9e\xcb7\xef\x0e\xcel\xe0\x84B\xb2\x80\x05,`\x01\x0bX\xc0\x02'
-#          b'\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05\xde\xd7\x02\x11d'
-#          b'\x01\x0b\x04\xb6@D\x05\xba@$\x05\xba@\xe4\x80\x8b\x12pQ\x03.Z\xc0E'
-#          b'\x87\xc5\x80\xc5\x84\xc5\x82\xc5\x86\xc5\x81\xc5\x85\xc5\x83\xc5\x87%\x80%'
-#          b'\x84%\x82%\x86%\x81}\x00K\nK\x06K\x0eK\x01K\tK\x05K\rK\x03K\x0bK'
-#          b'\x07K\x0f\xcb\x00\xcb\x08\xcb\x04\xfb\x10\x96\x19\x96\x05\x96\x15\x96\r\x96'
-#          b"\x1d\x96\x03\x96\x13\xf6\x11\xeccX.Xn\xd8'\xb0<\xb0Oaya\xf9`\xf9a\x05`"
-#          b'\x05a\x85`\x85aE`Ea\xc5`\xc5a%`%a\xa5`\xa5ae`ea\xe5`\xe5a\x15`\x15a\x95`'
-#          b'\x95aU`Ua\xd5`\xd5a5`5a\xb5`\xb5au`ua\xf5`\xf5a\r`\ra\x8d`\x8daM`'
-#          b'\x9f\xc1\x9a\xc2\x9a\xc1\x9a\xc3Z\xc0Z\xc2Z\xc1Z\xc3\xda\xc0\xda\xc2'
-#          b'\xda\xc1\xda\xc3:\xc0>\x87u\x84u\x82u\x86u\x81}\x01\xeb\n\xeb\x06\xeb\x0e'
-#          b'\xeb\x01\xeb\t\xeb\x05\xeb\r\xeb\x03\xeb\x0b\xeb\x07\xeb\x0f\x1b\x00\x1b\x08'
-#          b'\x1b\x04\x1b\x0c\x1b"\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0'
-#          b'\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0b'
-#          b'X\xc0\x02\x16\xb0\x80\x05,\x10\xce\x0b\x0c\r\x93\x05,\x10\xd4\x02\xef'
-#          b'\xeb\xaf\x99\xbb,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX'
-#          b'\xc0\x02\x16\xb0\x80\x05,`\x81Ph\x98,`\x81\xc0\x16\x18\xae@\x17\x18\xa1@'
-#          b'\x17\x18\x19p\xa3\x02nt\xc0\x8d\t\xb8\xb1\xb0q\xb0\xf1\xb0\t\xb0'
-#          b'\x89\xb0I\xb0\xc9\xb0)\xb0\xa9\xb0i\xb0\xe9\xb0\x19\xb0\x99\xb0Y\xb0'
-#          b'\xd9\xb09\xb0\xb9\xb0y\xb0\xf9\xb0/a\x0b`\x0ba\x8b`\x8baK`Ka\xcb`\xcba+`+a'
-#          b'\xab`\xabak`ka\xeb`\xeba\x1b`_\xc1\xbe\x86m\x84m\x82m\x86m\x81m\x85'
-#          b'm\x83}\x03\xfb\x16\xb6\x1d\xb6\x03\xb6\x13\xb6\x0b\xf6\x1d\xec{\xd8n'
-#          b'\xd8\x1e\xd8^\xd8>\xd8\x0f\xb0\x1fa\xfba\x07`\x07a\x87`\x87aG`Ga\xc7`?'
-#          b'\xc1\x8e\xc3~\x86\xfd\x02;\x01;\t;\x05;\r\xfb\x15\xf6\x1b\xec\x0c\xec,\xec'
-#          b'\x1c\xec<\xec\x02\xec"\xecw\xd8\x1f\xb0K\xb0?a\x97aW`Wa\xd7`\xd7a7`'
-#          b'\x7f\xc1\xfe\x86\xdd\x84\xdd\x82\xfd\x03\xfb\x17v\x1bv\x07v\x17v\x0f'
-#          b'v\x1f\xf6\x00\xf6\x10\xf6\x08\xf6\x18\xf6\x04\xf6\x14\xf6\x0c'
-#          b'\xf6\x1c\xf6\x02\xf6\x12\xf6\n\xf6\x1f\xec5\xec\r\xec\xad,`\x01\x0b'
-#          b'X\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0'
-#          b'\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0@8/\xf0.\xa8\xc7\xe7\xee\xb6'
-#          b'\x80\x05\xc2\xfe\x07j_rx')
-#
-#     y = (b'x\x01\xed\xdde\x9a\x90\x05\x00Ea\x1aIQZ\x1a\xa4\x94\x06\xa5A:\x04\xa4'
-#          b'T\xba\x1b\xe9n\x90\x90.%$\xa5KP\x91\xeeV\xba\xbb\xbb\xbb\x9bE\xcc\x8f'
-#          b'\xf3\xcc|\xe7\xdd\xc1=\x1b\xb8\xe1\xc2\xc9\x02\x16\xb0\x80\x05,`\x01'
-#          b'\x0bX\xc0\x02\x16\xb0\x80\x05,`\x810_ \xbc,`\x01\x0bX \x88\x05"\xc8\x02A.'
-#          b'\x10QA.\x10Il\x81\xc8\xc1\x16%\xe8\xa2\x06\xdbG\xa1]4VtZ\x0cVLZ,Vl\xda\xc7'
-#          b'\xac8\xb4OX\x9f\xd2\xe2\xb2\xe2\xd1\xe2\xb3\x12\xd0\x12\xb2\x12\xd1\x12'
-#          b'\xb3>\xa3%a%\xa5%c%\xa7\xa5`\xa5\xa4\xa5b\xa5\xa6\xa5a}NK\xcbJGK'
-#          b"\xcf\xca@\xcb\xc8\xfa\x82\xf6%+\x13-3+\x0b-++\x1b-;+\x07-'+\x17\xed"
-#          b'+\xd6\xd7\xb4\xdc\xac<\xb4\xbc\xac|\xb4\xfc\xac\x02\xb4\x82\xacB\xb4'
-#          b'\xc2\xacohEXEi\xc5X\xc5i%X%i\xa5X\xa5ieXei\xdf\xb2\xca\xd1\xca\xb3*\xd0'
-#          b'\xbecU\xa4UbU\xa6UaU\xa5}\xcf\xfa\x81\xf6#\xab\x1a\xad:\xab\x06\xad&\xab\x16'
-#          b'\xad6\xab\x0e\xad.\xab\x1e\xad>\xab\x01\xad!\xab\x11\xad1\xab\t\xad)\xab\x19'
-#          b"\xad9\xab\x05\xad%\xeb'Z+VkZ\x1bV[Z;V{Z\x07VGZ'VgZ\x17VWZ7VwZ\x0fVOZ/V\xef"
-#          b'\x90\xea#\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`'
-#          b'\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05'
-#          b',\x10\xca\x0b\xf4\x95\x05,\x10\xd4\x02a\xfe\xdf\xd0\x81\x16\xb0\x80\x05'
-#          b',`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\x08p\x81~\n'
-#          b't\x81\x9fe\x81 \x17\xe8\xaf \x17\x18 \xb6\xc0\xc0`\x1b\x14t\xbf\x04\xdb\xe0'
-#          b'\xd0n\x08k(m\x18k8m\x04k$m\x14k4m\x0ck,\xedW\xd6o\xb4q\xac\xf1\xb4\t\xac'
-#          b'\x89\xb4\xdfY\x93h\x93YShSY\xd3h\xd3Y\x7f\xd0f\xb0f\xd2f\xb1f\xd3\xe6\xb0'
-#          b'\xe6\xd2\xe6\xb1\xe6\xd3\x16\xb0\x16\xd2\x16\xb1\xfe\xa4-f-\xa1\xfd\xc5'
-#          b'\xfa\x9b\xf6\x0fk)\xed_\xd62\xdar\xd6\n\xdaJ\xd6*\xdaj\xd6\x1a\xdaZ'
-#          b'\xd6:\xdaz\xd6\x06\xdaF\xd6&\xdaf\xd6\x16\xdaV\xd66\xdav\xd6\x0e\xda\x7f'
-#          b"\xac\xffi;Y\xbbh\xbbY{h{Y\xfbh\xfbY\x07h\x07Y\x87h\x87YGhGY\xc7h\xc7Y'h'"
-#          b'Y\xa7h\xa7YghgY\xe7h\xe7Y\x17h\x17Y\x97h\x97YWhWY\xd7h\xd7Y7h7Y\xb7h\xb7Ywhw'
-#          b'Y\xf7h\xf7Y\x0fh\x0fY\x8fh\x8fYOhOY\xcfh\xcfY/h/Y\xafh\xafYohoY\xefB\xea'
-#          b'\xbd,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,'
-#          b'`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0@(/\x10\xd4'
-#          b'\xe3sw[\xc0\x02}?\x00\xacO\xfe\xf9')
-#
-#     import zlib
-#     x = zlib.decompress(x)
-#     y = zlib.decompress(y)
-#     assert len(x) == len(y) == 65536
-#     assert x == y
-
-
-class TestConversionToFP8:
-
-    def test_some143_values(self):
-        zero = bitstring.Bits('0b0000 0000')
-        assert p4binary_fmt.lut_binary8_to_float[zero.uint] == 0.0
-        max_normal = bitstring.Bits('0b0111 1110')
-        assert p4binary_fmt.lut_binary8_to_float[max_normal.uint] == 224.0
-        max_normal_neg = bitstring.Bits('0b1111 1110')
-        assert p4binary_fmt.lut_binary8_to_float[max_normal_neg.uint] == -224.0
-        min_normal = bitstring.Bits('0b0000 1000')
-        assert p4binary_fmt.lut_binary8_to_float[min_normal.uint] == 2**-7
-        min_subnormal = bitstring.Bits('0b0000 0001')
-        assert p4binary_fmt.lut_binary8_to_float[min_subnormal.uint] == 2**-10
-        max_subnormal = bitstring.Bits('0b0000 0111')
-        assert p4binary_fmt.lut_binary8_to_float[max_subnormal.uint] == 0.875 * 2**-7
-        nan = bitstring.Bits('0b1000 0000')
-        assert math.isnan(p4binary_fmt.lut_binary8_to_float[nan.uint])
-
-    def test_some152_values(self):
-        zero = bitstring.Bits('0b0000 0000')
-        assert p3binary_fmt.lut_binary8_to_float[zero.uint] == 0.0
-        max_normal = bitstring.Bits('0b0111 1110')
-        assert p3binary_fmt.lut_binary8_to_float[max_normal.uint] == 49152.0
-        max_normal_neg = bitstring.Bits('0b1111 1110')
-        assert p3binary_fmt.lut_binary8_to_float[max_normal_neg.uint] == -49152.0
-        min_normal = bitstring.Bits('0b0000 0100')
-        assert p3binary_fmt.lut_binary8_to_float[min_normal.uint] == 2**-15
-        min_subnormal = bitstring.Bits('0b0000 0001')
-        assert p3binary_fmt.lut_binary8_to_float[min_subnormal.uint] == 0.25 * 2**-15
-        max_subnormal = bitstring.Bits('0b0000 0011')
-        assert p3binary_fmt.lut_binary8_to_float[max_subnormal.uint] == 0.75 * 2**-15
-        nan = bitstring.Bits('0b1000 0000')
-        assert math.isnan(p3binary_fmt.lut_binary8_to_float[nan.uint])
-
-    def test_round_trip(self):
-        # For each possible 8bit int, convert to float, then convert that float back to an int
-        for fmt in [p4binary_fmt, p3binary_fmt]:
-            for i in range(256):
-                f = fmt.lut_binary8_to_float[i]
-                ip = fmt.float_to_int8(f)
-                assert ip == i
-
-    def test_compare_8bit_floats_with_gfloat(self):
-        for fi, lut in [(gfloat.formats.format_info_p3109(4), p4binary_fmt.lut_binary8_to_float),
-                        (gfloat.formats.format_info_p3109(3), p3binary_fmt.lut_binary8_to_float),
-                        (gfloat.formats.format_info_ocp_e4m3, e4m3mxfp_saturate_fmt.lut_int_to_float),
-                        (gfloat.formats.format_info_ocp_e5m2, e5m2mxfp_saturate_fmt.lut_int_to_float)]:
-            for i in range(256):
-                f = lut[i]
-                g = gfloat.decode_float(fi, i).fval
-                if math.isnan(g):
-                    assert math.isnan(f)
-                else:
-                    # The floats should be bitwise equal.
-                    assert f == g
-
-    def test_conversion_from_nan(self):
-        x = BitArray(p4binary8=float('nan'))
-        assert x == '0x80'
-        x = BitArray(p3binary8=float('nan'))
-        assert x == '0x80'
-
-    def test_conversion_from_inf(self):
-        x = BitArray(p4binary8=float('inf'))
-        assert x == '0x7f'
-        x = BitArray(p3binary8=float('inf'))
-        assert x == '0x7f'
-        x = BitArray(p4binary8=float('-inf'))
-        assert x == '0xff'
-        x = BitArray(p3binary8=float('-inf'))
-        assert x == '0xff'
-
-    def test_round_to_nearest(self):
-        # Some exact values
-        x = BitArray(p3binary=48.0)
-        assert x.p3binary == 48.0
-        x = BitArray(p3binary=56.0)
-        assert x.p3binary == 56.0
-        x = BitArray(p3binary=64.0)
-        assert x.p3binary == 64.0
-
-        x = BitArray(p3binary=51.9)
-        assert x.p3binary == 48.0
-        x = BitArray(p3binary=52.0)
-        assert x.p3binary == 48.0
-        assert x.bin[-1] == '0'
-        x = BitArray(p3binary=52.1)
-        assert x.p3binary == 56.0
-        x = BitArray(p3binary=60.0)
-        assert x.p3binary == 64.0
-        assert x.bin[-1] == '0'
-
-
-def test_rounding_consistent_to_gfloat():
-    for fi, dt in [[gfloat.formats.format_info_p3109(4), Dtype('p4binary')],
-                   [gfloat.formats.format_info_p3109(3), Dtype('p3binary')]]:
-        for i in range(0, 1 << 16):
-            f = BitArray(uint=i, length=16).float
-            mine = dt.parse(dt.build(f))
-            theirs = gfloat.round_float(fi, f)
-            if math.isnan(mine):
-                assert math.isnan(theirs)
-            else:
-                assert mine == theirs
-
+from __future__ import annotations
+
+import pytest
+import sys
+import array
+import math
+import bitstring
+from bitstring import Bits, BitArray, BitStream, Dtype
+from bitstring.fp8 import p4binary_fmt, p3binary_fmt
+from bitstring.mxfp import e4m3mxfp_saturate_fmt, e5m2mxfp_saturate_fmt, e3m2mxfp_fmt, e2m3mxfp_fmt, e2m1mxfp_fmt
+from gfloat.formats import (format_info_ocp_e4m3, format_info_ocp_e5m2, format_info_p3109, format_info_ocp_e3m2,
+                            format_info_ocp_e2m3, format_info_ocp_e2m1, format_info_ocp_int8, format_info_ocp_e8m0)
+import gfloat
+
+sys.path.insert(0, '..')
+
+
+class TestFp8:
+
+    def test_creation(self):
+        a = Bits(p4binary=-14.0)
+        assert a.p4binary == -14.0
+        b = Bits('p3binary=3.0')
+        assert b.p3binary == 3.0
+        assert len(b) == 8
+        c = Bits('p4binary=1000000000')
+        assert c.hex == '7f'
+        d = Bits('p3binary=-1e15774')
+        assert d.hex == 'ff'
+        e = Bits(p3binary=float('nan'))
+        assert math.isnan(e.p3binary)
+        assert e.hex == '80'
+
+    def test_reassignment(self):
+        a = BitArray()
+        a.p4binary = -0.25
+        assert a.p4binary == -0.25
+        a.p3binary = float('inf')
+        assert a.hex == '7f'
+        assert a.p4binary == float('inf')
+        a.p4binary = -9000.0
+        assert a.p4binary == float('-inf')
+        a.p3binary = -0.00000000001
+        assert a.p3binary == 0.0
+
+    def test_reading(self):
+        a = BitStream('0x00fff')
+        x = a.read('p3binary')
+        assert x == 0.0
+        assert a.pos == 8
+        x = a.read('p4binary')
+        assert x == -float('inf')
+        assert a.pos == 16
+
+    def test_read_list(self):
+        v = [-6, -2, 0.125, 7, 10]
+        a = bitstring.pack('5*p4binary', *v)
+        vp = a.readlist('5*p4binary')
+        assert v == vp
+
+    def test_interpretations(self):
+        a = BitArray('0x00')
+        assert a.p4binary == 0.0
+        assert a.p3binary == 0.0
+        a += '0b1'
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.p4binary
+        with pytest.raises(bitstring.InterpretError):
+            _ = a.p3binary
+
+
+def createLUT_for_int8_to_float(exp_bits, bias) -> array.array[float]:
+    """Create a LUT to convert an int in range 0-255 representing a float8 into a Python float"""
+    i2f = []
+    for i in range(256):
+        b = BitArray(uint=i, length=8)
+        sign = b[0]
+        exponent = b[1:1 + exp_bits].u
+        significand = b[1 + exp_bits:]
+        if exponent == 0:
+            significand.prepend([0])
+            exponent = -bias + 1
+        else:
+            significand.prepend([1])
+            exponent -= bias
+        f = float(significand.u) / (2.0 ** (7 - exp_bits))
+        f *= 2 ** exponent
+        i2f.append(f if not sign else -f)
+    # One special case for minus zero
+    i2f[0b10000000] = float('nan')
+    # and for positive and negative infinity
+    i2f[0b01111111] = float('inf')
+    i2f[0b11111111] = float('-inf')
+    return array.array('f', i2f)
+
+
+class TestCheckLUTs:
+
+    def test_lut_int8_to_p4binary(self):
+        lut_stored = p4binary_fmt.lut_binary8_to_float
+        assert len(lut_stored) == 256
+        lut_calculated = createLUT_for_int8_to_float(4, 8)
+        for i in range(len(lut_stored)):
+            if lut_stored[i] != lut_calculated[i]:
+                # Either they're equal or they're both nan (which doesn't compare as equal).
+                assert math.isnan(lut_stored[i])
+                assert math.isnan(lut_calculated[i])
+
+    def test_lut_int8_to_p3binary(self):
+        lut_stored = p3binary_fmt.lut_binary8_to_float
+        assert len(lut_stored) == 256
+        lut_calculated = createLUT_for_int8_to_float(5, 16)
+        for i in range(len(lut_stored)):
+            if lut_stored[i] != lut_calculated[i]:
+                # Either they're equal or they're both nan (which doesn't compare as equal).
+                assert math.isnan(lut_stored[i])
+                assert math.isnan(lut_calculated[i])
+
+# def test_strange_failure():
+#
+#     x = (b'x\x01\xed\xdd\x05\xba\x96\x05\x00\x05\xe1\x9f\xee\x06\xe9FZA\xa4\xbb'
+#          b'\xbb;\xa4SB\xba\xeb\xd2\xdd\x8dt\x97\x92J(\xa14\xa2\x84\x92\x8a\xa4\x82\xd2'
+#          b'\x1d\x12.c\x9e\xcb7\xef\x0e\xcel\xe0\x84B\xb2\x80\x05,`\x01\x0bX\xc0\x02'
+#          b'\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05\xde\xd7\x02\x11d'
+#          b'\x01\x0b\x04\xb6@D\x05\xba@$\x05\xba@\xe4\x80\x8b\x12pQ\x03.Z\xc0E'
+#          b'\x87\xc5\x80\xc5\x84\xc5\x82\xc5\x86\xc5\x81\xc5\x85\xc5\x83\xc5\x87%\x80%'
+#          b'\x84%\x82%\x86%\x81}\x00K\nK\x06K\x0eK\x01K\tK\x05K\rK\x03K\x0bK'
+#          b'\x07K\x0f\xcb\x00\xcb\x08\xcb\x04\xfb\x10\x96\x19\x96\x05\x96\x15\x96\r\x96'
+#          b"\x1d\x96\x03\x96\x13\xf6\x11\xeccX.Xn\xd8'\xb0<\xb0Oaya\xf9`\xf9a\x05`"
+#          b'\x05a\x85`\x85aE`Ea\xc5`\xc5a%`%a\xa5`\xa5ae`ea\xe5`\xe5a\x15`\x15a\x95`'
+#          b'\x95aU`Ua\xd5`\xd5a5`5a\xb5`\xb5au`ua\xf5`\xf5a\r`\ra\x8d`\x8daM`'
+#          b'\x9f\xc1\x9a\xc2\x9a\xc1\x9a\xc3Z\xc0Z\xc2Z\xc1Z\xc3\xda\xc0\xda\xc2'
+#          b'\xda\xc1\xda\xc3:\xc0>\x87u\x84u\x82u\x86u\x81}\x01\xeb\n\xeb\x06\xeb\x0e'
+#          b'\xeb\x01\xeb\t\xeb\x05\xeb\r\xeb\x03\xeb\x0b\xeb\x07\xeb\x0f\x1b\x00\x1b\x08'
+#          b'\x1b\x04\x1b\x0c\x1b"\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0'
+#          b'\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0b'
+#          b'X\xc0\x02\x16\xb0\x80\x05,\x10\xce\x0b\x0c\r\x93\x05,\x10\xd4\x02\xef'
+#          b'\xeb\xaf\x99\xbb,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX'
+#          b'\xc0\x02\x16\xb0\x80\x05,`\x81Ph\x98,`\x81\xc0\x16\x18\xae@\x17\x18\xa1@'
+#          b'\x17\x18\x19p\xa3\x02nt\xc0\x8d\t\xb8\xb1\xb0q\xb0\xf1\xb0\t\xb0'
+#          b'\x89\xb0I\xb0\xc9\xb0)\xb0\xa9\xb0i\xb0\xe9\xb0\x19\xb0\x99\xb0Y\xb0'
+#          b'\xd9\xb09\xb0\xb9\xb0y\xb0\xf9\xb0/a\x0b`\x0ba\x8b`\x8baK`Ka\xcb`\xcba+`+a'
+#          b'\xab`\xabak`ka\xeb`\xeba\x1b`_\xc1\xbe\x86m\x84m\x82m\x86m\x81m\x85'
+#          b'm\x83}\x03\xfb\x16\xb6\x1d\xb6\x03\xb6\x13\xb6\x0b\xf6\x1d\xec{\xd8n'
+#          b'\xd8\x1e\xd8^\xd8>\xd8\x0f\xb0\x1fa\xfba\x07`\x07a\x87`\x87aG`Ga\xc7`?'
+#          b'\xc1\x8e\xc3~\x86\xfd\x02;\x01;\t;\x05;\r\xfb\x15\xf6\x1b\xec\x0c\xec,\xec'
+#          b'\x1c\xec<\xec\x02\xec"\xecw\xd8\x1f\xb0K\xb0?a\x97aW`Wa\xd7`\xd7a7`'
+#          b'\x7f\xc1\xfe\x86\xdd\x84\xdd\x82\xfd\x03\xfb\x17v\x1bv\x07v\x17v\x0f'
+#          b'v\x1f\xf6\x00\xf6\x10\xf6\x08\xf6\x18\xf6\x04\xf6\x14\xf6\x0c'
+#          b'\xf6\x1c\xf6\x02\xf6\x12\xf6\n\xf6\x1f\xec5\xec\r\xec\xad,`\x01\x0b'
+#          b'X\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0'
+#          b'\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0@8/\xf0.\xa8\xc7\xe7\xee\xb6'
+#          b'\x80\x05\xc2\xfe\x07j_rx')
+#
+#     y = (b'x\x01\xed\xdde\x9a\x90\x05\x00Ea\x1aIQZ\x1a\xa4\x94\x06\xa5A:\x04\xa4'
+#          b'T\xba\x1b\xe9n\x90\x90.%$\xa5KP\x91\xeeV\xba\xbb\xbb\xbb\x9bE\xcc\x8f'
+#          b'\xf3\xcc|\xe7\xdd\xc1=\x1b\xb8\xe1\xc2\xc9\x02\x16\xb0\x80\x05,`\x01'
+#          b'\x0bX\xc0\x02\x16\xb0\x80\x05,`\x810_ \xbc,`\x01\x0bX \x88\x05"\xc8\x02A.'
+#          b'\x10QA.\x10Il\x81\xc8\xc1\x16%\xe8\xa2\x06\xdbG\xa1]4VtZ\x0cVLZ,Vl\xda\xc7'
+#          b'\xac8\xb4OX\x9f\xd2\xe2\xb2\xe2\xd1\xe2\xb3\x12\xd0\x12\xb2\x12\xd1\x12'
+#          b'\xb3>\xa3%a%\xa5%c%\xa7\xa5`\xa5\xa4\xa5b\xa5\xa6\xa5a}NK\xcbJGK'
+#          b"\xcf\xca@\xcb\xc8\xfa\x82\xf6%+\x13-3+\x0b-++\x1b-;+\x07-'+\x17\xed"
+#          b'+\xd6\xd7\xb4\xdc\xac<\xb4\xbc\xac|\xb4\xfc\xac\x02\xb4\x82\xacB\xb4'
+#          b'\xc2\xacohEXEi\xc5X\xc5i%X%i\xa5X\xa5ieXei\xdf\xb2\xca\xd1\xca\xb3*\xd0'
+#          b'\xbecU\xa4UbU\xa6UaU\xa5}\xcf\xfa\x81\xf6#\xab\x1a\xad:\xab\x06\xad&\xab\x16'
+#          b'\xad6\xab\x0e\xad.\xab\x1e\xad>\xab\x01\xad!\xab\x11\xad1\xab\t\xad)\xab\x19'
+#          b"\xad9\xab\x05\xad%\xeb'Z+VkZ\x1bV[Z;V{Z\x07VGZ'VgZ\x17VWZ7VwZ\x0fVOZ/V\xef"
+#          b'\x90\xea#\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`'
+#          b'\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05'
+#          b',\x10\xca\x0b\xf4\x95\x05,\x10\xd4\x02a\xfe\xdf\xd0\x81\x16\xb0\x80\x05'
+#          b',`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\x08p\x81~\n'
+#          b't\x81\x9fe\x81 \x17\xe8\xaf \x17\x18 \xb6\xc0\xc0`\x1b\x14t\xbf\x04\xdb\xe0'
+#          b'\xd0n\x08k(m\x18k8m\x04k$m\x14k4m\x0ck,\xedW\xd6o\xb4q\xac\xf1\xb4\t\xac'
+#          b'\x89\xb4\xdfY\x93h\x93YShSY\xd3h\xd3Y\x7f\xd0f\xb0f\xd2f\xb1f\xd3\xe6\xb0'
+#          b'\xe6\xd2\xe6\xb1\xe6\xd3\x16\xb0\x16\xd2\x16\xb1\xfe\xa4-f-\xa1\xfd\xc5'
+#          b'\xfa\x9b\xf6\x0fk)\xed_\xd62\xdar\xd6\n\xdaJ\xd6*\xdaj\xd6\x1a\xdaZ'
+#          b'\xd6:\xdaz\xd6\x06\xdaF\xd6&\xdaf\xd6\x16\xdaV\xd66\xdav\xd6\x0e\xda\x7f'
+#          b"\xac\xffi;Y\xbbh\xbbY{h{Y\xfbh\xfbY\x07h\x07Y\x87h\x87YGhGY\xc7h\xc7Y'h'"
+#          b'Y\xa7h\xa7YghgY\xe7h\xe7Y\x17h\x17Y\x97h\x97YWhWY\xd7h\xd7Y7h7Y\xb7h\xb7Ywhw'
+#          b'Y\xf7h\xf7Y\x0fh\x0fY\x8fh\x8fYOhOY\xcfh\xcfY/h/Y\xafh\xafYohoY\xefB\xea'
+#          b'\xbd,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,'
+#          b'`\x01\x0bX\xc0\x02\x16\xb0\x80\x05,`\x01\x0bX\xc0\x02\x16\xb0@(/\x10\xd4'
+#          b'\xe3sw[\xc0\x02}?\x00\xacO\xfe\xf9')
+#
+#     import zlib
+#     x = zlib.decompress(x)
+#     y = zlib.decompress(y)
+#     assert len(x) == len(y) == 65536
+#     assert x == y
+
+
+class TestConversionToFP8:
+
+    def test_some143_values(self):
+        zero = bitstring.Bits('0b0000 0000')
+        assert p4binary_fmt.lut_binary8_to_float[zero.uint] == 0.0
+        max_normal = bitstring.Bits('0b0111 1110')
+        assert p4binary_fmt.lut_binary8_to_float[max_normal.uint] == 224.0
+        max_normal_neg = bitstring.Bits('0b1111 1110')
+        assert p4binary_fmt.lut_binary8_to_float[max_normal_neg.uint] == -224.0
+        min_normal = bitstring.Bits('0b0000 1000')
+        assert p4binary_fmt.lut_binary8_to_float[min_normal.uint] == 2**-7
+        min_subnormal = bitstring.Bits('0b0000 0001')
+        assert p4binary_fmt.lut_binary8_to_float[min_subnormal.uint] == 2**-10
+        max_subnormal = bitstring.Bits('0b0000 0111')
+        assert p4binary_fmt.lut_binary8_to_float[max_subnormal.uint] == 0.875 * 2**-7
+        nan = bitstring.Bits('0b1000 0000')
+        assert math.isnan(p4binary_fmt.lut_binary8_to_float[nan.uint])
+
+    def test_some152_values(self):
+        zero = bitstring.Bits('0b0000 0000')
+        assert p3binary_fmt.lut_binary8_to_float[zero.uint] == 0.0
+        max_normal = bitstring.Bits('0b0111 1110')
+        assert p3binary_fmt.lut_binary8_to_float[max_normal.uint] == 49152.0
+        max_normal_neg = bitstring.Bits('0b1111 1110')
+        assert p3binary_fmt.lut_binary8_to_float[max_normal_neg.uint] == -49152.0
+        min_normal = bitstring.Bits('0b0000 0100')
+        assert p3binary_fmt.lut_binary8_to_float[min_normal.uint] == 2**-15
+        min_subnormal = bitstring.Bits('0b0000 0001')
+        assert p3binary_fmt.lut_binary8_to_float[min_subnormal.uint] == 0.25 * 2**-15
+        max_subnormal = bitstring.Bits('0b0000 0011')
+        assert p3binary_fmt.lut_binary8_to_float[max_subnormal.uint] == 0.75 * 2**-15
+        nan = bitstring.Bits('0b1000 0000')
+        assert math.isnan(p3binary_fmt.lut_binary8_to_float[nan.uint])
+
+    def test_round_trip(self):
+        # For each possible 8bit int, convert to float, then convert that float back to an int
+        for fmt in [p4binary_fmt, p3binary_fmt]:
+            for i in range(1 << 8):
+                f = fmt.lut_binary8_to_float[i]
+                ip = fmt.float_to_int8(f)
+                assert ip == i
+
+    def test_compare_8bit_floats_with_gfloat(self):
+        for fi, lut in [(format_info_p3109(4), p4binary_fmt.lut_binary8_to_float),
+                        (format_info_p3109(3), p3binary_fmt.lut_binary8_to_float),
+                        (format_info_ocp_e4m3, e4m3mxfp_saturate_fmt.lut_int_to_float),
+                        (format_info_ocp_e5m2, e5m2mxfp_saturate_fmt.lut_int_to_float),
+                        ]:
+            for i in range(1 << 8):
+                f = lut[i]
+                g = gfloat.decode_float(fi, i).fval
+                if math.isnan(g):
+                    assert math.isnan(f)
+                else:
+                    # The floats should be bitwise equal.
+                    assert f == g
+
+    def test_conversion_from_nan(self):
+        x = BitArray(p4binary8=float('nan'))
+        assert x == '0x80'
+        x = BitArray(p3binary8=float('nan'))
+        assert x == '0x80'
+
+    def test_conversion_from_inf(self):
+        x = BitArray(p4binary8=float('inf'))
+        assert x == '0x7f'
+        x = BitArray(p3binary8=float('inf'))
+        assert x == '0x7f'
+        x = BitArray(p4binary8=float('-inf'))
+        assert x == '0xff'
+        x = BitArray(p3binary8=float('-inf'))
+        assert x == '0xff'
+
+    def test_round_to_nearest(self):
+        # Some exact values
+        x = BitArray(p3binary=48.0)
+        assert x.p3binary == 48.0
+        x = BitArray(p3binary=56.0)
+        assert x.p3binary == 56.0
+        x = BitArray(p3binary=64.0)
+        assert x.p3binary == 64.0
+
+        x = BitArray(p3binary=51.9)
+        assert x.p3binary == 48.0
+        x = BitArray(p3binary=52.0)
+        assert x.p3binary == 48.0
+        assert x.bin[-1] == '0'
+        x = BitArray(p3binary=52.1)
+        assert x.p3binary == 56.0
+        x = BitArray(p3binary=60.0)
+        assert x.p3binary == 64.0
+        assert x.bin[-1] == '0'
+
+def test_compare_mxint8_with_gfloat():
+    for i in range(1 << 8):
+        f = Dtype('mxint8').parse(BitArray(uint=i, length=8))
+        g = gfloat.decode_float(format_info_ocp_int8, i).fval
+        assert f == g
+
+def test_compare_e8m0_with_gfloat():
+    for i in range(1 << 8):
+        f = Dtype('e8m0mxfp').parse(BitArray(uint=i, length=8))
+        g = gfloat.decode_float(format_info_ocp_e8m0, i).fval
+        if math.isnan(g):
+            assert math.isnan(f)
+        else:
+            assert f == g
+
+def test_compare_6bit_floats_with_gfloat():
+    for fi, lut in [(format_info_ocp_e3m2, e3m2mxfp_fmt.lut_int_to_float),
+                    (format_info_ocp_e2m3, e2m3mxfp_fmt.lut_int_to_float)]:
+        for i in range(1 << 6):
+            f = lut[i]
+            g = gfloat.decode_float(fi, i).fval
+            if math.isnan(g):
+                assert math.isnan(f)
+            else:
+                assert f == g
+
+def test_compare_4bit_floats_with_gfloat():
+    fi = format_info_ocp_e2m1
+    lut = e2m1mxfp_fmt.lut_int_to_float
+
+    for i in range(1 << 4):
+        f = lut[i]
+        g = gfloat.decode_float(fi, i).fval
+        if math.isnan(g):
+            assert math.isnan(f)
+        else:
+            assert f == g
+
+
+def test_rounding_consistent_to_gfloat():
+    for fi, dt in [[format_info_p3109(4), Dtype('p4binary')],
+                   [format_info_p3109(3), Dtype('p3binary')]]:
+        for i in range(0, 1 << 16):
+            f = BitArray(uint=i, length=16).float
+            mine = dt.parse(dt.build(f))
+            theirs = gfloat.round_float(fi, f)
+            if math.isnan(mine):
+                assert math.isnan(theirs)
+            else:
+                assert mine == theirs
+
```

### Comparing `bitstring-4.2.1/tests/test_mxfp.py` & `bitstring-4.2.2/tests/test_mxfp.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,441 +1,440 @@
-from __future__ import annotations
-
-import sys
-import math
-from bitstring import BitArray, Dtype, Array, options
-import pytest
-import gfloat
-
-sys.path.insert(0, '..')
-
-
-def test_creation_e3m2mxfp():
-    x = BitArray('0b000000')
-    assert x.e3m2mxfp == 0.0
-    x.e3m2mxfp = 0.0
-    assert x.e3m2mxfp == 0.0
-    assert len(x) == 6
-
-def test_getting_e4m3mxfp_values():
-    assert BitArray('0b00000000').e4m3mxfp == 0.0
-    assert BitArray('0b01111110').e4m3mxfp == 448.0
-    assert BitArray('0b11111110').e4m3mxfp == -448.0
-    assert BitArray('0b00001000').e4m3mxfp == 2**-6
-    assert math.isnan(BitArray('0b01111111').e4m3mxfp)
-    assert math.isnan(BitArray('0b11111111').e4m3mxfp)
-
-def test_setting_e4m3mxfp_values():
-    x = BitArray('0b00000000')
-    x.e4m3mxfp = 0.0
-    assert x == '0b00000000'
-    x.e4m3mxfp = -(2 ** -9)
-    assert x == '0b10000001'
-    x.e4m3mxfp = 99999
-    assert x.e4m3mxfp == 448.0
-
-def test_getting_e5m2mxfp_values():
-    assert BitArray('0b00000000').e5m2mxfp == 0.0
-    assert BitArray('0b01111011').e5m2mxfp == 57344
-    for b in ['0b01111101', '0b11111101', '0b01111110', '0b11111110', '0b01111111', '0b11111111']:
-        assert math.isnan(BitArray(b).e5m2mxfp)
-    assert BitArray('0b01111100').e5m2mxfp == float('inf')
-    assert BitArray('0b11111100').e5m2mxfp == float('-inf')
-    assert BitArray('0b00000001').e5m2mxfp == 2 ** -16
-    assert BitArray('0b00000100').e5m2mxfp == 2 ** -14
-
-def test_setting_e5m2mxfp_values():
-    x = BitArray('0b00000000')
-    x.e5m2mxfp = 0.0
-    assert x == '0b00000000'
-    x.e5m2mxfp = -(2 ** -16)
-    assert x == '0b10000001'
-    x.e5m2mxfp = 99999
-    assert x.e5m2mxfp == 57344.0
-
-
-def test_getting_e3m2mxfp_values():
-    assert BitArray('0b000000').e3m2mxfp == 0.0
-    assert BitArray('0b000001').e3m2mxfp == 0.0625
-    assert BitArray('0b000011').e3m2mxfp == 0.1875
-    assert BitArray('0b000100').e3m2mxfp == 0.25
-    assert BitArray('0b011111').e3m2mxfp == 28.0
-
-def test_setting_e3m2mxfp_values():
-    x = BitArray('0b000000')
-    x.e3m2mxfp = 0.0
-    assert x == '0b000000'
-    x.e3m2mxfp = -0.0625
-    assert x == '0b100001'
-    x.e3m2mxfp = -0.1875
-    assert x == '0b100011'
-    x.e3m2mxfp = -0.25
-    assert x == '0b100100'
-    x.e3m2mxfp = -28.0
-    assert x == '0b111111'
-
-def test_getting_e2m3mxfp_values():
-    assert BitArray('0b000000').e2m3mxfp == 0.0
-    assert BitArray('0b000001').e2m3mxfp == 0.125
-    assert BitArray('0b000111').e2m3mxfp == 0.875
-    assert BitArray('0b001000').e2m3mxfp == 1.0
-    assert BitArray('0b011111').e2m3mxfp == 7.5
-
-def test_setting_e2m3mxfp_values():
-    x = BitArray('0b000000')
-    x.e2m3mxfp = 0.0
-    assert x == '0b000000'
-    x.e2m3mxfp = -0.125
-    assert x == '0b100001'
-    x.e2m3mxfp = -0.875
-    assert x == '0b100111'
-    x.e2m3mxfp = -1.0
-    assert x == '0b101000'
-    x.e2m3mxfp = -7.5
-    assert x == '0b111111'
-
-def test_getting_e2m1mxfp_values():
-    assert BitArray('0b0000').e2m1mxfp == 0.0
-    assert BitArray('0b0001').e2m1mxfp == 0.5
-    assert BitArray('0b0010').e2m1mxfp == 1.0
-    assert BitArray('0b0111').e2m1mxfp == 6.0
-
-def test_setting_e2m1mxfp_values():
-    x = BitArray('0b0000')
-    x.e2m1mxfp = 0.0
-    assert x == '0b0000'
-    x.e2m1mxfp = -0.5
-    assert x == '0b1001'
-    x.e2m1mxfp = -1.0
-    assert x == '0b1010'
-    x.e2m1mxfp = -6.0
-    assert x == '0b1111'
-
-
-def test_e8m0mxfp_value():
-    x = BitArray('0x00')
-    assert x.e8m0mxfp == 2.0 ** -127
-    x.uint = 127
-    assert x.e8m0mxfp == 1.0
-    x.uint = 254
-    assert x.e8m0mxfp == 2.0 ** 127
-    x.bin = '11111111'
-    assert math.isnan(x.e8m0mxfp)
-
-def test_getting_mxint_values():
-    assert BitArray('0b00000000').mxint == 0.0
-    assert BitArray('0b00000001').mxint == 1 * 2 ** -6
-    assert BitArray('0b00000011').mxint == 3 * 2 ** -6
-    assert BitArray('0b01111111').mxint == 127 * 2 ** -6
-    assert BitArray('0b10000000').mxint == -2.0
-    assert BitArray('0b11111111').mxint == -1 * 2 ** -6
-    assert BitArray('0b11111110').mxint == -2 * 2 ** -6
-    assert BitArray('0b10000001').mxint == -127 * 2 ** -6
-
-def test_setting_mxint_values():
-    x = BitArray('0b00000000')
-    x.mxint = 0.0
-    assert x == '0b00000000'
-    x.mxint = 1 * 2 ** -6
-    assert x == '0b00000001'
-    x.mxint = -1 * 2 ** -6
-    assert x == '0b11111111'
-
-
-def test_scaled_array():
-    sa = Array(Dtype('uint8', scale=2),[100, 200, 300, 400, 500])
-    assert sa.dtype.scale == 2
-    assert sa[0] == 100
-    assert sa[:] == [100, 200, 300, 400, 500]
-    sa.dtype = Dtype('uint8', scale=4)
-    assert sa.dtype.scale == 4
-    assert sa[0] == 200
-    sa.dtype = Dtype('uint8', scale=0.25)
-    assert sa.tolist() == [12.5, 25.0, 37.5, 50.0, 62.5]
-
-
-def test_setting_scaled_array():
-    sa = Array('e3m2mxfp')
-    sa.append(4.0)
-    assert sa[0] == 4.0
-    assert sa.dtype.scale is None
-    sa.dtype = Dtype('e3m2mxfp', scale = 0.5)
-    assert sa[0] == 2.0
-    sa.append(6.0)
-    assert sa[1] == 6.0
-    assert sa[:] == [2.0, 6.0]
-    sa *= 2
-    assert sa[:] == [4.0, 12.0]
-    sa[:] = [0.0, 0.5, 1.0]
-    assert sa[:] == [0.0, 0.5, 1.0]
-    sa.dtype = Dtype('e3m2mxfp', scale = 1)
-    assert sa[:] == [0.0, 1.0, 2.0]
-
-def test_multiple_scaled_arrays():
-    d = bytes(b'hello_everyone!')
-    s1 = Array(Dtype('e2m1mxfp', scale=1), d)
-    s2 = Array(Dtype('e2m1mxfp', scale=2**10), d)
-    s3 = Array(Dtype('e2m1mxfp', scale=2**-10), d)
-    assert s1.dtype.scale == 1
-    assert s2.dtype.scale == 2**10
-    assert s3.dtype.scale == 2**-10
-    assert s1[0] * 2**10 == s2[0]
-    assert s1[0] * 2**-10 == s3[0]
-
-def test_multiple_scaled_arrays2():
-    b = BitArray('0b011111')
-    assert b.e3m2mxfp == 28.0
-    s1 = Array('e3m2mxfp', [28])
-    assert s1[0] == 28.0
-    assert b.e3m2mxfp == 28.0
-    s2 = Array('e3m2mxfp', [28])
-    s2.dtype = Dtype('e3m2mxfp', scale=2**4)
-    assert s1[0] == 28.0
-    assert s2[0] == 28.0 * 2 ** 4
-    assert b.e3m2mxfp == 28.0
-
-def test_setting_from_outside_range():
-    b = BitArray(e2m1mxfp=0.0)
-    b.e2m1mxfp = 6.0
-    assert b.e2m1mxfp == 6.0
-    b.e2m1mxfp = 7.0
-    assert b.e2m1mxfp == 6.0
-    b.e2m1mxfp = 10000000000.0
-    assert b.e2m1mxfp == 6.0
-    s = Array('e2m1mxfp', [-1000.0, 6.0, 7.0, 10000.0])
-    assert s.tolist() == [-6.0, 6.0, 6.0, 6.0]
-    s = Array(Dtype('e2m1mxfp', scale=2), [-1000.0, 6.0, 7.0, 10000000000.0])
-    x = s.tolist()
-    assert x == [-12.0, 6.0, 8.0, 12.0]
-
-def test_ops():
-    s = Array(Dtype('e8m0mxfp', scale=2**2), [0.5, 1.0, 2.0, 4.0, 8.0])
-    t = s * 2
-    assert type(t) is Array
-    assert t.tolist() == [1.0, 2.0, 4.0, 8.0, 16.0]
-    assert t.dtype.scale == 2 ** 2
-
-def test_auto_scaling():
-    f = [0.0, 100.0, 256.0, -150.0]
-    for dtype in ['e3m2mxfp', 'e2m3mxfp', 'e2m1mxfp', 'mxint8', 'p3binary', 'p4binary']:
-        d = Dtype(dtype, scale='auto')
-        a = Array(d, f)
-        assert a[2] == 256.0
-
-def test_auto_scaling2():
-    some_floats = [-4, 100.0, -9999, 0.5, 42, 666]
-    a = Array(Dtype('float16', scale='auto'), some_floats)
-    assert a[2] == -10000.0
-    a = Array(Dtype('e2m1mxfp', scale='auto'), [1e200])
-    assert a.dtype.scale == 2 ** 127
-    a = Array(Dtype('e2m1mxfp', scale='auto'), [1e-200])
-    assert a.dtype.scale == 2 ** -127
-    a = Array(Dtype('e2m1mxfp', scale='auto'), [0, 0, 0, 0])
-    assert a.dtype.scale == 1
-
-
-def test_scaled_array_errors():
-    with pytest.raises(ValueError):
-        _ = Array(Dtype('bfloat', scale='auto'), [0.0, 100.0, 256.0, -150.0])
-    with pytest.raises(ValueError):
-        _ = Array(Dtype('uint9', scale='auto'), [0.0, 100.0, 256.0, -150.0])
-    with pytest.raises(ValueError):
-        _ = Dtype('e3m2mxfp', scale=0)
-    with pytest.raises(TypeError):
-        _ = Array(Dtype('e3m2mxfp', scale='auto'), b'hello')
-    with pytest.raises(TypeError):
-        _ = Array(Dtype('e3m2mxfp', scale='auto'), 100)
-
-
-def test_changing_to_auto_scaled_array():
-    a = Array('int16', [0, 2003, -43, 104, 6, 1, 99])
-    with pytest.raises(ValueError):
-        a.dtype = Dtype('e3m2mxfp', scale='auto')
-
-def test_conversion_to_e8m0():
-    x = BitArray(e8m0mxfp=1.0)
-    assert x.e8m0mxfp == 1.0
-    x = BitArray(e8m0mxfp=2**127)
-    assert x.e8m0mxfp == 2**127
-    x = BitArray(e8m0mxfp=2**-127)
-    assert x.e8m0mxfp == 2**-127
-    x = BitArray(e8m0mxfp=float('nan'))
-    assert math.isnan(x.e8m0mxfp)
-    with pytest.raises(ValueError):
-        _ = BitArray(e8m0mxfp=2**128)
-    with pytest.raises(ValueError):
-        _ = BitArray(e8m0mxfp=-2**128)
-    with pytest.raises(ValueError):
-        _ = BitArray(e8m0mxfp=0.0)
-    with pytest.raises(ValueError):
-        _ = BitArray(e8m0mxfp=1.1)
-
-
-def test_rounding_to_even():
-    # When rounding to even, the value chosen when two are equidistant should end in a zero bit.
-    x = BitArray(e4m3mxfp=21.0)
-    assert x.e4m3mxfp == 20.0
-    a = BitArray(e4m3mxfp=20.0).bin
-    b = BitArray(e4m3mxfp=22.0).bin
-    assert a[:-1] == b[:-1]
-    assert a[-1] == '0'
-    assert b[-1] == '1'
-    x = BitArray(e4m3mxfp=22.0)
-    assert x.e4m3mxfp == 22.0
-    x = BitArray(e4m3mxfp=23.0)
-    assert x.e4m3mxfp == 24.0
-    x = BitArray(e4m3mxfp=24.0)
-    assert x.e4m3mxfp == 24.0
-
-    x = BitArray(e4m3mxfp=-50)  # Midway between -48 and -52
-    assert x.e4m3mxfp == -48.0  # Rounds towards zero
-    assert x.bin[-1] == '0'
-    x = BitArray(e4m3mxfp=-54)  # Midway between -52 and -56
-    assert x.e4m3mxfp == -56.0  # Rounds away from zero
-    assert x.bin[-1] == '0'
-
-def test_rounding_consistent_to_gfloat():
-    for fi, dt in [[gfloat.formats.format_info_ocp_e4m3, Dtype('e4m3mxfp')],
-                   [gfloat.formats.format_info_ocp_e5m2, Dtype('e5m2mxfp')]]:
-        for i in range(1 << 16):
-            f = BitArray(uint=i, length=16).float
-            mine = dt.parse(dt.build(f))
-            theirs = gfloat.round_float(fi, f, sat=True)
-            if math.isnan(mine):
-                assert math.isnan(theirs)
-            else:
-                assert mine == theirs
-
-@pytest.mark.usefixtures('switch_to_overflow')
-def test_rounding_consistent_to_gfloat_with_overflow():
-    assert options.mxfp_overflow == 'overflow'
-    for fi, dt in [[gfloat.formats.format_info_ocp_e4m3, Dtype('e4m3mxfp')],
-                   [gfloat.formats.format_info_ocp_e5m2, Dtype('e5m2mxfp')]]:
-        for i in range(1 << 16):
-            f = BitArray(uint=i, length=16).float
-            mine = dt.parse(dt.build(f))
-            theirs = gfloat.round_float(fi, f, sat=False)
-            if math.isnan(mine):
-                pass
-                # assert math.isnan(theirs)
-            else:
-                if mine != theirs:
-                    print(mine, theirs)
-
-def test_conversion_from_nan():
-    x = BitArray(e4m3mxfp=float('nan'))
-    assert x == '0b11111111'
-    x = BitArray(e5m2mxfp=float('nan'))
-    assert x == '0b11111111'
-    with pytest.raises(ValueError):
-        _ = BitArray(e3m2mxfp=float('nan'))
-    with pytest.raises(ValueError):
-        _ = BitArray(e2m3mxfp=float('nan'))
-    with pytest.raises(ValueError):
-        _ = BitArray(e2m1mxfp=float('nan'))
-    with pytest.raises(ValueError):
-        _ = BitArray(mxint=float('nan'))
-    x = BitArray(e8m0mxfp=float('nan'))
-    assert x == '0b11111111'
-
-def test_conversion_from_inf():
-    x = BitArray(e3m2mxfp=float('inf'))
-    assert x.e3m2mxfp == 28.0
-    x = BitArray(e3m2mxfp=float('-inf'))
-    assert x.e3m2mxfp == -28.0
-
-    x = BitArray(e2m3mxfp=float('inf'))
-    assert x.e2m3mxfp == 7.5
-    x = BitArray(e2m3mxfp=float('-inf'))
-    assert x.e2m3mxfp == -7.5
-
-    x = BitArray(e2m1mxfp=float('inf'))
-    assert x.e2m1mxfp == 6.0
-    x = BitArray(e2m1mxfp=float('-inf'))
-    assert x.e2m1mxfp == -6.0
-
-    x = BitArray(mxint=float('inf'))
-    assert x.mxint == 1.984375
-    x = BitArray(mxint=float('-inf'))
-    assert x.mxint == -2.0
-
-    with pytest.raises(ValueError):
-        _ = BitArray(e8m0mxfp=float('inf'))
-    with pytest.raises(ValueError):
-        _ = BitArray(e8m0mxfp=float('-inf'))
-
-def test_conversion_to_8bit_with_saturate():
-    assert options.mxfp_overflow == 'saturate'
-    x = BitArray(e5m2mxfp=float('inf'))
-    assert x.e5m2mxfp == 57344.0
-    x = BitArray(e5m2mxfp=float('-inf'))
-    assert x.e5m2mxfp == -57344.0
-
-    x = BitArray(e5m2mxfp=1e10)
-    assert x.e5m2mxfp == 57344.0
-    x = BitArray(e5m2mxfp=-1e10)
-    assert x.e5m2mxfp == -57344.0
-
-    x = BitArray(e4m3mxfp=float('inf'))
-    assert x.e4m3mxfp == 448.0
-    x = BitArray(e4m3mxfp=float('-inf'))
-    assert x.e4m3mxfp == -448.0
-
-    x = BitArray(e4m3mxfp=1e10)
-    assert x.e4m3mxfp == 448.0
-    x = BitArray(e4m3mxfp=-1e10)
-    assert x.e4m3mxfp == -448.0
-
-@pytest.fixture
-def switch_to_overflow():
-    options.mxfp_overflow = 'overflow'
-    yield
-    options.mxfp_overflow = 'saturate'
-
-@pytest.mark.usefixtures('switch_to_overflow')
-def test_conversion_to_8bit_with_overflow():
-    x = BitArray(e5m2mxfp=float('inf'))
-    assert x.e5m2mxfp == float('inf')
-    x = BitArray(e5m2mxfp=float('-inf'))
-    assert x.e5m2mxfp == float('-inf')
-
-    x = BitArray(e5m2mxfp=1e10)
-    assert x.e5m2mxfp == float('inf')
-    x = BitArray(e5m2mxfp=-1e10)
-    assert x.e5m2mxfp == float('-inf')
-
-    x = BitArray(e4m3mxfp=float('inf'))
-    assert math.isnan(x.e4m3mxfp)
-    x = BitArray(e4m3mxfp=float('-inf'))
-    assert math.isnan(x.e4m3mxfp)
-
-    x = BitArray(e4m3mxfp=1e10)
-    assert math.isnan(x.e4m3mxfp)
-    x = BitArray(e4m3mxfp=-1e10)
-    assert math.isnan(x.e4m3mxfp)
-
-def test_mxint_rounding():
-    x = BitArray('mxint=0.0')
-    assert x == '0x00'
-    x.mxint = -2.0
-    assert x.mxint == -2.0
-    x.mxint = 1.0/64
-    assert x.mxint == 1.0/64
-    assert x == '0x01'
-    x.mxint = 1000
-    assert x.mxint == 1.0 + 63.0/64.0
-    x.mxint = 1.4 / 64.0
-    assert x.mxint == 1.0 / 64.0
-    x.mxint = 1.6 / 64.0
-    assert x.mxint == 2.0 / 64.0
-    x.mxint = 1.5 / 64.0
-    assert x.mxint == 2.0 / 64.0  # Round to even
-    x.mxint = 2.5 / 64.0
-    assert x.mxint == 2.0 / 64.0  # Round to even
-    x.mxint = -2.5
-    assert x.mxint == -2.0
-    x.mxint = -1.5 / 64.0
-    assert x.mxint == -2.0 / 64.0
-    x.mxint = -2.5 / 64.0
-    assert x.mxint == -2.0 / 64.0
-    x.mxint = -3.5 / 64.0
-    assert x.mxint == -4.0 / 64.0
+from __future__ import annotations
+
+import sys
+import math
+from bitstring import BitArray, Dtype, Array, options
+import pytest
+import gfloat
+
+sys.path.insert(0, '..')
+
+
+def test_creation_e3m2mxfp():
+    x = BitArray('0b000000')
+    assert x.e3m2mxfp == 0.0
+    x.e3m2mxfp = 0.0
+    assert x.e3m2mxfp == 0.0
+    assert len(x) == 6
+
+def test_getting_e4m3mxfp_values():
+    assert BitArray('0b00000000').e4m3mxfp == 0.0
+    assert BitArray('0b01111110').e4m3mxfp == 448.0
+    assert BitArray('0b11111110').e4m3mxfp == -448.0
+    assert BitArray('0b00001000').e4m3mxfp == 2**-6
+    assert math.isnan(BitArray('0b01111111').e4m3mxfp)
+    assert math.isnan(BitArray('0b11111111').e4m3mxfp)
+
+def test_setting_e4m3mxfp_values():
+    x = BitArray('0b00000000')
+    x.e4m3mxfp = 0.0
+    assert x == '0b00000000'
+    x.e4m3mxfp = -(2 ** -9)
+    assert x == '0b10000001'
+    x.e4m3mxfp = 99999
+    assert x.e4m3mxfp == 448.0
+
+def test_getting_e5m2mxfp_values():
+    assert BitArray('0b00000000').e5m2mxfp == 0.0
+    assert BitArray('0b01111011').e5m2mxfp == 57344
+    for b in ['0b01111101', '0b11111101', '0b01111110', '0b11111110', '0b01111111', '0b11111111']:
+        assert math.isnan(BitArray(b).e5m2mxfp)
+    assert BitArray('0b01111100').e5m2mxfp == float('inf')
+    assert BitArray('0b11111100').e5m2mxfp == float('-inf')
+    assert BitArray('0b00000001').e5m2mxfp == 2 ** -16
+    assert BitArray('0b00000100').e5m2mxfp == 2 ** -14
+
+def test_setting_e5m2mxfp_values():
+    x = BitArray('0b00000000')
+    x.e5m2mxfp = 0.0
+    assert x == '0b00000000'
+    x.e5m2mxfp = -(2 ** -16)
+    assert x == '0b10000001'
+    x.e5m2mxfp = 99999
+    assert x.e5m2mxfp == 57344.0
+
+
+def test_getting_e3m2mxfp_values():
+    assert BitArray('0b000000').e3m2mxfp == 0.0
+    assert BitArray('0b000001').e3m2mxfp == 0.0625
+    assert BitArray('0b000011').e3m2mxfp == 0.1875
+    assert BitArray('0b000100').e3m2mxfp == 0.25
+    assert BitArray('0b011111').e3m2mxfp == 28.0
+
+def test_setting_e3m2mxfp_values():
+    x = BitArray('0b000000')
+    x.e3m2mxfp = 0.0
+    assert x == '0b000000'
+    x.e3m2mxfp = -0.0625
+    assert x == '0b100001'
+    x.e3m2mxfp = -0.1875
+    assert x == '0b100011'
+    x.e3m2mxfp = -0.25
+    assert x == '0b100100'
+    x.e3m2mxfp = -28.0
+    assert x == '0b111111'
+
+def test_getting_e2m3mxfp_values():
+    assert BitArray('0b000000').e2m3mxfp == 0.0
+    assert BitArray('0b000001').e2m3mxfp == 0.125
+    assert BitArray('0b000111').e2m3mxfp == 0.875
+    assert BitArray('0b001000').e2m3mxfp == 1.0
+    assert BitArray('0b011111').e2m3mxfp == 7.5
+
+def test_setting_e2m3mxfp_values():
+    x = BitArray('0b000000')
+    x.e2m3mxfp = 0.0
+    assert x == '0b000000'
+    x.e2m3mxfp = -0.125
+    assert x == '0b100001'
+    x.e2m3mxfp = -0.875
+    assert x == '0b100111'
+    x.e2m3mxfp = -1.0
+    assert x == '0b101000'
+    x.e2m3mxfp = -7.5
+    assert x == '0b111111'
+
+def test_getting_e2m1mxfp_values():
+    assert BitArray('0b0000').e2m1mxfp == 0.0
+    assert BitArray('0b0001').e2m1mxfp == 0.5
+    assert BitArray('0b0010').e2m1mxfp == 1.0
+    assert BitArray('0b0111').e2m1mxfp == 6.0
+
+def test_setting_e2m1mxfp_values():
+    x = BitArray('0b0000')
+    x.e2m1mxfp = 0.0
+    assert x == '0b0000'
+    x.e2m1mxfp = -0.5
+    assert x == '0b1001'
+    x.e2m1mxfp = -1.0
+    assert x == '0b1010'
+    x.e2m1mxfp = -6.0
+    assert x == '0b1111'
+
+
+def test_e8m0mxfp_value():
+    x = BitArray('0x00')
+    assert x.e8m0mxfp == 2.0 ** -127
+    x.uint = 127
+    assert x.e8m0mxfp == 1.0
+    x.uint = 254
+    assert x.e8m0mxfp == 2.0 ** 127
+    x.bin = '11111111'
+    assert math.isnan(x.e8m0mxfp)
+
+def test_getting_mxint_values():
+    assert BitArray('0b00000000').mxint == 0.0
+    assert BitArray('0b00000001').mxint == 1 * 2 ** -6
+    assert BitArray('0b00000011').mxint == 3 * 2 ** -6
+    assert BitArray('0b01111111').mxint == 127 * 2 ** -6
+    assert BitArray('0b10000000').mxint == -2.0
+    assert BitArray('0b11111111').mxint == -1 * 2 ** -6
+    assert BitArray('0b11111110').mxint == -2 * 2 ** -6
+    assert BitArray('0b10000001').mxint == -127 * 2 ** -6
+
+def test_setting_mxint_values():
+    x = BitArray('0b00000000')
+    x.mxint = 0.0
+    assert x == '0b00000000'
+    x.mxint = 1 * 2 ** -6
+    assert x == '0b00000001'
+    x.mxint = -1 * 2 ** -6
+    assert x == '0b11111111'
+
+
+def test_scaled_array():
+    sa = Array(Dtype('uint8', scale=2),[100, 200, 300, 400, 500])
+    assert sa.dtype.scale == 2
+    assert sa[0] == 100
+    assert sa[:] == [100, 200, 300, 400, 500]
+    sa.dtype = Dtype('uint8', scale=4)
+    assert sa.dtype.scale == 4
+    assert sa[0] == 200
+    sa.dtype = Dtype('uint8', scale=0.25)
+    assert sa.tolist() == [12.5, 25.0, 37.5, 50.0, 62.5]
+
+
+def test_setting_scaled_array():
+    sa = Array('e3m2mxfp')
+    sa.append(4.0)
+    assert sa[0] == 4.0
+    assert sa.dtype.scale is None
+    sa.dtype = Dtype('e3m2mxfp', scale = 0.5)
+    assert sa[0] == 2.0
+    sa.append(6.0)
+    assert sa[1] == 6.0
+    assert sa[:] == [2.0, 6.0]
+    sa *= 2
+    assert sa[:] == [4.0, 12.0]
+    sa[:] = [0.0, 0.5, 1.0]
+    assert sa[:] == [0.0, 0.5, 1.0]
+    sa.dtype = Dtype('e3m2mxfp', scale = 1)
+    assert sa[:] == [0.0, 1.0, 2.0]
+
+def test_multiple_scaled_arrays():
+    d = bytes(b'hello_everyone!')
+    s1 = Array(Dtype('e2m1mxfp', scale=1), d)
+    s2 = Array(Dtype('e2m1mxfp', scale=2**10), d)
+    s3 = Array(Dtype('e2m1mxfp', scale=2**-10), d)
+    assert s1.dtype.scale == 1
+    assert s2.dtype.scale == 2**10
+    assert s3.dtype.scale == 2**-10
+    assert s1[0] * 2**10 == s2[0]
+    assert s1[0] * 2**-10 == s3[0]
+
+def test_multiple_scaled_arrays2():
+    b = BitArray('0b011111')
+    assert b.e3m2mxfp == 28.0
+    s1 = Array('e3m2mxfp', [28])
+    assert s1[0] == 28.0
+    assert b.e3m2mxfp == 28.0
+    s2 = Array('e3m2mxfp', [28])
+    s2.dtype = Dtype('e3m2mxfp', scale=2**4)
+    assert s1[0] == 28.0
+    assert s2[0] == 28.0 * 2 ** 4
+    assert b.e3m2mxfp == 28.0
+
+def test_setting_from_outside_range():
+    b = BitArray(e2m1mxfp=0.0)
+    b.e2m1mxfp = 6.0
+    assert b.e2m1mxfp == 6.0
+    b.e2m1mxfp = 7.0
+    assert b.e2m1mxfp == 6.0
+    b.e2m1mxfp = 10000000000.0
+    assert b.e2m1mxfp == 6.0
+    s = Array('e2m1mxfp', [-1000.0, 6.0, 7.0, 10000.0])
+    assert s.tolist() == [-6.0, 6.0, 6.0, 6.0]
+    s = Array(Dtype('e2m1mxfp', scale=2), [-1000.0, 6.0, 7.0, 10000000000.0])
+    x = s.tolist()
+    assert x == [-12.0, 6.0, 8.0, 12.0]
+
+def test_ops():
+    s = Array(Dtype('e8m0mxfp', scale=2**2), [0.5, 1.0, 2.0, 4.0, 8.0])
+    t = s * 2
+    assert type(t) is Array
+    assert t.tolist() == [1.0, 2.0, 4.0, 8.0, 16.0]
+    assert t.dtype.scale == 2 ** 2
+
+def test_auto_scaling():
+    f = [0.0, 100.0, 256.0, -150.0]
+    for dtype in ['e3m2mxfp', 'e2m3mxfp', 'e2m1mxfp', 'mxint8', 'p3binary', 'p4binary']:
+        d = Dtype(dtype, scale='auto')
+        a = Array(d, f)
+        assert a[2] == 256.0
+
+def test_auto_scaling2():
+    some_floats = [-4, 100.0, -9999, 0.5, 42, 666]
+    a = Array(Dtype('float16', scale='auto'), some_floats)
+    assert a[2] == -10000.0
+    a = Array(Dtype('e2m1mxfp', scale='auto'), [1e200])
+    assert a.dtype.scale == 2 ** 127
+    a = Array(Dtype('e2m1mxfp', scale='auto'), [1e-200])
+    assert a.dtype.scale == 2 ** -127
+    a = Array(Dtype('e2m1mxfp', scale='auto'), [0, 0, 0, 0])
+    assert a.dtype.scale == 1
+
+
+def test_scaled_array_errors():
+    with pytest.raises(ValueError):
+        _ = Array(Dtype('bfloat', scale='auto'), [0.0, 100.0, 256.0, -150.0])
+    with pytest.raises(ValueError):
+        _ = Array(Dtype('uint9', scale='auto'), [0.0, 100.0, 256.0, -150.0])
+    with pytest.raises(ValueError):
+        _ = Dtype('e3m2mxfp', scale=0)
+    with pytest.raises(TypeError):
+        _ = Array(Dtype('e3m2mxfp', scale='auto'), b'hello')
+    with pytest.raises(TypeError):
+        _ = Array(Dtype('e3m2mxfp', scale='auto'), 100)
+
+
+def test_changing_to_auto_scaled_array():
+    a = Array('int16', [0, 2003, -43, 104, 6, 1, 99])
+    with pytest.raises(ValueError):
+        a.dtype = Dtype('e3m2mxfp', scale='auto')
+
+def test_conversion_to_e8m0():
+    x = BitArray(e8m0mxfp=1.0)
+    assert x.e8m0mxfp == 1.0
+    x = BitArray(e8m0mxfp=2**127)
+    assert x.e8m0mxfp == 2**127
+    x = BitArray(e8m0mxfp=2**-127)
+    assert x.e8m0mxfp == 2**-127
+    x = BitArray(e8m0mxfp=float('nan'))
+    assert math.isnan(x.e8m0mxfp)
+    with pytest.raises(ValueError):
+        _ = BitArray(e8m0mxfp=2**128)
+    with pytest.raises(ValueError):
+        _ = BitArray(e8m0mxfp=-2**128)
+    with pytest.raises(ValueError):
+        _ = BitArray(e8m0mxfp=0.0)
+    with pytest.raises(ValueError):
+        _ = BitArray(e8m0mxfp=1.1)
+
+
+def test_rounding_to_even():
+    # When rounding to even, the value chosen when two are equidistant should end in a zero bit.
+    x = BitArray(e4m3mxfp=21.0)
+    assert x.e4m3mxfp == 20.0
+    a = BitArray(e4m3mxfp=20.0).bin
+    b = BitArray(e4m3mxfp=22.0).bin
+    assert a[:-1] == b[:-1]
+    assert a[-1] == '0'
+    assert b[-1] == '1'
+    x = BitArray(e4m3mxfp=22.0)
+    assert x.e4m3mxfp == 22.0
+    x = BitArray(e4m3mxfp=23.0)
+    assert x.e4m3mxfp == 24.0
+    x = BitArray(e4m3mxfp=24.0)
+    assert x.e4m3mxfp == 24.0
+
+    x = BitArray(e4m3mxfp=-50)  # Midway between -48 and -52
+    assert x.e4m3mxfp == -48.0  # Rounds towards zero
+    assert x.bin[-1] == '0'
+    x = BitArray(e4m3mxfp=-54)  # Midway between -52 and -56
+    assert x.e4m3mxfp == -56.0  # Rounds away from zero
+    assert x.bin[-1] == '0'
+
+def test_rounding_consistent_to_gfloat():
+    for fi, dt in [[gfloat.formats.format_info_ocp_e4m3, Dtype('e4m3mxfp')],
+                   [gfloat.formats.format_info_ocp_e5m2, Dtype('e5m2mxfp')]]:
+        for i in range(1 << 16):
+            f = BitArray(uint=i, length=16).float
+            mine = dt.parse(dt.build(f))
+            theirs = gfloat.round_float(fi, f, sat=True)
+            if math.isnan(mine):
+                assert math.isnan(theirs)
+            else:
+                assert mine == theirs
+
+@pytest.mark.usefixtures('switch_to_overflow')
+def test_rounding_consistent_to_gfloat_with_overflow():
+    assert options.mxfp_overflow == 'overflow'
+    for fi, dt in [[gfloat.formats.format_info_ocp_e4m3, Dtype('e4m3mxfp')],
+                   [gfloat.formats.format_info_ocp_e5m2, Dtype('e5m2mxfp')]]:
+        for i in range(1 << 16):
+            f = BitArray(uint=i, length=16).float
+            mine = dt.parse(dt.build(f))
+            theirs = gfloat.round_float(fi, f, sat=False)
+            if math.isnan(mine):
+                assert math.isnan(theirs)
+            else:
+                if mine != theirs:
+                    print(mine, theirs)
+
+def test_conversion_from_nan():
+    x = BitArray(e4m3mxfp=float('nan'))
+    assert x == '0b11111111'
+    x = BitArray(e5m2mxfp=float('nan'))
+    assert x == '0b11111111'
+    with pytest.raises(ValueError):
+        _ = BitArray(e3m2mxfp=float('nan'))
+    with pytest.raises(ValueError):
+        _ = BitArray(e2m3mxfp=float('nan'))
+    with pytest.raises(ValueError):
+        _ = BitArray(e2m1mxfp=float('nan'))
+    with pytest.raises(ValueError):
+        _ = BitArray(mxint=float('nan'))
+    x = BitArray(e8m0mxfp=float('nan'))
+    assert x == '0b11111111'
+
+def test_conversion_from_inf():
+    x = BitArray(e3m2mxfp=float('inf'))
+    assert x.e3m2mxfp == 28.0
+    x = BitArray(e3m2mxfp=float('-inf'))
+    assert x.e3m2mxfp == -28.0
+
+    x = BitArray(e2m3mxfp=float('inf'))
+    assert x.e2m3mxfp == 7.5
+    x = BitArray(e2m3mxfp=float('-inf'))
+    assert x.e2m3mxfp == -7.5
+
+    x = BitArray(e2m1mxfp=float('inf'))
+    assert x.e2m1mxfp == 6.0
+    x = BitArray(e2m1mxfp=float('-inf'))
+    assert x.e2m1mxfp == -6.0
+
+    x = BitArray(mxint=float('inf'))
+    assert x.mxint == 1.984375
+    x = BitArray(mxint=float('-inf'))
+    assert x.mxint == -2.0
+
+    with pytest.raises(ValueError):
+        _ = BitArray(e8m0mxfp=float('inf'))
+    with pytest.raises(ValueError):
+        _ = BitArray(e8m0mxfp=float('-inf'))
+
+def test_conversion_to_8bit_with_saturate():
+    assert options.mxfp_overflow == 'saturate'
+    x = BitArray(e5m2mxfp=float('inf'))
+    assert x.e5m2mxfp == 57344.0
+    x = BitArray(e5m2mxfp=float('-inf'))
+    assert x.e5m2mxfp == -57344.0
+
+    x = BitArray(e5m2mxfp=1e10)
+    assert x.e5m2mxfp == 57344.0
+    x = BitArray(e5m2mxfp=-1e10)
+    assert x.e5m2mxfp == -57344.0
+
+    x = BitArray(e4m3mxfp=float('inf'))
+    assert x.e4m3mxfp == 448.0
+    x = BitArray(e4m3mxfp=float('-inf'))
+    assert x.e4m3mxfp == -448.0
+
+    x = BitArray(e4m3mxfp=1e10)
+    assert x.e4m3mxfp == 448.0
+    x = BitArray(e4m3mxfp=-1e10)
+    assert x.e4m3mxfp == -448.0
+
+@pytest.fixture
+def switch_to_overflow():
+    options.mxfp_overflow = 'overflow'
+    yield
+    options.mxfp_overflow = 'saturate'
+
+@pytest.mark.usefixtures('switch_to_overflow')
+def test_conversion_to_8bit_with_overflow():
+    x = BitArray(e5m2mxfp=float('inf'))
+    assert x.e5m2mxfp == float('inf')
+    x = BitArray(e5m2mxfp=float('-inf'))
+    assert x.e5m2mxfp == float('-inf')
+
+    x = BitArray(e5m2mxfp=1e10)
+    assert x.e5m2mxfp == float('inf')
+    x = BitArray(e5m2mxfp=-1e10)
+    assert x.e5m2mxfp == float('-inf')
+
+    x = BitArray(e4m3mxfp=float('inf'))
+    assert math.isnan(x.e4m3mxfp)
+    x = BitArray(e4m3mxfp=float('-inf'))
+    assert math.isnan(x.e4m3mxfp)
+
+    x = BitArray(e4m3mxfp=1e10)
+    assert math.isnan(x.e4m3mxfp)
+    x = BitArray(e4m3mxfp=-1e10)
+    assert math.isnan(x.e4m3mxfp)
+
+def test_mxint_rounding():
+    x = BitArray('mxint=0.0')
+    assert x == '0x00'
+    x.mxint = -2.0
+    assert x.mxint == -2.0
+    x.mxint = 1.0/64
+    assert x.mxint == 1.0/64
+    assert x == '0x01'
+    x.mxint = 1000
+    assert x.mxint == 1.0 + 63.0/64.0
+    x.mxint = 1.4 / 64.0
+    assert x.mxint == 1.0 / 64.0
+    x.mxint = 1.6 / 64.0
+    assert x.mxint == 2.0 / 64.0
+    x.mxint = 1.5 / 64.0
+    assert x.mxint == 2.0 / 64.0  # Round to even
+    x.mxint = 2.5 / 64.0
+    assert x.mxint == 2.0 / 64.0  # Round to even
+    x.mxint = -2.5
+    assert x.mxint == -2.0
+    x.mxint = -1.5 / 64.0
+    assert x.mxint == -2.0 / 64.0
+    x.mxint = -2.5 / 64.0
+    assert x.mxint == -2.0 / 64.0
+    x.mxint = -3.5 / 64.0
+    assert x.mxint == -4.0 / 64.0
```

