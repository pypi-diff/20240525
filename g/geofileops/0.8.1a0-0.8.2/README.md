# Comparing `tmp/geofileops-0.8.1a0.tar.gz` & `tmp/geofileops-0.8.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "geofileops-0.8.1a0.tar", last modified: Fri Jan 12 21:21:57 2024, max compression
+gzip compressed data, was "geofileops-0.8.2.tar", last modified: Sat May 25 21:26:23 2024, max compression
```

## Comparing `geofileops-0.8.1a0.tar` & `geofileops-0.8.2.tar`

### file list

```diff
@@ -1,43 +1,78 @@
-drwxrwxrwx   0        0        0        0 2024-01-12 21:21:57.072161 geofileops-0.8.1a0/
--rw-rw-rw-   0        0        0     1558 2022-12-03 18:13:01.000000 geofileops-0.8.1a0/LICENSE.txt
--rw-rw-rw-   0        0        0      289 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/MANIFEST.in
--rw-rw-rw-   0        0        0     3010 2024-01-12 21:21:57.478123 geofileops-0.8.1a0/PKG-INFO
--rw-rw-rw-   0        0        0     2554 2024-01-12 15:53:29.000000 geofileops-0.8.1a0/README.md
-drwxrwxrwx   0        0        0        0 2024-01-12 21:21:57.078170 geofileops-0.8.1a0/geofileops/
--rw-rw-rw-   0        0        0      817 2023-11-21 08:55:34.000000 geofileops-0.8.1a0/geofileops/__init__.py
--rw-rw-rw-   0        0        0      538 2024-01-12 10:23:36.000000 geofileops-0.8.1a0/geofileops/_compat.py
--rw-rw-rw-   0        0        0   101438 2024-01-12 10:24:30.000000 geofileops-0.8.1a0/geofileops/fileops.py
--rw-rw-rw-   0        0        0   136859 2024-01-12 15:53:29.000000 geofileops-0.8.1a0/geofileops/geoops.py
-drwxrwxrwx   0        0        0        0 2024-01-12 21:21:57.078170 geofileops-0.8.1a0/geofileops/helpers/
--rw-rw-rw-   0        0        0       89 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/geofileops/helpers/__init__.py
--rw-rw-rw-   0        0        0     3942 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/geofileops/helpers/_parameter_helper.py
--rw-rw-rw-   0        0        0     8047 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/geofileops/helpers/layerstyles.py
--rw-rw-rw-   0        0        0        0 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/geofileops/py.typed
-drwxrwxrwx   0        0        0        0 2024-01-12 21:21:57.082140 geofileops-0.8.1a0/geofileops/util/
--rw-rw-rw-   0        0        0       98 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/geofileops/util/__init__.py
--rw-rw-rw-   0        0        0     6232 2024-01-12 15:53:29.000000 geofileops-0.8.1a0/geofileops/util/_general_util.py
--rw-rw-rw-   0        0        0     9458 2023-11-08 11:11:57.000000 geofileops-0.8.1a0/geofileops/util/_geofileinfo.py
--rw-rw-rw-   0        0        0      867 2023-10-11 15:30:13.000000 geofileops-0.8.1a0/geofileops/util/_geometry_util.py
--rw-rw-rw-   0        0        0    92633 2024-01-12 15:53:29.000000 geofileops-0.8.1a0/geofileops/util/_geoops_gpd.py
--rw-rw-rw-   0        0        0     5079 2023-11-08 11:11:57.000000 geofileops-0.8.1a0/geofileops/util/_geoops_ogr.py
--rw-rw-rw-   0        0        0   139298 2024-01-12 10:25:04.000000 geofileops-0.8.1a0/geofileops/util/_geoops_sql.py
--rw-rw-rw-   0        0        0    11323 2023-11-08 11:11:57.000000 geofileops-0.8.1a0/geofileops/util/_geoseries_util.py
--rw-rw-rw-   0        0        0     4621 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/geofileops/util/_io_util.py
--rw-rw-rw-   0        0        0     7966 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/geofileops/util/_ogr_sql_util.py
--rw-rw-rw-   0        0        0    28113 2024-01-12 10:23:36.000000 geofileops-0.8.1a0/geofileops/util/_ogr_util.py
--rw-rw-rw-   0        0        0     5074 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/geofileops/util/_processing_util.py
--rw-rw-rw-   0        0        0    14129 2024-01-12 10:23:36.000000 geofileops-0.8.1a0/geofileops/util/_sqlite_userdefined.py
--rw-rw-rw-   0        0        0    28173 2024-01-12 10:23:36.000000 geofileops-0.8.1a0/geofileops/util/_sqlite_util.py
--rw-rw-rw-   0        0        0     1360 2023-11-07 17:37:11.000000 geofileops-0.8.1a0/geofileops/util/geodataframe_util.py
--rw-rw-rw-   0        0        0      675 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/geofileops/util/geofiletypes.csv
--rw-rw-rw-   0        0        0    98304 2022-12-03 18:13:01.000000 geofileops-0.8.1a0/geofileops/util/test.gpkg
--rw-rw-rw-   0        0        0        7 2024-01-12 19:05:51.000000 geofileops-0.8.1a0/geofileops/version.txt
-drwxrwxrwx   0        0        0        0 2024-01-12 21:21:57.075168 geofileops-0.8.1a0/geofileops.egg-info/
--rw-rw-rw-   0        0        0     3010 2024-01-12 21:21:56.000000 geofileops-0.8.1a0/geofileops.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     1010 2024-01-12 21:21:56.000000 geofileops-0.8.1a0/geofileops.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2024-01-12 21:21:56.000000 geofileops-0.8.1a0/geofileops.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0      150 2024-01-12 21:21:56.000000 geofileops-0.8.1a0/geofileops.egg-info/requires.txt
--rw-rw-rw-   0        0        0       11 2024-01-12 21:21:56.000000 geofileops-0.8.1a0/geofileops.egg-info/top_level.txt
--rw-rw-rw-   0        0        0     3843 2023-09-22 12:57:05.000000 geofileops-0.8.1a0/pyproject.toml
--rw-rw-rw-   0        0        0       42 2024-01-12 21:21:57.484199 geofileops-0.8.1a0/setup.cfg
--rw-rw-rw-   0        0        0     1159 2024-01-12 10:24:30.000000 geofileops-0.8.1a0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:23.001103 geofileops-0.8.2/
+-rw-r--r--   0 runner    (1001) docker     (127)     1529 2024-05-25 21:26:18.000000 geofileops-0.8.2/LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      280 2024-05-25 21:26:18.000000 geofileops-0.8.2/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (127)     3264 2024-05-25 21:26:23.001103 geofileops-0.8.2/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     2464 2024-05-25 21:26:18.000000 geofileops-0.8.2/README.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:22.989103 geofileops-0.8.2/benchmark/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:18.000000 geofileops-0.8.2/benchmark/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)       95 2024-05-25 21:26:18.000000 geofileops-0.8.2/benchmark/benchmark_all.py
+-rw-r--r--   0 runner    (1001) docker     (127)      485 2024-05-25 21:26:18.000000 geofileops-0.8.2/benchmark/benchmark_geofileops.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5034 2024-05-25 21:26:18.000000 geofileops-0.8.2/benchmark/benchmarker.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:22.989103 geofileops-0.8.2/benchmark/benchmarks/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:18.000000 geofileops-0.8.2/benchmark/benchmarks/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15726 2024-05-25 21:26:18.000000 geofileops-0.8.2/benchmark/benchmarks/benchmarks_geofileops.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7546 2024-05-25 21:26:18.000000 geofileops-0.8.2/benchmark/benchmarks/testdata.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9685 2024-05-25 21:26:18.000000 geofileops-0.8.2/benchmark/reporter.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:22.993103 geofileops-0.8.2/geofileops/
+-rw-r--r--   0 runner    (1001) docker     (127)      788 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      523 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/_compat.py
+-rw-r--r--   0 runner    (1001) docker     (127)    98835 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/fileops.py
+-rw-r--r--   0 runner    (1001) docker     (127)   134324 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/geoops.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:22.993103 geofileops-0.8.2/geofileops/helpers/
+-rw-r--r--   0 runner    (1001) docker     (127)       86 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/helpers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3842 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/helpers/_parameter_helper.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7816 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/helpers/layerstyles.py
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/py.typed
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:22.997104 geofileops-0.8.2/geofileops/util/
+-rw-r--r--   0 runner    (1001) docker     (127)       95 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6049 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_general_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9169 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_geofileinfo.py
+-rw-r--r--   0 runner    (1001) docker     (127)      823 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_geometry_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)    90180 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_geoops_gpd.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4912 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_geoops_ogr.py
+-rw-r--r--   0 runner    (1001) docker     (127)   137266 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_geoops_sql.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11039 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_geoseries_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4489 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_io_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7774 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_ogr_sql_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27269 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_ogr_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4929 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_processing_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13736 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_sqlite_userdefined.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27462 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/_sqlite_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1317 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/geodataframe_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)      670 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/geofiletypes.csv
+-rw-r--r--   0 runner    (1001) docker     (127)    98304 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/util/test.gpkg
+-rw-r--r--   0 runner    (1001) docker     (127)        5 2024-05-25 21:26:18.000000 geofileops-0.8.2/geofileops/version.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:23.001103 geofileops-0.8.2/geofileops.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)     3264 2024-05-25 21:26:22.000000 geofileops-0.8.2/geofileops.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     1926 2024-05-25 21:26:22.000000 geofileops-0.8.2/geofileops.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-25 21:26:22.000000 geofileops-0.8.2/geofileops.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      156 2024-05-25 21:26:22.000000 geofileops-0.8.2/geofileops.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       27 2024-05-25 21:26:22.000000 geofileops-0.8.2/geofileops.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     3655 2024-05-25 21:26:18.000000 geofileops-0.8.2/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (127)       38 2024-05-25 21:26:23.001103 geofileops-0.8.2/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (127)     1121 2024-05-25 21:26:18.000000 geofileops-0.8.2/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:23.001103 geofileops-0.8.2/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-25 21:26:18.000000 geofileops-0.8.2/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1087 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_general_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)    64248 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geofile.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4093 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geofileinfo.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38036 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geofileops_singlelayer.py
+-rw-r--r--   0 runner    (1001) docker     (127)    46309 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geofileops_singlelayer_gpd.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4923 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geofileops_singlelayer_ogr.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18497 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geofileops_singlelayer_sql.py
+-rw-r--r--   0 runner    (1001) docker     (127)    67660 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geofileops_twolayers.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1660 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geoops.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2417 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geoops_gpd.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2140 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geoops_sql.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10264 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_geoseries_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13513 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_helper.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1540 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_io_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1924 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_layerstyles.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4088 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_ogr_sql_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10145 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_ogr_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2519 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_parameter_helper.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1415 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_processing_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3746 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_spatialite.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7582 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_sqlite_userdefined.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7199 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_sqlite_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)      152 2024-05-25 21:26:19.000000 geofileops-0.8.2/tests/test_version.py
```

### Comparing `geofileops-0.8.1a0/LICENSE.txt` & `geofileops-0.8.2/LICENSE.txt`

 * *Files 26% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-BSD 3-Clause License
-
-Copyright (c) 2020-2021, Pieter Roggemans
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its
-   contributors may be used to endorse or promote products derived from
-   this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+BSD 3-Clause License
+
+Copyright (c) 2020-2024, Pieter Roggemans
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its
+   contributors may be used to endorse or promote products derived from
+   this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

### Comparing `geofileops-0.8.1a0/PKG-INFO` & `geofileops-0.8.2/README.md`

 * *Files 12% similar despite different names*

```diff
@@ -1,47 +1,38 @@
-Metadata-Version: 2.1
-Name: geofileops
-Version: 0.8.1a0
-Summary: Package to do spatial operations on large geo files.
-Home-page: https://github.com/geofileops/geofileops
-Author: Pieter Roggemans
-Author-email: pieter.roggemans@gmail.com
-Classifier: Programming Language :: Python :: 3
-Classifier: Operating System :: OS Independent
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Provides-Extra: full
-License-File: LICENSE.txt
-
-# geofileops 
-
-[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
-[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
-[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
-[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
-[![DOI](https://zenodo.org/badge/203202318.svg)](https://zenodo.org/doi/10.5281/zenodo.10340100)
-
-Geofileops aims to speed up spatial analysis on large/complex vector datasets.
-
-It provides an easy to use API that can accomplish a lot with few lines of code. Most
-typical GIS operations are available: e.g. 
-[buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer), 
-[dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
-[erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
-[intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection), 
-[union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),... 
-
-The spatial operations are tested on geopackage and shapefile input files, but geopackage is recommended as it will give better performance. General [layer](https://geofileops.readthedocs.io/en/stable/reference.html#general-layer-operations) and [file operations](https://geofileops.readthedocs.io/en/stable/reference.html#general-file-operations) can be used on the file formats supported by [GDAL](https://gdal.org/).
-
-The full documentation is available on [readthedocs](https://geofileops.readthedocs.io).
-
-## Performance
-
-Different techniques are used under the hood to be able to process large files as fast as possible:
-- process data in batches
-- subdivide/merge complex geometries on the fly
-- process data in different passes
-- use all available CPUs
-
-The following chart gives an impression of the speed improvement that can be expected when processing larger files. The [benchmarks](https://github.com/geofileops/geobenchmark) ran on a Windows PC with 12 cores and include I/O.
-
-![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
+# geofileops 
+
+[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
+[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
+[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
+[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
+[![DOI](https://zenodo.org/badge/203202318.svg)](https://zenodo.org/doi/10.5281/zenodo.10340100)
+
+Geofileops is a python toolbox to process large vector files faster.
+
+Most typical GIS operations are available: e.g.
+[buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer), 
+[dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
+[erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
+[intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection), 
+[union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),... 
+
+The spatial operations are tested on geopackage and shapefile input files, but
+geopackage is recommended as it will give better performance. General 
+[layer](https://geofileops.readthedocs.io/en/stable/reference.html#general-layer-operations)
+and [file operations](https://geofileops.readthedocs.io/en/stable/reference.html#general-file-operations) can be used on the file formats supported by 
+[GDAL](https://gdal.org/).
+
+The full documentation is available on [readthedocs](https://geofileops.readthedocs.io).
+
+Different techniques are used under the hood to be able to process large files as fast
+as possible:
+
+* process data in batches
+* subdivide/merge complex geometries on the fly
+* process data in different passes
+* use all available CPUs
+
+The following chart gives an impression of the speed improvement that can be expected
+when processing larger files. The [benchmarks](https://github.com/geofileops/geobenchmark)
+typically use input file(s) with 500K polygons, ran on a Windows PC with 12 cores and include I/O.
+
+![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
```

### Comparing `geofileops-0.8.1a0/README.md` & `geofileops-0.8.2/PKG-INFO`

 * *Files 24% similar despite different names*

```diff
@@ -1,33 +1,65 @@
-# geofileops 
-
-[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
-[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
-[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
-[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
-[![DOI](https://zenodo.org/badge/203202318.svg)](https://zenodo.org/doi/10.5281/zenodo.10340100)
-
-Geofileops aims to speed up spatial analysis on large/complex vector datasets.
-
-It provides an easy to use API that can accomplish a lot with few lines of code. Most
-typical GIS operations are available: e.g. 
-[buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer), 
-[dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
-[erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
-[intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection), 
-[union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),... 
-
-The spatial operations are tested on geopackage and shapefile input files, but geopackage is recommended as it will give better performance. General [layer](https://geofileops.readthedocs.io/en/stable/reference.html#general-layer-operations) and [file operations](https://geofileops.readthedocs.io/en/stable/reference.html#general-file-operations) can be used on the file formats supported by [GDAL](https://gdal.org/).
-
-The full documentation is available on [readthedocs](https://geofileops.readthedocs.io).
-
-## Performance
-
-Different techniques are used under the hood to be able to process large files as fast as possible:
-- process data in batches
-- subdivide/merge complex geometries on the fly
-- process data in different passes
-- use all available CPUs
-
-The following chart gives an impression of the speed improvement that can be expected when processing larger files. The [benchmarks](https://github.com/geofileops/geobenchmark) ran on a Windows PC with 12 cores and include I/O.
-
-![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
+Metadata-Version: 2.1
+Name: geofileops
+Version: 0.8.2
+Summary: Python toolbox to process large vector files faster.
+Home-page: https://github.com/geofileops/geofileops
+Author: Pieter Roggemans
+Author-email: pieter.roggemans@gmail.com
+Classifier: Programming Language :: Python :: 3
+Classifier: Operating System :: OS Independent
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+License-File: LICENSE.txt
+Requires-Dist: cloudpickle
+Requires-Dist: fiona
+Requires-Dist: gdal<=3.9,>=3.6
+Requires-Dist: geopandas<1,>=0.12
+Requires-Dist: numpy
+Requires-Dist: packaging
+Requires-Dist: pandas
+Requires-Dist: psutil
+Requires-Dist: pygeoops<0.5,>=0.4
+Requires-Dist: pyogrio
+Requires-Dist: pyproj
+Requires-Dist: shapely<2.1,>=2
+Provides-Extra: full
+Requires-Dist: simplification; extra == "full"
+
+# geofileops 
+
+[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
+[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
+[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
+[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
+[![DOI](https://zenodo.org/badge/203202318.svg)](https://zenodo.org/doi/10.5281/zenodo.10340100)
+
+Geofileops is a python toolbox to process large vector files faster.
+
+Most typical GIS operations are available: e.g.
+[buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer), 
+[dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
+[erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
+[intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection), 
+[union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),... 
+
+The spatial operations are tested on geopackage and shapefile input files, but
+geopackage is recommended as it will give better performance. General 
+[layer](https://geofileops.readthedocs.io/en/stable/reference.html#general-layer-operations)
+and [file operations](https://geofileops.readthedocs.io/en/stable/reference.html#general-file-operations) can be used on the file formats supported by 
+[GDAL](https://gdal.org/).
+
+The full documentation is available on [readthedocs](https://geofileops.readthedocs.io).
+
+Different techniques are used under the hood to be able to process large files as fast
+as possible:
+
+* process data in batches
+* subdivide/merge complex geometries on the fly
+* process data in different passes
+* use all available CPUs
+
+The following chart gives an impression of the speed improvement that can be expected
+when processing larger files. The [benchmarks](https://github.com/geofileops/geobenchmark)
+typically use input file(s) with 500K polygons, ran on a Windows PC with 12 cores and include I/O.
+
+![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
```

### Comparing `geofileops-0.8.1a0/geofileops/__init__.py` & `geofileops-0.8.2/geofileops/__init__.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-"""
-Library to make spatial operations on large geo files fast(er) and easy.
-"""
-
-from pathlib import Path
-import os
-
-# Import geopandas here so the warning about pygeos <> shapely2 is given, but set
-# USE_PYGEOS to avoid further warnings
-import geopandas._compat as gpd_compat
-
-if gpd_compat.USE_PYGEOS:
-    os.environ["USE_PYGEOS"] = "1"
-else:
-    os.environ["USE_PYGEOS"] = "0"
-
-from geofileops.fileops import *  # noqa: F403
-from geofileops.geoops import *  # noqa: F403
-from geofileops.helpers.layerstyles import *  # noqa: F403
-from geofileops.util._geofileinfo import get_driver  # noqa: F401
-
-
-def _get_version():
-    version_path = Path(__file__).resolve().parent / "version.txt"
-    with open(version_path) as file:
-        return file.readline()
-
-
-__version__ = _get_version()
+"""
+Library to make spatial operations on large geo files fast(er) and easy.
+"""
+
+from pathlib import Path
+import os
+
+# Import geopandas here so the warning about pygeos <> shapely2 is given, but set
+# USE_PYGEOS to avoid further warnings
+import geopandas._compat as gpd_compat
+
+if gpd_compat.USE_PYGEOS:
+    os.environ["USE_PYGEOS"] = "1"
+else:
+    os.environ["USE_PYGEOS"] = "0"
+
+from geofileops.fileops import *  # noqa: F403
+from geofileops.geoops import *  # noqa: F403
+from geofileops.helpers.layerstyles import *  # noqa: F403
+from geofileops.util._geofileinfo import get_driver  # noqa: F401
+
+
+def _get_version():
+    version_path = Path(__file__).resolve().parent / "version.txt"
+    with open(version_path) as file:
+        return file.readline()
+
+
+__version__ = _get_version()
```

### Comparing `geofileops-0.8.1a0/geofileops/fileops.py` & `geofileops-0.8.2/geofileops/fileops.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,6340 +1,6178 @@
-00000000: 2222 220d 0a4d 6f64 756c 6520 7769 7468  """..Module with
-00000010: 2068 656c 7065 7220 6675 6e63 7469 6f6e   helper function
-00000020: 7320 666f 7220 6765 6f20 6669 6c65 732e  s for geo files.
-00000030: 0d0a 2222 220d 0a0d 0a69 6d70 6f72 7420  .."""....import 
-00000040: 656e 756d 0d0a 696d 706f 7274 2064 6174  enum..import dat
-00000050: 6574 696d 650d 0a69 6d70 6f72 7420 6669  etime..import fi
-00000060: 6c65 636d 700d 0a69 6d70 6f72 7420 6c6f  lecmp..import lo
-00000070: 6767 696e 670d 0a69 6d70 6f72 7420 6f73  gging..import os
-00000080: 0d0a 6672 6f6d 2070 6174 686c 6962 2069  ..from pathlib i
-00000090: 6d70 6f72 7420 5061 7468 0d0a 696d 706f  mport Path..impo
-000000a0: 7274 2070 7072 696e 740d 0a69 6d70 6f72  rt pprint..impor
-000000b0: 7420 7368 7574 696c 0d0a 696d 706f 7274  t shutil..import
-000000c0: 2073 7472 696e 670d 0a69 6d70 6f72 7420   string..import 
-000000d0: 7465 6d70 6669 6c65 0d0a 696d 706f 7274  tempfile..import
-000000e0: 2074 696d 650d 0a66 726f 6d20 7479 7069   time..from typi
-000000f0: 6e67 2069 6d70 6f72 7420 416e 792c 2044  ng import Any, D
-00000100: 6963 742c 2049 7465 7261 626c 652c 204c  ict, Iterable, L
-00000110: 6973 742c 204c 6974 6572 616c 2c20 4f70  ist, Literal, Op
-00000120: 7469 6f6e 616c 2c20 5475 706c 652c 2055  tional, Tuple, U
-00000130: 6e69 6f6e 0d0a 696d 706f 7274 2077 6172  nion..import war
-00000140: 6e69 6e67 730d 0a0d 0a69 6d70 6f72 7420  nings....import 
-00000150: 6669 6f6e 610d 0a69 6d70 6f72 7420 6765  fiona..import ge
-00000160: 6f70 616e 6461 7320 6173 2067 7064 0d0a  opandas as gpd..
-00000170: 6672 6f6d 2067 656f 7061 6e64 6173 2e69  from geopandas.i
-00000180: 6f20 696d 706f 7274 2066 696c 6520 6173  o import file as
-00000190: 2067 7064 5f69 6f5f 6669 6c65 0d0a 696d   gpd_io_file..im
-000001a0: 706f 7274 206e 756d 7079 2061 7320 6e70  port numpy as np
-000001b0: 0d0a 6672 6f6d 206f 7367 656f 2069 6d70  ..from osgeo imp
-000001c0: 6f72 7420 6764 616c 0d0a 696d 706f 7274  ort gdal..import
-000001d0: 2070 616e 6461 7320 6173 2070 640d 0a66   pandas as pd..f
-000001e0: 726f 6d20 7061 6e64 6173 2e61 7069 2e74  rom pandas.api.t
-000001f0: 7970 6573 2069 6d70 6f72 7420 6973 5f69  ypes import is_i
-00000200: 6e74 6567 6572 5f64 7479 7065 0d0a 6672  nteger_dtype..fr
-00000210: 6f6d 2070 7967 656f 6f70 7320 696d 706f  om pygeoops impo
-00000220: 7274 2047 656f 6d65 7472 7954 7970 652c  rt GeometryType,
-00000230: 2050 7269 6d69 7469 7665 5479 7065 2020   PrimitiveType  
-00000240: 2320 6e6f 7161 3a20 4634 3031 0d0a 696d  # noqa: F401..im
-00000250: 706f 7274 2070 796f 6772 696f 0d0a 696d  port pyogrio..im
-00000260: 706f 7274 2070 7970 726f 6a0d 0a0d 0a66  port pyproj....f
-00000270: 726f 6d20 6765 6f66 696c 656f 7073 2e75  rom geofileops.u
-00000280: 7469 6c20 696d 706f 7274 205f 6765 6f66  til import _geof
-00000290: 696c 6569 6e66 6f0d 0a66 726f 6d20 6765  ileinfo..from ge
-000002a0: 6f66 696c 656f 7073 2e75 7469 6c20 696d  ofileops.util im
-000002b0: 706f 7274 205f 6765 6f73 6572 6965 735f  port _geoseries_
-000002c0: 7574 696c 0d0a 6672 6f6d 2067 656f 6669  util..from geofi
-000002d0: 6c65 6f70 732e 7574 696c 2069 6d70 6f72  leops.util impor
-000002e0: 7420 5f69 6f5f 7574 696c 0d0a 6672 6f6d  t _io_util..from
-000002f0: 2067 656f 6669 6c65 6f70 732e 7574 696c   geofileops.util
-00000300: 2069 6d70 6f72 7420 5f6f 6772 5f75 7469   import _ogr_uti
-00000310: 6c0d 0a66 726f 6d20 6765 6f66 696c 656f  l..from geofileo
-00000320: 7073 2e75 7469 6c20 696d 706f 7274 205f  ps.util import _
-00000330: 6f67 725f 7371 6c5f 7574 696c 0d0a 0d0a  ogr_sql_util....
+00000000: 2222 220a 4d6f 6475 6c65 2077 6974 6820  """.Module with 
+00000010: 6865 6c70 6572 2066 756e 6374 696f 6e73  helper functions
+00000020: 2066 6f72 2067 656f 2066 696c 6573 2e0a   for geo files..
+00000030: 2222 220a 0a69 6d70 6f72 7420 656e 756d  """..import enum
+00000040: 0a69 6d70 6f72 7420 6461 7465 7469 6d65  .import datetime
+00000050: 0a69 6d70 6f72 7420 6669 6c65 636d 700a  .import filecmp.
+00000060: 696d 706f 7274 206c 6f67 6769 6e67 0a69  import logging.i
+00000070: 6d70 6f72 7420 6f73 0a66 726f 6d20 7061  mport os.from pa
+00000080: 7468 6c69 6220 696d 706f 7274 2050 6174  thlib import Pat
+00000090: 680a 696d 706f 7274 2070 7072 696e 740a  h.import pprint.
+000000a0: 696d 706f 7274 2073 6875 7469 6c0a 696d  import shutil.im
+000000b0: 706f 7274 2073 7472 696e 670a 696d 706f  port string.impo
+000000c0: 7274 2074 656d 7066 696c 650a 696d 706f  rt tempfile.impo
+000000d0: 7274 2074 696d 650a 6672 6f6d 2074 7970  rt time.from typ
+000000e0: 696e 6720 696d 706f 7274 2041 6e79 2c20  ing import Any, 
+000000f0: 4469 6374 2c20 4974 6572 6162 6c65 2c20  Dict, Iterable, 
+00000100: 4c69 7374 2c20 4c69 7465 7261 6c2c 204f  List, Literal, O
+00000110: 7074 696f 6e61 6c2c 2054 7570 6c65 2c20  ptional, Tuple, 
+00000120: 556e 696f 6e0a 696d 706f 7274 2077 6172  Union.import war
+00000130: 6e69 6e67 730a 0a69 6d70 6f72 7420 6669  nings..import fi
+00000140: 6f6e 610a 696d 706f 7274 2067 656f 7061  ona.import geopa
+00000150: 6e64 6173 2061 7320 6770 640a 6672 6f6d  ndas as gpd.from
+00000160: 2067 656f 7061 6e64 6173 2e69 6f20 696d   geopandas.io im
+00000170: 706f 7274 2066 696c 6520 6173 2067 7064  port file as gpd
+00000180: 5f69 6f5f 6669 6c65 0a69 6d70 6f72 7420  _io_file.import 
+00000190: 6e75 6d70 7920 6173 206e 700a 6672 6f6d  numpy as np.from
+000001a0: 206f 7367 656f 2069 6d70 6f72 7420 6764   osgeo import gd
+000001b0: 616c 0a69 6d70 6f72 7420 7061 6e64 6173  al.import pandas
+000001c0: 2061 7320 7064 0a66 726f 6d20 7061 6e64   as pd.from pand
+000001d0: 6173 2e61 7069 2e74 7970 6573 2069 6d70  as.api.types imp
+000001e0: 6f72 7420 6973 5f69 6e74 6567 6572 5f64  ort is_integer_d
+000001f0: 7479 7065 0a66 726f 6d20 7079 6765 6f6f  type.from pygeoo
+00000200: 7073 2069 6d70 6f72 7420 4765 6f6d 6574  ps import Geomet
+00000210: 7279 5479 7065 2c20 5072 696d 6974 6976  ryType, Primitiv
+00000220: 6554 7970 6520 2023 206e 6f71 613a 2046  eType  # noqa: F
+00000230: 3430 310a 696d 706f 7274 2070 796f 6772  401.import pyogr
+00000240: 696f 0a69 6d70 6f72 7420 7079 7072 6f6a  io.import pyproj
+00000250: 0a0a 6672 6f6d 2067 656f 6669 6c65 6f70  ..from geofileop
+00000260: 732e 7574 696c 2069 6d70 6f72 7420 5f67  s.util import _g
+00000270: 656f 6669 6c65 696e 666f 0a66 726f 6d20  eofileinfo.from 
+00000280: 6765 6f66 696c 656f 7073 2e75 7469 6c20  geofileops.util 
+00000290: 696d 706f 7274 205f 6765 6f73 6572 6965  import _geoserie
+000002a0: 735f 7574 696c 0a66 726f 6d20 6765 6f66  s_util.from geof
+000002b0: 696c 656f 7073 2e75 7469 6c20 696d 706f  ileops.util impo
+000002c0: 7274 205f 696f 5f75 7469 6c0a 6672 6f6d  rt _io_util.from
+000002d0: 2067 656f 6669 6c65 6f70 732e 7574 696c   geofileops.util
+000002e0: 2069 6d70 6f72 7420 5f6f 6772 5f75 7469   import _ogr_uti
+000002f0: 6c0a 6672 6f6d 2067 656f 6669 6c65 6f70  l.from geofileop
+00000300: 732e 7574 696c 2069 6d70 6f72 7420 5f6f  s.util import _o
+00000310: 6772 5f73 716c 5f75 7469 6c0a 0a23 2323  gr_sql_util..###
+00000320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000330: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000340: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000350: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000360: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000370: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000380: 2323 2323 230d 0a23 2046 6972 7374 2064  #####..# First d
-00000390: 6566 696e 652f 696e 6974 2073 6f6d 6520  efine/init some 
-000003a0: 6765 6e65 7261 6c20 7661 7269 6162 6c65  general variable
-000003b0: 732f 636f 6e73 7461 6e74 730d 0a23 2323  s/constants..###
+00000360: 2323 0a23 2046 6972 7374 2064 6566 696e  ##.# First defin
+00000370: 652f 696e 6974 2073 6f6d 6520 6765 6e65  e/init some gene
+00000380: 7261 6c20 7661 7269 6162 6c65 732f 636f  ral variables/co
+00000390: 6e73 7461 6e74 730a 2323 2323 2323 2323  nstants.########
+000003a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000003b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000003c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000003d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000003e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000003f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000400: 2323 0d0a 0d0a 2320 4765 7420 6120 6c6f  ##....# Get a lo
-00000410: 6767 6572 2e2e 2e0d 0a6c 6f67 6765 7220  gger.....logger 
-00000420: 3d20 6c6f 6767 696e 672e 6765 744c 6f67  = logging.getLog
-00000430: 6765 7228 5f5f 6e61 6d65 5f5f 290d 0a23  ger(__name__)..#
-00000440: 206c 6f67 6765 722e 7365 744c 6576 656c   logger.setLevel
-00000450: 286c 6f67 6769 6e67 2e44 4542 5547 290d  (logging.DEBUG).
-00000460: 0a0d 0a23 2045 6e61 626c 6520 6578 6365  ...# Enable exce
-00000470: 7074 696f 6e73 2066 6f72 2047 4441 4c0d  ptions for GDAL.
-00000480: 0a67 6461 6c2e 5573 6545 7863 6570 7469  .gdal.UseExcepti
-00000490: 6f6e 7328 290d 0a67 6461 6c2e 6f67 722e  ons()..gdal.ogr.
-000004a0: 5573 6545 7863 6570 7469 6f6e 7328 290d  UseExceptions().
-000004b0: 0a0d 0a23 2044 6973 6162 6c65 2074 6869  ...# Disable thi
-000004c0: 7320 7761 726e 696e 6720 696e 2066 696f  s warning in fio
-000004d0: 6e61 0d0a 7761 726e 696e 6773 2e66 696c  na..warnings.fil
-000004e0: 7465 7277 6172 6e69 6e67 7328 0d0a 2020  terwarnings(..  
-000004f0: 2020 6163 7469 6f6e 3d22 6967 6e6f 7265    action="ignore
-00000500: 222c 0d0a 2020 2020 6361 7465 676f 7279  ",..    category
-00000510: 3d52 756e 7469 6d65 5761 726e 696e 672c  =RuntimeWarning,
-00000520: 0d0a 2020 2020 6d65 7373 6167 653d 280d  ..    message=(.
-00000530: 0a20 2020 2020 2020 2022 5e53 6571 7565  .        "^Seque
-00000540: 6e74 6961 6c20 7265 6164 206f 6620 6974  ntial read of it
-00000550: 6572 6174 6f72 2077 6173 2069 6e74 6572  erator was inter
-00000560: 7275 7074 6564 2e20 5265 7365 7474 696e  rupted. Resettin
-00000570: 6720 6974 6572 6174 6f72 2e20 220d 0a20  g iterator. ".. 
-00000580: 2020 2020 2020 2022 5468 6973 2063 616e         "This can
-00000590: 206e 6567 6174 6976 656c 7920 696d 7061   negatively impa
-000005a0: 6374 2074 6865 2070 6572 666f 726d 616e  ct the performan
-000005b0: 6365 2e24 220d 0a20 2020 2029 2c0d 0a29  ce.$"..    ),..)
-000005c0: 0d0a 0d0a 2320 4469 7361 626c 6520 7468  ....# Disable th
-000005d0: 6973 2077 6172 6e69 6e67 2069 6e20 7079  is warning in py
-000005e0: 6f67 7269 6f0d 0a77 6172 6e69 6e67 732e  ogrio..warnings.
-000005f0: 6669 6c74 6572 7761 726e 696e 6773 280d  filterwarnings(.
-00000600: 0a20 2020 2061 6374 696f 6e3d 2269 676e  .    action="ign
-00000610: 6f72 6522 2c0d 0a20 2020 2063 6174 6567  ore",..    categ
-00000620: 6f72 793d 5573 6572 5761 726e 696e 672c  ory=UserWarning,
-00000630: 0d0a 2020 2020 6d65 7373 6167 653d 225e  ..    message="^
-00000640: 4c61 7965 7220 2e2a 2064 6f65 7320 6e6f  Layer .* does no
-00000650: 7420 6861 7665 2061 6e79 2066 6561 7475  t have any featu
-00000660: 7265 7320 746f 2072 6561 6424 222c 0d0a  res to read$",..
-00000670: 290d 0a23 2053 6574 206c 6f67 6769 6e67  )..# Set logging
-00000680: 206c 6576 656c 2066 6f72 2070 796f 6772   level for pyogr
-00000690: 696f 2074 6f20 7761 726e 696e 670d 0a70  io to warning..p
-000006a0: 796f 6772 696f 5f6c 6f67 6765 7220 3d20  yogrio_logger = 
-000006b0: 6c6f 6767 696e 672e 6765 744c 6f67 6765  logging.getLogge
-000006c0: 7228 2270 796f 6772 696f 2229 0d0a 7079  r("pyogrio")..py
-000006d0: 6f67 7269 6f5f 6c6f 6767 6572 2e73 6574  ogrio_logger.set
-000006e0: 4c65 7665 6c28 6c6f 6767 696e 672e 5741  Level(logging.WA
-000006f0: 524e 494e 4729 0d0a 0d0a 2320 4861 7264  RNING)....# Hard
-00000700: 636f 6465 6420 3331 3337 3020 7072 6a20  coded 31370 prj 
-00000710: 7374 7269 6e67 2074 6f20 7265 706c 6163  string to replac
-00000720: 6520 6661 756c 7479 206f 6e65 730d 0a50  e faulty ones..P
-00000730: 524a 5f45 5053 475f 3331 3337 3020 3d20  RJ_EPSG_31370 = 
-00000740: 280d 0a20 2020 2027 5052 4f4a 4353 5b22  (..    'PROJCS["
-00000750: 4265 6c67 655f 3139 3732 5f42 656c 6769  Belge_1972_Belgi
-00000760: 616e 5f4c 616d 6265 7274 5f37 3222 2c27  an_Lambert_72",'
-00000770: 0d0a 2020 2020 2747 454f 4743 535b 2242  ..    'GEOGCS["B
-00000780: 656c 6765 2031 3937 3222 2c27 0d0a 2020  elge 1972",'..  
-00000790: 2020 2744 4154 554d 5b22 445f 4265 6c67    'DATUM["D_Belg
-000007a0: 655f 3139 3732 222c 5350 4845 524f 4944  e_1972",SPHEROID
-000007b0: 5b22 496e 7465 726e 6174 696f 6e61 6c5f  ["International_
-000007c0: 3139 3234 222c 3633 3738 3338 382c 3239  1924",6378388,29
-000007d0: 375d 5d2c 270d 0a20 2020 2027 5052 494d  7]],'..    'PRIM
-000007e0: 454d 5b22 4772 6565 6e77 6963 6822 2c30  EM["Greenwich",0
-000007f0: 5d2c 270d 0a20 2020 2027 554e 4954 5b22  ],'..    'UNIT["
-00000800: 4465 6772 6565 222c 302e 3031 3734 3533  Degree",0.017453
-00000810: 3239 3235 3139 3934 3332 3935 5d27 0d0a  292519943295]'..
-00000820: 2020 2020 225d 2c22 0d0a 2020 2020 2750      "],"..    'P
-00000830: 524f 4a45 4354 494f 4e5b 224c 616d 6265  ROJECTION["Lambe
-00000840: 7274 5f43 6f6e 666f 726d 616c 5f43 6f6e  rt_Conformal_Con
-00000850: 6963 225d 2c27 0d0a 2020 2020 2750 4152  ic"],'..    'PAR
-00000860: 414d 4554 4552 5b22 7374 616e 6461 7264  AMETER["standard
-00000870: 5f70 6172 616c 6c65 6c5f 3122 2c35 312e  _parallel_1",51.
-00000880: 3136 3636 3637 3233 3333 3333 3333 5d2c  16666723333333],
-00000890: 270d 0a20 2020 2027 5041 5241 4d45 5445  '..    'PARAMETE
-000008a0: 525b 2273 7461 6e64 6172 645f 7061 7261  R["standard_para
-000008b0: 6c6c 656c 5f32 222c 3439 2e38 3333 3333  llel_2",49.83333
-000008c0: 3339 5d2c 270d 0a20 2020 2027 5041 5241  39],'..    'PARA
-000008d0: 4d45 5445 525b 226c 6174 6974 7564 655f  METER["latitude_
-000008e0: 6f66 5f6f 7269 6769 6e22 2c39 305d 2c27  of_origin",90],'
-000008f0: 0d0a 2020 2020 2750 4152 414d 4554 4552  ..    'PARAMETER
-00000900: 5b22 6365 6e74 7261 6c5f 6d65 7269 6469  ["central_meridi
-00000910: 616e 222c 342e 3336 3734 3836 3636 3636  an",4.3674866666
-00000920: 3636 3636 365d 2c27 0d0a 2020 2020 2750  66666],'..    'P
-00000930: 4152 414d 4554 4552 5b22 6661 6c73 655f  ARAMETER["false_
-00000940: 6561 7374 696e 6722 2c31 3530 3030 302e  easting",150000.
-00000950: 3031 335d 2c27 0d0a 2020 2020 2750 4152  013],'..    'PAR
-00000960: 414d 4554 4552 5b22 6661 6c73 655f 6e6f  AMETER["false_no
-00000970: 7274 6869 6e67 222c 3534 3030 3038 382e  rthing",5400088.
-00000980: 3433 385d 2c27 0d0a 2020 2020 2755 4e49  438],'..    'UNI
-00000990: 545b 224d 6574 6572 222c 315d 2c27 0d0a  T["Meter",1],'..
-000009a0: 2020 2020 2741 5554 484f 5249 5459 5b22      'AUTHORITY["
-000009b0: 4550 5347 222c 3331 3337 305d 270d 0a20  EPSG",31370]'.. 
-000009c0: 2020 2022 5d22 0d0a 290d 0a0d 0a23 2323     "]"..)....###
+000003d0: 2323 2323 2323 2323 2323 2323 230a 0a23  #############..#
+000003e0: 2047 6574 2061 206c 6f67 6765 722e 2e2e   Get a logger...
+000003f0: 0a6c 6f67 6765 7220 3d20 6c6f 6767 696e  .logger = loggin
+00000400: 672e 6765 744c 6f67 6765 7228 5f5f 6e61  g.getLogger(__na
+00000410: 6d65 5f5f 290a 2320 6c6f 6767 6572 2e73  me__).# logger.s
+00000420: 6574 4c65 7665 6c28 6c6f 6767 696e 672e  etLevel(logging.
+00000430: 4445 4255 4729 0a0a 2320 456e 6162 6c65  DEBUG)..# Enable
+00000440: 2065 7863 6570 7469 6f6e 7320 666f 7220   exceptions for 
+00000450: 4744 414c 0a67 6461 6c2e 5573 6545 7863  GDAL.gdal.UseExc
+00000460: 6570 7469 6f6e 7328 290a 6764 616c 2e6f  eptions().gdal.o
+00000470: 6772 2e55 7365 4578 6365 7074 696f 6e73  gr.UseExceptions
+00000480: 2829 0a0a 2320 4469 7361 626c 6520 7468  ()..# Disable th
+00000490: 6973 2077 6172 6e69 6e67 2069 6e20 6669  is warning in fi
+000004a0: 6f6e 610a 7761 726e 696e 6773 2e66 696c  ona.warnings.fil
+000004b0: 7465 7277 6172 6e69 6e67 7328 0a20 2020  terwarnings(.   
+000004c0: 2061 6374 696f 6e3d 2269 676e 6f72 6522   action="ignore"
+000004d0: 2c0a 2020 2020 6361 7465 676f 7279 3d52  ,.    category=R
+000004e0: 756e 7469 6d65 5761 726e 696e 672c 0a20  untimeWarning,. 
+000004f0: 2020 206d 6573 7361 6765 3d28 0a20 2020     message=(.   
+00000500: 2020 2020 2022 5e53 6571 7565 6e74 6961       "^Sequentia
+00000510: 6c20 7265 6164 206f 6620 6974 6572 6174  l read of iterat
+00000520: 6f72 2077 6173 2069 6e74 6572 7275 7074  or was interrupt
+00000530: 6564 2e20 5265 7365 7474 696e 6720 6974  ed. Resetting it
+00000540: 6572 6174 6f72 2e20 220a 2020 2020 2020  erator. ".      
+00000550: 2020 2254 6869 7320 6361 6e20 6e65 6761    "This can nega
+00000560: 7469 7665 6c79 2069 6d70 6163 7420 7468  tively impact th
+00000570: 6520 7065 7266 6f72 6d61 6e63 652e 2422  e performance.$"
+00000580: 0a20 2020 2029 2c0a 290a 0a23 2044 6973  .    ),.)..# Dis
+00000590: 6162 6c65 2074 6869 7320 7761 726e 696e  able this warnin
+000005a0: 6720 696e 2070 796f 6772 696f 0a77 6172  g in pyogrio.war
+000005b0: 6e69 6e67 732e 6669 6c74 6572 7761 726e  nings.filterwarn
+000005c0: 696e 6773 280a 2020 2020 6163 7469 6f6e  ings(.    action
+000005d0: 3d22 6967 6e6f 7265 222c 0a20 2020 2063  ="ignore",.    c
+000005e0: 6174 6567 6f72 793d 5573 6572 5761 726e  ategory=UserWarn
+000005f0: 696e 672c 0a20 2020 206d 6573 7361 6765  ing,.    message
+00000600: 3d22 5e4c 6179 6572 202e 2a20 646f 6573  ="^Layer .* does
+00000610: 206e 6f74 2068 6176 6520 616e 7920 6665   not have any fe
+00000620: 6174 7572 6573 2074 6f20 7265 6164 2422  atures to read$"
+00000630: 2c0a 290a 2320 5365 7420 6c6f 6767 696e  ,.).# Set loggin
+00000640: 6720 6c65 7665 6c20 666f 7220 7079 6f67  g level for pyog
+00000650: 7269 6f20 746f 2077 6172 6e69 6e67 0a70  rio to warning.p
+00000660: 796f 6772 696f 5f6c 6f67 6765 7220 3d20  yogrio_logger = 
+00000670: 6c6f 6767 696e 672e 6765 744c 6f67 6765  logging.getLogge
+00000680: 7228 2270 796f 6772 696f 2229 0a70 796f  r("pyogrio").pyo
+00000690: 6772 696f 5f6c 6f67 6765 722e 7365 744c  grio_logger.setL
+000006a0: 6576 656c 286c 6f67 6769 6e67 2e57 4152  evel(logging.WAR
+000006b0: 4e49 4e47 290a 0a23 2048 6172 6463 6f64  NING)..# Hardcod
+000006c0: 6564 2033 3133 3730 2070 726a 2073 7472  ed 31370 prj str
+000006d0: 696e 6720 746f 2072 6570 6c61 6365 2066  ing to replace f
+000006e0: 6175 6c74 7920 6f6e 6573 0a50 524a 5f45  aulty ones.PRJ_E
+000006f0: 5053 475f 3331 3337 3020 3d20 280a 2020  PSG_31370 = (.  
+00000700: 2020 2750 524f 4a43 535b 2242 656c 6765    'PROJCS["Belge
+00000710: 5f31 3937 325f 4265 6c67 6961 6e5f 4c61  _1972_Belgian_La
+00000720: 6d62 6572 745f 3732 222c 270a 2020 2020  mbert_72",'.    
+00000730: 2747 454f 4743 535b 2242 656c 6765 2031  'GEOGCS["Belge 1
+00000740: 3937 3222 2c27 0a20 2020 2027 4441 5455  972",'.    'DATU
+00000750: 4d5b 2244 5f42 656c 6765 5f31 3937 3222  M["D_Belge_1972"
+00000760: 2c53 5048 4552 4f49 445b 2249 6e74 6572  ,SPHEROID["Inter
+00000770: 6e61 7469 6f6e 616c 5f31 3932 3422 2c36  national_1924",6
+00000780: 3337 3833 3838 2c32 3937 5d5d 2c27 0a20  378388,297]],'. 
+00000790: 2020 2027 5052 494d 454d 5b22 4772 6565     'PRIMEM["Gree
+000007a0: 6e77 6963 6822 2c30 5d2c 270a 2020 2020  nwich",0],'.    
+000007b0: 2755 4e49 545b 2244 6567 7265 6522 2c30  'UNIT["Degree",0
+000007c0: 2e30 3137 3435 3332 3932 3531 3939 3433  .017453292519943
+000007d0: 3239 355d 270a 2020 2020 225d 2c22 0a20  295]'.    "],". 
+000007e0: 2020 2027 5052 4f4a 4543 5449 4f4e 5b22     'PROJECTION["
+000007f0: 4c61 6d62 6572 745f 436f 6e66 6f72 6d61  Lambert_Conforma
+00000800: 6c5f 436f 6e69 6322 5d2c 270a 2020 2020  l_Conic"],'.    
+00000810: 2750 4152 414d 4554 4552 5b22 7374 616e  'PARAMETER["stan
+00000820: 6461 7264 5f70 6172 616c 6c65 6c5f 3122  dard_parallel_1"
+00000830: 2c35 312e 3136 3636 3637 3233 3333 3333  ,51.166667233333
+00000840: 3333 5d2c 270a 2020 2020 2750 4152 414d  33],'.    'PARAM
+00000850: 4554 4552 5b22 7374 616e 6461 7264 5f70  ETER["standard_p
+00000860: 6172 616c 6c65 6c5f 3222 2c34 392e 3833  arallel_2",49.83
+00000870: 3333 3333 395d 2c27 0a20 2020 2027 5041  33339],'.    'PA
+00000880: 5241 4d45 5445 525b 226c 6174 6974 7564  RAMETER["latitud
+00000890: 655f 6f66 5f6f 7269 6769 6e22 2c39 305d  e_of_origin",90]
+000008a0: 2c27 0a20 2020 2027 5041 5241 4d45 5445  ,'.    'PARAMETE
+000008b0: 525b 2263 656e 7472 616c 5f6d 6572 6964  R["central_merid
+000008c0: 6961 6e22 2c34 2e33 3637 3438 3636 3636  ian",4.367486666
+000008d0: 3636 3636 3636 5d2c 270a 2020 2020 2750  666666],'.    'P
+000008e0: 4152 414d 4554 4552 5b22 6661 6c73 655f  ARAMETER["false_
+000008f0: 6561 7374 696e 6722 2c31 3530 3030 302e  easting",150000.
+00000900: 3031 335d 2c27 0a20 2020 2027 5041 5241  013],'.    'PARA
+00000910: 4d45 5445 525b 2266 616c 7365 5f6e 6f72  METER["false_nor
+00000920: 7468 696e 6722 2c35 3430 3030 3838 2e34  thing",5400088.4
+00000930: 3338 5d2c 270a 2020 2020 2755 4e49 545b  38],'.    'UNIT[
+00000940: 224d 6574 6572 222c 315d 2c27 0a20 2020  "Meter",1],'.   
+00000950: 2027 4155 5448 4f52 4954 595b 2245 5053   'AUTHORITY["EPS
+00000960: 4722 2c33 3133 3730 5d27 0a20 2020 2022  G",31370]'.    "
+00000970: 5d22 0a29 0a0a 2323 2323 2323 2323 2323  ]".)..##########
+00000980: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000990: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000009a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000009b0: 2323 2323 2323 2323 2323 230a 2320 5468  ###########.# Th
+000009c0: 6520 7265 616c 2077 6f72 6b0a 2323 2323  e real work.####
 000009d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000009e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000009f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000a00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a10: 2323 0d0a 2320 5468 6520 7265 616c 2077  ##..# The real w
-00000a20: 6f72 6b0d 0a23 2323 2323 2323 2323 2323  ork..###########
-00000a30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a60: 2323 2323 2323 2323 2323 0d0a 0d0a 0d0a  ##########......
-00000a70: 6465 6620 6c69 7374 6c61 7965 7273 280d  def listlayers(.
-00000a80: 0a20 2020 2070 6174 683a 2055 6e69 6f6e  .    path: Union
-00000a90: 5b73 7472 2c20 226f 732e 5061 7468 4c69  [str, "os.PathLi
-00000aa0: 6b65 5b41 6e79 5d22 5d2c 0d0a 2020 2020  ke[Any]"],..    
-00000ab0: 6f6e 6c79 5f73 7061 7469 616c 5f6c 6179  only_spatial_lay
-00000ac0: 6572 733a 2062 6f6f 6c20 3d20 5472 7565  ers: bool = True
-00000ad0: 2c0d 0a29 202d 3e20 4c69 7374 5b73 7472  ,..) -> List[str
-00000ae0: 5d3a 0d0a 2020 2020 2222 220d 0a20 2020  ]:..    """..   
-00000af0: 2047 6574 2074 6865 206c 6973 7420 6f66   Get the list of
-00000b00: 206c 6179 6572 7320 696e 2061 2067 656f   layers in a geo
-00000b10: 6669 6c65 2e0d 0a0d 0a20 2020 2041 7267  file.....    Arg
-00000b20: 733a 0d0a 2020 2020 2020 2020 7061 7468  s:..        path
-00000b30: 2028 5061 7468 4c69 6b65 293a 2070 6174   (PathLike): pat
-00000b40: 6820 746f 2074 6865 2066 696c 6520 746f  h to the file to
-00000b50: 2067 6574 2069 6e66 6f20 6162 6f75 740d   get info about.
-00000b60: 0a20 2020 2020 2020 206f 6e6c 795f 7370  .        only_sp
-00000b70: 6174 6961 6c5f 6c61 7965 7273 2028 626f  atial_layers (bo
-00000b80: 6f6c 2c20 6f70 7469 6f6e 616c 293a 2054  ol, optional): T
-00000b90: 7275 6520 746f 206f 6e6c 7920 6c69 7374  rue to only list
-00000ba0: 2073 7061 7469 616c 206c 6179 6572 732e   spatial layers.
-00000bb0: 0d0a 2020 2020 2020 2020 2020 2020 4661  ..            Fa
-00000bc0: 6c73 6520 746f 206c 6973 7420 616c 6c20  lse to list all 
-00000bd0: 7461 626c 6573 2e0d 0a0d 0a20 2020 2052  tables.....    R
-00000be0: 6574 7572 6e73 3a0d 0a20 2020 2020 2020  eturns:..       
-00000bf0: 204c 6973 745b 7374 725d 3a20 7468 6520   List[str]: the 
-00000c00: 6c69 7374 206f 6620 6c61 7965 7273 0d0a  list of layers..
-00000c10: 2020 2020 2222 220d 0a20 2020 2070 6174      """..    pat
-00000c20: 6820 3d20 5061 7468 2870 6174 6829 0d0a  h = Path(path)..
-00000c30: 2020 2020 6966 2070 6174 682e 7375 6666      if path.suff
-00000c40: 6978 2e6c 6f77 6572 2829 203d 3d20 222e  ix.lower() == ".
-00000c50: 7368 7022 3a0d 0a20 2020 2020 2020 2072  shp":..        r
-00000c60: 6574 7572 6e20 5b70 6174 682e 7374 656d  eturn [path.stem
-00000c70: 5d0d 0a0d 0a20 2020 2064 6174 6173 6f75  ]....    datasou
-00000c80: 7263 6520 3d20 4e6f 6e65 0d0a 2020 2020  rce = None..    
-00000c90: 6c61 7965 7273 203d 205b 5d0d 0a20 2020  layers = []..   
-00000ca0: 2074 7279 3a0d 0a20 2020 2020 2020 2064   try:..        d
-00000cb0: 6174 6173 6f75 7263 6520 3d20 6764 616c  atasource = gdal
-00000cc0: 2e4f 7065 6e45 7828 0d0a 2020 2020 2020  .OpenEx(..      
-00000cd0: 2020 2020 2020 7374 7228 7061 7468 292c        str(path),
-00000ce0: 206e 4f70 656e 466c 6167 733d 6764 616c   nOpenFlags=gdal
-00000cf0: 2e4f 465f 5645 4354 4f52 207c 2067 6461  .OF_VECTOR | gda
-00000d00: 6c2e 4f46 5f52 4541 444f 4e4c 5920 7c20  l.OF_READONLY | 
-00000d10: 6764 616c 2e4f 465f 5348 4152 4544 0d0a  gdal.OF_SHARED..
-00000d20: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-00000d30: 2020 206e 625f 6c61 7965 7273 203d 2064     nb_layers = d
-00000d40: 6174 6173 6f75 7263 652e 4765 744c 6179  atasource.GetLay
-00000d50: 6572 436f 756e 7428 290d 0a20 2020 2020  erCount()..     
-00000d60: 2020 2066 6f72 206c 6179 6572 5f69 6420     for layer_id 
-00000d70: 696e 2072 616e 6765 286e 625f 6c61 7965  in range(nb_laye
-00000d80: 7273 293a 0d0a 2020 2020 2020 2020 2020  rs):..          
-00000d90: 2020 6461 7461 736f 7572 6365 5f6c 6179    datasource_lay
-00000da0: 6572 203d 2064 6174 6173 6f75 7263 652e  er = datasource.
-00000db0: 4765 744c 6179 6572 4279 496e 6465 7828  GetLayerByIndex(
-00000dc0: 6c61 7965 725f 6964 290d 0a20 2020 2020  layer_id)..     
-00000dd0: 2020 2020 2020 2069 6620 280d 0a20 2020         if (..   
-00000de0: 2020 2020 2020 2020 2020 2020 206f 6e6c               onl
-00000df0: 795f 7370 6174 6961 6c5f 6c61 7965 7273  y_spatial_layers
-00000e00: 2069 7320 4661 6c73 650d 0a20 2020 2020   is False..     
-00000e10: 2020 2020 2020 2020 2020 206f 7220 6461             or da
-00000e20: 7461 736f 7572 6365 5f6c 6179 6572 2e47  tasource_layer.G
-00000e30: 6574 4765 6f6d 6574 7279 436f 6c75 6d6e  etGeometryColumn
-00000e40: 2829 2021 3d20 2222 0d0a 2020 2020 2020  () != ""..      
-00000e50: 2020 2020 2020 293a 0d0a 2020 2020 2020        ):..      
-00000e60: 2020 2020 2020 2020 2020 6c61 7965 7273            layers
-00000e70: 2e61 7070 656e 6428 6461 7461 736f 7572  .append(datasour
-00000e80: 6365 5f6c 6179 6572 2e47 6574 4e61 6d65  ce_layer.GetName
-00000e90: 2829 290d 0a0d 0a20 2020 2065 7863 6570  ())....    excep
-00000ea0: 7420 4578 6365 7074 696f 6e20 6173 2065  t Exception as e
-00000eb0: 783a 0d0a 2020 2020 2020 2020 6578 2e61  x:..        ex.a
-00000ec0: 7267 7320 3d20 2866 226c 6973 746c 6179  rgs = (f"listlay
-00000ed0: 6572 7320 6572 726f 7220 666f 7220 7b70  ers error for {p
-00000ee0: 6174 687d 3a5c 6e20 207b 6578 7d22 2c29  ath}:\n  {ex}",)
-00000ef0: 0d0a 2020 2020 2020 2020 7261 6973 650d  ..        raise.
-00000f00: 0a20 2020 2066 696e 616c 6c79 3a0d 0a20  .    finally:.. 
-00000f10: 2020 2020 2020 2064 6174 6173 6f75 7263         datasourc
-00000f20: 6520 3d20 4e6f 6e65 0d0a 0d0a 2020 2020  e = None....    
-00000f30: 7265 7475 726e 206c 6179 6572 730d 0a0d  return layers...
-00000f40: 0a0d 0a63 6c61 7373 2043 6f6c 756d 6e49  ...class ColumnI
-00000f50: 6e66 6f3a 0d0a 2020 2020 2222 220d 0a20  nfo:..    """.. 
-00000f60: 2020 2041 2064 6174 6120 6f62 6a65 6374     A data object
-00000f70: 2063 6f6e 7461 696e 696e 6720 6d65 7461   containing meta
-00000f80: 2d69 6e66 6f72 6d61 7469 6f6e 2061 626f  -information abo
-00000f90: 7574 2061 2063 6f6c 756d 6e2e 0d0a 0d0a  ut a column.....
-00000fa0: 2020 2020 4174 7472 6962 7574 6573 3a0d      Attributes:.
-00000fb0: 0a20 2020 2020 2020 206e 616d 6520 2873  .        name (s
-00000fc0: 7472 293a 2074 6865 206e 616d 6520 6f66  tr): the name of
-00000fd0: 2074 6865 2063 6f6c 756d 6e2e 0d0a 2020   the column...  
-00000fe0: 2020 2020 2020 6764 616c 5f74 7970 6520        gdal_type 
-00000ff0: 2873 7472 293a 2074 6865 2074 7970 6520  (str): the type 
-00001000: 6f66 2074 6865 2063 6f6c 756d 6e20 6163  of the column ac
-00001010: 636f 7264 696e 6720 746f 2067 6461 6c2e  cording to gdal.
-00001020: 0d0a 2020 2020 2020 2020 7769 6474 6820  ..        width 
-00001030: 2869 6e74 293a 2074 6865 2077 6964 7468  (int): the width
-00001040: 206f 6620 7468 6520 636f 6c75 6d6e 2c20   of the column, 
-00001050: 6966 2073 7065 6369 6669 6564 2e0d 0a20  if specified... 
-00001060: 2020 2022 2222 0d0a 0d0a 2020 2020 6465     """....    de
-00001070: 6620 5f5f 696e 6974 5f5f 280d 0a20 2020  f __init__(..   
-00001080: 2020 2020 2073 656c 662c 0d0a 2020 2020       self,..    
-00001090: 2020 2020 6e61 6d65 3a20 7374 722c 0d0a      name: str,..
-000010a0: 2020 2020 2020 2020 6764 616c 5f74 7970          gdal_typ
-000010b0: 653a 2073 7472 2c0d 0a20 2020 2020 2020  e: str,..       
-000010c0: 2077 6964 7468 3a20 4f70 7469 6f6e 616c   width: Optional
-000010d0: 5b69 6e74 5d2c 0d0a 2020 2020 2020 2020  [int],..        
-000010e0: 7072 6563 6973 696f 6e3a 204f 7074 696f  precision: Optio
-000010f0: 6e61 6c5b 696e 745d 2c0d 0a20 2020 2029  nal[int],..    )
-00001100: 3a0d 0a20 2020 2020 2020 2022 2222 0d0a  :..        """..
-00001110: 2020 2020 2020 2020 436f 6e73 7472 7563          Construc
-00001120: 746f 7220 6f66 2043 6f6c 756d 6e49 6e66  tor of ColumnInf
-00001130: 6f2e 0d0a 0d0a 2020 2020 2020 2020 4172  o.....        Ar
-00001140: 6773 3a0d 0a20 2020 2020 2020 2020 2020  gs:..           
-00001150: 206e 616d 6520 2873 7472 293a 2074 6865   name (str): the
-00001160: 2063 6f6c 756d 6e20 6e61 6d65 2e0d 0a20   column name... 
-00001170: 2020 2020 2020 2020 2020 2067 6461 6c5f             gdal_
-00001180: 7479 7065 2028 7374 7229 3a20 7468 6520  type (str): the 
-00001190: 6764 616c 2074 7970 6520 6f66 2074 6865  gdal type of the
-000011a0: 2063 6f6c 756d 6e2e 0d0a 2020 2020 2020   column...      
-000011b0: 2020 2020 2020 7769 6474 6820 284f 7074        width (Opt
-000011c0: 696f 6e61 6c5b 696e 745d 293a 2074 6865  ional[int]): the
-000011d0: 2077 6964 7468 206f 6620 7468 6520 636f   width of the co
-000011e0: 6c75 6d6e 2c20 6966 2061 7070 6c69 6361  lumn, if applica
-000011f0: 626c 652e 0d0a 2020 2020 2020 2020 2020  ble...          
-00001200: 2020 7072 6563 6973 696f 6e20 284f 7074    precision (Opt
-00001210: 696f 6e61 6c5b 696e 745d 293a 2074 6865  ional[int]): the
-00001220: 2070 7265 6369 7369 6f6e 206f 6620 7468   precision of th
-00001230: 6520 636f 6c75 6d6e 2c20 6966 2061 7070  e column, if app
-00001240: 6c69 6361 626c 652e 0d0a 2020 2020 2020  licable...      
-00001250: 2020 2222 220d 0a20 2020 2020 2020 2073    """..        s
-00001260: 656c 662e 6e61 6d65 203d 206e 616d 650d  elf.name = name.
-00001270: 0a20 2020 2020 2020 2073 656c 662e 6764  .        self.gd
-00001280: 616c 5f74 7970 6520 3d20 6764 616c 5f74  al_type = gdal_t
-00001290: 7970 650d 0a20 2020 2020 2020 2073 656c  ype..        sel
-000012a0: 662e 7769 6474 6820 3d20 7769 6474 680d  f.width = width.
-000012b0: 0a20 2020 2020 2020 2073 656c 662e 7072  .        self.pr
-000012c0: 6563 6973 696f 6e20 3d20 7072 6563 6973  ecision = precis
-000012d0: 696f 6e0d 0a0d 0a20 2020 2064 6566 205f  ion....    def _
-000012e0: 5f72 6570 725f 5f28 7365 6c66 293a 0d0a  _repr__(self):..
-000012f0: 2020 2020 2020 2020 2222 224f 7665 7272          """Overr
-00001300: 6964 6573 2074 6865 2072 6570 7265 7365  ides the represe
-00001310: 6e74 6174 696f 6e20 7072 6f70 6572 7479  ntation property
-00001320: 206f 6620 436f 6c75 6d6e 496e 666f 2e22   of ColumnInfo."
-00001330: 2222 0d0a 2020 2020 2020 2020 7265 7475  ""..        retu
-00001340: 726e 2066 227b 7365 6c66 2e5f 5f63 6c61  rn f"{self.__cla
-00001350: 7373 5f5f 7d28 7b73 656c 662e 5f5f 6469  ss__}({self.__di
-00001360: 6374 5f5f 7d29 220d 0a0d 0a0d 0a63 6c61  ct__})"......cla
-00001370: 7373 204c 6179 6572 496e 666f 3a0d 0a20  ss LayerInfo:.. 
-00001380: 2020 2022 2222 0d0a 2020 2020 4120 6461     """..    A da
-00001390: 7461 206f 626a 6563 7420 636f 6e74 6169  ta object contai
-000013a0: 6e69 6e67 206d 6574 612d 696e 666f 726d  ning meta-inform
-000013b0: 6174 696f 6e20 6162 6f75 7420 6120 6c61  ation about a la
-000013c0: 7965 722e 0d0a 0d0a 2020 2020 4174 7472  yer.....    Attr
-000013d0: 6962 7574 6573 3a0d 0a20 2020 2020 2020  ibutes:..       
-000013e0: 206e 616d 6520 2873 7472 293a 2074 6865   name (str): the
-000013f0: 206e 616d 6520 6f66 2074 6865 206c 6179   name of the lay
-00001400: 6572 2e0d 0a20 2020 2020 2020 2066 6561  er...        fea
-00001410: 7475 7265 636f 756e 7420 2869 6e74 293a  turecount (int):
-00001420: 2074 6865 206e 756d 6265 7220 6f66 2066   the number of f
-00001430: 6561 7475 7265 7320 2872 6f77 7329 2069  eatures (rows) i
-00001440: 6e20 7468 6520 6c61 7965 722e 0d0a 2020  n the layer...  
-00001450: 2020 2020 2020 746f 7461 6c5f 626f 756e        total_boun
-00001460: 6473 2028 5475 706c 655b 666c 6f61 742c  ds (Tuple[float,
-00001470: 2066 6c6f 6174 2c20 666c 6f61 742c 2066   float, float, f
-00001480: 6c6f 6174 5d29 3a20 7468 6520 626f 756e  loat]): the boun
-00001490: 6469 6e67 2062 6f78 206f 660d 0a20 2020  ding box of..   
-000014a0: 2020 2020 2020 2020 2074 6865 206c 6179           the lay
-000014b0: 6572 3a20 286d 696e 782c 206d 696e 792c  er: (minx, miny,
-000014c0: 206d 6178 782c 206d 6178 7929 2e0d 0a20   maxx, maxy)... 
-000014d0: 2020 2020 2020 2067 656f 6d65 7472 7963         geometryc
-000014e0: 6f6c 756d 6e20 2873 7472 293a 206e 616d  olumn (str): nam
-000014f0: 6520 6f66 2074 6865 2063 6f6c 756d 6e20  e of the column 
-00001500: 7468 6174 2063 6f6e 7461 696e 7320 7468  that contains th
-00001510: 650d 0a20 2020 2020 2020 2020 2020 2070  e..            p
-00001520: 7269 6d61 7279 2067 656f 6d65 7472 792e  rimary geometry.
-00001530: 0d0a 2020 2020 2020 2020 6765 6f6d 6574  ..        geomet
-00001540: 7279 7479 7065 6e61 6d65 2028 7374 7229  rytypename (str)
-00001550: 3a20 7468 6520 6765 6f6d 6574 7279 2074  : the geometry t
-00001560: 7970 6520 6e61 6d65 206f 6620 7468 6520  ype name of the 
-00001570: 6765 6f6d 6574 7279 636f 6c75 6d6e 2e0d  geometrycolumn..
-00001580: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
-00001590: 2074 7970 6520 6e61 6d65 2072 6574 7572   type name retur
-000015a0: 6e65 6420 6973 206f 6e65 206f 6620 7468  ned is one of th
-000015b0: 6520 666f 6c6c 6f77 696e 673a 2050 4f49  e following: POI
-000015c0: 4e54 2c20 4d55 4c54 4950 4f49 4e54 2c0d  NT, MULTIPOINT,.
-000015d0: 0a20 2020 2020 2020 2020 2020 204c 494e  .            LIN
-000015e0: 4553 5452 494e 472c 204d 554c 5449 4c49  ESTRING, MULTILI
-000015f0: 4e45 5354 5249 4e47 2c20 504f 4c59 474f  NESTRING, POLYGO
-00001600: 4e2c 204d 554c 5449 504f 4c59 474f 4e2c  N, MULTIPOLYGON,
-00001610: 2043 4f4c 4c45 4354 494f 4e2e 0d0a 2020   COLLECTION...  
-00001620: 2020 2020 2020 6765 6f6d 6574 7279 7479        geometryty
-00001630: 7065 2028 4765 6f6d 6574 7279 5479 7065  pe (GeometryType
-00001640: 293a 2074 6865 2067 656f 6d65 7472 7920  ): the geometry 
-00001650: 7479 7065 206f 6620 7468 6520 6765 6f6d  type of the geom
-00001660: 6574 7279 636f 6c75 6d6e 2e0d 0a20 2020  etrycolumn...   
-00001670: 2020 2020 2063 6f6c 756d 6e73 2028 6469       columns (di
-00001680: 6374 293a 2074 6865 2063 6f6c 756d 6e73  ct): the columns
-00001690: 2028 6f74 6865 7220 7468 616e 2074 6865   (other than the
-000016a0: 2067 656f 6d65 7472 7920 636f 6c75 6d6e   geometry column
-000016b0: 2920 7468 6174 0d0a 2020 2020 2020 2020  ) that..        
-000016c0: 2020 2020 6172 6520 6176 6169 6c61 626c      are availabl
-000016d0: 6520 6f6e 2074 6865 206c 6179 6572 2077  e on the layer w
-000016e0: 6974 6820 7468 6569 7220 7072 6f70 6572  ith their proper
-000016f0: 7469 6573 2061 7320 6120 6469 6374 2e0d  ties as a dict..
-00001700: 0a20 2020 2020 2020 2066 6964 5f63 6f6c  .        fid_col
-00001710: 756d 6e20 2873 7472 293a 2063 6f6c 756d  umn (str): colum
-00001720: 6e20 6e61 6d65 206f 6620 7468 6520 4649  n name of the FI
-00001730: 4420 636f 6c75 6d6e 2e20 4973 2022 2220  D column. Is "" 
-00001740: 666f 7220 6669 6c65 2074 7970 6573 2074  for file types t
-00001750: 6861 7420 646f 6e27 740d 0a20 2020 2020  hat don't..     
-00001760: 2020 2020 2020 2065 7870 6c69 6369 746c         explicitl
-00001770: 7920 7374 6f72 6520 616e 2046 4944 2c20  y store an FID, 
-00001780: 6c69 6b65 2073 6861 7065 6669 6c65 2e0d  like shapefile..
-00001790: 0a20 2020 2020 2020 2063 7273 2028 7079  .        crs (py
-000017a0: 7072 6f6a 2e43 5253 293a 2074 6865 2073  proj.CRS): the s
-000017b0: 7061 7469 616c 2072 6566 6572 656e 6365  patial reference
-000017c0: 206f 6620 7468 6520 6c61 7965 722e 0d0a   of the layer...
-000017d0: 2020 2020 2020 2020 6572 726f 7273 2028          errors (
-000017e0: 4c69 7374 5b73 7472 5d29 3a20 6c69 7374  List[str]): list
-000017f0: 206f 6620 6572 726f 7273 2069 6e20 7468   of errors in th
-00001800: 6520 6c61 7965 722c 2065 672e 2069 6e76  e layer, eg. inv
-00001810: 616c 6964 2063 6f6c 756d 6e0d 0a20 2020  alid column..   
-00001820: 2020 2020 2020 2020 206e 616d 6573 2c2e           names,.
-00001830: 2e2e 0d0a 2020 2020 2222 220d 0a0d 0a20  ....    """.... 
-00001840: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
-00001850: 0d0a 2020 2020 2020 2020 7365 6c66 2c0d  ..        self,.
-00001860: 0a20 2020 2020 2020 206e 616d 653a 2073  .        name: s
-00001870: 7472 2c0d 0a20 2020 2020 2020 2066 6561  tr,..        fea
-00001880: 7475 7265 636f 756e 743a 2069 6e74 2c0d  turecount: int,.
-00001890: 0a20 2020 2020 2020 2074 6f74 616c 5f62  .        total_b
-000018a0: 6f75 6e64 733a 2054 7570 6c65 5b66 6c6f  ounds: Tuple[flo
-000018b0: 6174 2c20 666c 6f61 742c 2066 6c6f 6174  at, float, float
-000018c0: 2c20 666c 6f61 745d 2c0d 0a20 2020 2020  , float],..     
-000018d0: 2020 2067 656f 6d65 7472 7963 6f6c 756d     geometrycolum
-000018e0: 6e3a 2073 7472 2c0d 0a20 2020 2020 2020  n: str,..       
-000018f0: 2067 656f 6d65 7472 7974 7970 656e 616d   geometrytypenam
-00001900: 653a 2073 7472 2c0d 0a20 2020 2020 2020  e: str,..       
-00001910: 2067 656f 6d65 7472 7974 7970 653a 2047   geometrytype: G
-00001920: 656f 6d65 7472 7954 7970 652c 0d0a 2020  eometryType,..  
-00001930: 2020 2020 2020 636f 6c75 6d6e 733a 2044        columns: D
-00001940: 6963 745b 7374 722c 2043 6f6c 756d 6e49  ict[str, ColumnI
-00001950: 6e66 6f5d 2c0d 0a20 2020 2020 2020 2066  nfo],..        f
-00001960: 6964 5f63 6f6c 756d 6e3a 2073 7472 2c0d  id_column: str,.
-00001970: 0a20 2020 2020 2020 2063 7273 3a20 4f70  .        crs: Op
-00001980: 7469 6f6e 616c 5b70 7970 726f 6a2e 4352  tional[pyproj.CR
-00001990: 535d 2c0d 0a20 2020 2020 2020 2065 7272  S],..        err
-000019a0: 6f72 733a 204c 6973 745b 7374 725d 2c0d  ors: List[str],.
-000019b0: 0a20 2020 2029 3a0d 0a20 2020 2020 2020  .    ):..       
-000019c0: 2022 2222 0d0a 2020 2020 2020 2020 436f   """..        Co
-000019d0: 6e73 7472 7563 746f 7220 6f66 204c 6179  nstructor of Lay
-000019e0: 6572 696e 666f 2e0d 0a0d 0a20 2020 2020  erinfo.....     
-000019f0: 2020 2041 7267 733a 0d0a 2020 2020 2020     Args:..      
-00001a00: 2020 2020 2020 6e61 6d65 2028 7374 7229        name (str)
-00001a10: 3a20 6e61 6d65 206f 6620 7468 6520 6c61  : name of the la
-00001a20: 7965 722e 0d0a 2020 2020 2020 2020 2020  yer...          
-00001a30: 2020 6665 6174 7572 6563 6f75 6e74 2028    featurecount (
-00001a40: 696e 7429 3a20 6e75 6d62 6572 206f 6620  int): number of 
-00001a50: 6665 6174 7572 6573 2069 6e20 7468 6520  features in the 
-00001a60: 6c61 7965 722e 0d0a 2020 2020 2020 2020  layer...        
-00001a70: 2020 2020 746f 7461 6c5f 626f 756e 6473      total_bounds
-00001a80: 2028 5475 706c 655b 666c 6f61 742c 2066   (Tuple[float, f
-00001a90: 6c6f 6174 2c20 666c 6f61 742c 2066 6c6f  loat, float, flo
-00001aa0: 6174 5d29 3a20 7468 6520 626f 756e 6473  at]): the bounds
-00001ab0: 206f 6620 7468 6520 6c61 7965 722e 0d0a   of the layer...
-00001ac0: 2020 2020 2020 2020 2020 2020 6765 6f6d              geom
-00001ad0: 6574 7279 636f 6c75 6d6e 2028 7374 7229  etrycolumn (str)
-00001ae0: 3a20 7468 6520 6e61 6d65 206f 6620 7468  : the name of th
-00001af0: 6520 6765 6f6d 6574 7279 2063 6f6c 756d  e geometry colum
-00001b00: 6e2e 0d0a 2020 2020 2020 2020 2020 2020  n...            
-00001b10: 6765 6f6d 6574 7279 7479 7065 6e61 6d65  geometrytypename
-00001b20: 2028 7374 7229 3a20 7468 6520 6e61 6d65   (str): the name
-00001b30: 206f 6620 7468 6520 6765 6f6d 6574 7279   of the geometry
-00001b40: 2063 6f6c 756d 6e20 7479 7065 2e0d 0a20   column type... 
-00001b50: 2020 2020 2020 2020 2020 2067 656f 6d65             geome
-00001b60: 7472 7974 7970 6520 2847 656f 6d65 7472  trytype (Geometr
-00001b70: 7954 7970 6529 3a20 7468 6520 7479 7065  yType): the type
-00001b80: 206f 6620 7468 6520 6765 6f6d 6574 7279   of the geometry
-00001b90: 2063 6f6c 756d 6e2e 0d0a 2020 2020 2020   column...      
-00001ba0: 2020 2020 2020 636f 6c75 6d6e 7320 2844        columns (D
-00001bb0: 6963 745b 7374 722c 2043 6f6c 756d 6e49  ict[str, ColumnI
-00001bc0: 6e66 6f5d 293a 2074 6865 2061 7474 7269  nfo]): the attri
-00001bd0: 6275 7465 2063 6f6c 756d 6e73 206f 6620  bute columns of 
-00001be0: 7468 6520 6c61 7965 722e 0d0a 2020 2020  the layer...    
-00001bf0: 2020 2020 2020 2020 6669 645f 636f 6c75          fid_colu
-00001c00: 6d6e 2028 7374 7229 3a20 7468 6520 6e61  mn (str): the na
-00001c10: 6d65 206f 6620 7468 6520 6669 6420 636f  me of the fid co
-00001c20: 6c75 6d6e 2e0d 0a20 2020 2020 2020 2020  lumn...         
-00001c30: 2020 2063 7273 2028 4f70 7469 6f6e 616c     crs (Optional
-00001c40: 5b70 7970 726f 6a2e 4352 535d 293a 2074  [pyproj.CRS]): t
-00001c50: 6865 2063 7273 206f 6620 7468 6520 6c61  he crs of the la
-00001c60: 7965 722e 0d0a 2020 2020 2020 2020 2020  yer...          
-00001c70: 2020 6572 726f 7273 2028 4c69 7374 5b73    errors (List[s
-00001c80: 7472 5d29 3a20 6572 726f 7273 2065 6e63  tr]): errors enc
-00001c90: 6f75 6e74 6572 6564 2072 6561 6469 6e67  ountered reading
-00001ca0: 2074 6865 206c 6179 6572 2069 6e66 6f2e   the layer info.
-00001cb0: 0d0a 2020 2020 2020 2020 2222 220d 0a20  ..        """.. 
-00001cc0: 2020 2020 2020 2073 656c 662e 6e61 6d65         self.name
-00001cd0: 203d 206e 616d 650d 0a20 2020 2020 2020   = name..       
-00001ce0: 2073 656c 662e 6665 6174 7572 6563 6f75   self.featurecou
-00001cf0: 6e74 203d 2066 6561 7475 7265 636f 756e  nt = featurecoun
-00001d00: 740d 0a20 2020 2020 2020 2073 656c 662e  t..        self.
-00001d10: 746f 7461 6c5f 626f 756e 6473 203d 2074  total_bounds = t
-00001d20: 6f74 616c 5f62 6f75 6e64 730d 0a20 2020  otal_bounds..   
-00001d30: 2020 2020 2073 656c 662e 6765 6f6d 6574       self.geomet
-00001d40: 7279 636f 6c75 6d6e 203d 2067 656f 6d65  rycolumn = geome
-00001d50: 7472 7963 6f6c 756d 6e0d 0a20 2020 2020  trycolumn..     
-00001d60: 2020 2073 656c 662e 6765 6f6d 6574 7279     self.geometry
-00001d70: 7479 7065 6e61 6d65 203d 2067 656f 6d65  typename = geome
-00001d80: 7472 7974 7970 656e 616d 650d 0a20 2020  trytypename..   
-00001d90: 2020 2020 2073 656c 662e 6765 6f6d 6574       self.geomet
-00001da0: 7279 7479 7065 203d 2067 656f 6d65 7472  rytype = geometr
-00001db0: 7974 7970 650d 0a20 2020 2020 2020 2073  ytype..        s
-00001dc0: 656c 662e 636f 6c75 6d6e 7320 3d20 636f  elf.columns = co
-00001dd0: 6c75 6d6e 730d 0a20 2020 2020 2020 2073  lumns..        s
-00001de0: 656c 662e 6669 645f 636f 6c75 6d6e 203d  elf.fid_column =
-00001df0: 2066 6964 5f63 6f6c 756d 6e0d 0a20 2020   fid_column..   
-00001e00: 2020 2020 2073 656c 662e 6372 7320 3d20       self.crs = 
-00001e10: 6372 730d 0a20 2020 2020 2020 2073 656c  crs..        sel
-00001e20: 662e 6572 726f 7273 203d 2065 7272 6f72  f.errors = error
-00001e30: 730d 0a0d 0a20 2020 2064 6566 205f 5f72  s....    def __r
-00001e40: 6570 725f 5f28 7365 6c66 293a 0d0a 2020  epr__(self):..  
-00001e50: 2020 2020 2020 2222 224f 7665 7272 6964        """Overrid
-00001e60: 6573 2074 6865 2072 6570 7265 7365 6e74  es the represent
-00001e70: 6174 696f 6e20 7072 6f70 6572 7479 206f  ation property o
-00001e80: 6620 4c61 7965 7249 6e66 6f2e 2222 220d  f LayerInfo.""".
-00001e90: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00001ea0: 6622 7b73 656c 662e 5f5f 636c 6173 735f  f"{self.__class_
-00001eb0: 5f7d 287b 7365 6c66 2e5f 5f64 6963 745f  _}({self.__dict_
-00001ec0: 5f7d 2922 0d0a 0d0a 0d0a 6465 6620 6765  _})"......def ge
-00001ed0: 745f 6c61 7965 725f 6765 6f6d 6574 7279  t_layer_geometry
-00001ee0: 7479 7065 7328 0d0a 2020 2020 7061 7468  types(..    path
-00001ef0: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
-00001f00: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
-00001f10: 2c20 6c61 7965 723a 204f 7074 696f 6e61  , layer: Optiona
-00001f20: 6c5b 7374 725d 203d 204e 6f6e 650d 0a29  l[str] = None..)
-00001f30: 202d 3e20 4c69 7374 5b73 7472 5d3a 0d0a   -> List[str]:..
-00001f40: 2020 2020 2222 220d 0a20 2020 2047 6574      """..    Get
-00001f50: 2074 6865 2067 656f 6d65 7472 7920 7479   the geometry ty
-00001f60: 7065 7320 696e 2074 6865 206c 6179 6572  pes in the layer
-00001f70: 2062 7920 6578 616d 696e 696e 6720 6561   by examining ea
-00001f80: 6368 2067 656f 6d65 7472 7920 696e 2074  ch geometry in t
-00001f90: 6865 206c 6179 6572 2e0d 0a0d 0a20 2020  he layer.....   
-00001fa0: 2054 6865 2067 656e 6572 616c 2067 656f   The general geo
-00001fb0: 6d65 7472 7920 7479 7065 206f 6620 7468  metry type of th
-00001fc0: 6520 6c61 7965 7220 6361 6e20 6265 2064  e layer can be d
-00001fd0: 6574 6572 6d69 6e65 6420 7573 696e 670d  etermined using.
-00001fe0: 0a20 2020 203a 6d65 7468 3a60 7e67 6574  .    :meth:`~get
-00001ff0: 5f6c 6179 6572 696e 666f 602e 0d0a 0d0a  _layerinfo`.....
-00002000: 2020 2020 4172 6773 3a0d 0a20 2020 2020      Args:..     
-00002010: 2020 2070 6174 6820 2850 6174 684c 696b     path (PathLik
-00002020: 6529 3a20 7061 7468 2074 6f20 7468 6520  e): path to the 
-00002030: 6669 6c65 2074 6f20 6765 7420 696e 666f  file to get info
-00002040: 2061 626f 7574 0d0a 2020 2020 2020 2020   about..        
-00002050: 6c61 7965 7220 2873 7472 293a 2074 6865  layer (str): the
-00002060: 206c 6179 6572 2079 6f75 2077 616e 7420   layer you want 
-00002070: 696e 666f 2061 626f 7574 2e20 446f 6573  info about. Does
-00002080: 6e27 7420 6e65 6564 2074 6f20 6265 0d0a  n't need to be..
-00002090: 2020 2020 2020 2020 2020 2020 7370 6563              spec
-000020a0: 6966 6965 6420 6966 2074 6865 7265 2069  ified if there i
-000020b0: 7320 6f6e 6c79 206f 6e65 206c 6179 6572  s only one layer
-000020c0: 2069 6e20 7468 6520 6765 6f66 696c 652e   in the geofile.
-000020d0: 0d0a 0d0a 2020 2020 5265 7475 726e 733a  ....    Returns:
-000020e0: 0d0a 2020 2020 2020 2020 4c69 7374 5b73  ..        List[s
-000020f0: 7472 5d3a 2074 6865 2067 656f 6d65 7472  tr]: the geometr
-00002100: 7920 7479 7065 7320 696e 2074 6865 206c  y types in the l
-00002110: 6179 6572 2e0d 0a20 2020 2022 2222 0d0a  ayer...    """..
-00002120: 2020 2020 7371 6c5f 7374 6d74 203d 2022      sql_stmt = "
-00002130: 2222 0d0a 2020 2020 2020 2020 5345 4c45  ""..        SELE
-00002140: 4354 2044 4953 5449 4e43 540d 0a20 2020  CT DISTINCT..   
-00002150: 2020 2020 2020 2020 2020 2020 4341 5345              CASE
-00002160: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00002170: 2020 2057 4845 4e20 4361 7374 546f 5369     WHEN CastToSi
-00002180: 6e67 6c65 287b 6765 6f6d 6574 7279 636f  ngle({geometryco
-00002190: 6c75 6d6e 7d29 2049 5320 4e4f 5420 4e55  lumn}) IS NOT NU
-000021a0: 4c4c 2054 4845 4e0d 0a20 2020 2020 2020  LL THEN..       
-000021b0: 2020 2020 2020 2020 2020 2020 2020 5354                ST
-000021c0: 5f47 656f 6d65 7472 7954 7970 6528 4361  _GeometryType(Ca
-000021d0: 7374 546f 5369 6e67 6c65 287b 6765 6f6d  stToSingle({geom
-000021e0: 6574 7279 636f 6c75 6d6e 7d29 290d 0a20  etrycolumn})).. 
-000021f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002200: 454c 5345 2053 545f 4765 6f6d 6574 7279  ELSE ST_Geometry
-00002210: 5479 7065 287b 6765 6f6d 6574 7279 636f  Type({geometryco
-00002220: 6c75 6d6e 7d29 0d0a 2020 2020 2020 2020  lumn})..        
-00002230: 2020 2020 2020 2045 4e44 2041 5320 6765         END AS ge
-00002240: 6f6d 5f74 7970 650d 0a20 2020 2020 2020  om_type..       
-00002250: 2020 2046 524f 4d20 227b 696e 7075 745f     FROM "{input_
-00002260: 6c61 7965 727d 2220 6c61 7965 720d 0a20  layer}" layer.. 
-00002270: 2020 2022 2222 0d0a 2020 2020 7265 7375     """..    resu
-00002280: 6c74 5f64 6620 3d20 7265 6164 5f66 696c  lt_df = read_fil
-00002290: 6528 7061 7468 2c20 7371 6c5f 7374 6d74  e(path, sql_stmt
-000022a0: 3d73 716c 5f73 746d 742c 2073 716c 5f64  =sql_stmt, sql_d
-000022b0: 6961 6c65 6374 3d22 5351 4c49 5445 2229  ialect="SQLITE")
-000022c0: 0d0a 2020 2020 7265 7475 726e 2072 6573  ..    return res
-000022d0: 756c 745f 6466 5b22 6765 6f6d 5f74 7970  ult_df["geom_typ
-000022e0: 6522 5d2e 746f 5f6c 6973 7428 290d 0a0d  e"].to_list()...
-000022f0: 0a0d 0a64 6566 2067 6574 5f6c 6179 6572  ...def get_layer
-00002300: 696e 666f 280d 0a20 2020 2070 6174 683a  info(..    path:
-00002310: 2055 6e69 6f6e 5b73 7472 2c20 226f 732e   Union[str, "os.
-00002320: 5061 7468 4c69 6b65 5b41 6e79 5d22 5d2c  PathLike[Any]"],
-00002330: 0d0a 2020 2020 6c61 7965 723a 204f 7074  ..    layer: Opt
-00002340: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
-00002350: 652c 0d0a 2020 2020 7261 6973 655f 6f6e  e,..    raise_on
-00002360: 5f6e 6f67 656f 6d3a 2062 6f6f 6c20 3d20  _nogeom: bool = 
-00002370: 5472 7565 2c0d 0a29 202d 3e20 4c61 7965  True,..) -> Laye
-00002380: 7249 6e66 6f3a 0d0a 2020 2020 2222 220d  rInfo:..    """.
-00002390: 0a20 2020 2047 6574 2069 6e66 6f72 6d61  .    Get informa
-000023a0: 7469 6f6e 2061 626f 7574 2061 206c 6179  tion about a lay
-000023b0: 6572 2069 6e20 7468 6520 6765 6f66 696c  er in the geofil
-000023c0: 652e 0d0a 0d0a 2020 2020 5261 6973 6573  e.....    Raises
-000023d0: 2056 616c 7565 4572 726f 7220 6966 2074   ValueError if t
-000023e0: 6865 206c 6179 6572 2064 6566 696e 6974  he layer definit
-000023f0: 696f 6e20 6861 7320 6572 726f 7273 206c  ion has errors l
-00002400: 696b 6520 696e 7661 6c69 6420 636f 6c75  ike invalid colu
-00002410: 6d6e 206e 616d 6573 2c2e 2e2e 0d0a 0d0a  mn names,.......
-00002420: 2020 2020 4172 6773 3a0d 0a20 2020 2020      Args:..     
-00002430: 2020 2070 6174 6820 2850 6174 684c 696b     path (PathLik
-00002440: 6529 3a20 7061 7468 2074 6f20 7468 6520  e): path to the 
-00002450: 6669 6c65 2074 6f20 6765 7420 696e 666f  file to get info
-00002460: 2061 626f 7574 0d0a 2020 2020 2020 2020   about..        
-00002470: 6c61 7965 7220 2873 7472 2c20 6f70 7469  layer (str, opti
-00002480: 6f6e 616c 293a 2074 6865 206c 6179 6572  onal): the layer
-00002490: 2079 6f75 2077 616e 7420 696e 666f 2061   you want info a
-000024a0: 626f 7574 2e20 446f 6573 6e27 7420 6e65  bout. Doesn't ne
-000024b0: 6564 2074 6f20 6265 0d0a 2020 2020 2020  ed to be..      
-000024c0: 2020 2020 2020 7370 6563 6966 6965 6420        specified 
-000024d0: 6966 2074 6865 7265 2069 7320 6f6e 6c79  if there is only
-000024e0: 206f 6e65 206c 6179 6572 2069 6e20 7468   one layer in th
-000024f0: 6520 6765 6f66 696c 652e 0d0a 2020 2020  e geofile...    
-00002500: 2020 2020 7261 6973 655f 6f6e 5f6e 6f67      raise_on_nog
-00002510: 656f 6d20 2862 6f6f 6c2c 206f 7074 696f  eom (bool, optio
-00002520: 6e61 6c29 3a20 5472 7565 2074 6f20 7261  nal): True to ra
-00002530: 6973 6520 6966 2074 6865 206c 6179 6572  ise if the layer
-00002540: 2064 6f65 736e 2774 2068 6176 6520 610d   doesn't have a.
-00002550: 0a20 2020 2020 2020 2020 2020 2067 656f  .            geo
-00002560: 6d65 7472 7920 636f 6c75 6d6e 2e20 4966  metry column. If
-00002570: 2046 616c 7365 2c20 7468 6520 7265 7475   False, the retu
-00002580: 726e 6564 204c 6179 6572 496e 666f 2e67  rned LayerInfo.g
-00002590: 656f 6d65 7472 7963 6f6c 756d 6e20 7769  eometrycolumn wi
-000025a0: 6c6c 2062 650d 0a20 2020 2020 2020 2020  ll be..         
-000025b0: 2020 204e 6f6e 652e 2044 6566 6175 6c74     None. Default
-000025c0: 7320 746f 2054 7275 652e 0d0a 0d0a 2020  s to True.....  
-000025d0: 2020 5265 7475 726e 733a 0d0a 2020 2020    Returns:..    
-000025e0: 2020 2020 4c61 7965 7249 6e66 6f3a 2074      LayerInfo: t
-000025f0: 6865 2069 6e66 6f72 6d61 7469 6f6e 2061  he information a
-00002600: 626f 7574 2074 6865 206c 6179 6572 2e0d  bout the layer..
-00002610: 0a20 2020 2022 2222 0d0a 2020 2020 2320  .    """..    # 
-00002620: 496e 6974 0d0a 2020 2020 7061 7468 203d  Init..    path =
-00002630: 2050 6174 6828 7061 7468 290d 0a20 2020   Path(path)..   
-00002640: 2069 6620 6e6f 7420 7061 7468 2e65 7869   if not path.exi
-00002650: 7374 7328 293a 0d0a 2020 2020 2020 2020  sts():..        
-00002660: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00002670: 2866 2269 6e70 7574 5f70 6174 6820 646f  (f"input_path do
-00002680: 6573 6e27 7420 6578 6973 743a 207b 7061  esn't exist: {pa
-00002690: 7468 7d22 290d 0a0d 0a20 2020 2069 6620  th}")....    if 
-000026a0: 6c61 7965 7220 6973 204e 6f6e 653a 0d0a  layer is None:..
-000026b0: 2020 2020 2020 2020 6c61 7965 7220 3d20          layer = 
-000026c0: 6765 745f 6f6e 6c79 5f6c 6179 6572 2870  get_only_layer(p
-000026d0: 6174 6829 0d0a 0d0a 2020 2020 6461 7461  ath)....    data
-000026e0: 736f 7572 6365 203d 204e 6f6e 650d 0a20  source = None.. 
-000026f0: 2020 2074 7279 3a0d 0a20 2020 2020 2020     try:..       
-00002700: 2064 6174 6173 6f75 7263 6520 3d20 6764   datasource = gd
-00002710: 616c 2e4f 7065 6e45 7828 0d0a 2020 2020  al.OpenEx(..    
-00002720: 2020 2020 2020 2020 7374 7228 7061 7468          str(path
-00002730: 292c 206e 4f70 656e 466c 6167 733d 6764  ), nOpenFlags=gd
-00002740: 616c 2e4f 465f 5645 4354 4f52 207c 2067  al.OF_VECTOR | g
-00002750: 6461 6c2e 4f46 5f52 4541 444f 4e4c 5920  dal.OF_READONLY 
-00002760: 7c20 6764 616c 2e4f 465f 5348 4152 4544  | gdal.OF_SHARED
-00002770: 0d0a 2020 2020 2020 2020 290d 0a20 2020  ..        )..   
-00002780: 2020 2020 2064 6174 6173 6f75 7263 655f       datasource_
-00002790: 6c61 7965 7220 3d20 6461 7461 736f 7572  layer = datasour
-000027a0: 6365 2e47 6574 4c61 7965 7228 6c61 7965  ce.GetLayer(laye
-000027b0: 7229 0d0a 0d0a 2020 2020 2020 2020 2320  r)....        # 
-000027c0: 4966 2074 6865 206c 6179 6572 2064 6f65  If the layer doe
-000027d0: 736e 2774 2065 7869 7374 2c20 7265 7475  sn't exist, retu
-000027e0: 726e 0d0a 2020 2020 2020 2020 6966 2064  rn..        if d
-000027f0: 6174 6173 6f75 7263 655f 6c61 7965 7220  atasource_layer 
-00002800: 6973 204e 6f6e 653a 0d0a 2020 2020 2020  is None:..      
-00002810: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00002820: 6545 7272 6f72 2866 224c 6179 6572 207b  eError(f"Layer {
-00002830: 6c61 7965 727d 206e 6f74 2066 6f75 6e64  layer} not found
-00002840: 2069 6e20 6669 6c65 3a20 7b70 6174 687d   in file: {path}
-00002850: 2229 0d0a 0d0a 2020 2020 2020 2020 2320  ")....        # 
-00002860: 4765 7420 636f 6c75 6d6e 2069 6e66 6f0d  Get column info.
-00002870: 0a20 2020 2020 2020 2063 6f6c 756d 6e73  .        columns
-00002880: 203d 207b 7d0d 0a20 2020 2020 2020 2065   = {}..        e
-00002890: 7272 6f72 7320 3d20 5b5d 0d0a 2020 2020  rrors = []..    
-000028a0: 2020 2020 6472 6976 6572 203d 2064 6174      driver = dat
-000028b0: 6173 6f75 7263 652e 4765 7444 7269 7665  asource.GetDrive
-000028c0: 7228 292e 5368 6f72 744e 616d 650d 0a20  r().ShortName.. 
-000028d0: 2020 2020 2020 206c 6179 6572 5f64 6566         layer_def
-000028e0: 6e20 3d20 6461 7461 736f 7572 6365 5f6c  n = datasource_l
-000028f0: 6179 6572 2e47 6574 4c61 7965 7244 6566  ayer.GetLayerDef
-00002900: 6e28 290d 0a20 2020 2020 2020 2066 6f72  n()..        for
-00002910: 2069 2069 6e20 7261 6e67 6528 6c61 7965   i in range(laye
-00002920: 725f 6465 666e 2e47 6574 4669 656c 6443  r_defn.GetFieldC
-00002930: 6f75 6e74 2829 293a 0d0a 2020 2020 2020  ount()):..      
-00002940: 2020 2020 2020 6e61 6d65 203d 206c 6179        name = lay
-00002950: 6572 5f64 6566 6e2e 4765 7446 6965 6c64  er_defn.GetField
-00002960: 4465 666e 2869 292e 4765 744e 616d 6528  Defn(i).GetName(
-00002970: 290d 0a20 2020 2020 2020 2020 2020 2023  )..            #
-00002980: 2054 4f44 4f3a 2074 6869 6e6b 2077 6865   TODO: think whe
-00002990: 7468 6572 2074 6865 2074 7970 6520 6e61  ther the type na
-000029a0: 6d65 2073 686f 756c 6420 6265 2063 6f6e  me should be con
-000029b0: 7665 7274 6564 2074 6f20 6f74 6865 7220  verted to other 
-000029c0: 6e61 6d65 730d 0a20 2020 2020 2020 2020  names..         
-000029d0: 2020 2067 6461 6c5f 7479 7065 203d 206c     gdal_type = l
-000029e0: 6179 6572 5f64 6566 6e2e 4765 7446 6965  ayer_defn.GetFie
-000029f0: 6c64 4465 666e 2869 292e 4765 7454 7970  ldDefn(i).GetTyp
-00002a00: 654e 616d 6528 290d 0a20 2020 2020 2020  eName()..       
-00002a10: 2020 2020 2077 6964 7468 203d 206c 6179       width = lay
-00002a20: 6572 5f64 6566 6e2e 4765 7446 6965 6c64  er_defn.GetField
-00002a30: 4465 666e 2869 292e 4765 7457 6964 7468  Defn(i).GetWidth
-00002a40: 2829 0d0a 2020 2020 2020 2020 2020 2020  ()..            
-00002a50: 7769 6474 6820 3d20 7769 6474 6820 6966  width = width if
-00002a60: 2077 6964 7468 203e 2030 2065 6c73 6520   width > 0 else 
-00002a70: 4e6f 6e65 0d0a 2020 2020 2020 2020 2020  None..          
-00002a80: 2020 7072 6563 6973 696f 6e20 3d20 6c61    precision = la
-00002a90: 7965 725f 6465 666e 2e47 6574 4669 656c  yer_defn.GetFiel
-00002aa0: 6444 6566 6e28 6929 2e47 6574 5072 6563  dDefn(i).GetPrec
-00002ab0: 6973 696f 6e28 290d 0a20 2020 2020 2020  ision()..       
-00002ac0: 2020 2020 2070 7265 6369 7369 6f6e 203d       precision =
-00002ad0: 2070 7265 6369 7369 6f6e 2069 6620 7072   precision if pr
-00002ae0: 6563 6973 696f 6e20 3e20 3020 656c 7365  ecision > 0 else
-00002af0: 204e 6f6e 650d 0a20 2020 2020 2020 2020   None..         
-00002b00: 2020 2069 6c6c 6567 616c 5f63 6f6c 756d     illegal_colum
-00002b10: 6e5f 6368 6172 7320 3d20 5b27 2227 5d0d  n_chars = ['"'].
-00002b20: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-00002b30: 2069 6c6c 6567 616c 5f63 6861 7220 696e   illegal_char in
-00002b40: 2069 6c6c 6567 616c 5f63 6f6c 756d 6e5f   illegal_column_
-00002b50: 6368 6172 733a 0d0a 2020 2020 2020 2020  chars:..        
-00002b60: 2020 2020 2020 2020 6966 2069 6c6c 6567          if illeg
-00002b70: 616c 5f63 6861 7220 696e 206e 616d 653a  al_char in name:
-00002b80: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00002b90: 2020 2020 2020 6572 726f 7273 2e61 7070        errors.app
-00002ba0: 656e 6428 0d0a 2020 2020 2020 2020 2020  end(..          
-00002bb0: 2020 2020 2020 2020 2020 2020 2020 6622                f"
-00002bc0: 436f 6c75 6d6e 206e 616d 6520 7b6e 616d  Column name {nam
-00002bd0: 657d 2063 6f6e 7461 696e 7320 696c 6c65  e} contains ille
-00002be0: 6761 6c20 6368 6172 3a20 7b69 6c6c 6567  gal char: {illeg
-00002bf0: 616c 5f63 6861 727d 2022 0d0a 2020 2020  al_char} "..    
-00002c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c10: 2020 2020 6622 696e 2066 696c 6520 7b70      f"in file {p
-00002c20: 6174 687d 2c20 6c61 7965 7220 7b6c 6179  ath}, layer {lay
-00002c30: 6572 7d22 0d0a 2020 2020 2020 2020 2020  er}"..          
-00002c40: 2020 2020 2020 2020 2020 290d 0a20 2020            )..   
-00002c50: 2020 2020 2020 2020 2063 6f6c 756d 6e5f           column_
-00002c60: 696e 666f 203d 2043 6f6c 756d 6e49 6e66  info = ColumnInf
-00002c70: 6f28 0d0a 2020 2020 2020 2020 2020 2020  o(..            
-00002c80: 2020 2020 6e61 6d65 3d6e 616d 652c 2067      name=name, g
-00002c90: 6461 6c5f 7479 7065 3d67 6461 6c5f 7479  dal_type=gdal_ty
-00002ca0: 7065 2c20 7769 6474 683d 7769 6474 682c  pe, width=width,
-00002cb0: 2070 7265 6369 7369 6f6e 3d70 7265 6369   precision=preci
-00002cc0: 7369 6f6e 0d0a 2020 2020 2020 2020 2020  sion..          
-00002cd0: 2020 290d 0a20 2020 2020 2020 2020 2020    )..           
-00002ce0: 2063 6f6c 756d 6e73 5b6e 616d 655d 203d   columns[name] =
-00002cf0: 2063 6f6c 756d 6e5f 696e 666f 0d0a 2020   column_info..  
-00002d00: 2020 2020 2020 2020 2020 6966 2064 7269            if dri
-00002d10: 7665 7220 3d3d 2022 4553 5249 2053 6861  ver == "ESRI Sha
-00002d20: 7065 6669 6c65 223a 0d0a 2020 2020 2020  pefile":..      
-00002d30: 2020 2020 2020 2020 2020 6966 206e 616d            if nam
-00002d40: 652e 6361 7365 666f 6c64 2829 203d 3d20  e.casefold() == 
-00002d50: 2267 656f 6d65 7472 7922 3a0d 0a20 2020  "geometry":..   
-00002d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d70: 2065 7272 6f72 732e 6170 7065 6e64 280d   errors.append(.
-00002d80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002d90: 2020 2020 2020 2020 2022 416e 2061 7474           "An att
-00002da0: 7269 6275 7465 2063 6f6c 756d 6e20 2767  ribute column 'g
-00002db0: 656f 6d65 7472 7927 2069 7320 6e6f 7420  eometry' is not 
-00002dc0: 7375 7070 6f72 7465 6420 696e 2061 2073  supported in a s
-00002dd0: 6861 7065 6669 6c65 220d 0a20 2020 2020  hapefile"..     
-00002de0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00002df0: 0d0a 0d0a 2020 2020 2020 2020 2320 4765  ....        # Ge
-00002e00: 7420 6765 6f6d 6574 7279 2063 6f6c 756d  t geometry colum
-00002e10: 6e20 696e 666f 2e2e 2e0d 0a20 2020 2020  n info.....     
-00002e20: 2020 2067 656f 6d65 7472 7974 7970 6520     geometrytype 
-00002e30: 3d20 5f6f 6772 5f75 7469 6c2e 6f67 7274  = _ogr_util.ogrt
-00002e40: 7970 655f 746f 5f67 656f 6d65 7472 7974  ype_to_geometryt
-00002e50: 7970 655b 6461 7461 736f 7572 6365 5f6c  ype[datasource_l
-00002e60: 6179 6572 2e47 6574 4765 6f6d 5479 7065  ayer.GetGeomType
-00002e70: 2829 5d0d 0a20 2020 2020 2020 2069 6620  ()]..        if 
-00002e80: 6765 6f6d 6574 7279 7479 7065 2069 7320  geometrytype is 
-00002e90: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2020  None:..         
-00002ea0: 2020 2067 656f 6d65 7472 7974 7970 656e     geometrytypen
-00002eb0: 616d 6520 3d20 224e 4f4e 4522 0d0a 2020  ame = "NONE"..  
-00002ec0: 2020 2020 2020 656c 7365 3a0d 0a20 2020        else:..   
-00002ed0: 2020 2020 2020 2020 2023 2046 6f72 2073           # For s
-00002ee0: 6861 7065 2066 696c 6573 2c20 7468 6520  hape files, the 
-00002ef0: 6469 6666 6572 656e 6365 2062 6574 7765  difference betwe
-00002f00: 656e 2074 6865 2027 4d55 4c54 4927 2076  en the 'MULTI' v
-00002f10: 6172 6961 6e74 2061 6e64 2074 6865 0d0a  ariant and the..
-00002f20: 2020 2020 2020 2020 2020 2020 2320 7369              # si
-00002f30: 6e67 6c65 206f 6e65 2064 6f65 736e 2774  ngle one doesn't
-00002f40: 2065 7869 7374 732e 2e2e 2073 6f20 616c   exists... so al
-00002f50: 7761 7973 2072 6570 6f72 7420 4d55 4c54  ways report MULT
-00002f60: 4920 7661 7269 616e 7420 6279 2063 6f6e  I variant by con
-00002f70: 7665 6e74 696f 6e2e 0d0a 2020 2020 2020  vention...      
-00002f80: 2020 2020 2020 6966 2064 7269 7665 7220        if driver 
-00002f90: 3d3d 2022 4553 5249 2053 6861 7065 6669  == "ESRI Shapefi
-00002fa0: 6c65 223a 0d0a 2020 2020 2020 2020 2020  le":..          
-00002fb0: 2020 2020 2020 6765 6f6d 6574 7279 7479        geometryty
-00002fc0: 7065 203d 2067 656f 6d65 7472 7974 7970  pe = geometrytyp
-00002fd0: 652e 746f 5f6d 756c 7469 7479 7065 0d0a  e.to_multitype..
-00002fe0: 0d0a 2020 2020 2020 2020 2020 2020 6765  ..            ge
-00002ff0: 6f6d 6574 7279 7479 7065 6e61 6d65 203d  ometrytypename =
-00003000: 2067 656f 6d65 7472 7974 7970 652e 6e61   geometrytype.na
-00003010: 6d65 0d0a 0d0a 2020 2020 2020 2020 2320  me....        # 
-00003020: 4966 2074 6865 2067 656f 6d65 7472 7920  If the geometry 
-00003030: 7479 7065 2069 7320 6e6f 7420 4e6f 6e65  type is not None
-00003040: 2c20 6669 6c6c 206f 7574 2074 6865 2065  , fill out the e
-00003050: 7874 7261 2070 726f 7065 7274 6965 730d  xtra properties.
-00003060: 0a20 2020 2020 2020 2067 656f 6d65 7472  .        geometr
-00003070: 7963 6f6c 756d 6e20 3d20 4e6f 6e65 0d0a  ycolumn = None..
-00003080: 2020 2020 2020 2020 6578 7465 6e74 203d          extent =
-00003090: 204e 6f6e 650d 0a20 2020 2020 2020 2063   None..        c
-000030a0: 7273 203d 204e 6f6e 650d 0a20 2020 2020  rs = None..     
-000030b0: 2020 2074 6f74 616c 5f62 6f75 6e64 7320     total_bounds 
-000030c0: 3d20 4e6f 6e65 0d0a 2020 2020 2020 2020  = None..        
-000030d0: 6966 2067 656f 6d65 7472 7974 7970 6520  if geometrytype 
-000030e0: 6973 206e 6f74 204e 6f6e 653a 0d0a 2020  is not None:..  
-000030f0: 2020 2020 2020 2020 2020 2320 4765 6f6d            # Geom
-00003100: 6574 7279 2063 6f6c 756d 6e20 6e61 6d65  etry column name
-00003110: 0d0a 2020 2020 2020 2020 2020 2020 6765  ..            ge
-00003120: 6f6d 6574 7279 636f 6c75 6d6e 203d 2064  ometrycolumn = d
-00003130: 6174 6173 6f75 7263 655f 6c61 7965 722e  atasource_layer.
-00003140: 4765 7447 656f 6d65 7472 7943 6f6c 756d  GetGeometryColum
-00003150: 6e28 290d 0a20 2020 2020 2020 2020 2020  n()..           
-00003160: 2069 6620 6765 6f6d 6574 7279 636f 6c75   if geometrycolu
-00003170: 6d6e 203d 3d20 2222 3a0d 0a20 2020 2020  mn == "":..     
-00003180: 2020 2020 2020 2020 2020 2067 656f 6d65             geome
-00003190: 7472 7963 6f6c 756d 6e20 3d20 2267 656f  trycolumn = "geo
-000031a0: 6d65 7472 7922 0d0a 2020 2020 2020 2020  metry"..        
-000031b0: 2020 2020 2320 436f 6e76 6572 7420 6578      # Convert ex
-000031c0: 7465 6e74 2028 786d 696e 2c20 786d 6178  tent (xmin, xmax
-000031d0: 2c20 796d 696e 2c20 796d 6178 2920 746f  , ymin, ymax) to
-000031e0: 2062 6f75 6e64 7320 2878 6d69 6e2c 2079   bounds (xmin, y
-000031f0: 6d69 6e2c 2078 6d61 782c 2079 6d61 7829  min, xmax, ymax)
-00003200: 0d0a 2020 2020 2020 2020 2020 2020 6578  ..            ex
-00003210: 7465 6e74 203d 2064 6174 6173 6f75 7263  tent = datasourc
-00003220: 655f 6c61 7965 722e 4765 7445 7874 656e  e_layer.GetExten
-00003230: 7428 290d 0a20 2020 2020 2020 2020 2020  t()..           
-00003240: 2074 6f74 616c 5f62 6f75 6e64 7320 3d20   total_bounds = 
-00003250: 2865 7874 656e 745b 305d 2c20 6578 7465  (extent[0], exte
-00003260: 6e74 5b32 5d2c 2065 7874 656e 745b 315d  nt[2], extent[1]
-00003270: 2c20 6578 7465 6e74 5b33 5d29 0d0a 2020  , extent[3])..  
-00003280: 2020 2020 2020 2020 2020 2320 4352 530d            # CRS.
-00003290: 0a20 2020 2020 2020 2020 2020 2073 7061  .            spa
-000032a0: 7469 616c 7265 6620 3d20 6461 7461 736f  tialref = dataso
-000032b0: 7572 6365 5f6c 6179 6572 2e47 6574 5370  urce_layer.GetSp
-000032c0: 6174 6961 6c52 6566 2829 0d0a 2020 2020  atialRef()..    
-000032d0: 2020 2020 2020 2020 6966 2073 7061 7469          if spati
-000032e0: 616c 7265 6620 6973 206e 6f74 204e 6f6e  alref is not Non
-000032f0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-00003300: 2020 2020 6372 7320 3d20 7079 7072 6f6a      crs = pyproj
-00003310: 2e43 5253 2873 7061 7469 616c 7265 662e  .CRS(spatialref.
-00003320: 4578 706f 7274 546f 576b 7428 2929 0d0a  ExportToWkt())..
-00003330: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00003340: 2020 2320 4966 2073 7061 7469 616c 2072    # If spatial r
-00003350: 6566 2068 6173 206e 6f20 6570 7367 2c20  ef has no epsg, 
-00003360: 7472 7920 746f 2066 696e 6420 636f 7272  try to find corr
-00003370: 6573 706f 6e64 696e 6720 6f6e 650d 0a20  esponding one.. 
-00003380: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00003390: 7273 5f65 7073 6720 3d20 6372 732e 746f  rs_epsg = crs.to
-000033a0: 5f65 7073 6728 290d 0a20 2020 2020 2020  _epsg()..       
-000033b0: 2020 2020 2020 2020 2069 6620 6372 735f           if crs_
-000033c0: 6570 7367 2069 7320 4e6f 6e65 3a0d 0a20  epsg is None:.. 
-000033d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000033e0: 2020 2069 6620 6372 732e 6e61 6d65 2069     if crs.name i
-000033f0: 6e20 5b0d 0a20 2020 2020 2020 2020 2020  n [..           
-00003400: 2020 2020 2020 2020 2020 2020 2022 4265               "Be
-00003410: 6c67 6520 3139 3732 202f 2042 656c 6769  lge 1972 / Belgi
-00003420: 616e 204c 616d 6265 7274 2037 3222 2c0d  an Lambert 72",.
-00003430: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003440: 2020 2020 2020 2020 2022 4265 6c67 655f           "Belge_
-00003450: 3139 3732 5f42 656c 6769 616e 5f4c 616d  1972_Belgian_Lam
-00003460: 6265 7274 5f37 3222 2c0d 0a20 2020 2020  bert_72",..     
+00000a10: 230a 0a0a 6465 6620 6c69 7374 6c61 7965  #...def listlaye
+00000a20: 7273 280a 2020 2020 7061 7468 3a20 556e  rs(.    path: Un
+00000a30: 696f 6e5b 7374 722c 2022 6f73 2e50 6174  ion[str, "os.Pat
+00000a40: 684c 696b 655b 416e 795d 225d 2c0a 2020  hLike[Any]"],.  
+00000a50: 2020 6f6e 6c79 5f73 7061 7469 616c 5f6c    only_spatial_l
+00000a60: 6179 6572 733a 2062 6f6f 6c20 3d20 5472  ayers: bool = Tr
+00000a70: 7565 2c0a 2920 2d3e 204c 6973 745b 7374  ue,.) -> List[st
+00000a80: 725d 3a0a 2020 2020 2222 220a 2020 2020  r]:.    """.    
+00000a90: 4765 7420 7468 6520 6c69 7374 206f 6620  Get the list of 
+00000aa0: 6c61 7965 7273 2069 6e20 6120 6765 6f66  layers in a geof
+00000ab0: 696c 652e 0a0a 2020 2020 4172 6773 3a0a  ile...    Args:.
+00000ac0: 2020 2020 2020 2020 7061 7468 2028 5061          path (Pa
+00000ad0: 7468 4c69 6b65 293a 2070 6174 6820 746f  thLike): path to
+00000ae0: 2074 6865 2066 696c 6520 746f 2067 6574   the file to get
+00000af0: 2069 6e66 6f20 6162 6f75 740a 2020 2020   info about.    
+00000b00: 2020 2020 6f6e 6c79 5f73 7061 7469 616c      only_spatial
+00000b10: 5f6c 6179 6572 7320 2862 6f6f 6c2c 206f  _layers (bool, o
+00000b20: 7074 696f 6e61 6c29 3a20 5472 7565 2074  ptional): True t
+00000b30: 6f20 6f6e 6c79 206c 6973 7420 7370 6174  o only list spat
+00000b40: 6961 6c20 6c61 7965 7273 2e0a 2020 2020  ial layers..    
+00000b50: 2020 2020 2020 2020 4661 6c73 6520 746f          False to
+00000b60: 206c 6973 7420 616c 6c20 7461 626c 6573   list all tables
+00000b70: 2e0a 0a20 2020 2052 6574 7572 6e73 3a0a  ...    Returns:.
+00000b80: 2020 2020 2020 2020 4c69 7374 5b73 7472          List[str
+00000b90: 5d3a 2074 6865 206c 6973 7420 6f66 206c  ]: the list of l
+00000ba0: 6179 6572 730a 2020 2020 2222 220a 2020  ayers.    """.  
+00000bb0: 2020 7061 7468 203d 2050 6174 6828 7061    path = Path(pa
+00000bc0: 7468 290a 2020 2020 6966 2070 6174 682e  th).    if path.
+00000bd0: 7375 6666 6978 2e6c 6f77 6572 2829 203d  suffix.lower() =
+00000be0: 3d20 222e 7368 7022 3a0a 2020 2020 2020  = ".shp":.      
+00000bf0: 2020 7265 7475 726e 205b 7061 7468 2e73    return [path.s
+00000c00: 7465 6d5d 0a0a 2020 2020 6461 7461 736f  tem]..    dataso
+00000c10: 7572 6365 203d 204e 6f6e 650a 2020 2020  urce = None.    
+00000c20: 6c61 7965 7273 203d 205b 5d0a 2020 2020  layers = [].    
+00000c30: 7472 793a 0a20 2020 2020 2020 2064 6174  try:.        dat
+00000c40: 6173 6f75 7263 6520 3d20 6764 616c 2e4f  asource = gdal.O
+00000c50: 7065 6e45 7828 0a20 2020 2020 2020 2020  penEx(.         
+00000c60: 2020 2073 7472 2870 6174 6829 2c20 6e4f     str(path), nO
+00000c70: 7065 6e46 6c61 6773 3d67 6461 6c2e 4f46  penFlags=gdal.OF
+00000c80: 5f56 4543 544f 5220 7c20 6764 616c 2e4f  _VECTOR | gdal.O
+00000c90: 465f 5245 4144 4f4e 4c59 207c 2067 6461  F_READONLY | gda
+00000ca0: 6c2e 4f46 5f53 4841 5245 440a 2020 2020  l.OF_SHARED.    
+00000cb0: 2020 2020 290a 2020 2020 2020 2020 6e62      ).        nb
+00000cc0: 5f6c 6179 6572 7320 3d20 6461 7461 736f  _layers = dataso
+00000cd0: 7572 6365 2e47 6574 4c61 7965 7243 6f75  urce.GetLayerCou
+00000ce0: 6e74 2829 0a20 2020 2020 2020 2066 6f72  nt().        for
+00000cf0: 206c 6179 6572 5f69 6420 696e 2072 616e   layer_id in ran
+00000d00: 6765 286e 625f 6c61 7965 7273 293a 0a20  ge(nb_layers):. 
+00000d10: 2020 2020 2020 2020 2020 2064 6174 6173             datas
+00000d20: 6f75 7263 655f 6c61 7965 7220 3d20 6461  ource_layer = da
+00000d30: 7461 736f 7572 6365 2e47 6574 4c61 7965  tasource.GetLaye
+00000d40: 7242 7949 6e64 6578 286c 6179 6572 5f69  rByIndex(layer_i
+00000d50: 6429 0a20 2020 2020 2020 2020 2020 2069  d).            i
+00000d60: 6620 280a 2020 2020 2020 2020 2020 2020  f (.            
+00000d70: 2020 2020 6f6e 6c79 5f73 7061 7469 616c      only_spatial
+00000d80: 5f6c 6179 6572 7320 6973 2046 616c 7365  _layers is False
+00000d90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00000da0: 206f 7220 6461 7461 736f 7572 6365 5f6c   or datasource_l
+00000db0: 6179 6572 2e47 6574 4765 6f6d 6574 7279  ayer.GetGeometry
+00000dc0: 436f 6c75 6d6e 2829 2021 3d20 2222 0a20  Column() != "". 
+00000dd0: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
+00000de0: 2020 2020 2020 2020 2020 2020 2020 6c61                la
+00000df0: 7965 7273 2e61 7070 656e 6428 6461 7461  yers.append(data
+00000e00: 736f 7572 6365 5f6c 6179 6572 2e47 6574  source_layer.Get
+00000e10: 4e61 6d65 2829 290a 0a20 2020 2065 7863  Name())..    exc
+00000e20: 6570 7420 4578 6365 7074 696f 6e20 6173  ept Exception as
+00000e30: 2065 783a 0a20 2020 2020 2020 2065 782e   ex:.        ex.
+00000e40: 6172 6773 203d 2028 6622 6c69 7374 6c61  args = (f"listla
+00000e50: 7965 7273 2065 7272 6f72 2066 6f72 207b  yers error for {
+00000e60: 7061 7468 7d3a 5c6e 2020 7b65 787d 222c  path}:\n  {ex}",
+00000e70: 290a 2020 2020 2020 2020 7261 6973 650a  ).        raise.
+00000e80: 2020 2020 6669 6e61 6c6c 793a 0a20 2020      finally:.   
+00000e90: 2020 2020 2064 6174 6173 6f75 7263 6520       datasource 
+00000ea0: 3d20 4e6f 6e65 0a0a 2020 2020 7265 7475  = None..    retu
+00000eb0: 726e 206c 6179 6572 730a 0a0a 636c 6173  rn layers...clas
+00000ec0: 7320 436f 6c75 6d6e 496e 666f 3a0a 2020  s ColumnInfo:.  
+00000ed0: 2020 2222 220a 2020 2020 4120 6461 7461    """.    A data
+00000ee0: 206f 626a 6563 7420 636f 6e74 6169 6e69   object containi
+00000ef0: 6e67 206d 6574 612d 696e 666f 726d 6174  ng meta-informat
+00000f00: 696f 6e20 6162 6f75 7420 6120 636f 6c75  ion about a colu
+00000f10: 6d6e 2e0a 0a20 2020 2041 7474 7269 6275  mn...    Attribu
+00000f20: 7465 733a 0a20 2020 2020 2020 206e 616d  tes:.        nam
+00000f30: 6520 2873 7472 293a 2074 6865 206e 616d  e (str): the nam
+00000f40: 6520 6f66 2074 6865 2063 6f6c 756d 6e2e  e of the column.
+00000f50: 0a20 2020 2020 2020 2067 6461 6c5f 7479  .        gdal_ty
+00000f60: 7065 2028 7374 7229 3a20 7468 6520 7479  pe (str): the ty
+00000f70: 7065 206f 6620 7468 6520 636f 6c75 6d6e  pe of the column
+00000f80: 2061 6363 6f72 6469 6e67 2074 6f20 6764   according to gd
+00000f90: 616c 2e0a 2020 2020 2020 2020 7769 6474  al..        widt
+00000fa0: 6820 2869 6e74 293a 2074 6865 2077 6964  h (int): the wid
+00000fb0: 7468 206f 6620 7468 6520 636f 6c75 6d6e  th of the column
+00000fc0: 2c20 6966 2073 7065 6369 6669 6564 2e0a  , if specified..
+00000fd0: 2020 2020 2222 220a 0a20 2020 2064 6566      """..    def
+00000fe0: 205f 5f69 6e69 745f 5f28 0a20 2020 2020   __init__(.     
+00000ff0: 2020 2073 656c 662c 0a20 2020 2020 2020     self,.       
+00001000: 206e 616d 653a 2073 7472 2c0a 2020 2020   name: str,.    
+00001010: 2020 2020 6764 616c 5f74 7970 653a 2073      gdal_type: s
+00001020: 7472 2c0a 2020 2020 2020 2020 7769 6474  tr,.        widt
+00001030: 683a 204f 7074 696f 6e61 6c5b 696e 745d  h: Optional[int]
+00001040: 2c0a 2020 2020 2020 2020 7072 6563 6973  ,.        precis
+00001050: 696f 6e3a 204f 7074 696f 6e61 6c5b 696e  ion: Optional[in
+00001060: 745d 2c0a 2020 2020 293a 0a20 2020 2020  t],.    ):.     
+00001070: 2020 2022 2222 0a20 2020 2020 2020 2043     """.        C
+00001080: 6f6e 7374 7275 6374 6f72 206f 6620 436f  onstructor of Co
+00001090: 6c75 6d6e 496e 666f 2e0a 0a20 2020 2020  lumnInfo...     
+000010a0: 2020 2041 7267 733a 0a20 2020 2020 2020     Args:.       
+000010b0: 2020 2020 206e 616d 6520 2873 7472 293a       name (str):
+000010c0: 2074 6865 2063 6f6c 756d 6e20 6e61 6d65   the column name
+000010d0: 2e0a 2020 2020 2020 2020 2020 2020 6764  ..            gd
+000010e0: 616c 5f74 7970 6520 2873 7472 293a 2074  al_type (str): t
+000010f0: 6865 2067 6461 6c20 7479 7065 206f 6620  he gdal type of 
+00001100: 7468 6520 636f 6c75 6d6e 2e0a 2020 2020  the column..    
+00001110: 2020 2020 2020 2020 7769 6474 6820 284f          width (O
+00001120: 7074 696f 6e61 6c5b 696e 745d 293a 2074  ptional[int]): t
+00001130: 6865 2077 6964 7468 206f 6620 7468 6520  he width of the 
+00001140: 636f 6c75 6d6e 2c20 6966 2061 7070 6c69  column, if appli
+00001150: 6361 626c 652e 0a20 2020 2020 2020 2020  cable..         
+00001160: 2020 2070 7265 6369 7369 6f6e 2028 4f70     precision (Op
+00001170: 7469 6f6e 616c 5b69 6e74 5d29 3a20 7468  tional[int]): th
+00001180: 6520 7072 6563 6973 696f 6e20 6f66 2074  e precision of t
+00001190: 6865 2063 6f6c 756d 6e2c 2069 6620 6170  he column, if ap
+000011a0: 706c 6963 6162 6c65 2e0a 2020 2020 2020  plicable..      
+000011b0: 2020 2222 220a 2020 2020 2020 2020 7365    """.        se
+000011c0: 6c66 2e6e 616d 6520 3d20 6e61 6d65 0a20  lf.name = name. 
+000011d0: 2020 2020 2020 2073 656c 662e 6764 616c         self.gdal
+000011e0: 5f74 7970 6520 3d20 6764 616c 5f74 7970  _type = gdal_typ
+000011f0: 650a 2020 2020 2020 2020 7365 6c66 2e77  e.        self.w
+00001200: 6964 7468 203d 2077 6964 7468 0a20 2020  idth = width.   
+00001210: 2020 2020 2073 656c 662e 7072 6563 6973       self.precis
+00001220: 696f 6e20 3d20 7072 6563 6973 696f 6e0a  ion = precision.
+00001230: 0a20 2020 2064 6566 205f 5f72 6570 725f  .    def __repr_
+00001240: 5f28 7365 6c66 293a 0a20 2020 2020 2020  _(self):.       
+00001250: 2022 2222 4f76 6572 7269 6465 7320 7468   """Overrides th
+00001260: 6520 7265 7072 6573 656e 7461 7469 6f6e  e representation
+00001270: 2070 726f 7065 7274 7920 6f66 2043 6f6c   property of Col
+00001280: 756d 6e49 6e66 6f2e 2222 220a 2020 2020  umnInfo.""".    
+00001290: 2020 2020 7265 7475 726e 2066 227b 7365      return f"{se
+000012a0: 6c66 2e5f 5f63 6c61 7373 5f5f 7d28 7b73  lf.__class__}({s
+000012b0: 656c 662e 5f5f 6469 6374 5f5f 7d29 220a  elf.__dict__})".
+000012c0: 0a0a 636c 6173 7320 4c61 7965 7249 6e66  ..class LayerInf
+000012d0: 6f3a 0a20 2020 2022 2222 0a20 2020 2041  o:.    """.    A
+000012e0: 2064 6174 6120 6f62 6a65 6374 2063 6f6e   data object con
+000012f0: 7461 696e 696e 6720 6d65 7461 2d69 6e66  taining meta-inf
+00001300: 6f72 6d61 7469 6f6e 2061 626f 7574 2061  ormation about a
+00001310: 206c 6179 6572 2e0a 0a20 2020 2041 7474   layer...    Att
+00001320: 7269 6275 7465 733a 0a20 2020 2020 2020  ributes:.       
+00001330: 206e 616d 6520 2873 7472 293a 2074 6865   name (str): the
+00001340: 206e 616d 6520 6f66 2074 6865 206c 6179   name of the lay
+00001350: 6572 2e0a 2020 2020 2020 2020 6665 6174  er..        feat
+00001360: 7572 6563 6f75 6e74 2028 696e 7429 3a20  urecount (int): 
+00001370: 7468 6520 6e75 6d62 6572 206f 6620 6665  the number of fe
+00001380: 6174 7572 6573 2028 726f 7773 2920 696e  atures (rows) in
+00001390: 2074 6865 206c 6179 6572 2e0a 2020 2020   the layer..    
+000013a0: 2020 2020 746f 7461 6c5f 626f 756e 6473      total_bounds
+000013b0: 2028 5475 706c 655b 666c 6f61 742c 2066   (Tuple[float, f
+000013c0: 6c6f 6174 2c20 666c 6f61 742c 2066 6c6f  loat, float, flo
+000013d0: 6174 5d29 3a20 7468 6520 626f 756e 6469  at]): the boundi
+000013e0: 6e67 2062 6f78 206f 660a 2020 2020 2020  ng box of.      
+000013f0: 2020 2020 2020 7468 6520 6c61 7965 723a        the layer:
+00001400: 2028 6d69 6e78 2c20 6d69 6e79 2c20 6d61   (minx, miny, ma
+00001410: 7878 2c20 6d61 7879 292e 0a20 2020 2020  xx, maxy)..     
+00001420: 2020 2067 656f 6d65 7472 7963 6f6c 756d     geometrycolum
+00001430: 6e20 2873 7472 293a 206e 616d 6520 6f66  n (str): name of
+00001440: 2074 6865 2063 6f6c 756d 6e20 7468 6174   the column that
+00001450: 2063 6f6e 7461 696e 7320 7468 650a 2020   contains the.  
+00001460: 2020 2020 2020 2020 2020 7072 696d 6172            primar
+00001470: 7920 6765 6f6d 6574 7279 2e0a 2020 2020  y geometry..    
+00001480: 2020 2020 6765 6f6d 6574 7279 7479 7065      geometrytype
+00001490: 6e61 6d65 2028 7374 7229 3a20 7468 6520  name (str): the 
+000014a0: 6765 6f6d 6574 7279 2074 7970 6520 6e61  geometry type na
+000014b0: 6d65 206f 6620 7468 6520 6765 6f6d 6574  me of the geomet
+000014c0: 7279 636f 6c75 6d6e 2e0a 2020 2020 2020  rycolumn..      
+000014d0: 2020 2020 2020 5468 6520 7479 7065 206e        The type n
+000014e0: 616d 6520 7265 7475 726e 6564 2069 7320  ame returned is 
+000014f0: 6f6e 6520 6f66 2074 6865 2066 6f6c 6c6f  one of the follo
+00001500: 7769 6e67 3a20 504f 494e 542c 204d 554c  wing: POINT, MUL
+00001510: 5449 504f 494e 542c 0a20 2020 2020 2020  TIPOINT,.       
+00001520: 2020 2020 204c 494e 4553 5452 494e 472c       LINESTRING,
+00001530: 204d 554c 5449 4c49 4e45 5354 5249 4e47   MULTILINESTRING
+00001540: 2c20 504f 4c59 474f 4e2c 204d 554c 5449  , POLYGON, MULTI
+00001550: 504f 4c59 474f 4e2c 2043 4f4c 4c45 4354  POLYGON, COLLECT
+00001560: 494f 4e2e 0a20 2020 2020 2020 2067 656f  ION..        geo
+00001570: 6d65 7472 7974 7970 6520 2847 656f 6d65  metrytype (Geome
+00001580: 7472 7954 7970 6529 3a20 7468 6520 6765  tryType): the ge
+00001590: 6f6d 6574 7279 2074 7970 6520 6f66 2074  ometry type of t
+000015a0: 6865 2067 656f 6d65 7472 7963 6f6c 756d  he geometrycolum
+000015b0: 6e2e 0a20 2020 2020 2020 2063 6f6c 756d  n..        colum
+000015c0: 6e73 2028 6469 6374 293a 2074 6865 2063  ns (dict): the c
+000015d0: 6f6c 756d 6e73 2028 6f74 6865 7220 7468  olumns (other th
+000015e0: 616e 2074 6865 2067 656f 6d65 7472 7920  an the geometry 
+000015f0: 636f 6c75 6d6e 2920 7468 6174 0a20 2020  column) that.   
+00001600: 2020 2020 2020 2020 2061 7265 2061 7661           are ava
+00001610: 696c 6162 6c65 206f 6e20 7468 6520 6c61  ilable on the la
+00001620: 7965 7220 7769 7468 2074 6865 6972 2070  yer with their p
+00001630: 726f 7065 7274 6965 7320 6173 2061 2064  roperties as a d
+00001640: 6963 742e 0a20 2020 2020 2020 2066 6964  ict..        fid
+00001650: 5f63 6f6c 756d 6e20 2873 7472 293a 2063  _column (str): c
+00001660: 6f6c 756d 6e20 6e61 6d65 206f 6620 7468  olumn name of th
+00001670: 6520 4649 4420 636f 6c75 6d6e 2e20 4973  e FID column. Is
+00001680: 2022 2220 666f 7220 6669 6c65 2074 7970   "" for file typ
+00001690: 6573 2074 6861 7420 646f 6e27 740a 2020  es that don't.  
+000016a0: 2020 2020 2020 2020 2020 6578 706c 6963            explic
+000016b0: 6974 6c79 2073 746f 7265 2061 6e20 4649  itly store an FI
+000016c0: 442c 206c 696b 6520 7368 6170 6566 696c  D, like shapefil
+000016d0: 652e 0a20 2020 2020 2020 2063 7273 2028  e..        crs (
+000016e0: 7079 7072 6f6a 2e43 5253 293a 2074 6865  pyproj.CRS): the
+000016f0: 2073 7061 7469 616c 2072 6566 6572 656e   spatial referen
+00001700: 6365 206f 6620 7468 6520 6c61 7965 722e  ce of the layer.
+00001710: 0a20 2020 2020 2020 2065 7272 6f72 7320  .        errors 
+00001720: 284c 6973 745b 7374 725d 293a 206c 6973  (List[str]): lis
+00001730: 7420 6f66 2065 7272 6f72 7320 696e 2074  t of errors in t
+00001740: 6865 206c 6179 6572 2c20 6567 2e20 696e  he layer, eg. in
+00001750: 7661 6c69 6420 636f 6c75 6d6e 0a20 2020  valid column.   
+00001760: 2020 2020 2020 2020 206e 616d 6573 2c2e           names,.
+00001770: 2e2e 0a20 2020 2022 2222 0a0a 2020 2020  ...    """..    
+00001780: 6465 6620 5f5f 696e 6974 5f5f 280a 2020  def __init__(.  
+00001790: 2020 2020 2020 7365 6c66 2c0a 2020 2020        self,.    
+000017a0: 2020 2020 6e61 6d65 3a20 7374 722c 0a20      name: str,. 
+000017b0: 2020 2020 2020 2066 6561 7475 7265 636f         featureco
+000017c0: 756e 743a 2069 6e74 2c0a 2020 2020 2020  unt: int,.      
+000017d0: 2020 746f 7461 6c5f 626f 756e 6473 3a20    total_bounds: 
+000017e0: 5475 706c 655b 666c 6f61 742c 2066 6c6f  Tuple[float, flo
+000017f0: 6174 2c20 666c 6f61 742c 2066 6c6f 6174  at, float, float
+00001800: 5d2c 0a20 2020 2020 2020 2067 656f 6d65  ],.        geome
+00001810: 7472 7963 6f6c 756d 6e3a 2073 7472 2c0a  trycolumn: str,.
+00001820: 2020 2020 2020 2020 6765 6f6d 6574 7279          geometry
+00001830: 7479 7065 6e61 6d65 3a20 7374 722c 0a20  typename: str,. 
+00001840: 2020 2020 2020 2067 656f 6d65 7472 7974         geometryt
+00001850: 7970 653a 2047 656f 6d65 7472 7954 7970  ype: GeometryTyp
+00001860: 652c 0a20 2020 2020 2020 2063 6f6c 756d  e,.        colum
+00001870: 6e73 3a20 4469 6374 5b73 7472 2c20 436f  ns: Dict[str, Co
+00001880: 6c75 6d6e 496e 666f 5d2c 0a20 2020 2020  lumnInfo],.     
+00001890: 2020 2066 6964 5f63 6f6c 756d 6e3a 2073     fid_column: s
+000018a0: 7472 2c0a 2020 2020 2020 2020 6372 733a  tr,.        crs:
+000018b0: 204f 7074 696f 6e61 6c5b 7079 7072 6f6a   Optional[pyproj
+000018c0: 2e43 5253 5d2c 0a20 2020 2020 2020 2065  .CRS],.        e
+000018d0: 7272 6f72 733a 204c 6973 745b 7374 725d  rrors: List[str]
+000018e0: 2c0a 2020 2020 293a 0a20 2020 2020 2020  ,.    ):.       
+000018f0: 2022 2222 0a20 2020 2020 2020 2043 6f6e   """.        Con
+00001900: 7374 7275 6374 6f72 206f 6620 4c61 7965  structor of Laye
+00001910: 7269 6e66 6f2e 0a0a 2020 2020 2020 2020  rinfo...        
+00001920: 4172 6773 3a0a 2020 2020 2020 2020 2020  Args:.          
+00001930: 2020 6e61 6d65 2028 7374 7229 3a20 6e61    name (str): na
+00001940: 6d65 206f 6620 7468 6520 6c61 7965 722e  me of the layer.
+00001950: 0a20 2020 2020 2020 2020 2020 2066 6561  .            fea
+00001960: 7475 7265 636f 756e 7420 2869 6e74 293a  turecount (int):
+00001970: 206e 756d 6265 7220 6f66 2066 6561 7475   number of featu
+00001980: 7265 7320 696e 2074 6865 206c 6179 6572  res in the layer
+00001990: 2e0a 2020 2020 2020 2020 2020 2020 746f  ..            to
+000019a0: 7461 6c5f 626f 756e 6473 2028 5475 706c  tal_bounds (Tupl
+000019b0: 655b 666c 6f61 742c 2066 6c6f 6174 2c20  e[float, float, 
+000019c0: 666c 6f61 742c 2066 6c6f 6174 5d29 3a20  float, float]): 
+000019d0: 7468 6520 626f 756e 6473 206f 6620 7468  the bounds of th
+000019e0: 6520 6c61 7965 722e 0a20 2020 2020 2020  e layer..       
+000019f0: 2020 2020 2067 656f 6d65 7472 7963 6f6c       geometrycol
+00001a00: 756d 6e20 2873 7472 293a 2074 6865 206e  umn (str): the n
+00001a10: 616d 6520 6f66 2074 6865 2067 656f 6d65  ame of the geome
+00001a20: 7472 7920 636f 6c75 6d6e 2e0a 2020 2020  try column..    
+00001a30: 2020 2020 2020 2020 6765 6f6d 6574 7279          geometry
+00001a40: 7479 7065 6e61 6d65 2028 7374 7229 3a20  typename (str): 
+00001a50: 7468 6520 6e61 6d65 206f 6620 7468 6520  the name of the 
+00001a60: 6765 6f6d 6574 7279 2063 6f6c 756d 6e20  geometry column 
+00001a70: 7479 7065 2e0a 2020 2020 2020 2020 2020  type..          
+00001a80: 2020 6765 6f6d 6574 7279 7479 7065 2028    geometrytype (
+00001a90: 4765 6f6d 6574 7279 5479 7065 293a 2074  GeometryType): t
+00001aa0: 6865 2074 7970 6520 6f66 2074 6865 2067  he type of the g
+00001ab0: 656f 6d65 7472 7920 636f 6c75 6d6e 2e0a  eometry column..
+00001ac0: 2020 2020 2020 2020 2020 2020 636f 6c75              colu
+00001ad0: 6d6e 7320 2844 6963 745b 7374 722c 2043  mns (Dict[str, C
+00001ae0: 6f6c 756d 6e49 6e66 6f5d 293a 2074 6865  olumnInfo]): the
+00001af0: 2061 7474 7269 6275 7465 2063 6f6c 756d   attribute colum
+00001b00: 6e73 206f 6620 7468 6520 6c61 7965 722e  ns of the layer.
+00001b10: 0a20 2020 2020 2020 2020 2020 2066 6964  .            fid
+00001b20: 5f63 6f6c 756d 6e20 2873 7472 293a 2074  _column (str): t
+00001b30: 6865 206e 616d 6520 6f66 2074 6865 2066  he name of the f
+00001b40: 6964 2063 6f6c 756d 6e2e 0a20 2020 2020  id column..     
+00001b50: 2020 2020 2020 2063 7273 2028 4f70 7469         crs (Opti
+00001b60: 6f6e 616c 5b70 7970 726f 6a2e 4352 535d  onal[pyproj.CRS]
+00001b70: 293a 2074 6865 2063 7273 206f 6620 7468  ): the crs of th
+00001b80: 6520 6c61 7965 722e 0a20 2020 2020 2020  e layer..       
+00001b90: 2020 2020 2065 7272 6f72 7320 284c 6973       errors (Lis
+00001ba0: 745b 7374 725d 293a 2065 7272 6f72 7320  t[str]): errors 
+00001bb0: 656e 636f 756e 7465 7265 6420 7265 6164  encountered read
+00001bc0: 696e 6720 7468 6520 6c61 7965 7220 696e  ing the layer in
+00001bd0: 666f 2e0a 2020 2020 2020 2020 2222 220a  fo..        """.
+00001be0: 2020 2020 2020 2020 7365 6c66 2e6e 616d          self.nam
+00001bf0: 6520 3d20 6e61 6d65 0a20 2020 2020 2020  e = name.       
+00001c00: 2073 656c 662e 6665 6174 7572 6563 6f75   self.featurecou
+00001c10: 6e74 203d 2066 6561 7475 7265 636f 756e  nt = featurecoun
+00001c20: 740a 2020 2020 2020 2020 7365 6c66 2e74  t.        self.t
+00001c30: 6f74 616c 5f62 6f75 6e64 7320 3d20 746f  otal_bounds = to
+00001c40: 7461 6c5f 626f 756e 6473 0a20 2020 2020  tal_bounds.     
+00001c50: 2020 2073 656c 662e 6765 6f6d 6574 7279     self.geometry
+00001c60: 636f 6c75 6d6e 203d 2067 656f 6d65 7472  column = geometr
+00001c70: 7963 6f6c 756d 6e0a 2020 2020 2020 2020  ycolumn.        
+00001c80: 7365 6c66 2e67 656f 6d65 7472 7974 7970  self.geometrytyp
+00001c90: 656e 616d 6520 3d20 6765 6f6d 6574 7279  ename = geometry
+00001ca0: 7479 7065 6e61 6d65 0a20 2020 2020 2020  typename.       
+00001cb0: 2073 656c 662e 6765 6f6d 6574 7279 7479   self.geometryty
+00001cc0: 7065 203d 2067 656f 6d65 7472 7974 7970  pe = geometrytyp
+00001cd0: 650a 2020 2020 2020 2020 7365 6c66 2e63  e.        self.c
+00001ce0: 6f6c 756d 6e73 203d 2063 6f6c 756d 6e73  olumns = columns
+00001cf0: 0a20 2020 2020 2020 2073 656c 662e 6669  .        self.fi
+00001d00: 645f 636f 6c75 6d6e 203d 2066 6964 5f63  d_column = fid_c
+00001d10: 6f6c 756d 6e0a 2020 2020 2020 2020 7365  olumn.        se
+00001d20: 6c66 2e63 7273 203d 2063 7273 0a20 2020  lf.crs = crs.   
+00001d30: 2020 2020 2073 656c 662e 6572 726f 7273       self.errors
+00001d40: 203d 2065 7272 6f72 730a 0a20 2020 2064   = errors..    d
+00001d50: 6566 205f 5f72 6570 725f 5f28 7365 6c66  ef __repr__(self
+00001d60: 293a 0a20 2020 2020 2020 2022 2222 4f76  ):.        """Ov
+00001d70: 6572 7269 6465 7320 7468 6520 7265 7072  errides the repr
+00001d80: 6573 656e 7461 7469 6f6e 2070 726f 7065  esentation prope
+00001d90: 7274 7920 6f66 204c 6179 6572 496e 666f  rty of LayerInfo
+00001da0: 2e22 2222 0a20 2020 2020 2020 2072 6574  .""".        ret
+00001db0: 7572 6e20 6622 7b73 656c 662e 5f5f 636c  urn f"{self.__cl
+00001dc0: 6173 735f 5f7d 287b 7365 6c66 2e5f 5f64  ass__}({self.__d
+00001dd0: 6963 745f 5f7d 2922 0a0a 0a64 6566 2067  ict__})"...def g
+00001de0: 6574 5f6c 6179 6572 5f67 656f 6d65 7472  et_layer_geometr
+00001df0: 7974 7970 6573 280a 2020 2020 7061 7468  ytypes(.    path
+00001e00: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
+00001e10: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
+00001e20: 2c20 6c61 7965 723a 204f 7074 696f 6e61  , layer: Optiona
+00001e30: 6c5b 7374 725d 203d 204e 6f6e 650a 2920  l[str] = None.) 
+00001e40: 2d3e 204c 6973 745b 7374 725d 3a0a 2020  -> List[str]:.  
+00001e50: 2020 2222 220a 2020 2020 4765 7420 7468    """.    Get th
+00001e60: 6520 6765 6f6d 6574 7279 2074 7970 6573  e geometry types
+00001e70: 2069 6e20 7468 6520 6c61 7965 7220 6279   in the layer by
+00001e80: 2065 7861 6d69 6e69 6e67 2065 6163 6820   examining each 
+00001e90: 6765 6f6d 6574 7279 2069 6e20 7468 6520  geometry in the 
+00001ea0: 6c61 7965 722e 0a0a 2020 2020 5468 6520  layer...    The 
+00001eb0: 6765 6e65 7261 6c20 6765 6f6d 6574 7279  general geometry
+00001ec0: 2074 7970 6520 6f66 2074 6865 206c 6179   type of the lay
+00001ed0: 6572 2063 616e 2062 6520 6465 7465 726d  er can be determ
+00001ee0: 696e 6564 2075 7369 6e67 0a20 2020 203a  ined using.    :
+00001ef0: 6d65 7468 3a60 7e67 6574 5f6c 6179 6572  meth:`~get_layer
+00001f00: 696e 666f 602e 0a0a 2020 2020 4172 6773  info`...    Args
+00001f10: 3a0a 2020 2020 2020 2020 7061 7468 2028  :.        path (
+00001f20: 5061 7468 4c69 6b65 293a 2070 6174 6820  PathLike): path 
+00001f30: 746f 2074 6865 2066 696c 6520 746f 2067  to the file to g
+00001f40: 6574 2069 6e66 6f20 6162 6f75 740a 2020  et info about.  
+00001f50: 2020 2020 2020 6c61 7965 7220 2873 7472        layer (str
+00001f60: 293a 2074 6865 206c 6179 6572 2079 6f75  ): the layer you
+00001f70: 2077 616e 7420 696e 666f 2061 626f 7574   want info about
+00001f80: 2e20 446f 6573 6e27 7420 6e65 6564 2074  . Doesn't need t
+00001f90: 6f20 6265 0a20 2020 2020 2020 2020 2020  o be.           
+00001fa0: 2073 7065 6369 6669 6564 2069 6620 7468   specified if th
+00001fb0: 6572 6520 6973 206f 6e6c 7920 6f6e 6520  ere is only one 
+00001fc0: 6c61 7965 7220 696e 2074 6865 2067 656f  layer in the geo
+00001fd0: 6669 6c65 2e0a 0a20 2020 2052 6574 7572  file...    Retur
+00001fe0: 6e73 3a0a 2020 2020 2020 2020 4c69 7374  ns:.        List
+00001ff0: 5b73 7472 5d3a 2074 6865 2067 656f 6d65  [str]: the geome
+00002000: 7472 7920 7479 7065 7320 696e 2074 6865  try types in the
+00002010: 206c 6179 6572 2e0a 2020 2020 2222 220a   layer..    """.
+00002020: 2020 2020 7371 6c5f 7374 6d74 203d 2022      sql_stmt = "
+00002030: 2222 0a20 2020 2020 2020 2053 454c 4543  "".        SELEC
+00002040: 5420 4449 5354 494e 4354 0a20 2020 2020  T DISTINCT.     
+00002050: 2020 2020 2020 2020 2020 4341 5345 0a20            CASE. 
+00002060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002070: 5748 454e 2043 6173 7454 6f53 696e 676c  WHEN CastToSingl
+00002080: 6528 7b67 656f 6d65 7472 7963 6f6c 756d  e({geometrycolum
+00002090: 6e7d 2920 4953 204e 4f54 204e 554c 4c20  n}) IS NOT NULL 
+000020a0: 5448 454e 0a20 2020 2020 2020 2020 2020  THEN.           
+000020b0: 2020 2020 2020 2020 2020 5354 5f47 656f            ST_Geo
+000020c0: 6d65 7472 7954 7970 6528 4361 7374 546f  metryType(CastTo
+000020d0: 5369 6e67 6c65 287b 6765 6f6d 6574 7279  Single({geometry
+000020e0: 636f 6c75 6d6e 7d29 290a 2020 2020 2020  column})).      
+000020f0: 2020 2020 2020 2020 2020 2045 4c53 4520             ELSE 
+00002100: 5354 5f47 656f 6d65 7472 7954 7970 6528  ST_GeometryType(
+00002110: 7b67 656f 6d65 7472 7963 6f6c 756d 6e7d  {geometrycolumn}
+00002120: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00002130: 2045 4e44 2041 5320 6765 6f6d 5f74 7970   END AS geom_typ
+00002140: 650a 2020 2020 2020 2020 2020 4652 4f4d  e.          FROM
+00002150: 2022 7b69 6e70 7574 5f6c 6179 6572 7d22   "{input_layer}"
+00002160: 206c 6179 6572 0a20 2020 2022 2222 0a20   layer.    """. 
+00002170: 2020 2072 6573 756c 745f 6466 203d 2072     result_df = r
+00002180: 6561 645f 6669 6c65 2870 6174 682c 2073  ead_file(path, s
+00002190: 716c 5f73 746d 743d 7371 6c5f 7374 6d74  ql_stmt=sql_stmt
+000021a0: 2c20 7371 6c5f 6469 616c 6563 743d 2253  , sql_dialect="S
+000021b0: 514c 4954 4522 290a 2020 2020 7265 7475  QLITE").    retu
+000021c0: 726e 2072 6573 756c 745f 6466 5b22 6765  rn result_df["ge
+000021d0: 6f6d 5f74 7970 6522 5d2e 746f 5f6c 6973  om_type"].to_lis
+000021e0: 7428 290a 0a0a 6465 6620 6765 745f 6c61  t()...def get_la
+000021f0: 7965 7269 6e66 6f28 0a20 2020 2070 6174  yerinfo(.    pat
+00002200: 683a 2055 6e69 6f6e 5b73 7472 2c20 226f  h: Union[str, "o
+00002210: 732e 5061 7468 4c69 6b65 5b41 6e79 5d22  s.PathLike[Any]"
+00002220: 5d2c 0a20 2020 206c 6179 6572 3a20 4f70  ],.    layer: Op
+00002230: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
+00002240: 6e65 2c0a 2020 2020 7261 6973 655f 6f6e  ne,.    raise_on
+00002250: 5f6e 6f67 656f 6d3a 2062 6f6f 6c20 3d20  _nogeom: bool = 
+00002260: 5472 7565 2c0a 2920 2d3e 204c 6179 6572  True,.) -> Layer
+00002270: 496e 666f 3a0a 2020 2020 2222 220a 2020  Info:.    """.  
+00002280: 2020 4765 7420 696e 666f 726d 6174 696f    Get informatio
+00002290: 6e20 6162 6f75 7420 6120 6c61 7965 7220  n about a layer 
+000022a0: 696e 2074 6865 2067 656f 6669 6c65 2e0a  in the geofile..
+000022b0: 0a20 2020 2052 6169 7365 7320 5661 6c75  .    Raises Valu
+000022c0: 6545 7272 6f72 2069 6620 7468 6520 6c61  eError if the la
+000022d0: 7965 7220 6465 6669 6e69 7469 6f6e 2068  yer definition h
+000022e0: 6173 2065 7272 6f72 7320 6c69 6b65 2069  as errors like i
+000022f0: 6e76 616c 6964 2063 6f6c 756d 6e20 6e61  nvalid column na
+00002300: 6d65 732c 2e2e 2e0a 0a20 2020 2041 7267  mes,.....    Arg
+00002310: 733a 0a20 2020 2020 2020 2070 6174 6820  s:.        path 
+00002320: 2850 6174 684c 696b 6529 3a20 7061 7468  (PathLike): path
+00002330: 2074 6f20 7468 6520 6669 6c65 2074 6f20   to the file to 
+00002340: 6765 7420 696e 666f 2061 626f 7574 0a20  get info about. 
+00002350: 2020 2020 2020 206c 6179 6572 2028 7374         layer (st
+00002360: 722c 206f 7074 696f 6e61 6c29 3a20 7468  r, optional): th
+00002370: 6520 6c61 7965 7220 796f 7520 7761 6e74  e layer you want
+00002380: 2069 6e66 6f20 6162 6f75 742e 2044 6f65   info about. Doe
+00002390: 736e 2774 206e 6565 6420 746f 2062 650a  sn't need to be.
+000023a0: 2020 2020 2020 2020 2020 2020 7370 6563              spec
+000023b0: 6966 6965 6420 6966 2074 6865 7265 2069  ified if there i
+000023c0: 7320 6f6e 6c79 206f 6e65 206c 6179 6572  s only one layer
+000023d0: 2069 6e20 7468 6520 6765 6f66 696c 652e   in the geofile.
+000023e0: 0a20 2020 2020 2020 2072 6169 7365 5f6f  .        raise_o
+000023f0: 6e5f 6e6f 6765 6f6d 2028 626f 6f6c 2c20  n_nogeom (bool, 
+00002400: 6f70 7469 6f6e 616c 293a 2054 7275 6520  optional): True 
+00002410: 746f 2072 6169 7365 2069 6620 7468 6520  to raise if the 
+00002420: 6c61 7965 7220 646f 6573 6e27 7420 6861  layer doesn't ha
+00002430: 7665 2061 0a20 2020 2020 2020 2020 2020  ve a.           
+00002440: 2067 656f 6d65 7472 7920 636f 6c75 6d6e   geometry column
+00002450: 2e20 4966 2046 616c 7365 2c20 7468 6520  . If False, the 
+00002460: 7265 7475 726e 6564 204c 6179 6572 496e  returned LayerIn
+00002470: 666f 2e67 656f 6d65 7472 7963 6f6c 756d  fo.geometrycolum
+00002480: 6e20 7769 6c6c 2062 650a 2020 2020 2020  n will be.      
+00002490: 2020 2020 2020 4e6f 6e65 2e20 4465 6661        None. Defa
+000024a0: 756c 7473 2074 6f20 5472 7565 2e0a 0a20  ults to True... 
+000024b0: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
+000024c0: 2020 2020 4c61 7965 7249 6e66 6f3a 2074      LayerInfo: t
+000024d0: 6865 2069 6e66 6f72 6d61 7469 6f6e 2061  he information a
+000024e0: 626f 7574 2074 6865 206c 6179 6572 2e0a  bout the layer..
+000024f0: 2020 2020 2222 220a 2020 2020 2320 496e      """.    # In
+00002500: 6974 0a20 2020 2070 6174 6820 3d20 5061  it.    path = Pa
+00002510: 7468 2870 6174 6829 0a20 2020 2069 6620  th(path).    if 
+00002520: 6e6f 7420 7061 7468 2e65 7869 7374 7328  not path.exists(
+00002530: 293a 0a20 2020 2020 2020 2072 6169 7365  ):.        raise
+00002540: 2056 616c 7565 4572 726f 7228 6622 696e   ValueError(f"in
+00002550: 7075 745f 7061 7468 2064 6f65 736e 2774  put_path doesn't
+00002560: 2065 7869 7374 3a20 7b70 6174 687d 2229   exist: {path}")
+00002570: 0a0a 2020 2020 6966 206c 6179 6572 2069  ..    if layer i
+00002580: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+00002590: 6c61 7965 7220 3d20 6765 745f 6f6e 6c79  layer = get_only
+000025a0: 5f6c 6179 6572 2870 6174 6829 0a0a 2020  _layer(path)..  
+000025b0: 2020 6461 7461 736f 7572 6365 203d 204e    datasource = N
+000025c0: 6f6e 650a 2020 2020 7472 793a 0a20 2020  one.    try:.   
+000025d0: 2020 2020 2064 6174 6173 6f75 7263 6520       datasource 
+000025e0: 3d20 6764 616c 2e4f 7065 6e45 7828 0a20  = gdal.OpenEx(. 
+000025f0: 2020 2020 2020 2020 2020 2073 7472 2870             str(p
+00002600: 6174 6829 2c20 6e4f 7065 6e46 6c61 6773  ath), nOpenFlags
+00002610: 3d67 6461 6c2e 4f46 5f56 4543 544f 5220  =gdal.OF_VECTOR 
+00002620: 7c20 6764 616c 2e4f 465f 5245 4144 4f4e  | gdal.OF_READON
+00002630: 4c59 207c 2067 6461 6c2e 4f46 5f53 4841  LY | gdal.OF_SHA
+00002640: 5245 440a 2020 2020 2020 2020 290a 2020  RED.        ).  
+00002650: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
+00002660: 5f6c 6179 6572 203d 2064 6174 6173 6f75  _layer = datasou
+00002670: 7263 652e 4765 744c 6179 6572 286c 6179  rce.GetLayer(lay
+00002680: 6572 290a 0a20 2020 2020 2020 2023 2049  er)..        # I
+00002690: 6620 7468 6520 6c61 7965 7220 646f 6573  f the layer does
+000026a0: 6e27 7420 6578 6973 742c 2072 6574 7572  n't exist, retur
+000026b0: 6e0a 2020 2020 2020 2020 6966 2064 6174  n.        if dat
+000026c0: 6173 6f75 7263 655f 6c61 7965 7220 6973  asource_layer is
+000026d0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+000026e0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+000026f0: 726f 7228 6622 4c61 7965 7220 7b6c 6179  ror(f"Layer {lay
+00002700: 6572 7d20 6e6f 7420 666f 756e 6420 696e  er} not found in
+00002710: 2066 696c 653a 207b 7061 7468 7d22 290a   file: {path}").
+00002720: 0a20 2020 2020 2020 2023 2047 6574 2063  .        # Get c
+00002730: 6f6c 756d 6e20 696e 666f 0a20 2020 2020  olumn info.     
+00002740: 2020 2063 6f6c 756d 6e73 203d 207b 7d0a     columns = {}.
+00002750: 2020 2020 2020 2020 6572 726f 7273 203d          errors =
+00002760: 205b 5d0a 2020 2020 2020 2020 6472 6976   [].        driv
+00002770: 6572 203d 2064 6174 6173 6f75 7263 652e  er = datasource.
+00002780: 4765 7444 7269 7665 7228 292e 5368 6f72  GetDriver().Shor
+00002790: 744e 616d 650a 2020 2020 2020 2020 6c61  tName.        la
+000027a0: 7965 725f 6465 666e 203d 2064 6174 6173  yer_defn = datas
+000027b0: 6f75 7263 655f 6c61 7965 722e 4765 744c  ource_layer.GetL
+000027c0: 6179 6572 4465 666e 2829 0a20 2020 2020  ayerDefn().     
+000027d0: 2020 2066 6f72 2069 2069 6e20 7261 6e67     for i in rang
+000027e0: 6528 6c61 7965 725f 6465 666e 2e47 6574  e(layer_defn.Get
+000027f0: 4669 656c 6443 6f75 6e74 2829 293a 0a20  FieldCount()):. 
+00002800: 2020 2020 2020 2020 2020 206e 616d 6520             name 
+00002810: 3d20 6c61 7965 725f 6465 666e 2e47 6574  = layer_defn.Get
+00002820: 4669 656c 6444 6566 6e28 6929 2e47 6574  FieldDefn(i).Get
+00002830: 4e61 6d65 2829 0a20 2020 2020 2020 2020  Name().         
+00002840: 2020 2023 2054 4f44 4f3a 2074 6869 6e6b     # TODO: think
+00002850: 2077 6865 7468 6572 2074 6865 2074 7970   whether the typ
+00002860: 6520 6e61 6d65 2073 686f 756c 6420 6265  e name should be
+00002870: 2063 6f6e 7665 7274 6564 2074 6f20 6f74   converted to ot
+00002880: 6865 7220 6e61 6d65 730a 2020 2020 2020  her names.      
+00002890: 2020 2020 2020 6764 616c 5f74 7970 6520        gdal_type 
+000028a0: 3d20 6c61 7965 725f 6465 666e 2e47 6574  = layer_defn.Get
+000028b0: 4669 656c 6444 6566 6e28 6929 2e47 6574  FieldDefn(i).Get
+000028c0: 5479 7065 4e61 6d65 2829 0a20 2020 2020  TypeName().     
+000028d0: 2020 2020 2020 2077 6964 7468 203d 206c         width = l
+000028e0: 6179 6572 5f64 6566 6e2e 4765 7446 6965  ayer_defn.GetFie
+000028f0: 6c64 4465 666e 2869 292e 4765 7457 6964  ldDefn(i).GetWid
+00002900: 7468 2829 0a20 2020 2020 2020 2020 2020  th().           
+00002910: 2077 6964 7468 203d 2077 6964 7468 2069   width = width i
+00002920: 6620 7769 6474 6820 3e20 3020 656c 7365  f width > 0 else
+00002930: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
+00002940: 2020 7072 6563 6973 696f 6e20 3d20 6c61    precision = la
+00002950: 7965 725f 6465 666e 2e47 6574 4669 656c  yer_defn.GetFiel
+00002960: 6444 6566 6e28 6929 2e47 6574 5072 6563  dDefn(i).GetPrec
+00002970: 6973 696f 6e28 290a 2020 2020 2020 2020  ision().        
+00002980: 2020 2020 7072 6563 6973 696f 6e20 3d20      precision = 
+00002990: 7072 6563 6973 696f 6e20 6966 2070 7265  precision if pre
+000029a0: 6369 7369 6f6e 203e 2030 2065 6c73 6520  cision > 0 else 
+000029b0: 4e6f 6e65 0a20 2020 2020 2020 2020 2020  None.           
+000029c0: 2069 6c6c 6567 616c 5f63 6f6c 756d 6e5f   illegal_column_
+000029d0: 6368 6172 7320 3d20 5b27 2227 5d0a 2020  chars = ['"'].  
+000029e0: 2020 2020 2020 2020 2020 666f 7220 696c            for il
+000029f0: 6c65 6761 6c5f 6368 6172 2069 6e20 696c  legal_char in il
+00002a00: 6c65 6761 6c5f 636f 6c75 6d6e 5f63 6861  legal_column_cha
+00002a10: 7273 3a0a 2020 2020 2020 2020 2020 2020  rs:.            
+00002a20: 2020 2020 6966 2069 6c6c 6567 616c 5f63      if illegal_c
+00002a30: 6861 7220 696e 206e 616d 653a 0a20 2020  har in name:.   
+00002a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002a50: 2065 7272 6f72 732e 6170 7065 6e64 280a   errors.append(.
+00002a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002a70: 2020 2020 2020 2020 6622 436f 6c75 6d6e          f"Column
+00002a80: 206e 616d 6520 7b6e 616d 657d 2063 6f6e   name {name} con
+00002a90: 7461 696e 7320 696c 6c65 6761 6c20 6368  tains illegal ch
+00002aa0: 6172 3a20 7b69 6c6c 6567 616c 5f63 6861  ar: {illegal_cha
+00002ab0: 727d 2022 0a20 2020 2020 2020 2020 2020  r} ".           
+00002ac0: 2020 2020 2020 2020 2020 2020 2066 2269               f"i
+00002ad0: 6e20 6669 6c65 207b 7061 7468 7d2c 206c  n file {path}, l
+00002ae0: 6179 6572 207b 6c61 7965 727d 220a 2020  ayer {layer}".  
+00002af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002b00: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+00002b10: 636f 6c75 6d6e 5f69 6e66 6f20 3d20 436f  column_info = Co
+00002b20: 6c75 6d6e 496e 666f 280a 2020 2020 2020  lumnInfo(.      
+00002b30: 2020 2020 2020 2020 2020 6e61 6d65 3d6e            name=n
+00002b40: 616d 652c 2067 6461 6c5f 7479 7065 3d67  ame, gdal_type=g
+00002b50: 6461 6c5f 7479 7065 2c20 7769 6474 683d  dal_type, width=
+00002b60: 7769 6474 682c 2070 7265 6369 7369 6f6e  width, precision
+00002b70: 3d70 7265 6369 7369 6f6e 0a20 2020 2020  =precision.     
+00002b80: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00002b90: 2020 2020 2063 6f6c 756d 6e73 5b6e 616d       columns[nam
+00002ba0: 655d 203d 2063 6f6c 756d 6e5f 696e 666f  e] = column_info
+00002bb0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00002bc0: 6472 6976 6572 203d 3d20 2245 5352 4920  driver == "ESRI 
+00002bd0: 5368 6170 6566 696c 6522 3a0a 2020 2020  Shapefile":.    
+00002be0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00002bf0: 616d 652e 6361 7365 666f 6c64 2829 203d  ame.casefold() =
+00002c00: 3d20 2267 656f 6d65 7472 7922 3a0a 2020  = "geometry":.  
+00002c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002c20: 2020 6572 726f 7273 2e61 7070 656e 6428    errors.append(
+00002c30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002c40: 2020 2020 2020 2020 2022 416e 2061 7474           "An att
+00002c50: 7269 6275 7465 2063 6f6c 756d 6e20 2767  ribute column 'g
+00002c60: 656f 6d65 7472 7927 2069 7320 6e6f 7420  eometry' is not 
+00002c70: 7375 7070 6f72 7465 6420 696e 2061 2073  supported in a s
+00002c80: 6861 7065 6669 6c65 220a 2020 2020 2020  hapefile".      
+00002c90: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00002ca0: 0a20 2020 2020 2020 2023 2047 6574 2067  .        # Get g
+00002cb0: 656f 6d65 7472 7920 636f 6c75 6d6e 2069  eometry column i
+00002cc0: 6e66 6f2e 2e2e 0a20 2020 2020 2020 2067  nfo....        g
+00002cd0: 656f 6d65 7472 7974 7970 6520 3d20 5f6f  eometrytype = _o
+00002ce0: 6772 5f75 7469 6c2e 6f67 7274 7970 655f  gr_util.ogrtype_
+00002cf0: 746f 5f67 656f 6d65 7472 7974 7970 655b  to_geometrytype[
+00002d00: 6461 7461 736f 7572 6365 5f6c 6179 6572  datasource_layer
+00002d10: 2e47 6574 4765 6f6d 5479 7065 2829 5d0a  .GetGeomType()].
+00002d20: 2020 2020 2020 2020 6966 2067 656f 6d65          if geome
+00002d30: 7472 7974 7970 6520 6973 204e 6f6e 653a  trytype is None:
+00002d40: 0a20 2020 2020 2020 2020 2020 2067 656f  .            geo
+00002d50: 6d65 7472 7974 7970 656e 616d 6520 3d20  metrytypename = 
+00002d60: 224e 4f4e 4522 0a20 2020 2020 2020 2065  "NONE".        e
+00002d70: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00002d80: 2023 2046 6f72 2073 6861 7065 2066 696c   # For shape fil
+00002d90: 6573 2c20 7468 6520 6469 6666 6572 656e  es, the differen
+00002da0: 6365 2062 6574 7765 656e 2074 6865 2027  ce between the '
+00002db0: 4d55 4c54 4927 2076 6172 6961 6e74 2061  MULTI' variant a
+00002dc0: 6e64 2074 6865 0a20 2020 2020 2020 2020  nd the.         
+00002dd0: 2020 2023 2073 696e 676c 6520 6f6e 6520     # single one 
+00002de0: 646f 6573 6e27 7420 6578 6973 7473 2e2e  doesn't exists..
+00002df0: 2e20 736f 2061 6c77 6179 7320 7265 706f  . so always repo
+00002e00: 7274 204d 554c 5449 2076 6172 6961 6e74  rt MULTI variant
+00002e10: 2062 7920 636f 6e76 656e 7469 6f6e 2e0a   by convention..
+00002e20: 2020 2020 2020 2020 2020 2020 6966 2064              if d
+00002e30: 7269 7665 7220 3d3d 2022 4553 5249 2053  river == "ESRI S
+00002e40: 6861 7065 6669 6c65 223a 0a20 2020 2020  hapefile":.     
+00002e50: 2020 2020 2020 2020 2020 2067 656f 6d65             geome
+00002e60: 7472 7974 7970 6520 3d20 6765 6f6d 6574  trytype = geomet
+00002e70: 7279 7479 7065 2e74 6f5f 6d75 6c74 6974  rytype.to_multit
+00002e80: 7970 650a 0a20 2020 2020 2020 2020 2020  ype..           
+00002e90: 2067 656f 6d65 7472 7974 7970 656e 616d   geometrytypenam
+00002ea0: 6520 3d20 6765 6f6d 6574 7279 7479 7065  e = geometrytype
+00002eb0: 2e6e 616d 650a 0a20 2020 2020 2020 2023  .name..        #
+00002ec0: 2049 6620 7468 6520 6765 6f6d 6574 7279   If the geometry
+00002ed0: 2074 7970 6520 6973 206e 6f74 204e 6f6e   type is not Non
+00002ee0: 652c 2066 696c 6c20 6f75 7420 7468 6520  e, fill out the 
+00002ef0: 6578 7472 6120 7072 6f70 6572 7469 6573  extra properties
+00002f00: 0a20 2020 2020 2020 2067 656f 6d65 7472  .        geometr
+00002f10: 7963 6f6c 756d 6e20 3d20 4e6f 6e65 0a20  ycolumn = None. 
+00002f20: 2020 2020 2020 2065 7874 656e 7420 3d20         extent = 
+00002f30: 4e6f 6e65 0a20 2020 2020 2020 2063 7273  None.        crs
+00002f40: 203d 204e 6f6e 650a 2020 2020 2020 2020   = None.        
+00002f50: 746f 7461 6c5f 626f 756e 6473 203d 204e  total_bounds = N
+00002f60: 6f6e 650a 2020 2020 2020 2020 6966 2067  one.        if g
+00002f70: 656f 6d65 7472 7974 7970 6520 6973 206e  eometrytype is n
+00002f80: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+00002f90: 2020 2020 2023 2047 656f 6d65 7472 7920       # Geometry 
+00002fa0: 636f 6c75 6d6e 206e 616d 650a 2020 2020  column name.    
+00002fb0: 2020 2020 2020 2020 6765 6f6d 6574 7279          geometry
+00002fc0: 636f 6c75 6d6e 203d 2064 6174 6173 6f75  column = datasou
+00002fd0: 7263 655f 6c61 7965 722e 4765 7447 656f  rce_layer.GetGeo
+00002fe0: 6d65 7472 7943 6f6c 756d 6e28 290a 2020  metryColumn().  
+00002ff0: 2020 2020 2020 2020 2020 6966 2067 656f            if geo
+00003000: 6d65 7472 7963 6f6c 756d 6e20 3d3d 2022  metrycolumn == "
+00003010: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
+00003020: 2020 2067 656f 6d65 7472 7963 6f6c 756d     geometrycolum
+00003030: 6e20 3d20 2267 656f 6d65 7472 7922 0a20  n = "geometry". 
+00003040: 2020 2020 2020 2020 2020 2023 2043 6f6e             # Con
+00003050: 7665 7274 2065 7874 656e 7420 2878 6d69  vert extent (xmi
+00003060: 6e2c 2078 6d61 782c 2079 6d69 6e2c 2079  n, xmax, ymin, y
+00003070: 6d61 7829 2074 6f20 626f 756e 6473 2028  max) to bounds (
+00003080: 786d 696e 2c20 796d 696e 2c20 786d 6178  xmin, ymin, xmax
+00003090: 2c20 796d 6178 290a 2020 2020 2020 2020  , ymax).        
+000030a0: 2020 2020 6578 7465 6e74 203d 2064 6174      extent = dat
+000030b0: 6173 6f75 7263 655f 6c61 7965 722e 4765  asource_layer.Ge
+000030c0: 7445 7874 656e 7428 290a 2020 2020 2020  tExtent().      
+000030d0: 2020 2020 2020 746f 7461 6c5f 626f 756e        total_boun
+000030e0: 6473 203d 2028 6578 7465 6e74 5b30 5d2c  ds = (extent[0],
+000030f0: 2065 7874 656e 745b 325d 2c20 6578 7465   extent[2], exte
+00003100: 6e74 5b31 5d2c 2065 7874 656e 745b 335d  nt[1], extent[3]
+00003110: 290a 2020 2020 2020 2020 2020 2020 2320  ).            # 
+00003120: 4352 530a 2020 2020 2020 2020 2020 2020  CRS.            
+00003130: 7370 6174 6961 6c72 6566 203d 2064 6174  spatialref = dat
+00003140: 6173 6f75 7263 655f 6c61 7965 722e 4765  asource_layer.Ge
+00003150: 7453 7061 7469 616c 5265 6628 290a 2020  tSpatialRef().  
+00003160: 2020 2020 2020 2020 2020 6966 2073 7061            if spa
+00003170: 7469 616c 7265 6620 6973 206e 6f74 204e  tialref is not N
+00003180: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00003190: 2020 2020 2063 7273 203d 2070 7970 726f       crs = pypro
+000031a0: 6a2e 4352 5328 7370 6174 6961 6c72 6566  j.CRS(spatialref
+000031b0: 2e45 7870 6f72 7454 6f57 6b74 2829 290a  .ExportToWkt()).
+000031c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000031d0: 2023 2049 6620 7370 6174 6961 6c20 7265   # If spatial re
+000031e0: 6620 6861 7320 6e6f 2065 7073 672c 2074  f has no epsg, t
+000031f0: 7279 2074 6f20 6669 6e64 2063 6f72 7265  ry to find corre
+00003200: 7370 6f6e 6469 6e67 206f 6e65 0a20 2020  sponding one.   
+00003210: 2020 2020 2020 2020 2020 2020 2063 7273               crs
+00003220: 5f65 7073 6720 3d20 6372 732e 746f 5f65  _epsg = crs.to_e
+00003230: 7073 6728 290a 2020 2020 2020 2020 2020  psg().          
+00003240: 2020 2020 2020 6966 2063 7273 5f65 7073        if crs_eps
+00003250: 6720 6973 204e 6f6e 653a 0a20 2020 2020  g is None:.     
+00003260: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00003270: 6620 6372 732e 6e61 6d65 2069 6e20 5b0a  f crs.name in [.
+00003280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003290: 2020 2020 2020 2020 2242 656c 6765 2031          "Belge 1
+000032a0: 3937 3220 2f20 4265 6c67 6961 6e20 4c61  972 / Belgian La
+000032b0: 6d62 6572 7420 3732 222c 0a20 2020 2020  mbert 72",.     
+000032c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000032d0: 2020 2022 4265 6c67 655f 3139 3732 5f42     "Belge_1972_B
+000032e0: 656c 6769 616e 5f4c 616d 6265 7274 5f37  elgian_Lambert_7
+000032f0: 3222 2c0a 2020 2020 2020 2020 2020 2020  2",.            
+00003300: 2020 2020 2020 2020 2020 2020 2242 656c              "Bel
+00003310: 6765 5f4c 616d 6265 7274 5f31 3937 3222  ge_Lambert_1972"
+00003320: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00003330: 2020 2020 2020 2020 2020 2242 4437 3220            "BD72 
+00003340: 2f20 4265 6c67 6961 6e20 4c61 6d62 6572  / Belgian Lamber
+00003350: 7420 3732 222c 0a20 2020 2020 2020 2020  t 72",.         
+00003360: 2020 2020 2020 2020 2020 205d 3a0a 2020             ]:.  
+00003370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003380: 2020 2020 2020 2320 4265 6c67 6961 6e20        # Belgian 
+00003390: 4c61 6d62 6572 7420 696e 206e 616d 652c  Lambert in name,
+000033a0: 2073 6f20 6173 7375 6d65 2033 3133 3730   so assume 31370
+000033b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000033c0: 2020 2020 2020 2020 2063 7273 203d 2070           crs = p
+000033d0: 7970 726f 6a2e 4352 532e 6672 6f6d 5f65  yproj.CRS.from_e
+000033e0: 7073 6728 3331 3337 3029 0a0a 2020 2020  psg(31370)..    
+000033f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003400: 2020 2020 2320 4966 2073 6861 7065 6669      # If shapefi
+00003410: 6c65 2c20 6164 6420 636f 7272 6563 7420  le, add correct 
+00003420: 3331 3337 3020 2e70 726a 2066 696c 650a  31370 .prj file.
+00003430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003440: 2020 2020 2020 2020 6966 2064 7269 7665          if drive
+00003450: 7220 3d3d 2022 4553 5249 2053 6861 7065  r == "ESRI Shape
+00003460: 6669 6c65 223a 0a20 2020 2020 2020 2020  file":.         
 00003470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003480: 2020 2022 4265 6c67 655f 4c61 6d62 6572     "Belge_Lamber
-00003490: 745f 3139 3732 222c 0d0a 2020 2020 2020  t_1972",..      
-000034a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000034b0: 2020 2242 4437 3220 2f20 4265 6c67 6961    "BD72 / Belgia
-000034c0: 6e20 4c61 6d62 6572 7420 3732 222c 0d0a  n Lambert 72",..
-000034d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000034e0: 2020 2020 5d3a 0d0a 2020 2020 2020 2020      ]:..        
+00003480: 2020 2070 726a 5f70 6174 6820 3d20 7061     prj_path = pa
+00003490: 7468 2e70 6172 656e 7420 2f20 6622 7b70  th.parent / f"{p
+000034a0: 6174 682e 7374 656d 7d2e 7072 6a22 0a20  ath.stem}.prj". 
+000034b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000034c0: 2020 2020 2020 2020 2020 2069 6620 7072             if pr
+000034d0: 6a5f 7061 7468 2e65 7869 7374 7328 293a  j_path.exists():
+000034e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 000034f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003500: 2320 4265 6c67 6961 6e20 4c61 6d62 6572  # Belgian Lamber
-00003510: 7420 696e 206e 616d 652c 2073 6f20 6173  t in name, so as
-00003520: 7375 6d65 2033 3133 3730 0d0a 2020 2020  sume 31370..    
-00003530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003540: 2020 2020 6372 7320 3d20 7079 7072 6f6a      crs = pyproj
-00003550: 2e43 5253 2e66 726f 6d5f 6570 7367 2833  .CRS.from_epsg(3
-00003560: 3133 3730 290d 0a0d 0a20 2020 2020 2020  1370)....       
-00003570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003580: 2023 2049 6620 7368 6170 6566 696c 652c   # If shapefile,
-00003590: 2061 6464 2063 6f72 7265 6374 2033 3133   add correct 313
-000035a0: 3730 202e 7072 6a20 6669 6c65 0d0a 2020  70 .prj file..  
-000035b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000035c0: 2020 2020 2020 6966 2064 7269 7665 7220        if driver 
-000035d0: 3d3d 2022 4553 5249 2053 6861 7065 6669  == "ESRI Shapefi
-000035e0: 6c65 223a 0d0a 2020 2020 2020 2020 2020  le":..          
+00003500: 2070 726a 5f72 656e 616d 655f 7061 7468   prj_rename_path
+00003510: 203d 2070 6174 682e 7061 7265 6e74 202f   = path.parent /
+00003520: 2066 227b 7061 7468 2e73 7465 6d7d 5f6f   f"{path.stem}_o
+00003530: 7269 672e 7072 6a22 0a20 2020 2020 2020  rig.prj".       
+00003540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003550: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
+00003560: 7072 6a5f 7265 6e61 6d65 5f70 6174 682e  prj_rename_path.
+00003570: 6578 6973 7473 2829 3a0a 2020 2020 2020  exists():.      
+00003580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003590: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+000035a0: 6a5f 7061 7468 2e72 656e 616d 6528 7072  j_path.rename(pr
+000035b0: 6a5f 7265 6e61 6d65 5f70 6174 6829 0a20  j_rename_path). 
+000035c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000035d0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+000035e0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
 000035f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003600: 2020 7072 6a5f 7061 7468 203d 2070 6174    prj_path = pat
-00003610: 682e 7061 7265 6e74 202f 2066 227b 7061  h.parent / f"{pa
-00003620: 7468 2e73 7465 6d7d 2e70 726a 220d 0a20  th.stem}.prj".. 
-00003630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003640: 2020 2020 2020 2020 2020 2069 6620 7072             if pr
-00003650: 6a5f 7061 7468 2e65 7869 7374 7328 293a  j_path.exists():
-00003660: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00003670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003680: 2020 7072 6a5f 7265 6e61 6d65 5f70 6174    prj_rename_pat
-00003690: 6820 3d20 7061 7468 2e70 6172 656e 7420  h = path.parent 
-000036a0: 2f20 6622 7b70 6174 682e 7374 656d 7d5f  / f"{path.stem}_
-000036b0: 6f72 6967 2e70 726a 220d 0a20 2020 2020  orig.prj"..     
-000036c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000036d0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
-000036e0: 7420 7072 6a5f 7265 6e61 6d65 5f70 6174  t prj_rename_pat
-000036f0: 682e 6578 6973 7473 2829 3a0d 0a20 2020  h.exists():..   
-00003700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003720: 2070 726a 5f70 6174 682e 7265 6e61 6d65   prj_path.rename
-00003730: 2870 726a 5f72 656e 616d 655f 7061 7468  (prj_rename_path
-00003740: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-00003750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003760: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-00003770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003780: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00003790: 6a5f 7061 7468 2e75 6e6c 696e 6b28 290d  j_path.unlink().
-000037a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000037b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000037c0: 2070 726a 5f70 6174 682e 7772 6974 655f   prj_path.write_
-000037d0: 7465 7874 2850 524a 5f45 5053 475f 3331  text(PRJ_EPSG_31
-000037e0: 3337 3029 0d0a 2020 2020 2020 2020 656c  370)..        el
-000037f0: 6966 2072 6169 7365 5f6f 6e5f 6e6f 6765  if raise_on_noge
-00003800: 6f6d 3a0d 0a20 2020 2020 2020 2020 2020  om:..           
-00003810: 2065 7272 6f72 732e 6170 7065 6e64 2822   errors.append("
-00003820: 4c61 7965 7220 646f 6573 6e27 7420 6861  Layer doesn't ha
-00003830: 7665 2061 2067 656f 6d65 7472 7920 636f  ve a geometry co
-00003840: 6c75 6d6e 2122 290d 0a0d 0a20 2020 2020  lumn!")....     
-00003850: 2020 2023 2049 6620 7468 6572 6520 7765     # If there we
-00003860: 7265 206e 6f20 6572 726f 7273 2c20 6576  re no errors, ev
-00003870: 6572 7974 6869 6e67 2077 6173 204f 4b20  erything was OK 
-00003880: 736f 2077 6520 6361 6e20 7265 7475 726e  so we can return
-00003890: 2e0d 0a20 2020 2020 2020 2069 6620 6c65  ...        if le
-000038a0: 6e28 6572 726f 7273 2920 3d3d 2030 3a0d  n(errors) == 0:.
-000038b0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-000038c0: 7572 6e20 4c61 7965 7249 6e66 6f28 0d0a  urn LayerInfo(..
-000038d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000038e0: 6e61 6d65 3d64 6174 6173 6f75 7263 655f  name=datasource_
-000038f0: 6c61 7965 722e 4765 744e 616d 6528 292c  layer.GetName(),
-00003900: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00003910: 2020 6665 6174 7572 6563 6f75 6e74 3d64    featurecount=d
-00003920: 6174 6173 6f75 7263 655f 6c61 7965 722e  atasource_layer.
-00003930: 4765 7446 6561 7475 7265 436f 756e 7428  GetFeatureCount(
-00003940: 292c 0d0a 2020 2020 2020 2020 2020 2020  ),..            
-00003950: 2020 2020 746f 7461 6c5f 626f 756e 6473      total_bounds
-00003960: 3d74 6f74 616c 5f62 6f75 6e64 732c 2020  =total_bounds,  
-00003970: 2320 7479 7065 3a20 6967 6e6f 7265 5b61  # type: ignore[a
-00003980: 7267 2d74 7970 655d 0d0a 2020 2020 2020  rg-type]..      
-00003990: 2020 2020 2020 2020 2020 6765 6f6d 6574            geomet
-000039a0: 7279 636f 6c75 6d6e 3d67 656f 6d65 7472  rycolumn=geometr
-000039b0: 7963 6f6c 756d 6e2c 2020 2320 7479 7065  ycolumn,  # type
-000039c0: 3a20 6967 6e6f 7265 5b61 7267 2d74 7970  : ignore[arg-typ
-000039d0: 655d 0d0a 2020 2020 2020 2020 2020 2020  e]..            
-000039e0: 2020 2020 6765 6f6d 6574 7279 7479 7065      geometrytype
-000039f0: 6e61 6d65 3d67 656f 6d65 7472 7974 7970  name=geometrytyp
-00003a00: 656e 616d 652c 0d0a 2020 2020 2020 2020  ename,..        
-00003a10: 2020 2020 2020 2020 6765 6f6d 6574 7279          geometry
-00003a20: 7479 7065 3d67 656f 6d65 7472 7974 7970  type=geometrytyp
-00003a30: 652c 2020 2320 7479 7065 3a20 6967 6e6f  e,  # type: igno
-00003a40: 7265 5b61 7267 2d74 7970 655d 0d0a 2020  re[arg-type]..  
-00003a50: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00003a60: 6c75 6d6e 733d 636f 6c75 6d6e 732c 0d0a  lumns=columns,..
-00003a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003a80: 6669 645f 636f 6c75 6d6e 3d64 6174 6173  fid_column=datas
-00003a90: 6f75 7263 655f 6c61 7965 722e 4765 7446  ource_layer.GetF
-00003aa0: 4944 436f 6c75 6d6e 2829 2c0d 0a20 2020  IDColumn(),..   
-00003ab0: 2020 2020 2020 2020 2020 2020 2063 7273               crs
-00003ac0: 3d63 7273 2c0d 0a20 2020 2020 2020 2020  =crs,..         
-00003ad0: 2020 2020 2020 2065 7272 6f72 733d 6572         errors=er
-00003ae0: 726f 7273 2c0d 0a20 2020 2020 2020 2020  rors,..         
-00003af0: 2020 2029 0d0a 0d0a 2020 2020 6578 6365     )....    exce
-00003b00: 7074 2045 7863 6570 7469 6f6e 2061 7320  pt Exception as 
-00003b10: 6578 3a0d 0a20 2020 2020 2020 2065 782e  ex:..        ex.
-00003b20: 6172 6773 203d 2028 6622 6765 745f 6c61  args = (f"get_la
-00003b30: 7965 7269 6e66 6f20 6572 726f 7220 666f  yerinfo error fo
-00003b40: 7220 7b70 6174 687d 2e7b 6c61 7965 727d  r {path}.{layer}
-00003b50: 3a5c 6e20 207b 6578 7d22 2c29 0d0a 2020  :\n  {ex}",)..  
-00003b60: 2020 2020 2020 7261 6973 650d 0a20 2020        raise..   
-00003b70: 2066 696e 616c 6c79 3a0d 0a20 2020 2020   finally:..     
-00003b80: 2020 2064 6174 6173 6f75 7263 6520 3d20     datasource = 
-00003b90: 4e6f 6e65 0d0a 0d0a 2020 2020 2320 4966  None....    # If
-00003ba0: 2077 6520 6469 646e 2774 2072 6574 7572   we didn't retur
-00003bb0: 6e20 6f72 2072 6169 7365 2079 6574 2068  n or raise yet h
-00003bc0: 6572 652c 2074 6865 7265 206d 7573 7420  ere, there must 
-00003bd0: 6861 7665 2062 6565 6e20 6572 726f 7273  have been errors
-00003be0: 0d0a 2020 2020 6572 726f 7273 5f73 7472  ..    errors_str
-00003bf0: 203d 2070 7072 696e 742e 7066 6f72 6d61   = pprint.pforma
-00003c00: 7428 6572 726f 7273 290d 0a20 2020 2072  t(errors)..    r
-00003c10: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-00003c20: 0d0a 2020 2020 2020 2020 6622 4572 726f  ..        f"Erro
-00003c30: 7273 2069 6e20 6c61 7965 7220 6465 6669  rs in layer defi
-00003c40: 6e69 7469 6f6e 206f 6620 6669 6c65 207b  nition of file {
-00003c50: 7061 7468 7d2c 206c 6179 6572 207b 6c61  path}, layer {la
-00003c60: 7965 727d 3a20 5c6e 7b65 7272 6f72 735f  yer}: \n{errors_
-00003c70: 7374 727d 220d 0a20 2020 2029 0d0a 0d0a  str}"..    )....
-00003c80: 0d0a 6465 6620 6765 745f 6f6e 6c79 5f6c  ..def get_only_l
-00003c90: 6179 6572 2870 6174 683a 2055 6e69 6f6e  ayer(path: Union
-00003ca0: 5b73 7472 2c20 226f 732e 5061 7468 4c69  [str, "os.PathLi
-00003cb0: 6b65 5b41 6e79 5d22 5d29 202d 3e20 7374  ke[Any]"]) -> st
-00003cc0: 723a 0d0a 2020 2020 2222 220d 0a20 2020  r:..    """..   
-00003cd0: 2047 6574 2074 6865 206c 6179 6572 6e61   Get the layerna
-00003ce0: 6d65 2066 6f72 2061 2066 696c 6520 7468  me for a file th
-00003cf0: 6174 206f 6e6c 7920 636f 6e74 6169 6e73  at only contains
-00003d00: 206f 6e65 206c 6179 6572 2e0d 0a0d 0a20   one layer..... 
-00003d10: 2020 2049 6620 7468 6520 6669 6c65 2063     If the file c
-00003d20: 6f6e 7461 696e 7320 6d75 6c74 6970 6c65  ontains multiple
-00003d30: 206c 6179 6572 732c 2061 6e20 6578 6365   layers, an exce
-00003d40: 7074 696f 6e20 6973 2074 6872 6f77 6e2e  ption is thrown.
-00003d50: 0d0a 0d0a 2020 2020 4172 6773 3a0d 0a20  ....    Args:.. 
-00003d60: 2020 2020 2020 2070 6174 6820 2850 6174         path (Pat
-00003d70: 684c 696b 6529 3a20 7468 6520 6669 6c65  hLike): the file
-00003d80: 2e0d 0a0d 0a20 2020 2052 6169 7365 733a  .....    Raises:
-00003d90: 0d0a 2020 2020 2020 2020 5661 6c75 6545  ..        ValueE
-00003da0: 7272 6f72 3a20 616e 2069 6e76 616c 6964  rror: an invalid
-00003db0: 2070 6172 616d 6574 6572 2076 616c 7565   parameter value
-00003dc0: 2077 6173 2070 6173 7365 642e 0d0a 0d0a   was passed.....
-00003dd0: 2020 2020 5265 7475 726e 733a 0d0a 2020      Returns:..  
-00003de0: 2020 2020 2020 7374 723a 2074 6865 206c        str: the l
-00003df0: 6179 6572 206e 616d 650d 0a20 2020 2022  ayer name..    "
-00003e00: 2222 0d0a 2020 2020 6461 7461 736f 7572  ""..    datasour
-00003e10: 6365 203d 204e 6f6e 650d 0a20 2020 2074  ce = None..    t
-00003e20: 7279 3a0d 0a20 2020 2020 2020 2064 6174  ry:..        dat
-00003e30: 6173 6f75 7263 655f 6c61 7965 7220 3d20  asource_layer = 
-00003e40: 4e6f 6e65 0d0a 2020 2020 2020 2020 6461  None..        da
-00003e50: 7461 736f 7572 6365 203d 2067 6461 6c2e  tasource = gdal.
-00003e60: 4f70 656e 4578 280d 0a20 2020 2020 2020  OpenEx(..       
-00003e70: 2020 2020 2073 7472 2870 6174 6829 2c20       str(path), 
-00003e80: 6e4f 7065 6e46 6c61 6773 3d67 6461 6c2e  nOpenFlags=gdal.
-00003e90: 4f46 5f56 4543 544f 5220 7c20 6764 616c  OF_VECTOR | gdal
-00003ea0: 2e4f 465f 5245 4144 4f4e 4c59 207c 2067  .OF_READONLY | g
-00003eb0: 6461 6c2e 4f46 5f53 4841 5245 440d 0a20  dal.OF_SHARED.. 
-00003ec0: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-00003ed0: 2020 6e62 5f6c 6179 6572 7320 3d20 6461    nb_layers = da
-00003ee0: 7461 736f 7572 6365 2e47 6574 4c61 7965  tasource.GetLaye
-00003ef0: 7243 6f75 6e74 2829 0d0a 2020 2020 2020  rCount()..      
-00003f00: 2020 6966 206e 625f 6c61 7965 7273 203d    if nb_layers =
-00003f10: 3d20 313a 0d0a 2020 2020 2020 2020 2020  = 1:..          
-00003f20: 2020 6461 7461 736f 7572 6365 5f6c 6179    datasource_lay
-00003f30: 6572 203d 2064 6174 6173 6f75 7263 652e  er = datasource.
-00003f40: 4765 744c 6179 6572 4279 496e 6465 7828  GetLayerByIndex(
-00003f50: 3029 0d0a 2020 2020 2020 2020 656c 6966  0)..        elif
-00003f60: 206e 625f 6c61 7965 7273 203d 3d20 303a   nb_layers == 0:
-00003f70: 0d0a 2020 2020 2020 2020 2020 2020 7261  ..            ra
-00003f80: 6973 6520 5661 6c75 6545 7272 6f72 2866  ise ValueError(f
-00003f90: 2245 7272 6f72 3a20 4e6f 206c 6179 6572  "Error: No layer
-00003fa0: 7320 666f 756e 6420 696e 207b 7061 7468  s found in {path
-00003fb0: 7d22 290d 0a20 2020 2020 2020 2065 6c73  }")..        els
-00003fc0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-00003fd0: 2320 4368 6563 6b20 6966 2074 6865 7265  # Check if there
-00003fe0: 2069 7320 6f6e 6c79 206f 6e65 2073 7061   is only one spa
-00003ff0: 7469 616c 206c 6179 6572 0d0a 2020 2020  tial layer..    
-00004000: 2020 2020 2020 2020 6c61 7965 7273 203d          layers =
-00004010: 206c 6973 746c 6179 6572 7328 7061 7468   listlayers(path
-00004020: 2c20 6f6e 6c79 5f73 7061 7469 616c 5f6c  , only_spatial_l
-00004030: 6179 6572 733d 5472 7565 290d 0a20 2020  ayers=True)..   
-00004040: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
-00004050: 6c61 7965 7273 2920 3d3d 2031 3a0d 0a20  layers) == 1:.. 
-00004060: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00004070: 6174 6173 6f75 7263 655f 6c61 7965 7220  atasource_layer 
-00004080: 3d20 6461 7461 736f 7572 6365 2e47 6574  = datasource.Get
-00004090: 4c61 7965 7228 6c61 7965 7273 5b30 5d29  Layer(layers[0])
-000040a0: 0d0a 2020 2020 2020 2020 2020 2020 656c  ..            el
-000040b0: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-000040c0: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-000040d0: 4572 726f 7228 0d0a 2020 2020 2020 2020  Error(..        
-000040e0: 2020 2020 2020 2020 2020 2020 6622 696e              f"in
-000040f0: 7075 7420 6861 7320 3e20 3120 6c61 7965  put has > 1 laye
-00004100: 722c 2062 7574 206e 6f20 6c61 7965 7220  r, but no layer 
-00004110: 7370 6563 6966 6965 643a 207b 7061 7468  specified: {path
-00004120: 7d3a 207b 6c61 7965 7273 7d22 0d0a 2020  }: {layers}"..  
-00004130: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-00004140: 0a0d 0a20 2020 2020 2020 2072 6574 7572  ...        retur
-00004150: 6e20 6461 7461 736f 7572 6365 5f6c 6179  n datasource_lay
-00004160: 6572 2e47 6574 4e61 6d65 2829 0d0a 0d0a  er.GetName()....
-00004170: 2020 2020 6578 6365 7074 2045 7863 6570      except Excep
-00004180: 7469 6f6e 2061 7320 6578 3a0d 0a20 2020  tion as ex:..   
-00004190: 2020 2020 2065 782e 6172 6773 203d 2028       ex.args = (
-000041a0: 6622 6765 745f 6f6e 6c79 5f6c 6179 6572  f"get_only_layer
-000041b0: 2065 7272 6f72 2066 6f72 207b 7061 7468   error for {path
-000041c0: 7d3a 5c6e 2020 7b65 787d 222c 290d 0a20  }:\n  {ex}",).. 
-000041d0: 2020 2020 2020 2072 6169 7365 0d0a 2020         raise..  
-000041e0: 2020 6669 6e61 6c6c 793a 0d0a 2020 2020    finally:..    
-000041f0: 2020 2020 6461 7461 736f 7572 6365 203d      datasource =
-00004200: 204e 6f6e 650d 0a0d 0a0d 0a64 6566 2067   None......def g
-00004210: 6574 5f64 6566 6175 6c74 5f6c 6179 6572  et_default_layer
-00004220: 2870 6174 683a 2055 6e69 6f6e 5b73 7472  (path: Union[str
-00004230: 2c20 226f 732e 5061 7468 4c69 6b65 5b41  , "os.PathLike[A
-00004240: 6e79 5d22 5d29 202d 3e20 7374 723a 0d0a  ny]"]) -> str:..
-00004250: 2020 2020 2222 220d 0a20 2020 2047 6574      """..    Get
-00004260: 2074 6865 2064 6566 6175 6c74 206c 6179   the default lay
-00004270: 6572 206e 616d 6520 746f 2062 6520 7573  er name to be us
-00004280: 6564 2066 6f72 2061 206c 6179 6572 2069  ed for a layer i
-00004290: 6e20 7468 6973 2066 696c 652e 0d0a 0d0a  n this file.....
-000042a0: 2020 2020 5468 6973 2069 7320 7468 6520      This is the 
-000042b0: 7374 656d 206f 6620 7468 6520 6669 6c65  stem of the file
-000042c0: 7061 7468 2e0d 0a0d 0a20 2020 2041 7267  path.....    Arg
-000042d0: 733a 0d0a 2020 2020 2020 2020 7061 7468  s:..        path
-000042e0: 2028 556e 696f 6e5b 7374 722c 293a 2054   (Union[str,): T
-000042f0: 6865 2070 6174 6820 746f 2074 6865 2066  he path to the f
-00004300: 696c 652e 0d0a 0d0a 2020 2020 5265 7475  ile.....    Retu
-00004310: 726e 733a 0d0a 2020 2020 2020 2020 7374  rns:..        st
-00004320: 723a 2054 6865 2064 6566 6175 6c74 206c  r: The default l
-00004330: 6179 6572 206e 616d 652e 0d0a 2020 2020  ayer name...    
-00004340: 2222 220d 0a20 2020 2072 6574 7572 6e20  """..    return 
-00004350: 5061 7468 2870 6174 6829 2e73 7465 6d0d  Path(path).stem.
-00004360: 0a0d 0a0d 0a64 6566 2065 7865 6375 7465  .....def execute
-00004370: 5f73 716c 280d 0a20 2020 2070 6174 683a  _sql(..    path:
-00004380: 2055 6e69 6f6e 5b73 7472 2c20 226f 732e   Union[str, "os.
-00004390: 5061 7468 4c69 6b65 5b41 6e79 5d22 5d2c  PathLike[Any]"],
-000043a0: 0d0a 2020 2020 7371 6c5f 7374 6d74 3a20  ..    sql_stmt: 
-000043b0: 7374 722c 0d0a 2020 2020 7371 6c5f 6469  str,..    sql_di
-000043c0: 616c 6563 743a 204f 7074 696f 6e61 6c5b  alect: Optional[
-000043d0: 7374 725d 203d 204e 6f6e 652c 0d0a 293a  str] = None,..):
-000043e0: 0d0a 2020 2020 2222 220d 0a20 2020 2045  ..    """..    E
-000043f0: 7865 6375 7465 2061 2053 514c 2073 7461  xecute a SQL sta
-00004400: 7465 6d65 6e74 2028 444d 4c20 6f72 2044  tement (DML or D
-00004410: 444c 2920 6f6e 2074 6865 2066 696c 652e  DL) on the file.
-00004420: 0d0a 0d0a 2020 2020 546f 2072 756e 2053  ....    To run S
-00004430: 454c 4543 5420 5351 4c20 7374 6174 656d  ELECT SQL statem
-00004440: 656e 7473 206f 6e20 6120 6669 6c65 2c20  ents on a file, 
-00004450: 7573 6520 3a6d 6574 683a 607e 7265 6164  use :meth:`~read
-00004460: 5f66 696c 6560 2e0d 0a0d 0a20 2020 2041  _file`.....    A
-00004470: 7267 733a 0d0a 2020 2020 2020 2020 7061  rgs:..        pa
-00004480: 7468 2028 5061 7468 4c69 6b65 293a 2054  th (PathLike): T
-00004490: 6865 2070 6174 6820 746f 2074 6865 2066  he path to the f
-000044a0: 696c 652e 0d0a 2020 2020 2020 2020 7371  ile...        sq
-000044b0: 6c5f 7374 6d74 2028 7374 7229 3a20 5468  l_stmt (str): Th
-000044c0: 6520 5351 4c20 7374 6174 656d 656e 7420  e SQL statement 
-000044d0: 746f 2065 7865 6375 7465 2e0d 0a20 2020  to execute...   
-000044e0: 2020 2020 2073 716c 5f64 6961 6c65 6374       sql_dialect
-000044f0: 2028 7374 7229 3a20 5468 6520 5351 4c20   (str): The SQL 
-00004500: 6469 616c 6563 7420 746f 2075 7365 3a0d  dialect to use:.
-00004510: 0a20 2020 2020 2020 2020 2020 202a 204e  .            * N
-00004520: 6f6e 653a 2075 7365 2074 6865 206e 6174  one: use the nat
-00004530: 6976 6520 5351 4c20 6469 616c 6563 7420  ive SQL dialect 
-00004540: 6f66 2074 6865 2067 656f 6669 6c65 2e0d  of the geofile..
-00004550: 0a20 2020 2020 2020 2020 2020 202a 2027  .            * '
-00004560: 4f47 5253 514c 273a 2066 6f72 6365 2074  OGRSQL': force t
-00004570: 6865 2075 7365 206f 6620 7468 6520 4f47  he use of the OG
-00004580: 5220 5351 4c20 6469 616c 6563 742e 0d0a  R SQL dialect...
-00004590: 2020 2020 2020 2020 2020 2020 2a20 2753              * 'S
-000045a0: 514c 4954 4527 3a20 666f 7263 6520 7468  QLITE': force th
-000045b0: 6520 7573 6520 6f66 2074 6865 2053 514c  e use of the SQL
-000045c0: 4954 4520 6469 616c 6563 742e 0d0a 2020  ITE dialect...  
-000045d0: 2020 2020 2020 2020 2020 4465 6661 756c            Defaul
-000045e0: 7473 2074 6f20 4e6f 6e65 2e0d 0a20 2020  ts to None...   
-000045f0: 2022 2222 0d0a 2020 2020 6461 7461 736f   """..    dataso
-00004600: 7572 6365 203d 204e 6f6e 650d 0a20 2020  urce = None..   
-00004610: 2074 7279 3a0d 0a20 2020 2020 2020 2064   try:..        d
-00004620: 6174 6173 6f75 7263 6520 3d20 6764 616c  atasource = gdal
-00004630: 2e4f 7065 6e45 7828 7374 7228 7061 7468  .OpenEx(str(path
-00004640: 292c 206e 4f70 656e 466c 6167 733d 6764  ), nOpenFlags=gd
-00004650: 616c 2e4f 465f 5550 4441 5445 290d 0a20  al.OF_UPDATE).. 
-00004660: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
-00004670: 6461 7461 736f 7572 6365 2e45 7865 6375  datasource.Execu
-00004680: 7465 5351 4c28 7371 6c5f 7374 6d74 2c20  teSQL(sql_stmt, 
-00004690: 6469 616c 6563 743d 7371 6c5f 6469 616c  dialect=sql_dial
-000046a0: 6563 7429 0d0a 2020 2020 2020 2020 6461  ect)..        da
-000046b0: 7461 736f 7572 6365 2e52 656c 6561 7365  tasource.Release
-000046c0: 5265 7375 6c74 5365 7428 7265 7375 6c74  ResultSet(result
-000046d0: 290d 0a0d 0a20 2020 2065 7863 6570 7420  )....    except 
-000046e0: 4578 6365 7074 696f 6e20 6173 2065 783a  Exception as ex:
-000046f0: 0d0a 2020 2020 2020 2020 6578 2e61 7267  ..        ex.arg
-00004700: 7320 3d20 2866 2265 7865 6375 7465 5f73  s = (f"execute_s
-00004710: 716c 2065 7272 6f72 2066 6f72 207b 7061  ql error for {pa
-00004720: 7468 7d5c 6e20 207b 6578 7d22 2c29 0d0a  th}\n  {ex}",)..
-00004730: 2020 2020 2020 2020 7261 6973 650d 0a20          raise.. 
-00004740: 2020 2066 696e 616c 6c79 3a0d 0a20 2020     finally:..   
-00004750: 2020 2020 2064 6174 6173 6f75 7263 6520       datasource 
-00004760: 3d20 4e6f 6e65 0d0a 0d0a 0d0a 6465 6620  = None......def 
-00004770: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-00004780: 6e64 6578 280d 0a20 2020 2070 6174 683a  ndex(..    path:
-00004790: 2055 6e69 6f6e 5b73 7472 2c20 226f 732e   Union[str, "os.
-000047a0: 5061 7468 4c69 6b65 5b41 6e79 5d22 5d2c  PathLike[Any]"],
-000047b0: 0d0a 2020 2020 6c61 7965 723a 204f 7074  ..    layer: Opt
-000047c0: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
-000047d0: 652c 0d0a 2020 2020 6361 6368 655f 7369  e,..    cache_si
-000047e0: 7a65 5f6d 623a 204f 7074 696f 6e61 6c5b  ze_mb: Optional[
-000047f0: 696e 745d 203d 2031 3238 2c0d 0a20 2020  int] = 128,..   
-00004800: 2065 7869 7374 5f6f 6b3a 2062 6f6f 6c20   exist_ok: bool 
-00004810: 3d20 4661 6c73 652c 0d0a 2020 2020 666f  = False,..    fo
-00004820: 7263 655f 7265 6275 696c 643a 2062 6f6f  rce_rebuild: boo
-00004830: 6c20 3d20 4661 6c73 652c 0d0a 2020 2020  l = False,..    
-00004840: 6e6f 5f67 656f 6d5f 6f6b 3a20 626f 6f6c  no_geom_ok: bool
-00004850: 203d 2046 616c 7365 2c0d 0a29 3a0d 0a20   = False,..):.. 
-00004860: 2020 2022 2222 0d0a 2020 2020 4372 6561     """..    Crea
-00004870: 7465 2061 2073 7061 7469 616c 2069 6e64  te a spatial ind
-00004880: 6578 206f 6e20 7468 6520 6c61 7965 7220  ex on the layer 
-00004890: 7370 6563 6966 6965 642e 0d0a 0d0a 2020  specified.....  
-000048a0: 2020 4172 6773 3a0d 0a20 2020 2020 2020    Args:..       
-000048b0: 2070 6174 6820 2850 6174 684c 696b 6529   path (PathLike)
-000048c0: 3a20 5468 6520 6669 6c65 2070 6174 682e  : The file path.
-000048d0: 0d0a 2020 2020 2020 2020 6c61 7965 7220  ..        layer 
-000048e0: 2873 7472 2c20 6f70 7469 6f6e 616c 293a  (str, optional):
-000048f0: 2054 6865 206c 6179 6572 2e20 4966 206e   The layer. If n
-00004900: 6f74 2073 7065 6369 6669 6564 2c20 616e  ot specified, an
-00004910: 6420 7468 6572 6520 6973 206f 6e6c 790d  d there is only.
-00004920: 0a20 2020 2020 2020 2020 2020 206f 6e65  .            one
-00004930: 206c 6179 6572 2069 6e20 7468 6520 6669   layer in the fi
-00004940: 6c65 2c20 7468 6973 206c 6179 6572 2069  le, this layer i
-00004950: 7320 7573 6564 2e20 4f74 6865 7277 6973  s used. Otherwis
-00004960: 6520 6578 6365 7074 696f 6e2e 0d0a 2020  e exception...  
-00004970: 2020 2020 2020 6361 6368 655f 7369 7a65        cache_size
-00004980: 5f6d 6220 2869 6e74 2c20 6f70 7469 6f6e  _mb (int, option
-00004990: 616c 293a 2063 6163 6865 206d 656d 6f72  al): cache memor
-000049a0: 7920 696e 204d 4220 7468 6174 2063 616e  y in MB that can
-000049b0: 2062 6520 7573 6564 2077 6869 6c65 0d0a   be used while..
-000049c0: 2020 2020 2020 2020 2020 2020 6372 6561              crea
-000049d0: 7469 6e67 2073 7061 7469 616c 2069 6e64  ting spatial ind
-000049e0: 6578 2066 6f72 2073 7061 7469 616c 6974  ex for spatialit
-000049f0: 6520 6669 6c65 7320 282e 6770 6b67 206f  e files (.gpkg o
-00004a00: 7220 2e73 716c 6974 6529 2e20 4966 204e  r .sqlite). If N
-00004a10: 6f6e 652c 0d0a 2020 2020 2020 2020 2020  one,..          
-00004a20: 2020 7468 6520 6465 6661 756c 7420 6361    the default ca
-00004a30: 6368 655f 7369 7a65 2066 726f 6d20 7371  che_size from sq
-00004a40: 6c69 7465 2069 7320 7573 6564 2e20 4465  lite is used. De
-00004a50: 6661 756c 7473 2074 6f20 3132 382e 0d0a  faults to 128...
-00004a60: 2020 2020 2020 2020 6578 6973 745f 6f6b          exist_ok
-00004a70: 2028 626f 6f6c 2c20 6f70 7469 6f6e 616c   (bool, optional
-00004a80: 293a 2049 6620 5472 7565 2061 6e64 2074  ): If True and t
-00004a90: 6865 2069 6e64 6578 2065 7869 7374 7320  he index exists 
-00004aa0: 616c 7265 6164 792c 2064 6f6e 2774 0d0a  already, don't..
-00004ab0: 2020 2020 2020 2020 2020 2020 7468 726f              thro
-00004ac0: 7720 616e 2065 7272 6f72 2e20 4465 6661  w an error. Defa
-00004ad0: 756c 7473 2074 6f20 4661 6c73 652e 0d0a  ults to False...
-00004ae0: 2020 2020 2020 2020 666f 7263 655f 7265          force_re
-00004af0: 6275 696c 6420 2862 6f6f 6c2c 206f 7074  build (bool, opt
-00004b00: 696f 6e73 293a 2054 7275 6520 746f 2066  ions): True to f
-00004b10: 6f72 6365 2072 6562 7569 6c64 2065 7665  orce rebuild eve
-00004b20: 6e20 6966 2069 6e64 6578 0d0a 2020 2020  n if index..    
-00004b30: 2020 2020 2020 2020 6578 6973 7473 2061          exists a
-00004b40: 6c72 6561 6479 2e20 4465 6661 756c 7473  lready. Defaults
-00004b50: 2074 6f20 4661 6c73 652e 0d0a 2020 2020   to False...    
-00004b60: 2020 2020 6e6f 5f67 656f 6d5f 6f6b 2028      no_geom_ok (
-00004b70: 626f 6f6c 2c20 6f70 7469 6f6e 7329 3a20  bool, options): 
-00004b80: 4966 2054 7275 6520 616e 6420 7468 6520  If True and the 
-00004b90: 6669 6c65 2064 6f65 736e 2774 2068 6176  file doesn't hav
-00004ba0: 6520 6120 6765 6f6d 6574 7279 2063 6f6c  e a geometry col
-00004bb0: 756d 6e2c 0d0a 2020 2020 2020 2020 2020  umn,..          
-00004bc0: 2020 646f 6e27 7420 7468 726f 7720 616e    don't throw an
-00004bd0: 2065 7272 6f72 2e20 4465 6661 756c 7473   error. Defaults
-00004be0: 2074 6f20 4661 6c73 652e 0d0a 2020 2020   to False...    
-00004bf0: 2222 220d 0a20 2020 2023 2049 6e69 740d  """..    # Init.
-00004c00: 0a20 2020 2070 6174 6820 3d20 5061 7468  .    path = Path
-00004c10: 2870 6174 6829 0d0a 2020 2020 6966 206c  (path)..    if l
-00004c20: 6179 6572 2069 7320 4e6f 6e65 3a0d 0a20  ayer is None:.. 
-00004c30: 2020 2020 2020 206c 6179 6572 203d 2067         layer = g
-00004c40: 6574 5f6f 6e6c 795f 6c61 7965 7228 7061  et_only_layer(pa
-00004c50: 7468 290d 0a0d 0a20 2020 2023 2041 6464  th)....    # Add
-00004c60: 2069 6e64 6578 0d0a 2020 2020 6461 7461   index..    data
-00004c70: 736f 7572 6365 203d 204e 6f6e 650d 0a20  source = None.. 
-00004c80: 2020 2074 7279 3a0d 0a20 2020 2020 2020     try:..       
-00004c90: 2070 6174 685f 696e 666f 203d 205f 6765   path_info = _ge
-00004ca0: 6f66 696c 6569 6e66 6f2e 6765 745f 6765  ofileinfo.get_ge
-00004cb0: 6f66 696c 6569 6e66 6f28 7061 7468 290d  ofileinfo(path).
-00004cc0: 0a0d 0a20 2020 2020 2020 206c 6179 6572  ...        layer
-00004cd0: 696e 666f 203d 2067 6574 5f6c 6179 6572  info = get_layer
-00004ce0: 696e 666f 2870 6174 682c 206c 6179 6572  info(path, layer
-00004cf0: 2c20 7261 6973 655f 6f6e 5f6e 6f67 656f  , raise_on_nogeo
-00004d00: 6d3d 6e6f 7420 6e6f 5f67 656f 6d5f 6f6b  m=not no_geom_ok
-00004d10: 290d 0a20 2020 2020 2020 2069 6620 6e6f  )..        if no
-00004d20: 5f67 656f 6d5f 6f6b 2061 6e64 206c 6179  _geom_ok and lay
-00004d30: 6572 696e 666f 2e67 656f 6d65 7472 7963  erinfo.geometryc
-00004d40: 6f6c 756d 6e20 6973 204e 6f6e 653a 0d0a  olumn is None:..
-00004d50: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00004d60: 726e 0d0a 0d0a 2020 2020 2020 2020 2320  rn....        # 
-00004d70: 4966 2069 6e64 6578 2061 6c72 6561 6479  If index already
-00004d80: 2065 7869 7374 732c 2072 656d 6f76 6520   exists, remove 
-00004d90: 696e 6465 7820 6f72 2072 6574 7572 6e0d  index or return.
-00004da0: 0a20 2020 2020 2020 2069 6620 6861 735f  .        if has_
-00004db0: 7370 6174 6961 6c5f 696e 6465 7828 7061  spatial_index(pa
-00004dc0: 7468 2c20 6c61 7965 7229 3a0d 0a20 2020  th, layer):..   
-00004dd0: 2020 2020 2020 2020 2069 6620 666f 7263           if forc
-00004de0: 655f 7265 6275 696c 643a 0d0a 2020 2020  e_rebuild:..    
-00004df0: 2020 2020 2020 2020 2020 2020 7265 6d6f              remo
-00004e00: 7665 5f73 7061 7469 616c 5f69 6e64 6578  ve_spatial_index
-00004e10: 2870 6174 682c 206c 6179 6572 290d 0a20  (path, layer).. 
-00004e20: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
-00004e30: 6578 6973 745f 6f6b 3a0d 0a20 2020 2020  exist_ok:..     
-00004e40: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00004e50: 6e0d 0a20 2020 2020 2020 2020 2020 2065  n..            e
-00004e60: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-00004e70: 2020 2020 2020 7261 6973 6520 5275 6e74        raise Runt
-00004e80: 696d 6545 7272 6f72 2866 2273 7061 7469  imeError(f"spati
-00004e90: 616c 2069 6e64 6578 2065 7869 7374 7320  al index exists 
-00004ea0: 616c 7265 6164 7920 6f6e 207b 7061 7468  already on {path
-00004eb0: 7d2e 7b6c 6179 6572 7d22 290d 0a0d 0a20  }.{layer}").... 
-00004ec0: 2020 2020 2020 2069 6620 7061 7468 5f69         if path_i
-00004ed0: 6e66 6f2e 6973 5f73 7061 7469 616c 6974  nfo.is_spatialit
-00004ee0: 655f 6261 7365 643a 0d0a 2020 2020 2020  e_based:..      
-00004ef0: 2020 2020 2020 2320 5468 6520 636f 6e66        # The conf
-00004f00: 6967 206f 7074 696f 6e73 206e 6565 6420  ig options need 
-00004f10: 746f 2062 6520 7365 7420 6265 666f 7265  to be set before
-00004f20: 206f 7065 6e69 6e67 2074 6865 2066 696c   opening the fil
-00004f30: 6521 0d0a 2020 2020 2020 2020 2020 2020  e!..            
-00004f40: 7769 7468 205f 6f67 725f 7574 696c 2e73  with _ogr_util.s
-00004f50: 6574 5f63 6f6e 6669 675f 6f70 7469 6f6e  et_config_option
-00004f60: 7328 7b22 4f47 525f 5351 4c49 5445 5f43  s({"OGR_SQLITE_C
-00004f70: 4143 4845 223a 2063 6163 6865 5f73 697a  ACHE": cache_siz
-00004f80: 655f 6d62 7d29 3a0d 0a20 2020 2020 2020  e_mb}):..       
-00004f90: 2020 2020 2020 2020 2064 6174 6173 6f75           datasou
-00004fa0: 7263 6520 3d20 6764 616c 2e4f 7065 6e45  rce = gdal.OpenE
-00004fb0: 7828 7374 7228 7061 7468 292c 206e 4f70  x(str(path), nOp
-00004fc0: 656e 466c 6167 733d 6764 616c 2e4f 465f  enFlags=gdal.OF_
-00004fd0: 5550 4441 5445 290d 0a20 2020 2020 2020  UPDATE)..       
-00004fe0: 2020 2020 2020 2020 2067 656f 6d65 7472           geometr
-00004ff0: 7963 6f6c 756d 6e20 3d20 6c61 7965 7269  ycolumn = layeri
-00005000: 6e66 6f2e 6765 6f6d 6574 7279 636f 6c75  nfo.geometrycolu
-00005010: 6d6e 0d0a 2020 2020 2020 2020 2020 2020  mn..            
-00005020: 2020 2020 7371 6c20 3d20 6622 5345 4c45      sql = f"SELE
-00005030: 4354 2043 7265 6174 6553 7061 7469 616c  CT CreateSpatial
-00005040: 496e 6465 7828 277b 6c61 7965 727d 272c  Index('{layer}',
-00005050: 2027 7b67 656f 6d65 7472 7963 6f6c 756d   '{geometrycolum
-00005060: 6e7d 2729 220d 0a20 2020 2020 2020 2020  n}')"..         
-00005070: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
-00005080: 6461 7461 736f 7572 6365 2e45 7865 6375  datasource.Execu
-00005090: 7465 5351 4c28 7371 6c2c 2064 6961 6c65  teSQL(sql, diale
-000050a0: 6374 3d22 5351 4c49 5445 2229 0d0a 2020  ct="SQLITE")..  
-000050b0: 2020 2020 2020 2020 2020 2020 2020 6461                da
-000050c0: 7461 736f 7572 6365 2e52 656c 6561 7365  tasource.Release
-000050d0: 5265 7375 6c74 5365 7428 7265 7375 6c74  ResultSet(result
-000050e0: 290d 0a20 2020 2020 2020 2065 6c73 653a  )..        else:
-000050f0: 0d0a 2020 2020 2020 2020 2020 2020 6461  ..            da
-00005100: 7461 736f 7572 6365 203d 2067 6461 6c2e  tasource = gdal.
-00005110: 4f70 656e 4578 2873 7472 2870 6174 6829  OpenEx(str(path)
-00005120: 2c20 6e4f 7065 6e46 6c61 6773 3d67 6461  , nOpenFlags=gda
-00005130: 6c2e 4f46 5f55 5044 4154 4529 0d0a 2020  l.OF_UPDATE)..  
-00005140: 2020 2020 2020 2020 2020 7265 7375 6c74            result
-00005150: 203d 2064 6174 6173 6f75 7263 652e 4578   = datasource.Ex
-00005160: 6563 7574 6553 514c 2866 2743 5245 4154  ecuteSQL(f'CREAT
-00005170: 4520 5350 4154 4941 4c20 494e 4445 5820  E SPATIAL INDEX 
-00005180: 4f4e 2022 7b6c 6179 6572 7d22 2729 0d0a  ON "{layer}"')..
-00005190: 2020 2020 2020 2020 2020 2020 6461 7461              data
-000051a0: 736f 7572 6365 2e52 656c 6561 7365 5265  source.ReleaseRe
-000051b0: 7375 6c74 5365 7428 7265 7375 6c74 290d  sultSet(result).
-000051c0: 0a0d 0a20 2020 2065 7863 6570 7420 4578  ...    except Ex
-000051d0: 6365 7074 696f 6e20 6173 2065 783a 0d0a  ception as ex:..
-000051e0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
-000051f0: 7461 6e63 6528 6578 2c20 5661 6c75 6545  tance(ex, ValueE
-00005200: 7272 6f72 2920 616e 6420 7374 7228 6578  rror) and str(ex
-00005210: 292e 7374 6172 7473 7769 7468 280d 0a20  ).startswith(.. 
-00005220: 2020 2020 2020 2020 2020 2022 6861 735f             "has_
-00005230: 7370 6174 6961 6c5f 696e 6465 7820 6e6f  spatial_index no
-00005240: 7420 7375 7070 6f72 7465 6420 666f 7222  t supported for"
-00005250: 0d0a 2020 2020 2020 2020 293a 0d0a 2020  ..        ):..  
-00005260: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00005270: 5661 6c75 6545 7272 6f72 280d 0a20 2020  ValueError(..   
-00005280: 2020 2020 2020 2020 2020 2020 2066 2263               f"c
-00005290: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
-000052a0: 6465 7820 6e6f 7420 7375 7070 6f72 7465  dex not supporte
-000052b0: 6420 666f 7220 7b70 6174 685f 696e 666f  d for {path_info
-000052c0: 2e64 7269 7665 727d 3a20 7b70 6174 687d  .driver}: {path}
-000052d0: 220d 0a20 2020 2020 2020 2020 2020 2029  "..            )
-000052e0: 2066 726f 6d20 6578 0d0a 2020 2020 2020   from ex..      
-000052f0: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-00005300: 2020 2020 2065 782e 6172 6773 203d 2028       ex.args = (
-00005310: 6622 6372 6561 7465 5f73 7061 7469 616c  f"create_spatial
-00005320: 5f69 6e64 6578 2065 7272 6f72 3a20 7b65  _index error: {e
-00005330: 787d 2c20 666f 7220 7b70 6174 687d 2e7b  x}, for {path}.{
-00005340: 6c61 7965 727d 222c 290d 0a20 2020 2020  layer}",)..     
-00005350: 2020 2072 6169 7365 0d0a 2020 2020 6669     raise..    fi
-00005360: 6e61 6c6c 793a 0d0a 2020 2020 2020 2020  nally:..        
-00005370: 6461 7461 736f 7572 6365 203d 204e 6f6e  datasource = Non
-00005380: 650d 0a0d 0a20 2020 2069 6620 6e6f 7420  e....    if not 
-00005390: 6861 735f 7370 6174 6961 6c5f 696e 6465  has_spatial_inde
-000053a0: 7828 7061 7468 2c20 6c61 7965 7229 3a0d  x(path, layer):.
-000053b0: 0a20 2020 2020 2020 2072 6169 7365 2052  .        raise R
-000053c0: 756e 7469 6d65 4572 726f 7228 6622 6372  untimeError(f"cr
-000053d0: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
-000053e0: 6578 2066 6169 6c65 6420 6f6e 207b 7061  ex failed on {pa
-000053f0: 7468 7d2c 206c 6179 6572 3a20 7b6c 6179  th}, layer: {lay
-00005400: 6572 7d22 290d 0a0d 0a0d 0a64 6566 2068  er}")......def h
-00005410: 6173 5f73 7061 7469 616c 5f69 6e64 6578  as_spatial_index
-00005420: 280d 0a20 2020 2070 6174 683a 2055 6e69  (..    path: Uni
-00005430: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
-00005440: 4c69 6b65 5b41 6e79 5d22 5d2c 0d0a 2020  Like[Any]"],..  
-00005450: 2020 6c61 7965 723a 204f 7074 696f 6e61    layer: Optiona
-00005460: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
-00005470: 2020 2020 6e6f 5f67 656f 6d5f 6f6b 3a20      no_geom_ok: 
-00005480: 626f 6f6c 203d 2046 616c 7365 2c0d 0a29  bool = False,..)
-00005490: 202d 3e20 626f 6f6c 3a0d 0a20 2020 2022   -> bool:..    "
-000054a0: 2222 0d0a 2020 2020 4368 6563 6b20 6966  ""..    Check if
-000054b0: 2074 6865 206c 6179 6572 2f63 6f6c 756d   the layer/colum
-000054c0: 6e20 6861 7320 6120 7370 6174 6961 6c20  n has a spatial 
-000054d0: 696e 6465 782e 0d0a 0d0a 2020 2020 4172  index.....    Ar
-000054e0: 6773 3a0d 0a20 2020 2020 2020 2070 6174  gs:..        pat
-000054f0: 6820 2850 6174 684c 696b 6529 3a20 5468  h (PathLike): Th
-00005500: 6520 6669 6c65 2070 6174 682e 0d0a 2020  e file path...  
-00005510: 2020 2020 2020 6c61 7965 7220 2873 7472        layer (str
-00005520: 2c20 6f70 7469 6f6e 616c 293a 2054 6865  , optional): The
-00005530: 206c 6179 6572 2e20 4465 6661 756c 7473   layer. Defaults
-00005540: 2074 6f20 4e6f 6e65 2e0d 0a20 2020 2020   to None...     
-00005550: 2020 206e 6f5f 6765 6f6d 5f6f 6b20 2862     no_geom_ok (b
-00005560: 6f6f 6c2c 206f 7074 696f 6e73 293a 2049  ool, options): I
-00005570: 6620 5472 7565 2061 6e64 2074 6865 2066  f True and the f
-00005580: 696c 6520 646f 6573 6e27 7420 6861 7665  ile doesn't have
-00005590: 2061 2067 656f 6d65 7472 7920 636f 6c75   a geometry colu
-000055a0: 6d6e 2c0d 0a20 2020 2020 2020 2020 2020  mn,..           
-000055b0: 2064 6f6e 2774 2074 6872 6f77 2061 6e20   don't throw an 
-000055c0: 6572 726f 722e 2044 6566 6175 6c74 7320  error. Defaults 
-000055d0: 746f 2046 616c 7365 2e0d 0a0d 0a20 2020  to False.....   
-000055e0: 2052 6169 7365 733a 0d0a 2020 2020 2020   Raises:..      
-000055f0: 2020 5661 6c75 6545 7272 6f72 3a20 616e    ValueError: an
-00005600: 2069 6e76 616c 6964 2070 6172 616d 6574   invalid paramet
-00005610: 6572 2076 616c 7565 2077 6173 2070 6173  er value was pas
-00005620: 7365 642e 0d0a 0d0a 2020 2020 5265 7475  sed.....    Retu
-00005630: 726e 733a 0d0a 2020 2020 2020 2020 626f  rns:..        bo
-00005640: 6f6c 3a20 5472 7565 2069 6620 6120 7370  ol: True if a sp
-00005650: 6174 6961 6c20 696e 6465 7820 6578 6973  atial index exis
-00005660: 7473 2c20 4661 6c73 6520 6966 2069 7420  ts, False if it 
-00005670: 646f 6573 6e27 7420 6578 6973 742e 0d0a  doesn't exist...
-00005680: 2020 2020 2222 220d 0a20 2020 2023 2049      """..    # I
-00005690: 6e69 740d 0a20 2020 2070 6174 6820 3d20  nit..    path = 
-000056a0: 5061 7468 2870 6174 6829 0d0a 0d0a 2020  Path(path)....  
-000056b0: 2020 2320 4e6f 7720 6368 6563 6b20 7468    # Now check th
-000056c0: 6520 696e 6465 780d 0a20 2020 2064 6174  e index..    dat
-000056d0: 6173 6f75 7263 6520 3d20 4e6f 6e65 0d0a  asource = None..
-000056e0: 2020 2020 7061 7468 5f69 6e66 6f20 3d20      path_info = 
-000056f0: 5f67 656f 6669 6c65 696e 666f 2e67 6574  _geofileinfo.get
-00005700: 5f67 656f 6669 6c65 696e 666f 2870 6174  _geofileinfo(pat
-00005710: 6829 0d0a 2020 2020 7472 793a 0d0a 2020  h)..    try:..  
-00005720: 2020 2020 2020 6966 2070 6174 685f 696e        if path_in
-00005730: 666f 2e69 735f 7370 6174 6961 6c69 7465  fo.is_spatialite
-00005740: 5f62 6173 6564 3a0d 0a20 2020 2020 2020  _based:..       
-00005750: 2020 2020 206c 6179 6572 696e 666f 203d       layerinfo =
-00005760: 2067 6574 5f6c 6179 6572 696e 666f 2870   get_layerinfo(p
-00005770: 6174 682c 206c 6179 6572 2c20 7261 6973  ath, layer, rais
-00005780: 655f 6f6e 5f6e 6f67 656f 6d3d 6e6f 7420  e_on_nogeom=not 
-00005790: 6e6f 5f67 656f 6d5f 6f6b 290d 0a20 2020  no_geom_ok)..   
-000057a0: 2020 2020 2020 2020 2069 6620 6e6f 5f67           if no_g
-000057b0: 656f 6d5f 6f6b 2061 6e64 206c 6179 6572  eom_ok and layer
-000057c0: 696e 666f 2e67 656f 6d65 7472 7963 6f6c  info.geometrycol
-000057d0: 756d 6e20 6973 204e 6f6e 653a 0d0a 2020  umn is None:..  
-000057e0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-000057f0: 7475 726e 2046 616c 7365 0d0a 2020 2020  turn False..    
-00005800: 2020 2020 2020 2020 6461 7461 736f 7572          datasour
-00005810: 6365 203d 2067 6461 6c2e 4f70 656e 4578  ce = gdal.OpenEx
-00005820: 2873 7472 2870 6174 6829 2c20 6e4f 7065  (str(path), nOpe
-00005830: 6e46 6c61 6773 3d67 6461 6c2e 4f46 5f52  nFlags=gdal.OF_R
-00005840: 4541 444f 4e4c 5929 0d0a 2020 2020 2020  EADONLY)..      
-00005850: 2020 2020 2020 7371 6c20 3d20 6622 2222        sql = f"""
-00005860: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00005870: 2020 5345 4c45 4354 2048 6173 5370 6174    SELECT HasSpat
-00005880: 6961 6c49 6e64 6578 2827 7b6c 6179 6572  ialIndex('{layer
-00005890: 696e 666f 2e6e 616d 657d 272c 0d0a 2020  info.name}',..  
-000058a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000058b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000058c0: 2020 2020 2027 7b6c 6179 6572 696e 666f       '{layerinfo
-000058d0: 2e67 656f 6d65 7472 7963 6f6c 756d 6e7d  .geometrycolumn}
-000058e0: 2729 0d0a 2020 2020 2020 2020 2020 2020  ')..            
-000058f0: 2222 220d 0a20 2020 2020 2020 2020 2020  """..           
-00005900: 2072 6573 756c 7420 3d20 6461 7461 736f   result = dataso
-00005910: 7572 6365 2e45 7865 6375 7465 5351 4c28  urce.ExecuteSQL(
-00005920: 7371 6c2c 2064 6961 6c65 6374 3d22 5351  sql, dialect="SQ
-00005930: 4c49 5445 2229 0d0a 2020 2020 2020 2020  LITE")..        
-00005940: 2020 2020 6861 735f 7370 6174 6961 6c5f      has_spatial_
-00005950: 696e 6465 7820 3d20 7265 7375 6c74 2e47  index = result.G
-00005960: 6574 4e65 7874 4665 6174 7572 6528 292e  etNextFeature().
-00005970: 4765 7446 6965 6c64 2830 2920 3d3d 2031  GetField(0) == 1
-00005980: 0d0a 2020 2020 2020 2020 2020 2020 6461  ..            da
-00005990: 7461 736f 7572 6365 2e52 656c 6561 7365  tasource.Release
-000059a0: 5265 7375 6c74 5365 7428 7265 7375 6c74  ResultSet(result
-000059b0: 290d 0a20 2020 2020 2020 2020 2020 2072  )..            r
-000059c0: 6574 7572 6e20 6861 735f 7370 6174 6961  eturn has_spatia
-000059d0: 6c5f 696e 6465 780d 0a20 2020 2020 2020  l_index..       
-000059e0: 2065 6c69 6620 7061 7468 5f69 6e66 6f2e   elif path_info.
-000059f0: 6472 6976 6572 203d 3d20 2245 5352 4920  driver == "ESRI 
-00005a00: 5368 6170 6566 696c 6522 3a0d 0a20 2020  Shapefile":..   
-00005a10: 2020 2020 2020 2020 2069 6e64 6578 5f70           index_p
-00005a20: 6174 6820 3d20 7061 7468 2e70 6172 656e  ath = path.paren
-00005a30: 7420 2f20 6622 7b70 6174 682e 7374 656d  t / f"{path.stem
-00005a40: 7d2e 7169 7822 0d0a 2020 2020 2020 2020  }.qix"..        
-00005a50: 2020 2020 7265 7475 726e 2069 6e64 6578      return index
-00005a60: 5f70 6174 682e 6578 6973 7473 2829 0d0a  _path.exists()..
-00005a70: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-00005a80: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-00005a90: 2056 616c 7565 4572 726f 7228 0d0a 2020   ValueError(..  
-00005aa0: 2020 2020 2020 2020 2020 2020 2020 6622                f"
-00005ab0: 6861 735f 7370 6174 6961 6c5f 696e 6465  has_spatial_inde
-00005ac0: 7820 6e6f 7420 7375 7070 6f72 7465 6420  x not supported 
-00005ad0: 666f 7220 7b70 6174 685f 696e 666f 2e64  for {path_info.d
-00005ae0: 7269 7665 727d 3a20 7b70 6174 687d 220d  river}: {path}".
-00005af0: 0a20 2020 2020 2020 2020 2020 2029 0d0a  .            )..
-00005b00: 0d0a 2020 2020 6578 6365 7074 2056 616c  ..    except Val
-00005b10: 7565 4572 726f 723a 0d0a 2020 2020 2020  ueError:..      
-00005b20: 2020 7261 6973 650d 0a20 2020 2065 7863    raise..    exc
-00005b30: 6570 7420 4578 6365 7074 696f 6e20 6173  ept Exception as
-00005b40: 2065 783a 0d0a 2020 2020 2020 2020 6578   ex:..        ex
-00005b50: 2e61 7267 7320 3d20 2866 2268 6173 5f73  .args = (f"has_s
-00005b60: 7061 7469 616c 5f69 6e64 6578 2065 7272  patial_index err
-00005b70: 6f72 3a20 7b65 787d 2c20 666f 7220 7b70  or: {ex}, for {p
-00005b80: 6174 687d 2e7b 6c61 7965 727d 222c 290d  ath}.{layer}",).
-00005b90: 0a20 2020 2020 2020 2072 6169 7365 0d0a  .        raise..
-00005ba0: 2020 2020 6669 6e61 6c6c 793a 0d0a 2020      finally:..  
-00005bb0: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
-00005bc0: 203d 204e 6f6e 650d 0a0d 0a0d 0a64 6566   = None......def
-00005bd0: 2072 656d 6f76 655f 7370 6174 6961 6c5f   remove_spatial_
-00005be0: 696e 6465 7828 0d0a 2020 2020 7061 7468  index(..    path
-00005bf0: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
-00005c00: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
-00005c10: 2c20 6c61 7965 723a 204f 7074 696f 6e61  , layer: Optiona
-00005c20: 6c5b 7374 725d 203d 204e 6f6e 650d 0a29  l[str] = None..)
-00005c30: 3a0d 0a20 2020 2022 2222 0d0a 2020 2020  :..    """..    
-00005c40: 5265 6d6f 7665 2074 6865 2073 7061 7469  Remove the spati
-00005c50: 616c 2069 6e64 6578 2066 726f 6d20 7468  al index from th
-00005c60: 6520 6c61 7965 7220 7370 6563 6966 6965  e layer specifie
-00005c70: 642e 0d0a 0d0a 2020 2020 4172 6773 3a0d  d.....    Args:.
-00005c80: 0a20 2020 2020 2020 2070 6174 6820 2850  .        path (P
-00005c90: 6174 684c 696b 6529 3a20 5468 6520 6669  athLike): The fi
-00005ca0: 6c65 2070 6174 682e 0d0a 2020 2020 2020  le path...      
-00005cb0: 2020 6c61 7965 7220 2873 7472 2c20 6f70    layer (str, op
-00005cc0: 7469 6f6e 616c 293a 2054 6865 206c 6179  tional): The lay
-00005cd0: 6572 2e20 4966 206e 6f74 2073 7065 6369  er. If not speci
-00005ce0: 6669 6564 2c20 616e 6420 7468 6572 6520  fied, and there 
-00005cf0: 6973 206f 6e6c 790d 0a20 2020 2020 2020  is only..       
-00005d00: 2020 2020 206f 6e65 206c 6179 6572 2069       one layer i
-00005d10: 6e20 7468 6520 6669 6c65 2c20 7468 6973  n the file, this
-00005d20: 206c 6179 6572 2069 7320 7573 6564 2e20   layer is used. 
-00005d30: 4f74 6865 7277 6973 6520 6578 6365 7074  Otherwise except
-00005d40: 696f 6e2e 0d0a 2020 2020 2222 220d 0a20  ion...    """.. 
-00005d50: 2020 2023 2049 6e69 740d 0a20 2020 2070     # Init..    p
-00005d60: 6174 6820 3d20 5061 7468 2870 6174 6829  ath = Path(path)
-00005d70: 0d0a 0d0a 2020 2020 2320 4e6f 7720 7265  ....    # Now re
-00005d80: 616c 6c79 2072 656d 6f76 6520 696e 6465  ally remove inde
-00005d90: 780d 0a20 2020 2064 6174 6173 6f75 7263  x..    datasourc
-00005da0: 6520 3d20 4e6f 6e65 0d0a 2020 2020 7061  e = None..    pa
-00005db0: 7468 5f69 6e66 6f20 3d20 5f67 656f 6669  th_info = _geofi
-00005dc0: 6c65 696e 666f 2e67 6574 5f67 656f 6669  leinfo.get_geofi
-00005dd0: 6c65 696e 666f 2870 6174 6829 0d0a 2020  leinfo(path)..  
-00005de0: 2020 7061 7468 5f6c 6179 6572 696e 666f    path_layerinfo
-00005df0: 203d 2067 6574 5f6c 6179 6572 696e 666f   = get_layerinfo
-00005e00: 2870 6174 682c 206c 6179 6572 290d 0a20  (path, layer).. 
-00005e10: 2020 2074 7279 3a0d 0a20 2020 2020 2020     try:..       
-00005e20: 2069 6620 7061 7468 5f69 6e66 6f2e 6973   if path_info.is
-00005e30: 5f73 7061 7469 616c 6974 655f 6261 7365  _spatialite_base
-00005e40: 643a 0d0a 2020 2020 2020 2020 2020 2020  d:..            
-00005e50: 6461 7461 736f 7572 6365 203d 2067 6461  datasource = gda
-00005e60: 6c2e 4f70 656e 4578 2873 7472 2870 6174  l.OpenEx(str(pat
-00005e70: 6829 2c20 6e4f 7065 6e46 6c61 6773 3d67  h), nOpenFlags=g
-00005e80: 6461 6c2e 4f46 5f55 5044 4154 4529 0d0a  dal.OF_UPDATE)..
-00005e90: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-00005ea0: 6c74 203d 2064 6174 6173 6f75 7263 652e  lt = datasource.
-00005eb0: 4578 6563 7574 6553 514c 280d 0a20 2020  ExecuteSQL(..   
-00005ec0: 2020 2020 2020 2020 2020 2020 2022 5345               "SE
-00005ed0: 4c45 4354 2044 6973 6162 6c65 5370 6174  LECT DisableSpat
-00005ee0: 6961 6c49 6e64 6578 2822 0d0a 2020 2020  ialIndex("..    
-00005ef0: 2020 2020 2020 2020 2020 2020 6622 2020              f"  
-00005f00: 2020 2020 277b 7061 7468 5f6c 6179 6572      '{path_layer
-00005f10: 696e 666f 2e6e 616d 657d 272c 2027 7b70  info.name}', '{p
-00005f20: 6174 685f 6c61 7965 7269 6e66 6f2e 6765  ath_layerinfo.ge
-00005f30: 6f6d 6574 7279 636f 6c75 6d6e 7d27 2922  ometrycolumn}')"
-00005f40: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00005f50: 2020 2064 6961 6c65 6374 3d22 5351 4c49     dialect="SQLI
-00005f60: 5445 222c 0d0a 2020 2020 2020 2020 2020  TE",..          
-00005f70: 2020 290d 0a20 2020 2020 2020 2020 2020    )..           
-00005f80: 2064 6174 6173 6f75 7263 652e 5265 6c65   datasource.Rele
-00005f90: 6173 6552 6573 756c 7453 6574 2872 6573  aseResultSet(res
-00005fa0: 756c 7429 0d0a 2020 2020 2020 2020 656c  ult)..        el
-00005fb0: 6966 2070 6174 685f 696e 666f 2e64 7269  if path_info.dri
-00005fc0: 7665 7220 3d3d 2022 4553 5249 2053 6861  ver == "ESRI Sha
-00005fd0: 7065 6669 6c65 223a 0d0a 2020 2020 2020  pefile":..      
-00005fe0: 2020 2020 2020 2320 4452 4f50 2053 5041        # DROP SPA
-00005ff0: 5449 414c 2049 4e44 4558 204f 4e20 2e2e  TIAL INDEX ON ..
-00006000: 2e20 636f 6d6d 616e 6420 6769 7665 7320  . command gives 
-00006010: 616e 2065 7272 6f72 2c20 736f 206a 7573  an error, so jus
-00006020: 7420 7265 6d6f 7665 202e 7169 780d 0a20  t remove .qix.. 
-00006030: 2020 2020 2020 2020 2020 2069 6e64 6578             index
-00006040: 5f70 6174 6820 3d20 7061 7468 2e70 6172  _path = path.par
-00006050: 656e 7420 2f20 6622 7b70 6174 682e 7374  ent / f"{path.st
-00006060: 656d 7d2e 7169 7822 0d0a 2020 2020 2020  em}.qix"..      
-00006070: 2020 2020 2020 696e 6465 785f 7061 7468        index_path
-00006080: 2e75 6e6c 696e 6b28 290d 0a20 2020 2020  .unlink()..     
-00006090: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-000060a0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-000060b0: 6545 7272 6f72 280d 0a20 2020 2020 2020  eError(..       
-000060c0: 2020 2020 2020 2020 2066 2272 656d 6f76           f"remov
-000060d0: 655f 7370 6174 6961 6c5f 696e 6465 7820  e_spatial_index 
-000060e0: 6e6f 7420 7375 7070 6f72 7465 6420 666f  not supported fo
-000060f0: 7220 7b70 6174 685f 696e 666f 2e64 7269  r {path_info.dri
-00006100: 7665 727d 3a20 7b70 6174 687d 220d 0a20  ver}: {path}".. 
-00006110: 2020 2020 2020 2020 2020 2029 0d0a 0d0a             )....
-00006120: 2020 2020 6578 6365 7074 2056 616c 7565      except Value
-00006130: 4572 726f 723a 0d0a 2020 2020 2020 2020  Error:..        
-00006140: 7261 6973 650d 0a20 2020 2065 7863 6570  raise..    excep
-00006150: 7420 4578 6365 7074 696f 6e20 6173 2065  t Exception as e
-00006160: 783a 0d0a 2020 2020 2020 2020 6578 2e61  x:..        ex.a
-00006170: 7267 7320 3d20 2866 2272 656d 6f76 655f  rgs = (f"remove_
-00006180: 7370 6174 6961 6c5f 696e 6465 7820 6572  spatial_index er
-00006190: 726f 723a 207b 6578 7d2c 2066 6f72 207b  ror: {ex}, for {
-000061a0: 7061 7468 7d2e 7b6c 6179 6572 7d22 2c29  path}.{layer}",)
-000061b0: 0d0a 2020 2020 2020 2020 7261 6973 650d  ..        raise.
-000061c0: 0a20 2020 2066 696e 616c 6c79 3a0d 0a20  .    finally:.. 
-000061d0: 2020 2020 2020 2064 6174 6173 6f75 7263         datasourc
-000061e0: 6520 3d20 4e6f 6e65 0d0a 0d0a 0d0a 6465  e = None......de
-000061f0: 6620 7265 6e61 6d65 5f6c 6179 6572 280d  f rename_layer(.
-00006200: 0a20 2020 2070 6174 683a 2055 6e69 6f6e  .    path: Union
-00006210: 5b73 7472 2c20 226f 732e 5061 7468 4c69  [str, "os.PathLi
-00006220: 6b65 5b41 6e79 5d22 5d2c 206e 6577 5f6c  ke[Any]"], new_l
-00006230: 6179 6572 3a20 7374 722c 206c 6179 6572  ayer: str, layer
-00006240: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
-00006250: 3d20 4e6f 6e65 0d0a 293a 0d0a 2020 2020  = None..):..    
-00006260: 2222 220d 0a20 2020 2052 656e 616d 6520  """..    Rename 
-00006270: 7468 6520 6c61 7965 7220 7370 6563 6966  the layer specif
-00006280: 6965 642e 0d0a 0d0a 2020 2020 4172 6773  ied.....    Args
-00006290: 3a0d 0a20 2020 2020 2020 2070 6174 6820  :..        path 
-000062a0: 2850 6174 684c 696b 6529 3a20 5468 6520  (PathLike): The 
-000062b0: 6669 6c65 2070 6174 682e 0d0a 2020 2020  file path...    
-000062c0: 2020 2020 6c61 7965 7220 284f 7074 696f      layer (Optio
-000062d0: 6e61 6c5b 7374 725d 293a 2054 6865 206c  nal[str]): The l
-000062e0: 6179 6572 206e 616d 652e 2049 6620 6e6f  ayer name. If no
-000062f0: 7420 7370 6563 6966 6965 642c 2061 6e64  t specified, and
-00006300: 2074 6865 7265 2069 7320 6f6e 6c79 0d0a   there is only..
-00006310: 2020 2020 2020 2020 2020 2020 6f6e 6520              one 
-00006320: 6c61 7965 7220 696e 2074 6865 2066 696c  layer in the fil
-00006330: 652c 2074 6869 7320 6c61 7965 7220 6973  e, this layer is
-00006340: 2075 7365 642e 204f 7468 6572 7769 7365   used. Otherwise
-00006350: 2065 7863 6570 7469 6f6e 2e0d 0a20 2020   exception...   
-00006360: 2020 2020 206e 6577 5f6c 6179 6572 2028       new_layer (
-00006370: 7374 7229 3a20 5468 6520 6e65 7720 6c61  str): The new la
-00006380: 7965 7220 6e61 6d65 2e20 4966 206e 6f74  yer name. If not
-00006390: 2073 7065 6369 6669 6564 2c20 616e 6420   specified, and 
-000063a0: 7468 6572 6520 6973 206f 6e6c 790d 0a20  there is only.. 
-000063b0: 2020 2020 2020 2020 2020 206f 6e65 206c             one l
-000063c0: 6179 6572 2069 6e20 7468 6520 6669 6c65  ayer in the file
-000063d0: 2c20 7468 6973 206c 6179 6572 2069 7320  , this layer is 
-000063e0: 7573 6564 2e20 4f74 6865 7277 6973 6520  used. Otherwise 
-000063f0: 6578 6365 7074 696f 6e2e 0d0a 2020 2020  exception...    
-00006400: 2222 220d 0a20 2020 2023 2043 6865 636b  """..    # Check
-00006410: 2069 6e70 7574 2070 6172 616d 6574 6572   input parameter
-00006420: 730d 0a20 2020 2070 6174 6820 3d20 5061  s..    path = Pa
-00006430: 7468 2870 6174 6829 0d0a 2020 2020 6966  th(path)..    if
-00006440: 206c 6179 6572 2069 7320 4e6f 6e65 3a0d   layer is None:.
-00006450: 0a20 2020 2020 2020 206c 6179 6572 203d  .        layer =
-00006460: 2067 6574 5f6f 6e6c 795f 6c61 7965 7228   get_only_layer(
-00006470: 7061 7468 290d 0a0d 0a20 2020 2023 2052  path)....    # R
-00006480: 656e 616d 696e 6720 7468 6520 6c61 7965  enaming the laye
-00006490: 7220 6e61 6d65 2069 7320 6e6f 7420 706f  r name is not po
-000064a0: 7373 6962 6c65 2066 6f72 2073 696e 676c  ssible for singl
-000064b0: 6520 6c61 7965 7220 6669 6c65 2066 6f72  e layer file for
-000064c0: 6d61 7473 2e0d 0a20 2020 2070 6174 685f  mats...    path_
-000064d0: 696e 666f 203d 205f 6765 6f66 696c 6569  info = _geofilei
-000064e0: 6e66 6f2e 6765 745f 6765 6f66 696c 6569  nfo.get_geofilei
-000064f0: 6e66 6f28 7061 7468 290d 0a20 2020 2069  nfo(path)..    i
-00006500: 6620 7061 7468 5f69 6e66 6f2e 6973 5f73  f path_info.is_s
-00006510: 696e 676c 656c 6179 6572 3a0d 0a20 2020  inglelayer:..   
-00006520: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-00006530: 4572 726f 7228 6622 7265 6e61 6d65 5f6c  Error(f"rename_l
-00006540: 6179 6572 206e 6f74 2070 6f73 7369 626c  ayer not possibl
-00006550: 6520 666f 7220 7b70 6174 685f 696e 666f  e for {path_info
-00006560: 2e64 7269 7665 727d 2066 696c 6522 290d  .driver} file").
-00006570: 0a0d 0a20 2020 2023 204e 6f77 2072 6561  ...    # Now rea
-00006580: 6c6c 7920 7265 6e61 6d65 0d0a 2020 2020  lly rename..    
-00006590: 6461 7461 736f 7572 6365 203d 204e 6f6e  datasource = Non
-000065a0: 650d 0a20 2020 2074 7279 3a0d 0a20 2020  e..    try:..   
-000065b0: 2020 2020 2064 6174 6173 6f75 7263 6520       datasource 
-000065c0: 3d20 6764 616c 2e4f 7065 6e45 7828 7374  = gdal.OpenEx(st
-000065d0: 7228 7061 7468 292c 206e 4f70 656e 466c  r(path), nOpenFl
-000065e0: 6167 733d 6764 616c 2e4f 465f 5550 4441  ags=gdal.OF_UPDA
-000065f0: 5445 290d 0a20 2020 2020 2020 2073 716c  TE)..        sql
-00006600: 5f73 746d 7420 3d20 6627 414c 5445 5220  _stmt = f'ALTER 
-00006610: 5441 424c 4520 227b 6c61 7965 727d 2220  TABLE "{layer}" 
-00006620: 5245 4e41 4d45 2054 4f20 227b 6e65 775f  RENAME TO "{new_
-00006630: 6c61 7965 727d 2227 0d0a 2020 2020 2020  layer}"'..      
-00006640: 2020 7265 7375 6c74 203d 2064 6174 6173    result = datas
-00006650: 6f75 7263 652e 4578 6563 7574 6553 514c  ource.ExecuteSQL
-00006660: 2873 716c 5f73 746d 7429 0d0a 2020 2020  (sql_stmt)..    
-00006670: 2020 2020 6461 7461 736f 7572 6365 2e52      datasource.R
-00006680: 656c 6561 7365 5265 7375 6c74 5365 7428  eleaseResultSet(
-00006690: 7265 7375 6c74 290d 0a20 2020 2065 7863  result)..    exc
-000066a0: 6570 7420 4578 6365 7074 696f 6e20 6173  ept Exception as
-000066b0: 2065 783a 0d0a 2020 2020 2020 2020 6578   ex:..        ex
-000066c0: 2e61 7267 7320 3d20 2866 2272 656e 616d  .args = (f"renam
-000066d0: 655f 6c61 7965 7220 6572 726f 723a 207b  e_layer error: {
-000066e0: 6578 7d2c 2066 6f72 207b 7061 7468 7d2e  ex}, for {path}.
-000066f0: 7b6c 6179 6572 7d22 2c29 0d0a 2020 2020  {layer}",)..    
-00006700: 2020 2020 7261 6973 650d 0a20 2020 2066      raise..    f
-00006710: 696e 616c 6c79 3a0d 0a20 2020 2020 2020  inally:..       
-00006720: 2064 6174 6173 6f75 7263 6520 3d20 4e6f   datasource = No
-00006730: 6e65 0d0a 0d0a 0d0a 6465 6620 7265 6e61  ne......def rena
-00006740: 6d65 5f63 6f6c 756d 6e28 0d0a 2020 2020  me_column(..    
-00006750: 7061 7468 3a20 556e 696f 6e5b 7374 722c  path: Union[str,
-00006760: 2022 6f73 2e50 6174 684c 696b 655b 416e   "os.PathLike[An
-00006770: 795d 225d 2c0d 0a20 2020 2063 6f6c 756d  y]"],..    colum
-00006780: 6e5f 6e61 6d65 3a20 7374 722c 0d0a 2020  n_name: str,..  
-00006790: 2020 6e65 775f 636f 6c75 6d6e 5f6e 616d    new_column_nam
-000067a0: 653a 2073 7472 2c0d 0a20 2020 206c 6179  e: str,..    lay
-000067b0: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
-000067c0: 5d20 3d20 4e6f 6e65 2c0d 0a29 3a0d 0a20  ] = None,..):.. 
-000067d0: 2020 2022 2222 0d0a 2020 2020 5265 6e61     """..    Rena
-000067e0: 6d65 2074 6865 2063 6f6c 756d 6e20 7370  me the column sp
-000067f0: 6563 6966 6965 642e 0d0a 0d0a 2020 2020  ecified.....    
-00006800: 4172 6773 3a0d 0a20 2020 2020 2020 2070  Args:..        p
-00006810: 6174 6820 2850 6174 684c 696b 6529 3a20  ath (PathLike): 
-00006820: 7468 6520 6669 6c65 2070 6174 682e 0d0a  the file path...
-00006830: 2020 2020 2020 2020 636f 6c75 6d6e 5f6e          column_n
-00006840: 616d 6520 2873 7472 293a 2063 7572 7265  ame (str): curre
-00006850: 6e74 2063 6f6c 756d 6e20 6e61 6d65 2e0d  nt column name..
-00006860: 0a20 2020 2020 2020 206e 6577 5f63 6f6c  .        new_col
-00006870: 756d 6e5f 6e61 6d65 2028 7374 7229 3a20  umn_name (str): 
-00006880: 6e65 7720 636f 6c75 6d6e 206e 616d 652e  new column name.
-00006890: 0d0a 2020 2020 2020 2020 6c61 7965 7220  ..        layer 
-000068a0: 284f 7074 696f 6e61 6c5b 7374 725d 293a  (Optional[str]):
-000068b0: 206c 6179 6572 206e 616d 652e 2049 6620   layer name. If 
-000068c0: 6e6f 7420 7370 6563 6966 6965 642c 2061  not specified, a
-000068d0: 6e64 2074 6865 7265 2069 7320 6f6e 6c79  nd there is only
-000068e0: 0d0a 2020 2020 2020 2020 2020 2020 6f6e  ..            on
-000068f0: 6520 6c61 7965 7220 696e 2074 6865 2066  e layer in the f
-00006900: 696c 652c 2074 6869 7320 6c61 7965 7220  ile, this layer 
-00006910: 6973 2075 7365 642e 204f 7468 6572 7769  is used. Otherwi
-00006920: 7365 2065 7863 6570 7469 6f6e 2e0d 0a20  se exception... 
-00006930: 2020 2022 2222 0d0a 2020 2020 2320 4368     """..    # Ch
-00006940: 6563 6b20 696e 7075 7420 7061 7261 6d65  eck input parame
-00006950: 7465 7273 0d0a 2020 2020 7061 7468 203d  ters..    path =
-00006960: 2050 6174 6828 7061 7468 290d 0a20 2020   Path(path)..   
-00006970: 2069 6620 6c61 7965 7220 6973 204e 6f6e   if layer is Non
-00006980: 653a 0d0a 2020 2020 2020 2020 6c61 7965  e:..        laye
-00006990: 7220 3d20 6765 745f 6f6e 6c79 5f6c 6179  r = get_only_lay
-000069a0: 6572 2870 6174 6829 0d0a 2020 2020 696e  er(path)..    in
-000069b0: 666f 203d 2067 6574 5f6c 6179 6572 696e  fo = get_layerin
-000069c0: 666f 2870 6174 682c 206c 6179 6572 2c20  fo(path, layer, 
-000069d0: 7261 6973 655f 6f6e 5f6e 6f67 656f 6d3d  raise_on_nogeom=
-000069e0: 4661 6c73 6529 0d0a 2020 2020 6966 2063  False)..    if c
-000069f0: 6f6c 756d 6e5f 6e61 6d65 206e 6f74 2069  olumn_name not i
-00006a00: 6e20 696e 666f 2e63 6f6c 756d 6e73 2061  n info.columns a
-00006a10: 6e64 206e 6577 5f63 6f6c 756d 6e5f 6e61  nd new_column_na
-00006a20: 6d65 2069 6e20 696e 666f 2e63 6f6c 756d  me in info.colum
-00006a30: 6e73 3a0d 0a20 2020 2020 2020 206c 6f67  ns:..        log
-00006a40: 6765 722e 696e 666f 280d 0a20 2020 2020  ger.info(..     
-00006a50: 2020 2020 2020 2066 2243 6f6c 756d 6e20         f"Column 
-00006a60: 7b63 6f6c 756d 6e5f 6e61 6d65 7d20 7365  {column_name} se
-00006a70: 656d 7320 746f 2062 6520 7265 6e61 6d65  ems to be rename
-00006a80: 6420 616c 7265 6164 7920 746f 207b 6e65  d already to {ne
-00006a90: 775f 636f 6c75 6d6e 5f6e 616d 657d 220d  w_column_name}".
-00006aa0: 0a20 2020 2020 2020 2029 0d0a 2020 2020  .        )..    
-00006ab0: 2020 2020 7265 7475 726e 0d0a 0d0a 2020      return....  
-00006ac0: 2020 2320 4e6f 7720 7265 616c 6c79 2072    # Now really r
-00006ad0: 656e 616d 650d 0a20 2020 2064 6174 6173  ename..    datas
-00006ae0: 6f75 7263 6520 3d20 4e6f 6e65 0d0a 2020  ource = None..  
-00006af0: 2020 7472 793a 0d0a 2020 2020 2020 2020    try:..        
-00006b00: 6461 7461 736f 7572 6365 203d 2067 6461  datasource = gda
-00006b10: 6c2e 4f70 656e 4578 2873 7472 2870 6174  l.OpenEx(str(pat
-00006b20: 6829 2c20 6e4f 7065 6e46 6c61 6773 3d67  h), nOpenFlags=g
-00006b30: 6461 6c2e 4f46 5f55 5044 4154 4529 0d0a  dal.OF_UPDATE)..
-00006b40: 2020 2020 2020 2020 6461 7461 736f 7572          datasour
-00006b50: 6365 5f6c 6179 6572 203d 2064 6174 6173  ce_layer = datas
-00006b60: 6f75 7263 652e 4765 744c 6179 6572 286c  ource.GetLayer(l
-00006b70: 6179 6572 290d 0a20 2020 2020 2020 2069  ayer)..        i
-00006b80: 6620 6e6f 7420 6461 7461 736f 7572 6365  f not datasource
-00006b90: 5f6c 6179 6572 2e54 6573 7443 6170 6162  _layer.TestCapab
-00006ba0: 696c 6974 7928 6764 616c 2e6f 6772 2e4f  ility(gdal.ogr.O
-00006bb0: 4c43 416c 7465 7246 6965 6c64 4465 666e  LCAlterFieldDefn
-00006bc0: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-00006bd0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00006be0: 2866 2272 656e 616d 655f 636f 6c75 6d6e  (f"rename_column
-00006bf0: 206e 6f74 2073 7570 706f 7274 6564 2066   not supported f
-00006c00: 6f72 207b 7061 7468 7d22 290d 0a0d 0a20  or {path}").... 
-00006c10: 2020 2020 2020 2023 2052 656e 616d 6520         # Rename 
-00006c20: 636f 6c75 6d6e 0d0a 2020 2020 2020 2020  column..        
-00006c30: 7371 6c5f 7374 6d74 203d 2028 0d0a 2020  sql_stmt = (..  
-00006c40: 2020 2020 2020 2020 2020 6627 414c 5445            f'ALTE
-00006c50: 5220 5441 424c 4520 227b 6c61 7965 727d  R TABLE "{layer}
-00006c60: 2220 270d 0a20 2020 2020 2020 2020 2020  " '..           
-00006c70: 2066 2752 454e 414d 4520 434f 4c55 4d4e   f'RENAME COLUMN
-00006c80: 2022 7b63 6f6c 756d 6e5f 6e61 6d65 7d22   "{column_name}"
-00006c90: 2054 4f20 227b 6e65 775f 636f 6c75 6d6e   TO "{new_column
-00006ca0: 5f6e 616d 657d 2227 0d0a 2020 2020 2020  _name}"'..      
-00006cb0: 2020 290d 0a20 2020 2020 2020 2072 6573    )..        res
-00006cc0: 756c 7420 3d20 6461 7461 736f 7572 6365  ult = datasource
-00006cd0: 2e45 7865 6375 7465 5351 4c28 7371 6c5f  .ExecuteSQL(sql_
-00006ce0: 7374 6d74 290d 0a20 2020 2020 2020 2064  stmt)..        d
-00006cf0: 6174 6173 6f75 7263 652e 5265 6c65 6173  atasource.Releas
-00006d00: 6552 6573 756c 7453 6574 2872 6573 756c  eResultSet(resul
-00006d10: 7429 0d0a 0d0a 2020 2020 6578 6365 7074  t)....    except
-00006d20: 2045 7863 6570 7469 6f6e 2061 7320 6578   Exception as ex
-00006d30: 3a0d 0a20 2020 2020 2020 2023 2049 6620  :..        # If 
-00006d40: 6974 2069 7320 7468 6520 5661 6c75 6545  it is the ValueE
-00006d50: 7272 6f72 2074 6872 6f77 6e20 6162 6f76  rror thrown abov
-00006d60: 652c 206a 7573 7420 7261 6973 650d 0a20  e, just raise.. 
-00006d70: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
-00006d80: 616e 6365 2865 782c 2056 616c 7565 4572  ance(ex, ValueEr
-00006d90: 726f 7229 2061 6e64 2073 7472 2865 7829  ror) and str(ex)
-00006da0: 2e73 7461 7274 7377 6974 6828 0d0a 2020  .startswith(..  
-00006db0: 2020 2020 2020 2020 2020 2272 656e 616d            "renam
-00006dc0: 655f 636f 6c75 6d6e 206e 6f74 2073 7570  e_column not sup
-00006dd0: 706f 7274 6564 2066 6f72 220d 0a20 2020  ported for"..   
-00006de0: 2020 2020 2029 3a0d 0a20 2020 2020 2020       ):..       
-00006df0: 2020 2020 2072 6169 7365 0d0a 0d0a 2020       raise....  
-00006e00: 2020 2020 2020 2320 4974 2069 7320 616e        # It is an
-00006e10: 6f74 6865 7220 6572 726f 722e 2e2e 2061  other error... a
-00006e20: 6464 2073 6f6d 6520 6d6f 7265 2063 6f6e  dd some more con
-00006e30: 7465 7874 0d0a 2020 2020 2020 2020 6578  text..        ex
-00006e40: 2e61 7267 7320 3d20 2866 2272 656e 616d  .args = (f"renam
-00006e50: 655f 636f 6c75 6d6e 2065 7272 6f72 3a20  e_column error: 
-00006e60: 7b65 787d 2066 6f72 207b 7061 7468 7d2e  {ex} for {path}.
-00006e70: 7b6c 6179 6572 7d22 2c29 0d0a 2020 2020  {layer}",)..    
-00006e80: 2020 2020 7261 6973 650d 0a20 2020 2066      raise..    f
-00006e90: 696e 616c 6c79 3a0d 0a20 2020 2020 2020  inally:..       
-00006ea0: 2064 6174 6173 6f75 7263 6520 3d20 4e6f   datasource = No
-00006eb0: 6e65 0d0a 0d0a 0d0a 636c 6173 7320 4461  ne......class Da
-00006ec0: 7461 5479 7065 2865 6e75 6d2e 456e 756d  taType(enum.Enum
-00006ed0: 293a 0d0a 2020 2020 2222 220d 0a20 2020  ):..    """..   
-00006ee0: 2054 6869 7320 656e 756d 2064 6566 696e   This enum defin
-00006ef0: 6573 2074 6865 2073 7461 6e64 6172 6420  es the standard 
-00006f00: 6461 7461 2074 7970 6573 2074 6861 7420  data types that 
-00006f10: 6361 6e20 6265 2075 7365 6420 666f 7220  can be used for 
-00006f20: 636f 6c75 6d6e 732e 0d0a 2020 2020 2222  columns...    ""
-00006f30: 220d 0a0d 0a20 2020 2054 4558 5420 3d20  "....    TEXT = 
-00006f40: 2254 4558 5422 0d0a 2020 2020 2222 2243  "TEXT"..    """C
-00006f50: 6f6c 756d 6e20 7769 7468 2074 6578 7420  olumn with text 
-00006f60: 6461 7461 3a20 7e20 7374 7269 6e67 2c20  data: ~ string, 
-00006f70: 6368 6172 2c20 7661 7263 6861 722c 2063  char, varchar, c
-00006f80: 6c6f 622e 2222 220d 0a20 2020 2049 4e54  lob."""..    INT
-00006f90: 4547 4552 203d 2022 494e 5445 4745 5222  EGER = "INTEGER"
-00006fa0: 0d0a 2020 2020 2222 2243 6f6c 756d 6e20  ..    """Column 
-00006fb0: 7769 7468 2069 6e74 6567 6572 2064 6174  with integer dat
-00006fc0: 612e 2222 220d 0a20 2020 2052 4541 4c20  a."""..    REAL 
-00006fd0: 3d20 2252 4541 4c22 0d0a 2020 2020 2222  = "REAL"..    ""
-00006fe0: 2243 6f6c 756d 6e20 7769 7468 2066 6c6f  "Column with flo
-00006ff0: 6174 696e 6720 706f 696e 7420 6461 7461  ating point data
-00007000: 3a20 7e20 666c 6f61 742c 2064 6f75 626c  : ~ float, doubl
-00007010: 652e 2222 220d 0a20 2020 2044 4154 4520  e."""..    DATE 
-00007020: 3d20 2244 4154 4522 0d0a 2020 2020 2222  = "DATE"..    ""
-00007030: 2243 6f6c 756d 6e20 7769 7468 2064 6174  "Column with dat
-00007040: 6520 6461 7461 2e22 2222 0d0a 2020 2020  e data."""..    
-00007050: 5449 4d45 5354 414d 5020 3d20 2254 494d  TIMESTAMP = "TIM
-00007060: 4553 5441 4d50 220d 0a20 2020 2022 2222  ESTAMP"..    """
-00007070: 436f 6c75 6d6e 2077 6974 6820 7469 6d65  Column with time
-00007080: 7374 616d 7020 6461 7461 3a20 7e20 6461  stamp data: ~ da
-00007090: 7465 7469 6d65 2e22 2222 0d0a 2020 2020  tetime."""..    
-000070a0: 424f 4f4c 4541 4e20 3d20 2242 4f4f 4c45  BOOLEAN = "BOOLE
-000070b0: 414e 220d 0a20 2020 2022 2222 436f 6c75  AN"..    """Colu
-000070c0: 6d6e 2077 6974 6820 626f 6f6c 6561 6e20  mn with boolean 
-000070d0: 6461 7461 2e22 2222 0d0a 2020 2020 424c  data."""..    BL
-000070e0: 4f42 203d 2022 424c 4f42 220d 0a20 2020  OB = "BLOB"..   
-000070f0: 2022 2222 436f 6c75 6d6e 2077 6974 6820   """Column with 
-00007100: 6269 6e61 7279 2064 6174 612e 2222 220d  binary data.""".
-00007110: 0a20 2020 204e 554d 4552 4943 203d 2022  .    NUMERIC = "
-00007120: 4e55 4d45 5249 4322 0d0a 2020 2020 2222  NUMERIC"..    ""
-00007130: 2243 6f6c 756d 6e20 7769 7468 206e 756d  "Column with num
-00007140: 6572 6963 2064 6174 613a 2065 7861 6374  eric data: exact
-00007150: 2064 6563 696d 616c 2064 6174 612e 2222   decimal data.""
-00007160: 220d 0a0d 0a0d 0a64 6566 2061 6464 5f63  "......def add_c
-00007170: 6f6c 756d 6e28 0d0a 2020 2020 7061 7468  olumn(..    path
-00007180: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
-00007190: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
-000071a0: 2c0d 0a20 2020 206e 616d 653a 2073 7472  ,..    name: str
-000071b0: 2c0d 0a20 2020 2074 7970 653a 2055 6e69  ,..    type: Uni
-000071c0: 6f6e 5b44 6174 6154 7970 652c 2073 7472  on[DataType, str
-000071d0: 5d2c 0d0a 2020 2020 6578 7072 6573 7369  ],..    expressi
-000071e0: 6f6e 3a20 556e 696f 6e5b 7374 722c 2069  on: Union[str, i
-000071f0: 6e74 2c20 666c 6f61 742c 204e 6f6e 655d  nt, float, None]
-00007200: 203d 204e 6f6e 652c 0d0a 2020 2020 6578   = None,..    ex
-00007210: 7072 6573 7369 6f6e 5f64 6961 6c65 6374  pression_dialect
-00007220: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
-00007230: 3d20 4e6f 6e65 2c0d 0a20 2020 206c 6179  = None,..    lay
-00007240: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
-00007250: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2066  ] = None,..    f
-00007260: 6f72 6365 5f75 7064 6174 653a 2062 6f6f  orce_update: boo
-00007270: 6c20 3d20 4661 6c73 652c 0d0a 2020 2020  l = False,..    
-00007280: 7769 6474 683a 204f 7074 696f 6e61 6c5b  width: Optional[
-00007290: 696e 745d 203d 204e 6f6e 652c 0d0a 293a  int] = None,..):
-000072a0: 0d0a 2020 2020 2222 220d 0a20 2020 2041  ..    """..    A
-000072b0: 6464 2061 2063 6f6c 756d 6e20 746f 2061  dd a column to a
-000072c0: 206c 6179 6572 206f 6620 7468 6520 6765   layer of the ge
-000072d0: 6f66 696c 652e 0d0a 0d0a 2020 2020 4172  ofile.....    Ar
-000072e0: 6773 3a0d 0a20 2020 2020 2020 2070 6174  gs:..        pat
-000072f0: 6820 2850 6174 684c 696b 6529 3a20 5061  h (PathLike): Pa
-00007300: 7468 2074 6f20 7468 6520 6765 6f66 696c  th to the geofil
-00007310: 652e 0d0a 2020 2020 2020 2020 6e61 6d65  e...        name
-00007320: 2028 7374 7229 3a20 4e61 6d65 2066 6f72   (str): Name for
-00007330: 2074 6865 206e 6577 2063 6f6c 756d 6e2e   the new column.
-00007340: 0d0a 2020 2020 2020 2020 7479 7065 2028  ..        type (
-00007350: 7374 7229 3a20 436f 6c75 6d6e 2074 7970  str): Column typ
-00007360: 6520 6f66 2074 6865 206e 6577 2063 6f6c  e of the new col
-00007370: 756d 6e2e 0d0a 2020 2020 2020 2020 6578  umn...        ex
-00007380: 7072 6573 7369 6f6e 2028 7374 722c 206f  pression (str, o
-00007390: 7074 696f 6e61 6c29 3a20 5351 4c69 7465  ptional): SQLite
-000073a0: 2065 7870 7265 7373 696f 6e20 746f 2075   expression to u
-000073b0: 7365 2074 6f20 7570 6461 7465 0d0a 2020  se to update..  
-000073c0: 2020 2020 2020 2020 2020 7468 6520 7661            the va
-000073d0: 6c75 652e 2044 6566 6175 6c74 7320 746f  lue. Defaults to
-000073e0: 204e 6f6e 652e 0d0a 2020 2020 2020 2020   None...        
-000073f0: 6578 7072 6573 7369 6f6e 5f64 6961 6c65  expression_diale
-00007400: 6374 2028 7374 722c 206f 7074 696f 6e61  ct (str, optiona
-00007410: 6c29 3a20 5351 4c20 6469 616c 6563 7420  l): SQL dialect 
-00007420: 7573 6564 2066 6f72 2074 6865 2065 7870  used for the exp
-00007430: 7265 7373 696f 6e2e 0d0a 2020 2020 2020  ression...      
-00007440: 2020 6c61 7965 7220 2873 7472 2c20 6f70    layer (str, op
-00007450: 7469 6f6e 616c 293a 2054 6865 206c 6179  tional): The lay
-00007460: 6572 206e 616d 652e 2049 6620 4e6f 6e65  er name. If None
-00007470: 2061 6e64 2074 6865 2067 656f 6669 6c65   and the geofile
-00007480: 0d0a 2020 2020 2020 2020 2020 2020 6861  ..            ha
-00007490: 7320 6f6e 6c79 206f 6e65 206c 6179 6572  s only one layer
-000074a0: 2c20 7468 6174 206c 6179 6572 2069 7320  , that layer is 
-000074b0: 7573 6564 2e20 4465 6661 756c 7473 2074  used. Defaults t
-000074c0: 6f20 4e6f 6e65 2e0d 0a20 2020 2020 2020  o None...       
-000074d0: 2066 6f72 6365 5f75 7064 6174 6520 2862   force_update (b
-000074e0: 6f6f 6c2c 206f 7074 696f 6e61 6c29 3a20  ool, optional): 
-000074f0: 4966 2074 6865 2063 6f6c 756d 6e20 616c  If the column al
-00007500: 7265 6164 7920 6578 6973 7473 2c20 6578  ready exists, ex
-00007510: 6563 7574 650d 0a20 2020 2020 2020 2020  ecute..         
-00007520: 2020 2074 6865 2075 7064 6174 6520 616e     the update an
-00007530: 7977 6179 2e20 4465 6661 756c 7473 2074  yway. Defaults t
-00007540: 6f20 4661 6c73 652e 0d0a 2020 2020 2020  o False...      
-00007550: 2020 7769 6474 6820 2869 6e74 2c20 6f70    width (int, op
-00007560: 7469 6f6e 616c 293a 2074 6865 2077 6964  tional): the wid
-00007570: 7468 206f 6620 7468 6520 6669 656c 642e  th of the field.
-00007580: 0d0a 0d0a 2020 2020 5261 6973 6573 3a0d  ....    Raises:.
-00007590: 0a20 2020 2020 2020 2065 783a 205b 6465  .        ex: [de
-000075a0: 7363 7269 7074 696f 6e5d 0d0a 2020 2020  scription]..    
-000075b0: 2222 220d 0a20 2020 2023 2049 6e69 740d  """..    # Init.
-000075c0: 0a20 2020 2069 6620 6973 696e 7374 616e  .    if isinstan
-000075d0: 6365 2874 7970 652c 2044 6174 6154 7970  ce(type, DataTyp
-000075e0: 6529 3a0d 0a20 2020 2020 2020 2074 7970  e):..        typ
-000075f0: 655f 7374 7220 3d20 7479 7065 2e76 616c  e_str = type.val
-00007600: 7565 0d0a 2020 2020 656c 7365 3a0d 0a20  ue..    else:.. 
-00007610: 2020 2020 2020 2074 7970 655f 6c6f 7765         type_lowe
-00007620: 7220 3d20 7479 7065 2e6c 6f77 6572 2829  r = type.lower()
-00007630: 0d0a 2020 2020 2020 2020 6966 2074 7970  ..        if typ
-00007640: 655f 6c6f 7765 7220 3d3d 2022 7374 7269  e_lower == "stri
-00007650: 6e67 223a 0d0a 2020 2020 2020 2020 2020  ng":..          
-00007660: 2020 2320 544f 444f 3a20 7468 696e 6b20    # TODO: think 
-00007670: 7768 6574 6865 7220 6265 696e 6720 666c  whether being fl
-00007680: 6578 6962 6c65 2068 6572 6520 6973 2061  exible here is a
-00007690: 2067 6f6f 6420 6964 6561 2e2e 2e0d 0a20   good idea..... 
-000076a0: 2020 2020 2020 2020 2020 2074 7970 655f             type_
-000076b0: 7374 7220 3d20 2254 4558 5422 0d0a 2020  str = "TEXT"..  
-000076c0: 2020 2020 2020 656c 6966 2074 7970 655f        elif type_
-000076d0: 6c6f 7765 7220 3d3d 2022 6269 6e61 7279  lower == "binary
-000076e0: 223a 0d0a 2020 2020 2020 2020 2020 2020  ":..            
-000076f0: 7479 7065 5f73 7472 203d 2022 424c 4f42  type_str = "BLOB
-00007700: 220d 0a20 2020 2020 2020 2065 6c69 6620  "..        elif 
-00007710: 7479 7065 5f6c 6f77 6572 203d 3d20 2274  type_lower == "t
-00007720: 696d 6522 3a0d 0a20 2020 2020 2020 2020  ime":..         
-00007730: 2020 2074 7970 655f 7374 7220 3d20 2244     type_str = "D
-00007740: 4154 4554 494d 4522 0d0a 2020 2020 2020  ATETIME"..      
-00007750: 2020 656c 6966 2074 7970 655f 6c6f 7765    elif type_lowe
-00007760: 7220 3d3d 2022 696e 7465 6765 7236 3422  r == "integer64"
-00007770: 3a0d 0a20 2020 2020 2020 2020 2020 2074  :..            t
-00007780: 7970 655f 7374 7220 3d20 2249 4e54 4547  ype_str = "INTEG
-00007790: 4552 220d 0a20 2020 2020 2020 2065 6c73  ER"..        els
-000077a0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-000077b0: 7479 7065 5f73 7472 203d 2074 7970 650d  type_str = type.
-000077c0: 0a20 2020 2070 6174 6820 3d20 5061 7468  .    path = Path
-000077d0: 2870 6174 6829 0d0a 2020 2020 6966 206c  (path)..    if l
-000077e0: 6179 6572 2069 7320 4e6f 6e65 3a0d 0a20  ayer is None:.. 
-000077f0: 2020 2020 2020 206c 6179 6572 203d 2067         layer = g
-00007800: 6574 5f6f 6e6c 795f 6c61 7965 7228 7061  et_only_layer(pa
-00007810: 7468 290d 0a20 2020 206c 6179 6572 696e  th)..    layerin
-00007820: 666f 5f6f 7269 6720 3d20 6765 745f 6c61  fo_orig = get_la
-00007830: 7965 7269 6e66 6f28 7061 7468 2c20 6c61  yerinfo(path, la
-00007840: 7965 722c 2072 6169 7365 5f6f 6e5f 6e6f  yer, raise_on_no
-00007850: 6765 6f6d 3d46 616c 7365 290d 0a0d 0a20  geom=False).... 
-00007860: 2020 2023 2047 6f21 0d0a 2020 2020 6461     # Go!..    da
-00007870: 7461 736f 7572 6365 203d 204e 6f6e 650d  tasource = None.
-00007880: 0a20 2020 2074 7279 3a0d 0a20 2020 2020  .    try:..     
-00007890: 2020 2023 2049 6620 636f 6c75 6d6e 2064     # If column d
-000078a0: 6f65 736e 2774 2065 7869 7374 2079 6574  oesn't exist yet
-000078b0: 2c20 6372 6561 7465 2069 740d 0a20 2020  , create it..   
-000078c0: 2020 2020 2063 6f6c 756d 6e73 5f75 7070       columns_upp
-000078d0: 6572 203d 205b 636f 6c75 6d6e 2e75 7070  er = [column.upp
-000078e0: 6572 2829 2066 6f72 2063 6f6c 756d 6e20  er() for column 
-000078f0: 696e 206c 6179 6572 696e 666f 5f6f 7269  in layerinfo_ori
-00007900: 672e 636f 6c75 6d6e 735d 0d0a 2020 2020  g.columns]..    
-00007910: 2020 2020 6966 206e 616d 652e 7570 7065      if name.uppe
-00007920: 7228 2920 6e6f 7420 696e 2063 6f6c 756d  r() not in colum
-00007930: 6e73 5f75 7070 6572 3a0d 0a20 2020 2020  ns_upper:..     
-00007940: 2020 2020 2020 2077 6964 7468 5f73 7472         width_str
-00007950: 203d 2066 2228 7b77 6964 7468 7d29 2220   = f"({width})" 
-00007960: 6966 2077 6964 7468 2069 7320 6e6f 7420  if width is not 
-00007970: 4e6f 6e65 2065 6c73 6520 2222 0d0a 2020  None else ""..  
-00007980: 2020 2020 2020 2020 2020 7371 6c5f 7374            sql_st
-00007990: 6d74 203d 2028 0d0a 2020 2020 2020 2020  mt = (..        
-000079a0: 2020 2020 2020 2020 6627 414c 5445 5220          f'ALTER 
-000079b0: 5441 424c 4520 227b 6c61 7965 727d 2220  TABLE "{layer}" 
-000079c0: 4144 4420 434f 4c55 4d4e 2022 7b6e 616d  ADD COLUMN "{nam
-000079d0: 657d 2220 7b74 7970 655f 7374 727d 7b77  e}" {type_str}{w
-000079e0: 6964 7468 5f73 7472 7d27 0d0a 2020 2020  idth_str}'..    
-000079f0: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-00007a00: 2020 2020 2020 2064 6174 6173 6f75 7263         datasourc
-00007a10: 6520 3d20 6764 616c 2e4f 7065 6e45 7828  e = gdal.OpenEx(
-00007a20: 7374 7228 7061 7468 292c 206e 4f70 656e  str(path), nOpen
-00007a30: 466c 6167 733d 6764 616c 2e4f 465f 5550  Flags=gdal.OF_UP
-00007a40: 4441 5445 290d 0a20 2020 2020 2020 2020  DATE)..         
-00007a50: 2020 2072 6573 756c 7420 3d20 6461 7461     result = data
-00007a60: 736f 7572 6365 2e45 7865 6375 7465 5351  source.ExecuteSQ
-00007a70: 4c28 7371 6c5f 7374 6d74 290d 0a20 2020  L(sql_stmt)..   
-00007a80: 2020 2020 2020 2020 2064 6174 6173 6f75           datasou
-00007a90: 7263 652e 5265 6c65 6173 6552 6573 756c  rce.ReleaseResul
-00007aa0: 7453 6574 2872 6573 756c 7429 0d0a 2020  tSet(result)..  
-00007ab0: 2020 2020 2020 656c 7365 3a0d 0a20 2020        else:..   
-00007ac0: 2020 2020 2020 2020 206c 6f67 6765 722e           logger.
-00007ad0: 7761 726e 696e 6728 6622 436f 6c75 6d6e  warning(f"Column
-00007ae0: 207b 6e61 6d65 7d20 6578 6973 7465 6420   {name} existed 
-00007af0: 616c 7265 6164 7920 696e 207b 7061 7468  already in {path
-00007b00: 7d2c 206c 6179 6572 207b 6c61 7965 727d  }, layer {layer}
-00007b10: 2229 0d0a 0d0a 2020 2020 2020 2020 2320  ")....        # 
-00007b20: 4966 2061 6e20 6578 7072 6573 7369 6f6e  If an expression
-00007b30: 2077 6173 2070 726f 7669 6465 6420 616e   was provided an
-00007b40: 6420 7570 6461 7465 2063 616e 2062 6520  d update can be 
-00007b50: 646f 6e65 2c20 676f 2066 6f72 2069 742e  done, go for it.
-00007b60: 2e2e 0d0a 2020 2020 2020 2020 6966 2065  ....        if e
-00007b70: 7870 7265 7373 696f 6e20 6973 206e 6f74  xpression is not
-00007b80: 204e 6f6e 6520 616e 6420 280d 0a20 2020   None and (..   
-00007b90: 2020 2020 2020 2020 206e 616d 6520 6e6f           name no
-00007ba0: 7420 696e 206c 6179 6572 696e 666f 5f6f  t in layerinfo_o
-00007bb0: 7269 672e 636f 6c75 6d6e 7320 6f72 2066  rig.columns or f
-00007bc0: 6f72 6365 5f75 7064 6174 6520 6973 2054  orce_update is T
-00007bd0: 7275 650d 0a20 2020 2020 2020 2029 3a0d  rue..        ):.
-00007be0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00007bf0: 6461 7461 736f 7572 6365 2069 7320 4e6f  datasource is No
-00007c00: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-00007c10: 2020 2020 2064 6174 6173 6f75 7263 6520       datasource 
-00007c20: 3d20 6764 616c 2e4f 7065 6e45 7828 7374  = gdal.OpenEx(st
-00007c30: 7228 7061 7468 292c 206e 4f70 656e 466c  r(path), nOpenFl
-00007c40: 6167 733d 6764 616c 2e4f 465f 5550 4441  ags=gdal.OF_UPDA
-00007c50: 5445 290d 0a20 2020 2020 2020 2020 2020  TE)..           
-00007c60: 2073 716c 5f73 746d 7420 3d20 6627 5550   sql_stmt = f'UP
-00007c70: 4441 5445 2022 7b6c 6179 6572 7d22 2053  DATE "{layer}" S
-00007c80: 4554 2022 7b6e 616d 657d 2220 3d20 7b65  ET "{name}" = {e
-00007c90: 7870 7265 7373 696f 6e7d 270d 0a20 2020  xpression}'..   
-00007ca0: 2020 2020 2020 2020 2072 6573 756c 7420           result 
-00007cb0: 3d20 6461 7461 736f 7572 6365 2e45 7865  = datasource.Exe
-00007cc0: 6375 7465 5351 4c28 7371 6c5f 7374 6d74  cuteSQL(sql_stmt
-00007cd0: 2c20 6469 616c 6563 743d 6578 7072 6573  , dialect=expres
-00007ce0: 7369 6f6e 5f64 6961 6c65 6374 290d 0a20  sion_dialect).. 
-00007cf0: 2020 2020 2020 2020 2020 2064 6174 6173             datas
-00007d00: 6f75 7263 652e 5265 6c65 6173 6552 6573  ource.ReleaseRes
-00007d10: 756c 7453 6574 2872 6573 756c 7429 0d0a  ultSet(result)..
-00007d20: 0d0a 2020 2020 6578 6365 7074 2045 7863  ..    except Exc
-00007d30: 6570 7469 6f6e 2061 7320 6578 3a0d 0a20  eption as ex:.. 
-00007d40: 2020 2020 2020 2065 782e 6172 6773 203d         ex.args =
-00007d50: 2028 6622 6164 645f 636f 6c75 6d6e 2065   (f"add_column e
-00007d60: 7272 6f72 2066 6f72 207b 7061 7468 7d2e  rror for {path}.
-00007d70: 7b6c 6179 6572 7d3a 5c6e 2020 7b65 787d  {layer}:\n  {ex}
-00007d80: 222c 290d 0a20 2020 2020 2020 2072 6169  ",)..        rai
-00007d90: 7365 0d0a 2020 2020 6669 6e61 6c6c 793a  se..    finally:
-00007da0: 0d0a 2020 2020 2020 2020 6461 7461 736f  ..        dataso
-00007db0: 7572 6365 203d 204e 6f6e 650d 0a0d 0a0d  urce = None.....
-00007dc0: 0a64 6566 2064 726f 705f 636f 6c75 6d6e  .def drop_column
-00007dd0: 280d 0a20 2020 2070 6174 683a 2055 6e69  (..    path: Uni
-00007de0: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
-00007df0: 4c69 6b65 5b41 6e79 5d22 5d2c 2063 6f6c  Like[Any]"], col
-00007e00: 756d 6e5f 6e61 6d65 3a20 7374 722c 206c  umn_name: str, l
-00007e10: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
-00007e20: 7472 5d20 3d20 4e6f 6e65 0d0a 293a 0d0a  tr] = None..):..
-00007e30: 2020 2020 2222 220d 0a20 2020 2044 726f      """..    Dro
-00007e40: 7020 7468 6520 636f 6c75 6d6e 2073 7065  p the column spe
-00007e50: 6369 6669 6564 2e0d 0a0d 0a20 2020 2041  cified.....    A
-00007e60: 7267 733a 0d0a 2020 2020 2020 2020 7061  rgs:..        pa
-00007e70: 7468 2028 5061 7468 4c69 6b65 293a 2054  th (PathLike): T
-00007e80: 6865 2066 696c 6520 7061 7468 2e0d 0a20  he file path... 
-00007e90: 2020 2020 2020 2063 6f6c 756d 6e5f 6e61         column_na
-00007ea0: 6d65 2028 7374 7229 3a20 7468 6520 636f  me (str): the co
-00007eb0: 6c75 6d6e 206e 616d 652e 0d0a 2020 2020  lumn name...    
-00007ec0: 2020 2020 6c61 7965 7220 284f 7074 696f      layer (Optio
-00007ed0: 6e61 6c5b 7374 725d 293a 2054 6865 206c  nal[str]): The l
-00007ee0: 6179 6572 206e 616d 652e 2049 6620 6e6f  ayer name. If no
-00007ef0: 7420 7370 6563 6966 6965 642c 2061 6e64  t specified, and
-00007f00: 2074 6865 7265 2069 7320 6f6e 6c79 0d0a   there is only..
-00007f10: 2020 2020 2020 2020 2020 2020 6f6e 6520              one 
-00007f20: 6c61 7965 7220 696e 2074 6865 2066 696c  layer in the fil
-00007f30: 652c 2074 6869 7320 6c61 7965 7220 6973  e, this layer is
-00007f40: 2075 7365 642e 204f 7468 6572 7769 7365   used. Otherwise
-00007f50: 2061 2056 616c 7565 4572 726f 7220 6973   a ValueError is
-00007f60: 0d0a 2020 2020 2020 2020 2020 2020 7261  ..            ra
-00007f70: 6973 6564 2e0d 0a20 2020 2022 2222 0d0a  ised...    """..
-00007f80: 2020 2020 2320 4368 6563 6b20 696e 7075      # Check inpu
-00007f90: 7420 7061 7261 6d65 7465 7273 0d0a 2020  t parameters..  
-00007fa0: 2020 7061 7468 203d 2050 6174 6828 7061    path = Path(pa
-00007fb0: 7468 290d 0a20 2020 2069 6620 6c61 7965  th)..    if laye
-00007fc0: 7220 6973 204e 6f6e 653a 0d0a 2020 2020  r is None:..    
-00007fd0: 2020 2020 6c61 7965 7220 3d20 6765 745f      layer = get_
-00007fe0: 6f6e 6c79 5f6c 6179 6572 2870 6174 6829  only_layer(path)
-00007ff0: 0d0a 2020 2020 696e 666f 203d 2067 6574  ..    info = get
-00008000: 5f6c 6179 6572 696e 666f 2870 6174 682c  _layerinfo(path,
-00008010: 206c 6179 6572 2c20 7261 6973 655f 6f6e   layer, raise_on
-00008020: 5f6e 6f67 656f 6d3d 4661 6c73 6529 0d0a  _nogeom=False)..
-00008030: 2020 2020 6966 2063 6f6c 756d 6e5f 6e61      if column_na
-00008040: 6d65 206e 6f74 2069 6e20 696e 666f 2e63  me not in info.c
-00008050: 6f6c 756d 6e73 3a0d 0a20 2020 2020 2020  olumns:..       
-00008060: 206c 6f67 6765 722e 696e 666f 2866 2243   logger.info(f"C
-00008070: 6f6c 756d 6e20 7b63 6f6c 756d 6e5f 6e61  olumn {column_na
-00008080: 6d65 7d20 6e6f 7420 7072 6573 656e 7420  me} not present 
-00008090: 736f 2063 616e 6e6f 7420 6265 2064 726f  so cannot be dro
-000080a0: 7070 6564 2e22 290d 0a20 2020 2020 2020  pped.")..       
-000080b0: 2072 6574 7572 6e0d 0a0d 0a20 2020 2023   return....    #
-000080c0: 204e 6f77 2072 6561 6c6c 7920 7265 6e61   Now really rena
-000080d0: 6d65 0d0a 2020 2020 6461 7461 736f 7572  me..    datasour
-000080e0: 6365 203d 204e 6f6e 650d 0a20 2020 2074  ce = None..    t
-000080f0: 7279 3a0d 0a20 2020 2020 2020 2064 6174  ry:..        dat
-00008100: 6173 6f75 7263 6520 3d20 6764 616c 2e4f  asource = gdal.O
-00008110: 7065 6e45 7828 7374 7228 7061 7468 292c  penEx(str(path),
-00008120: 206e 4f70 656e 466c 6167 733d 6764 616c   nOpenFlags=gdal
-00008130: 2e4f 465f 5550 4441 5445 290d 0a20 2020  .OF_UPDATE)..   
-00008140: 2020 2020 2073 716c 5f73 746d 7420 3d20       sql_stmt = 
-00008150: 6627 414c 5445 5220 5441 424c 4520 227b  f'ALTER TABLE "{
-00008160: 6c61 7965 727d 2220 4452 4f50 2043 4f4c  layer}" DROP COL
-00008170: 554d 4e20 227b 636f 6c75 6d6e 5f6e 616d  UMN "{column_nam
-00008180: 657d 2227 0d0a 2020 2020 2020 2020 7265  e}"'..        re
-00008190: 7375 6c74 203d 2064 6174 6173 6f75 7263  sult = datasourc
-000081a0: 652e 4578 6563 7574 6553 514c 2873 716c  e.ExecuteSQL(sql
-000081b0: 5f73 746d 7429 0d0a 2020 2020 2020 2020  _stmt)..        
-000081c0: 6461 7461 736f 7572 6365 2e52 656c 6561  datasource.Relea
-000081d0: 7365 5265 7375 6c74 5365 7428 7265 7375  seResultSet(resu
-000081e0: 6c74 290d 0a0d 0a20 2020 2065 7863 6570  lt)....    excep
-000081f0: 7420 4578 6365 7074 696f 6e20 6173 2065  t Exception as e
-00008200: 783a 0d0a 2020 2020 2020 2020 6578 2e61  x:..        ex.a
-00008210: 7267 7320 3d20 2866 2264 726f 705f 636f  rgs = (f"drop_co
-00008220: 6c75 6d6e 2065 7272 6f72 2066 6f72 207b  lumn error for {
-00008230: 7061 7468 7d2e 7b6c 6179 6572 7d3a 5c6e  path}.{layer}:\n
-00008240: 2020 7b65 787d 222c 290d 0a20 2020 2020    {ex}",)..     
-00008250: 2020 2072 6169 7365 0d0a 2020 2020 6669     raise..    fi
-00008260: 6e61 6c6c 793a 0d0a 2020 2020 2020 2020  nally:..        
-00008270: 6461 7461 736f 7572 6365 203d 204e 6f6e  datasource = Non
-00008280: 650d 0a0d 0a0d 0a64 6566 2075 7064 6174  e......def updat
-00008290: 655f 636f 6c75 6d6e 280d 0a20 2020 2070  e_column(..    p
-000082a0: 6174 683a 2055 6e69 6f6e 5b73 7472 2c20  ath: Union[str, 
-000082b0: 226f 732e 5061 7468 4c69 6b65 5b41 6e79  "os.PathLike[Any
-000082c0: 5d22 5d2c 0d0a 2020 2020 6e61 6d65 3a20  ]"],..    name: 
-000082d0: 7374 722c 0d0a 2020 2020 6578 7072 6573  str,..    expres
-000082e0: 7369 6f6e 3a20 7374 722c 0d0a 2020 2020  sion: str,..    
-000082f0: 6c61 7965 723a 204f 7074 696f 6e61 6c5b  layer: Optional[
-00008300: 7374 725d 203d 204e 6f6e 652c 0d0a 2020  str] = None,..  
-00008310: 2020 7768 6572 653a 204f 7074 696f 6e61    where: Optiona
-00008320: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
-00008330: 293a 0d0a 2020 2020 2222 220d 0a20 2020  ):..    """..   
-00008340: 2055 7064 6174 6520 6120 636f 6c75 6d6e   Update a column
-00008350: 2066 726f 6d20 6120 6c61 7965 7220 6f66   from a layer of
-00008360: 2074 6865 2067 656f 6669 6c65 2e0d 0a0d   the geofile....
-00008370: 0a20 2020 2041 7267 733a 0d0a 2020 2020  .    Args:..    
-00008380: 2020 2020 7061 7468 2028 5061 7468 4c69      path (PathLi
-00008390: 6b65 293a 2050 6174 6820 746f 2074 6865  ke): Path to the
-000083a0: 2067 656f 6669 6c65 0d0a 2020 2020 2020   geofile..      
-000083b0: 2020 6e61 6d65 2028 7374 7229 3a20 4e61    name (str): Na
-000083c0: 6d65 2066 6f72 2074 6865 206e 6577 2063  me for the new c
-000083d0: 6f6c 756d 6e0d 0a20 2020 2020 2020 2065  olumn..        e
-000083e0: 7870 7265 7373 696f 6e20 2873 7472 293a  xpression (str):
-000083f0: 2053 514c 6974 6520 6578 7072 6573 7369   SQLite expressi
-00008400: 6f6e 2074 6f20 7573 6520 746f 2075 7064  on to use to upd
-00008410: 6174 6520 7468 6520 7661 6c75 652e 0d0a  ate the value...
-00008420: 2020 2020 2020 2020 6c61 7965 7220 2873          layer (s
-00008430: 7472 2c20 6f70 7469 6f6e 616c 293a 2054  tr, optional): T
-00008440: 6865 206c 6179 6572 206e 616d 652e 2049  he layer name. I
-00008450: 6620 4e6f 6e65 2061 6e64 2074 6865 2067  f None and the g
-00008460: 656f 6669 6c65 0d0a 2020 2020 2020 2020  eofile..        
-00008470: 2020 2020 6861 7320 6f6e 6c79 206f 6e65      has only one
-00008480: 206c 6179 6572 2c20 7468 6174 206c 6179   layer, that lay
-00008490: 6572 2069 7320 7573 6564 2e20 4465 6661  er is used. Defa
-000084a0: 756c 7473 2074 6f20 4e6f 6e65 2e0d 0a20  ults to None... 
-000084b0: 2020 2020 2020 2077 6865 7265 2028 7374         where (st
-000084c0: 722c 206f 7074 696f 6e61 6c29 3a20 5351  r, optional): SQ
-000084d0: 4c20 7768 6572 6520 636c 6175 7365 2074  L where clause t
-000084e0: 6f20 7265 7374 7269 6374 2074 6865 2072  o restrict the r
-000084f0: 6f77 7320 7468 6174 2077 696c 6c0d 0a20  ows that will.. 
-00008500: 2020 2020 2020 2020 2020 2062 6520 7570             be up
-00008510: 6461 7465 642e 2044 6566 6175 6c74 7320  dated. Defaults 
-00008520: 746f 204e 6f6e 652e 0d0a 0d0a 2020 2020  to None.....    
-00008530: 5261 6973 6573 3a0d 0a20 2020 2020 2020  Raises:..       
-00008540: 2056 616c 7565 4572 726f 723a 2061 6e20   ValueError: an 
-00008550: 696e 7661 6c69 6420 7061 7261 6d65 7465  invalid paramete
-00008560: 7220 7661 6c75 6520 7761 7320 7061 7373  r value was pass
-00008570: 6564 2e0d 0a20 2020 2022 2222 0d0a 2020  ed...    """..  
-00008580: 2020 2320 496e 6974 0d0a 2020 2020 7061    # Init..    pa
-00008590: 7468 203d 2050 6174 6828 7061 7468 290d  th = Path(path).
-000085a0: 0a20 2020 2069 6620 6c61 7965 7220 6973  .    if layer is
-000085b0: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-000085c0: 6c61 7965 7220 3d20 6765 745f 6f6e 6c79  layer = get_only
-000085d0: 5f6c 6179 6572 2870 6174 6829 0d0a 2020  _layer(path)..  
-000085e0: 2020 6c61 7965 7269 6e66 6f5f 6f72 6967    layerinfo_orig
-000085f0: 203d 2067 6574 5f6c 6179 6572 696e 666f   = get_layerinfo
-00008600: 2870 6174 682c 206c 6179 6572 290d 0a20  (path, layer).. 
-00008610: 2020 2063 6f6c 756d 6e73 5f75 7070 6572     columns_upper
-00008620: 203d 205b 636f 6c75 6d6e 2e75 7070 6572   = [column.upper
-00008630: 2829 2066 6f72 2063 6f6c 756d 6e20 696e  () for column in
-00008640: 206c 6179 6572 696e 666f 5f6f 7269 672e   layerinfo_orig.
-00008650: 636f 6c75 6d6e 735d 0d0a 2020 2020 6966  columns]..    if
-00008660: 206c 6179 6572 696e 666f 5f6f 7269 672e   layerinfo_orig.
-00008670: 6765 6f6d 6574 7279 636f 6c75 6d6e 2069  geometrycolumn i
-00008680: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
-00008690: 2020 2020 2063 6f6c 756d 6e73 5f75 7070       columns_upp
-000086a0: 6572 2e61 7070 656e 6428 6c61 7965 7269  er.append(layeri
-000086b0: 6e66 6f5f 6f72 6967 2e67 656f 6d65 7472  nfo_orig.geometr
-000086c0: 7963 6f6c 756d 6e2e 7570 7065 7228 2929  ycolumn.upper())
-000086d0: 0d0a 2020 2020 6966 206e 616d 652e 7570  ..    if name.up
-000086e0: 7065 7228 2920 6e6f 7420 696e 2063 6f6c  per() not in col
-000086f0: 756d 6e73 5f75 7070 6572 3a0d 0a20 2020  umns_upper:..   
-00008700: 2020 2020 2023 2049 6620 636f 6c75 6d6e       # If column
-00008710: 2064 6f65 736e 2774 2065 7869 7374 2079   doesn't exist y
-00008720: 6574 2c20 6572 726f 7221 0d0a 2020 2020  et, error!..    
-00008730: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-00008740: 7272 6f72 2866 2243 6f6c 756d 6e20 7b6e  rror(f"Column {n
-00008750: 616d 657d 2064 6f65 736e 2774 2065 7869  ame} doesn't exi
-00008760: 7374 2069 6e20 7b70 6174 687d 2c20 6c61  st in {path}, la
-00008770: 7965 7220 7b6c 6179 6572 7d22 290d 0a0d  yer {layer}")...
-00008780: 0a20 2020 2023 2047 6f21 0d0a 2020 2020  .    # Go!..    
-00008790: 6461 7461 736f 7572 6365 203d 204e 6f6e  datasource = Non
-000087a0: 650d 0a20 2020 2074 7279 3a0d 0a20 2020  e..    try:..   
-000087b0: 2020 2020 2064 6174 6173 6f75 7263 6520       datasource 
-000087c0: 3d20 6764 616c 2e4f 7065 6e45 7828 7374  = gdal.OpenEx(st
-000087d0: 7228 7061 7468 292c 206e 4f70 656e 466c  r(path), nOpenFl
-000087e0: 6167 733d 6764 616c 2e4f 465f 5550 4441  ags=gdal.OF_UPDA
-000087f0: 5445 290d 0a20 2020 2020 2020 2073 716c  TE)..        sql
-00008800: 6974 655f 7374 6d74 203d 2066 2755 5044  ite_stmt = f'UPD
-00008810: 4154 4520 227b 6c61 7965 727d 2220 5345  ATE "{layer}" SE
-00008820: 5420 227b 6e61 6d65 7d22 203d 207b 6578  T "{name}" = {ex
-00008830: 7072 6573 7369 6f6e 7d27 0d0a 2020 2020  pression}'..    
-00008840: 2020 2020 6966 2077 6865 7265 2069 7320      if where is 
-00008850: 6e6f 7420 4e6f 6e65 3a0d 0a20 2020 2020  not None:..     
-00008860: 2020 2020 2020 2073 716c 6974 655f 7374         sqlite_st
-00008870: 6d74 202b 3d20 6622 5c6e 2057 4845 5245  mt += f"\n WHERE
-00008880: 207b 7768 6572 657d 220d 0a20 2020 2020   {where}"..     
-00008890: 2020 2072 6573 756c 7420 3d20 6461 7461     result = data
-000088a0: 736f 7572 6365 2e45 7865 6375 7465 5351  source.ExecuteSQ
-000088b0: 4c28 7371 6c69 7465 5f73 746d 742c 2064  L(sqlite_stmt, d
-000088c0: 6961 6c65 6374 3d22 5351 4c49 5445 2229  ialect="SQLITE")
-000088d0: 0d0a 2020 2020 2020 2020 6461 7461 736f  ..        dataso
-000088e0: 7572 6365 2e52 656c 6561 7365 5265 7375  urce.ReleaseResu
-000088f0: 6c74 5365 7428 7265 7375 6c74 290d 0a0d  ltSet(result)...
-00008900: 0a20 2020 2065 7863 6570 7420 4578 6365  .    except Exce
-00008910: 7074 696f 6e20 6173 2065 783a 0d0a 2020  ption as ex:..  
-00008920: 2020 2020 2020 6578 2e61 7267 7320 3d20        ex.args = 
-00008930: 2866 2275 7064 6174 655f 636f 6c75 6d6e  (f"update_column
-00008940: 2065 7272 6f72 2066 6f72 207b 7061 7468   error for {path
-00008950: 7d2e 7b6c 6179 6572 7d3a 5c6e 2020 7b65  }.{layer}:\n  {e
-00008960: 787d 222c 290d 0a20 2020 2020 2020 2072  x}",)..        r
-00008970: 6169 7365 0d0a 2020 2020 6669 6e61 6c6c  aise..    finall
-00008980: 793a 0d0a 2020 2020 2020 2020 6461 7461  y:..        data
-00008990: 736f 7572 6365 203d 204e 6f6e 650d 0a0d  source = None...
-000089a0: 0a0d 0a64 6566 2072 6561 645f 6669 6c65  ...def read_file
-000089b0: 280d 0a20 2020 2070 6174 683a 2055 6e69  (..    path: Uni
-000089c0: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
-000089d0: 4c69 6b65 5b41 6e79 5d22 5d2c 0d0a 2020  Like[Any]"],..  
-000089e0: 2020 6c61 7965 723a 204f 7074 696f 6e61    layer: Optiona
-000089f0: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
-00008a00: 2020 2020 636f 6c75 6d6e 733a 204f 7074      columns: Opt
-00008a10: 696f 6e61 6c5b 4974 6572 6162 6c65 5b73  ional[Iterable[s
-00008a20: 7472 5d5d 203d 204e 6f6e 652c 0d0a 2020  tr]] = None,..  
-00008a30: 2020 6262 6f78 3d4e 6f6e 652c 0d0a 2020    bbox=None,..  
-00008a40: 2020 726f 7773 3d4e 6f6e 652c 0d0a 2020    rows=None,..  
-00008a50: 2020 7768 6572 653a 204f 7074 696f 6e61    where: Optiona
-00008a60: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
-00008a70: 2020 2020 7371 6c5f 7374 6d74 3a20 4f70      sql_stmt: Op
-00008a80: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
-00008a90: 6e65 2c0d 0a20 2020 2073 716c 5f64 6961  ne,..    sql_dia
-00008aa0: 6c65 6374 3a20 4f70 7469 6f6e 616c 5b4c  lect: Optional[L
-00008ab0: 6974 6572 616c 5b22 5351 4c49 5445 222c  iteral["SQLITE",
-00008ac0: 2022 4f47 5253 514c 225d 5d20 3d20 4e6f   "OGRSQL"]] = No
-00008ad0: 6e65 2c0d 0a20 2020 2069 676e 6f72 655f  ne,..    ignore_
-00008ae0: 6765 6f6d 6574 7279 3a20 626f 6f6c 203d  geometry: bool =
-00008af0: 2046 616c 7365 2c0d 0a20 2020 2066 6964   False,..    fid
-00008b00: 5f61 735f 696e 6465 783a 2062 6f6f 6c20  _as_index: bool 
-00008b10: 3d20 4661 6c73 652c 0d0a 2920 2d3e 2067  = False,..) -> g
-00008b20: 7064 2e47 656f 4461 7461 4672 616d 653a  pd.GeoDataFrame:
-00008b30: 0d0a 2020 2020 2222 220d 0a20 2020 2052  ..    """..    R
-00008b40: 6561 6473 2061 2066 696c 6520 746f 2061  eads a file to a
-00008b50: 2067 656f 7061 6e64 6173 2047 656f 4461   geopandas GeoDa
-00008b60: 7461 6672 616d 652e 0d0a 0d0a 2020 2020  taframe.....    
-00008b70: 5468 6520 6669 6c65 2066 6f72 6d61 7420  The file format 
-00008b80: 6973 2064 6574 6563 7465 6420 6261 7365  is detected base
-00008b90: 6420 6f6e 2074 6865 2066 696c 6570 6174  d on the filepat
-00008ba0: 6820 6578 7465 6e73 696f 6e2e 0d0a 0d0a  h extension.....
-00008bb0: 2020 2020 4966 2060 6073 716c 5f73 746d      If ``sql_stm
-00008bc0: 7460 6020 6973 2073 7065 6369 6669 6564  t`` is specified
-00008bd0: 2c20 7468 6520 7371 6c69 7465 2071 7565  , the sqlite que
-00008be0: 7279 2063 616e 2063 6f6e 7461 696e 2066  ry can contain f
-00008bf0: 6f6c 6c6f 7769 6e67 2070 6c61 6365 686f  ollowing placeho
-00008c00: 6c64 6572 730d 0a20 2020 2074 6861 7420  lders..    that 
-00008c10: 7769 6c6c 2062 6520 6175 746f 6d61 7469  will be automati
-00008c20: 6361 6c6c 7920 7265 706c 6163 6564 2066  cally replaced f
-00008c30: 6f72 2079 6f75 3a0d 0a0d 0a20 2020 2020  or you:....     
-00008c40: 202a 207b 6765 6f6d 6574 7279 636f 6c75   * {geometrycolu
-00008c50: 6d6e 7d3a 2074 6865 2063 6f6c 756d 6e20  mn}: the column 
-00008c60: 7768 6572 6520 7468 6520 7072 696d 6172  where the primar
-00008c70: 7920 6765 6f6d 6574 7279 2069 7320 7374  y geometry is st
-00008c80: 6f72 6564 2e0d 0a20 2020 2020 202a 207b  ored...      * {
-00008c90: 636f 6c75 6d6e 735f 746f 5f73 656c 6563  columns_to_selec
-00008ca0: 745f 7374 727d 3a20 6966 2060 6063 6f6c  t_str}: if ``col
-00008cb0: 756d 6e73 6060 2069 7320 6e6f 7420 4e6f  umns`` is not No
-00008cc0: 6e65 2c20 7468 6f73 6520 636f 6c75 6d6e  ne, those column
-00008cd0: 732c 0d0a 2020 2020 2020 2020 6f74 6865  s,..        othe
-00008ce0: 7277 6973 6520 616c 6c20 636f 6c75 6d6e  rwise all column
-00008cf0: 7320 6f66 2074 6865 206c 6179 6572 2e0d  s of the layer..
-00008d00: 0a20 2020 2020 202a 207b 696e 7075 745f  .      * {input_
-00008d10: 6c61 7965 727d 3a20 7468 6520 6c61 7965  layer}: the laye
-00008d20: 7220 6e61 6d65 206f 6620 7468 6520 696e  r name of the in
-00008d30: 7075 7420 6c61 7965 722e 0d0a 0d0a 2020  put layer.....  
-00008d40: 2020 4578 616d 706c 6520 5351 4c20 7374    Example SQL st
-00008d50: 6174 656d 656e 7420 7769 7468 2070 6c61  atement with pla
-00008d60: 6365 686f 6c64 6572 733a 0d0a 2020 2020  ceholders:..    
-00008d70: 3a3a 0d0a 0d0a 2020 2020 2020 2020 5345  ::....        SE
-00008d80: 4c45 4354 207b 6765 6f6d 6574 7279 636f  LECT {geometryco
-00008d90: 6c75 6d6e 7d0d 0a20 2020 2020 2020 2020  lumn}..         
-00008da0: 2020 2020 207b 636f 6c75 6d6e 735f 746f       {columns_to
-00008db0: 5f73 656c 6563 745f 7374 727d 0d0a 2020  _select_str}..  
-00008dc0: 2020 2020 2020 2020 4652 4f4d 2022 7b69          FROM "{i
-00008dd0: 6e70 7574 5f6c 6179 6572 7d22 206c 6179  nput_layer}" lay
-00008de0: 6572 0d0a 0d0a 2020 2020 5468 6520 756e  er....    The un
-00008df0: 6465 726c 7969 6e67 206c 6962 7261 7279  derlying library
-00008e00: 2075 7365 6420 746f 2072 6561 6420 7468   used to read th
-00008e10: 6520 6669 6c65 2063 616e 2062 6520 6368  e file can be ch
-00008e20: 6f6f 7365 6e20 7573 696e 6720 7468 650d  oosen using the.
-00008e30: 0a20 2020 2022 4746 4f5f 494f 5f45 4e47  .    "GFO_IO_ENG
-00008e40: 494e 4522 2065 6e76 6972 6f6e 6d65 6e74  INE" environment
-00008e50: 2076 6172 6961 626c 652e 2050 6f73 7369   variable. Possi
-00008e60: 626c 6520 7661 6c75 6573 2061 7265 2022  ble values are "
-00008e70: 6669 6f6e 6122 2061 6e64 2022 7079 6f67  fiona" and "pyog
-00008e80: 7269 6f22 2e0d 0a20 2020 2054 6869 7320  rio"...    This 
-00008e90: 6f70 7469 6f6e 2069 7320 6372 6561 7465  option is create
-00008ea0: 6420 6173 2061 2074 656d 706f 7261 7279  d as a temporary
-00008eb0: 2066 616c 6c62 6163 6b20 746f 2022 6669   fallback to "fi
-00008ec0: 6f6e 6122 2066 6f72 2063 6173 6573 2077  ona" for cases w
-00008ed0: 6865 7265 2022 7079 6f67 7269 6f22 0d0a  here "pyogrio"..
-00008ee0: 2020 2020 6769 7665 7320 6973 7375 6573      gives issues
-00008ef0: 2c20 736f 2070 6c65 6173 6520 7265 706f  , so please repo
-00008f00: 7274 2069 7373 7565 7320 6966 2074 6865  rt issues if the
-00008f10: 7920 6172 6520 656e 636f 756e 7465 7265  y are encountere
-00008f20: 642e 2049 6e20 7468 6520 6675 7475 7265  d. In the future
-00008f30: 2073 7570 706f 7274 0d0a 2020 2020 666f   support..    fo
-00008f40: 7220 7468 6520 2266 696f 6e61 2220 656e  r the "fiona" en
-00008f50: 6769 6e65 206d 6f73 7420 6c69 6b65 6c79  gine most likely
-00008f60: 2077 696c 6c20 6265 2072 656d 6f76 6564   will be removed
-00008f70: 2e20 4465 6661 756c 7420 656e 6769 6e65  . Default engine
-00008f80: 2069 7320 2270 796f 6772 696f 222e 0d0a   is "pyogrio"...
-00008f90: 0d0a 2020 2020 4172 6773 3a0d 0a20 2020  ..    Args:..   
-00008fa0: 2020 2020 2070 6174 6820 2866 696c 6520       path (file 
-00008fb0: 7061 7468 293a 2070 6174 6820 746f 2074  path): path to t
-00008fc0: 6865 2066 696c 6520 746f 2072 6561 6420  he file to read 
-00008fd0: 6672 6f6d 0d0a 2020 2020 2020 2020 6c61  from..        la
-00008fe0: 7965 7220 2873 7472 2c20 6f70 7469 6f6e  yer (str, option
-00008ff0: 616c 293a 2054 6865 206c 6179 6572 2074  al): The layer t
-00009000: 6f20 7265 6164 2e20 4966 204e 6f6e 6520  o read. If None 
-00009010: 616e 6420 7468 6572 6520 6973 206f 6e6c  and there is onl
-00009020: 7920 6f6e 6520 6c61 7965 7220 696e 0d0a  y one layer in..
-00009030: 2020 2020 2020 2020 2020 2020 7468 6520              the 
-00009040: 6669 6c65 2069 7420 6973 2072 6561 642c  file it is read,
-00009050: 206f 7468 6572 7769 7365 2061 6e20 6572   otherwise an er
-00009060: 726f 7220 6973 2074 6872 6f77 6e2e 2044  ror is thrown. D
-00009070: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
-00009080: 0d0a 2020 2020 2020 2020 636f 6c75 6d6e  ..        column
-00009090: 7320 2849 7465 7261 626c 655b 7374 725d  s (Iterable[str]
-000090a0: 2c20 6f70 7469 6f6e 616c 293a 2054 6865  , optional): The
-000090b0: 2028 6e6f 6e2d 6765 6f6d 6574 7279 2920   (non-geometry) 
-000090c0: 636f 6c75 6d6e 7320 746f 2072 6561 6420  columns to read 
-000090d0: 7769 6c6c 0d0a 2020 2020 2020 2020 2020  will..          
-000090e0: 2020 6265 2072 6574 7572 6e65 6420 696e    be returned in
-000090f0: 2074 6865 206f 7264 6572 2073 7065 6369   the order speci
-00009100: 6669 6564 2e20 4966 204e 6f6e 652c 2061  fied. If None, a
-00009110: 6c6c 2073 7461 6e64 6172 6420 636f 6c75  ll standard colu
-00009120: 6d6e 7320 6172 6520 7265 6164 2e0d 0a20  mns are read... 
-00009130: 2020 2020 2020 2020 2020 2049 6e20 6164             In ad
-00009140: 6469 7469 6f6e 2074 6f20 7374 616e 6461  dition to standa
-00009150: 7264 2063 6f6c 756d 6e73 2c20 6974 2069  rd columns, it i
-00009160: 7320 616c 736f 2070 6f73 7369 626c 650d  s also possible.
-00009170: 0a20 2020 2020 2020 2020 2020 2074 6f20  .            to 
-00009180: 7370 6563 6966 7920 2266 6964 222c 2061  specify "fid", a
-00009190: 2075 6e69 7175 6520 696e 6465 7820 6176   unique index av
-000091a0: 6169 6c61 626c 6520 696e 2061 6c6c 2069  ailable in all i
-000091b0: 6e70 7574 2066 696c 6573 2e20 4e6f 7465  nput files. Note
-000091c0: 2074 6861 7420 7468 650d 0a20 2020 2020   that the..     
-000091d0: 2020 2020 2020 2022 6669 6422 2077 696c         "fid" wil
-000091e0: 6c20 6265 2061 6c69 6173 6564 2065 672e  l be aliased eg.
-000091f0: 2074 6f20 2266 6964 5f31 222e 2044 6566   to "fid_1". Def
-00009200: 6175 6c74 7320 746f 204e 6f6e 652e 0d0a  aults to None...
-00009210: 2020 2020 2020 2020 6262 6f78 2028 5475          bbox (Tu
-00009220: 706c 652c 206f 7074 696f 6e61 6c29 3a20  ple, optional): 
-00009230: 7265 7475 726e 206f 6e6c 7920 6765 6f6d  return only geom
-00009240: 6574 7269 6573 2069 6e74 6572 7365 6374  etries intersect
-00009250: 696e 6720 7468 6973 2062 626f 782e 0d0a  ing this bbox...
-00009260: 2020 2020 2020 2020 2020 2020 4465 6661              Defa
-00009270: 756c 7473 2074 6f20 4e6f 6e65 2c20 7468  ults to None, th
-00009280: 656e 2061 6c6c 2072 6f77 7320 6172 6520  en all rows are 
-00009290: 7265 6164 2e0d 0a20 2020 2020 2020 2072  read...        r
-000092a0: 6f77 7320 2873 6c69 6365 2c20 6f70 7469  ows (slice, opti
-000092b0: 6f6e 616c 293a 2072 6574 7572 6e20 6f6e  onal): return on
-000092c0: 6c79 2074 6865 2072 6f77 7320 7370 6563  ly the rows spec
-000092d0: 6966 6965 642e 2046 6f72 206d 616e 7920  ified. For many 
-000092e0: 6669 6c65 2066 6f72 6d61 7473 0d0a 2020  file formats..  
-000092f0: 2020 2020 2020 2020 2020 2865 2e67 2e20            (e.g. 
-00009300: 4765 6f70 6163 6b61 6765 2920 7468 6973  Geopackage) this
-00009310: 2069 7320 736c 6f77 2c20 736f 2075 7369   is slow, so usi
-00009320: 6e67 2065 2e67 2e20 6120 7768 6572 6520  ng e.g. a where 
-00009330: 6669 6c74 6572 2069 6e73 7465 6164 2069  filter instead i
-00009340: 730d 0a20 2020 2020 2020 2020 2020 2072  s..            r
-00009350: 6563 6f6d 6d65 6e64 6564 2e20 4465 6661  ecommended. Defa
-00009360: 756c 7473 2074 6f20 4e6f 6e65 2c20 7468  ults to None, th
-00009370: 656e 2061 6c6c 2072 6f77 7320 6172 6520  en all rows are 
-00009380: 7265 7475 726e 6564 2e0d 0a20 2020 2020  returned...     
-00009390: 2020 2077 6865 7265 2028 7374 722c 206f     where (str, o
-000093a0: 7074 696f 6e61 6c29 3a20 7768 6572 6520  ptional): where 
-000093b0: 636c 6175 7365 2074 6f20 6669 6c74 6572  clause to filter
-000093c0: 2066 6561 7475 7265 7320 696e 206c 6179   features in lay
-000093d0: 6572 2062 7920 6174 7472 6962 7574 650d  er by attribute.
-000093e0: 0a20 2020 2020 2020 2020 2020 2076 616c  .            val
-000093f0: 7565 732e 2049 6620 7468 6520 6461 7461  ues. If the data
-00009400: 736f 7572 6365 206e 6174 6976 656c 7920  source natively 
-00009410: 7375 7070 6f72 7473 2073 716c 2c20 6974  supports sql, it
-00009420: 7320 7370 6563 6966 6963 2053 514c 2064  s specific SQL d
-00009430: 6961 6c65 6374 0d0a 2020 2020 2020 2020  ialect..        
-00009440: 2020 2020 7368 6f75 6c64 2062 6520 7573      should be us
-00009450: 6564 2028 6567 2e20 5351 4c69 7465 2061  ed (eg. SQLite a
-00009460: 6e64 2047 656f 5061 636b 6167 653a 2060  nd GeoPackage: `
-00009470: 5351 4c49 5445 605f 2c20 506f 7374 6772  SQLITE`_, Postgr
-00009480: 6553 514c 292e 2049 6620 6974 0d0a 2020  eSQL). If it..  
-00009490: 2020 2020 2020 2020 2020 646f 6573 6e27            doesn'
-000094a0: 742c 2074 6865 2060 4f47 5253 514c 2057  t, the `OGRSQL W
-000094b0: 4845 5245 605f 2073 796e 7461 7820 7368  HERE`_ syntax sh
-000094c0: 6f75 6c64 2062 6520 7573 6564 2e20 4e6f  ould be used. No
-000094d0: 7465 2074 6861 7420 6974 2069 7320 6e6f  te that it is no
-000094e0: 740d 0a20 2020 2020 2020 2020 2020 2070  t..            p
-000094f0: 6f73 7369 626c 6520 746f 206f 7665 7272  ossible to overr
-00009500: 756c 6520 7468 6520 5351 4c20 6469 616c  ule the SQL dial
-00009510: 6563 742c 2074 6869 7320 6973 206f 6e6c  ect, this is onl
-00009520: 7920 706f 7373 6962 6c65 2077 6865 6e20  y possible when 
-00009530: 796f 7520 7573 6520 7468 650d 0a20 2020  you use the..   
-00009540: 2020 2020 2020 2020 2053 514c 2070 6172           SQL par
-00009550: 616d 6574 6572 2e20 4578 616d 706c 6573  ameter. Examples
-00009560: 3a20 6060 2249 534f 5f41 3320 3d20 2743  : ``"ISO_A3 = 'C
-00009570: 414e 2722 6060 2c0d 0a20 2020 2020 2020  AN'"``,..       
-00009580: 2020 2020 2060 6022 504f 505f 4553 5420       ``"POP_EST 
-00009590: 3e20 3130 3030 3030 3030 2041 4e44 2050  > 10000000 AND P
-000095a0: 4f50 5f45 5354 203c 2031 3030 3030 3030  OP_EST < 1000000
-000095b0: 3030 2260 602e 2044 6566 6175 6c74 7320  00"``. Defaults 
-000095c0: 746f 204e 6f6e 652e 0d0a 2020 2020 2020  to None...      
-000095d0: 2020 7371 6c5f 7374 6d74 2028 7374 7229    sql_stmt (str)
-000095e0: 3a20 5351 4c20 7374 6174 656d 656e 7420  : SQL statement 
-000095f0: 746f 2075 7365 2e20 4f6e 6c79 2073 7570  to use. Only sup
-00009600: 706f 7274 6564 2077 6974 6820 2270 796f  ported with "pyo
-00009610: 6772 696f 2220 656e 6769 6e65 2e0d 0a20  grio" engine... 
-00009620: 2020 2020 2020 2073 716c 5f64 6961 6c65         sql_diale
-00009630: 6374 2028 7374 722c 206f 7074 696f 6e61  ct (str, optiona
-00009640: 6c29 3a20 5351 4c20 6469 616c 6563 7420  l): SQL dialect 
-00009650: 7573 6564 2e20 4f70 7469 6f6e 7320 6172  used. Options ar
-00009660: 6520 4e6f 6e65 2c20 2253 514c 4954 4522  e None, "SQLITE"
-00009670: 206f 720d 0a20 2020 2020 2020 2020 2020   or..           
-00009680: 2022 4f47 5253 514c 222e 2049 6620 4e6f   "OGRSQL". If No
-00009690: 6e65 2c20 666f 7220 6461 7461 2073 6f75  ne, for data sou
-000096a0: 7263 6573 2077 6974 6820 6578 706c 6963  rces with explic
-000096b0: 6974 2053 514c 2073 7570 706f 7274 2074  it SQL support t
-000096c0: 6865 2073 7461 7465 6d65 6e74 0d0a 2020  he statement..  
-000096d0: 2020 2020 2020 2020 2020 6973 2070 726f            is pro
-000096e0: 6365 7373 6564 2062 7920 7468 6520 6465  cessed by the de
-000096f0: 6661 756c 7420 5351 4c20 656e 6769 6e65  fault SQL engine
-00009700: 2028 652e 672e 2066 6f72 2047 656f 7061   (e.g. for Geopa
-00009710: 636b 6167 6520 616e 6420 5370 6174 6961  ckage and Spatia
-00009720: 6c69 7465 0d0a 2020 2020 2020 2020 2020  lite..          
-00009730: 2020 7468 6973 2069 7320 2253 514c 4954    this is "SQLIT
-00009740: 4522 292e 2046 6f72 2064 6174 6120 736f  E"). For data so
-00009750: 7572 6365 7320 7769 7468 6f75 7420 6e61  urces without na
-00009760: 7469 7665 2053 514c 2073 7570 706f 7274  tive SQL support
-00009770: 2028 652e 672e 202e 7368 7029 2c0d 0a20   (e.g. .shp),.. 
-00009780: 2020 2020 2020 2020 2020 2074 6865 2022             the "
-00009790: 4f47 5253 514c 2220 6469 616c 6563 7420  OGRSQL" dialect 
-000097a0: 6973 2074 6865 2064 6566 6175 6c74 2e20  is the default. 
-000097b0: 4966 2074 6865 2022 5351 4c49 5445 2220  If the "SQLITE" 
-000097c0: 6469 616c 6563 7420 6973 2073 7065 6369  dialect is speci
-000097d0: 6669 6564 2c0d 0a20 2020 2020 2020 2020  fied,..         
-000097e0: 2020 207c 7370 6174 6961 6c69 7465 5f72     |spatialite_r
-000097f0: 6566 6572 656e 6365 5f6c 696e 6b7c 2066  eference_link| f
-00009800: 756e 6374 696f 6e73 2063 616e 2061 6c73  unctions can als
-00009810: 6f20 6265 2075 7365 642e 2044 6566 6175  o be used. Defau
-00009820: 6c74 7320 746f 204e 6f6e 652e 0d0a 2020  lts to None...  
-00009830: 2020 2020 2020 6967 6e6f 7265 5f67 656f        ignore_geo
-00009840: 6d65 7472 7920 2862 6f6f 6c2c 206f 7074  metry (bool, opt
-00009850: 696f 6e61 6c29 3a20 5472 7565 206e 6f74  ional): True not
-00009860: 2074 6f20 7265 6164 2f72 6574 7572 6e20   to read/return 
-00009870: 7468 6520 6765 6f6d 6574 7279 2e0d 0a20  the geometry... 
-00009880: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
-00009890: 6c74 7320 746f 2046 616c 7365 2e0d 0a20  lts to False... 
-000098a0: 2020 2020 2020 2066 6964 5f61 735f 696e         fid_as_in
-000098b0: 6465 7820 2862 6f6f 6c2c 206f 7074 696f  dex (bool, optio
-000098c0: 6e61 6c29 3a20 4966 2054 7275 652c 2077  nal): If True, w
-000098d0: 696c 6c20 7573 6520 7468 6520 4649 4473  ill use the FIDs
-000098e0: 206f 6620 7468 6520 6665 6174 7572 6573   of the features
-000098f0: 2074 6861 740d 0a20 2020 2020 2020 2020   that..         
-00009900: 2020 2077 6572 6520 7265 6164 2061 7320     were read as 
-00009910: 7468 6520 696e 6465 7820 6f66 2074 6865  the index of the
-00009920: 2047 656f 4461 7461 4672 616d 652e 204d   GeoDataFrame. M
-00009930: 6179 2073 7461 7274 2061 7420 3020 6f72  ay start at 0 or
-00009940: 2031 2064 6570 656e 6469 6e67 206f 6e0d   1 depending on.
-00009950: 0a20 2020 2020 2020 2020 2020 2074 6865  .            the
-00009960: 2064 7269 7665 722e 2044 6566 6175 6c74   driver. Default
-00009970: 7320 746f 2046 616c 7365 2e0d 0a0d 0a20  s to False..... 
-00009980: 2020 2052 6169 7365 733a 0d0a 2020 2020     Raises:..    
-00009990: 2020 2020 5661 6c75 6545 7272 6f72 3a20      ValueError: 
-000099a0: 616e 2069 6e76 616c 6964 2070 6172 616d  an invalid param
-000099b0: 6574 6572 2076 616c 7565 2077 6173 2070  eter value was p
-000099c0: 6173 7365 642e 0d0a 0d0a 2020 2020 5265  assed.....    Re
-000099d0: 7475 726e 733a 0d0a 2020 2020 2020 2020  turns:..        
-000099e0: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
-000099f0: 3a20 7468 6520 6461 7461 2072 6561 642e  : the data read.
-00009a00: 0d0a 0d0a 2020 2020 2e2e 207c 4f47 5253  ....    .. |OGRS
-00009a10: 514c 2057 4845 5245 7c20 7261 773a 3a20  QL WHERE| raw:: 
-00009a20: 6874 6d6c 0d0a 0d0a 2020 2020 2020 2020  html....        
-00009a30: 3c61 2068 7265 663d 2268 7474 7073 3a2f  <a href="https:/
-00009a40: 2f67 6461 6c2e 6f72 672f 7573 6572 2f6f  /gdal.org/user/o
-00009a50: 6772 5f73 716c 5f64 6961 6c65 6374 2e68  gr_sql_dialect.h
-00009a60: 746d 6c23 7768 6572 6522 2074 6172 6765  tml#where" targe
-00009a70: 743d 225f 626c 616e 6b22 3e4f 4752 5351  t="_blank">OGRSQ
-00009a80: 4c20 5748 4552 453c 2f61 3e0d 0a0d 0a20  L WHERE</a>.... 
-00009a90: 2020 202e 2e20 7c73 7061 7469 616c 6974     .. |spatialit
-00009aa0: 655f 7265 6665 7265 6e63 655f 6c69 6e6b  e_reference_link
-00009ab0: 7c20 7261 773a 3a20 6874 6d6c 0d0a 0d0a  | raw:: html....
-00009ac0: 2020 2020 2020 2020 3c61 2068 7265 663d          <a href=
-00009ad0: 2268 7474 7073 3a2f 2f77 7777 2e67 6169  "https://www.gai
-00009ae0: 612d 6769 732e 6974 2f67 6169 612d 7369  a-gis.it/gaia-si
-00009af0: 6e73 2f73 7061 7469 616c 6974 652d 7371  ns/spatialite-sq
-00009b00: 6c2d 6c61 7465 7374 2e68 746d 6c22 2074  l-latest.html" t
-00009b10: 6172 6765 743d 225f 626c 616e 6b22 3e73  arget="_blank">s
-00009b20: 7061 7469 616c 6974 6520 7265 6665 7265  patialite refere
-00009b30: 6e63 653c 2f61 3e0d 0a0d 0a20 2020 2022  nce</a>....    "
-00009b40: 2222 2020 2320 6e6f 7161 3a20 4535 3031  ""  # noqa: E501
-00009b50: 0d0a 2020 2020 7265 7375 6c74 5f67 6466  ..    result_gdf
-00009b60: 203d 205f 7265 6164 5f66 696c 655f 6261   = _read_file_ba
-00009b70: 7365 280d 0a20 2020 2020 2020 2070 6174  se(..        pat
-00009b80: 683d 7061 7468 2c0d 0a20 2020 2020 2020  h=path,..       
-00009b90: 206c 6179 6572 3d6c 6179 6572 2c0d 0a20   layer=layer,.. 
-00009ba0: 2020 2020 2020 2063 6f6c 756d 6e73 3d63         columns=c
-00009bb0: 6f6c 756d 6e73 2c0d 0a20 2020 2020 2020  olumns,..       
-00009bc0: 2062 626f 783d 6262 6f78 2c0d 0a20 2020   bbox=bbox,..   
-00009bd0: 2020 2020 2072 6f77 733d 726f 7773 2c0d       rows=rows,.
-00009be0: 0a20 2020 2020 2020 2077 6865 7265 3d77  .        where=w
-00009bf0: 6865 7265 2c0d 0a20 2020 2020 2020 2073  here,..        s
-00009c00: 716c 5f73 746d 743d 7371 6c5f 7374 6d74  ql_stmt=sql_stmt
-00009c10: 2c0d 0a20 2020 2020 2020 2073 716c 5f64  ,..        sql_d
-00009c20: 6961 6c65 6374 3d73 716c 5f64 6961 6c65  ialect=sql_diale
-00009c30: 6374 2c0d 0a20 2020 2020 2020 2069 676e  ct,..        ign
-00009c40: 6f72 655f 6765 6f6d 6574 7279 3d69 676e  ore_geometry=ign
-00009c50: 6f72 655f 6765 6f6d 6574 7279 2c0d 0a20  ore_geometry,.. 
-00009c60: 2020 2020 2020 2066 6964 5f61 735f 696e         fid_as_in
-00009c70: 6465 783d 6669 645f 6173 5f69 6e64 6578  dex=fid_as_index
-00009c80: 2c0d 0a20 2020 2029 0d0a 0d0a 2020 2020  ,..    )....    
-00009c90: 2320 4e6f 2061 7373 6572 7420 746f 206b  # No assert to k
-00009ca0: 6565 7020 6261 636b 7761 7264 7320 636f  eep backwards co
-00009cb0: 6d70 6174 6962 696c 6974 790d 0a20 2020  mpatibility..   
-00009cc0: 2072 6574 7572 6e20 7265 7375 6c74 5f67   return result_g
-00009cd0: 6466 0d0a 0d0a 0d0a 6465 6620 7265 6164  df......def read
-00009ce0: 5f66 696c 655f 6e6f 6765 6f6d 280d 0a20  _file_nogeom(.. 
-00009cf0: 2020 2070 6174 683a 2055 6e69 6f6e 5b73     path: Union[s
-00009d00: 7472 2c20 226f 732e 5061 7468 4c69 6b65  tr, "os.PathLike
-00009d10: 5b41 6e79 5d22 5d2c 0d0a 2020 2020 6c61  [Any]"],..    la
-00009d20: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
-00009d30: 725d 203d 204e 6f6e 652c 0d0a 2020 2020  r] = None,..    
-00009d40: 636f 6c75 6d6e 733a 204f 7074 696f 6e61  columns: Optiona
-00009d50: 6c5b 4974 6572 6162 6c65 5b73 7472 5d5d  l[Iterable[str]]
-00009d60: 203d 204e 6f6e 652c 0d0a 2020 2020 6262   = None,..    bb
-00009d70: 6f78 3d4e 6f6e 652c 0d0a 2020 2020 726f  ox=None,..    ro
-00009d80: 7773 3d4e 6f6e 652c 0d0a 2020 2020 7371  ws=None,..    sq
-00009d90: 6c5f 7374 6d74 3a20 4f70 7469 6f6e 616c  l_stmt: Optional
-00009da0: 5b73 7472 5d20 3d20 4e6f 6e65 2c0d 0a20  [str] = None,.. 
-00009db0: 2020 2073 716c 5f64 6961 6c65 6374 3a20     sql_dialect: 
-00009dc0: 4f70 7469 6f6e 616c 5b4c 6974 6572 616c  Optional[Literal
-00009dd0: 5b22 5351 4c49 5445 222c 2022 4f47 5253  ["SQLITE", "OGRS
-00009de0: 514c 225d 5d20 3d20 4e6f 6e65 2c0d 0a20  QL"]] = None,.. 
-00009df0: 2020 2066 6964 5f61 735f 696e 6465 783a     fid_as_index:
-00009e00: 2062 6f6f 6c20 3d20 4661 6c73 652c 0d0a   bool = False,..
-00009e10: 2920 2d3e 2070 642e 4461 7461 4672 616d  ) -> pd.DataFram
-00009e20: 653a 0d0a 2020 2020 2222 220d 0a20 2020  e:..    """..   
-00009e30: 2044 4550 5245 4341 5445 443a 2070 6c65   DEPRECATED: ple
-00009e40: 6173 6520 7573 6520 7265 6164 5f66 696c  ase use read_fil
-00009e50: 6520 7769 7468 206f 7074 696f 6e20 6967  e with option ig
-00009e60: 6e6f 7265 5f67 656f 6d65 7472 793d 5472  nore_geometry=Tr
-00009e70: 7565 2e0d 0a20 2020 2022 2222 0d0a 2020  ue...    """..  
-00009e80: 2020 7761 726e 696e 6773 2e77 6172 6e28    warnings.warn(
-00009e90: 0d0a 2020 2020 2020 2020 2272 6561 645f  ..        "read_
-00009ea0: 6669 6c65 5f6e 6f67 656f 6d20 6973 2064  file_nogeom is d
-00009eb0: 6570 7265 6361 7465 643a 2075 7365 2072  eprecated: use r
-00009ec0: 6561 645f 6669 6c65 2077 6974 6820 6967  ead_file with ig
-00009ed0: 6e6f 7265 5f67 656f 6d65 7472 793d 5472  nore_geometry=Tr
-00009ee0: 7565 222c 0d0a 2020 2020 2020 2020 4675  ue",..        Fu
-00009ef0: 7475 7265 5761 726e 696e 672c 0d0a 2020  tureWarning,..  
-00009f00: 2020 2020 2020 7374 6163 6b6c 6576 656c        stacklevel
-00009f10: 3d32 2c0d 0a20 2020 2029 0d0a 2020 2020  =2,..    )..    
-00009f20: 7265 7375 6c74 5f67 6466 203d 205f 7265  result_gdf = _re
-00009f30: 6164 5f66 696c 655f 6261 7365 280d 0a20  ad_file_base(.. 
-00009f40: 2020 2020 2020 2070 6174 683d 7061 7468         path=path
-00009f50: 2c0d 0a20 2020 2020 2020 206c 6179 6572  ,..        layer
-00009f60: 3d6c 6179 6572 2c0d 0a20 2020 2020 2020  =layer,..       
-00009f70: 2063 6f6c 756d 6e73 3d63 6f6c 756d 6e73   columns=columns
-00009f80: 2c0d 0a20 2020 2020 2020 2062 626f 783d  ,..        bbox=
-00009f90: 6262 6f78 2c0d 0a20 2020 2020 2020 2072  bbox,..        r
-00009fa0: 6f77 733d 726f 7773 2c0d 0a20 2020 2020  ows=rows,..     
-00009fb0: 2020 2073 716c 5f73 746d 743d 7371 6c5f     sql_stmt=sql_
-00009fc0: 7374 6d74 2c0d 0a20 2020 2020 2020 2073  stmt,..        s
-00009fd0: 716c 5f64 6961 6c65 6374 3d73 716c 5f64  ql_dialect=sql_d
-00009fe0: 6961 6c65 6374 2c0d 0a20 2020 2020 2020  ialect,..       
-00009ff0: 2069 676e 6f72 655f 6765 6f6d 6574 7279   ignore_geometry
-0000a000: 3d54 7275 652c 0d0a 2020 2020 2020 2020  =True,..        
-0000a010: 6669 645f 6173 5f69 6e64 6578 3d66 6964  fid_as_index=fid
-0000a020: 5f61 735f 696e 6465 782c 0d0a 2020 2020  _as_index,..    
-0000a030: 290d 0a20 2020 2061 7373 6572 7420 6973  )..    assert is
-0000a040: 696e 7374 616e 6365 2872 6573 756c 745f  instance(result_
-0000a050: 6764 662c 2070 642e 4461 7461 4672 616d  gdf, pd.DataFram
-0000a060: 6529 0d0a 2020 2020 7265 7475 726e 2072  e)..    return r
-0000a070: 6573 756c 745f 6764 660d 0a0d 0a0d 0a64  esult_gdf......d
-0000a080: 6566 205f 7265 6164 5f66 696c 655f 6261  ef _read_file_ba
-0000a090: 7365 280d 0a20 2020 2070 6174 683a 2055  se(..    path: U
-0000a0a0: 6e69 6f6e 5b73 7472 2c20 226f 732e 5061  nion[str, "os.Pa
-0000a0b0: 7468 4c69 6b65 5b41 6e79 5d22 5d2c 0d0a  thLike[Any]"],..
-0000a0c0: 2020 2020 6c61 7965 723a 204f 7074 696f      layer: Optio
-0000a0d0: 6e61 6c5b 7374 725d 203d 204e 6f6e 652c  nal[str] = None,
-0000a0e0: 0d0a 2020 2020 636f 6c75 6d6e 733a 204f  ..    columns: O
-0000a0f0: 7074 696f 6e61 6c5b 4974 6572 6162 6c65  ptional[Iterable
-0000a100: 5b73 7472 5d5d 203d 204e 6f6e 652c 0d0a  [str]] = None,..
-0000a110: 2020 2020 6262 6f78 3d4e 6f6e 652c 0d0a      bbox=None,..
-0000a120: 2020 2020 726f 7773 3d4e 6f6e 652c 0d0a      rows=None,..
-0000a130: 2020 2020 7768 6572 653a 204f 7074 696f      where: Optio
-0000a140: 6e61 6c5b 7374 725d 203d 204e 6f6e 652c  nal[str] = None,
-0000a150: 0d0a 2020 2020 7371 6c5f 7374 6d74 3a20  ..    sql_stmt: 
-0000a160: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
-0000a170: 4e6f 6e65 2c0d 0a20 2020 2073 716c 5f64  None,..    sql_d
-0000a180: 6961 6c65 6374 3a20 4f70 7469 6f6e 616c  ialect: Optional
-0000a190: 5b4c 6974 6572 616c 5b22 5351 4c49 5445  [Literal["SQLITE
-0000a1a0: 222c 2022 4f47 5253 514c 225d 5d20 3d20  ", "OGRSQL"]] = 
-0000a1b0: 4e6f 6e65 2c0d 0a20 2020 2069 676e 6f72  None,..    ignor
-0000a1c0: 655f 6765 6f6d 6574 7279 3a20 626f 6f6c  e_geometry: bool
-0000a1d0: 203d 2046 616c 7365 2c0d 0a20 2020 2066   = False,..    f
-0000a1e0: 6964 5f61 735f 696e 6465 783a 2062 6f6f  id_as_index: boo
-0000a1f0: 6c20 3d20 4661 6c73 652c 0d0a 2920 2d3e  l = False,..) ->
-0000a200: 2055 6e69 6f6e 5b70 642e 4461 7461 4672   Union[pd.DataFr
-0000a210: 616d 652c 2067 7064 2e47 656f 4461 7461  ame, gpd.GeoData
-0000a220: 4672 616d 655d 3a0d 0a20 2020 2022 2222  Frame]:..    """
-0000a230: 0d0a 2020 2020 5265 6164 7320 6120 6669  ..    Reads a fi
-0000a240: 6c65 2074 6f20 6120 7061 6e64 6173 2044  le to a pandas D
-0000a250: 6174 6166 7261 6d65 2e0d 0a20 2020 2022  ataframe...    "
-0000a260: 2222 0d0a 2020 2020 2320 4368 6563 6b20  ""..    # Check 
-0000a270: 6966 2074 6865 2066 6964 2063 6f6c 756d  if the fid colum
-0000a280: 6e20 6e65 6564 7320 746f 2062 6520 7265  n needs to be re
-0000a290: 6164 2061 7320 636f 6c75 6d6e 2076 6961  ad as column via
-0000a2a0: 2074 6865 2063 6f6c 756d 6e73 2070 6172   the columns par
-0000a2b0: 616d 6574 6572 0d0a 2020 2020 6669 645f  ameter..    fid_
-0000a2c0: 6173 5f63 6f6c 756d 6e20 3d20 4661 6c73  as_column = Fals
-0000a2d0: 650d 0a20 2020 2069 6620 636f 6c75 6d6e  e..    if column
-0000a2e0: 7320 6973 206e 6f74 204e 6f6e 653a 0d0a  s is not None:..
-0000a2f0: 2020 2020 2020 2020 6966 2022 6669 6422          if "fid"
-0000a300: 2069 6e20 5b63 6f6c 756d 6e2e 6c6f 7765   in [column.lowe
-0000a310: 7228 2920 666f 7220 636f 6c75 6d6e 2069  r() for column i
-0000a320: 6e20 636f 6c75 6d6e 735d 3a0d 0a20 2020  n columns]:..   
-0000a330: 2020 2020 2020 2020 2066 6964 5f61 735f           fid_as_
-0000a340: 636f 6c75 6d6e 203d 2054 7275 650d 0a0d  column = True...
-0000a350: 0a20 2020 2023 2052 6561 6420 7769 7468  .    # Read with
-0000a360: 2074 6865 2065 6e67 696e 6520 7370 6563   the engine spec
-0000a370: 6966 6965 640d 0a20 2020 2065 6e67 696e  ified..    engin
-0000a380: 6520 3d20 5f67 6574 5f65 6e67 696e 6528  e = _get_engine(
-0000a390: 290d 0a20 2020 2069 6620 656e 6769 6e65  )..    if engine
-0000a3a0: 203d 3d20 2270 796f 6772 696f 223a 0d0a   == "pyogrio":..
-0000a3b0: 2020 2020 2020 2020 6764 6620 3d20 5f72          gdf = _r
-0000a3c0: 6561 645f 6669 6c65 5f62 6173 655f 7079  ead_file_base_py
-0000a3d0: 6f67 7269 6f28 0d0a 2020 2020 2020 2020  ogrio(..        
-0000a3e0: 2020 2020 7061 7468 3d70 6174 682c 0d0a      path=path,..
-0000a3f0: 2020 2020 2020 2020 2020 2020 6c61 7965              laye
-0000a400: 723d 6c61 7965 722c 0d0a 2020 2020 2020  r=layer,..      
-0000a410: 2020 2020 2020 636f 6c75 6d6e 733d 636f        columns=co
-0000a420: 6c75 6d6e 732c 0d0a 2020 2020 2020 2020  lumns,..        
-0000a430: 2020 2020 6262 6f78 3d62 626f 782c 0d0a      bbox=bbox,..
-0000a440: 2020 2020 2020 2020 2020 2020 726f 7773              rows
-0000a450: 3d72 6f77 732c 0d0a 2020 2020 2020 2020  =rows,..        
-0000a460: 2020 2020 7768 6572 653d 7768 6572 652c      where=where,
-0000a470: 0d0a 2020 2020 2020 2020 2020 2020 7371  ..            sq
-0000a480: 6c5f 7374 6d74 3d73 716c 5f73 746d 742c  l_stmt=sql_stmt,
-0000a490: 0d0a 2020 2020 2020 2020 2020 2020 7371  ..            sq
-0000a4a0: 6c5f 6469 616c 6563 743d 7371 6c5f 6469  l_dialect=sql_di
-0000a4b0: 616c 6563 742c 0d0a 2020 2020 2020 2020  alect,..        
-0000a4c0: 2020 2020 6967 6e6f 7265 5f67 656f 6d65      ignore_geome
-0000a4d0: 7472 793d 6967 6e6f 7265 5f67 656f 6d65  try=ignore_geome
-0000a4e0: 7472 792c 0d0a 2020 2020 2020 2020 2020  try,..          
-0000a4f0: 2020 6669 645f 6173 5f69 6e64 6578 3d66    fid_as_index=f
-0000a500: 6964 5f61 735f 696e 6465 7820 6f72 2066  id_as_index or f
-0000a510: 6964 5f61 735f 636f 6c75 6d6e 2c0d 0a20  id_as_column,.. 
-0000a520: 2020 2020 2020 2029 0d0a 2020 2020 656c         )..    el
-0000a530: 6966 2065 6e67 696e 6520 3d3d 2022 6669  if engine == "fi
-0000a540: 6f6e 6122 3a0d 0a20 2020 2020 2020 2067  ona":..        g
-0000a550: 6466 203d 205f 7265 6164 5f66 696c 655f  df = _read_file_
-0000a560: 6261 7365 5f66 696f 6e61 280d 0a20 2020  base_fiona(..   
-0000a570: 2020 2020 2020 2020 2070 6174 683d 7061           path=pa
-0000a580: 7468 2c0d 0a20 2020 2020 2020 2020 2020  th,..           
-0000a590: 206c 6179 6572 3d6c 6179 6572 2c0d 0a20   layer=layer,.. 
-0000a5a0: 2020 2020 2020 2020 2020 2063 6f6c 756d             colum
-0000a5b0: 6e73 3d63 6f6c 756d 6e73 2c0d 0a20 2020  ns=columns,..   
-0000a5c0: 2020 2020 2020 2020 2062 626f 783d 6262           bbox=bb
-0000a5d0: 6f78 2c0d 0a20 2020 2020 2020 2020 2020  ox,..           
-0000a5e0: 2072 6f77 733d 726f 7773 2c0d 0a20 2020   rows=rows,..   
-0000a5f0: 2020 2020 2020 2020 2077 6865 7265 3d77           where=w
-0000a600: 6865 7265 2c0d 0a20 2020 2020 2020 2020  here,..         
-0000a610: 2020 2073 716c 5f73 746d 743d 7371 6c5f     sql_stmt=sql_
-0000a620: 7374 6d74 2c0d 0a20 2020 2020 2020 2020  stmt,..         
-0000a630: 2020 2073 716c 5f64 6961 6c65 6374 3d73     sql_dialect=s
-0000a640: 716c 5f64 6961 6c65 6374 2c0d 0a20 2020  ql_dialect,..   
-0000a650: 2020 2020 2020 2020 2069 676e 6f72 655f           ignore_
-0000a660: 6765 6f6d 6574 7279 3d69 676e 6f72 655f  geometry=ignore_
-0000a670: 6765 6f6d 6574 7279 2c0d 0a20 2020 2020  geometry,..     
-0000a680: 2020 2020 2020 2066 6964 5f61 735f 696e         fid_as_in
-0000a690: 6465 783d 6669 645f 6173 5f69 6e64 6578  dex=fid_as_index
-0000a6a0: 206f 7220 6669 645f 6173 5f63 6f6c 756d   or fid_as_colum
-0000a6b0: 6e2c 0d0a 2020 2020 2020 2020 290d 0a20  n,..        ).. 
-0000a6c0: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-0000a6d0: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
-0000a6e0: 6f72 2866 2255 6e73 7570 706f 7274 6564  or(f"Unsupported
-0000a6f0: 2065 6e67 696e 653a 207b 656e 6769 6e65   engine: {engine
-0000a700: 7d22 290d 0a0d 0a20 2020 2023 2043 6f70  }")....    # Cop
-0000a710: 7920 7468 6520 696e 6465 7820 746f 2061  y the index to a
-0000a720: 2063 6f6c 756d 6e20 6966 206e 6565 6465   column if neede
-0000a730: 642e 2e2e 0d0a 2020 2020 6966 2066 6964  d.....    if fid
-0000a740: 5f61 735f 636f 6c75 6d6e 3a0d 0a20 2020  _as_column:..   
-0000a750: 2020 2020 2067 6466 5b22 6669 6422 5d20       gdf["fid"] 
-0000a760: 3d20 6764 662e 696e 6465 780d 0a20 2020  = gdf.index..   
-0000a770: 2020 2020 2069 6620 6e6f 7420 6669 645f       if not fid_
-0000a780: 6173 5f69 6e64 6578 3a0d 0a20 2020 2020  as_index:..     
-0000a790: 2020 2020 2020 2067 6466 203d 2067 6466         gdf = gdf
-0000a7a0: 2e72 6573 6574 5f69 6e64 6578 2864 726f  .reset_index(dro
-0000a7b0: 703d 5472 7565 290d 0a0d 0a20 2020 2072  p=True)....    r
-0000a7c0: 6574 7572 6e20 6764 660d 0a0d 0a0d 0a64  eturn gdf......d
-0000a7d0: 6566 205f 7265 6164 5f66 696c 655f 6261  ef _read_file_ba
-0000a7e0: 7365 5f66 696f 6e61 280d 0a20 2020 2070  se_fiona(..    p
-0000a7f0: 6174 683a 2055 6e69 6f6e 5b73 7472 2c20  ath: Union[str, 
-0000a800: 226f 732e 5061 7468 4c69 6b65 5b41 6e79  "os.PathLike[Any
-0000a810: 5d22 5d2c 0d0a 2020 2020 6c61 7965 723a  ]"],..    layer:
-0000a820: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
-0000a830: 204e 6f6e 652c 0d0a 2020 2020 636f 6c75   None,..    colu
-0000a840: 6d6e 733a 204f 7074 696f 6e61 6c5b 4974  mns: Optional[It
-0000a850: 6572 6162 6c65 5b73 7472 5d5d 203d 204e  erable[str]] = N
-0000a860: 6f6e 652c 0d0a 2020 2020 6262 6f78 3d4e  one,..    bbox=N
-0000a870: 6f6e 652c 0d0a 2020 2020 726f 7773 3d4e  one,..    rows=N
-0000a880: 6f6e 652c 0d0a 2020 2020 7768 6572 653a  one,..    where:
-0000a890: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
-0000a8a0: 204e 6f6e 652c 0d0a 2020 2020 7371 6c5f   None,..    sql_
-0000a8b0: 7374 6d74 3a20 4f70 7469 6f6e 616c 5b73  stmt: Optional[s
-0000a8c0: 7472 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  tr] = None,..   
-0000a8d0: 2073 716c 5f64 6961 6c65 6374 3a20 4f70   sql_dialect: Op
-0000a8e0: 7469 6f6e 616c 5b4c 6974 6572 616c 5b22  tional[Literal["
-0000a8f0: 5351 4c49 5445 222c 2022 4f47 5253 514c  SQLITE", "OGRSQL
-0000a900: 225d 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  "]] = None,..   
-0000a910: 2069 676e 6f72 655f 6765 6f6d 6574 7279   ignore_geometry
-0000a920: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-0000a930: 0a20 2020 2066 6964 5f61 735f 696e 6465  .    fid_as_inde
-0000a940: 783a 2062 6f6f 6c20 3d20 4661 6c73 652c  x: bool = False,
-0000a950: 0d0a 2920 2d3e 2055 6e69 6f6e 5b70 642e  ..) -> Union[pd.
-0000a960: 4461 7461 4672 616d 652c 2067 7064 2e47  DataFrame, gpd.G
-0000a970: 656f 4461 7461 4672 616d 655d 3a0d 0a20  eoDataFrame]:.. 
-0000a980: 2020 2022 2222 0d0a 2020 2020 5265 6164     """..    Read
-0000a990: 7320 6120 6669 6c65 2074 6f20 6120 7061  s a file to a pa
-0000a9a0: 6e64 6173 2044 6174 6166 7261 6d65 2075  ndas Dataframe u
-0000a9b0: 7369 6e67 2066 696f 6e61 2e0d 0a20 2020  sing fiona...   
-0000a9c0: 2022 2222 0d0a 2020 2020 6966 2069 676e   """..    if ign
-0000a9d0: 6f72 655f 6765 6f6d 6574 7279 2061 6e64  ore_geometry and
-0000a9e0: 2063 6f6c 756d 6e73 203d 3d20 5b5d 3a0d   columns == []:.
-0000a9f0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0000aa00: 7064 2e44 6174 6146 7261 6d65 2829 0d0a  pd.DataFrame()..
-0000aa10: 2020 2020 6966 2073 716c 5f73 746d 7420      if sql_stmt 
-0000aa20: 6973 206e 6f74 204e 6f6e 653a 0d0a 2020  is not None:..  
-0000aa30: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-0000aa40: 6545 7272 6f72 2822 7371 6c5f 7374 6d74  eError("sql_stmt
-0000aa50: 2069 7320 6e6f 7420 7375 7070 6f72 7465   is not supporte
-0000aa60: 6420 7769 7468 2066 696f 6e61 2065 6e67  d with fiona eng
-0000aa70: 696e 6522 290d 0a0d 0a20 2020 2023 2049  ine")....    # I
-0000aa80: 6e69 740d 0a20 2020 2070 6174 6820 3d20  nit..    path = 
-0000aa90: 5061 7468 2870 6174 6829 0d0a 2020 2020  Path(path)..    
-0000aaa0: 6966 2070 6174 682e 6578 6973 7473 2829  if path.exists()
-0000aab0: 2069 7320 4661 6c73 653a 0d0a 2020 2020   is False:..    
-0000aac0: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-0000aad0: 7272 6f72 2866 2266 696c 6520 646f 6573  rror(f"file does
-0000aae0: 6e27 7420 6578 6973 743a 207b 7061 7468  n't exist: {path
-0000aaf0: 7d22 290d 0a0d 0a20 2020 2023 2049 6620  }")....    # If 
-0000ab00: 6e6f 206c 6179 6572 206e 616d 6520 7370  no layer name sp
-0000ab10: 6563 6966 6965 642c 2063 6865 636b 2069  ecified, check i
-0000ab20: 6620 7468 6572 6520 6973 206f 6e6c 7920  f there is only 
-0000ab30: 6f6e 6520 6c61 7965 7220 696e 2074 6865  one layer in the
-0000ab40: 2066 696c 652e 0d0a 2020 2020 6966 206c   file...    if l
-0000ab50: 6179 6572 2069 7320 4e6f 6e65 3a0d 0a20  ayer is None:.. 
-0000ab60: 2020 2020 2020 206c 6179 6572 203d 2067         layer = g
-0000ab70: 6574 5f6f 6e6c 795f 6c61 7965 7228 7061  et_only_layer(pa
-0000ab80: 7468 290d 0a0d 0a20 2020 2023 2056 4552  th)....    # VER
-0000ab90: 5920 4449 5254 5920 6861 636b 2074 6f20  Y DIRTY hack to 
-0000aba0: 6765 7420 7468 6520 6669 640d 0a20 2020  get the fid..   
-0000abb0: 2069 6620 6669 645f 6173 5f69 6e64 6578   if fid_as_index
-0000abc0: 3a0d 0a20 2020 2020 2020 2023 204d 616b  :..        # Mak
-0000abd0: 6520 6120 636f 7079 2f63 6f70 7920 696e  e a copy/copy in
-0000abe0: 7075 7420 6669 6c65 2074 6f20 6765 6f70  put file to geop
-0000abf0: 6163 6b61 6765 2c20 6173 2077 6520 7769  ackage, as we wi
-0000ac00: 6c6c 2061 6464 2061 6e20 6669 642f 726f  ll add an fid/ro
-0000ac10: 7764 2063 6f6c 756d 6e0d 0a20 2020 2020  wd column..     
-0000ac20: 2020 2074 6d70 5f66 6964 5f70 6174 6820     tmp_fid_path 
-0000ac30: 3d20 5061 7468 2874 656d 7066 696c 652e  = Path(tempfile.
-0000ac40: 6d6b 6474 656d 7028 2929 202f 2066 227b  mkdtemp()) / f"{
-0000ac50: 7061 7468 2e73 7465 6d7d 2e67 706b 6722  path.stem}.gpkg"
-0000ac60: 0d0a 2020 2020 2020 2020 7061 7468 5f69  ..        path_i
-0000ac70: 6e66 6f20 3d20 5f67 656f 6669 6c65 696e  nfo = _geofilein
-0000ac80: 666f 2e67 6574 5f67 656f 6669 6c65 696e  fo.get_geofilein
-0000ac90: 666f 2870 6174 6829 0d0a 2020 2020 2020  fo(path)..      
-0000aca0: 2020 7472 793a 0d0a 2020 2020 2020 2020    try:..        
-0000acb0: 2020 2020 6966 2070 6174 685f 696e 666f      if path_info
-0000acc0: 2e64 7269 7665 7220 3d3d 2022 4750 4b47  .driver == "GPKG
-0000acd0: 223a 0d0a 2020 2020 2020 2020 2020 2020  ":..            
-0000ace0: 2020 2020 636f 7079 2870 6174 682c 2074      copy(path, t
-0000acf0: 6d70 5f66 6964 5f70 6174 6829 0d0a 2020  mp_fid_path)..  
-0000ad00: 2020 2020 2020 2020 2020 656c 7365 3a0d            else:.
-0000ad10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ad20: 2063 6f70 795f 6c61 7965 7228 7061 7468   copy_layer(path
-0000ad30: 2c20 746d 705f 6669 645f 7061 7468 290d  , tmp_fid_path).
-0000ad40: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000ad50: 7061 7468 5f69 6e66 6f2e 6973 5f66 6964  path_info.is_fid
-0000ad60: 5f7a 6572 6f62 6173 6564 3a0d 0a20 2020  _zerobased:..   
-0000ad70: 2020 2020 2020 2020 2020 2020 2023 2066               # f
-0000ad80: 6964 2069 6e20 7368 6170 6566 696c 6520  id in shapefile 
-0000ad90: 6973 2030 2062 6173 6564 2c20 736f 2066  is 0 based, so f
-0000ada0: 6964 2d31 0d0a 2020 2020 2020 2020 2020  id-1..          
-0000adb0: 2020 2020 2020 6164 645f 636f 6c75 6d6e        add_column
-0000adc0: 2874 6d70 5f66 6964 5f70 6174 682c 2022  (tmp_fid_path, "
-0000add0: 5f5f 544d 505f 4745 4f46 494c 454f 5053  __TMP_GEOFILEOPS
-0000ade0: 5f46 4944 222c 2022 494e 5445 4745 5222  _FID", "INTEGER"
-0000adf0: 2c20 2266 6964 2d31 2229 0d0a 2020 2020  , "fid-1")..    
-0000ae00: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-0000ae10: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0000ae20: 6464 5f63 6f6c 756d 6e28 746d 705f 6669  dd_column(tmp_fi
-0000ae30: 645f 7061 7468 2c20 225f 5f54 4d50 5f47  d_path, "__TMP_G
-0000ae40: 454f 4649 4c45 4f50 535f 4649 4422 2c20  EOFILEOPS_FID", 
-0000ae50: 2249 4e54 4547 4552 222c 2022 6669 6422  "INTEGER", "fid"
-0000ae60: 290d 0a0d 0a20 2020 2020 2020 2020 2020  )....           
-0000ae70: 2070 6174 6820 3d20 746d 705f 6669 645f   path = tmp_fid_
-0000ae80: 7061 7468 0d0a 2020 2020 2020 2020 6669  path..        fi
-0000ae90: 6e61 6c6c 793a 0d0a 2020 2020 2020 2020  nally:..        
-0000aea0: 2020 2020 6966 2074 6d70 5f66 6964 5f70      if tmp_fid_p
-0000aeb0: 6174 682e 7061 7265 6e74 2e65 7869 7374  ath.parent.exist
-0000aec0: 7328 293a 0d0a 2020 2020 2020 2020 2020  s():..          
-0000aed0: 2020 2020 2020 7368 7574 696c 2e72 6d74        shutil.rmt
-0000aee0: 7265 6528 746d 705f 6669 645f 7061 7468  ree(tmp_fid_path
-0000aef0: 2c20 6967 6e6f 7265 5f65 7272 6f72 733d  , ignore_errors=
-0000af00: 5472 7565 290d 0a0d 0a20 2020 2023 2043  True)....    # C
-0000af10: 6865 636b 696e 6720 6966 2066 6965 6c64  hecking if field
-0000af20: 2f63 6f6c 756d 6e20 6e61 6d65 7320 7368  /column names sh
-0000af30: 6f75 6c64 2062 6520 7265 6164 2069 7320  ould be read is 
-0000af40: 6361 7365 2073 656e 7369 7469 7665 2069  case sensitive i
-0000af50: 6e20 6669 6f6e 612c 2073 6f0d 0a20 2020  n fiona, so..   
-0000af60: 2023 206d 616b 6520 7375 7265 2074 6865   # make sure the
-0000af70: 2063 6f6c 756d 6e20 6e61 6d65 7320 7370   column names sp
-0000af80: 6563 6966 6965 6420 6861 7665 2074 6865  ecified have the
-0000af90: 2073 616d 6520 6361 7369 6e67 2e0d 0a20   same casing... 
-0000afa0: 2020 2063 6f6c 756d 6e73 5f70 7265 7061     columns_prepa
-0000afb0: 7265 6420 3d20 4e6f 6e65 0d0a 2020 2020  red = None..    
-0000afc0: 6966 2063 6f6c 756d 6e73 2069 7320 6e6f  if columns is no
-0000afd0: 7420 4e6f 6e65 3a0d 0a20 2020 2020 2020  t None:..       
-0000afe0: 206c 6179 6572 696e 666f 203d 2067 6574   layerinfo = get
-0000aff0: 5f6c 6179 6572 696e 666f 2870 6174 682c  _layerinfo(path,
-0000b000: 206c 6179 6572 3d6c 6179 6572 2c20 7261   layer=layer, ra
-0000b010: 6973 655f 6f6e 5f6e 6f67 656f 6d3d 4661  ise_on_nogeom=Fa
-0000b020: 6c73 6529 0d0a 2020 2020 2020 2020 636f  lse)..        co
-0000b030: 6c75 6d6e 735f 7570 7065 725f 6c6f 6f6b  lumns_upper_look
-0000b040: 7570 203d 207b 636f 6c75 6d6e 2e75 7070  up = {column.upp
-0000b050: 6572 2829 3a20 636f 6c75 6d6e 2066 6f72  er(): column for
-0000b060: 2063 6f6c 756d 6e20 696e 2063 6f6c 756d   column in colum
-0000b070: 6e73 7d0d 0a20 2020 2020 2020 2063 6f6c  ns}..        col
-0000b080: 756d 6e73 5f70 7265 7061 7265 6420 3d20  umns_prepared = 
-0000b090: 7b0d 0a20 2020 2020 2020 2020 2020 2063  {..            c
-0000b0a0: 6f6c 756d 6e3a 2063 6f6c 756d 6e73 5f75  olumn: columns_u
-0000b0b0: 7070 6572 5f6c 6f6f 6b75 705b 636f 6c75  pper_lookup[colu
-0000b0c0: 6d6e 2e75 7070 6572 2829 5d0d 0a20 2020  mn.upper()]..   
-0000b0d0: 2020 2020 2020 2020 2066 6f72 2063 6f6c           for col
-0000b0e0: 756d 6e20 696e 206c 6179 6572 696e 666f  umn in layerinfo
-0000b0f0: 2e63 6f6c 756d 6e73 0d0a 2020 2020 2020  .columns..      
-0000b100: 2020 2020 2020 6966 2063 6f6c 756d 6e2e        if column.
-0000b110: 7570 7065 7228 2920 696e 2063 6f6c 756d  upper() in colum
-0000b120: 6e73 5f75 7070 6572 5f6c 6f6f 6b75 700d  ns_upper_lookup.
-0000b130: 0a20 2020 2020 2020 207d 0d0a 0d0a 2020  .        }....  
-0000b140: 2020 2320 5265 6164 2e2e 2e0d 0a20 2020    # Read.....   
-0000b150: 2063 6f6c 756d 6e73 5f6c 6973 7420 3d20   columns_list = 
-0000b160: 4e6f 6e65 2069 6620 636f 6c75 6d6e 735f  None if columns_
-0000b170: 7072 6570 6172 6564 2069 7320 4e6f 6e65  prepared is None
-0000b180: 2065 6c73 6520 6c69 7374 2863 6f6c 756d   else list(colum
-0000b190: 6e73 5f70 7265 7061 7265 6429 0d0a 2020  ns_prepared)..  
-0000b1a0: 2020 7265 7375 6c74 5f67 6466 203d 2067    result_gdf = g
-0000b1b0: 7064 2e72 6561 645f 6669 6c65 280d 0a20  pd.read_file(.. 
-0000b1c0: 2020 2020 2020 2073 7472 2870 6174 6829         str(path)
-0000b1d0: 2c0d 0a20 2020 2020 2020 206c 6179 6572  ,..        layer
-0000b1e0: 3d6c 6179 6572 2c0d 0a20 2020 2020 2020  =layer,..       
-0000b1f0: 2062 626f 783d 6262 6f78 2c0d 0a20 2020   bbox=bbox,..   
-0000b200: 2020 2020 2072 6f77 733d 726f 7773 2c0d       rows=rows,.
-0000b210: 0a20 2020 2020 2020 2069 6e63 6c75 6465  .        include
-0000b220: 5f66 6965 6c64 733d 636f 6c75 6d6e 735f  _fields=columns_
-0000b230: 6c69 7374 2c0d 0a20 2020 2020 2020 2077  list,..        w
-0000b240: 6865 7265 3d77 6865 7265 2c0d 0a20 2020  here=where,..   
-0000b250: 2020 2020 2073 716c 3d73 716c 5f73 746d       sql=sql_stm
-0000b260: 742c 0d0a 2020 2020 2020 2020 7371 6c5f  t,..        sql_
-0000b270: 6469 616c 6563 743d 7371 6c5f 6469 616c  dialect=sql_dial
-0000b280: 6563 742c 0d0a 2020 2020 2020 2020 6967  ect,..        ig
-0000b290: 6e6f 7265 5f67 656f 6d65 7472 793d 6967  nore_geometry=ig
-0000b2a0: 6e6f 7265 5f67 656f 6d65 7472 792c 0d0a  nore_geometry,..
-0000b2b0: 2020 2020 290d 0a0d 0a20 2020 2023 2053      )....    # S
-0000b2c0: 6574 2074 6865 2069 6e64 6578 2074 6f20  et the index to 
-0000b2d0: 7468 6520 6261 636b 6564 2d75 7020 6669  the backed-up fi
-0000b2e0: 640d 0a20 2020 2069 6620 6669 645f 6173  d..    if fid_as
-0000b2f0: 5f69 6e64 6578 3a0d 0a20 2020 2020 2020  _index:..       
-0000b300: 2072 6573 756c 745f 6764 6620 3d20 7265   result_gdf = re
-0000b310: 7375 6c74 5f67 6466 2e73 6574 5f69 6e64  sult_gdf.set_ind
-0000b320: 6578 2822 5f5f 544d 505f 4745 4f46 494c  ex("__TMP_GEOFIL
-0000b330: 454f 5053 5f46 4944 2229 0d0a 2020 2020  EOPS_FID")..    
-0000b340: 2020 2020 7265 7375 6c74 5f67 6466 2e69      result_gdf.i
-0000b350: 6e64 6578 2e6e 616d 6520 3d20 2266 6964  ndex.name = "fid
-0000b360: 220d 0a0d 0a20 2020 2023 2052 656f 7264  "....    # Reord
-0000b370: 6572 2063 6f6c 756d 6e73 202b 2063 6861  er columns + cha
-0000b380: 6e67 6520 6361 7369 6e67 2073 6f20 7468  nge casing so th
-0000b390: 6579 2061 7265 2074 6865 2073 616d 6520  ey are the same 
-0000b3a0: 6173 2063 6f6c 756d 6e73 2070 6172 616d  as columns param
-0000b3b0: 6574 6572 0d0a 2020 2020 6966 2063 6f6c  eter..    if col
-0000b3c0: 756d 6e73 5f70 7265 7061 7265 6420 6973  umns_prepared is
-0000b3d0: 206e 6f74 204e 6f6e 6520 616e 6420 6c65   not None and le
-0000b3e0: 6e28 636f 6c75 6d6e 735f 7072 6570 6172  n(columns_prepar
-0000b3f0: 6564 2920 3e20 303a 0d0a 2020 2020 2020  ed) > 0:..      
-0000b400: 2020 636f 6c75 6d6e 735f 746f 5f6b 6565    columns_to_kee
-0000b410: 7020 3d20 6c69 7374 2863 6f6c 756d 6e73  p = list(columns
-0000b420: 5f70 7265 7061 7265 6429 0d0a 2020 2020  _prepared)..    
-0000b430: 2020 2020 6966 2022 6765 6f6d 6574 7279      if "geometry
-0000b440: 2220 696e 2072 6573 756c 745f 6764 662e  " in result_gdf.
-0000b450: 636f 6c75 6d6e 733a 0d0a 2020 2020 2020  columns:..      
-0000b460: 2020 2020 2020 636f 6c75 6d6e 735f 746f        columns_to
-0000b470: 5f6b 6565 7020 2b3d 205b 2267 656f 6d65  _keep += ["geome
-0000b480: 7472 7922 5d0d 0a20 2020 2020 2020 2072  try"]..        r
-0000b490: 6573 756c 745f 6764 6620 3d20 7265 7375  esult_gdf = resu
-0000b4a0: 6c74 5f67 6466 5b63 6f6c 756d 6e73 5f74  lt_gdf[columns_t
-0000b4b0: 6f5f 6b65 6570 5d0d 0a20 2020 2020 2020  o_keep]..       
-0000b4c0: 2072 6573 756c 745f 6764 6620 3d20 7265   result_gdf = re
-0000b4d0: 7375 6c74 5f67 6466 2e72 656e 616d 6528  sult_gdf.rename(
-0000b4e0: 636f 6c75 6d6e 733d 636f 6c75 6d6e 735f  columns=columns_
-0000b4f0: 7072 6570 6172 6564 290d 0a0d 0a20 2020  prepared)....   
-0000b500: 2023 2053 7461 7274 696e 6720 6672 6f6d   # Starting from
-0000b510: 2066 696f 6e61 2031 2e39 2c20 7374 7269   fiona 1.9, stri
-0000b520: 6e67 2063 6f6c 756d 6e73 2077 6974 6820  ng columns with 
-0000b530: 616c 6c20 4e6f 6e65 2076 616c 7565 7320  all None values 
-0000b540: 6172 6520 7265 6164 2061 7320 6265 696e  are read as bein
-0000b550: 670d 0a20 2020 2023 2066 6c6f 6174 2063  g..    # float c
-0000b560: 6f6c 756d 6e73 2e20 436f 6e76 6572 7420  olumns. Convert 
-0000b570: 7468 656d 2074 6f20 6f62 6a65 6374 2074  them to object t
-0000b580: 7970 652e 0d0a 2020 2020 666c 6f61 745f  ype...    float_
-0000b590: 636f 6c73 203d 206c 6973 7428 7265 7375  cols = list(resu
-0000b5a0: 6c74 5f67 6466 2e73 656c 6563 745f 6474  lt_gdf.select_dt
-0000b5b0: 7970 6573 285b 2266 6c6f 6174 3634 225d  ypes(["float64"]
-0000b5c0: 292e 636f 6c75 6d6e 7329 0d0a 2020 2020  ).columns)..    
-0000b5d0: 6966 206c 656e 2866 6c6f 6174 5f63 6f6c  if len(float_col
-0000b5e0: 7329 203e 2030 3a0d 0a20 2020 2020 2020  s) > 0:..       
-0000b5f0: 2023 2043 6865 636b 2066 6f72 2061 6c6c   # Check for all
-0000b600: 2066 6c6f 6174 2063 6f6c 756d 6e73 2066   float columns f
-0000b610: 6f75 6e64 2069 6620 7468 6579 2073 686f  ound if they sho
-0000b620: 756c 6420 6265 206f 626a 6563 7420 636f  uld be object co
-0000b630: 6c75 6d6e 7320 696e 7374 6561 640d 0a20  lumns instead.. 
-0000b640: 2020 2020 2020 2077 6974 6820 6669 6f6e         with fion
-0000b650: 612e 6f70 656e 2870 6174 682c 206c 6179  a.open(path, lay
-0000b660: 6572 3d6c 6179 6572 2920 6173 2063 6f6c  er=layer) as col
-0000b670: 6c65 6374 696f 6e3a 0d0a 2020 2020 2020  lection:..      
-0000b680: 2020 2020 2020 6173 7365 7274 2063 6f6c        assert col
-0000b690: 6c65 6374 696f 6e2e 7363 6865 6d61 2069  lection.schema i
-0000b6a0: 7320 6e6f 7420 4e6f 6e65 0d0a 2020 2020  s not None..    
-0000b6b0: 2020 2020 2020 2020 7072 6f70 6572 7469          properti
-0000b6c0: 6573 203d 2063 6f6c 6c65 6374 696f 6e2e  es = collection.
-0000b6d0: 7363 6865 6d61 5b22 7072 6f70 6572 7469  schema["properti
-0000b6e0: 6573 225d 0d0a 2020 2020 2020 2020 2020  es"]..          
-0000b6f0: 2020 666f 7220 636f 6c20 696e 2066 6c6f    for col in flo
-0000b700: 6174 5f63 6f6c 733a 0d0a 2020 2020 2020  at_cols:..      
-0000b710: 2020 2020 2020 2020 2020 6966 2063 6f6c            if col
-0000b720: 2069 6e20 7072 6f70 6572 7469 6573 2061   in properties a
-0000b730: 6e64 2070 726f 7065 7274 6965 735b 636f  nd properties[co
-0000b740: 6c5d 2e73 7461 7274 7377 6974 6828 2273  l].startswith("s
-0000b750: 7472 2229 3a0d 0a20 2020 2020 2020 2020  tr"):..         
-0000b760: 2020 2020 2020 2020 2020 2072 6573 756c             resul
-0000b770: 745f 6764 665b 636f 6c5d 203d 2028 0d0a  t_gdf[col] = (..
-0000b780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b790: 2020 2020 2020 2020 7265 7375 6c74 5f67          result_g
-0000b7a0: 6466 5b63 6f6c 5d2e 6173 7479 7065 286f  df[col].astype(o
-0000b7b0: 626a 6563 7429 2e72 6570 6c61 6365 286e  bject).replace(n
-0000b7c0: 702e 6e61 6e2c 204e 6f6e 6529 0d0a 2020  p.nan, None)..  
-0000b7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b7e0: 2020 290d 0a0d 0a20 2020 2072 6574 7572    )....    retur
-0000b7f0: 6e20 7265 7375 6c74 5f67 6466 0d0a 0d0a  n result_gdf....
-0000b800: 0d0a 6465 6620 5f72 6561 645f 6669 6c65  ..def _read_file
-0000b810: 5f62 6173 655f 7079 6f67 7269 6f28 0d0a  _base_pyogrio(..
-0000b820: 2020 2020 7061 7468 3a20 556e 696f 6e5b      path: Union[
-0000b830: 7374 722c 2022 6f73 2e50 6174 684c 696b  str, "os.PathLik
-0000b840: 655b 416e 795d 225d 2c0d 0a20 2020 206c  e[Any]"],..    l
-0000b850: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
-0000b860: 7472 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  tr] = None,..   
-0000b870: 2063 6f6c 756d 6e73 3a20 4f70 7469 6f6e   columns: Option
-0000b880: 616c 5b49 7465 7261 626c 655b 7374 725d  al[Iterable[str]
-0000b890: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2062  ] = None,..    b
-0000b8a0: 626f 783d 4e6f 6e65 2c0d 0a20 2020 2072  box=None,..    r
-0000b8b0: 6f77 733d 4e6f 6e65 2c0d 0a20 2020 2077  ows=None,..    w
-0000b8c0: 6865 7265 3a20 4f70 7469 6f6e 616c 5b73  here: Optional[s
-0000b8d0: 7472 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  tr] = None,..   
-0000b8e0: 2073 716c 5f73 746d 743a 204f 7074 696f   sql_stmt: Optio
-0000b8f0: 6e61 6c5b 7374 725d 203d 204e 6f6e 652c  nal[str] = None,
-0000b900: 0d0a 2020 2020 7371 6c5f 6469 616c 6563  ..    sql_dialec
-0000b910: 743a 204f 7074 696f 6e61 6c5b 4c69 7465  t: Optional[Lite
-0000b920: 7261 6c5b 2253 514c 4954 4522 2c20 224f  ral["SQLITE", "O
-0000b930: 4752 5351 4c22 5d5d 203d 204e 6f6e 652c  GRSQL"]] = None,
-0000b940: 0d0a 2020 2020 6967 6e6f 7265 5f67 656f  ..    ignore_geo
-0000b950: 6d65 7472 793a 2062 6f6f 6c20 3d20 4661  metry: bool = Fa
-0000b960: 6c73 652c 0d0a 2020 2020 6669 645f 6173  lse,..    fid_as
-0000b970: 5f69 6e64 6578 3a20 626f 6f6c 203d 2046  _index: bool = F
-0000b980: 616c 7365 2c0d 0a29 202d 3e20 556e 696f  alse,..) -> Unio
-0000b990: 6e5b 7064 2e44 6174 6146 7261 6d65 2c20  n[pd.DataFrame, 
-0000b9a0: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
-0000b9b0: 5d3a 0d0a 2020 2020 2222 220d 0a20 2020  ]:..    """..   
-0000b9c0: 2052 6561 6473 2061 2066 696c 6520 746f   Reads a file to
-0000b9d0: 2061 2070 616e 6461 7320 4461 7461 6672   a pandas Datafr
-0000b9e0: 616d 6520 7573 696e 6720 7079 6f67 7269  ame using pyogri
-0000b9f0: 6f2e 0d0a 2020 2020 2222 220d 0a20 2020  o...    """..   
-0000ba00: 2023 2049 6e69 740d 0a20 2020 2070 6174   # Init..    pat
-0000ba10: 6820 3d20 5061 7468 2870 6174 6829 0d0a  h = Path(path)..
-0000ba20: 2020 2020 6966 2070 6174 682e 6578 6973      if path.exis
-0000ba30: 7473 2829 2069 7320 4661 6c73 653a 0d0a  ts() is False:..
-0000ba40: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-0000ba50: 6c75 6545 7272 6f72 2866 2266 696c 6520  lueError(f"file 
-0000ba60: 646f 6573 6e27 7420 6578 6973 743a 207b  doesn't exist: {
-0000ba70: 7061 7468 7d22 290d 0a0d 0a20 2020 2023  path}")....    #
-0000ba80: 2043 6f6e 7665 7274 2072 6f77 7320 736c   Convert rows sl
-0000ba90: 6963 6520 6f62 6a65 6374 2074 6f20 7079  ice object to py
-0000baa0: 6f67 7269 6f20 7061 7261 6d65 7465 7273  ogrio parameters
-0000bab0: 0d0a 2020 2020 6966 2072 6f77 7320 6973  ..    if rows is
-0000bac0: 206e 6f74 204e 6f6e 653a 0d0a 2020 2020   not None:..    
-0000bad0: 2020 2020 736b 6970 5f66 6561 7475 7265      skip_feature
-0000bae0: 7320 3d20 726f 7773 2e73 7461 7274 0d0a  s = rows.start..
-0000baf0: 2020 2020 2020 2020 6d61 785f 6665 6174          max_feat
-0000bb00: 7572 6573 203d 2072 6f77 732e 7374 6f70  ures = rows.stop
-0000bb10: 202d 2072 6f77 732e 7374 6172 740d 0a20   - rows.start.. 
-0000bb20: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-0000bb30: 2020 736b 6970 5f66 6561 7475 7265 7320    skip_features 
-0000bb40: 3d20 300d 0a20 2020 2020 2020 206d 6178  = 0..        max
-0000bb50: 5f66 6561 7475 7265 7320 3d20 4e6f 6e65  _features = None
-0000bb60: 0d0a 2020 2020 2320 4172 726f 7720 646f  ..    # Arrow do
-0000bb70: 6573 6e27 7420 7375 7070 6f72 7420 6669  esn't support fi
-0000bb80: 6c74 6572 696e 6720 726f 7773 206c 696b  ltering rows lik
-0000bb90: 6520 7468 6973 0d0a 2020 2020 2320 7573  e this..    # us
-0000bba0: 655f 6172 726f 7720 3d20 5472 7565 2069  e_arrow = True i
-0000bbb0: 6620 726f 7773 2069 7320 4e6f 6e65 2065  f rows is None e
-0000bbc0: 6c73 6520 4661 6c73 650d 0a0d 0a20 2020  lse False....   
-0000bbd0: 2023 2049 6620 6e6f 2073 716c 5f73 746d   # If no sql_stm
-0000bbe0: 7420 7370 6563 6966 6965 640d 0a20 2020  t specified..   
-0000bbf0: 2063 6f6c 756d 6e73 5f70 7265 7061 7265   columns_prepare
-0000bc00: 6420 3d20 4e6f 6e65 0d0a 2020 2020 6966  d = None..    if
-0000bc10: 2073 716c 5f73 746d 7420 6973 204e 6f6e   sql_stmt is Non
-0000bc20: 653a 0d0a 2020 2020 2020 2020 2320 4966  e:..        # If
-0000bc30: 206e 6f20 6c61 7965 7220 7370 6563 6966   no layer specif
-0000bc40: 6965 642c 2074 6865 7265 2073 686f 756c  ied, there shoul
-0000bc50: 6420 6265 206f 6e6c 7920 6f6e 6520 6c61  d be only one la
-0000bc60: 7965 7220 696e 2074 6865 2066 696c 652e  yer in the file.
-0000bc70: 0d0a 2020 2020 2020 2020 6966 206c 6179  ..        if lay
-0000bc80: 6572 2069 7320 4e6f 6e65 3a0d 0a20 2020  er is None:..   
-0000bc90: 2020 2020 2020 2020 206c 6179 6572 203d           layer =
-0000bca0: 2067 6574 5f6f 6e6c 795f 6c61 7965 7228   get_only_layer(
-0000bcb0: 7061 7468 290d 0a0d 0a20 2020 2020 2020  path)....       
-0000bcc0: 2023 2043 6865 636b 696e 6720 6966 2063   # Checking if c
-0000bcd0: 6f6c 756d 6e20 6e61 6d65 7320 7368 6f75  olumn names shou
-0000bce0: 6c64 2062 6520 7265 6164 2069 7320 6361  ld be read is ca
-0000bcf0: 7365 2073 656e 7369 7469 7665 2069 6e20  se sensitive in 
-0000bd00: 7079 6f67 7269 6f2c 2073 6f0d 0a20 2020  pyogrio, so..   
-0000bd10: 2020 2020 2023 206d 616b 6520 7375 7265       # make sure
-0000bd20: 2074 6865 2063 6f6c 756d 6e20 6e61 6d65   the column name
-0000bd30: 7320 7370 6563 6966 6965 6420 6861 7665  s specified have
-0000bd40: 2074 6865 2073 616d 6520 6361 7369 6e67   the same casing
-0000bd50: 2e0d 0a20 2020 2020 2020 2069 6620 636f  ...        if co
-0000bd60: 6c75 6d6e 7320 6973 206e 6f74 204e 6f6e  lumns is not Non
-0000bd70: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-0000bd80: 6c61 7965 7269 6e66 6f20 3d20 6765 745f  layerinfo = get_
-0000bd90: 6c61 7965 7269 6e66 6f28 7061 7468 2c20  layerinfo(path, 
-0000bda0: 6c61 7965 723d 6c61 7965 722c 2072 6169  layer=layer, rai
-0000bdb0: 7365 5f6f 6e5f 6e6f 6765 6f6d 3d46 616c  se_on_nogeom=Fal
-0000bdc0: 7365 290d 0a20 2020 2020 2020 2020 2020  se)..           
-0000bdd0: 2063 6f6c 756d 6e73 5f75 7070 6572 5f6c   columns_upper_l
-0000bde0: 6f6f 6b75 7020 3d20 7b63 6f6c 756d 6e2e  ookup = {column.
-0000bdf0: 7570 7065 7228 293a 2063 6f6c 756d 6e20  upper(): column 
-0000be00: 666f 7220 636f 6c75 6d6e 2069 6e20 636f  for column in co
-0000be10: 6c75 6d6e 737d 0d0a 2020 2020 2020 2020  lumns}..        
-0000be20: 2020 2020 636f 6c75 6d6e 735f 7072 6570      columns_prep
-0000be30: 6172 6564 203d 207b 0d0a 2020 2020 2020  ared = {..      
-0000be40: 2020 2020 2020 2020 2020 636f 6c75 6d6e            column
-0000be50: 3a20 636f 6c75 6d6e 735f 7570 7065 725f  : columns_upper_
-0000be60: 6c6f 6f6b 7570 5b63 6f6c 756d 6e2e 7570  lookup[column.up
-0000be70: 7065 7228 295d 0d0a 2020 2020 2020 2020  per()]..        
-0000be80: 2020 2020 2020 2020 666f 7220 636f 6c75          for colu
-0000be90: 6d6e 2069 6e20 6c61 7965 7269 6e66 6f2e  mn in layerinfo.
-0000bea0: 636f 6c75 6d6e 730d 0a20 2020 2020 2020  columns..       
-0000beb0: 2020 2020 2020 2020 2069 6620 636f 6c75           if colu
-0000bec0: 6d6e 2e75 7070 6572 2829 2069 6e20 636f  mn.upper() in co
-0000bed0: 6c75 6d6e 735f 7570 7065 725f 6c6f 6f6b  lumns_upper_look
-0000bee0: 7570 0d0a 2020 2020 2020 2020 2020 2020  up..            
-0000bef0: 7d0d 0a20 2020 2065 6c73 653a 0d0a 2020  }..    else:..  
-0000bf00: 2020 2020 2020 2320 4669 6c6c 206f 7574        # Fill out
-0000bf10: 2070 6c61 6365 686f 6c64 6572 732c 206b   placeholders, k
-0000bf20: 6565 7020 636f 6c75 6d6e 735f 7072 6570  eep columns_prep
-0000bf30: 6172 6564 204e 6f6e 6520 6265 6361 7573  ared None becaus
-0000bf40: 6520 636f 6c75 6d6e 2066 696c 7465 7269  e column filteri
-0000bf50: 6e67 0d0a 2020 2020 2020 2020 2320 7368  ng..        # sh
-0000bf60: 6f75 6c64 2068 6170 7065 6e20 696e 2073  ould happen in s
-0000bf70: 716c 5f73 746d 742e 0d0a 2020 2020 2020  ql_stmt...      
-0000bf80: 2020 7371 6c5f 7374 6d74 203d 205f 6669    sql_stmt = _fi
-0000bf90: 6c6c 5f6f 7574 5f73 716c 5f70 6c61 6365  ll_out_sql_place
-0000bfa0: 686f 6c64 6572 7328 0d0a 2020 2020 2020  holders(..      
-0000bfb0: 2020 2020 2020 7061 7468 3d70 6174 682c        path=path,
-0000bfc0: 206c 6179 6572 3d6c 6179 6572 2c20 7371   layer=layer, sq
-0000bfd0: 6c5f 7374 6d74 3d73 716c 5f73 746d 742c  l_stmt=sql_stmt,
-0000bfe0: 2063 6f6c 756d 6e73 3d63 6f6c 756d 6e73   columns=columns
-0000bff0: 0d0a 2020 2020 2020 2020 290d 0a20 2020  ..        )..   
-0000c000: 2020 2020 2023 2053 7065 6369 6679 696e       # Specifyin
-0000c010: 6720 6120 6c61 7965 7220 6173 2077 656c  g a layer as wel
-0000c020: 6c20 6173 2061 6e20 5351 4c20 7374 6174  l as an SQL stat
-0000c030: 656d 656e 7420 696e 2070 796f 6772 696f  ement in pyogrio
-0000c040: 2069 7320 6e6f 7420 7375 7070 6f72 7465   is not supporte
-0000c050: 642e 0d0a 2020 2020 2020 2020 6c61 7965  d...        laye
-0000c060: 7220 3d20 4e6f 6e65 0d0a 0d0a 2020 2020  r = None....    
-0000c070: 2320 5265 6164 210d 0a20 2020 2063 6f6c  # Read!..    col
-0000c080: 756d 6e73 5f6c 6973 7420 3d20 4e6f 6e65  umns_list = None
-0000c090: 2069 6620 636f 6c75 6d6e 735f 7072 6570   if columns_prep
-0000c0a0: 6172 6564 2069 7320 4e6f 6e65 2065 6c73  ared is None els
-0000c0b0: 6520 6c69 7374 2863 6f6c 756d 6e73 5f70  e list(columns_p
-0000c0c0: 7265 7061 7265 6429 0d0a 2020 2020 7265  repared)..    re
-0000c0d0: 7375 6c74 5f67 6466 203d 2070 796f 6772  sult_gdf = pyogr
-0000c0e0: 696f 2e72 6561 645f 6461 7461 6672 616d  io.read_datafram
-0000c0f0: 6528 0d0a 2020 2020 2020 2020 7061 7468  e(..        path
-0000c100: 2c0d 0a20 2020 2020 2020 206c 6179 6572  ,..        layer
-0000c110: 3d6c 6179 6572 2c0d 0a20 2020 2020 2020  =layer,..       
-0000c120: 2063 6f6c 756d 6e73 3d63 6f6c 756d 6e73   columns=columns
-0000c130: 5f6c 6973 742c 0d0a 2020 2020 2020 2020  _list,..        
-0000c140: 6262 6f78 3d62 626f 782c 0d0a 2020 2020  bbox=bbox,..    
-0000c150: 2020 2020 736b 6970 5f66 6561 7475 7265      skip_feature
-0000c160: 733d 736b 6970 5f66 6561 7475 7265 732c  s=skip_features,
-0000c170: 0d0a 2020 2020 2020 2020 6d61 785f 6665  ..        max_fe
-0000c180: 6174 7572 6573 3d6d 6178 5f66 6561 7475  atures=max_featu
-0000c190: 7265 732c 0d0a 2020 2020 2020 2020 7768  res,..        wh
-0000c1a0: 6572 653d 7768 6572 652c 0d0a 2020 2020  ere=where,..    
-0000c1b0: 2020 2020 7371 6c3d 7371 6c5f 7374 6d74      sql=sql_stmt
-0000c1c0: 2c0d 0a20 2020 2020 2020 2073 716c 5f64  ,..        sql_d
-0000c1d0: 6961 6c65 6374 3d73 716c 5f64 6961 6c65  ialect=sql_diale
-0000c1e0: 6374 2c0d 0a20 2020 2020 2020 2072 6561  ct,..        rea
-0000c1f0: 645f 6765 6f6d 6574 7279 3d6e 6f74 2069  d_geometry=not i
-0000c200: 676e 6f72 655f 6765 6f6d 6574 7279 2c0d  gnore_geometry,.
-0000c210: 0a20 2020 2020 2020 2066 6964 5f61 735f  .        fid_as_
-0000c220: 696e 6465 783d 6669 645f 6173 5f69 6e64  index=fid_as_ind
-0000c230: 6578 2c0d 0a20 2020 2020 2020 2023 2075  ex,..        # u
-0000c240: 7365 5f61 7272 6f77 3d75 7365 5f61 7272  se_arrow=use_arr
-0000c250: 6f77 2c0d 0a20 2020 2029 0d0a 0d0a 2020  ow,..    )....  
-0000c260: 2020 2320 5265 6f72 6465 7220 636f 6c75    # Reorder colu
-0000c270: 6d6e 7320 2b20 6368 616e 6765 2063 6173  mns + change cas
-0000c280: 696e 6720 736f 2074 6865 7920 6172 6520  ing so they are 
-0000c290: 7468 6520 7361 6d65 2061 7320 636f 6c75  the same as colu
-0000c2a0: 6d6e 7320 7061 7261 6d65 7465 720d 0a20  mns parameter.. 
-0000c2b0: 2020 2069 6620 636f 6c75 6d6e 735f 7072     if columns_pr
-0000c2c0: 6570 6172 6564 2069 7320 6e6f 7420 4e6f  epared is not No
-0000c2d0: 6e65 2061 6e64 206c 656e 2863 6f6c 756d  ne and len(colum
-0000c2e0: 6e73 5f70 7265 7061 7265 6429 203e 2030  ns_prepared) > 0
-0000c2f0: 3a0d 0a20 2020 2020 2020 2063 6f6c 756d  :..        colum
-0000c300: 6e73 5f74 6f5f 6b65 6570 203d 206c 6973  ns_to_keep = lis
-0000c310: 7428 636f 6c75 6d6e 735f 7072 6570 6172  t(columns_prepar
-0000c320: 6564 290d 0a20 2020 2020 2020 2069 6620  ed)..        if 
-0000c330: 6c61 7965 7269 6e66 6f2e 6765 6f6d 6574  layerinfo.geomet
-0000c340: 7279 636f 6c75 6d6e 2069 7320 6e6f 7420  rycolumn is not 
-0000c350: 4e6f 6e65 2061 6e64 206e 6f74 2069 676e  None and not ign
-0000c360: 6f72 655f 6765 6f6d 6574 7279 3a0d 0a20  ore_geometry:.. 
-0000c370: 2020 2020 2020 2020 2020 2063 6f6c 756d             colum
-0000c380: 6e73 5f74 6f5f 6b65 6570 202b 3d20 5b22  ns_to_keep += ["
-0000c390: 6765 6f6d 6574 7279 225d 0d0a 2020 2020  geometry"]..    
-0000c3a0: 2020 2020 7265 7375 6c74 5f67 6466 203d      result_gdf =
-0000c3b0: 2072 6573 756c 745f 6764 665b 636f 6c75   result_gdf[colu
-0000c3c0: 6d6e 735f 746f 5f6b 6565 705d 0d0a 2020  mns_to_keep]..  
-0000c3d0: 2020 2020 2020 7265 7375 6c74 5f67 6466        result_gdf
-0000c3e0: 203d 2072 6573 756c 745f 6764 662e 7265   = result_gdf.re
-0000c3f0: 6e61 6d65 2863 6f6c 756d 6e73 3d63 6f6c  name(columns=col
-0000c400: 756d 6e73 5f70 7265 7061 7265 6429 0d0a  umns_prepared)..
-0000c410: 0d0a 2020 2020 2320 4361 7374 2063 6f6c  ..    # Cast col
-0000c420: 756d 6e73 2074 6861 7420 6172 6520 6f66  umns that are of
-0000c430: 206f 626a 6563 7420 7479 7065 2c20 6275   object type, bu
-0000c440: 7420 636f 6e74 6169 6e20 6461 7465 7469  t contain dateti
-0000c450: 6d65 2e64 6174 6520 6f72 2064 6174 6574  me.date or datet
-0000c460: 696d 652e 6461 7465 0d0a 2020 2020 2320  ime.date..    # 
-0000c470: 746f 2070 726f 7065 7220 6461 7465 7469  to proper dateti
-0000c480: 6d65 3634 2063 6f6c 756d 6e73 2e0d 0a20  me64 columns... 
-0000c490: 2020 2069 6620 6c65 6e28 7265 7375 6c74     if len(result
-0000c4a0: 5f67 6466 2920 3e20 303a 0d0a 2020 2020  _gdf) > 0:..    
-0000c4b0: 2020 2020 666f 7220 636f 6c75 6d6e 2069      for column i
-0000c4c0: 6e20 7265 7375 6c74 5f67 6466 2e73 656c  n result_gdf.sel
-0000c4d0: 6563 745f 6474 7970 6573 2869 6e63 6c75  ect_dtypes(inclu
-0000c4e0: 6465 3d5b 226f 626a 6563 7422 5d29 3a0d  de=["object"]):.
-0000c4f0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000c500: 6973 696e 7374 616e 6365 280d 0a20 2020  isinstance(..   
-0000c510: 2020 2020 2020 2020 2020 2020 2072 6573               res
-0000c520: 756c 745f 6764 665b 636f 6c75 6d6e 5d2e  ult_gdf[column].
-0000c530: 696c 6f63 5b30 5d2c 2028 6461 7465 7469  iloc[0], (dateti
-0000c540: 6d65 2e64 6174 652c 2064 6174 6574 696d  me.date, datetim
-0000c550: 652e 6461 7465 7469 6d65 290d 0a20 2020  e.datetime)..   
-0000c560: 2020 2020 2020 2020 2029 3a0d 0a20 2020           ):..   
-0000c570: 2020 2020 2020 2020 2020 2020 2072 6573               res
-0000c580: 756c 745f 6764 665b 636f 6c75 6d6e 5d20  ult_gdf[column] 
-0000c590: 3d20 7064 2e74 6f5f 6461 7465 7469 6d65  = pd.to_datetime
-0000c5a0: 2872 6573 756c 745f 6764 665b 636f 6c75  (result_gdf[colu
-0000c5b0: 6d6e 5d29 0d0a 0d0a 2020 2020 6173 7365  mn])....    asse
-0000c5c0: 7274 2069 7369 6e73 7461 6e63 6528 7265  rt isinstance(re
-0000c5d0: 7375 6c74 5f67 6466 2c20 2867 7064 2e47  sult_gdf, (gpd.G
-0000c5e0: 656f 4461 7461 4672 616d 652c 2070 642e  eoDataFrame, pd.
-0000c5f0: 4461 7461 4672 616d 6529 290d 0a20 2020  DataFrame))..   
-0000c600: 2072 6574 7572 6e20 7265 7375 6c74 5f67   return result_g
-0000c610: 6466 0d0a 0d0a 0d0a 6465 6620 5f66 696c  df......def _fil
-0000c620: 6c5f 6f75 745f 7371 6c5f 706c 6163 6568  l_out_sql_placeh
-0000c630: 6f6c 6465 7273 280d 0a20 2020 2070 6174  olders(..    pat
-0000c640: 683a 2050 6174 682c 206c 6179 6572 3a20  h: Path, layer: 
-0000c650: 4f70 7469 6f6e 616c 5b73 7472 5d2c 2073  Optional[str], s
-0000c660: 716c 5f73 746d 743a 2073 7472 2c20 636f  ql_stmt: str, co
-0000c670: 6c75 6d6e 733a 204f 7074 696f 6e61 6c5b  lumns: Optional[
-0000c680: 4974 6572 6162 6c65 5b73 7472 5d5d 0d0a  Iterable[str]]..
-0000c690: 2920 2d3e 2073 7472 3a0d 0a20 2020 2023  ) -> str:..    #
-0000c6a0: 2046 696c 6c20 6f75 7420 706c 6163 6568   Fill out placeh
-0000c6b0: 6f6c 6465 7273 2069 6e20 7468 6520 7371  olders in the sq
-0000c6c0: 6c5f 7374 6d74 2069 6620 6e65 6564 6564  l_stmt if needed
-0000c6d0: 3a0d 0a20 2020 2070 6c61 6365 686f 6c64  :..    placehold
-0000c6e0: 6572 7320 3d20 5b0d 0a20 2020 2020 2020  ers = [..       
-0000c6f0: 206e 616d 6520 666f 7220 5f2c 206e 616d   name for _, nam
-0000c700: 652c 205f 2c20 5f20 696e 2073 7472 696e  e, _, _ in strin
-0000c710: 672e 466f 726d 6174 7465 7228 292e 7061  g.Formatter().pa
-0000c720: 7273 6528 7371 6c5f 7374 6d74 2920 6966  rse(sql_stmt) if
-0000c730: 206e 616d 650d 0a20 2020 205d 0d0a 2020   name..    ]..  
-0000c740: 2020 6c61 7965 725f 746d 7020 3d20 6c61    layer_tmp = la
-0000c750: 7965 720d 0a20 2020 206c 6179 6572 696e  yer..    layerin
-0000c760: 666f 203d 204e 6f6e 650d 0a20 2020 2066  fo = None..    f
-0000c770: 6f72 6d61 745f 6b77 6172 6773 3a20 4469  ormat_kwargs: Di
-0000c780: 6374 5b73 7472 2c20 416e 795d 203d 207b  ct[str, Any] = {
-0000c790: 7d0d 0a20 2020 2066 6f72 2070 6c61 6365  }..    for place
-0000c7a0: 686f 6c64 6572 2069 6e20 706c 6163 6568  holder in placeh
-0000c7b0: 6f6c 6465 7273 3a0d 0a20 2020 2020 2020  olders:..       
-0000c7c0: 2069 6620 6c61 7965 725f 746d 7020 6973   if layer_tmp is
-0000c7d0: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-0000c7e0: 2020 2020 6c61 7965 725f 746d 7020 3d20      layer_tmp = 
-0000c7f0: 6765 745f 6f6e 6c79 5f6c 6179 6572 2870  get_only_layer(p
-0000c800: 6174 6829 0d0a 0d0a 2020 2020 2020 2020  ath)....        
-0000c810: 6966 2070 6c61 6365 686f 6c64 6572 203d  if placeholder =
-0000c820: 3d20 2269 6e70 7574 5f6c 6179 6572 223a  = "input_layer":
-0000c830: 0d0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
-0000c840: 726d 6174 5f6b 7761 7267 735b 706c 6163  rmat_kwargs[plac
-0000c850: 6568 6f6c 6465 725d 203d 206c 6179 6572  eholder] = layer
-0000c860: 5f74 6d70 0d0a 2020 2020 2020 2020 656c  _tmp..        el
-0000c870: 6966 2070 6c61 6365 686f 6c64 6572 203d  if placeholder =
-0000c880: 3d20 2267 656f 6d65 7472 7963 6f6c 756d  = "geometrycolum
-0000c890: 6e22 3a0d 0a20 2020 2020 2020 2020 2020  n":..           
-0000c8a0: 2069 6620 6c61 7965 7269 6e66 6f20 6973   if layerinfo is
-0000c8b0: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-0000c8c0: 2020 2020 2020 2020 6c61 7965 7269 6e66          layerinf
-0000c8d0: 6f20 3d20 6765 745f 6c61 7965 7269 6e66  o = get_layerinf
-0000c8e0: 6f28 7061 7468 2c20 6c61 7965 725f 746d  o(path, layer_tm
-0000c8f0: 7029 0d0a 2020 2020 2020 2020 2020 2020  p)..            
-0000c900: 666f 726d 6174 5f6b 7761 7267 735b 706c  format_kwargs[pl
-0000c910: 6163 6568 6f6c 6465 725d 203d 206c 6179  aceholder] = lay
-0000c920: 6572 696e 666f 2e67 656f 6d65 7472 7963  erinfo.geometryc
-0000c930: 6f6c 756d 6e0d 0a20 2020 2020 2020 2065  olumn..        e
-0000c940: 6c69 6620 706c 6163 6568 6f6c 6465 7220  lif placeholder 
-0000c950: 3d3d 2022 636f 6c75 6d6e 735f 746f 5f73  == "columns_to_s
-0000c960: 656c 6563 745f 7374 7222 3a0d 0a20 2020  elect_str":..   
-0000c970: 2020 2020 2020 2020 2069 6620 6c61 7965           if laye
-0000c980: 7269 6e66 6f20 6973 204e 6f6e 653a 0d0a  rinfo is None:..
-0000c990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c9a0: 6c61 7965 7269 6e66 6f20 3d20 6765 745f  layerinfo = get_
-0000c9b0: 6c61 7965 7269 6e66 6f28 7061 7468 2c20  layerinfo(path, 
-0000c9c0: 6c61 7965 725f 746d 7029 0d0a 2020 2020  layer_tmp)..    
-0000c9d0: 2020 2020 2020 2020 636f 6c75 6d6e 735f          columns_
-0000c9e0: 6173 6b65 6420 3d20 4e6f 6e65 2069 6620  asked = None if 
-0000c9f0: 636f 6c75 6d6e 7320 6973 204e 6f6e 6520  columns is None 
-0000ca00: 656c 7365 206c 6973 7428 636f 6c75 6d6e  else list(column
-0000ca10: 7329 0d0a 2020 2020 2020 2020 2020 2020  s)..            
-0000ca20: 666f 726d 6174 7465 7220 3d20 5f6f 6772  formatter = _ogr
-0000ca30: 5f73 716c 5f75 7469 6c2e 436f 6c75 6d6e  _sql_util.Column
-0000ca40: 466f 726d 6174 7465 7228 0d0a 2020 2020  Formatter(..    
-0000ca50: 2020 2020 2020 2020 2020 2020 636f 6c75              colu
-0000ca60: 6d6e 735f 6173 6b65 643d 636f 6c75 6d6e  mns_asked=column
-0000ca70: 735f 6173 6b65 642c 0d0a 2020 2020 2020  s_asked,..      
-0000ca80: 2020 2020 2020 2020 2020 636f 6c75 6d6e            column
-0000ca90: 735f 696e 5f6c 6179 6572 3d6c 6179 6572  s_in_layer=layer
-0000caa0: 696e 666f 2e63 6f6c 756d 6e73 2c0d 0a20  info.columns,.. 
-0000cab0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0000cac0: 6964 5f63 6f6c 756d 6e3d 6c61 7965 7269  id_column=layeri
-0000cad0: 6e66 6f2e 6669 645f 636f 6c75 6d6e 2c0d  nfo.fid_column,.
-0000cae0: 0a20 2020 2020 2020 2020 2020 2029 0d0a  .            )..
-0000caf0: 2020 2020 2020 2020 2020 2020 666f 726d              form
-0000cb00: 6174 5f6b 7761 7267 735b 706c 6163 6568  at_kwargs[placeh
-0000cb10: 6f6c 6465 725d 203d 2066 6f72 6d61 7474  older] = formatt
-0000cb20: 6572 2e70 7265 6669 7865 645f 616c 6961  er.prefixed_alia
-0000cb30: 7365 6428 290d 0a0d 0a20 2020 2020 2020  sed()....       
-0000cb40: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-0000cb50: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-0000cb60: 7272 6f72 280d 0a20 2020 2020 2020 2020  rror(..         
-0000cb70: 2020 2020 2020 2066 2275 6e6b 6e6f 776e         f"unknown
-0000cb80: 2070 6c61 6365 686f 6c64 6572 207b 706c   placeholder {pl
-0000cb90: 6163 6568 6f6c 6465 727d 2069 6e20 7371  aceholder} in sq
-0000cba0: 6c5f 7374 6d74 3a20 7b73 716c 5f73 746d  l_stmt: {sql_stm
-0000cbb0: 747d 220d 0a20 2020 2020 2020 2020 2020  t}"..           
-0000cbc0: 2029 0d0a 0d0a 2020 2020 6966 206c 656e   )....    if len
-0000cbd0: 2866 6f72 6d61 745f 6b77 6172 6773 2920  (format_kwargs) 
-0000cbe0: 3e20 303a 0d0a 2020 2020 2020 2020 7371  > 0:..        sq
-0000cbf0: 6c5f 7374 6d74 203d 2073 716c 5f73 746d  l_stmt = sql_stm
-0000cc00: 742e 666f 726d 6174 282a 2a66 6f72 6d61  t.format(**forma
-0000cc10: 745f 6b77 6172 6773 290d 0a20 2020 2072  t_kwargs)..    r
-0000cc20: 6574 7572 6e20 7371 6c5f 7374 6d74 0d0a  eturn sql_stmt..
-0000cc30: 0d0a 0d0a 6465 6620 7265 6164 5f66 696c  ....def read_fil
-0000cc40: 655f 7371 6c28 0d0a 2020 2020 7061 7468  e_sql(..    path
-0000cc50: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
-0000cc60: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
-0000cc70: 2c0d 0a20 2020 2073 716c 5f73 746d 743a  ,..    sql_stmt:
-0000cc80: 2073 7472 2c0d 0a20 2020 2073 716c 5f64   str,..    sql_d
-0000cc90: 6961 6c65 6374 3a20 4f70 7469 6f6e 616c  ialect: Optional
-0000cca0: 5b4c 6974 6572 616c 5b22 5351 4c49 5445  [Literal["SQLITE
-0000ccb0: 222c 2022 4f47 5253 514c 225d 5d20 3d20  ", "OGRSQL"]] = 
-0000ccc0: 2253 514c 4954 4522 2c0d 0a20 2020 206c  "SQLITE",..    l
-0000ccd0: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
-0000cce0: 7472 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  tr] = None,..   
-0000ccf0: 2069 676e 6f72 655f 6765 6f6d 6574 7279   ignore_geometry
-0000cd00: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-0000cd10: 0a29 202d 3e20 556e 696f 6e5b 7064 2e44  .) -> Union[pd.D
-0000cd20: 6174 6146 7261 6d65 2c20 6770 642e 4765  ataFrame, gpd.Ge
-0000cd30: 6f44 6174 6146 7261 6d65 5d3a 0d0a 2020  oDataFrame]:..  
-0000cd40: 2020 2222 220d 0a20 2020 2044 4550 5245    """..    DEPRE
-0000cd50: 4341 5445 443a 2052 6561 6473 2061 2066  CATED: Reads a f
-0000cd60: 696c 6520 7573 696e 6720 616e 2053 514c  ile using an SQL
-0000cd70: 2073 7461 7465 6d65 6e74 2e0d 0a0d 0a20   statement..... 
-0000cd80: 2020 2041 7267 733a 0d0a 2020 2020 2020     Args:..      
-0000cd90: 2020 7061 7468 2028 6669 6c65 2070 6174    path (file pat
-0000cda0: 6829 3a20 7061 7468 2074 6f20 7468 6520  h): path to the 
-0000cdb0: 6669 6c65 2074 6f20 7265 6164 2066 726f  file to read fro
-0000cdc0: 6d0d 0a20 2020 2020 2020 2073 716c 5f73  m..        sql_s
-0000cdd0: 746d 7420 2873 7472 293a 2053 514c 2073  tmt (str): SQL s
-0000cde0: 7461 7465 6d65 6e74 2074 6f20 7573 650d  tatement to use.
-0000cdf0: 0a20 2020 2020 2020 2073 716c 5f64 6961  .        sql_dia
-0000ce00: 6c65 6374 2028 7374 722c 206f 7074 696f  lect (str, optio
-0000ce10: 6e61 6c29 3a20 5351 4c20 6469 616c 6563  nal): SQL dialec
-0000ce20: 7420 7573 6564 2e20 4465 6661 756c 7473  t used. Defaults
-0000ce30: 2074 6f20 2753 514c 4954 4527 2e0d 0a20   to 'SQLITE'... 
-0000ce40: 2020 2020 2020 206c 6179 6572 2028 7374         layer (st
-0000ce50: 722c 206f 7074 696f 6e61 6c29 3a20 5468  r, optional): Th
-0000ce60: 6520 6c61 7965 7220 746f 2072 6561 642e  e layer to read.
-0000ce70: 2049 6620 6e6f 206c 6179 6572 2069 7320   If no layer is 
-0000ce80: 7370 6563 6966 6965 642c 0d0a 2020 2020  specified,..    
-0000ce90: 2020 2020 2020 2020 7265 6164 7320 7468          reads th
-0000cea0: 6520 6f6e 6c79 206c 6179 6572 2069 6e20  e only layer in 
-0000ceb0: 7468 6520 6669 6c65 206f 7220 7468 726f  the file or thro
-0000cec0: 7773 2061 6e20 4578 6365 7074 696f 6e2e  ws an Exception.
-0000ced0: 0d0a 2020 2020 2020 2020 6967 6e6f 7265  ..        ignore
-0000cee0: 5f67 656f 6d65 7472 7920 2862 6f6f 6c2c  _geometry (bool,
-0000cef0: 206f 7074 696f 6e61 6c29 3a20 5472 7565   optional): True
-0000cf00: 206e 6f74 2074 6f20 7265 6164 2f72 6574   not to read/ret
-0000cf10: 7572 6e20 7468 6520 6765 6f6d 6174 7279  urn the geomatry
-0000cf20: 2e0d 0a20 2020 2020 2020 2020 2020 2044  ...            D
-0000cf30: 6566 6175 6c74 7320 746f 2046 616c 7365  efaults to False
-0000cf40: 2e0d 0a0d 0a20 2020 2052 6574 7572 6e73  .....    Returns
-0000cf50: 3a0d 0a20 2020 2020 2020 2055 6e69 6f6e  :..        Union
-0000cf60: 5b70 642e 4461 7461 4672 616d 652c 2067  [pd.DataFrame, g
-0000cf70: 7064 2e47 656f 4461 7461 4672 616d 655d  pd.GeoDataFrame]
-0000cf80: 3a20 5468 6520 6461 7461 2072 6561 642e  : The data read.
-0000cf90: 0d0a 2020 2020 2222 220d 0a20 2020 2077  ..    """..    w
-0000cfa0: 6172 6e69 6e67 732e 7761 726e 280d 0a20  arnings.warn(.. 
-0000cfb0: 2020 2020 2020 2027 7265 6164 5f66 696c         'read_fil
-0000cfc0: 655f 7371 6c20 6973 2064 6570 7265 6361  e_sql is depreca
-0000cfd0: 7465 643a 2075 7365 2072 6561 645f 6669  ted: use read_fi
-0000cfe0: 6c65 2120 4d69 6e64 3a20 7371 6c5f 6469  le! Mind: sql_di
-0000cff0: 616c 6563 7420 6973 206e 6f74 2022 5351  alect is not "SQ
-0000d000: 4c49 5445 2220 270d 0a20 2020 2020 2020  LITE" '..       
-0000d010: 2022 6279 2064 6566 6175 6c74 2074 6865   "by default the
-0000d020: 7265 2122 2c0d 0a20 2020 2020 2020 2046  re!",..        F
-0000d030: 7574 7572 6557 6172 6e69 6e67 2c0d 0a20  utureWarning,.. 
-0000d040: 2020 2020 2020 2073 7461 636b 6c65 7665         stackleve
-0000d050: 6c3d 322c 0d0a 2020 2020 290d 0a0d 0a20  l=2,..    ).... 
-0000d060: 2020 2023 2052 756e 0d0a 2020 2020 7265     # Run..    re
-0000d070: 7475 726e 205f 7265 6164 5f66 696c 655f  turn _read_file_
-0000d080: 6261 7365 280d 0a20 2020 2020 2020 2070  base(..        p
-0000d090: 6174 682c 0d0a 2020 2020 2020 2020 7371  ath,..        sq
-0000d0a0: 6c5f 7374 6d74 3d73 716c 5f73 746d 742c  l_stmt=sql_stmt,
-0000d0b0: 0d0a 2020 2020 2020 2020 7371 6c5f 6469  ..        sql_di
-0000d0c0: 616c 6563 743d 7371 6c5f 6469 616c 6563  alect=sql_dialec
-0000d0d0: 742c 0d0a 2020 2020 2020 2020 6c61 7965  t,..        laye
-0000d0e0: 723d 6c61 7965 722c 0d0a 2020 2020 2020  r=layer,..      
-0000d0f0: 2020 6967 6e6f 7265 5f67 656f 6d65 7472    ignore_geometr
-0000d100: 793d 6967 6e6f 7265 5f67 656f 6d65 7472  y=ignore_geometr
-0000d110: 792c 0d0a 2020 2020 290d 0a0d 0a0d 0a64  y,..    )......d
-0000d120: 6566 2074 6f5f 6669 6c65 280d 0a20 2020  ef to_file(..   
-0000d130: 2067 6466 3a20 556e 696f 6e5b 7064 2e44   gdf: Union[pd.D
-0000d140: 6174 6146 7261 6d65 2c20 6770 642e 4765  ataFrame, gpd.Ge
-0000d150: 6f44 6174 6146 7261 6d65 5d2c 0d0a 2020  oDataFrame],..  
-0000d160: 2020 7061 7468 3a20 556e 696f 6e5b 7374    path: Union[st
-0000d170: 722c 2022 6f73 2e50 6174 684c 696b 655b  r, "os.PathLike[
-0000d180: 416e 795d 225d 2c0d 0a20 2020 206c 6179  Any]"],..    lay
-0000d190: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
-0000d1a0: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2066  ] = None,..    f
-0000d1b0: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-0000d1c0: 6574 7279 7479 7065 3a20 556e 696f 6e5b  etrytype: Union[
-0000d1d0: 4765 6f6d 6574 7279 5479 7065 2c20 7374  GeometryType, st
-0000d1e0: 722c 204e 6f6e 655d 203d 204e 6f6e 652c  r, None] = None,
-0000d1f0: 0d0a 2020 2020 666f 7263 655f 6d75 6c74  ..    force_mult
-0000d200: 6974 7970 653a 2062 6f6f 6c20 3d20 4661  itype: bool = Fa
-0000d210: 6c73 652c 0d0a 2020 2020 6170 7065 6e64  lse,..    append
-0000d220: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-0000d230: 0a20 2020 2061 7070 656e 645f 7469 6d65  .    append_time
-0000d240: 6f75 745f 733a 2069 6e74 203d 2036 3030  out_s: int = 600
-0000d250: 2c0d 0a20 2020 2069 6e64 6578 3a20 4f70  ,..    index: Op
-0000d260: 7469 6f6e 616c 5b62 6f6f 6c5d 203d 204e  tional[bool] = N
-0000d270: 6f6e 652c 0d0a 2020 2020 6372 6561 7465  one,..    create
-0000d280: 5f73 7061 7469 616c 5f69 6e64 6578 3a20  _spatial_index: 
-0000d290: 4f70 7469 6f6e 616c 5b62 6f6f 6c5d 203d  Optional[bool] =
-0000d2a0: 2054 7275 652c 0d0a 293a 0d0a 2020 2020   True,..):..    
-0000d2b0: 2222 220d 0a20 2020 2057 7269 7465 7320  """..    Writes 
-0000d2c0: 6120 7061 6e64 6173 2064 6174 6166 7261  a pandas datafra
-0000d2d0: 6d65 2074 6f20 6669 6c65 2e0d 0a0d 0a20  me to file..... 
-0000d2e0: 2020 2054 6865 2066 696c 6566 6f72 6d61     The fileforma
-0000d2f0: 7420 6973 2064 6574 6563 7465 6420 6261  t is detected ba
-0000d300: 7365 6420 6f6e 2074 6865 2066 696c 6570  sed on the filep
-0000d310: 6174 6820 6578 7465 6e73 696f 6e2e 0d0a  ath extension...
-0000d320: 0d0a 2020 2020 5468 6520 756e 6465 726c  ..    The underl
-0000d330: 7969 6e67 206c 6962 7261 7279 2075 7365  ying library use
-0000d340: 6420 746f 2077 7269 7465 2074 6865 2066  d to write the f
-0000d350: 696c 6520 6361 6e20 6265 2063 686f 6f73  ile can be choos
-0000d360: 656e 2075 7369 6e67 2074 6865 0d0a 2020  en using the..  
-0000d370: 2020 2247 464f 5f49 4f5f 454e 4749 4e45    "GFO_IO_ENGINE
-0000d380: 2220 656e 7669 726f 6e6d 656e 7420 7661  " environment va
-0000d390: 7269 6162 6c65 2e20 506f 7373 6962 6c65  riable. Possible
-0000d3a0: 2076 616c 7565 7320 6172 6520 2266 696f   values are "fio
-0000d3b0: 6e61 2220 616e 6420 2270 796f 6772 696f  na" and "pyogrio
-0000d3c0: 222e 0d0a 2020 2020 4465 6661 756c 7420  "...    Default 
-0000d3d0: 656e 6769 6e65 2069 7320 2270 796f 6772  engine is "pyogr
-0000d3e0: 696f 222e 0d0a 0d0a 2020 2020 4172 6773  io".....    Args
-0000d3f0: 3a0d 0a20 2020 2020 2020 2067 6466 2028  :..        gdf (
-0000d400: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
-0000d410: 293a 2054 6865 2047 656f 4461 7461 4672  ): The GeoDataFr
-0000d420: 616d 6520 746f 2065 7870 6f72 7420 746f  ame to export to
-0000d430: 2066 696c 652e 0d0a 2020 2020 2020 2020   file...        
-0000d440: 7061 7468 2028 556e 696f 6e5b 7374 722c  path (Union[str,
-0000d450: 293a 2054 6865 2066 696c 6520 7061 7468  ): The file path
-0000d460: 2074 6f20 7772 6974 6520 746f 2e0d 0a20   to write to... 
-0000d470: 2020 2020 2020 206c 6179 6572 2028 7374         layer (st
-0000d480: 722c 206f 7074 696f 6e61 6c29 3a20 5468  r, optional): Th
-0000d490: 6520 6c61 7965 7220 746f 2072 6561 642e  e layer to read.
-0000d4a0: 2049 6620 6e6f 206c 6179 6572 2069 7320   If no layer is 
-0000d4b0: 7370 6563 6966 6965 642c 0d0a 2020 2020  specified,..    
-0000d4c0: 2020 2020 2020 2020 7265 6164 7320 7468          reads th
-0000d4d0: 6520 6f6e 6c79 206c 6179 6572 2069 6e20  e only layer in 
-0000d4e0: 7468 6520 6669 6c65 206f 7220 7468 726f  the file or thro
-0000d4f0: 7773 2061 6e20 4578 6365 7074 696f 6e2e  ws an Exception.
-0000d500: 0d0a 2020 2020 2020 2020 666f 7263 655f  ..        force_
-0000d510: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-0000d520: 7970 6520 2855 6e69 6f6e 5b47 656f 6d65  ype (Union[Geome
-0000d530: 7472 7954 7970 652c 2073 7472 5d2c 206f  tryType, str], o
-0000d540: 7074 696f 6e61 6c29 3a20 4765 6f6d 6574  ptional): Geomet
-0000d550: 7279 2074 7970 650d 0a20 2020 2020 2020  ry type..       
-0000d560: 2020 2020 2074 6f20 2874 7279 2074 6f29       to (try to)
-0000d570: 2066 6f72 6365 2074 6865 206f 7574 7075   force the outpu
-0000d580: 7420 746f 2e20 4465 6661 756c 7473 2074  t to. Defaults t
-0000d590: 6f20 4e6f 6e65 2e0d 0a20 2020 2020 2020  o None...       
-0000d5a0: 2020 2020 204d 6172 6b3a 2063 6f6d 7061       Mark: compa
-0000d5b0: 7265 6420 746f 206f 7468 6572 2066 756e  red to other fun
-0000d5c0: 6374 696f 6e73 2069 6e20 6766 6f20 7769  ctions in gfo wi
-0000d5d0: 7468 2074 6869 7320 7061 7261 6d65 7465  th this paramete
-0000d5e0: 722c 2074 6865 2062 6568 6176 696f 7572  r, the behaviour
-0000d5f0: 0d0a 2020 2020 2020 2020 2020 2020 6865  ..            he
-0000d600: 7265 2069 7320 6c69 6d69 7465 6420 746f  re is limited to
-0000d610: 2074 6865 2066 6f6c 6c6f 7769 6e67 3a0d   the following:.
-0000d620: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d630: 202d 2066 6f72 2065 6d70 7479 2069 6e70   - for empty inp
-0000d640: 7574 2067 6466 2773 2c20 6120 7374 616e  ut gdf's, a stan
-0000d650: 6461 7264 2067 656f 6d65 7472 7920 7479  dard geometry ty
-0000d660: 7065 2028 6567 2e20 506f 6c79 676f 6e2c  pe (eg. Polygon,
-0000d670: 2e2e 2e29 2063 616e 0d0a 2020 2020 2020  ...) can..      
-0000d680: 2020 2020 2020 2020 2020 2020 6265 2075              be u
-0000d690: 7365 6420 746f 2066 6f72 6365 2074 6865  sed to force the
-0000d6a0: 2067 656f 6d65 7472 7920 636f 6c75 6d6e   geometry column
-0000d6b0: 2074 6f20 6265 206f 6620 7468 6174 2074   to be of that t
-0000d6c0: 7970 652e 0d0a 2020 2020 2020 2020 2020  ype...          
-0000d6d0: 2020 2020 2020 2d20 6966 2066 6f72 6365        - if force
-0000d6e0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
-0000d6f0: 7479 7065 2069 7320 6120 4d55 4c54 4920  type is a MULTI 
-0000d700: 7479 7065 2c20 7061 7261 6d65 7465 720d  type, parameter.
-0000d710: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d720: 2020 2066 6f72 6365 5f6d 756c 7469 7479     force_multity
-0000d730: 7065 2062 6563 6f6d 6573 2054 7275 652e  pe becomes True.
-0000d740: 0d0a 2020 2020 2020 2020 666f 7263 655f  ..        force_
-0000d750: 6d75 6c74 6974 7970 6520 2862 6f6f 6c2c  multitype (bool,
-0000d760: 206f 7074 696f 6e61 6c29 3a20 666f 7263   optional): forc
-0000d770: 6520 7468 6520 6765 6f6d 6574 7279 2074  e the geometry t
-0000d780: 7970 6520 746f 2061 206d 756c 7469 7479  ype to a multity
-0000d790: 7065 0d0a 2020 2020 2020 2020 2020 2020  pe..            
-0000d7a0: 666f 7220 6669 6c65 2074 7970 6573 2074  for file types t
-0000d7b0: 6861 7420 7265 7175 6972 6520 6f6e 6520  hat require one 
-0000d7c0: 6765 6f6d 6574 7279 7479 7065 2070 6572  geometrytype per
-0000d7d0: 206c 6179 6572 2e0d 0a20 2020 2020 2020   layer...       
-0000d7e0: 2020 2020 2044 6566 6175 6c74 7320 746f       Defaults to
-0000d7f0: 2046 616c 7365 2e0d 0a20 2020 2020 2020   False...       
-0000d800: 2061 7070 656e 6420 2862 6f6f 6c2c 206f   append (bool, o
-0000d810: 7074 696f 6e61 6c29 3a20 5472 7565 2074  ptional): True t
-0000d820: 6f20 6170 7065 6e64 2074 6f20 7468 6520  o append to the 
-0000d830: 6669 6c65 2f6c 6179 6572 2069 6620 6974  file/layer if it
-0000d840: 2065 7869 7374 7320 616c 7265 6164 792e   exists already.
-0000d850: 0d0a 2020 2020 2020 2020 2020 2020 4966  ..            If
-0000d860: 2069 7420 646f 6573 6e27 7420 6578 6973   it doesn't exis
-0000d870: 7420 7965 742c 2069 7420 6973 2063 7265  t yet, it is cre
-0000d880: 6174 6564 2e20 4465 6661 756c 7473 2074  ated. Defaults t
-0000d890: 6f20 4661 6c73 652e 0d0a 2020 2020 2020  o False...      
-0000d8a0: 2020 6170 7065 6e64 5f74 696d 656f 7574    append_timeout
-0000d8b0: 5f73 2028 696e 742c 206f 7074 696f 6e61  _s (int, optiona
-0000d8c0: 6c29 3a20 5468 6520 6d61 7869 6d75 6d20  l): The maximum 
-0000d8d0: 7469 6d65 6f75 7420 746f 2077 6169 7420  timeout to wait 
-0000d8e0: 7768 656e 2074 6865 0d0a 2020 2020 2020  when the..      
-0000d8f0: 2020 2020 2020 6f75 7470 7574 2066 696c        output fil
-0000d900: 6520 6973 2061 6c72 6561 6479 2062 6569  e is already bei
-0000d910: 6e67 2077 7269 7474 656e 2074 6f20 6279  ng written to by
-0000d920: 2061 6e6f 7468 6572 2070 726f 6365 7373   another process
-0000d930: 2e0d 0a20 2020 2020 2020 2020 2020 2044  ...            D
-0000d940: 6566 6175 6c74 7320 746f 2036 3030 2e0d  efaults to 600..
-0000d950: 0a20 2020 2020 2020 2069 6e64 6578 2028  .        index (
-0000d960: 626f 6f6c 2c20 6f70 7469 6f6e 616c 293a  bool, optional):
-0000d970: 2049 6620 5472 7565 2c20 7772 6974 6520   If True, write 
-0000d980: 696e 6465 7820 696e 746f 206f 6e65 206f  index into one o
-0000d990: 7220 6d6f 7265 2063 6f6c 756d 6e73 2028  r more columns (
-0000d9a0: 666f 720d 0a20 2020 2020 2020 2020 2020  for..           
-0000d9b0: 204d 756c 7469 496e 6465 7829 2e20 4e6f   MultiIndex). No
-0000d9c0: 6e65 2077 7269 7465 7320 7468 6520 696e  ne writes the in
-0000d9d0: 6465 7820 696e 746f 206f 6e65 206f 7220  dex into one or 
-0000d9e0: 6d6f 7265 2063 6f6c 756d 6e73 206f 6e6c  more columns onl
-0000d9f0: 7920 6966 2074 6865 0d0a 2020 2020 2020  y if the..      
-0000da00: 2020 2020 2020 696e 6465 7820 6973 206e        index is n
-0000da10: 616d 6564 2c20 6973 2061 204d 756c 7469  amed, is a Multi
-0000da20: 496e 6465 782c 206f 7220 6861 7320 6120  Index, or has a 
-0000da30: 6e6f 6e2d 696e 7465 6765 7220 6461 7461  non-integer data
-0000da40: 2074 7970 652e 0d0a 2020 2020 2020 2020   type...        
-0000da50: 2020 2020 4966 2046 616c 7365 2c20 6e6f      If False, no
-0000da60: 2069 6e64 6578 2069 7320 7772 6974 7465   index is writte
-0000da70: 6e2e 2044 6566 6175 6c74 7320 746f 204e  n. Defaults to N
-0000da80: 6f6e 652e 0d0a 2020 2020 2020 2020 6372  one...        cr
-0000da90: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
-0000daa0: 6578 2028 626f 6f6c 2c20 6f70 7469 6f6e  ex (bool, option
-0000dab0: 616c 293a 2054 7275 6520 746f 2066 6f72  al): True to for
-0000dac0: 6365 2063 7265 6174 696f 6e20 6f66 2073  ce creation of s
-0000dad0: 7061 7469 616c 2069 6e64 6578 2c0d 0a20  patial index,.. 
-0000dae0: 2020 2020 2020 2020 2020 2046 616c 7365             False
-0000daf0: 2074 6f20 6176 6f69 6420 6372 6561 7469   to avoid creati
-0000db00: 6f6e 2e20 4e6f 6e65 206c 6561 6473 2074  on. None leads t
-0000db10: 6f20 7468 6520 6465 6661 756c 7420 6265  o the default be
-0000db20: 6861 7669 6f75 7220 6f66 2067 6461 6c2e  haviour of gdal.
-0000db30: 0d0a 2020 2020 2020 2020 2020 2020 4465  ..            De
-0000db40: 6661 756c 7473 2074 6f20 5472 7565 2e0d  faults to True..
-0000db50: 0a0d 0a20 2020 2052 6169 7365 733a 0d0a  ...    Raises:..
-0000db60: 2020 2020 2020 2020 5661 6c75 6545 7272          ValueErr
-0000db70: 6f72 3a20 616e 2069 6e76 616c 6964 2070  or: an invalid p
-0000db80: 6172 616d 6574 6572 2076 616c 7565 2077  arameter value w
-0000db90: 6173 2070 6173 7365 642e 0d0a 2020 2020  as passed...    
-0000dba0: 2020 2020 5275 6e74 696d 6545 7272 6f72      RuntimeError
-0000dbb0: 3a20 7469 6d65 6f75 7420 7761 7320 7265  : timeout was re
-0000dbc0: 6163 6865 6420 7768 696c 6520 7472 7969  ached while tryi
-0000dbd0: 6e67 2074 6f20 6170 7065 6e64 2064 6174  ng to append dat
-0000dbe0: 6120 746f 2070 6174 682e 0d0a 2020 2020  a to path...    
-0000dbf0: 2222 220d 0a20 2020 2023 2043 6865 636b  """..    # Check
-0000dc00: 2069 6e70 7574 2070 6172 616d 6574 6572   input parameter
-0000dc10: 730d 0a20 2020 2023 202d 2d2d 2d2d 2d2d  s..    # -------
-0000dc20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0d  ---------------.
-0000dc30: 0a20 2020 2070 6174 6820 3d20 5061 7468  .    path = Path
-0000dc40: 2870 6174 6829 0d0a 0d0a 2020 2020 2320  (path)....    # 
-0000dc50: 4966 206e 6f20 6c61 7965 7220 6e61 6d65  If no layer name
-0000dc60: 2073 7065 6369 6669 6564 2c20 6465 7465   specified, dete
-0000dc70: 726d 696e 6520 6f6e 650d 0a20 2020 2069  rmine one..    i
-0000dc80: 6620 6c61 7965 7220 6973 204e 6f6e 653a  f layer is None:
-0000dc90: 0d0a 2020 2020 2020 2020 6966 2061 7070  ..        if app
-0000dca0: 656e 6420 616e 6420 7061 7468 2e65 7869  end and path.exi
-0000dcb0: 7374 7328 293a 0d0a 2020 2020 2020 2020  sts():..        
-0000dcc0: 2020 2020 6c61 7965 7220 3d20 6765 745f      layer = get_
-0000dcd0: 6f6e 6c79 5f6c 6179 6572 2870 6174 6829  only_layer(path)
-0000dce0: 0d0a 2020 2020 2020 2020 656c 7365 3a0d  ..        else:.
-0000dcf0: 0a20 2020 2020 2020 2020 2020 206c 6179  .            lay
-0000dd00: 6572 203d 2050 6174 6828 7061 7468 292e  er = Path(path).
-0000dd10: 7374 656d 0d0a 0d0a 2020 2020 2320 4966  stem....    # If
-0000dd20: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-0000dd30: 6f6d 6574 7279 7479 7065 2069 7320 6120  ometrytype is a 
-0000dd40: 7374 7269 6e67 2c20 6368 6563 6b20 6966  string, check if
-0000dd50: 2069 7420 6973 2061 2022 7374 616e 6461   it is a "standa
-0000dd60: 7264 2220 6765 6f6d 6574 7279 0d0a 2020  rd" geometry..  
-0000dd70: 2020 2320 7479 7065 2c20 6173 2047 4441    # type, as GDA
-0000dd80: 4c20 616c 736f 2073 7570 706f 7274 7320  L also supports 
-0000dd90: 7370 6563 6961 6c20 6765 6f6d 6574 7279  special geometry
-0000dda0: 2074 7970 6573 206c 696b 6520 2250 524f   types like "PRO
-0000ddb0: 4d4f 5445 5f54 4f5f 4d55 4c54 4922 0d0a  MOTE_TO_MULTI"..
-0000ddc0: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
-0000ddd0: 6528 666f 7263 655f 6f75 7470 7574 5f67  e(force_output_g
-0000dde0: 656f 6d65 7472 7974 7970 652c 2073 7472  eometrytype, str
-0000ddf0: 293a 0d0a 2020 2020 2020 2020 666f 7263  ):..        forc
-0000de00: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-0000de10: 7974 7970 6520 3d20 666f 7263 655f 6f75  ytype = force_ou
-0000de20: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
-0000de30: 652e 7570 7065 7228 290d 0a20 2020 2020  e.upper()..     
-0000de40: 2020 2074 7279 3a0d 0a20 2020 2020 2020     try:..       
-0000de50: 2020 2020 2023 2056 6572 6966 7920 6966       # Verify if
-0000de60: 2069 7420 6973 2061 2022 7374 616e 6461   it is a "standa
-0000de70: 7264 2220 6765 6f6d 6574 7279 2074 7970  rd" geometry typ
-0000de80: 652c 2061 7320 4744 414c 2061 6c73 6f20  e, as GDAL also 
-0000de90: 7375 7070 6f72 7473 0d0a 2020 2020 2020  supports..      
-0000dea0: 2020 2020 2020 2320 7370 6563 6961 6c20        # special 
-0000deb0: 6765 6f6d 6574 7279 2074 7970 6573 206c  geometry types l
-0000dec0: 696b 6520 2250 524f 4d4f 5445 5f54 4f5f  ike "PROMOTE_TO_
-0000ded0: 4d55 4c54 4922 0d0a 2020 2020 2020 2020  MULTI"..        
-0000dee0: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
-0000def0: 5f67 656f 6d65 7472 7974 7970 6520 3d20  _geometrytype = 
-0000df00: 4765 6f6d 6574 7279 5479 7065 5b66 6f72  GeometryType[for
-0000df10: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-0000df20: 7279 7479 7065 5d0d 0a20 2020 2020 2020  rytype]..       
-0000df30: 2065 7863 6570 7420 4578 6365 7074 696f   except Exceptio
-0000df40: 6e3a 0d0a 2020 2020 2020 2020 2020 2020  n:..            
-0000df50: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-0000df60: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-0000df70: 2020 2066 2255 6e73 7570 706f 7274 6564     f"Unsupported
-0000df80: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-0000df90: 6f6d 6574 7279 7479 7065 3a20 7b66 6f72  ometrytype: {for
-0000dfa0: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-0000dfb0: 7279 7479 7065 7d22 0d0a 2020 2020 2020  rytype}"..      
-0000dfc0: 2020 2020 2020 290d 0a20 2020 2069 6620        )..    if 
-0000dfd0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
-0000dfe0: 6d65 7472 7974 7970 6520 6973 206e 6f74  metrytype is not
-0000dff0: 204e 6f6e 6520 616e 6420 666f 7263 655f   None and force_
-0000e000: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-0000e010: 7970 652e 6973 5f6d 756c 7469 7479 7065  ype.is_multitype
-0000e020: 3a0d 0a20 2020 2020 2020 2066 6f72 6365  :..        force
-0000e030: 5f6d 756c 7469 7479 7065 203d 2054 7275  _multitype = Tru
-0000e040: 650d 0a0d 0a20 2020 2023 2049 6620 7468  e....    # If th
-0000e050: 6572 6520 6973 206e 6f20 6765 6f6d 6574  ere is no geomet
-0000e060: 7279 2063 6f6c 756d 6e20 696e 2074 6865  ry column in the
-0000e070: 2069 6e70 7574 2c20 616c 7761 7973 2075   input, always u
-0000e080: 7365 2066 696f 6e61 2c20 6173 2070 796f  se fiona, as pyo
-0000e090: 6772 696f 2064 6f65 736e 2774 0d0a 2020  grio doesn't..  
-0000e0a0: 2020 2320 7375 7070 6f72 7420 7468 6174    # support that
-0000e0b0: 2079 6574 2061 7420 7469 6d65 206f 6620   yet at time of 
-0000e0c0: 7772 6974 696e 672e 0d0a 2020 2020 6966  writing...    if
-0000e0d0: 2069 7369 6e73 7461 6e63 6528 6764 662c   isinstance(gdf,
-0000e0e0: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
-0000e0f0: 6529 2069 7320 4661 6c73 6520 6f72 2028  e) is False or (
-0000e100: 0d0a 2020 2020 2020 2020 6973 696e 7374  ..        isinst
-0000e110: 616e 6365 2867 6466 2c20 6770 642e 4765  ance(gdf, gpd.Ge
-0000e120: 6f44 6174 6146 7261 6d65 2920 616e 6420  oDataFrame) and 
-0000e130: 2267 656f 6d65 7472 7922 206e 6f74 2069  "geometry" not i
-0000e140: 6e20 6764 662e 636f 6c75 6d6e 730d 0a20  n gdf.columns.. 
-0000e150: 2020 2029 3a0d 0a20 2020 2020 2020 2065     ):..        e
-0000e160: 6e67 696e 6520 3d20 2266 696f 6e61 220d  ngine = "fiona".
-0000e170: 0a20 2020 2020 2020 2063 7265 6174 655f  .        create_
-0000e180: 7370 6174 6961 6c5f 696e 6465 7820 3d20  spatial_index = 
-0000e190: 4661 6c73 650d 0a20 2020 2065 6c73 653a  False..    else:
-0000e1a0: 0d0a 2020 2020 2020 2020 656e 6769 6e65  ..        engine
-0000e1b0: 203d 205f 6765 745f 656e 6769 6e65 2829   = _get_engine()
-0000e1c0: 0d0a 0d0a 2020 2020 2320 4e6f 7720 7772  ....    # Now wr
-0000e1d0: 6974 6520 7769 7468 2074 6865 2063 6f72  ite with the cor
-0000e1e0: 7265 6374 2065 6e67 696e 650d 0a20 2020  rect engine..   
-0000e1f0: 2069 6620 656e 6769 6e65 203d 3d20 2270   if engine == "p
-0000e200: 796f 6772 696f 223a 0d0a 2020 2020 2020  yogrio":..      
-0000e210: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
-0000e220: 6e63 6528 6764 662c 2067 7064 2e47 656f  nce(gdf, gpd.Geo
-0000e230: 4461 7461 4672 616d 6529 0d0a 2020 2020  DataFrame)..    
-0000e240: 2020 2020 7265 7475 726e 205f 746f 5f66      return _to_f
-0000e250: 696c 655f 7079 6f67 7269 6f28 0d0a 2020  ile_pyogrio(..  
-0000e260: 2020 2020 2020 2020 2020 6764 663d 6764            gdf=gd
-0000e270: 662c 0d0a 2020 2020 2020 2020 2020 2020  f,..            
-0000e280: 7061 7468 3d70 6174 682c 0d0a 2020 2020  path=path,..    
-0000e290: 2020 2020 2020 2020 6c61 7965 723d 6c61          layer=la
-0000e2a0: 7965 722c 0d0a 2020 2020 2020 2020 2020  yer,..          
-0000e2b0: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
-0000e2c0: 656f 6d65 7472 7974 7970 653d 666f 7263  eometrytype=forc
-0000e2d0: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-0000e2e0: 7974 7970 652c 0d0a 2020 2020 2020 2020  ytype,..        
-0000e2f0: 2020 2020 666f 7263 655f 6d75 6c74 6974      force_multit
-0000e300: 7970 653d 666f 7263 655f 6d75 6c74 6974  ype=force_multit
-0000e310: 7970 652c 0d0a 2020 2020 2020 2020 2020  ype,..          
-0000e320: 2020 6170 7065 6e64 3d61 7070 656e 642c    append=append,
-0000e330: 0d0a 2020 2020 2020 2020 2020 2020 6170  ..            ap
-0000e340: 7065 6e64 5f74 696d 656f 7574 5f73 3d61  pend_timeout_s=a
-0000e350: 7070 656e 645f 7469 6d65 6f75 745f 732c  ppend_timeout_s,
-0000e360: 0d0a 2020 2020 2020 2020 2020 2020 696e  ..            in
-0000e370: 6465 783d 696e 6465 782c 0d0a 2020 2020  dex=index,..    
-0000e380: 2020 2020 2020 2020 6372 6561 7465 5f73          create_s
-0000e390: 7061 7469 616c 5f69 6e64 6578 3d63 7265  patial_index=cre
-0000e3a0: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
-0000e3b0: 782c 0d0a 2020 2020 2020 2020 290d 0a20  x,..        ).. 
-0000e3c0: 2020 2065 6c69 6620 656e 6769 6e65 203d     elif engine =
-0000e3d0: 3d20 2266 696f 6e61 223a 0d0a 2020 2020  = "fiona":..    
-0000e3e0: 2020 2020 7265 7475 726e 205f 746f 5f66      return _to_f
-0000e3f0: 696c 655f 6669 6f6e 6128 0d0a 2020 2020  ile_fiona(..    
-0000e400: 2020 2020 2020 2020 6764 663d 6764 662c          gdf=gdf,
-0000e410: 0d0a 2020 2020 2020 2020 2020 2020 7061  ..            pa
-0000e420: 7468 3d70 6174 682c 0d0a 2020 2020 2020  th=path,..      
-0000e430: 2020 2020 2020 6c61 7965 723d 6c61 7965        layer=laye
-0000e440: 722c 0d0a 2020 2020 2020 2020 2020 2020  r,..            
-0000e450: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
-0000e460: 6d65 7472 7974 7970 653d 666f 7263 655f  metrytype=force_
-0000e470: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-0000e480: 7970 652c 0d0a 2020 2020 2020 2020 2020  ype,..          
-0000e490: 2020 666f 7263 655f 6d75 6c74 6974 7970    force_multityp
-0000e4a0: 653d 666f 7263 655f 6d75 6c74 6974 7970  e=force_multityp
-0000e4b0: 652c 0d0a 2020 2020 2020 2020 2020 2020  e,..            
-0000e4c0: 6170 7065 6e64 3d61 7070 656e 642c 0d0a  append=append,..
-0000e4d0: 2020 2020 2020 2020 2020 2020 6170 7065              appe
-0000e4e0: 6e64 5f74 696d 656f 7574 5f73 3d61 7070  nd_timeout_s=app
-0000e4f0: 656e 645f 7469 6d65 6f75 745f 732c 0d0a  end_timeout_s,..
-0000e500: 2020 2020 2020 2020 2020 2020 696e 6465              inde
-0000e510: 783d 696e 6465 782c 0d0a 2020 2020 2020  x=index,..      
-0000e520: 2020 2020 2020 6372 6561 7465 5f73 7061        create_spa
-0000e530: 7469 616c 5f69 6e64 6578 3d63 7265 6174  tial_index=creat
-0000e540: 655f 7370 6174 6961 6c5f 696e 6465 782c  e_spatial_index,
-0000e550: 0d0a 2020 2020 2020 2020 290d 0a20 2020  ..        )..   
-0000e560: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-0000e570: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-0000e580: 2866 2255 6e73 7570 706f 7274 6564 2065  (f"Unsupported e
-0000e590: 6e67 696e 653a 207b 656e 6769 6e65 7d22  ngine: {engine}"
-0000e5a0: 290d 0a0d 0a0d 0a64 6566 205f 6765 745f  )......def _get_
-0000e5b0: 656e 6769 6e65 2829 3a0d 0a20 2020 2072  engine():..    r
-0000e5c0: 6574 7572 6e20 6f73 2e65 6e76 6972 6f6e  eturn os.environ
-0000e5d0: 2e67 6574 2822 4746 4f5f 494f 5f45 4e47  .get("GFO_IO_ENG
-0000e5e0: 494e 4522 2c20 2270 796f 6772 696f 2229  INE", "pyogrio")
-0000e5f0: 0d0a 0d0a 0d0a 6465 6620 5f74 6f5f 6669  ......def _to_fi
-0000e600: 6c65 5f66 696f 6e61 280d 0a20 2020 2067  le_fiona(..    g
-0000e610: 6466 3a20 556e 696f 6e5b 7064 2e44 6174  df: Union[pd.Dat
-0000e620: 6146 7261 6d65 2c20 6770 642e 4765 6f44  aFrame, gpd.GeoD
-0000e630: 6174 6146 7261 6d65 5d2c 0d0a 2020 2020  ataFrame],..    
-0000e640: 7061 7468 3a20 5061 7468 2c0d 0a20 2020  path: Path,..   
-0000e650: 206c 6179 6572 3a20 7374 722c 0d0a 2020   layer: str,..  
-0000e660: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
-0000e670: 656f 6d65 7472 7974 7970 653a 2055 6e69  eometrytype: Uni
-0000e680: 6f6e 5b47 656f 6d65 7472 7954 7970 652c  on[GeometryType,
-0000e690: 2073 7472 2c20 4e6f 6e65 5d20 3d20 4e6f   str, None] = No
-0000e6a0: 6e65 2c0d 0a20 2020 2066 6f72 6365 5f6d  ne,..    force_m
-0000e6b0: 756c 7469 7479 7065 3a20 626f 6f6c 203d  ultitype: bool =
-0000e6c0: 2046 616c 7365 2c0d 0a20 2020 2061 7070   False,..    app
-0000e6d0: 656e 643a 2062 6f6f 6c20 3d20 4661 6c73  end: bool = Fals
-0000e6e0: 652c 0d0a 2020 2020 6170 7065 6e64 5f74  e,..    append_t
-0000e6f0: 696d 656f 7574 5f73 3a20 696e 7420 3d20  imeout_s: int = 
-0000e700: 3630 302c 0d0a 2020 2020 696e 6465 783a  600,..    index:
-0000e710: 204f 7074 696f 6e61 6c5b 626f 6f6c 5d20   Optional[bool] 
-0000e720: 3d20 4e6f 6e65 2c0d 0a20 2020 2063 7265  = None,..    cre
-0000e730: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
-0000e740: 783a 204f 7074 696f 6e61 6c5b 626f 6f6c  x: Optional[bool
-0000e750: 5d20 3d20 5472 7565 2c0d 0a29 3a0d 0a20  ] = True,..):.. 
-0000e760: 2020 2022 2222 0d0a 2020 2020 5772 6974     """..    Writ
-0000e770: 6573 2061 2070 616e 6461 7320 6461 7461  es a pandas data
-0000e780: 6672 616d 6520 746f 2066 696c 6520 7573  frame to file us
-0000e790: 696e 6720 6669 6f6e 612e 0d0a 2020 2020  ing fiona...    
-0000e7a0: 2222 220d 0a20 2020 2023 2053 6861 7065  """..    # Shape
-0000e7b0: 6669 6c65 2064 6f65 736e 2774 2073 7570  file doesn't sup
-0000e7c0: 706f 7274 2064 6174 6574 696d 6520 636f  port datetime co
-0000e7d0: 6c75 6d6e 732c 2073 6f20 6669 7273 7420  lumns, so first 
-0000e7e0: 6361 7374 2074 6865 6d20 746f 2073 7472  cast them to str
-0000e7f0: 696e 670d 0a20 2020 2069 6620 7061 7468  ing..    if path
-0000e800: 2e73 7566 6669 782e 6c6f 7765 7228 2920  .suffix.lower() 
-0000e810: 696e 205b 222e 7368 7022 2c20 222e 6462  in [".shp", ".db
-0000e820: 6622 5d3a 0d0a 2020 2020 2020 2020 6764  f"]:..        gd
-0000e830: 6620 3d20 6764 662e 636f 7079 2829 0d0a  f = gdf.copy()..
-0000e840: 2020 2020 2020 2020 2320 436f 6c75 6d6e          # Column
-0000e850: 7320 7468 6174 2068 6176 6520 6120 7072  s that have a pr
-0000e860: 6f70 6572 2064 6174 6574 696d 6536 3420  oper datetime64 
-0000e870: 7479 7065 0d0a 2020 2020 2020 2020 666f  type..        fo
-0000e880: 7220 636f 6c75 6d6e 2069 6e20 6764 662e  r column in gdf.
-0000e890: 7365 6c65 6374 5f64 7479 7065 7328 696e  select_dtypes(in
-0000e8a0: 636c 7564 653d 5b22 6461 7465 7469 6d65  clude=["datetime
-0000e8b0: 3634 225d 293a 0d0a 2020 2020 2020 2020  64"]):..        
-0000e8c0: 2020 2020 6764 665b 636f 6c75 6d6e 5d20      gdf[column] 
-0000e8d0: 3d20 6764 665b 636f 6c75 6d6e 5d2e 6173  = gdf[column].as
-0000e8e0: 7479 7065 2873 7472 290d 0a0d 0a20 2020  type(str)....   
-0000e8f0: 2020 2020 2023 2043 6f6c 756d 6e73 2074       # Columns t
-0000e900: 6861 7420 6172 6520 6f66 206f 626a 6563  hat are of objec
-0000e910: 7420 7479 7065 2c20 6275 7420 636f 6e74  t type, but cont
-0000e920: 6169 6e20 6461 7465 7469 6d65 2e64 6174  ain datetime.dat
-0000e930: 6520 6f72 2064 6174 6574 696d 652e 6461  e or datetime.da
-0000e940: 7465 0d0a 2020 2020 2020 2020 2320 7479  te..        # ty
-0000e950: 7065 2064 6174 6120 696e 7374 6561 6420  pe data instead 
-0000e960: 6f66 2073 7472 696e 6773 2e0d 0a20 2020  of strings...   
-0000e970: 2020 2020 2069 6620 6c65 6e28 6764 6629       if len(gdf)
-0000e980: 203e 2030 3a0d 0a20 2020 2020 2020 2020   > 0:..         
-0000e990: 2020 2066 6f72 2063 6f6c 756d 6e20 696e     for column in
-0000e9a0: 2067 6466 2e73 656c 6563 745f 6474 7970   gdf.select_dtyp
-0000e9b0: 6573 2869 6e63 6c75 6465 3d5b 226f 626a  es(include=["obj
-0000e9c0: 6563 7422 5d29 3a0d 0a20 2020 2020 2020  ect"]):..       
-0000e9d0: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
-0000e9e0: 7374 616e 6365 2867 6466 5b63 6f6c 756d  stance(gdf[colum
-0000e9f0: 6e5d 5b30 5d2c 2028 6461 7465 7469 6d65  n][0], (datetime
-0000ea00: 2e64 6174 652c 2064 6174 6574 696d 652e  .date, datetime.
-0000ea10: 6461 7465 7469 6d65 2929 3a0d 0a20 2020  datetime)):..   
-0000ea20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ea30: 2067 6466 5b63 6f6c 756d 6e5d 203d 2067   gdf[column] = g
-0000ea40: 6466 5b63 6f6c 756d 6e5d 2e61 7374 7970  df[column].astyp
-0000ea50: 6528 7374 7229 0d0a 0d0a 2020 2020 2320  e(str)....    # 
-0000ea60: 4861 6e64 6c65 2073 6f6d 6520 7370 6563  Handle some spec
-0000ea70: 6966 6963 2063 6173 6573 2077 6865 7265  ific cases where
-0000ea80: 2074 6865 2066 696c 6520 7363 6865 6d61   the file schema
-0000ea90: 206e 6565 6473 2074 6f20 6265 206d 616e   needs to be man
-0000eaa0: 6970 756c 6174 6564 2e0d 0a20 2020 2073  ipulated...    s
-0000eab0: 6368 656d 6120 3d20 4e6f 6e65 0d0a 2020  chema = None..  
-0000eac0: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-0000ead0: 6764 662c 2067 7064 2e47 656f 4461 7461  gdf, gpd.GeoData
-0000eae0: 4672 616d 6529 2069 7320 4661 6c73 6520  Frame) is False 
-0000eaf0: 6f72 2028 0d0a 2020 2020 2020 2020 6973  or (..        is
-0000eb00: 696e 7374 616e 6365 2867 6466 2c20 6770  instance(gdf, gp
-0000eb10: 642e 4765 6f44 6174 6146 7261 6d65 2920  d.GeoDataFrame) 
-0000eb20: 616e 6420 2267 656f 6d65 7472 7922 206e  and "geometry" n
-0000eb30: 6f74 2069 6e20 6764 662e 636f 6c75 6d6e  ot in gdf.column
-0000eb40: 730d 0a20 2020 2029 3a0d 0a20 2020 2020  s..    ):..     
-0000eb50: 2020 2023 204e 6f20 6765 6f6d 6574 7279     # No geometry
-0000eb60: 2c20 736f 2070 7265 7061 7265 2074 6f20  , so prepare to 
-0000eb70: 6265 2077 7269 7474 656e 2061 7320 6174  be written as at
-0000eb80: 7472 6962 7574 6520 7461 626c 653a 2061  tribute table: a
-0000eb90: 6464 2067 656f 6d65 7472 7920 636f 6c75  dd geometry colu
-0000eba0: 6d6e 0d0a 2020 2020 2020 2020 2320 7769  mn..        # wi
-0000ebb0: 7468 204e 6f6e 6520 6765 6f6d 6574 7279  th None geometry
-0000ebc0: 2074 7970 6520 696e 2073 6368 656d 610d   type in schema.
-0000ebd0: 0a20 2020 2020 2020 2023 2057 6974 6820  .        # With 
-0000ebe0: 6f6c 6465 7220 7665 7273 696f 6e73 206f  older versions o
-0000ebf0: 6620 7061 6e64 6173 2061 6e64 2f6f 7220  f pandas and/or 
-0000ec00: 6765 6f70 616e 6461 732c 2077 6974 686f  geopandas, witho
-0000ec10: 7574 2074 6865 2063 6f70 7920 7468 6520  ut the copy the 
-0000ec20: 6163 7475 616c 0d0a 2020 2020 2020 2020  actual..        
-0000ec30: 2320 6764 6620 6973 2063 6861 6e67 6564  # gdf is changed
-0000ec40: 2061 6e64 2072 6574 7572 6e65 6420 7768   and returned wh
-0000ec50: 6963 6820 6973 6e27 7420 4f4b 2e0d 0a20  ich isn't OK... 
-0000ec60: 2020 2020 2020 2023 2054 6869 7320 6361         # This ca
-0000ec70: 7573 6564 2074 6573 745f 746f 5f66 696c  used test_to_fil
-0000ec80: 6520 7769 7468 202e 6373 7620 746f 2066  e with .csv to f
-0000ec90: 6169 6c20 666f 7220 7468 6520 226d 696e  ail for the "min
-0000eca0: 696d 616c 2220 4349 2065 6e76 2e0d 0a20  imal" CI env... 
-0000ecb0: 2020 2020 2020 2067 6466 203d 2067 7064         gdf = gpd
-0000ecc0: 2e47 656f 4461 7461 4672 616d 6528 6764  .GeoDataFrame(gd
-0000ecd0: 662e 636f 7079 2829 2c20 6765 6f6d 6574  f.copy(), geomet
-0000ece0: 7279 3d5b 4e6f 6e65 2066 6f72 2069 2069  ry=[None for i i
-0000ecf0: 6e20 6764 662e 696e 6465 785d 290d 0a0d  n gdf.index])...
-0000ed00: 0a20 2020 2020 2020 2073 6368 656d 6120  .        schema 
-0000ed10: 3d20 6770 645f 696f 5f66 696c 652e 696e  = gpd_io_file.in
-0000ed20: 6665 725f 7363 6865 6d61 2867 6466 290d  fer_schema(gdf).
-0000ed30: 0a20 2020 2020 2020 2073 6368 656d 615b  .        schema[
-0000ed40: 2267 656f 6d65 7472 7922 5d20 3d20 224e  "geometry"] = "N
-0000ed50: 6f6e 6522 0d0a 2020 2020 656c 6966 2028  one"..    elif (
-0000ed60: 0d0a 2020 2020 2020 2020 6c65 6e28 6764  ..        len(gd
-0000ed70: 6629 203d 3d20 300d 0a20 2020 2020 2020  f) == 0..       
-0000ed80: 2061 6e64 2066 6f72 6365 5f6f 7574 7075   and force_outpu
-0000ed90: 745f 6765 6f6d 6574 7279 7479 7065 2069  t_geometrytype i
-0000eda0: 7320 6e6f 7420 4e6f 6e65 0d0a 2020 2020  s not None..    
-0000edb0: 2020 2020 616e 6420 6973 696e 7374 616e      and isinstan
-0000edc0: 6365 2866 6f72 6365 5f6f 7574 7075 745f  ce(force_output_
-0000edd0: 6765 6f6d 6574 7279 7479 7065 2c20 4765  geometrytype, Ge
-0000ede0: 6f6d 6574 7279 5479 7065 290d 0a20 2020  ometryType)..   
-0000edf0: 2029 3a0d 0a20 2020 2020 2020 2023 2049   ):..        # I
-0000ee00: 6620 7468 6520 6764 6620 6973 2065 6d70  f the gdf is emp
-0000ee10: 7479 2062 7574 2061 2067 656f 6d65 7472  ty but a geometr
-0000ee20: 7920 7479 7065 2069 7320 7370 6563 6966  y type is specif
-0000ee30: 6965 642c 2075 7365 2074 6865 2073 7065  ied, use the spe
-0000ee40: 6369 6669 6564 2074 7970 650d 0a20 2020  cified type..   
-0000ee50: 2020 2020 2073 6368 656d 6120 3d20 6770       schema = gp
-0000ee60: 645f 696f 5f66 696c 652e 696e 6665 725f  d_io_file.infer_
-0000ee70: 7363 6865 6d61 2867 6466 290d 0a20 2020  schema(gdf)..   
-0000ee80: 2020 2020 2023 2047 656f 6d65 7472 7920       # Geometry 
-0000ee90: 7479 7065 206d 7573 7420 6265 2069 6e20  type must be in 
-0000eea0: 6361 6d65 6c63 6173 6520 666f 7220 6669  camelcase for fi
-0000eeb0: 6f6e 610d 0a20 2020 2020 2020 2073 6368  ona..        sch
-0000eec0: 656d 615b 2267 656f 6d65 7472 7922 5d20  ema["geometry"] 
-0000eed0: 3d20 666f 7263 655f 6f75 7470 7574 5f67  = force_output_g
-0000eee0: 656f 6d65 7472 7974 7970 652e 6e61 6d65  eometrytype.name
-0000eef0: 5f63 616d 656c 6361 7365 0d0a 2020 2020  _camelcase..    
-0000ef00: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
-0000ef10: 6528 6764 662c 2067 7064 2e47 656f 4461  e(gdf, gpd.GeoDa
-0000ef20: 7461 4672 616d 6529 0d0a 0d0a 2020 2020  taFrame)....    
-0000ef30: 2320 436f 6e76 6572 7420 666f 7263 655f  # Convert force_
-0000ef40: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-0000ef50: 7970 6520 746f 2073 7472 696e 6720 746f  ype to string to
-0000ef60: 2073 696d 706c 6966 7920 636f 6465 2061   simplify code a
-0000ef70: 6674 6572 7761 7264 730d 0a20 2020 2069  fterwards..    i
-0000ef80: 6620 6973 696e 7374 616e 6365 2866 6f72  f isinstance(for
-0000ef90: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-0000efa0: 7279 7479 7065 2c20 4765 6f6d 6574 7279  rytype, Geometry
-0000efb0: 5479 7065 293a 0d0a 2020 2020 2020 2020  Type):..        
-0000efc0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
-0000efd0: 6d65 7472 7974 7970 6520 3d20 666f 7263  metrytype = forc
-0000efe0: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-0000eff0: 7974 7970 652e 6e61 6d65 0d0a 0d0a 2020  ytype.name....  
-0000f000: 2020 2320 4e6f 2074 6865 2066 696c 6520    # No the file 
-0000f010: 6361 6e20 6163 7475 616c 6c79 2062 6520  can actually be 
-0000f020: 7772 6974 7465 6e0d 0a20 2020 2023 202d  written..    # -
-0000f030: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000f040: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000f050: 2d2d 0d0a 2020 2020 2320 4669 6f6e 6120  --..    # Fiona 
-0000f060: 646f 6573 6e27 7420 7375 7070 6f72 7420  doesn't support 
-0000f070: 7468 6520 6f75 7470 7574 2067 656f 6d65  the output geome
-0000f080: 7472 7974 7970 6520 7061 7261 6d65 7465  trytype paramete
-0000f090: 7220 6173 2075 7365 6420 696e 2067 6461  r as used in gda
-0000f0a0: 6c2c 2073 6f20 6173 2061 0d0a 2020 2020  l, so as a..    
-0000f0b0: 2320 6c69 6768 7477 6569 6768 7420 696d  # lightweight im
-0000f0c0: 706c 656d 656e 7461 7469 6f6e 206a 7573  plementation jus
-0000f0d0: 7420 7365 7420 666f 7263 650d 0a20 2020  t set force..   
-0000f0e0: 2064 6566 2077 7269 7465 5f74 6f5f 6669   def write_to_fi
-0000f0f0: 6c65 280d 0a20 2020 2020 2020 2067 6466  le(..        gdf
-0000f100: 3a20 6770 642e 4765 6f44 6174 6146 7261  : gpd.GeoDataFra
-0000f110: 6d65 2c0d 0a20 2020 2020 2020 2070 6174  me,..        pat
-0000f120: 683a 2050 6174 682c 0d0a 2020 2020 2020  h: Path,..      
-0000f130: 2020 6c61 7965 723a 2073 7472 2c0d 0a20    layer: str,.. 
-0000f140: 2020 2020 2020 2069 6e64 6578 3a20 4f70         index: Op
-0000f150: 7469 6f6e 616c 5b62 6f6f 6c5d 203d 204e  tional[bool] = N
-0000f160: 6f6e 652c 0d0a 2020 2020 2020 2020 666f  one,..        fo
-0000f170: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-0000f180: 7472 7974 7970 653a 204f 7074 696f 6e61  trytype: Optiona
-0000f190: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
-0000f1a0: 2020 2020 2020 2020 666f 7263 655f 6d75          force_mu
-0000f1b0: 6c74 6974 7970 653a 2062 6f6f 6c20 3d20  ltitype: bool = 
-0000f1c0: 4661 6c73 652c 0d0a 2020 2020 2020 2020  False,..        
-0000f1d0: 6170 7065 6e64 3a20 626f 6f6c 203d 2046  append: bool = F
-0000f1e0: 616c 7365 2c0d 0a20 2020 2020 2020 2073  alse,..        s
-0000f1f0: 6368 656d 613a 204f 7074 696f 6e61 6c5b  chema: Optional[
-0000f200: 6469 6374 5d20 3d20 4e6f 6e65 2c0d 0a20  dict] = None,.. 
-0000f210: 2020 2020 2020 2063 7265 6174 655f 7370         create_sp
-0000f220: 6174 6961 6c5f 696e 6465 783a 204f 7074  atial_index: Opt
-0000f230: 696f 6e61 6c5b 626f 6f6c 5d20 3d20 5472  ional[bool] = Tr
-0000f240: 7565 2c0d 0a20 2020 2029 3a0d 0a20 2020  ue,..    ):..   
-0000f250: 2020 2020 2023 2050 7265 7061 7265 2061       # Prepare a
-0000f260: 7267 7320 666f 7220 746f 5f66 696c 650d  rgs for to_file.
-0000f270: 0a20 2020 2020 2020 2069 6620 6170 7065  .        if appe
-0000f280: 6e64 2069 7320 5472 7565 3a0d 0a20 2020  nd is True:..   
-0000f290: 2020 2020 2020 2020 2069 6620 7061 7468           if path
-0000f2a0: 2e65 7869 7374 7328 293a 0d0a 2020 2020  .exists():..    
-0000f2b0: 2020 2020 2020 2020 2020 2020 6d6f 6465              mode
-0000f2c0: 203d 2022 6122 0d0a 2020 2020 2020 2020   = "a"..        
-0000f2d0: 2020 2020 656c 7365 3a0d 0a20 2020 2020      else:..     
-0000f2e0: 2020 2020 2020 2020 2020 206d 6f64 6520             mode 
-0000f2f0: 3d20 2277 220d 0a20 2020 2020 2020 2065  = "w"..        e
-0000f300: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-0000f310: 2020 6d6f 6465 203d 2022 7722 0d0a 0d0a    mode = "w"....
-0000f320: 2020 2020 2020 2020 6b77 6172 6773 3a20          kwargs: 
-0000f330: 4469 6374 5b73 7472 2c20 416e 795d 203d  Dict[str, Any] =
-0000f340: 207b 7d0d 0a20 2020 2020 2020 206b 7761   {}..        kwa
-0000f350: 7267 735b 2265 6e67 696e 6522 5d20 3d20  rgs["engine"] = 
-0000f360: 2266 696f 6e61 220d 0a20 2020 2020 2020  "fiona"..       
-0000f370: 206b 7761 7267 735b 226d 6f64 6522 5d20   kwargs["mode"] 
-0000f380: 3d20 6d6f 6465 0d0a 2020 2020 2020 2020  = mode..        
-0000f390: 6472 6976 6572 6e61 6d65 203d 205f 6765  drivername = _ge
-0000f3a0: 6f66 696c 6569 6e66 6f2e 6765 745f 6472  ofileinfo.get_dr
-0000f3b0: 6976 6572 2870 6174 6829 0d0a 2020 2020  iver(path)..    
-0000f3c0: 2020 2020 6b77 6172 6773 5b22 6472 6976      kwargs["driv
-0000f3d0: 6572 225d 203d 2064 7269 7665 726e 616d  er"] = drivernam
-0000f3e0: 650d 0a20 2020 2020 2020 206b 7761 7267  e..        kwarg
-0000f3f0: 735b 2269 6e64 6578 225d 203d 2069 6e64  s["index"] = ind
-0000f400: 6578 0d0a 2020 2020 2020 2020 6966 2063  ex..        if c
-0000f410: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
-0000f420: 6465 7820 6973 206e 6f74 204e 6f6e 653a  dex is not None:
-0000f430: 0d0a 2020 2020 2020 2020 2020 2020 6b77  ..            kw
-0000f440: 6172 6773 5b22 5350 4154 4941 4c5f 494e  args["SPATIAL_IN
-0000f450: 4445 5822 5d20 3d20 6372 6561 7465 5f73  DEX"] = create_s
-0000f460: 7061 7469 616c 5f69 6e64 6578 0d0a 2020  patial_index..  
-0000f470: 2020 2020 2020 6966 2066 6f72 6365 5f6f        if force_o
-0000f480: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-0000f490: 7065 2069 7320 6e6f 7420 4e6f 6e65 3a0d  pe is not None:.
-0000f4a0: 0a20 2020 2020 2020 2020 2020 206b 7761  .            kwa
-0000f4b0: 7267 735b 2267 656f 6d65 7472 7974 7970  rgs["geometrytyp
-0000f4c0: 6522 5d20 3d20 666f 7263 655f 6f75 7470  e"] = force_outp
-0000f4d0: 7574 5f67 656f 6d65 7472 7974 7970 650d  ut_geometrytype.
-0000f4e0: 0a20 2020 2020 2020 2069 6620 7363 6865  .        if sche
-0000f4f0: 6d61 2069 7320 6e6f 7420 4e6f 6e65 3a0d  ma is not None:.
-0000f500: 0a20 2020 2020 2020 2020 2020 206b 7761  .            kwa
-0000f510: 7267 735b 2273 6368 656d 6122 5d20 3d20  rgs["schema"] = 
-0000f520: 7363 6865 6d61 0d0a 0d0a 2020 2020 2020  schema....      
-0000f530: 2020 2320 4e6f 7720 7765 2063 616e 2077    # Now we can w
-0000f540: 7269 7465 0d0a 2020 2020 2020 2020 6966  rite..        if
-0000f550: 2064 7269 7665 726e 616d 6520 3d3d 2022   drivername == "
-0000f560: 4750 4b47 223a 0d0a 2020 2020 2020 2020  GPKG":..        
-0000f570: 2020 2020 2320 5472 7920 746f 2068 6172      # Try to har
-0000f580: 6d6f 6e69 7a65 2074 6865 2067 656f 6d65  monize the geome
-0000f590: 7472 7974 7970 6520 746f 206f 6e65 2028  trytype to one (
-0000f5a0: 6d75 6c74 6929 7479 7065 2c20 6173 2047  multi)type, as G
-0000f5b0: 504b 470d 0a20 2020 2020 2020 2020 2020  PKG..           
-0000f5c0: 2023 2064 6f65 736e 2774 206c 696b 6520   # doesn't like 
-0000f5d0: 3e20 3120 7479 7065 2069 6e20 6120 6c61  > 1 type in a la
-0000f5e0: 7965 720d 0a20 2020 2020 2020 2020 2020  yer..           
-0000f5f0: 2069 6620 7363 6865 6d61 2069 7320 4e6f   if schema is No
-0000f600: 6e65 206f 7220 286c 656e 2867 6466 2920  ne or (len(gdf) 
-0000f610: 3e20 3020 616e 6420 7363 6865 6d61 5b22  > 0 and schema["
-0000f620: 6765 6f6d 6574 7279 225d 2021 3d20 224e  geometry"] != "N
-0000f630: 6f6e 6522 293a 0d0a 2020 2020 2020 2020  one"):..        
-0000f640: 2020 2020 2020 2020 6764 6620 3d20 6764          gdf = gd
-0000f650: 662e 636f 7079 2829 0d0a 2020 2020 2020  f.copy()..      
-0000f660: 2020 2020 2020 2020 2020 6764 662e 6765            gdf.ge
-0000f670: 6f6d 6574 7279 203d 205f 6765 6f73 6572  ometry = _geoser
-0000f680: 6965 735f 7574 696c 2e68 6172 6d6f 6e69  ies_util.harmoni
-0000f690: 7a65 5f67 656f 6d65 7472 7974 7970 6573  ze_geometrytypes
-0000f6a0: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-0000f6b0: 2020 2020 2020 2067 6466 2e67 656f 6d65         gdf.geome
-0000f6c0: 7472 792c 2066 6f72 6365 5f6d 756c 7469  try, force_multi
-0000f6d0: 7479 7065 3d66 6f72 6365 5f6d 756c 7469  type=force_multi
-0000f6e0: 7479 7065 0d0a 2020 2020 2020 2020 2020  type..          
-0000f6f0: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-0000f700: 2020 2020 2067 6466 2e74 6f5f 6669 6c65       gdf.to_file
-0000f710: 2873 7472 2870 6174 6829 2c20 6c61 7965  (str(path), laye
-0000f720: 723d 6c61 7965 722c 202a 2a6b 7761 7267  r=layer, **kwarg
-0000f730: 7329 0d0a 2020 2020 2020 2020 656c 7365  s)..        else
-0000f740: 3a0d 0a20 2020 2020 2020 2020 2020 2067  :..            g
-0000f750: 6466 2e74 6f5f 6669 6c65 2873 7472 2870  df.to_file(str(p
-0000f760: 6174 6829 2c20 6c61 7965 723d 6c61 7965  ath), layer=laye
-0000f770: 722c 202a 2a6b 7761 7267 7329 0d0a 0d0a  r, **kwargs)....
-0000f780: 2020 2020 2320 4966 206e 6f20 6170 7065      # If no appe
-0000f790: 6e64 2c20 6a75 7374 2077 7269 7465 2074  nd, just write t
-0000f7a0: 6f20 6f75 7470 7574 2070 6174 680d 0a20  o output path.. 
-0000f7b0: 2020 2069 6620 6e6f 7420 6170 7065 6e64     if not append
-0000f7c0: 3a0d 0a20 2020 2020 2020 2077 7269 7465  :..        write
-0000f7d0: 5f74 6f5f 6669 6c65 280d 0a20 2020 2020  _to_file(..     
-0000f7e0: 2020 2020 2020 2067 6466 3d67 6466 2c0d         gdf=gdf,.
-0000f7f0: 0a20 2020 2020 2020 2020 2020 2070 6174  .            pat
-0000f800: 683d 7061 7468 2c0d 0a20 2020 2020 2020  h=path,..       
-0000f810: 2020 2020 206c 6179 6572 3d6c 6179 6572       layer=layer
-0000f820: 2c0d 0a20 2020 2020 2020 2020 2020 2069  ,..            i
-0000f830: 6e64 6578 3d69 6e64 6578 2c0d 0a20 2020  ndex=index,..   
-0000f840: 2020 2020 2020 2020 2066 6f72 6365 5f6f           force_o
-0000f850: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-0000f860: 7065 3d66 6f72 6365 5f6f 7574 7075 745f  pe=force_output_
-0000f870: 6765 6f6d 6574 7279 7479 7065 2c0d 0a20  geometrytype,.. 
-0000f880: 2020 2020 2020 2020 2020 2066 6f72 6365             force
-0000f890: 5f6d 756c 7469 7479 7065 3d66 6f72 6365  _multitype=force
-0000f8a0: 5f6d 756c 7469 7479 7065 2c0d 0a20 2020  _multitype,..   
-0000f8b0: 2020 2020 2020 2020 2061 7070 656e 643d           append=
-0000f8c0: 6170 7065 6e64 2c0d 0a20 2020 2020 2020  append,..       
-0000f8d0: 2020 2020 2073 6368 656d 613d 7363 6865       schema=sche
-0000f8e0: 6d61 2c0d 0a20 2020 2020 2020 2020 2020  ma,..           
-0000f8f0: 2063 7265 6174 655f 7370 6174 6961 6c5f   create_spatial_
-0000f900: 696e 6465 783d 6372 6561 7465 5f73 7061  index=create_spa
-0000f910: 7469 616c 5f69 6e64 6578 2c0d 0a20 2020  tial_index,..   
-0000f920: 2020 2020 2029 0d0a 2020 2020 656c 7365       )..    else
-0000f930: 3a0d 0a20 2020 2020 2020 2023 2041 7070  :..        # App
-0000f940: 656e 6420 6973 2061 736b 6564 2c20 6368  end is asked, ch
-0000f950: 6563 6b20 6966 2074 6865 2066 696f 6e61  eck if the fiona
-0000f960: 2064 7269 7665 7220 7375 7070 6f72 7473   driver supports
-0000f970: 2061 7070 656e 6469 6e67 2e20 4966 0d0a   appending. If..
-0000f980: 2020 2020 2020 2020 2320 6e6f 742c 2077          # not, w
-0000f990: 7269 7465 2074 6f20 7465 6d70 6f72 6172  rite to temporar
-0000f9a0: 7920 6f75 7470 7574 2066 696c 650d 0a0d  y output file...
-0000f9b0: 0a20 2020 2020 2020 2023 2052 656d 6172  .        # Remar
-0000f9c0: 6b3a 2066 696f 6e61 2070 7265 2d31 2e38  k: fiona pre-1.8
-0000f9d0: 2e31 3420 6469 646e 2774 2073 7570 706f  .14 didn't suppo
-0000f9e0: 7274 2061 7070 656e 6469 6e67 2074 6f20  rt appending to 
-0000f9f0: 6765 6f70 6163 6b61 6765 2e20 4f6e 6365  geopackage. Once
-0000fa00: 0d0a 2020 2020 2020 2020 2320 6f6c 6465  ..        # olde
-0000fa10: 7220 7665 7273 696f 6e73 2062 6563 6f6d  r versions becom
-0000fa20: 6573 2072 6172 652c 2064 6570 656e 6465  es rare, depende
-0000fa30: 6e63 7920 6361 6e20 6265 2070 7574 2074  ncy can be put t
-0000fa40: 6f20 7468 6973 2076 6572 7369 6f6e 2c20  o this version, 
-0000fa50: 616e 640d 0a20 2020 2020 2020 2023 2074  and..        # t
-0000fa60: 6869 7320 636f 6465 2063 616e 2062 6520  his code can be 
-0000fa70: 636c 6561 6e65 6420 7570 2e2e 2e0d 0a20  cleaned up..... 
-0000fa80: 2020 2020 2020 2070 6174 685f 696e 666f         path_info
-0000fa90: 203d 205f 6765 6f66 696c 6569 6e66 6f2e   = _geofileinfo.
-0000faa0: 6765 745f 6765 6f66 696c 6569 6e66 6f28  get_geofileinfo(
-0000fab0: 7061 7468 290d 0a20 2020 2020 2020 2067  path)..        g
-0000fac0: 6466 7465 6d70 5f70 6174 6820 3d20 4e6f  dftemp_path = No
-0000fad0: 6e65 0d0a 2020 2020 2020 2020 6764 6674  ne..        gdft
-0000fae0: 656d 705f 6c6f 636b 7061 7468 203d 204e  emp_lockpath = N
-0000faf0: 6f6e 650d 0a20 2020 2020 2020 2069 6620  one..        if 
-0000fb00: 2261 2220 6e6f 7420 696e 2066 696f 6e61  "a" not in fiona
-0000fb10: 2e73 7570 706f 7274 6564 5f64 7269 7665  .supported_drive
-0000fb20: 7273 5b70 6174 685f 696e 666f 2e64 7269  rs[path_info.dri
-0000fb30: 7665 725d 3a0d 0a20 2020 2020 2020 2020  ver]:..         
-0000fb40: 2020 2023 2047 6574 2061 2075 6e69 7175     # Get a uniqu
-0000fb50: 6520 7465 6d70 2066 696c 6520 7061 7468  e temp file path
-0000fb60: 2e20 5468 6520 6669 6c65 2063 616e 6e6f  . The file canno
-0000fb70: 7420 6265 2063 7265 6174 6564 2079 6574  t be created yet
-0000fb80: 2c20 736f 0d0a 2020 2020 2020 2020 2020  , so..          
-0000fb90: 2020 2320 6f6e 6c79 2063 7265 6174 6520    # only create 
-0000fba0: 6120 6c6f 636b 2066 696c 6520 746f 2061  a lock file to a
-0000fbb0: 766f 6964 206f 7468 6572 2070 726f 6365  void other proce
-0000fbc0: 7373 6573 2075 7369 6e67 2074 6865 2073  sses using the s
-0000fbd0: 616d 650d 0a20 2020 2020 2020 2020 2020  ame..           
-0000fbe0: 2023 2074 656d 7020 6669 6c65 206e 616d   # temp file nam
-0000fbf0: 650d 0a20 2020 2020 2020 2020 2020 2067  e..            g
-0000fc00: 6466 7465 6d70 5f70 6174 682c 2067 6466  dftemp_path, gdf
-0000fc10: 7465 6d70 5f6c 6f63 6b70 6174 6820 3d20  temp_lockpath = 
-0000fc20: 5f69 6f5f 7574 696c 2e67 6574 5f74 656d  _io_util.get_tem
-0000fc30: 7066 696c 655f 6c6f 636b 6564 280d 0a20  pfile_locked(.. 
-0000fc40: 2020 2020 2020 2020 2020 2020 2020 2062                 b
-0000fc50: 6173 655f 6669 6c65 6e61 6d65 3d22 6764  ase_filename="gd
-0000fc60: 6674 656d 7022 2c20 7375 6666 6978 3d70  ftemp", suffix=p
-0000fc70: 6174 682e 7375 6666 6978 2c20 6469 726e  ath.suffix, dirn
-0000fc80: 616d 653d 2267 656f 6669 6c65 5f74 6f5f  ame="geofile_to_
-0000fc90: 6669 6c65 220d 0a20 2020 2020 2020 2020  file"..         
-0000fca0: 2020 2029 0d0a 2020 2020 2020 2020 2020     )..          
-0000fcb0: 2020 7772 6974 655f 746f 5f66 696c 6528    write_to_file(
-0000fcc0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000fcd0: 2020 6764 662c 0d0a 2020 2020 2020 2020    gdf,..        
-0000fce0: 2020 2020 2020 2020 7061 7468 3d67 6466          path=gdf
-0000fcf0: 7465 6d70 5f70 6174 682c 0d0a 2020 2020  temp_path,..    
-0000fd00: 2020 2020 2020 2020 2020 2020 6c61 7965              laye
-0000fd10: 723d 6c61 7965 722c 0d0a 2020 2020 2020  r=layer,..      
-0000fd20: 2020 2020 2020 2020 2020 696e 6465 783d            index=
-0000fd30: 696e 6465 782c 0d0a 2020 2020 2020 2020  index,..        
-0000fd40: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
-0000fd50: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
-0000fd60: 653d 666f 7263 655f 6f75 7470 7574 5f67  e=force_output_g
-0000fd70: 656f 6d65 7472 7974 7970 652c 0d0a 2020  eometrytype,..  
-0000fd80: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-0000fd90: 7263 655f 6d75 6c74 6974 7970 653d 666f  rce_multitype=fo
-0000fda0: 7263 655f 6d75 6c74 6974 7970 652c 0d0a  rce_multitype,..
-0000fdb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fdc0: 7363 6865 6d61 3d73 6368 656d 612c 0d0a  schema=schema,..
-0000fdd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fde0: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-0000fdf0: 6e64 6578 3d63 7265 6174 655f 7370 6174  ndex=create_spat
-0000fe00: 6961 6c5f 696e 6465 782c 0d0a 2020 2020  ial_index,..    
-0000fe10: 2020 2020 2020 2020 290d 0a0d 0a20 2020          )....   
-0000fe20: 2020 2020 2023 2046 696c 6573 2064 6f6e       # Files don
-0000fe30: 2774 2074 7970 6963 616c 6c79 2073 7570  't typically sup
-0000fe40: 706f 7274 2068 6176 696e 6720 6d75 6c74  port having mult
-0000fe50: 6970 6c65 2070 726f 6365 7373 6573 2077  iple processes w
-0000fe60: 7269 7469 6e67 0d0a 2020 2020 2020 2020  riting..        
-0000fe70: 2320 7369 6d75 6c74 616e 6f75 736c 7920  # simultanously 
-0000fe80: 746f 2074 6865 6d2c 2073 6f20 7573 6520  to them, so use 
-0000fe90: 6c6f 636b 2066 696c 6520 746f 2073 796e  lock file to syn
-0000fea0: 6368 726f 6e69 7a65 2061 6363 6573 732e  chronize access.
-0000feb0: 0d0a 2020 2020 2020 2020 6c6f 636b 6669  ..        lockfi
-0000fec0: 6c65 203d 2050 6174 6828 6622 7b73 7472  le = Path(f"{str
-0000fed0: 2870 6174 6829 7d2e 6c6f 636b 2229 0d0a  (path)}.lock")..
-0000fee0: 2020 2020 2020 2020 7374 6172 745f 7469          start_ti
-0000fef0: 6d65 203d 2064 6174 6574 696d 652e 6461  me = datetime.da
-0000ff00: 7465 7469 6d65 2e6e 6f77 2829 0d0a 2020  tetime.now()..  
-0000ff10: 2020 2020 2020 7265 6164 7920 3d20 4661        ready = Fa
-0000ff20: 6c73 650d 0a20 2020 2020 2020 2077 6869  lse..        whi
-0000ff30: 6c65 206e 6f74 2072 6561 6479 3a0d 0a20  le not ready:.. 
-0000ff40: 2020 2020 2020 2020 2020 2069 6620 5f69             if _i
-0000ff50: 6f5f 7574 696c 2e63 7265 6174 655f 6669  o_util.create_fi
-0000ff60: 6c65 5f61 746f 6d69 6328 6c6f 636b 6669  le_atomic(lockfi
-0000ff70: 6c65 2920 6973 2054 7275 653a 0d0a 2020  le) is True:..  
-0000ff80: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-0000ff90: 793a 0d0a 2020 2020 2020 2020 2020 2020  y:..            
-0000ffa0: 2020 2020 2020 2020 2320 4966 2067 6466          # If gdf
-0000ffb0: 2077 6173 6e27 7420 7772 6974 7465 6e20   wasn't written 
-0000ffc0: 746f 2074 656d 7020 6669 6c65 2c20 7573  to temp file, us
-0000ffd0: 6520 7374 616e 6461 7264 2077 7269 7465  e standard write
-0000ffe0: 2d74 6f2d 6669 6c65 0d0a 2020 2020 2020  -to-file..      
-0000fff0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00010000: 2067 6466 7465 6d70 5f70 6174 6820 6973   gdftemp_path is
-00010010: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-00010020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010030: 7772 6974 655f 746f 5f66 696c 6528 0d0a  write_to_file(..
-00010040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010050: 2020 2020 2020 2020 2020 2020 6764 663d              gdf=
-00010060: 6764 662c 0d0a 2020 2020 2020 2020 2020  gdf,..          
-00010070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010080: 2020 7061 7468 3d70 6174 682c 0d0a 2020    path=path,..  
+00003600: 2020 2020 2020 2020 2070 726a 5f70 6174           prj_pat
+00003610: 682e 756e 6c69 6e6b 2829 0a20 2020 2020  h.unlink().     
+00003620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003630: 2020 2020 2020 2020 2020 2070 726a 5f70             prj_p
+00003640: 6174 682e 7772 6974 655f 7465 7874 2850  ath.write_text(P
+00003650: 524a 5f45 5053 475f 3331 3337 3029 0a20  RJ_EPSG_31370). 
+00003660: 2020 2020 2020 2065 6c69 6620 7261 6973         elif rais
+00003670: 655f 6f6e 5f6e 6f67 656f 6d3a 0a20 2020  e_on_nogeom:.   
+00003680: 2020 2020 2020 2020 2065 7272 6f72 732e           errors.
+00003690: 6170 7065 6e64 2822 4c61 7965 7220 646f  append("Layer do
+000036a0: 6573 6e27 7420 6861 7665 2061 2067 656f  esn't have a geo
+000036b0: 6d65 7472 7920 636f 6c75 6d6e 2122 290a  metry column!").
+000036c0: 0a20 2020 2020 2020 2023 2049 6620 7468  .        # If th
+000036d0: 6572 6520 7765 7265 206e 6f20 6572 726f  ere were no erro
+000036e0: 7273 2c20 6576 6572 7974 6869 6e67 2077  rs, everything w
+000036f0: 6173 204f 4b20 736f 2077 6520 6361 6e20  as OK so we can 
+00003700: 7265 7475 726e 2e0a 2020 2020 2020 2020  return..        
+00003710: 6966 206c 656e 2865 7272 6f72 7329 203d  if len(errors) =
+00003720: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
+00003730: 2072 6574 7572 6e20 4c61 7965 7249 6e66   return LayerInf
+00003740: 6f28 0a20 2020 2020 2020 2020 2020 2020  o(.             
+00003750: 2020 206e 616d 653d 6461 7461 736f 7572     name=datasour
+00003760: 6365 5f6c 6179 6572 2e47 6574 4e61 6d65  ce_layer.GetName
+00003770: 2829 2c0a 2020 2020 2020 2020 2020 2020  (),.            
+00003780: 2020 2020 6665 6174 7572 6563 6f75 6e74      featurecount
+00003790: 3d64 6174 6173 6f75 7263 655f 6c61 7965  =datasource_laye
+000037a0: 722e 4765 7446 6561 7475 7265 436f 756e  r.GetFeatureCoun
+000037b0: 7428 292c 0a20 2020 2020 2020 2020 2020  t(),.           
+000037c0: 2020 2020 2074 6f74 616c 5f62 6f75 6e64       total_bound
+000037d0: 733d 746f 7461 6c5f 626f 756e 6473 2c20  s=total_bounds, 
+000037e0: 2023 2074 7970 653a 2069 676e 6f72 655b   # type: ignore[
+000037f0: 6172 672d 7479 7065 5d0a 2020 2020 2020  arg-type].      
+00003800: 2020 2020 2020 2020 2020 6765 6f6d 6574            geomet
+00003810: 7279 636f 6c75 6d6e 3d67 656f 6d65 7472  rycolumn=geometr
+00003820: 7963 6f6c 756d 6e2c 2020 2320 7479 7065  ycolumn,  # type
+00003830: 3a20 6967 6e6f 7265 5b61 7267 2d74 7970  : ignore[arg-typ
+00003840: 655d 0a20 2020 2020 2020 2020 2020 2020  e].             
+00003850: 2020 2067 656f 6d65 7472 7974 7970 656e     geometrytypen
+00003860: 616d 653d 6765 6f6d 6574 7279 7479 7065  ame=geometrytype
+00003870: 6e61 6d65 2c0a 2020 2020 2020 2020 2020  name,.          
+00003880: 2020 2020 2020 6765 6f6d 6574 7279 7479        geometryty
+00003890: 7065 3d67 656f 6d65 7472 7974 7970 652c  pe=geometrytype,
+000038a0: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
+000038b0: 5b61 7267 2d74 7970 655d 0a20 2020 2020  [arg-type].     
+000038c0: 2020 2020 2020 2020 2020 2063 6f6c 756d             colum
+000038d0: 6e73 3d63 6f6c 756d 6e73 2c0a 2020 2020  ns=columns,.    
+000038e0: 2020 2020 2020 2020 2020 2020 6669 645f              fid_
+000038f0: 636f 6c75 6d6e 3d64 6174 6173 6f75 7263  column=datasourc
+00003900: 655f 6c61 7965 722e 4765 7446 4944 436f  e_layer.GetFIDCo
+00003910: 6c75 6d6e 2829 2c0a 2020 2020 2020 2020  lumn(),.        
+00003920: 2020 2020 2020 2020 6372 733d 6372 732c          crs=crs,
+00003930: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003940: 2065 7272 6f72 733d 6572 726f 7273 2c0a   errors=errors,.
+00003950: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+00003960: 2020 2065 7863 6570 7420 4578 6365 7074     except Except
+00003970: 696f 6e20 6173 2065 783a 0a20 2020 2020  ion as ex:.     
+00003980: 2020 2065 782e 6172 6773 203d 2028 6622     ex.args = (f"
+00003990: 6765 745f 6c61 7965 7269 6e66 6f20 6572  get_layerinfo er
+000039a0: 726f 7220 666f 7220 7b70 6174 687d 2e7b  ror for {path}.{
+000039b0: 6c61 7965 727d 3a5c 6e20 207b 6578 7d22  layer}:\n  {ex}"
+000039c0: 2c29 0a20 2020 2020 2020 2072 6169 7365  ,).        raise
+000039d0: 0a20 2020 2066 696e 616c 6c79 3a0a 2020  .    finally:.  
+000039e0: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
+000039f0: 203d 204e 6f6e 650a 0a20 2020 2023 2049   = None..    # I
+00003a00: 6620 7765 2064 6964 6e27 7420 7265 7475  f we didn't retu
+00003a10: 726e 206f 7220 7261 6973 6520 7965 7420  rn or raise yet 
+00003a20: 6865 7265 2c20 7468 6572 6520 6d75 7374  here, there must
+00003a30: 2068 6176 6520 6265 656e 2065 7272 6f72   have been error
+00003a40: 730a 2020 2020 6572 726f 7273 5f73 7472  s.    errors_str
+00003a50: 203d 2070 7072 696e 742e 7066 6f72 6d61   = pprint.pforma
+00003a60: 7428 6572 726f 7273 290a 2020 2020 7261  t(errors).    ra
+00003a70: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
+00003a80: 2020 2020 2020 2020 6622 4572 726f 7273          f"Errors
+00003a90: 2069 6e20 6c61 7965 7220 6465 6669 6e69   in layer defini
+00003aa0: 7469 6f6e 206f 6620 6669 6c65 207b 7061  tion of file {pa
+00003ab0: 7468 7d2c 206c 6179 6572 207b 6c61 7965  th}, layer {laye
+00003ac0: 727d 3a20 5c6e 7b65 7272 6f72 735f 7374  r}: \n{errors_st
+00003ad0: 727d 220a 2020 2020 290a 0a0a 6465 6620  r}".    )...def 
+00003ae0: 6765 745f 6f6e 6c79 5f6c 6179 6572 2870  get_only_layer(p
+00003af0: 6174 683a 2055 6e69 6f6e 5b73 7472 2c20  ath: Union[str, 
+00003b00: 226f 732e 5061 7468 4c69 6b65 5b41 6e79  "os.PathLike[Any
+00003b10: 5d22 5d29 202d 3e20 7374 723a 0a20 2020  ]"]) -> str:.   
+00003b20: 2022 2222 0a20 2020 2047 6574 2074 6865   """.    Get the
+00003b30: 206c 6179 6572 6e61 6d65 2066 6f72 2061   layername for a
+00003b40: 2066 696c 6520 7468 6174 206f 6e6c 7920   file that only 
+00003b50: 636f 6e74 6169 6e73 206f 6e65 206c 6179  contains one lay
+00003b60: 6572 2e0a 0a20 2020 2049 6620 7468 6520  er...    If the 
+00003b70: 6669 6c65 2063 6f6e 7461 696e 7320 6d75  file contains mu
+00003b80: 6c74 6970 6c65 206c 6179 6572 732c 2061  ltiple layers, a
+00003b90: 6e20 6578 6365 7074 696f 6e20 6973 2074  n exception is t
+00003ba0: 6872 6f77 6e2e 0a0a 2020 2020 4172 6773  hrown...    Args
+00003bb0: 3a0a 2020 2020 2020 2020 7061 7468 2028  :.        path (
+00003bc0: 5061 7468 4c69 6b65 293a 2074 6865 2066  PathLike): the f
+00003bd0: 696c 652e 0a0a 2020 2020 5261 6973 6573  ile...    Raises
+00003be0: 3a0a 2020 2020 2020 2020 5661 6c75 6545  :.        ValueE
+00003bf0: 7272 6f72 3a20 616e 2069 6e76 616c 6964  rror: an invalid
+00003c00: 2070 6172 616d 6574 6572 2076 616c 7565   parameter value
+00003c10: 2077 6173 2070 6173 7365 642e 0a0a 2020   was passed...  
+00003c20: 2020 5265 7475 726e 733a 0a20 2020 2020    Returns:.     
+00003c30: 2020 2073 7472 3a20 7468 6520 6c61 7965     str: the laye
+00003c40: 7220 6e61 6d65 0a20 2020 2022 2222 0a20  r name.    """. 
+00003c50: 2020 2064 6174 6173 6f75 7263 6520 3d20     datasource = 
+00003c60: 4e6f 6e65 0a20 2020 2074 7279 3a0a 2020  None.    try:.  
+00003c70: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
+00003c80: 5f6c 6179 6572 203d 204e 6f6e 650a 2020  _layer = None.  
+00003c90: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
+00003ca0: 203d 2067 6461 6c2e 4f70 656e 4578 280a   = gdal.OpenEx(.
+00003cb0: 2020 2020 2020 2020 2020 2020 7374 7228              str(
+00003cc0: 7061 7468 292c 206e 4f70 656e 466c 6167  path), nOpenFlag
+00003cd0: 733d 6764 616c 2e4f 465f 5645 4354 4f52  s=gdal.OF_VECTOR
+00003ce0: 207c 2067 6461 6c2e 4f46 5f52 4541 444f   | gdal.OF_READO
+00003cf0: 4e4c 5920 7c20 6764 616c 2e4f 465f 5348  NLY | gdal.OF_SH
+00003d00: 4152 4544 0a20 2020 2020 2020 2029 0a20  ARED.        ). 
+00003d10: 2020 2020 2020 206e 625f 6c61 7965 7273         nb_layers
+00003d20: 203d 2064 6174 6173 6f75 7263 652e 4765   = datasource.Ge
+00003d30: 744c 6179 6572 436f 756e 7428 290a 2020  tLayerCount().  
+00003d40: 2020 2020 2020 6966 206e 625f 6c61 7965        if nb_laye
+00003d50: 7273 203d 3d20 313a 0a20 2020 2020 2020  rs == 1:.       
+00003d60: 2020 2020 2064 6174 6173 6f75 7263 655f       datasource_
+00003d70: 6c61 7965 7220 3d20 6461 7461 736f 7572  layer = datasour
+00003d80: 6365 2e47 6574 4c61 7965 7242 7949 6e64  ce.GetLayerByInd
+00003d90: 6578 2830 290a 2020 2020 2020 2020 656c  ex(0).        el
+00003da0: 6966 206e 625f 6c61 7965 7273 203d 3d20  if nb_layers == 
+00003db0: 303a 0a20 2020 2020 2020 2020 2020 2072  0:.            r
+00003dc0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+00003dd0: 6622 4572 726f 723a 204e 6f20 6c61 7965  f"Error: No laye
+00003de0: 7273 2066 6f75 6e64 2069 6e20 7b70 6174  rs found in {pat
+00003df0: 687d 2229 0a20 2020 2020 2020 2065 6c73  h}").        els
+00003e00: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
+00003e10: 2043 6865 636b 2069 6620 7468 6572 6520   Check if there 
+00003e20: 6973 206f 6e6c 7920 6f6e 6520 7370 6174  is only one spat
+00003e30: 6961 6c20 6c61 7965 720a 2020 2020 2020  ial layer.      
+00003e40: 2020 2020 2020 6c61 7965 7273 203d 206c        layers = l
+00003e50: 6973 746c 6179 6572 7328 7061 7468 2c20  istlayers(path, 
+00003e60: 6f6e 6c79 5f73 7061 7469 616c 5f6c 6179  only_spatial_lay
+00003e70: 6572 733d 5472 7565 290a 2020 2020 2020  ers=True).      
+00003e80: 2020 2020 2020 6966 206c 656e 286c 6179        if len(lay
+00003e90: 6572 7329 203d 3d20 313a 0a20 2020 2020  ers) == 1:.     
+00003ea0: 2020 2020 2020 2020 2020 2064 6174 6173             datas
+00003eb0: 6f75 7263 655f 6c61 7965 7220 3d20 6461  ource_layer = da
+00003ec0: 7461 736f 7572 6365 2e47 6574 4c61 7965  tasource.GetLaye
+00003ed0: 7228 6c61 7965 7273 5b30 5d29 0a20 2020  r(layers[0]).   
+00003ee0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00003ef0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00003f00: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+00003f10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003f20: 2020 2020 2066 2269 6e70 7574 2068 6173       f"input has
+00003f30: 203e 2031 206c 6179 6572 2c20 6275 7420   > 1 layer, but 
+00003f40: 6e6f 206c 6179 6572 2073 7065 6369 6669  no layer specifi
+00003f50: 6564 3a20 7b70 6174 687d 3a20 7b6c 6179  ed: {path}: {lay
+00003f60: 6572 737d 220a 2020 2020 2020 2020 2020  ers}".          
+00003f70: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+00003f80: 2072 6574 7572 6e20 6461 7461 736f 7572   return datasour
+00003f90: 6365 5f6c 6179 6572 2e47 6574 4e61 6d65  ce_layer.GetName
+00003fa0: 2829 0a0a 2020 2020 6578 6365 7074 2045  ()..    except E
+00003fb0: 7863 6570 7469 6f6e 2061 7320 6578 3a0a  xception as ex:.
+00003fc0: 2020 2020 2020 2020 6578 2e61 7267 7320          ex.args 
+00003fd0: 3d20 2866 2267 6574 5f6f 6e6c 795f 6c61  = (f"get_only_la
+00003fe0: 7965 7220 6572 726f 7220 666f 7220 7b70  yer error for {p
+00003ff0: 6174 687d 3a5c 6e20 207b 6578 7d22 2c29  ath}:\n  {ex}",)
+00004000: 0a20 2020 2020 2020 2072 6169 7365 0a20  .        raise. 
+00004010: 2020 2066 696e 616c 6c79 3a0a 2020 2020     finally:.    
+00004020: 2020 2020 6461 7461 736f 7572 6365 203d      datasource =
+00004030: 204e 6f6e 650a 0a0a 6465 6620 6765 745f   None...def get_
+00004040: 6465 6661 756c 745f 6c61 7965 7228 7061  default_layer(pa
+00004050: 7468 3a20 556e 696f 6e5b 7374 722c 2022  th: Union[str, "
+00004060: 6f73 2e50 6174 684c 696b 655b 416e 795d  os.PathLike[Any]
+00004070: 225d 2920 2d3e 2073 7472 3a0a 2020 2020  "]) -> str:.    
+00004080: 2222 220a 2020 2020 4765 7420 7468 6520  """.    Get the 
+00004090: 6465 6661 756c 7420 6c61 7965 7220 6e61  default layer na
+000040a0: 6d65 2074 6f20 6265 2075 7365 6420 666f  me to be used fo
+000040b0: 7220 6120 6c61 7965 7220 696e 2074 6869  r a layer in thi
+000040c0: 7320 6669 6c65 2e0a 0a20 2020 2054 6869  s file...    Thi
+000040d0: 7320 6973 2074 6865 2073 7465 6d20 6f66  s is the stem of
+000040e0: 2074 6865 2066 696c 6570 6174 682e 0a0a   the filepath...
+000040f0: 2020 2020 4172 6773 3a0a 2020 2020 2020      Args:.      
+00004100: 2020 7061 7468 2028 556e 696f 6e5b 7374    path (Union[st
+00004110: 722c 293a 2054 6865 2070 6174 6820 746f  r,): The path to
+00004120: 2074 6865 2066 696c 652e 0a0a 2020 2020   the file...    
+00004130: 5265 7475 726e 733a 0a20 2020 2020 2020  Returns:.       
+00004140: 2073 7472 3a20 5468 6520 6465 6661 756c   str: The defaul
+00004150: 7420 6c61 7965 7220 6e61 6d65 2e0a 2020  t layer name..  
+00004160: 2020 2222 220a 2020 2020 7265 7475 726e    """.    return
+00004170: 2050 6174 6828 7061 7468 292e 7374 656d   Path(path).stem
+00004180: 0a0a 0a64 6566 2065 7865 6375 7465 5f73  ...def execute_s
+00004190: 716c 280a 2020 2020 7061 7468 3a20 556e  ql(.    path: Un
+000041a0: 696f 6e5b 7374 722c 2022 6f73 2e50 6174  ion[str, "os.Pat
+000041b0: 684c 696b 655b 416e 795d 225d 2c0a 2020  hLike[Any]"],.  
+000041c0: 2020 7371 6c5f 7374 6d74 3a20 7374 722c    sql_stmt: str,
+000041d0: 0a20 2020 2073 716c 5f64 6961 6c65 6374  .    sql_dialect
+000041e0: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
+000041f0: 3d20 4e6f 6e65 2c0a 293a 0a20 2020 2022  = None,.):.    "
+00004200: 2222 0a20 2020 2045 7865 6375 7465 2061  "".    Execute a
+00004210: 2053 514c 2073 7461 7465 6d65 6e74 2028   SQL statement (
+00004220: 444d 4c20 6f72 2044 444c 2920 6f6e 2074  DML or DDL) on t
+00004230: 6865 2066 696c 652e 0a0a 2020 2020 546f  he file...    To
+00004240: 2072 756e 2053 454c 4543 5420 5351 4c20   run SELECT SQL 
+00004250: 7374 6174 656d 656e 7473 206f 6e20 6120  statements on a 
+00004260: 6669 6c65 2c20 7573 6520 3a6d 6574 683a  file, use :meth:
+00004270: 607e 7265 6164 5f66 696c 6560 2e0a 0a20  `~read_file`... 
+00004280: 2020 2041 7267 733a 0a20 2020 2020 2020     Args:.       
+00004290: 2070 6174 6820 2850 6174 684c 696b 6529   path (PathLike)
+000042a0: 3a20 5468 6520 7061 7468 2074 6f20 7468  : The path to th
+000042b0: 6520 6669 6c65 2e0a 2020 2020 2020 2020  e file..        
+000042c0: 7371 6c5f 7374 6d74 2028 7374 7229 3a20  sql_stmt (str): 
+000042d0: 5468 6520 5351 4c20 7374 6174 656d 656e  The SQL statemen
+000042e0: 7420 746f 2065 7865 6375 7465 2e0a 2020  t to execute..  
+000042f0: 2020 2020 2020 7371 6c5f 6469 616c 6563        sql_dialec
+00004300: 7420 2873 7472 293a 2054 6865 2053 514c  t (str): The SQL
+00004310: 2064 6961 6c65 6374 2074 6f20 7573 653a   dialect to use:
+00004320: 0a20 2020 2020 2020 2020 2020 202a 204e  .            * N
+00004330: 6f6e 653a 2075 7365 2074 6865 206e 6174  one: use the nat
+00004340: 6976 6520 5351 4c20 6469 616c 6563 7420  ive SQL dialect 
+00004350: 6f66 2074 6865 2067 656f 6669 6c65 2e0a  of the geofile..
+00004360: 2020 2020 2020 2020 2020 2020 2a20 274f              * 'O
+00004370: 4752 5351 4c27 3a20 666f 7263 6520 7468  GRSQL': force th
+00004380: 6520 7573 6520 6f66 2074 6865 204f 4752  e use of the OGR
+00004390: 2053 514c 2064 6961 6c65 6374 2e0a 2020   SQL dialect..  
+000043a0: 2020 2020 2020 2020 2020 2a20 2753 514c            * 'SQL
+000043b0: 4954 4527 3a20 666f 7263 6520 7468 6520  ITE': force the 
+000043c0: 7573 6520 6f66 2074 6865 2053 514c 4954  use of the SQLIT
+000043d0: 4520 6469 616c 6563 742e 0a20 2020 2020  E dialect..     
+000043e0: 2020 2020 2020 2044 6566 6175 6c74 7320         Defaults 
+000043f0: 746f 204e 6f6e 652e 0a20 2020 2022 2222  to None..    """
+00004400: 0a20 2020 2064 6174 6173 6f75 7263 6520  .    datasource 
+00004410: 3d20 4e6f 6e65 0a20 2020 2074 7279 3a0a  = None.    try:.
+00004420: 2020 2020 2020 2020 6461 7461 736f 7572          datasour
+00004430: 6365 203d 2067 6461 6c2e 4f70 656e 4578  ce = gdal.OpenEx
+00004440: 2873 7472 2870 6174 6829 2c20 6e4f 7065  (str(path), nOpe
+00004450: 6e46 6c61 6773 3d67 6461 6c2e 4f46 5f55  nFlags=gdal.OF_U
+00004460: 5044 4154 4529 0a20 2020 2020 2020 2072  PDATE).        r
+00004470: 6573 756c 7420 3d20 6461 7461 736f 7572  esult = datasour
+00004480: 6365 2e45 7865 6375 7465 5351 4c28 7371  ce.ExecuteSQL(sq
+00004490: 6c5f 7374 6d74 2c20 6469 616c 6563 743d  l_stmt, dialect=
+000044a0: 7371 6c5f 6469 616c 6563 7429 0a20 2020  sql_dialect).   
+000044b0: 2020 2020 2064 6174 6173 6f75 7263 652e       datasource.
+000044c0: 5265 6c65 6173 6552 6573 756c 7453 6574  ReleaseResultSet
+000044d0: 2872 6573 756c 7429 0a0a 2020 2020 6578  (result)..    ex
+000044e0: 6365 7074 2045 7863 6570 7469 6f6e 2061  cept Exception a
+000044f0: 7320 6578 3a0a 2020 2020 2020 2020 6578  s ex:.        ex
+00004500: 2e61 7267 7320 3d20 2866 2265 7865 6375  .args = (f"execu
+00004510: 7465 5f73 716c 2065 7272 6f72 2066 6f72  te_sql error for
+00004520: 207b 7061 7468 7d5c 6e20 207b 6578 7d22   {path}\n  {ex}"
+00004530: 2c29 0a20 2020 2020 2020 2072 6169 7365  ,).        raise
+00004540: 0a20 2020 2066 696e 616c 6c79 3a0a 2020  .    finally:.  
+00004550: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
+00004560: 203d 204e 6f6e 650a 0a0a 6465 6620 6372   = None...def cr
+00004570: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
+00004580: 6578 280a 2020 2020 7061 7468 3a20 556e  ex(.    path: Un
+00004590: 696f 6e5b 7374 722c 2022 6f73 2e50 6174  ion[str, "os.Pat
+000045a0: 684c 696b 655b 416e 795d 225d 2c0a 2020  hLike[Any]"],.  
+000045b0: 2020 6c61 7965 723a 204f 7074 696f 6e61    layer: Optiona
+000045c0: 6c5b 7374 725d 203d 204e 6f6e 652c 0a20  l[str] = None,. 
+000045d0: 2020 2063 6163 6865 5f73 697a 655f 6d62     cache_size_mb
+000045e0: 3a20 4f70 7469 6f6e 616c 5b69 6e74 5d20  : Optional[int] 
+000045f0: 3d20 3132 382c 0a20 2020 2065 7869 7374  = 128,.    exist
+00004600: 5f6f 6b3a 2062 6f6f 6c20 3d20 4661 6c73  _ok: bool = Fals
+00004610: 652c 0a20 2020 2066 6f72 6365 5f72 6562  e,.    force_reb
+00004620: 7569 6c64 3a20 626f 6f6c 203d 2046 616c  uild: bool = Fal
+00004630: 7365 2c0a 2020 2020 6e6f 5f67 656f 6d5f  se,.    no_geom_
+00004640: 6f6b 3a20 626f 6f6c 203d 2046 616c 7365  ok: bool = False
+00004650: 2c0a 293a 0a20 2020 2022 2222 0a20 2020  ,.):.    """.   
+00004660: 2043 7265 6174 6520 6120 7370 6174 6961   Create a spatia
+00004670: 6c20 696e 6465 7820 6f6e 2074 6865 206c  l index on the l
+00004680: 6179 6572 2073 7065 6369 6669 6564 2e0a  ayer specified..
+00004690: 0a20 2020 2041 7267 733a 0a20 2020 2020  .    Args:.     
+000046a0: 2020 2070 6174 6820 2850 6174 684c 696b     path (PathLik
+000046b0: 6529 3a20 5468 6520 6669 6c65 2070 6174  e): The file pat
+000046c0: 682e 0a20 2020 2020 2020 206c 6179 6572  h..        layer
+000046d0: 2028 7374 722c 206f 7074 696f 6e61 6c29   (str, optional)
+000046e0: 3a20 5468 6520 6c61 7965 722e 2049 6620  : The layer. If 
+000046f0: 6e6f 7420 7370 6563 6966 6965 642c 2061  not specified, a
+00004700: 6e64 2074 6865 7265 2069 7320 6f6e 6c79  nd there is only
+00004710: 0a20 2020 2020 2020 2020 2020 206f 6e65  .            one
+00004720: 206c 6179 6572 2069 6e20 7468 6520 6669   layer in the fi
+00004730: 6c65 2c20 7468 6973 206c 6179 6572 2069  le, this layer i
+00004740: 7320 7573 6564 2e20 4f74 6865 7277 6973  s used. Otherwis
+00004750: 6520 6578 6365 7074 696f 6e2e 0a20 2020  e exception..   
+00004760: 2020 2020 2063 6163 6865 5f73 697a 655f       cache_size_
+00004770: 6d62 2028 696e 742c 206f 7074 696f 6e61  mb (int, optiona
+00004780: 6c29 3a20 6361 6368 6520 6d65 6d6f 7279  l): cache memory
+00004790: 2069 6e20 4d42 2074 6861 7420 6361 6e20   in MB that can 
+000047a0: 6265 2075 7365 6420 7768 696c 650a 2020  be used while.  
+000047b0: 2020 2020 2020 2020 2020 6372 6561 7469            creati
+000047c0: 6e67 2073 7061 7469 616c 2069 6e64 6578  ng spatial index
+000047d0: 2066 6f72 2073 7061 7469 616c 6974 6520   for spatialite 
+000047e0: 6669 6c65 7320 282e 6770 6b67 206f 7220  files (.gpkg or 
+000047f0: 2e73 716c 6974 6529 2e20 4966 204e 6f6e  .sqlite). If Non
+00004800: 652c 0a20 2020 2020 2020 2020 2020 2074  e,.            t
+00004810: 6865 2064 6566 6175 6c74 2063 6163 6865  he default cache
+00004820: 5f73 697a 6520 6672 6f6d 2073 716c 6974  _size from sqlit
+00004830: 6520 6973 2075 7365 642e 2044 6566 6175  e is used. Defau
+00004840: 6c74 7320 746f 2031 3238 2e0a 2020 2020  lts to 128..    
+00004850: 2020 2020 6578 6973 745f 6f6b 2028 626f      exist_ok (bo
+00004860: 6f6c 2c20 6f70 7469 6f6e 616c 293a 2049  ol, optional): I
+00004870: 6620 5472 7565 2061 6e64 2074 6865 2069  f True and the i
+00004880: 6e64 6578 2065 7869 7374 7320 616c 7265  ndex exists alre
+00004890: 6164 792c 2064 6f6e 2774 0a20 2020 2020  ady, don't.     
+000048a0: 2020 2020 2020 2074 6872 6f77 2061 6e20         throw an 
+000048b0: 6572 726f 722e 2044 6566 6175 6c74 7320  error. Defaults 
+000048c0: 746f 2046 616c 7365 2e0a 2020 2020 2020  to False..      
+000048d0: 2020 666f 7263 655f 7265 6275 696c 6420    force_rebuild 
+000048e0: 2862 6f6f 6c2c 206f 7074 696f 6e73 293a  (bool, options):
+000048f0: 2054 7275 6520 746f 2066 6f72 6365 2072   True to force r
+00004900: 6562 7569 6c64 2065 7665 6e20 6966 2069  ebuild even if i
+00004910: 6e64 6578 0a20 2020 2020 2020 2020 2020  ndex.           
+00004920: 2065 7869 7374 7320 616c 7265 6164 792e   exists already.
+00004930: 2044 6566 6175 6c74 7320 746f 2046 616c   Defaults to Fal
+00004940: 7365 2e0a 2020 2020 2020 2020 6e6f 5f67  se..        no_g
+00004950: 656f 6d5f 6f6b 2028 626f 6f6c 2c20 6f70  eom_ok (bool, op
+00004960: 7469 6f6e 7329 3a20 4966 2054 7275 6520  tions): If True 
+00004970: 616e 6420 7468 6520 6669 6c65 2064 6f65  and the file doe
+00004980: 736e 2774 2068 6176 6520 6120 6765 6f6d  sn't have a geom
+00004990: 6574 7279 2063 6f6c 756d 6e2c 0a20 2020  etry column,.   
+000049a0: 2020 2020 2020 2020 2064 6f6e 2774 2074           don't t
+000049b0: 6872 6f77 2061 6e20 6572 726f 722e 2044  hrow an error. D
+000049c0: 6566 6175 6c74 7320 746f 2046 616c 7365  efaults to False
+000049d0: 2e0a 2020 2020 2222 220a 2020 2020 2320  ..    """.    # 
+000049e0: 496e 6974 0a20 2020 2070 6174 6820 3d20  Init.    path = 
+000049f0: 5061 7468 2870 6174 6829 0a20 2020 2069  Path(path).    i
+00004a00: 6620 6c61 7965 7220 6973 204e 6f6e 653a  f layer is None:
+00004a10: 0a20 2020 2020 2020 206c 6179 6572 203d  .        layer =
+00004a20: 2067 6574 5f6f 6e6c 795f 6c61 7965 7228   get_only_layer(
+00004a30: 7061 7468 290a 0a20 2020 2023 2041 6464  path)..    # Add
+00004a40: 2069 6e64 6578 0a20 2020 2064 6174 6173   index.    datas
+00004a50: 6f75 7263 6520 3d20 4e6f 6e65 0a20 2020  ource = None.   
+00004a60: 2074 7279 3a0a 2020 2020 2020 2020 7061   try:.        pa
+00004a70: 7468 5f69 6e66 6f20 3d20 5f67 656f 6669  th_info = _geofi
+00004a80: 6c65 696e 666f 2e67 6574 5f67 656f 6669  leinfo.get_geofi
+00004a90: 6c65 696e 666f 2870 6174 6829 0a0a 2020  leinfo(path)..  
+00004aa0: 2020 2020 2020 6c61 7965 7269 6e66 6f20        layerinfo 
+00004ab0: 3d20 6765 745f 6c61 7965 7269 6e66 6f28  = get_layerinfo(
+00004ac0: 7061 7468 2c20 6c61 7965 722c 2072 6169  path, layer, rai
+00004ad0: 7365 5f6f 6e5f 6e6f 6765 6f6d 3d6e 6f74  se_on_nogeom=not
+00004ae0: 206e 6f5f 6765 6f6d 5f6f 6b29 0a20 2020   no_geom_ok).   
+00004af0: 2020 2020 2069 6620 6e6f 5f67 656f 6d5f       if no_geom_
+00004b00: 6f6b 2061 6e64 206c 6179 6572 696e 666f  ok and layerinfo
+00004b10: 2e67 656f 6d65 7472 7963 6f6c 756d 6e20  .geometrycolumn 
+00004b20: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+00004b30: 2020 2020 2072 6574 7572 6e0a 0a20 2020       return..   
+00004b40: 2020 2020 2023 2049 6620 696e 6465 7820       # If index 
+00004b50: 616c 7265 6164 7920 6578 6973 7473 2c20  already exists, 
+00004b60: 7265 6d6f 7665 2069 6e64 6578 206f 7220  remove index or 
+00004b70: 7265 7475 726e 0a20 2020 2020 2020 2069  return.        i
+00004b80: 6620 6861 735f 7370 6174 6961 6c5f 696e  f has_spatial_in
+00004b90: 6465 7828 7061 7468 2c20 6c61 7965 7229  dex(path, layer)
+00004ba0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00004bb0: 2066 6f72 6365 5f72 6562 7569 6c64 3a0a   force_rebuild:.
+00004bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004bd0: 7265 6d6f 7665 5f73 7061 7469 616c 5f69  remove_spatial_i
+00004be0: 6e64 6578 2870 6174 682c 206c 6179 6572  ndex(path, layer
+00004bf0: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
+00004c00: 6966 2065 7869 7374 5f6f 6b3a 0a20 2020  if exist_ok:.   
+00004c10: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00004c20: 7572 6e0a 2020 2020 2020 2020 2020 2020  urn.            
+00004c30: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00004c40: 2020 2020 2020 7261 6973 6520 5275 6e74        raise Runt
+00004c50: 696d 6545 7272 6f72 2866 2273 7061 7469  imeError(f"spati
+00004c60: 616c 2069 6e64 6578 2065 7869 7374 7320  al index exists 
+00004c70: 616c 7265 6164 7920 6f6e 207b 7061 7468  already on {path
+00004c80: 7d2e 7b6c 6179 6572 7d22 290a 0a20 2020  }.{layer}")..   
+00004c90: 2020 2020 2069 6620 7061 7468 5f69 6e66       if path_inf
+00004ca0: 6f2e 6973 5f73 7061 7469 616c 6974 655f  o.is_spatialite_
+00004cb0: 6261 7365 643a 0a20 2020 2020 2020 2020  based:.         
+00004cc0: 2020 2023 2054 6865 2063 6f6e 6669 6720     # The config 
+00004cd0: 6f70 7469 6f6e 7320 6e65 6564 2074 6f20  options need to 
+00004ce0: 6265 2073 6574 2062 6566 6f72 6520 6f70  be set before op
+00004cf0: 656e 696e 6720 7468 6520 6669 6c65 210a  ening the file!.
+00004d00: 2020 2020 2020 2020 2020 2020 7769 7468              with
+00004d10: 205f 6f67 725f 7574 696c 2e73 6574 5f63   _ogr_util.set_c
+00004d20: 6f6e 6669 675f 6f70 7469 6f6e 7328 7b22  onfig_options({"
+00004d30: 4f47 525f 5351 4c49 5445 5f43 4143 4845  OGR_SQLITE_CACHE
+00004d40: 223a 2063 6163 6865 5f73 697a 655f 6d62  ": cache_size_mb
+00004d50: 7d29 3a0a 2020 2020 2020 2020 2020 2020  }):.            
+00004d60: 2020 2020 6461 7461 736f 7572 6365 203d      datasource =
+00004d70: 2067 6461 6c2e 4f70 656e 4578 2873 7472   gdal.OpenEx(str
+00004d80: 2870 6174 6829 2c20 6e4f 7065 6e46 6c61  (path), nOpenFla
+00004d90: 6773 3d67 6461 6c2e 4f46 5f55 5044 4154  gs=gdal.OF_UPDAT
+00004da0: 4529 0a20 2020 2020 2020 2020 2020 2020  E).             
+00004db0: 2020 2067 656f 6d65 7472 7963 6f6c 756d     geometrycolum
+00004dc0: 6e20 3d20 6c61 7965 7269 6e66 6f2e 6765  n = layerinfo.ge
+00004dd0: 6f6d 6574 7279 636f 6c75 6d6e 0a20 2020  ometrycolumn.   
+00004de0: 2020 2020 2020 2020 2020 2020 2073 716c               sql
+00004df0: 203d 2066 2253 454c 4543 5420 4372 6561   = f"SELECT Crea
+00004e00: 7465 5370 6174 6961 6c49 6e64 6578 2827  teSpatialIndex('
+00004e10: 7b6c 6179 6572 7d27 2c20 277b 6765 6f6d  {layer}', '{geom
+00004e20: 6574 7279 636f 6c75 6d6e 7d27 2922 0a20  etrycolumn}')". 
+00004e30: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00004e40: 6573 756c 7420 3d20 6461 7461 736f 7572  esult = datasour
+00004e50: 6365 2e45 7865 6375 7465 5351 4c28 7371  ce.ExecuteSQL(sq
+00004e60: 6c2c 2064 6961 6c65 6374 3d22 5351 4c49  l, dialect="SQLI
+00004e70: 5445 2229 0a20 2020 2020 2020 2020 2020  TE").           
+00004e80: 2020 2020 2064 6174 6173 6f75 7263 652e       datasource.
+00004e90: 5265 6c65 6173 6552 6573 756c 7453 6574  ReleaseResultSet
+00004ea0: 2872 6573 756c 7429 0a20 2020 2020 2020  (result).       
+00004eb0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00004ec0: 2020 2064 6174 6173 6f75 7263 6520 3d20     datasource = 
+00004ed0: 6764 616c 2e4f 7065 6e45 7828 7374 7228  gdal.OpenEx(str(
+00004ee0: 7061 7468 292c 206e 4f70 656e 466c 6167  path), nOpenFlag
+00004ef0: 733d 6764 616c 2e4f 465f 5550 4441 5445  s=gdal.OF_UPDATE
+00004f00: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00004f10: 7375 6c74 203d 2064 6174 6173 6f75 7263  sult = datasourc
+00004f20: 652e 4578 6563 7574 6553 514c 2866 2743  e.ExecuteSQL(f'C
+00004f30: 5245 4154 4520 5350 4154 4941 4c20 494e  REATE SPATIAL IN
+00004f40: 4445 5820 4f4e 2022 7b6c 6179 6572 7d22  DEX ON "{layer}"
+00004f50: 2729 0a20 2020 2020 2020 2020 2020 2064  ').            d
+00004f60: 6174 6173 6f75 7263 652e 5265 6c65 6173  atasource.Releas
+00004f70: 6552 6573 756c 7453 6574 2872 6573 756c  eResultSet(resul
+00004f80: 7429 0a0a 2020 2020 6578 6365 7074 2045  t)..    except E
+00004f90: 7863 6570 7469 6f6e 2061 7320 6578 3a0a  xception as ex:.
+00004fa0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+00004fb0: 7461 6e63 6528 6578 2c20 5661 6c75 6545  tance(ex, ValueE
+00004fc0: 7272 6f72 2920 616e 6420 7374 7228 6578  rror) and str(ex
+00004fd0: 292e 7374 6172 7473 7769 7468 280a 2020  ).startswith(.  
+00004fe0: 2020 2020 2020 2020 2020 2268 6173 5f73            "has_s
+00004ff0: 7061 7469 616c 5f69 6e64 6578 206e 6f74  patial_index not
+00005000: 2073 7570 706f 7274 6564 2066 6f72 220a   supported for".
+00005010: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
+00005020: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+00005030: 7565 4572 726f 7228 0a20 2020 2020 2020  ueError(.       
+00005040: 2020 2020 2020 2020 2066 2263 7265 6174           f"creat
+00005050: 655f 7370 6174 6961 6c5f 696e 6465 7820  e_spatial_index 
+00005060: 6e6f 7420 7375 7070 6f72 7465 6420 666f  not supported fo
+00005070: 7220 7b70 6174 685f 696e 666f 2e64 7269  r {path_info.dri
+00005080: 7665 727d 3a20 7b70 6174 687d 220a 2020  ver}: {path}".  
+00005090: 2020 2020 2020 2020 2020 2920 6672 6f6d            ) from
+000050a0: 2065 780a 2020 2020 2020 2020 656c 7365   ex.        else
+000050b0: 3a0a 2020 2020 2020 2020 2020 2020 6578  :.            ex
+000050c0: 2e61 7267 7320 3d20 2866 2263 7265 6174  .args = (f"creat
+000050d0: 655f 7370 6174 6961 6c5f 696e 6465 7820  e_spatial_index 
+000050e0: 6572 726f 723a 207b 6578 7d2c 2066 6f72  error: {ex}, for
+000050f0: 207b 7061 7468 7d2e 7b6c 6179 6572 7d22   {path}.{layer}"
+00005100: 2c29 0a20 2020 2020 2020 2072 6169 7365  ,).        raise
+00005110: 0a20 2020 2066 696e 616c 6c79 3a0a 2020  .    finally:.  
+00005120: 2020 2020 2020 6461 7461 736f 7572 6365        datasource
+00005130: 203d 204e 6f6e 650a 0a20 2020 2069 6620   = None..    if 
+00005140: 6e6f 7420 6861 735f 7370 6174 6961 6c5f  not has_spatial_
+00005150: 696e 6465 7828 7061 7468 2c20 6c61 7965  index(path, laye
+00005160: 7229 3a0a 2020 2020 2020 2020 7261 6973  r):.        rais
+00005170: 6520 5275 6e74 696d 6545 7272 6f72 2866  e RuntimeError(f
+00005180: 2263 7265 6174 655f 7370 6174 6961 6c5f  "create_spatial_
+00005190: 696e 6465 7820 6661 696c 6564 206f 6e20  index failed on 
+000051a0: 7b70 6174 687d 2c20 6c61 7965 723a 207b  {path}, layer: {
+000051b0: 6c61 7965 727d 2229 0a0a 0a64 6566 2068  layer}")...def h
+000051c0: 6173 5f73 7061 7469 616c 5f69 6e64 6578  as_spatial_index
+000051d0: 280a 2020 2020 7061 7468 3a20 556e 696f  (.    path: Unio
+000051e0: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
+000051f0: 696b 655b 416e 795d 225d 2c0a 2020 2020  ike[Any]"],.    
+00005200: 6c61 7965 723a 204f 7074 696f 6e61 6c5b  layer: Optional[
+00005210: 7374 725d 203d 204e 6f6e 652c 0a20 2020  str] = None,.   
+00005220: 206e 6f5f 6765 6f6d 5f6f 6b3a 2062 6f6f   no_geom_ok: boo
+00005230: 6c20 3d20 4661 6c73 652c 0a29 202d 3e20  l = False,.) -> 
+00005240: 626f 6f6c 3a0a 2020 2020 2222 220a 2020  bool:.    """.  
+00005250: 2020 4368 6563 6b20 6966 2074 6865 206c    Check if the l
+00005260: 6179 6572 2f63 6f6c 756d 6e20 6861 7320  ayer/column has 
+00005270: 6120 7370 6174 6961 6c20 696e 6465 782e  a spatial index.
+00005280: 0a0a 2020 2020 4172 6773 3a0a 2020 2020  ..    Args:.    
+00005290: 2020 2020 7061 7468 2028 5061 7468 4c69      path (PathLi
+000052a0: 6b65 293a 2054 6865 2066 696c 6520 7061  ke): The file pa
+000052b0: 7468 2e0a 2020 2020 2020 2020 6c61 7965  th..        laye
+000052c0: 7220 2873 7472 2c20 6f70 7469 6f6e 616c  r (str, optional
+000052d0: 293a 2054 6865 206c 6179 6572 2e20 4465  ): The layer. De
+000052e0: 6661 756c 7473 2074 6f20 4e6f 6e65 2e0a  faults to None..
+000052f0: 2020 2020 2020 2020 6e6f 5f67 656f 6d5f          no_geom_
+00005300: 6f6b 2028 626f 6f6c 2c20 6f70 7469 6f6e  ok (bool, option
+00005310: 7329 3a20 4966 2054 7275 6520 616e 6420  s): If True and 
+00005320: 7468 6520 6669 6c65 2064 6f65 736e 2774  the file doesn't
+00005330: 2068 6176 6520 6120 6765 6f6d 6574 7279   have a geometry
+00005340: 2063 6f6c 756d 6e2c 0a20 2020 2020 2020   column,.       
+00005350: 2020 2020 2064 6f6e 2774 2074 6872 6f77       don't throw
+00005360: 2061 6e20 6572 726f 722e 2044 6566 6175   an error. Defau
+00005370: 6c74 7320 746f 2046 616c 7365 2e0a 0a20  lts to False... 
+00005380: 2020 2052 6169 7365 733a 0a20 2020 2020     Raises:.     
+00005390: 2020 2056 616c 7565 4572 726f 723a 2061     ValueError: a
+000053a0: 6e20 696e 7661 6c69 6420 7061 7261 6d65  n invalid parame
+000053b0: 7465 7220 7661 6c75 6520 7761 7320 7061  ter value was pa
+000053c0: 7373 6564 2e0a 0a20 2020 2052 6574 7572  ssed...    Retur
+000053d0: 6e73 3a0a 2020 2020 2020 2020 626f 6f6c  ns:.        bool
+000053e0: 3a20 5472 7565 2069 6620 6120 7370 6174  : True if a spat
+000053f0: 6961 6c20 696e 6465 7820 6578 6973 7473  ial index exists
+00005400: 2c20 4661 6c73 6520 6966 2069 7420 646f  , False if it do
+00005410: 6573 6e27 7420 6578 6973 742e 0a20 2020  esn't exist..   
+00005420: 2022 2222 0a20 2020 2023 2049 6e69 740a   """.    # Init.
+00005430: 2020 2020 7061 7468 203d 2050 6174 6828      path = Path(
+00005440: 7061 7468 290a 0a20 2020 2023 204e 6f77  path)..    # Now
+00005450: 2063 6865 636b 2074 6865 2069 6e64 6578   check the index
+00005460: 0a20 2020 2064 6174 6173 6f75 7263 6520  .    datasource 
+00005470: 3d20 4e6f 6e65 0a20 2020 2070 6174 685f  = None.    path_
+00005480: 696e 666f 203d 205f 6765 6f66 696c 6569  info = _geofilei
+00005490: 6e66 6f2e 6765 745f 6765 6f66 696c 6569  nfo.get_geofilei
+000054a0: 6e66 6f28 7061 7468 290a 2020 2020 7472  nfo(path).    tr
+000054b0: 793a 0a20 2020 2020 2020 2069 6620 7061  y:.        if pa
+000054c0: 7468 5f69 6e66 6f2e 6973 5f73 7061 7469  th_info.is_spati
+000054d0: 616c 6974 655f 6261 7365 643a 0a20 2020  alite_based:.   
+000054e0: 2020 2020 2020 2020 206c 6179 6572 696e           layerin
+000054f0: 666f 203d 2067 6574 5f6c 6179 6572 696e  fo = get_layerin
+00005500: 666f 2870 6174 682c 206c 6179 6572 2c20  fo(path, layer, 
+00005510: 7261 6973 655f 6f6e 5f6e 6f67 656f 6d3d  raise_on_nogeom=
+00005520: 6e6f 7420 6e6f 5f67 656f 6d5f 6f6b 290a  not no_geom_ok).
+00005530: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00005540: 6f5f 6765 6f6d 5f6f 6b20 616e 6420 6c61  o_geom_ok and la
+00005550: 7965 7269 6e66 6f2e 6765 6f6d 6574 7279  yerinfo.geometry
+00005560: 636f 6c75 6d6e 2069 7320 4e6f 6e65 3a0a  column is None:.
+00005570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005580: 7265 7475 726e 2046 616c 7365 0a20 2020  return False.   
+00005590: 2020 2020 2020 2020 2064 6174 6173 6f75           datasou
+000055a0: 7263 6520 3d20 6764 616c 2e4f 7065 6e45  rce = gdal.OpenE
+000055b0: 7828 7374 7228 7061 7468 292c 206e 4f70  x(str(path), nOp
+000055c0: 656e 466c 6167 733d 6764 616c 2e4f 465f  enFlags=gdal.OF_
+000055d0: 5245 4144 4f4e 4c59 290a 2020 2020 2020  READONLY).      
+000055e0: 2020 2020 2020 7371 6c20 3d20 6622 2222        sql = f"""
+000055f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005600: 2053 454c 4543 5420 4861 7353 7061 7469   SELECT HasSpati
+00005610: 616c 496e 6465 7828 277b 6c61 7965 7269  alIndex('{layeri
+00005620: 6e66 6f2e 6e61 6d65 7d27 2c0a 2020 2020  nfo.name}',.    
+00005630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005650: 2020 2027 7b6c 6179 6572 696e 666f 2e67     '{layerinfo.g
+00005660: 656f 6d65 7472 7963 6f6c 756d 6e7d 2729  eometrycolumn}')
+00005670: 0a20 2020 2020 2020 2020 2020 2022 2222  .            """
+00005680: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
+00005690: 756c 7420 3d20 6461 7461 736f 7572 6365  ult = datasource
+000056a0: 2e45 7865 6375 7465 5351 4c28 7371 6c2c  .ExecuteSQL(sql,
+000056b0: 2064 6961 6c65 6374 3d22 5351 4c49 5445   dialect="SQLITE
+000056c0: 2229 0a20 2020 2020 2020 2020 2020 2068  ").            h
+000056d0: 6173 5f73 7061 7469 616c 5f69 6e64 6578  as_spatial_index
+000056e0: 203d 2072 6573 756c 742e 4765 744e 6578   = result.GetNex
+000056f0: 7446 6561 7475 7265 2829 2e47 6574 4669  tFeature().GetFi
+00005700: 656c 6428 3029 203d 3d20 310a 2020 2020  eld(0) == 1.    
+00005710: 2020 2020 2020 2020 6461 7461 736f 7572          datasour
+00005720: 6365 2e52 656c 6561 7365 5265 7375 6c74  ce.ReleaseResult
+00005730: 5365 7428 7265 7375 6c74 290a 2020 2020  Set(result).    
+00005740: 2020 2020 2020 2020 7265 7475 726e 2068          return h
+00005750: 6173 5f73 7061 7469 616c 5f69 6e64 6578  as_spatial_index
+00005760: 0a20 2020 2020 2020 2065 6c69 6620 7061  .        elif pa
+00005770: 7468 5f69 6e66 6f2e 6472 6976 6572 203d  th_info.driver =
+00005780: 3d20 2245 5352 4920 5368 6170 6566 696c  = "ESRI Shapefil
+00005790: 6522 3a0a 2020 2020 2020 2020 2020 2020  e":.            
+000057a0: 696e 6465 785f 7061 7468 203d 2070 6174  index_path = pat
+000057b0: 682e 7061 7265 6e74 202f 2066 227b 7061  h.parent / f"{pa
+000057c0: 7468 2e73 7465 6d7d 2e71 6978 220a 2020  th.stem}.qix".  
+000057d0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000057e0: 2069 6e64 6578 5f70 6174 682e 6578 6973   index_path.exis
+000057f0: 7473 2829 0a20 2020 2020 2020 2065 6c73  ts().        els
+00005800: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+00005810: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+00005820: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005830: 2066 2268 6173 5f73 7061 7469 616c 5f69   f"has_spatial_i
+00005840: 6e64 6578 206e 6f74 2073 7570 706f 7274  ndex not support
+00005850: 6564 2066 6f72 207b 7061 7468 5f69 6e66  ed for {path_inf
+00005860: 6f2e 6472 6976 6572 7d3a 207b 7061 7468  o.driver}: {path
+00005870: 7d22 0a20 2020 2020 2020 2020 2020 2029  }".            )
+00005880: 0a0a 2020 2020 6578 6365 7074 2056 616c  ..    except Val
+00005890: 7565 4572 726f 723a 0a20 2020 2020 2020  ueError:.       
+000058a0: 2072 6169 7365 0a20 2020 2065 7863 6570   raise.    excep
+000058b0: 7420 4578 6365 7074 696f 6e20 6173 2065  t Exception as e
+000058c0: 783a 0a20 2020 2020 2020 2065 782e 6172  x:.        ex.ar
+000058d0: 6773 203d 2028 6622 6861 735f 7370 6174  gs = (f"has_spat
+000058e0: 6961 6c5f 696e 6465 7820 6572 726f 723a  ial_index error:
+000058f0: 207b 6578 7d2c 2066 6f72 207b 7061 7468   {ex}, for {path
+00005900: 7d2e 7b6c 6179 6572 7d22 2c29 0a20 2020  }.{layer}",).   
+00005910: 2020 2020 2072 6169 7365 0a20 2020 2066       raise.    f
+00005920: 696e 616c 6c79 3a0a 2020 2020 2020 2020  inally:.        
+00005930: 6461 7461 736f 7572 6365 203d 204e 6f6e  datasource = Non
+00005940: 650a 0a0a 6465 6620 7265 6d6f 7665 5f73  e...def remove_s
+00005950: 7061 7469 616c 5f69 6e64 6578 280a 2020  patial_index(.  
+00005960: 2020 7061 7468 3a20 556e 696f 6e5b 7374    path: Union[st
+00005970: 722c 2022 6f73 2e50 6174 684c 696b 655b  r, "os.PathLike[
+00005980: 416e 795d 225d 2c20 6c61 7965 723a 204f  Any]"], layer: O
+00005990: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
+000059a0: 6f6e 650a 293a 0a20 2020 2022 2222 0a20  one.):.    """. 
+000059b0: 2020 2052 656d 6f76 6520 7468 6520 7370     Remove the sp
+000059c0: 6174 6961 6c20 696e 6465 7820 6672 6f6d  atial index from
+000059d0: 2074 6865 206c 6179 6572 2073 7065 6369   the layer speci
+000059e0: 6669 6564 2e0a 0a20 2020 2041 7267 733a  fied...    Args:
+000059f0: 0a20 2020 2020 2020 2070 6174 6820 2850  .        path (P
+00005a00: 6174 684c 696b 6529 3a20 5468 6520 6669  athLike): The fi
+00005a10: 6c65 2070 6174 682e 0a20 2020 2020 2020  le path..       
+00005a20: 206c 6179 6572 2028 7374 722c 206f 7074   layer (str, opt
+00005a30: 696f 6e61 6c29 3a20 5468 6520 6c61 7965  ional): The laye
+00005a40: 722e 2049 6620 6e6f 7420 7370 6563 6966  r. If not specif
+00005a50: 6965 642c 2061 6e64 2074 6865 7265 2069  ied, and there i
+00005a60: 7320 6f6e 6c79 0a20 2020 2020 2020 2020  s only.         
+00005a70: 2020 206f 6e65 206c 6179 6572 2069 6e20     one layer in 
+00005a80: 7468 6520 6669 6c65 2c20 7468 6973 206c  the file, this l
+00005a90: 6179 6572 2069 7320 7573 6564 2e20 4f74  ayer is used. Ot
+00005aa0: 6865 7277 6973 6520 6578 6365 7074 696f  herwise exceptio
+00005ab0: 6e2e 0a20 2020 2022 2222 0a20 2020 2023  n..    """.    #
+00005ac0: 2049 6e69 740a 2020 2020 7061 7468 203d   Init.    path =
+00005ad0: 2050 6174 6828 7061 7468 290a 0a20 2020   Path(path)..   
+00005ae0: 2023 204e 6f77 2072 6561 6c6c 7920 7265   # Now really re
+00005af0: 6d6f 7665 2069 6e64 6578 0a20 2020 2064  move index.    d
+00005b00: 6174 6173 6f75 7263 6520 3d20 4e6f 6e65  atasource = None
+00005b10: 0a20 2020 2070 6174 685f 696e 666f 203d  .    path_info =
+00005b20: 205f 6765 6f66 696c 6569 6e66 6f2e 6765   _geofileinfo.ge
+00005b30: 745f 6765 6f66 696c 6569 6e66 6f28 7061  t_geofileinfo(pa
+00005b40: 7468 290a 2020 2020 7061 7468 5f6c 6179  th).    path_lay
+00005b50: 6572 696e 666f 203d 2067 6574 5f6c 6179  erinfo = get_lay
+00005b60: 6572 696e 666f 2870 6174 682c 206c 6179  erinfo(path, lay
+00005b70: 6572 290a 2020 2020 7472 793a 0a20 2020  er).    try:.   
+00005b80: 2020 2020 2069 6620 7061 7468 5f69 6e66       if path_inf
+00005b90: 6f2e 6973 5f73 7061 7469 616c 6974 655f  o.is_spatialite_
+00005ba0: 6261 7365 643a 0a20 2020 2020 2020 2020  based:.         
+00005bb0: 2020 2064 6174 6173 6f75 7263 6520 3d20     datasource = 
+00005bc0: 6764 616c 2e4f 7065 6e45 7828 7374 7228  gdal.OpenEx(str(
+00005bd0: 7061 7468 292c 206e 4f70 656e 466c 6167  path), nOpenFlag
+00005be0: 733d 6764 616c 2e4f 465f 5550 4441 5445  s=gdal.OF_UPDATE
+00005bf0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00005c00: 7375 6c74 203d 2064 6174 6173 6f75 7263  sult = datasourc
+00005c10: 652e 4578 6563 7574 6553 514c 280a 2020  e.ExecuteSQL(.  
+00005c20: 2020 2020 2020 2020 2020 2020 2020 2253                "S
+00005c30: 454c 4543 5420 4469 7361 626c 6553 7061  ELECT DisableSpa
+00005c40: 7469 616c 496e 6465 7828 220a 2020 2020  tialIndex(".    
+00005c50: 2020 2020 2020 2020 2020 2020 6622 2020              f"  
+00005c60: 2020 2020 277b 7061 7468 5f6c 6179 6572      '{path_layer
+00005c70: 696e 666f 2e6e 616d 657d 272c 2027 7b70  info.name}', '{p
+00005c80: 6174 685f 6c61 7965 7269 6e66 6f2e 6765  ath_layerinfo.ge
+00005c90: 6f6d 6574 7279 636f 6c75 6d6e 7d27 2922  ometrycolumn}')"
+00005ca0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00005cb0: 2020 6469 616c 6563 743d 2253 514c 4954    dialect="SQLIT
+00005cc0: 4522 2c0a 2020 2020 2020 2020 2020 2020  E",.            
+00005cd0: 290a 2020 2020 2020 2020 2020 2020 6461  ).            da
+00005ce0: 7461 736f 7572 6365 2e52 656c 6561 7365  tasource.Release
+00005cf0: 5265 7375 6c74 5365 7428 7265 7375 6c74  ResultSet(result
+00005d00: 290a 2020 2020 2020 2020 656c 6966 2070  ).        elif p
+00005d10: 6174 685f 696e 666f 2e64 7269 7665 7220  ath_info.driver 
+00005d20: 3d3d 2022 4553 5249 2053 6861 7065 6669  == "ESRI Shapefi
+00005d30: 6c65 223a 0a20 2020 2020 2020 2020 2020  le":.           
+00005d40: 2023 2044 524f 5020 5350 4154 4941 4c20   # DROP SPATIAL 
+00005d50: 494e 4445 5820 4f4e 202e 2e2e 2063 6f6d  INDEX ON ... com
+00005d60: 6d61 6e64 2067 6976 6573 2061 6e20 6572  mand gives an er
+00005d70: 726f 722c 2073 6f20 6a75 7374 2072 656d  ror, so just rem
+00005d80: 6f76 6520 2e71 6978 0a20 2020 2020 2020  ove .qix.       
+00005d90: 2020 2020 2069 6e64 6578 5f70 6174 6820       index_path 
+00005da0: 3d20 7061 7468 2e70 6172 656e 7420 2f20  = path.parent / 
+00005db0: 6622 7b70 6174 682e 7374 656d 7d2e 7169  f"{path.stem}.qi
+00005dc0: 7822 0a20 2020 2020 2020 2020 2020 2069  x".            i
+00005dd0: 6e64 6578 5f70 6174 682e 756e 6c69 6e6b  ndex_path.unlink
+00005de0: 2829 0a20 2020 2020 2020 2065 6c73 653a  ().        else:
+00005df0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00005e00: 7365 2056 616c 7565 4572 726f 7228 0a20  se ValueError(. 
+00005e10: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00005e20: 2272 656d 6f76 655f 7370 6174 6961 6c5f  "remove_spatial_
+00005e30: 696e 6465 7820 6e6f 7420 7375 7070 6f72  index not suppor
+00005e40: 7465 6420 666f 7220 7b70 6174 685f 696e  ted for {path_in
+00005e50: 666f 2e64 7269 7665 727d 3a20 7b70 6174  fo.driver}: {pat
+00005e60: 687d 220a 2020 2020 2020 2020 2020 2020  h}".            
+00005e70: 290a 0a20 2020 2065 7863 6570 7420 5661  )..    except Va
+00005e80: 6c75 6545 7272 6f72 3a0a 2020 2020 2020  lueError:.      
+00005e90: 2020 7261 6973 650a 2020 2020 6578 6365    raise.    exce
+00005ea0: 7074 2045 7863 6570 7469 6f6e 2061 7320  pt Exception as 
+00005eb0: 6578 3a0a 2020 2020 2020 2020 6578 2e61  ex:.        ex.a
+00005ec0: 7267 7320 3d20 2866 2272 656d 6f76 655f  rgs = (f"remove_
+00005ed0: 7370 6174 6961 6c5f 696e 6465 7820 6572  spatial_index er
+00005ee0: 726f 723a 207b 6578 7d2c 2066 6f72 207b  ror: {ex}, for {
+00005ef0: 7061 7468 7d2e 7b6c 6179 6572 7d22 2c29  path}.{layer}",)
+00005f00: 0a20 2020 2020 2020 2072 6169 7365 0a20  .        raise. 
+00005f10: 2020 2066 696e 616c 6c79 3a0a 2020 2020     finally:.    
+00005f20: 2020 2020 6461 7461 736f 7572 6365 203d      datasource =
+00005f30: 204e 6f6e 650a 0a0a 6465 6620 7265 6e61   None...def rena
+00005f40: 6d65 5f6c 6179 6572 280a 2020 2020 7061  me_layer(.    pa
+00005f50: 7468 3a20 556e 696f 6e5b 7374 722c 2022  th: Union[str, "
+00005f60: 6f73 2e50 6174 684c 696b 655b 416e 795d  os.PathLike[Any]
+00005f70: 225d 2c20 6e65 775f 6c61 7965 723a 2073  "], new_layer: s
+00005f80: 7472 2c20 6c61 7965 723a 204f 7074 696f  tr, layer: Optio
+00005f90: 6e61 6c5b 7374 725d 203d 204e 6f6e 650a  nal[str] = None.
+00005fa0: 293a 0a20 2020 2022 2222 0a20 2020 2052  ):.    """.    R
+00005fb0: 656e 616d 6520 7468 6520 6c61 7965 7220  ename the layer 
+00005fc0: 7370 6563 6966 6965 642e 0a0a 2020 2020  specified...    
+00005fd0: 4172 6773 3a0a 2020 2020 2020 2020 7061  Args:.        pa
+00005fe0: 7468 2028 5061 7468 4c69 6b65 293a 2054  th (PathLike): T
+00005ff0: 6865 2066 696c 6520 7061 7468 2e0a 2020  he file path..  
+00006000: 2020 2020 2020 6c61 7965 7220 284f 7074        layer (Opt
+00006010: 696f 6e61 6c5b 7374 725d 293a 2054 6865  ional[str]): The
+00006020: 206c 6179 6572 206e 616d 652e 2049 6620   layer name. If 
+00006030: 6e6f 7420 7370 6563 6966 6965 642c 2061  not specified, a
+00006040: 6e64 2074 6865 7265 2069 7320 6f6e 6c79  nd there is only
+00006050: 0a20 2020 2020 2020 2020 2020 206f 6e65  .            one
+00006060: 206c 6179 6572 2069 6e20 7468 6520 6669   layer in the fi
+00006070: 6c65 2c20 7468 6973 206c 6179 6572 2069  le, this layer i
+00006080: 7320 7573 6564 2e20 4f74 6865 7277 6973  s used. Otherwis
+00006090: 6520 6578 6365 7074 696f 6e2e 0a20 2020  e exception..   
+000060a0: 2020 2020 206e 6577 5f6c 6179 6572 2028       new_layer (
+000060b0: 7374 7229 3a20 5468 6520 6e65 7720 6c61  str): The new la
+000060c0: 7965 7220 6e61 6d65 2e20 4966 206e 6f74  yer name. If not
+000060d0: 2073 7065 6369 6669 6564 2c20 616e 6420   specified, and 
+000060e0: 7468 6572 6520 6973 206f 6e6c 790a 2020  there is only.  
+000060f0: 2020 2020 2020 2020 2020 6f6e 6520 6c61            one la
+00006100: 7965 7220 696e 2074 6865 2066 696c 652c  yer in the file,
+00006110: 2074 6869 7320 6c61 7965 7220 6973 2075   this layer is u
+00006120: 7365 642e 204f 7468 6572 7769 7365 2065  sed. Otherwise e
+00006130: 7863 6570 7469 6f6e 2e0a 2020 2020 2222  xception..    ""
+00006140: 220a 2020 2020 2320 4368 6563 6b20 696e  ".    # Check in
+00006150: 7075 7420 7061 7261 6d65 7465 7273 0a20  put parameters. 
+00006160: 2020 2070 6174 6820 3d20 5061 7468 2870     path = Path(p
+00006170: 6174 6829 0a20 2020 2069 6620 6c61 7965  ath).    if laye
+00006180: 7220 6973 204e 6f6e 653a 0a20 2020 2020  r is None:.     
+00006190: 2020 206c 6179 6572 203d 2067 6574 5f6f     layer = get_o
+000061a0: 6e6c 795f 6c61 7965 7228 7061 7468 290a  nly_layer(path).
+000061b0: 0a20 2020 2023 2052 656e 616d 696e 6720  .    # Renaming 
+000061c0: 7468 6520 6c61 7965 7220 6e61 6d65 2069  the layer name i
+000061d0: 7320 6e6f 7420 706f 7373 6962 6c65 2066  s not possible f
+000061e0: 6f72 2073 696e 676c 6520 6c61 7965 7220  or single layer 
+000061f0: 6669 6c65 2066 6f72 6d61 7473 2e0a 2020  file formats..  
+00006200: 2020 7061 7468 5f69 6e66 6f20 3d20 5f67    path_info = _g
+00006210: 656f 6669 6c65 696e 666f 2e67 6574 5f67  eofileinfo.get_g
+00006220: 656f 6669 6c65 696e 666f 2870 6174 6829  eofileinfo(path)
+00006230: 0a20 2020 2069 6620 7061 7468 5f69 6e66  .    if path_inf
+00006240: 6f2e 6973 5f73 696e 676c 656c 6179 6572  o.is_singlelayer
+00006250: 3a0a 2020 2020 2020 2020 7261 6973 6520  :.        raise 
+00006260: 5661 6c75 6545 7272 6f72 2866 2272 656e  ValueError(f"ren
+00006270: 616d 655f 6c61 7965 7220 6e6f 7420 706f  ame_layer not po
+00006280: 7373 6962 6c65 2066 6f72 207b 7061 7468  ssible for {path
+00006290: 5f69 6e66 6f2e 6472 6976 6572 7d20 6669  _info.driver} fi
+000062a0: 6c65 2229 0a0a 2020 2020 2320 4e6f 7720  le")..    # Now 
+000062b0: 7265 616c 6c79 2072 656e 616d 650a 2020  really rename.  
+000062c0: 2020 6461 7461 736f 7572 6365 203d 204e    datasource = N
+000062d0: 6f6e 650a 2020 2020 7472 793a 0a20 2020  one.    try:.   
+000062e0: 2020 2020 2064 6174 6173 6f75 7263 6520       datasource 
+000062f0: 3d20 6764 616c 2e4f 7065 6e45 7828 7374  = gdal.OpenEx(st
+00006300: 7228 7061 7468 292c 206e 4f70 656e 466c  r(path), nOpenFl
+00006310: 6167 733d 6764 616c 2e4f 465f 5550 4441  ags=gdal.OF_UPDA
+00006320: 5445 290a 2020 2020 2020 2020 7371 6c5f  TE).        sql_
+00006330: 7374 6d74 203d 2066 2741 4c54 4552 2054  stmt = f'ALTER T
+00006340: 4142 4c45 2022 7b6c 6179 6572 7d22 2052  ABLE "{layer}" R
+00006350: 454e 414d 4520 544f 2022 7b6e 6577 5f6c  ENAME TO "{new_l
+00006360: 6179 6572 7d22 270a 2020 2020 2020 2020  ayer}"'.        
+00006370: 7265 7375 6c74 203d 2064 6174 6173 6f75  result = datasou
+00006380: 7263 652e 4578 6563 7574 6553 514c 2873  rce.ExecuteSQL(s
+00006390: 716c 5f73 746d 7429 0a20 2020 2020 2020  ql_stmt).       
+000063a0: 2064 6174 6173 6f75 7263 652e 5265 6c65   datasource.Rele
+000063b0: 6173 6552 6573 756c 7453 6574 2872 6573  aseResultSet(res
+000063c0: 756c 7429 0a20 2020 2065 7863 6570 7420  ult).    except 
+000063d0: 4578 6365 7074 696f 6e20 6173 2065 783a  Exception as ex:
+000063e0: 0a20 2020 2020 2020 2065 782e 6172 6773  .        ex.args
+000063f0: 203d 2028 6622 7265 6e61 6d65 5f6c 6179   = (f"rename_lay
+00006400: 6572 2065 7272 6f72 3a20 7b65 787d 2c20  er error: {ex}, 
+00006410: 666f 7220 7b70 6174 687d 2e7b 6c61 7965  for {path}.{laye
+00006420: 727d 222c 290a 2020 2020 2020 2020 7261  r}",).        ra
+00006430: 6973 650a 2020 2020 6669 6e61 6c6c 793a  ise.    finally:
+00006440: 0a20 2020 2020 2020 2064 6174 6173 6f75  .        datasou
+00006450: 7263 6520 3d20 4e6f 6e65 0a0a 0a64 6566  rce = None...def
+00006460: 2072 656e 616d 655f 636f 6c75 6d6e 280a   rename_column(.
+00006470: 2020 2020 7061 7468 3a20 556e 696f 6e5b      path: Union[
+00006480: 7374 722c 2022 6f73 2e50 6174 684c 696b  str, "os.PathLik
+00006490: 655b 416e 795d 225d 2c0a 2020 2020 636f  e[Any]"],.    co
+000064a0: 6c75 6d6e 5f6e 616d 653a 2073 7472 2c0a  lumn_name: str,.
+000064b0: 2020 2020 6e65 775f 636f 6c75 6d6e 5f6e      new_column_n
+000064c0: 616d 653a 2073 7472 2c0a 2020 2020 6c61  ame: str,.    la
+000064d0: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
+000064e0: 725d 203d 204e 6f6e 652c 0a29 3a0a 2020  r] = None,.):.  
+000064f0: 2020 2222 220a 2020 2020 5265 6e61 6d65    """.    Rename
+00006500: 2074 6865 2063 6f6c 756d 6e20 7370 6563   the column spec
+00006510: 6966 6965 642e 0a0a 2020 2020 4172 6773  ified...    Args
+00006520: 3a0a 2020 2020 2020 2020 7061 7468 2028  :.        path (
+00006530: 5061 7468 4c69 6b65 293a 2074 6865 2066  PathLike): the f
+00006540: 696c 6520 7061 7468 2e0a 2020 2020 2020  ile path..      
+00006550: 2020 636f 6c75 6d6e 5f6e 616d 6520 2873    column_name (s
+00006560: 7472 293a 2063 7572 7265 6e74 2063 6f6c  tr): current col
+00006570: 756d 6e20 6e61 6d65 2e0a 2020 2020 2020  umn name..      
+00006580: 2020 6e65 775f 636f 6c75 6d6e 5f6e 616d    new_column_nam
+00006590: 6520 2873 7472 293a 206e 6577 2063 6f6c  e (str): new col
+000065a0: 756d 6e20 6e61 6d65 2e0a 2020 2020 2020  umn name..      
+000065b0: 2020 6c61 7965 7220 284f 7074 696f 6e61    layer (Optiona
+000065c0: 6c5b 7374 725d 293a 206c 6179 6572 206e  l[str]): layer n
+000065d0: 616d 652e 2049 6620 6e6f 7420 7370 6563  ame. If not spec
+000065e0: 6966 6965 642c 2061 6e64 2074 6865 7265  ified, and there
+000065f0: 2069 7320 6f6e 6c79 0a20 2020 2020 2020   is only.       
+00006600: 2020 2020 206f 6e65 206c 6179 6572 2069       one layer i
+00006610: 6e20 7468 6520 6669 6c65 2c20 7468 6973  n the file, this
+00006620: 206c 6179 6572 2069 7320 7573 6564 2e20   layer is used. 
+00006630: 4f74 6865 7277 6973 6520 6578 6365 7074  Otherwise except
+00006640: 696f 6e2e 0a20 2020 2022 2222 0a20 2020  ion..    """.   
+00006650: 2023 2043 6865 636b 2069 6e70 7574 2070   # Check input p
+00006660: 6172 616d 6574 6572 730a 2020 2020 7061  arameters.    pa
+00006670: 7468 203d 2050 6174 6828 7061 7468 290a  th = Path(path).
+00006680: 2020 2020 6966 206c 6179 6572 2069 7320      if layer is 
+00006690: 4e6f 6e65 3a0a 2020 2020 2020 2020 6c61  None:.        la
+000066a0: 7965 7220 3d20 6765 745f 6f6e 6c79 5f6c  yer = get_only_l
+000066b0: 6179 6572 2870 6174 6829 0a20 2020 2069  ayer(path).    i
+000066c0: 6e66 6f20 3d20 6765 745f 6c61 7965 7269  nfo = get_layeri
+000066d0: 6e66 6f28 7061 7468 2c20 6c61 7965 722c  nfo(path, layer,
+000066e0: 2072 6169 7365 5f6f 6e5f 6e6f 6765 6f6d   raise_on_nogeom
+000066f0: 3d46 616c 7365 290a 2020 2020 6966 2063  =False).    if c
+00006700: 6f6c 756d 6e5f 6e61 6d65 206e 6f74 2069  olumn_name not i
+00006710: 6e20 696e 666f 2e63 6f6c 756d 6e73 2061  n info.columns a
+00006720: 6e64 206e 6577 5f63 6f6c 756d 6e5f 6e61  nd new_column_na
+00006730: 6d65 2069 6e20 696e 666f 2e63 6f6c 756d  me in info.colum
+00006740: 6e73 3a0a 2020 2020 2020 2020 6c6f 6767  ns:.        logg
+00006750: 6572 2e69 6e66 6f28 0a20 2020 2020 2020  er.info(.       
+00006760: 2020 2020 2066 2243 6f6c 756d 6e20 7b63       f"Column {c
+00006770: 6f6c 756d 6e5f 6e61 6d65 7d20 7365 656d  olumn_name} seem
+00006780: 7320 746f 2062 6520 7265 6e61 6d65 6420  s to be renamed 
+00006790: 616c 7265 6164 7920 746f 207b 6e65 775f  already to {new_
+000067a0: 636f 6c75 6d6e 5f6e 616d 657d 220a 2020  column_name}".  
+000067b0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+000067c0: 7265 7475 726e 0a0a 2020 2020 2320 4e6f  return..    # No
+000067d0: 7720 7265 616c 6c79 2072 656e 616d 650a  w really rename.
+000067e0: 2020 2020 6461 7461 736f 7572 6365 203d      datasource =
+000067f0: 204e 6f6e 650a 2020 2020 7472 793a 0a20   None.    try:. 
+00006800: 2020 2020 2020 2064 6174 6173 6f75 7263         datasourc
+00006810: 6520 3d20 6764 616c 2e4f 7065 6e45 7828  e = gdal.OpenEx(
+00006820: 7374 7228 7061 7468 292c 206e 4f70 656e  str(path), nOpen
+00006830: 466c 6167 733d 6764 616c 2e4f 465f 5550  Flags=gdal.OF_UP
+00006840: 4441 5445 290a 2020 2020 2020 2020 6461  DATE).        da
+00006850: 7461 736f 7572 6365 5f6c 6179 6572 203d  tasource_layer =
+00006860: 2064 6174 6173 6f75 7263 652e 4765 744c   datasource.GetL
+00006870: 6179 6572 286c 6179 6572 290a 2020 2020  ayer(layer).    
+00006880: 2020 2020 6966 206e 6f74 2064 6174 6173      if not datas
+00006890: 6f75 7263 655f 6c61 7965 722e 5465 7374  ource_layer.Test
+000068a0: 4361 7061 6269 6c69 7479 2867 6461 6c2e  Capability(gdal.
+000068b0: 6f67 722e 4f4c 4341 6c74 6572 4669 656c  ogr.OLCAlterFiel
+000068c0: 6444 6566 6e29 3a0a 2020 2020 2020 2020  dDefn):.        
+000068d0: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
+000068e0: 7272 6f72 2866 2272 656e 616d 655f 636f  rror(f"rename_co
+000068f0: 6c75 6d6e 206e 6f74 2073 7570 706f 7274  lumn not support
+00006900: 6564 2066 6f72 207b 7061 7468 7d22 290a  ed for {path}").
+00006910: 0a20 2020 2020 2020 2023 2052 656e 616d  .        # Renam
+00006920: 6520 636f 6c75 6d6e 0a20 2020 2020 2020  e column.       
+00006930: 2073 716c 5f73 746d 7420 3d20 280a 2020   sql_stmt = (.  
+00006940: 2020 2020 2020 2020 2020 6627 414c 5445            f'ALTE
+00006950: 5220 5441 424c 4520 227b 6c61 7965 727d  R TABLE "{layer}
+00006960: 2220 270a 2020 2020 2020 2020 2020 2020  " '.            
+00006970: 6627 5245 4e41 4d45 2043 4f4c 554d 4e20  f'RENAME COLUMN 
+00006980: 227b 636f 6c75 6d6e 5f6e 616d 657d 2220  "{column_name}" 
+00006990: 544f 2022 7b6e 6577 5f63 6f6c 756d 6e5f  TO "{new_column_
+000069a0: 6e61 6d65 7d22 270a 2020 2020 2020 2020  name}"'.        
+000069b0: 290a 2020 2020 2020 2020 7265 7375 6c74  ).        result
+000069c0: 203d 2064 6174 6173 6f75 7263 652e 4578   = datasource.Ex
+000069d0: 6563 7574 6553 514c 2873 716c 5f73 746d  ecuteSQL(sql_stm
+000069e0: 7429 0a20 2020 2020 2020 2064 6174 6173  t).        datas
+000069f0: 6f75 7263 652e 5265 6c65 6173 6552 6573  ource.ReleaseRes
+00006a00: 756c 7453 6574 2872 6573 756c 7429 0a0a  ultSet(result)..
+00006a10: 2020 2020 6578 6365 7074 2045 7863 6570      except Excep
+00006a20: 7469 6f6e 2061 7320 6578 3a0a 2020 2020  tion as ex:.    
+00006a30: 2020 2020 2320 4966 2069 7420 6973 2074      # If it is t
+00006a40: 6865 2056 616c 7565 4572 726f 7220 7468  he ValueError th
+00006a50: 726f 776e 2061 626f 7665 2c20 6a75 7374  rown above, just
+00006a60: 2072 6169 7365 0a20 2020 2020 2020 2069   raise.        i
+00006a70: 6620 6973 696e 7374 616e 6365 2865 782c  f isinstance(ex,
+00006a80: 2056 616c 7565 4572 726f 7229 2061 6e64   ValueError) and
+00006a90: 2073 7472 2865 7829 2e73 7461 7274 7377   str(ex).startsw
+00006aa0: 6974 6828 0a20 2020 2020 2020 2020 2020  ith(.           
+00006ab0: 2022 7265 6e61 6d65 5f63 6f6c 756d 6e20   "rename_column 
+00006ac0: 6e6f 7420 7375 7070 6f72 7465 6420 666f  not supported fo
+00006ad0: 7222 0a20 2020 2020 2020 2029 3a0a 2020  r".        ):.  
+00006ae0: 2020 2020 2020 2020 2020 7261 6973 650a            raise.
+00006af0: 0a20 2020 2020 2020 2023 2049 7420 6973  .        # It is
+00006b00: 2061 6e6f 7468 6572 2065 7272 6f72 2e2e   another error..
+00006b10: 2e20 6164 6420 736f 6d65 206d 6f72 6520  . add some more 
+00006b20: 636f 6e74 6578 740a 2020 2020 2020 2020  context.        
+00006b30: 6578 2e61 7267 7320 3d20 2866 2272 656e  ex.args = (f"ren
+00006b40: 616d 655f 636f 6c75 6d6e 2065 7272 6f72  ame_column error
+00006b50: 3a20 7b65 787d 2066 6f72 207b 7061 7468  : {ex} for {path
+00006b60: 7d2e 7b6c 6179 6572 7d22 2c29 0a20 2020  }.{layer}",).   
+00006b70: 2020 2020 2072 6169 7365 0a20 2020 2066       raise.    f
+00006b80: 696e 616c 6c79 3a0a 2020 2020 2020 2020  inally:.        
+00006b90: 6461 7461 736f 7572 6365 203d 204e 6f6e  datasource = Non
+00006ba0: 650a 0a0a 636c 6173 7320 4461 7461 5479  e...class DataTy
+00006bb0: 7065 2865 6e75 6d2e 456e 756d 293a 0a20  pe(enum.Enum):. 
+00006bc0: 2020 2022 2222 0a20 2020 2054 6869 7320     """.    This 
+00006bd0: 656e 756d 2064 6566 696e 6573 2074 6865  enum defines the
+00006be0: 2073 7461 6e64 6172 6420 6461 7461 2074   standard data t
+00006bf0: 7970 6573 2074 6861 7420 6361 6e20 6265  ypes that can be
+00006c00: 2075 7365 6420 666f 7220 636f 6c75 6d6e   used for column
+00006c10: 732e 0a20 2020 2022 2222 0a0a 2020 2020  s..    """..    
+00006c20: 5445 5854 203d 2022 5445 5854 220a 2020  TEXT = "TEXT".  
+00006c30: 2020 2222 2243 6f6c 756d 6e20 7769 7468    """Column with
+00006c40: 2074 6578 7420 6461 7461 3a20 7e20 7374   text data: ~ st
+00006c50: 7269 6e67 2c20 6368 6172 2c20 7661 7263  ring, char, varc
+00006c60: 6861 722c 2063 6c6f 622e 2222 220a 2020  har, clob.""".  
+00006c70: 2020 494e 5445 4745 5220 3d20 2249 4e54    INTEGER = "INT
+00006c80: 4547 4552 220a 2020 2020 2222 2243 6f6c  EGER".    """Col
+00006c90: 756d 6e20 7769 7468 2069 6e74 6567 6572  umn with integer
+00006ca0: 2064 6174 612e 2222 220a 2020 2020 5245   data.""".    RE
+00006cb0: 414c 203d 2022 5245 414c 220a 2020 2020  AL = "REAL".    
+00006cc0: 2222 2243 6f6c 756d 6e20 7769 7468 2066  """Column with f
+00006cd0: 6c6f 6174 696e 6720 706f 696e 7420 6461  loating point da
+00006ce0: 7461 3a20 7e20 666c 6f61 742c 2064 6f75  ta: ~ float, dou
+00006cf0: 626c 652e 2222 220a 2020 2020 4441 5445  ble.""".    DATE
+00006d00: 203d 2022 4441 5445 220a 2020 2020 2222   = "DATE".    ""
+00006d10: 2243 6f6c 756d 6e20 7769 7468 2064 6174  "Column with dat
+00006d20: 6520 6461 7461 2e22 2222 0a20 2020 2054  e data.""".    T
+00006d30: 494d 4553 5441 4d50 203d 2022 5449 4d45  IMESTAMP = "TIME
+00006d40: 5354 414d 5022 0a20 2020 2022 2222 436f  STAMP".    """Co
+00006d50: 6c75 6d6e 2077 6974 6820 7469 6d65 7374  lumn with timest
+00006d60: 616d 7020 6461 7461 3a20 7e20 6461 7465  amp data: ~ date
+00006d70: 7469 6d65 2e22 2222 0a20 2020 2042 4f4f  time.""".    BOO
+00006d80: 4c45 414e 203d 2022 424f 4f4c 4541 4e22  LEAN = "BOOLEAN"
+00006d90: 0a20 2020 2022 2222 436f 6c75 6d6e 2077  .    """Column w
+00006da0: 6974 6820 626f 6f6c 6561 6e20 6461 7461  ith boolean data
+00006db0: 2e22 2222 0a20 2020 2042 4c4f 4220 3d20  .""".    BLOB = 
+00006dc0: 2242 4c4f 4222 0a20 2020 2022 2222 436f  "BLOB".    """Co
+00006dd0: 6c75 6d6e 2077 6974 6820 6269 6e61 7279  lumn with binary
+00006de0: 2064 6174 612e 2222 220a 2020 2020 4e55   data.""".    NU
+00006df0: 4d45 5249 4320 3d20 224e 554d 4552 4943  MERIC = "NUMERIC
+00006e00: 220a 2020 2020 2222 2243 6f6c 756d 6e20  ".    """Column 
+00006e10: 7769 7468 206e 756d 6572 6963 2064 6174  with numeric dat
+00006e20: 613a 2065 7861 6374 2064 6563 696d 616c  a: exact decimal
+00006e30: 2064 6174 612e 2222 220a 0a0a 6465 6620   data."""...def 
+00006e40: 6164 645f 636f 6c75 6d6e 280a 2020 2020  add_column(.    
+00006e50: 7061 7468 3a20 556e 696f 6e5b 7374 722c  path: Union[str,
+00006e60: 2022 6f73 2e50 6174 684c 696b 655b 416e   "os.PathLike[An
+00006e70: 795d 225d 2c0a 2020 2020 6e61 6d65 3a20  y]"],.    name: 
+00006e80: 7374 722c 0a20 2020 2074 7970 653a 2055  str,.    type: U
+00006e90: 6e69 6f6e 5b44 6174 6154 7970 652c 2073  nion[DataType, s
+00006ea0: 7472 5d2c 0a20 2020 2065 7870 7265 7373  tr],.    express
+00006eb0: 696f 6e3a 2055 6e69 6f6e 5b73 7472 2c20  ion: Union[str, 
+00006ec0: 666c 6f61 742c 204e 6f6e 655d 203d 204e  float, None] = N
+00006ed0: 6f6e 652c 0a20 2020 2065 7870 7265 7373  one,.    express
+00006ee0: 696f 6e5f 6469 616c 6563 743a 204f 7074  ion_dialect: Opt
+00006ef0: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
+00006f00: 652c 0a20 2020 206c 6179 6572 3a20 4f70  e,.    layer: Op
+00006f10: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
+00006f20: 6e65 2c0a 2020 2020 666f 7263 655f 7570  ne,.    force_up
+00006f30: 6461 7465 3a20 626f 6f6c 203d 2046 616c  date: bool = Fal
+00006f40: 7365 2c0a 2020 2020 7769 6474 683a 204f  se,.    width: O
+00006f50: 7074 696f 6e61 6c5b 696e 745d 203d 204e  ptional[int] = N
+00006f60: 6f6e 652c 0a29 3a0a 2020 2020 2222 220a  one,.):.    """.
+00006f70: 2020 2020 4164 6420 6120 636f 6c75 6d6e      Add a column
+00006f80: 2074 6f20 6120 6c61 7965 7220 6f66 2074   to a layer of t
+00006f90: 6865 2067 656f 6669 6c65 2e0a 0a20 2020  he geofile...   
+00006fa0: 2041 7267 733a 0a20 2020 2020 2020 2070   Args:.        p
+00006fb0: 6174 6820 2850 6174 684c 696b 6529 3a20  ath (PathLike): 
+00006fc0: 5061 7468 2074 6f20 7468 6520 6765 6f66  Path to the geof
+00006fd0: 696c 652e 0a20 2020 2020 2020 206e 616d  ile..        nam
+00006fe0: 6520 2873 7472 293a 204e 616d 6520 666f  e (str): Name fo
+00006ff0: 7220 7468 6520 6e65 7720 636f 6c75 6d6e  r the new column
+00007000: 2e0a 2020 2020 2020 2020 7479 7065 2028  ..        type (
+00007010: 7374 7229 3a20 436f 6c75 6d6e 2074 7970  str): Column typ
+00007020: 6520 6f66 2074 6865 206e 6577 2063 6f6c  e of the new col
+00007030: 756d 6e2e 0a20 2020 2020 2020 2065 7870  umn..        exp
+00007040: 7265 7373 696f 6e20 2873 7472 2c20 6f70  ression (str, op
+00007050: 7469 6f6e 616c 293a 2053 514c 6974 6520  tional): SQLite 
+00007060: 6578 7072 6573 7369 6f6e 2074 6f20 7573  expression to us
+00007070: 6520 746f 2075 7064 6174 650a 2020 2020  e to update.    
+00007080: 2020 2020 2020 2020 7468 6520 7661 6c75          the valu
+00007090: 652e 2044 6566 6175 6c74 7320 746f 204e  e. Defaults to N
+000070a0: 6f6e 652e 0a20 2020 2020 2020 2065 7870  one..        exp
+000070b0: 7265 7373 696f 6e5f 6469 616c 6563 7420  ression_dialect 
+000070c0: 2873 7472 2c20 6f70 7469 6f6e 616c 293a  (str, optional):
+000070d0: 2053 514c 2064 6961 6c65 6374 2075 7365   SQL dialect use
+000070e0: 6420 666f 7220 7468 6520 6578 7072 6573  d for the expres
+000070f0: 7369 6f6e 2e0a 2020 2020 2020 2020 6c61  sion..        la
+00007100: 7965 7220 2873 7472 2c20 6f70 7469 6f6e  yer (str, option
+00007110: 616c 293a 2054 6865 206c 6179 6572 206e  al): The layer n
+00007120: 616d 652e 2049 6620 4e6f 6e65 2061 6e64  ame. If None and
+00007130: 2074 6865 2067 656f 6669 6c65 0a20 2020   the geofile.   
+00007140: 2020 2020 2020 2020 2068 6173 206f 6e6c           has onl
+00007150: 7920 6f6e 6520 6c61 7965 722c 2074 6861  y one layer, tha
+00007160: 7420 6c61 7965 7220 6973 2075 7365 642e  t layer is used.
+00007170: 2044 6566 6175 6c74 7320 746f 204e 6f6e   Defaults to Non
+00007180: 652e 0a20 2020 2020 2020 2066 6f72 6365  e..        force
+00007190: 5f75 7064 6174 6520 2862 6f6f 6c2c 206f  _update (bool, o
+000071a0: 7074 696f 6e61 6c29 3a20 4966 2074 6865  ptional): If the
+000071b0: 2063 6f6c 756d 6e20 616c 7265 6164 7920   column already 
+000071c0: 6578 6973 7473 2c20 6578 6563 7574 650a  exists, execute.
+000071d0: 2020 2020 2020 2020 2020 2020 7468 6520              the 
+000071e0: 7570 6461 7465 2061 6e79 7761 792e 2044  update anyway. D
+000071f0: 6566 6175 6c74 7320 746f 2046 616c 7365  efaults to False
+00007200: 2e0a 2020 2020 2020 2020 7769 6474 6820  ..        width 
+00007210: 2869 6e74 2c20 6f70 7469 6f6e 616c 293a  (int, optional):
+00007220: 2074 6865 2077 6964 7468 206f 6620 7468   the width of th
+00007230: 6520 6669 656c 642e 0a0a 2020 2020 5261  e field...    Ra
+00007240: 6973 6573 3a0a 2020 2020 2020 2020 6578  ises:.        ex
+00007250: 3a20 5b64 6573 6372 6970 7469 6f6e 5d0a  : [description].
+00007260: 2020 2020 2222 220a 2020 2020 2320 496e      """.    # In
+00007270: 6974 0a20 2020 2069 6620 6973 696e 7374  it.    if isinst
+00007280: 616e 6365 2874 7970 652c 2044 6174 6154  ance(type, DataT
+00007290: 7970 6529 3a0a 2020 2020 2020 2020 7479  ype):.        ty
+000072a0: 7065 5f73 7472 203d 2074 7970 652e 7661  pe_str = type.va
+000072b0: 6c75 650a 2020 2020 656c 7365 3a0a 2020  lue.    else:.  
+000072c0: 2020 2020 2020 7479 7065 5f6c 6f77 6572        type_lower
+000072d0: 203d 2074 7970 652e 6c6f 7765 7228 290a   = type.lower().
+000072e0: 2020 2020 2020 2020 6966 2074 7970 655f          if type_
+000072f0: 6c6f 7765 7220 3d3d 2022 7374 7269 6e67  lower == "string
+00007300: 223a 0a20 2020 2020 2020 2020 2020 2023  ":.            #
+00007310: 2054 4f44 4f3a 2074 6869 6e6b 2077 6865   TODO: think whe
+00007320: 7468 6572 2062 6569 6e67 2066 6c65 7869  ther being flexi
+00007330: 626c 6520 6865 7265 2069 7320 6120 676f  ble here is a go
+00007340: 6f64 2069 6465 612e 2e2e 0a20 2020 2020  od idea....     
+00007350: 2020 2020 2020 2074 7970 655f 7374 7220         type_str 
+00007360: 3d20 2254 4558 5422 0a20 2020 2020 2020  = "TEXT".       
+00007370: 2065 6c69 6620 7479 7065 5f6c 6f77 6572   elif type_lower
+00007380: 203d 3d20 2262 696e 6172 7922 3a0a 2020   == "binary":.  
+00007390: 2020 2020 2020 2020 2020 7479 7065 5f73            type_s
+000073a0: 7472 203d 2022 424c 4f42 220a 2020 2020  tr = "BLOB".    
+000073b0: 2020 2020 656c 6966 2074 7970 655f 6c6f      elif type_lo
+000073c0: 7765 7220 3d3d 2022 7469 6d65 223a 0a20  wer == "time":. 
+000073d0: 2020 2020 2020 2020 2020 2074 7970 655f             type_
+000073e0: 7374 7220 3d20 2244 4154 4554 494d 4522  str = "DATETIME"
+000073f0: 0a20 2020 2020 2020 2065 6c69 6620 7479  .        elif ty
+00007400: 7065 5f6c 6f77 6572 203d 3d20 2269 6e74  pe_lower == "int
+00007410: 6567 6572 3634 223a 0a20 2020 2020 2020  eger64":.       
+00007420: 2020 2020 2074 7970 655f 7374 7220 3d20       type_str = 
+00007430: 2249 4e54 4547 4552 220a 2020 2020 2020  "INTEGER".      
+00007440: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00007450: 2020 2020 7479 7065 5f73 7472 203d 2074      type_str = t
+00007460: 7970 650a 2020 2020 7061 7468 203d 2050  ype.    path = P
+00007470: 6174 6828 7061 7468 290a 2020 2020 6966  ath(path).    if
+00007480: 206c 6179 6572 2069 7320 4e6f 6e65 3a0a   layer is None:.
+00007490: 2020 2020 2020 2020 6c61 7965 7220 3d20          layer = 
+000074a0: 6765 745f 6f6e 6c79 5f6c 6179 6572 2870  get_only_layer(p
+000074b0: 6174 6829 0a20 2020 206c 6179 6572 696e  ath).    layerin
+000074c0: 666f 5f6f 7269 6720 3d20 6765 745f 6c61  fo_orig = get_la
+000074d0: 7965 7269 6e66 6f28 7061 7468 2c20 6c61  yerinfo(path, la
+000074e0: 7965 722c 2072 6169 7365 5f6f 6e5f 6e6f  yer, raise_on_no
+000074f0: 6765 6f6d 3d46 616c 7365 290a 0a20 2020  geom=False)..   
+00007500: 2023 2047 6f21 0a20 2020 2064 6174 6173   # Go!.    datas
+00007510: 6f75 7263 6520 3d20 4e6f 6e65 0a20 2020  ource = None.   
+00007520: 2074 7279 3a0a 2020 2020 2020 2020 2320   try:.        # 
+00007530: 4966 2063 6f6c 756d 6e20 646f 6573 6e27  If column doesn'
+00007540: 7420 6578 6973 7420 7965 742c 2063 7265  t exist yet, cre
+00007550: 6174 6520 6974 0a20 2020 2020 2020 2063  ate it.        c
+00007560: 6f6c 756d 6e73 5f75 7070 6572 203d 205b  olumns_upper = [
+00007570: 636f 6c75 6d6e 2e75 7070 6572 2829 2066  column.upper() f
+00007580: 6f72 2063 6f6c 756d 6e20 696e 206c 6179  or column in lay
+00007590: 6572 696e 666f 5f6f 7269 672e 636f 6c75  erinfo_orig.colu
+000075a0: 6d6e 735d 0a20 2020 2020 2020 2069 6620  mns].        if 
+000075b0: 6e61 6d65 2e75 7070 6572 2829 206e 6f74  name.upper() not
+000075c0: 2069 6e20 636f 6c75 6d6e 735f 7570 7065   in columns_uppe
+000075d0: 723a 0a20 2020 2020 2020 2020 2020 2077  r:.            w
+000075e0: 6964 7468 5f73 7472 203d 2066 2228 7b77  idth_str = f"({w
+000075f0: 6964 7468 7d29 2220 6966 2077 6964 7468  idth})" if width
+00007600: 2069 7320 6e6f 7420 4e6f 6e65 2065 6c73   is not None els
+00007610: 6520 2222 0a20 2020 2020 2020 2020 2020  e "".           
+00007620: 2073 716c 5f73 746d 7420 3d20 280a 2020   sql_stmt = (.  
+00007630: 2020 2020 2020 2020 2020 2020 2020 6627                f'
+00007640: 414c 5445 5220 5441 424c 4520 227b 6c61  ALTER TABLE "{la
+00007650: 7965 727d 2220 4144 4420 434f 4c55 4d4e  yer}" ADD COLUMN
+00007660: 2022 7b6e 616d 657d 2220 7b74 7970 655f   "{name}" {type_
+00007670: 7374 727d 7b77 6964 7468 5f73 7472 7d27  str}{width_str}'
+00007680: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+00007690: 2020 2020 2020 2020 2020 2064 6174 6173             datas
+000076a0: 6f75 7263 6520 3d20 6764 616c 2e4f 7065  ource = gdal.Ope
+000076b0: 6e45 7828 7374 7228 7061 7468 292c 206e  nEx(str(path), n
+000076c0: 4f70 656e 466c 6167 733d 6764 616c 2e4f  OpenFlags=gdal.O
+000076d0: 465f 5550 4441 5445 290a 2020 2020 2020  F_UPDATE).      
+000076e0: 2020 2020 2020 7265 7375 6c74 203d 2064        result = d
+000076f0: 6174 6173 6f75 7263 652e 4578 6563 7574  atasource.Execut
+00007700: 6553 514c 2873 716c 5f73 746d 7429 0a20  eSQL(sql_stmt). 
+00007710: 2020 2020 2020 2020 2020 2064 6174 6173             datas
+00007720: 6f75 7263 652e 5265 6c65 6173 6552 6573  ource.ReleaseRes
+00007730: 756c 7453 6574 2872 6573 756c 7429 0a20  ultSet(result). 
+00007740: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00007750: 2020 2020 2020 2020 206c 6f67 6765 722e           logger.
+00007760: 7761 726e 696e 6728 6622 436f 6c75 6d6e  warning(f"Column
+00007770: 207b 6e61 6d65 7d20 6578 6973 7465 6420   {name} existed 
+00007780: 616c 7265 6164 7920 696e 207b 7061 7468  already in {path
+00007790: 7d2c 206c 6179 6572 207b 6c61 7965 727d  }, layer {layer}
+000077a0: 2229 0a0a 2020 2020 2020 2020 2320 4966  ")..        # If
+000077b0: 2061 6e20 6578 7072 6573 7369 6f6e 2077   an expression w
+000077c0: 6173 2070 726f 7669 6465 6420 616e 6420  as provided and 
+000077d0: 7570 6461 7465 2063 616e 2062 6520 646f  update can be do
+000077e0: 6e65 2c20 676f 2066 6f72 2069 742e 2e2e  ne, go for it...
+000077f0: 0a20 2020 2020 2020 2069 6620 6578 7072  .        if expr
+00007800: 6573 7369 6f6e 2069 7320 6e6f 7420 4e6f  ession is not No
+00007810: 6e65 2061 6e64 2028 0a20 2020 2020 2020  ne and (.       
+00007820: 2020 2020 206e 616d 6520 6e6f 7420 696e       name not in
+00007830: 206c 6179 6572 696e 666f 5f6f 7269 672e   layerinfo_orig.
+00007840: 636f 6c75 6d6e 7320 6f72 2066 6f72 6365  columns or force
+00007850: 5f75 7064 6174 6520 6973 2054 7275 650a  _update is True.
+00007860: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
+00007870: 2020 2020 2020 2069 6620 6461 7461 736f         if dataso
+00007880: 7572 6365 2069 7320 4e6f 6e65 3a0a 2020  urce is None:.  
+00007890: 2020 2020 2020 2020 2020 2020 2020 6461                da
+000078a0: 7461 736f 7572 6365 203d 2067 6461 6c2e  tasource = gdal.
+000078b0: 4f70 656e 4578 2873 7472 2870 6174 6829  OpenEx(str(path)
+000078c0: 2c20 6e4f 7065 6e46 6c61 6773 3d67 6461  , nOpenFlags=gda
+000078d0: 6c2e 4f46 5f55 5044 4154 4529 0a20 2020  l.OF_UPDATE).   
+000078e0: 2020 2020 2020 2020 2073 716c 5f73 746d           sql_stm
+000078f0: 7420 3d20 6627 5550 4441 5445 2022 7b6c  t = f'UPDATE "{l
+00007900: 6179 6572 7d22 2053 4554 2022 7b6e 616d  ayer}" SET "{nam
+00007910: 657d 2220 3d20 7b65 7870 7265 7373 696f  e}" = {expressio
+00007920: 6e7d 270a 2020 2020 2020 2020 2020 2020  n}'.            
+00007930: 7265 7375 6c74 203d 2064 6174 6173 6f75  result = datasou
+00007940: 7263 652e 4578 6563 7574 6553 514c 2873  rce.ExecuteSQL(s
+00007950: 716c 5f73 746d 742c 2064 6961 6c65 6374  ql_stmt, dialect
+00007960: 3d65 7870 7265 7373 696f 6e5f 6469 616c  =expression_dial
+00007970: 6563 7429 0a20 2020 2020 2020 2020 2020  ect).           
+00007980: 2064 6174 6173 6f75 7263 652e 5265 6c65   datasource.Rele
+00007990: 6173 6552 6573 756c 7453 6574 2872 6573  aseResultSet(res
+000079a0: 756c 7429 0a0a 2020 2020 6578 6365 7074  ult)..    except
+000079b0: 2045 7863 6570 7469 6f6e 2061 7320 6578   Exception as ex
+000079c0: 3a0a 2020 2020 2020 2020 6578 2e61 7267  :.        ex.arg
+000079d0: 7320 3d20 2866 2261 6464 5f63 6f6c 756d  s = (f"add_colum
+000079e0: 6e20 6572 726f 7220 666f 7220 7b70 6174  n error for {pat
+000079f0: 687d 2e7b 6c61 7965 727d 3a5c 6e20 207b  h}.{layer}:\n  {
+00007a00: 6578 7d22 2c29 0a20 2020 2020 2020 2072  ex}",).        r
+00007a10: 6169 7365 0a20 2020 2066 696e 616c 6c79  aise.    finally
+00007a20: 3a0a 2020 2020 2020 2020 6461 7461 736f  :.        dataso
+00007a30: 7572 6365 203d 204e 6f6e 650a 0a0a 6465  urce = None...de
+00007a40: 6620 6472 6f70 5f63 6f6c 756d 6e28 0a20  f drop_column(. 
+00007a50: 2020 2070 6174 683a 2055 6e69 6f6e 5b73     path: Union[s
+00007a60: 7472 2c20 226f 732e 5061 7468 4c69 6b65  tr, "os.PathLike
+00007a70: 5b41 6e79 5d22 5d2c 2063 6f6c 756d 6e5f  [Any]"], column_
+00007a80: 6e61 6d65 3a20 7374 722c 206c 6179 6572  name: str, layer
+00007a90: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
+00007aa0: 3d20 4e6f 6e65 0a29 3a0a 2020 2020 2222  = None.):.    ""
+00007ab0: 220a 2020 2020 4472 6f70 2074 6865 2063  ".    Drop the c
+00007ac0: 6f6c 756d 6e20 7370 6563 6966 6965 642e  olumn specified.
+00007ad0: 0a0a 2020 2020 4172 6773 3a0a 2020 2020  ..    Args:.    
+00007ae0: 2020 2020 7061 7468 2028 5061 7468 4c69      path (PathLi
+00007af0: 6b65 293a 2054 6865 2066 696c 6520 7061  ke): The file pa
+00007b00: 7468 2e0a 2020 2020 2020 2020 636f 6c75  th..        colu
+00007b10: 6d6e 5f6e 616d 6520 2873 7472 293a 2074  mn_name (str): t
+00007b20: 6865 2063 6f6c 756d 6e20 6e61 6d65 2e0a  he column name..
+00007b30: 2020 2020 2020 2020 6c61 7965 7220 284f          layer (O
+00007b40: 7074 696f 6e61 6c5b 7374 725d 293a 2054  ptional[str]): T
+00007b50: 6865 206c 6179 6572 206e 616d 652e 2049  he layer name. I
+00007b60: 6620 6e6f 7420 7370 6563 6966 6965 642c  f not specified,
+00007b70: 2061 6e64 2074 6865 7265 2069 7320 6f6e   and there is on
+00007b80: 6c79 0a20 2020 2020 2020 2020 2020 206f  ly.            o
+00007b90: 6e65 206c 6179 6572 2069 6e20 7468 6520  ne layer in the 
+00007ba0: 6669 6c65 2c20 7468 6973 206c 6179 6572  file, this layer
+00007bb0: 2069 7320 7573 6564 2e20 4f74 6865 7277   is used. Otherw
+00007bc0: 6973 6520 6120 5661 6c75 6545 7272 6f72  ise a ValueError
+00007bd0: 2069 730a 2020 2020 2020 2020 2020 2020   is.            
+00007be0: 7261 6973 6564 2e0a 2020 2020 2222 220a  raised..    """.
+00007bf0: 2020 2020 2320 4368 6563 6b20 696e 7075      # Check inpu
+00007c00: 7420 7061 7261 6d65 7465 7273 0a20 2020  t parameters.   
+00007c10: 2070 6174 6820 3d20 5061 7468 2870 6174   path = Path(pat
+00007c20: 6829 0a20 2020 2069 6620 6c61 7965 7220  h).    if layer 
+00007c30: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+00007c40: 206c 6179 6572 203d 2067 6574 5f6f 6e6c   layer = get_onl
+00007c50: 795f 6c61 7965 7228 7061 7468 290a 2020  y_layer(path).  
+00007c60: 2020 696e 666f 203d 2067 6574 5f6c 6179    info = get_lay
+00007c70: 6572 696e 666f 2870 6174 682c 206c 6179  erinfo(path, lay
+00007c80: 6572 2c20 7261 6973 655f 6f6e 5f6e 6f67  er, raise_on_nog
+00007c90: 656f 6d3d 4661 6c73 6529 0a20 2020 2069  eom=False).    i
+00007ca0: 6620 636f 6c75 6d6e 5f6e 616d 6520 6e6f  f column_name no
+00007cb0: 7420 696e 2069 6e66 6f2e 636f 6c75 6d6e  t in info.column
+00007cc0: 733a 0a20 2020 2020 2020 206c 6f67 6765  s:.        logge
+00007cd0: 722e 696e 666f 2866 2243 6f6c 756d 6e20  r.info(f"Column 
+00007ce0: 7b63 6f6c 756d 6e5f 6e61 6d65 7d20 6e6f  {column_name} no
+00007cf0: 7420 7072 6573 656e 7420 736f 2063 616e  t present so can
+00007d00: 6e6f 7420 6265 2064 726f 7070 6564 2e22  not be dropped."
+00007d10: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00007d20: 0a0a 2020 2020 2320 4e6f 7720 7265 616c  ..    # Now real
+00007d30: 6c79 2072 656e 616d 650a 2020 2020 6461  ly rename.    da
+00007d40: 7461 736f 7572 6365 203d 204e 6f6e 650a  tasource = None.
+00007d50: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+00007d60: 2064 6174 6173 6f75 7263 6520 3d20 6764   datasource = gd
+00007d70: 616c 2e4f 7065 6e45 7828 7374 7228 7061  al.OpenEx(str(pa
+00007d80: 7468 292c 206e 4f70 656e 466c 6167 733d  th), nOpenFlags=
+00007d90: 6764 616c 2e4f 465f 5550 4441 5445 290a  gdal.OF_UPDATE).
+00007da0: 2020 2020 2020 2020 7371 6c5f 7374 6d74          sql_stmt
+00007db0: 203d 2066 2741 4c54 4552 2054 4142 4c45   = f'ALTER TABLE
+00007dc0: 2022 7b6c 6179 6572 7d22 2044 524f 5020   "{layer}" DROP 
+00007dd0: 434f 4c55 4d4e 2022 7b63 6f6c 756d 6e5f  COLUMN "{column_
+00007de0: 6e61 6d65 7d22 270a 2020 2020 2020 2020  name}"'.        
+00007df0: 7265 7375 6c74 203d 2064 6174 6173 6f75  result = datasou
+00007e00: 7263 652e 4578 6563 7574 6553 514c 2873  rce.ExecuteSQL(s
+00007e10: 716c 5f73 746d 7429 0a20 2020 2020 2020  ql_stmt).       
+00007e20: 2064 6174 6173 6f75 7263 652e 5265 6c65   datasource.Rele
+00007e30: 6173 6552 6573 756c 7453 6574 2872 6573  aseResultSet(res
+00007e40: 756c 7429 0a0a 2020 2020 6578 6365 7074  ult)..    except
+00007e50: 2045 7863 6570 7469 6f6e 2061 7320 6578   Exception as ex
+00007e60: 3a0a 2020 2020 2020 2020 6578 2e61 7267  :.        ex.arg
+00007e70: 7320 3d20 2866 2264 726f 705f 636f 6c75  s = (f"drop_colu
+00007e80: 6d6e 2065 7272 6f72 2066 6f72 207b 7061  mn error for {pa
+00007e90: 7468 7d2e 7b6c 6179 6572 7d3a 5c6e 2020  th}.{layer}:\n  
+00007ea0: 7b65 787d 222c 290a 2020 2020 2020 2020  {ex}",).        
+00007eb0: 7261 6973 650a 2020 2020 6669 6e61 6c6c  raise.    finall
+00007ec0: 793a 0a20 2020 2020 2020 2064 6174 6173  y:.        datas
+00007ed0: 6f75 7263 6520 3d20 4e6f 6e65 0a0a 0a64  ource = None...d
+00007ee0: 6566 2075 7064 6174 655f 636f 6c75 6d6e  ef update_column
+00007ef0: 280a 2020 2020 7061 7468 3a20 556e 696f  (.    path: Unio
+00007f00: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
+00007f10: 696b 655b 416e 795d 225d 2c0a 2020 2020  ike[Any]"],.    
+00007f20: 6e61 6d65 3a20 7374 722c 0a20 2020 2065  name: str,.    e
+00007f30: 7870 7265 7373 696f 6e3a 2073 7472 2c0a  xpression: str,.
+00007f40: 2020 2020 6c61 7965 723a 204f 7074 696f      layer: Optio
+00007f50: 6e61 6c5b 7374 725d 203d 204e 6f6e 652c  nal[str] = None,
+00007f60: 0a20 2020 2077 6865 7265 3a20 4f70 7469  .    where: Opti
+00007f70: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+00007f80: 2c0a 293a 0a20 2020 2022 2222 0a20 2020  ,.):.    """.   
+00007f90: 2055 7064 6174 6520 6120 636f 6c75 6d6e   Update a column
+00007fa0: 2066 726f 6d20 6120 6c61 7965 7220 6f66   from a layer of
+00007fb0: 2074 6865 2067 656f 6669 6c65 2e0a 0a20   the geofile... 
+00007fc0: 2020 2041 7267 733a 0a20 2020 2020 2020     Args:.       
+00007fd0: 2070 6174 6820 2850 6174 684c 696b 6529   path (PathLike)
+00007fe0: 3a20 5061 7468 2074 6f20 7468 6520 6765  : Path to the ge
+00007ff0: 6f66 696c 650a 2020 2020 2020 2020 6e61  ofile.        na
+00008000: 6d65 2028 7374 7229 3a20 4e61 6d65 2066  me (str): Name f
+00008010: 6f72 2074 6865 206e 6577 2063 6f6c 756d  or the new colum
+00008020: 6e0a 2020 2020 2020 2020 6578 7072 6573  n.        expres
+00008030: 7369 6f6e 2028 7374 7229 3a20 5351 4c69  sion (str): SQLi
+00008040: 7465 2065 7870 7265 7373 696f 6e20 746f  te expression to
+00008050: 2075 7365 2074 6f20 7570 6461 7465 2074   use to update t
+00008060: 6865 2076 616c 7565 2e0a 2020 2020 2020  he value..      
+00008070: 2020 6c61 7965 7220 2873 7472 2c20 6f70    layer (str, op
+00008080: 7469 6f6e 616c 293a 2054 6865 206c 6179  tional): The lay
+00008090: 6572 206e 616d 652e 2049 6620 4e6f 6e65  er name. If None
+000080a0: 2061 6e64 2074 6865 2067 656f 6669 6c65   and the geofile
+000080b0: 0a20 2020 2020 2020 2020 2020 2068 6173  .            has
+000080c0: 206f 6e6c 7920 6f6e 6520 6c61 7965 722c   only one layer,
+000080d0: 2074 6861 7420 6c61 7965 7220 6973 2075   that layer is u
+000080e0: 7365 642e 2044 6566 6175 6c74 7320 746f  sed. Defaults to
+000080f0: 204e 6f6e 652e 0a20 2020 2020 2020 2077   None..        w
+00008100: 6865 7265 2028 7374 722c 206f 7074 696f  here (str, optio
+00008110: 6e61 6c29 3a20 5351 4c20 7768 6572 6520  nal): SQL where 
+00008120: 636c 6175 7365 2074 6f20 7265 7374 7269  clause to restri
+00008130: 6374 2074 6865 2072 6f77 7320 7468 6174  ct the rows that
+00008140: 2077 696c 6c0a 2020 2020 2020 2020 2020   will.          
+00008150: 2020 6265 2075 7064 6174 6564 2e20 4465    be updated. De
+00008160: 6661 756c 7473 2074 6f20 4e6f 6e65 2e0a  faults to None..
+00008170: 0a20 2020 2052 6169 7365 733a 0a20 2020  .    Raises:.   
+00008180: 2020 2020 2056 616c 7565 4572 726f 723a       ValueError:
+00008190: 2061 6e20 696e 7661 6c69 6420 7061 7261   an invalid para
+000081a0: 6d65 7465 7220 7661 6c75 6520 7761 7320  meter value was 
+000081b0: 7061 7373 6564 2e0a 2020 2020 2222 220a  passed..    """.
+000081c0: 2020 2020 2320 496e 6974 0a20 2020 2070      # Init.    p
+000081d0: 6174 6820 3d20 5061 7468 2870 6174 6829  ath = Path(path)
+000081e0: 0a20 2020 2069 6620 6c61 7965 7220 6973  .    if layer is
+000081f0: 204e 6f6e 653a 0a20 2020 2020 2020 206c   None:.        l
+00008200: 6179 6572 203d 2067 6574 5f6f 6e6c 795f  ayer = get_only_
+00008210: 6c61 7965 7228 7061 7468 290a 2020 2020  layer(path).    
+00008220: 6c61 7965 7269 6e66 6f5f 6f72 6967 203d  layerinfo_orig =
+00008230: 2067 6574 5f6c 6179 6572 696e 666f 2870   get_layerinfo(p
+00008240: 6174 682c 206c 6179 6572 290a 2020 2020  ath, layer).    
+00008250: 636f 6c75 6d6e 735f 7570 7065 7220 3d20  columns_upper = 
+00008260: 5b63 6f6c 756d 6e2e 7570 7065 7228 2920  [column.upper() 
+00008270: 666f 7220 636f 6c75 6d6e 2069 6e20 6c61  for column in la
+00008280: 7965 7269 6e66 6f5f 6f72 6967 2e63 6f6c  yerinfo_orig.col
+00008290: 756d 6e73 5d0a 2020 2020 6966 206c 6179  umns].    if lay
+000082a0: 6572 696e 666f 5f6f 7269 672e 6765 6f6d  erinfo_orig.geom
+000082b0: 6574 7279 636f 6c75 6d6e 2069 7320 6e6f  etrycolumn is no
+000082c0: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
+000082d0: 636f 6c75 6d6e 735f 7570 7065 722e 6170  columns_upper.ap
+000082e0: 7065 6e64 286c 6179 6572 696e 666f 5f6f  pend(layerinfo_o
+000082f0: 7269 672e 6765 6f6d 6574 7279 636f 6c75  rig.geometrycolu
+00008300: 6d6e 2e75 7070 6572 2829 290a 2020 2020  mn.upper()).    
+00008310: 6966 206e 616d 652e 7570 7065 7228 2920  if name.upper() 
+00008320: 6e6f 7420 696e 2063 6f6c 756d 6e73 5f75  not in columns_u
+00008330: 7070 6572 3a0a 2020 2020 2020 2020 2320  pper:.        # 
+00008340: 4966 2063 6f6c 756d 6e20 646f 6573 6e27  If column doesn'
+00008350: 7420 6578 6973 7420 7965 742c 2065 7272  t exist yet, err
+00008360: 6f72 210a 2020 2020 2020 2020 7261 6973  or!.        rais
+00008370: 6520 5661 6c75 6545 7272 6f72 2866 2243  e ValueError(f"C
+00008380: 6f6c 756d 6e20 7b6e 616d 657d 2064 6f65  olumn {name} doe
+00008390: 736e 2774 2065 7869 7374 2069 6e20 7b70  sn't exist in {p
+000083a0: 6174 687d 2c20 6c61 7965 7220 7b6c 6179  ath}, layer {lay
+000083b0: 6572 7d22 290a 0a20 2020 2023 2047 6f21  er}")..    # Go!
+000083c0: 0a20 2020 2064 6174 6173 6f75 7263 6520  .    datasource 
+000083d0: 3d20 4e6f 6e65 0a20 2020 2074 7279 3a0a  = None.    try:.
+000083e0: 2020 2020 2020 2020 6461 7461 736f 7572          datasour
+000083f0: 6365 203d 2067 6461 6c2e 4f70 656e 4578  ce = gdal.OpenEx
+00008400: 2873 7472 2870 6174 6829 2c20 6e4f 7065  (str(path), nOpe
+00008410: 6e46 6c61 6773 3d67 6461 6c2e 4f46 5f55  nFlags=gdal.OF_U
+00008420: 5044 4154 4529 0a20 2020 2020 2020 2073  PDATE).        s
+00008430: 716c 6974 655f 7374 6d74 203d 2066 2755  qlite_stmt = f'U
+00008440: 5044 4154 4520 227b 6c61 7965 727d 2220  PDATE "{layer}" 
+00008450: 5345 5420 227b 6e61 6d65 7d22 203d 207b  SET "{name}" = {
+00008460: 6578 7072 6573 7369 6f6e 7d27 0a20 2020  expression}'.   
+00008470: 2020 2020 2069 6620 7768 6572 6520 6973       if where is
+00008480: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00008490: 2020 2020 2020 2073 716c 6974 655f 7374         sqlite_st
+000084a0: 6d74 202b 3d20 6622 5c6e 2057 4845 5245  mt += f"\n WHERE
+000084b0: 207b 7768 6572 657d 220a 2020 2020 2020   {where}".      
+000084c0: 2020 7265 7375 6c74 203d 2064 6174 6173    result = datas
+000084d0: 6f75 7263 652e 4578 6563 7574 6553 514c  ource.ExecuteSQL
+000084e0: 2873 716c 6974 655f 7374 6d74 2c20 6469  (sqlite_stmt, di
+000084f0: 616c 6563 743d 2253 514c 4954 4522 290a  alect="SQLITE").
+00008500: 2020 2020 2020 2020 6461 7461 736f 7572          datasour
+00008510: 6365 2e52 656c 6561 7365 5265 7375 6c74  ce.ReleaseResult
+00008520: 5365 7428 7265 7375 6c74 290a 0a20 2020  Set(result)..   
+00008530: 2065 7863 6570 7420 4578 6365 7074 696f   except Exceptio
+00008540: 6e20 6173 2065 783a 0a20 2020 2020 2020  n as ex:.       
+00008550: 2065 782e 6172 6773 203d 2028 6622 7570   ex.args = (f"up
+00008560: 6461 7465 5f63 6f6c 756d 6e20 6572 726f  date_column erro
+00008570: 7220 666f 7220 7b70 6174 687d 2e7b 6c61  r for {path}.{la
+00008580: 7965 727d 3a5c 6e20 207b 6578 7d22 2c29  yer}:\n  {ex}",)
+00008590: 0a20 2020 2020 2020 2072 6169 7365 0a20  .        raise. 
+000085a0: 2020 2066 696e 616c 6c79 3a0a 2020 2020     finally:.    
+000085b0: 2020 2020 6461 7461 736f 7572 6365 203d      datasource =
+000085c0: 204e 6f6e 650a 0a0a 6465 6620 7265 6164   None...def read
+000085d0: 5f66 696c 6528 0a20 2020 2070 6174 683a  _file(.    path:
+000085e0: 2055 6e69 6f6e 5b73 7472 2c20 226f 732e   Union[str, "os.
+000085f0: 5061 7468 4c69 6b65 5b41 6e79 5d22 5d2c  PathLike[Any]"],
+00008600: 0a20 2020 206c 6179 6572 3a20 4f70 7469  .    layer: Opti
+00008610: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+00008620: 2c0a 2020 2020 636f 6c75 6d6e 733a 204f  ,.    columns: O
+00008630: 7074 696f 6e61 6c5b 4974 6572 6162 6c65  ptional[Iterable
+00008640: 5b73 7472 5d5d 203d 204e 6f6e 652c 0a20  [str]] = None,. 
+00008650: 2020 2062 626f 783d 4e6f 6e65 2c0a 2020     bbox=None,.  
+00008660: 2020 726f 7773 3d4e 6f6e 652c 0a20 2020    rows=None,.   
+00008670: 2077 6865 7265 3a20 4f70 7469 6f6e 616c   where: Optional
+00008680: 5b73 7472 5d20 3d20 4e6f 6e65 2c0a 2020  [str] = None,.  
+00008690: 2020 7371 6c5f 7374 6d74 3a20 4f70 7469    sql_stmt: Opti
+000086a0: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+000086b0: 2c0a 2020 2020 7371 6c5f 6469 616c 6563  ,.    sql_dialec
+000086c0: 743a 204f 7074 696f 6e61 6c5b 4c69 7465  t: Optional[Lite
+000086d0: 7261 6c5b 2253 514c 4954 4522 2c20 224f  ral["SQLITE", "O
+000086e0: 4752 5351 4c22 5d5d 203d 204e 6f6e 652c  GRSQL"]] = None,
+000086f0: 0a20 2020 2069 676e 6f72 655f 6765 6f6d  .    ignore_geom
+00008700: 6574 7279 3a20 626f 6f6c 203d 2046 616c  etry: bool = Fal
+00008710: 7365 2c0a 2020 2020 6669 645f 6173 5f69  se,.    fid_as_i
+00008720: 6e64 6578 3a20 626f 6f6c 203d 2046 616c  ndex: bool = Fal
+00008730: 7365 2c0a 2920 2d3e 2067 7064 2e47 656f  se,.) -> gpd.Geo
+00008740: 4461 7461 4672 616d 653a 0a20 2020 2022  DataFrame:.    "
+00008750: 2222 0a20 2020 2052 6561 6473 2061 2066  "".    Reads a f
+00008760: 696c 6520 746f 2061 2067 656f 7061 6e64  ile to a geopand
+00008770: 6173 2047 656f 4461 7461 6672 616d 652e  as GeoDataframe.
+00008780: 0a0a 2020 2020 5468 6520 6669 6c65 2066  ..    The file f
+00008790: 6f72 6d61 7420 6973 2064 6574 6563 7465  ormat is detecte
+000087a0: 6420 6261 7365 6420 6f6e 2074 6865 2066  d based on the f
+000087b0: 696c 6570 6174 6820 6578 7465 6e73 696f  ilepath extensio
+000087c0: 6e2e 0a0a 2020 2020 4966 2060 6073 716c  n...    If ``sql
+000087d0: 5f73 746d 7460 6020 6973 2073 7065 6369  _stmt`` is speci
+000087e0: 6669 6564 2c20 7468 6520 7371 6c69 7465  fied, the sqlite
+000087f0: 2071 7565 7279 2063 616e 2063 6f6e 7461   query can conta
+00008800: 696e 2066 6f6c 6c6f 7769 6e67 2070 6c61  in following pla
+00008810: 6365 686f 6c64 6572 730a 2020 2020 7468  ceholders.    th
+00008820: 6174 2077 696c 6c20 6265 2061 7574 6f6d  at will be autom
+00008830: 6174 6963 616c 6c79 2072 6570 6c61 6365  atically replace
+00008840: 6420 666f 7220 796f 753a 0a0a 2020 2020  d for you:..    
+00008850: 2020 2a20 7b67 656f 6d65 7472 7963 6f6c    * {geometrycol
+00008860: 756d 6e7d 3a20 7468 6520 636f 6c75 6d6e  umn}: the column
+00008870: 2077 6865 7265 2074 6865 2070 7269 6d61   where the prima
+00008880: 7279 2067 656f 6d65 7472 7920 6973 2073  ry geometry is s
+00008890: 746f 7265 642e 0a20 2020 2020 202a 207b  tored..      * {
+000088a0: 636f 6c75 6d6e 735f 746f 5f73 656c 6563  columns_to_selec
+000088b0: 745f 7374 727d 3a20 6966 2060 6063 6f6c  t_str}: if ``col
+000088c0: 756d 6e73 6060 2069 7320 6e6f 7420 4e6f  umns`` is not No
+000088d0: 6e65 2c20 7468 6f73 6520 636f 6c75 6d6e  ne, those column
+000088e0: 732c 0a20 2020 2020 2020 206f 7468 6572  s,.        other
+000088f0: 7769 7365 2061 6c6c 2063 6f6c 756d 6e73  wise all columns
+00008900: 206f 6620 7468 6520 6c61 7965 722e 0a20   of the layer.. 
+00008910: 2020 2020 202a 207b 696e 7075 745f 6c61       * {input_la
+00008920: 7965 727d 3a20 7468 6520 6c61 7965 7220  yer}: the layer 
+00008930: 6e61 6d65 206f 6620 7468 6520 696e 7075  name of the inpu
+00008940: 7420 6c61 7965 722e 0a0a 2020 2020 4578  t layer...    Ex
+00008950: 616d 706c 6520 5351 4c20 7374 6174 656d  ample SQL statem
+00008960: 656e 7420 7769 7468 2070 6c61 6365 686f  ent with placeho
+00008970: 6c64 6572 733a 0a20 2020 203a 3a0a 0a20  lders:.    ::.. 
+00008980: 2020 2020 2020 2053 454c 4543 5420 7b67         SELECT {g
+00008990: 656f 6d65 7472 7963 6f6c 756d 6e7d 0a20  eometrycolumn}. 
+000089a0: 2020 2020 2020 2020 2020 2020 207b 636f               {co
+000089b0: 6c75 6d6e 735f 746f 5f73 656c 6563 745f  lumns_to_select_
+000089c0: 7374 727d 0a20 2020 2020 2020 2020 2046  str}.          F
+000089d0: 524f 4d20 227b 696e 7075 745f 6c61 7965  ROM "{input_laye
+000089e0: 727d 2220 6c61 7965 720a 0a20 2020 2054  r}" layer..    T
+000089f0: 6865 2075 6e64 6572 6c79 696e 6720 6c69  he underlying li
+00008a00: 6272 6172 7920 7573 6564 2074 6f20 7265  brary used to re
+00008a10: 6164 2074 6865 2066 696c 6520 6361 6e20  ad the file can 
+00008a20: 6265 2063 686f 6f73 656e 2075 7369 6e67  be choosen using
+00008a30: 2074 6865 0a20 2020 2022 4746 4f5f 494f   the.    "GFO_IO
+00008a40: 5f45 4e47 494e 4522 2065 6e76 6972 6f6e  _ENGINE" environ
+00008a50: 6d65 6e74 2076 6172 6961 626c 652e 2050  ment variable. P
+00008a60: 6f73 7369 626c 6520 7661 6c75 6573 2061  ossible values a
+00008a70: 7265 2022 6669 6f6e 6122 2061 6e64 2022  re "fiona" and "
+00008a80: 7079 6f67 7269 6f22 2e0a 2020 2020 5468  pyogrio"..    Th
+00008a90: 6973 206f 7074 696f 6e20 6973 2063 7265  is option is cre
+00008aa0: 6174 6564 2061 7320 6120 7465 6d70 6f72  ated as a tempor
+00008ab0: 6172 7920 6661 6c6c 6261 636b 2074 6f20  ary fallback to 
+00008ac0: 2266 696f 6e61 2220 666f 7220 6361 7365  "fiona" for case
+00008ad0: 7320 7768 6572 6520 2270 796f 6772 696f  s where "pyogrio
+00008ae0: 220a 2020 2020 6769 7665 7320 6973 7375  ".    gives issu
+00008af0: 6573 2c20 736f 2070 6c65 6173 6520 7265  es, so please re
+00008b00: 706f 7274 2069 7373 7565 7320 6966 2074  port issues if t
+00008b10: 6865 7920 6172 6520 656e 636f 756e 7465  hey are encounte
+00008b20: 7265 642e 2049 6e20 7468 6520 6675 7475  red. In the futu
+00008b30: 7265 2073 7570 706f 7274 0a20 2020 2066  re support.    f
+00008b40: 6f72 2074 6865 2022 6669 6f6e 6122 2065  or the "fiona" e
+00008b50: 6e67 696e 6520 6d6f 7374 206c 696b 656c  ngine most likel
+00008b60: 7920 7769 6c6c 2062 6520 7265 6d6f 7665  y will be remove
+00008b70: 642e 2044 6566 6175 6c74 2065 6e67 696e  d. Default engin
+00008b80: 6520 6973 2022 7079 6f67 7269 6f22 2e0a  e is "pyogrio"..
+00008b90: 0a20 2020 2041 7267 733a 0a20 2020 2020  .    Args:.     
+00008ba0: 2020 2070 6174 6820 2866 696c 6520 7061     path (file pa
+00008bb0: 7468 293a 2070 6174 6820 746f 2074 6865  th): path to the
+00008bc0: 2066 696c 6520 746f 2072 6561 6420 6672   file to read fr
+00008bd0: 6f6d 0a20 2020 2020 2020 206c 6179 6572  om.        layer
+00008be0: 2028 7374 722c 206f 7074 696f 6e61 6c29   (str, optional)
+00008bf0: 3a20 5468 6520 6c61 7965 7220 746f 2072  : The layer to r
+00008c00: 6561 642e 2049 6620 4e6f 6e65 2061 6e64  ead. If None and
+00008c10: 2074 6865 7265 2069 7320 6f6e 6c79 206f   there is only o
+00008c20: 6e65 206c 6179 6572 2069 6e0a 2020 2020  ne layer in.    
+00008c30: 2020 2020 2020 2020 7468 6520 6669 6c65          the file
+00008c40: 2069 7420 6973 2072 6561 642c 206f 7468   it is read, oth
+00008c50: 6572 7769 7365 2061 6e20 6572 726f 7220  erwise an error 
+00008c60: 6973 2074 6872 6f77 6e2e 2044 6566 6175  is thrown. Defau
+00008c70: 6c74 7320 746f 204e 6f6e 652e 0a20 2020  lts to None..   
+00008c80: 2020 2020 2063 6f6c 756d 6e73 2028 4974       columns (It
+00008c90: 6572 6162 6c65 5b73 7472 5d2c 206f 7074  erable[str], opt
+00008ca0: 696f 6e61 6c29 3a20 5468 6520 286e 6f6e  ional): The (non
+00008cb0: 2d67 656f 6d65 7472 7929 2063 6f6c 756d  -geometry) colum
+00008cc0: 6e73 2074 6f20 7265 6164 2077 696c 6c0a  ns to read will.
+00008cd0: 2020 2020 2020 2020 2020 2020 6265 2072              be r
+00008ce0: 6574 7572 6e65 6420 696e 2074 6865 206f  eturned in the o
+00008cf0: 7264 6572 2073 7065 6369 6669 6564 2e20  rder specified. 
+00008d00: 4966 204e 6f6e 652c 2061 6c6c 2073 7461  If None, all sta
+00008d10: 6e64 6172 6420 636f 6c75 6d6e 7320 6172  ndard columns ar
+00008d20: 6520 7265 6164 2e0a 2020 2020 2020 2020  e read..        
+00008d30: 2020 2020 496e 2061 6464 6974 696f 6e20      In addition 
+00008d40: 746f 2073 7461 6e64 6172 6420 636f 6c75  to standard colu
+00008d50: 6d6e 732c 2069 7420 6973 2061 6c73 6f20  mns, it is also 
+00008d60: 706f 7373 6962 6c65 0a20 2020 2020 2020  possible.       
+00008d70: 2020 2020 2074 6f20 7370 6563 6966 7920       to specify 
+00008d80: 2266 6964 222c 2061 2075 6e69 7175 6520  "fid", a unique 
+00008d90: 696e 6465 7820 6176 6169 6c61 626c 6520  index available 
+00008da0: 696e 2061 6c6c 2069 6e70 7574 2066 696c  in all input fil
+00008db0: 6573 2e20 4e6f 7465 2074 6861 7420 7468  es. Note that th
+00008dc0: 650a 2020 2020 2020 2020 2020 2020 2266  e.            "f
+00008dd0: 6964 2220 7769 6c6c 2062 6520 616c 6961  id" will be alia
+00008de0: 7365 6420 6567 2e20 746f 2022 6669 645f  sed eg. to "fid_
+00008df0: 3122 2e20 4465 6661 756c 7473 2074 6f20  1". Defaults to 
+00008e00: 4e6f 6e65 2e0a 2020 2020 2020 2020 6262  None..        bb
+00008e10: 6f78 2028 5475 706c 652c 206f 7074 696f  ox (Tuple, optio
+00008e20: 6e61 6c29 3a20 7265 7475 726e 206f 6e6c  nal): return onl
+00008e30: 7920 6765 6f6d 6574 7269 6573 2069 6e74  y geometries int
+00008e40: 6572 7365 6374 696e 6720 7468 6973 2062  ersecting this b
+00008e50: 626f 782e 0a20 2020 2020 2020 2020 2020  box..           
+00008e60: 2044 6566 6175 6c74 7320 746f 204e 6f6e   Defaults to Non
+00008e70: 652c 2074 6865 6e20 616c 6c20 726f 7773  e, then all rows
+00008e80: 2061 7265 2072 6561 642e 0a20 2020 2020   are read..     
+00008e90: 2020 2072 6f77 7320 2873 6c69 6365 2c20     rows (slice, 
+00008ea0: 6f70 7469 6f6e 616c 293a 2072 6574 7572  optional): retur
+00008eb0: 6e20 6f6e 6c79 2074 6865 2072 6f77 7320  n only the rows 
+00008ec0: 7370 6563 6966 6965 642e 2046 6f72 206d  specified. For m
+00008ed0: 616e 7920 6669 6c65 2066 6f72 6d61 7473  any file formats
+00008ee0: 0a20 2020 2020 2020 2020 2020 2028 652e  .            (e.
+00008ef0: 672e 2047 656f 7061 636b 6167 6529 2074  g. Geopackage) t
+00008f00: 6869 7320 6973 2073 6c6f 772c 2073 6f20  his is slow, so 
+00008f10: 7573 696e 6720 652e 672e 2061 2077 6865  using e.g. a whe
+00008f20: 7265 2066 696c 7465 7220 696e 7374 6561  re filter instea
+00008f30: 6420 6973 0a20 2020 2020 2020 2020 2020  d is.           
+00008f40: 2072 6563 6f6d 6d65 6e64 6564 2e20 4465   recommended. De
+00008f50: 6661 756c 7473 2074 6f20 4e6f 6e65 2c20  faults to None, 
+00008f60: 7468 656e 2061 6c6c 2072 6f77 7320 6172  then all rows ar
+00008f70: 6520 7265 7475 726e 6564 2e0a 2020 2020  e returned..    
+00008f80: 2020 2020 7768 6572 6520 2873 7472 2c20      where (str, 
+00008f90: 6f70 7469 6f6e 616c 293a 2077 6865 7265  optional): where
+00008fa0: 2063 6c61 7573 6520 746f 2066 696c 7465   clause to filte
+00008fb0: 7220 6665 6174 7572 6573 2069 6e20 6c61  r features in la
+00008fc0: 7965 7220 6279 2061 7474 7269 6275 7465  yer by attribute
+00008fd0: 0a20 2020 2020 2020 2020 2020 2076 616c  .            val
+00008fe0: 7565 732e 2049 6620 7468 6520 6461 7461  ues. If the data
+00008ff0: 736f 7572 6365 206e 6174 6976 656c 7920  source natively 
+00009000: 7375 7070 6f72 7473 2073 716c 2c20 6974  supports sql, it
+00009010: 7320 7370 6563 6966 6963 2053 514c 2064  s specific SQL d
+00009020: 6961 6c65 6374 0a20 2020 2020 2020 2020  ialect.         
+00009030: 2020 2073 686f 756c 6420 6265 2075 7365     should be use
+00009040: 6420 2865 672e 2053 514c 6974 6520 616e  d (eg. SQLite an
+00009050: 6420 4765 6f50 6163 6b61 6765 3a20 6053  d GeoPackage: `S
+00009060: 514c 4954 4560 5f2c 2050 6f73 7467 7265  QLITE`_, Postgre
+00009070: 5351 4c29 2e20 4966 2069 740a 2020 2020  SQL). If it.    
+00009080: 2020 2020 2020 2020 646f 6573 6e27 742c          doesn't,
+00009090: 2074 6865 2060 4f47 5253 514c 2057 4845   the `OGRSQL WHE
+000090a0: 5245 605f 2073 796e 7461 7820 7368 6f75  RE`_ syntax shou
+000090b0: 6c64 2062 6520 7573 6564 2e20 4e6f 7465  ld be used. Note
+000090c0: 2074 6861 7420 6974 2069 7320 6e6f 740a   that it is not.
+000090d0: 2020 2020 2020 2020 2020 2020 706f 7373              poss
+000090e0: 6962 6c65 2074 6f20 6f76 6572 7275 6c65  ible to overrule
+000090f0: 2074 6865 2053 514c 2064 6961 6c65 6374   the SQL dialect
+00009100: 2c20 7468 6973 2069 7320 6f6e 6c79 2070  , this is only p
+00009110: 6f73 7369 626c 6520 7768 656e 2079 6f75  ossible when you
+00009120: 2075 7365 2074 6865 0a20 2020 2020 2020   use the.       
+00009130: 2020 2020 2053 514c 2070 6172 616d 6574       SQL paramet
+00009140: 6572 2e20 4578 616d 706c 6573 3a20 6060  er. Examples: ``
+00009150: 2249 534f 5f41 3320 3d20 2743 414e 2722  "ISO_A3 = 'CAN'"
+00009160: 6060 2c0a 2020 2020 2020 2020 2020 2020  ``,.            
+00009170: 6060 2250 4f50 5f45 5354 203e 2031 3030  ``"POP_EST > 100
+00009180: 3030 3030 3020 414e 4420 504f 505f 4553  00000 AND POP_ES
+00009190: 5420 3c20 3130 3030 3030 3030 3022 6060  T < 100000000"``
+000091a0: 2e20 4465 6661 756c 7473 2074 6f20 4e6f  . Defaults to No
+000091b0: 6e65 2e0a 2020 2020 2020 2020 7371 6c5f  ne..        sql_
+000091c0: 7374 6d74 2028 7374 7229 3a20 5351 4c20  stmt (str): SQL 
+000091d0: 7374 6174 656d 656e 7420 746f 2075 7365  statement to use
+000091e0: 2e20 4f6e 6c79 2073 7570 706f 7274 6564  . Only supported
+000091f0: 2077 6974 6820 2270 796f 6772 696f 2220   with "pyogrio" 
+00009200: 656e 6769 6e65 2e0a 2020 2020 2020 2020  engine..        
+00009210: 7371 6c5f 6469 616c 6563 7420 2873 7472  sql_dialect (str
+00009220: 2c20 6f70 7469 6f6e 616c 293a 2053 514c  , optional): SQL
+00009230: 2064 6961 6c65 6374 2075 7365 642e 204f   dialect used. O
+00009240: 7074 696f 6e73 2061 7265 204e 6f6e 652c  ptions are None,
+00009250: 2022 5351 4c49 5445 2220 6f72 0a20 2020   "SQLITE" or.   
+00009260: 2020 2020 2020 2020 2022 4f47 5253 514c           "OGRSQL
+00009270: 222e 2049 6620 4e6f 6e65 2c20 666f 7220  ". If None, for 
+00009280: 6461 7461 2073 6f75 7263 6573 2077 6974  data sources wit
+00009290: 6820 6578 706c 6963 6974 2053 514c 2073  h explicit SQL s
+000092a0: 7570 706f 7274 2074 6865 2073 7461 7465  upport the state
+000092b0: 6d65 6e74 0a20 2020 2020 2020 2020 2020  ment.           
+000092c0: 2069 7320 7072 6f63 6573 7365 6420 6279   is processed by
+000092d0: 2074 6865 2064 6566 6175 6c74 2053 514c   the default SQL
+000092e0: 2065 6e67 696e 6520 2865 2e67 2e20 666f   engine (e.g. fo
+000092f0: 7220 4765 6f70 6163 6b61 6765 2061 6e64  r Geopackage and
+00009300: 2053 7061 7469 616c 6974 650a 2020 2020   Spatialite.    
+00009310: 2020 2020 2020 2020 7468 6973 2069 7320          this is 
+00009320: 2253 514c 4954 4522 292e 2046 6f72 2064  "SQLITE"). For d
+00009330: 6174 6120 736f 7572 6365 7320 7769 7468  ata sources with
+00009340: 6f75 7420 6e61 7469 7665 2053 514c 2073  out native SQL s
+00009350: 7570 706f 7274 2028 652e 672e 202e 7368  upport (e.g. .sh
+00009360: 7029 2c0a 2020 2020 2020 2020 2020 2020  p),.            
+00009370: 7468 6520 224f 4752 5351 4c22 2064 6961  the "OGRSQL" dia
+00009380: 6c65 6374 2069 7320 7468 6520 6465 6661  lect is the defa
+00009390: 756c 742e 2049 6620 7468 6520 2253 514c  ult. If the "SQL
+000093a0: 4954 4522 2064 6961 6c65 6374 2069 7320  ITE" dialect is 
+000093b0: 7370 6563 6966 6965 642c 0a20 2020 2020  specified,.     
+000093c0: 2020 2020 2020 207c 7370 6174 6961 6c69         |spatiali
+000093d0: 7465 5f72 6566 6572 656e 6365 5f6c 696e  te_reference_lin
+000093e0: 6b7c 2066 756e 6374 696f 6e73 2063 616e  k| functions can
+000093f0: 2061 6c73 6f20 6265 2075 7365 642e 2044   also be used. D
+00009400: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
+00009410: 0a20 2020 2020 2020 2069 676e 6f72 655f  .        ignore_
+00009420: 6765 6f6d 6574 7279 2028 626f 6f6c 2c20  geometry (bool, 
+00009430: 6f70 7469 6f6e 616c 293a 2054 7275 6520  optional): True 
+00009440: 6e6f 7420 746f 2072 6561 642f 7265 7475  not to read/retu
+00009450: 726e 2074 6865 2067 656f 6d65 7472 792e  rn the geometry.
+00009460: 0a20 2020 2020 2020 2020 2020 2044 6566  .            Def
+00009470: 6175 6c74 7320 746f 2046 616c 7365 2e0a  aults to False..
+00009480: 2020 2020 2020 2020 6669 645f 6173 5f69          fid_as_i
+00009490: 6e64 6578 2028 626f 6f6c 2c20 6f70 7469  ndex (bool, opti
+000094a0: 6f6e 616c 293a 2049 6620 5472 7565 2c20  onal): If True, 
+000094b0: 7769 6c6c 2075 7365 2074 6865 2046 4944  will use the FID
+000094c0: 7320 6f66 2074 6865 2066 6561 7475 7265  s of the feature
+000094d0: 7320 7468 6174 0a20 2020 2020 2020 2020  s that.         
+000094e0: 2020 2077 6572 6520 7265 6164 2061 7320     were read as 
+000094f0: 7468 6520 696e 6465 7820 6f66 2074 6865  the index of the
+00009500: 2047 656f 4461 7461 4672 616d 652e 204d   GeoDataFrame. M
+00009510: 6179 2073 7461 7274 2061 7420 3020 6f72  ay start at 0 or
+00009520: 2031 2064 6570 656e 6469 6e67 206f 6e0a   1 depending on.
+00009530: 2020 2020 2020 2020 2020 2020 7468 6520              the 
+00009540: 6472 6976 6572 2e20 4465 6661 756c 7473  driver. Defaults
+00009550: 2074 6f20 4661 6c73 652e 0a0a 2020 2020   to False...    
+00009560: 5261 6973 6573 3a0a 2020 2020 2020 2020  Raises:.        
+00009570: 5661 6c75 6545 7272 6f72 3a20 616e 2069  ValueError: an i
+00009580: 6e76 616c 6964 2070 6172 616d 6574 6572  nvalid parameter
+00009590: 2076 616c 7565 2077 6173 2070 6173 7365   value was passe
+000095a0: 642e 0a0a 2020 2020 5265 7475 726e 733a  d...    Returns:
+000095b0: 0a20 2020 2020 2020 2067 7064 2e47 656f  .        gpd.Geo
+000095c0: 4461 7461 4672 616d 653a 2074 6865 2064  DataFrame: the d
+000095d0: 6174 6120 7265 6164 2e0a 0a20 2020 202e  ata read...    .
+000095e0: 2e20 7c4f 4752 5351 4c20 5748 4552 457c  . |OGRSQL WHERE|
+000095f0: 2072 6177 3a3a 2068 746d 6c0a 0a20 2020   raw:: html..   
+00009600: 2020 2020 203c 6120 6872 6566 3d22 6874       <a href="ht
+00009610: 7470 733a 2f2f 6764 616c 2e6f 7267 2f75  tps://gdal.org/u
+00009620: 7365 722f 6f67 725f 7371 6c5f 6469 616c  ser/ogr_sql_dial
+00009630: 6563 742e 6874 6d6c 2377 6865 7265 2220  ect.html#where" 
+00009640: 7461 7267 6574 3d22 5f62 6c61 6e6b 223e  target="_blank">
+00009650: 4f47 5253 514c 2057 4845 5245 3c2f 613e  OGRSQL WHERE</a>
+00009660: 0a0a 2020 2020 2e2e 207c 7370 6174 6961  ..    .. |spatia
+00009670: 6c69 7465 5f72 6566 6572 656e 6365 5f6c  lite_reference_l
+00009680: 696e 6b7c 2072 6177 3a3a 2068 746d 6c0a  ink| raw:: html.
+00009690: 0a20 2020 2020 2020 203c 6120 6872 6566  .        <a href
+000096a0: 3d22 6874 7470 733a 2f2f 7777 772e 6761  ="https://www.ga
+000096b0: 6961 2d67 6973 2e69 742f 6761 6961 2d73  ia-gis.it/gaia-s
+000096c0: 696e 732f 7370 6174 6961 6c69 7465 2d73  ins/spatialite-s
+000096d0: 716c 2d6c 6174 6573 742e 6874 6d6c 2220  ql-latest.html" 
+000096e0: 7461 7267 6574 3d22 5f62 6c61 6e6b 223e  target="_blank">
+000096f0: 7370 6174 6961 6c69 7465 2072 6566 6572  spatialite refer
+00009700: 656e 6365 3c2f 613e 0a0a 2020 2020 2222  ence</a>..    ""
+00009710: 2220 2023 206e 6f71 613a 2045 3530 310a  "  # noqa: E501.
+00009720: 2020 2020 7265 7375 6c74 5f67 6466 203d      result_gdf =
+00009730: 205f 7265 6164 5f66 696c 655f 6261 7365   _read_file_base
+00009740: 280a 2020 2020 2020 2020 7061 7468 3d70  (.        path=p
+00009750: 6174 682c 0a20 2020 2020 2020 206c 6179  ath,.        lay
+00009760: 6572 3d6c 6179 6572 2c0a 2020 2020 2020  er=layer,.      
+00009770: 2020 636f 6c75 6d6e 733d 636f 6c75 6d6e    columns=column
+00009780: 732c 0a20 2020 2020 2020 2062 626f 783d  s,.        bbox=
+00009790: 6262 6f78 2c0a 2020 2020 2020 2020 726f  bbox,.        ro
+000097a0: 7773 3d72 6f77 732c 0a20 2020 2020 2020  ws=rows,.       
+000097b0: 2077 6865 7265 3d77 6865 7265 2c0a 2020   where=where,.  
+000097c0: 2020 2020 2020 7371 6c5f 7374 6d74 3d73        sql_stmt=s
+000097d0: 716c 5f73 746d 742c 0a20 2020 2020 2020  ql_stmt,.       
+000097e0: 2073 716c 5f64 6961 6c65 6374 3d73 716c   sql_dialect=sql
+000097f0: 5f64 6961 6c65 6374 2c0a 2020 2020 2020  _dialect,.      
+00009800: 2020 6967 6e6f 7265 5f67 656f 6d65 7472    ignore_geometr
+00009810: 793d 6967 6e6f 7265 5f67 656f 6d65 7472  y=ignore_geometr
+00009820: 792c 0a20 2020 2020 2020 2066 6964 5f61  y,.        fid_a
+00009830: 735f 696e 6465 783d 6669 645f 6173 5f69  s_index=fid_as_i
+00009840: 6e64 6578 2c0a 2020 2020 290a 0a20 2020  ndex,.    )..   
+00009850: 2023 204e 6f20 6173 7365 7274 2074 6f20   # No assert to 
+00009860: 6b65 6570 2062 6163 6b77 6172 6473 2063  keep backwards c
+00009870: 6f6d 7061 7469 6269 6c69 7479 0a20 2020  ompatibility.   
+00009880: 2072 6574 7572 6e20 7265 7375 6c74 5f67   return result_g
+00009890: 6466 0a0a 0a64 6566 2072 6561 645f 6669  df...def read_fi
+000098a0: 6c65 5f6e 6f67 656f 6d28 0a20 2020 2070  le_nogeom(.    p
+000098b0: 6174 683a 2055 6e69 6f6e 5b73 7472 2c20  ath: Union[str, 
+000098c0: 226f 732e 5061 7468 4c69 6b65 5b41 6e79  "os.PathLike[Any
+000098d0: 5d22 5d2c 0a20 2020 206c 6179 6572 3a20  ]"],.    layer: 
+000098e0: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
+000098f0: 4e6f 6e65 2c0a 2020 2020 636f 6c75 6d6e  None,.    column
+00009900: 733a 204f 7074 696f 6e61 6c5b 4974 6572  s: Optional[Iter
+00009910: 6162 6c65 5b73 7472 5d5d 203d 204e 6f6e  able[str]] = Non
+00009920: 652c 0a20 2020 2062 626f 783d 4e6f 6e65  e,.    bbox=None
+00009930: 2c0a 2020 2020 726f 7773 3d4e 6f6e 652c  ,.    rows=None,
+00009940: 0a20 2020 2073 716c 5f73 746d 743a 204f  .    sql_stmt: O
+00009950: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
+00009960: 6f6e 652c 0a20 2020 2073 716c 5f64 6961  one,.    sql_dia
+00009970: 6c65 6374 3a20 4f70 7469 6f6e 616c 5b4c  lect: Optional[L
+00009980: 6974 6572 616c 5b22 5351 4c49 5445 222c  iteral["SQLITE",
+00009990: 2022 4f47 5253 514c 225d 5d20 3d20 4e6f   "OGRSQL"]] = No
+000099a0: 6e65 2c0a 2020 2020 6669 645f 6173 5f69  ne,.    fid_as_i
+000099b0: 6e64 6578 3a20 626f 6f6c 203d 2046 616c  ndex: bool = Fal
+000099c0: 7365 2c0a 2920 2d3e 2070 642e 4461 7461  se,.) -> pd.Data
+000099d0: 4672 616d 653a 0a20 2020 2022 2222 0a20  Frame:.    """. 
+000099e0: 2020 2044 4550 5245 4341 5445 443a 2070     DEPRECATED: p
+000099f0: 6c65 6173 6520 7573 6520 7265 6164 5f66  lease use read_f
+00009a00: 696c 6520 7769 7468 206f 7074 696f 6e20  ile with option 
+00009a10: 6967 6e6f 7265 5f67 656f 6d65 7472 793d  ignore_geometry=
+00009a20: 5472 7565 2e0a 2020 2020 2222 220a 2020  True..    """.  
+00009a30: 2020 7761 726e 696e 6773 2e77 6172 6e28    warnings.warn(
+00009a40: 0a20 2020 2020 2020 2022 7265 6164 5f66  .        "read_f
+00009a50: 696c 655f 6e6f 6765 6f6d 2069 7320 6465  ile_nogeom is de
+00009a60: 7072 6563 6174 6564 3a20 7573 6520 7265  precated: use re
+00009a70: 6164 5f66 696c 6520 7769 7468 2069 676e  ad_file with ign
+00009a80: 6f72 655f 6765 6f6d 6574 7279 3d54 7275  ore_geometry=Tru
+00009a90: 6522 2c0a 2020 2020 2020 2020 4675 7475  e",.        Futu
+00009aa0: 7265 5761 726e 696e 672c 0a20 2020 2020  reWarning,.     
+00009ab0: 2020 2073 7461 636b 6c65 7665 6c3d 322c     stacklevel=2,
+00009ac0: 0a20 2020 2029 0a20 2020 2072 6573 756c  .    ).    resul
+00009ad0: 745f 6764 6620 3d20 5f72 6561 645f 6669  t_gdf = _read_fi
+00009ae0: 6c65 5f62 6173 6528 0a20 2020 2020 2020  le_base(.       
+00009af0: 2070 6174 683d 7061 7468 2c0a 2020 2020   path=path,.    
+00009b00: 2020 2020 6c61 7965 723d 6c61 7965 722c      layer=layer,
+00009b10: 0a20 2020 2020 2020 2063 6f6c 756d 6e73  .        columns
+00009b20: 3d63 6f6c 756d 6e73 2c0a 2020 2020 2020  =columns,.      
+00009b30: 2020 6262 6f78 3d62 626f 782c 0a20 2020    bbox=bbox,.   
+00009b40: 2020 2020 2072 6f77 733d 726f 7773 2c0a       rows=rows,.
+00009b50: 2020 2020 2020 2020 7371 6c5f 7374 6d74          sql_stmt
+00009b60: 3d73 716c 5f73 746d 742c 0a20 2020 2020  =sql_stmt,.     
+00009b70: 2020 2073 716c 5f64 6961 6c65 6374 3d73     sql_dialect=s
+00009b80: 716c 5f64 6961 6c65 6374 2c0a 2020 2020  ql_dialect,.    
+00009b90: 2020 2020 6967 6e6f 7265 5f67 656f 6d65      ignore_geome
+00009ba0: 7472 793d 5472 7565 2c0a 2020 2020 2020  try=True,.      
+00009bb0: 2020 6669 645f 6173 5f69 6e64 6578 3d66    fid_as_index=f
+00009bc0: 6964 5f61 735f 696e 6465 782c 0a20 2020  id_as_index,.   
+00009bd0: 2029 0a20 2020 2061 7373 6572 7420 6973   ).    assert is
+00009be0: 696e 7374 616e 6365 2872 6573 756c 745f  instance(result_
+00009bf0: 6764 662c 2070 642e 4461 7461 4672 616d  gdf, pd.DataFram
+00009c00: 6529 0a20 2020 2072 6574 7572 6e20 7265  e).    return re
+00009c10: 7375 6c74 5f67 6466 0a0a 0a64 6566 205f  sult_gdf...def _
+00009c20: 7265 6164 5f66 696c 655f 6261 7365 280a  read_file_base(.
+00009c30: 2020 2020 7061 7468 3a20 556e 696f 6e5b      path: Union[
+00009c40: 7374 722c 2022 6f73 2e50 6174 684c 696b  str, "os.PathLik
+00009c50: 655b 416e 795d 225d 2c0a 2020 2020 6c61  e[Any]"],.    la
+00009c60: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
+00009c70: 725d 203d 204e 6f6e 652c 0a20 2020 2063  r] = None,.    c
+00009c80: 6f6c 756d 6e73 3a20 4f70 7469 6f6e 616c  olumns: Optional
+00009c90: 5b49 7465 7261 626c 655b 7374 725d 5d20  [Iterable[str]] 
+00009ca0: 3d20 4e6f 6e65 2c0a 2020 2020 6262 6f78  = None,.    bbox
+00009cb0: 3d4e 6f6e 652c 0a20 2020 2072 6f77 733d  =None,.    rows=
+00009cc0: 4e6f 6e65 2c0a 2020 2020 7768 6572 653a  None,.    where:
+00009cd0: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
+00009ce0: 204e 6f6e 652c 0a20 2020 2073 716c 5f73   None,.    sql_s
+00009cf0: 746d 743a 204f 7074 696f 6e61 6c5b 7374  tmt: Optional[st
+00009d00: 725d 203d 204e 6f6e 652c 0a20 2020 2073  r] = None,.    s
+00009d10: 716c 5f64 6961 6c65 6374 3a20 4f70 7469  ql_dialect: Opti
+00009d20: 6f6e 616c 5b4c 6974 6572 616c 5b22 5351  onal[Literal["SQ
+00009d30: 4c49 5445 222c 2022 4f47 5253 514c 225d  LITE", "OGRSQL"]
+00009d40: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 6967  ] = None,.    ig
+00009d50: 6e6f 7265 5f67 656f 6d65 7472 793a 2062  nore_geometry: b
+00009d60: 6f6f 6c20 3d20 4661 6c73 652c 0a20 2020  ool = False,.   
+00009d70: 2066 6964 5f61 735f 696e 6465 783a 2062   fid_as_index: b
+00009d80: 6f6f 6c20 3d20 4661 6c73 652c 0a29 202d  ool = False,.) -
+00009d90: 3e20 556e 696f 6e5b 7064 2e44 6174 6146  > Union[pd.DataF
+00009da0: 7261 6d65 2c20 6770 642e 4765 6f44 6174  rame, gpd.GeoDat
+00009db0: 6146 7261 6d65 5d3a 0a20 2020 2022 2222  aFrame]:.    """
+00009dc0: 0a20 2020 2052 6561 6473 2061 2066 696c  .    Reads a fil
+00009dd0: 6520 746f 2061 2070 616e 6461 7320 4461  e to a pandas Da
+00009de0: 7461 6672 616d 652e 0a20 2020 2022 2222  taframe..    """
+00009df0: 0a20 2020 2023 2043 6865 636b 2069 6620  .    # Check if 
+00009e00: 7468 6520 6669 6420 636f 6c75 6d6e 206e  the fid column n
+00009e10: 6565 6473 2074 6f20 6265 2072 6561 6420  eeds to be read 
+00009e20: 6173 2063 6f6c 756d 6e20 7669 6120 7468  as column via th
+00009e30: 6520 636f 6c75 6d6e 7320 7061 7261 6d65  e columns parame
+00009e40: 7465 720a 2020 2020 6669 645f 6173 5f63  ter.    fid_as_c
+00009e50: 6f6c 756d 6e20 3d20 4661 6c73 650a 2020  olumn = False.  
+00009e60: 2020 6966 2063 6f6c 756d 6e73 2069 7320    if columns is 
+00009e70: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+00009e80: 2020 6966 2022 6669 6422 2069 6e20 5b63    if "fid" in [c
+00009e90: 6f6c 756d 6e2e 6c6f 7765 7228 2920 666f  olumn.lower() fo
+00009ea0: 7220 636f 6c75 6d6e 2069 6e20 636f 6c75  r column in colu
+00009eb0: 6d6e 735d 3a0a 2020 2020 2020 2020 2020  mns]:.          
+00009ec0: 2020 6669 645f 6173 5f63 6f6c 756d 6e20    fid_as_column 
+00009ed0: 3d20 5472 7565 0a0a 2020 2020 2320 5265  = True..    # Re
+00009ee0: 6164 2077 6974 6820 7468 6520 656e 6769  ad with the engi
+00009ef0: 6e65 2073 7065 6369 6669 6564 0a20 2020  ne specified.   
+00009f00: 2065 6e67 696e 6520 3d20 5f67 6574 5f65   engine = _get_e
+00009f10: 6e67 696e 6528 290a 2020 2020 6966 2065  ngine().    if e
+00009f20: 6e67 696e 6520 3d3d 2022 7079 6f67 7269  ngine == "pyogri
+00009f30: 6f22 3a0a 2020 2020 2020 2020 6764 6620  o":.        gdf 
+00009f40: 3d20 5f72 6561 645f 6669 6c65 5f62 6173  = _read_file_bas
+00009f50: 655f 7079 6f67 7269 6f28 0a20 2020 2020  e_pyogrio(.     
+00009f60: 2020 2020 2020 2070 6174 683d 7061 7468         path=path
+00009f70: 2c0a 2020 2020 2020 2020 2020 2020 6c61  ,.            la
+00009f80: 7965 723d 6c61 7965 722c 0a20 2020 2020  yer=layer,.     
+00009f90: 2020 2020 2020 2063 6f6c 756d 6e73 3d63         columns=c
+00009fa0: 6f6c 756d 6e73 2c0a 2020 2020 2020 2020  olumns,.        
+00009fb0: 2020 2020 6262 6f78 3d62 626f 782c 0a20      bbox=bbox,. 
+00009fc0: 2020 2020 2020 2020 2020 2072 6f77 733d             rows=
+00009fd0: 726f 7773 2c0a 2020 2020 2020 2020 2020  rows,.          
+00009fe0: 2020 7768 6572 653d 7768 6572 652c 0a20    where=where,. 
+00009ff0: 2020 2020 2020 2020 2020 2073 716c 5f73             sql_s
+0000a000: 746d 743d 7371 6c5f 7374 6d74 2c0a 2020  tmt=sql_stmt,.  
+0000a010: 2020 2020 2020 2020 2020 7371 6c5f 6469            sql_di
+0000a020: 616c 6563 743d 7371 6c5f 6469 616c 6563  alect=sql_dialec
+0000a030: 742c 0a20 2020 2020 2020 2020 2020 2069  t,.            i
+0000a040: 676e 6f72 655f 6765 6f6d 6574 7279 3d69  gnore_geometry=i
+0000a050: 676e 6f72 655f 6765 6f6d 6574 7279 2c0a  gnore_geometry,.
+0000a060: 2020 2020 2020 2020 2020 2020 6669 645f              fid_
+0000a070: 6173 5f69 6e64 6578 3d66 6964 5f61 735f  as_index=fid_as_
+0000a080: 696e 6465 7820 6f72 2066 6964 5f61 735f  index or fid_as_
+0000a090: 636f 6c75 6d6e 2c0a 2020 2020 2020 2020  column,.        
+0000a0a0: 290a 2020 2020 656c 6966 2065 6e67 696e  ).    elif engin
+0000a0b0: 6520 3d3d 2022 6669 6f6e 6122 3a0a 2020  e == "fiona":.  
+0000a0c0: 2020 2020 2020 6764 6620 3d20 5f72 6561        gdf = _rea
+0000a0d0: 645f 6669 6c65 5f62 6173 655f 6669 6f6e  d_file_base_fion
+0000a0e0: 6128 0a20 2020 2020 2020 2020 2020 2070  a(.            p
+0000a0f0: 6174 683d 7061 7468 2c0a 2020 2020 2020  ath=path,.      
+0000a100: 2020 2020 2020 6c61 7965 723d 6c61 7965        layer=laye
+0000a110: 722c 0a20 2020 2020 2020 2020 2020 2063  r,.            c
+0000a120: 6f6c 756d 6e73 3d63 6f6c 756d 6e73 2c0a  olumns=columns,.
+0000a130: 2020 2020 2020 2020 2020 2020 6262 6f78              bbox
+0000a140: 3d62 626f 782c 0a20 2020 2020 2020 2020  =bbox,.         
+0000a150: 2020 2072 6f77 733d 726f 7773 2c0a 2020     rows=rows,.  
+0000a160: 2020 2020 2020 2020 2020 7768 6572 653d            where=
+0000a170: 7768 6572 652c 0a20 2020 2020 2020 2020  where,.         
+0000a180: 2020 2073 716c 5f73 746d 743d 7371 6c5f     sql_stmt=sql_
+0000a190: 7374 6d74 2c0a 2020 2020 2020 2020 2020  stmt,.          
+0000a1a0: 2020 7371 6c5f 6469 616c 6563 743d 7371    sql_dialect=sq
+0000a1b0: 6c5f 6469 616c 6563 742c 0a20 2020 2020  l_dialect,.     
+0000a1c0: 2020 2020 2020 2069 676e 6f72 655f 6765         ignore_ge
+0000a1d0: 6f6d 6574 7279 3d69 676e 6f72 655f 6765  ometry=ignore_ge
+0000a1e0: 6f6d 6574 7279 2c0a 2020 2020 2020 2020  ometry,.        
+0000a1f0: 2020 2020 6669 645f 6173 5f69 6e64 6578      fid_as_index
+0000a200: 3d66 6964 5f61 735f 696e 6465 7820 6f72  =fid_as_index or
+0000a210: 2066 6964 5f61 735f 636f 6c75 6d6e 2c0a   fid_as_column,.
+0000a220: 2020 2020 2020 2020 290a 2020 2020 656c          ).    el
+0000a230: 7365 3a0a 2020 2020 2020 2020 7261 6973  se:.        rais
+0000a240: 6520 5661 6c75 6545 7272 6f72 2866 2255  e ValueError(f"U
+0000a250: 6e73 7570 706f 7274 6564 2065 6e67 696e  nsupported engin
+0000a260: 653a 207b 656e 6769 6e65 7d22 290a 0a20  e: {engine}").. 
+0000a270: 2020 2023 2043 6f70 7920 7468 6520 696e     # Copy the in
+0000a280: 6465 7820 746f 2061 2063 6f6c 756d 6e20  dex to a column 
+0000a290: 6966 206e 6565 6465 642e 2e2e 0a20 2020  if needed....   
+0000a2a0: 2069 6620 6669 645f 6173 5f63 6f6c 756d   if fid_as_colum
+0000a2b0: 6e3a 0a20 2020 2020 2020 2067 6466 5b22  n:.        gdf["
+0000a2c0: 6669 6422 5d20 3d20 6764 662e 696e 6465  fid"] = gdf.inde
+0000a2d0: 780a 2020 2020 2020 2020 6966 206e 6f74  x.        if not
+0000a2e0: 2066 6964 5f61 735f 696e 6465 783a 0a20   fid_as_index:. 
+0000a2f0: 2020 2020 2020 2020 2020 2067 6466 203d             gdf =
+0000a300: 2067 6466 2e72 6573 6574 5f69 6e64 6578   gdf.reset_index
+0000a310: 2864 726f 703d 5472 7565 290a 0a20 2020  (drop=True)..   
+0000a320: 2072 6574 7572 6e20 6764 660a 0a0a 6465   return gdf...de
+0000a330: 6620 5f72 6561 645f 6669 6c65 5f62 6173  f _read_file_bas
+0000a340: 655f 6669 6f6e 6128 0a20 2020 2070 6174  e_fiona(.    pat
+0000a350: 683a 2055 6e69 6f6e 5b73 7472 2c20 226f  h: Union[str, "o
+0000a360: 732e 5061 7468 4c69 6b65 5b41 6e79 5d22  s.PathLike[Any]"
+0000a370: 5d2c 0a20 2020 206c 6179 6572 3a20 4f70  ],.    layer: Op
+0000a380: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
+0000a390: 6e65 2c0a 2020 2020 636f 6c75 6d6e 733a  ne,.    columns:
+0000a3a0: 204f 7074 696f 6e61 6c5b 4974 6572 6162   Optional[Iterab
+0000a3b0: 6c65 5b73 7472 5d5d 203d 204e 6f6e 652c  le[str]] = None,
+0000a3c0: 0a20 2020 2062 626f 783d 4e6f 6e65 2c0a  .    bbox=None,.
+0000a3d0: 2020 2020 726f 7773 3d4e 6f6e 652c 0a20      rows=None,. 
+0000a3e0: 2020 2077 6865 7265 3a20 4f70 7469 6f6e     where: Option
+0000a3f0: 616c 5b73 7472 5d20 3d20 4e6f 6e65 2c0a  al[str] = None,.
+0000a400: 2020 2020 7371 6c5f 7374 6d74 3a20 4f70      sql_stmt: Op
+0000a410: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
+0000a420: 6e65 2c0a 2020 2020 7371 6c5f 6469 616c  ne,.    sql_dial
+0000a430: 6563 743a 204f 7074 696f 6e61 6c5b 4c69  ect: Optional[Li
+0000a440: 7465 7261 6c5b 2253 514c 4954 4522 2c20  teral["SQLITE", 
+0000a450: 224f 4752 5351 4c22 5d5d 203d 204e 6f6e  "OGRSQL"]] = Non
+0000a460: 652c 0a20 2020 2069 676e 6f72 655f 6765  e,.    ignore_ge
+0000a470: 6f6d 6574 7279 3a20 626f 6f6c 203d 2046  ometry: bool = F
+0000a480: 616c 7365 2c0a 2020 2020 6669 645f 6173  alse,.    fid_as
+0000a490: 5f69 6e64 6578 3a20 626f 6f6c 203d 2046  _index: bool = F
+0000a4a0: 616c 7365 2c0a 2920 2d3e 2055 6e69 6f6e  alse,.) -> Union
+0000a4b0: 5b70 642e 4461 7461 4672 616d 652c 2067  [pd.DataFrame, g
+0000a4c0: 7064 2e47 656f 4461 7461 4672 616d 655d  pd.GeoDataFrame]
+0000a4d0: 3a0a 2020 2020 2222 220a 2020 2020 5265  :.    """.    Re
+0000a4e0: 6164 7320 6120 6669 6c65 2074 6f20 6120  ads a file to a 
+0000a4f0: 7061 6e64 6173 2044 6174 6166 7261 6d65  pandas Dataframe
+0000a500: 2075 7369 6e67 2066 696f 6e61 2e0a 2020   using fiona..  
+0000a510: 2020 2222 220a 2020 2020 6966 2069 676e    """.    if ign
+0000a520: 6f72 655f 6765 6f6d 6574 7279 2061 6e64  ore_geometry and
+0000a530: 2063 6f6c 756d 6e73 203d 3d20 5b5d 3a0a   columns == []:.
+0000a540: 2020 2020 2020 2020 7265 7475 726e 2070          return p
+0000a550: 642e 4461 7461 4672 616d 6528 290a 2020  d.DataFrame().  
+0000a560: 2020 6966 2073 716c 5f73 746d 7420 6973    if sql_stmt is
+0000a570: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+0000a580: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+0000a590: 726f 7228 2273 716c 5f73 746d 7420 6973  ror("sql_stmt is
+0000a5a0: 206e 6f74 2073 7570 706f 7274 6564 2077   not supported w
+0000a5b0: 6974 6820 6669 6f6e 6120 656e 6769 6e65  ith fiona engine
+0000a5c0: 2229 0a0a 2020 2020 2320 496e 6974 0a20  ")..    # Init. 
+0000a5d0: 2020 2070 6174 6820 3d20 5061 7468 2870     path = Path(p
+0000a5e0: 6174 6829 0a20 2020 2069 6620 7061 7468  ath).    if path
+0000a5f0: 2e65 7869 7374 7328 2920 6973 2046 616c  .exists() is Fal
+0000a600: 7365 3a0a 2020 2020 2020 2020 7261 6973  se:.        rais
+0000a610: 6520 5661 6c75 6545 7272 6f72 2866 2266  e ValueError(f"f
+0000a620: 696c 6520 646f 6573 6e27 7420 6578 6973  ile doesn't exis
+0000a630: 743a 207b 7061 7468 7d22 290a 0a20 2020  t: {path}")..   
+0000a640: 2023 2049 6620 6e6f 206c 6179 6572 206e   # If no layer n
+0000a650: 616d 6520 7370 6563 6966 6965 642c 2063  ame specified, c
+0000a660: 6865 636b 2069 6620 7468 6572 6520 6973  heck if there is
+0000a670: 206f 6e6c 7920 6f6e 6520 6c61 7965 7220   only one layer 
+0000a680: 696e 2074 6865 2066 696c 652e 0a20 2020  in the file..   
+0000a690: 2069 6620 6c61 7965 7220 6973 204e 6f6e   if layer is Non
+0000a6a0: 653a 0a20 2020 2020 2020 206c 6179 6572  e:.        layer
+0000a6b0: 203d 2067 6574 5f6f 6e6c 795f 6c61 7965   = get_only_laye
+0000a6c0: 7228 7061 7468 290a 0a20 2020 2023 2056  r(path)..    # V
+0000a6d0: 4552 5920 4449 5254 5920 6861 636b 2074  ERY DIRTY hack t
+0000a6e0: 6f20 6765 7420 7468 6520 6669 640a 2020  o get the fid.  
+0000a6f0: 2020 6966 2066 6964 5f61 735f 696e 6465    if fid_as_inde
+0000a700: 783a 0a20 2020 2020 2020 2023 204d 616b  x:.        # Mak
+0000a710: 6520 6120 636f 7079 2f63 6f70 7920 696e  e a copy/copy in
+0000a720: 7075 7420 6669 6c65 2074 6f20 6765 6f70  put file to geop
+0000a730: 6163 6b61 6765 2c20 6173 2077 6520 7769  ackage, as we wi
+0000a740: 6c6c 2061 6464 2061 6e20 6669 642f 726f  ll add an fid/ro
+0000a750: 7764 2063 6f6c 756d 6e0a 2020 2020 2020  wd column.      
+0000a760: 2020 746d 705f 6669 645f 7061 7468 203d    tmp_fid_path =
+0000a770: 2050 6174 6828 7465 6d70 6669 6c65 2e6d   Path(tempfile.m
+0000a780: 6b64 7465 6d70 2829 2920 2f20 6622 7b70  kdtemp()) / f"{p
+0000a790: 6174 682e 7374 656d 7d2e 6770 6b67 220a  ath.stem}.gpkg".
+0000a7a0: 2020 2020 2020 2020 7061 7468 5f69 6e66          path_inf
+0000a7b0: 6f20 3d20 5f67 656f 6669 6c65 696e 666f  o = _geofileinfo
+0000a7c0: 2e67 6574 5f67 656f 6669 6c65 696e 666f  .get_geofileinfo
+0000a7d0: 2870 6174 6829 0a20 2020 2020 2020 2074  (path).        t
+0000a7e0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+0000a7f0: 6966 2070 6174 685f 696e 666f 2e64 7269  if path_info.dri
+0000a800: 7665 7220 3d3d 2022 4750 4b47 223a 0a20  ver == "GPKG":. 
+0000a810: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0000a820: 6f70 7928 7061 7468 2c20 746d 705f 6669  opy(path, tmp_fi
+0000a830: 645f 7061 7468 290a 2020 2020 2020 2020  d_path).        
+0000a840: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000a850: 2020 2020 2020 2020 2020 636f 7079 5f6c            copy_l
+0000a860: 6179 6572 2870 6174 682c 2074 6d70 5f66  ayer(path, tmp_f
+0000a870: 6964 5f70 6174 6829 0a20 2020 2020 2020  id_path).       
+0000a880: 2020 2020 2069 6620 7061 7468 5f69 6e66       if path_inf
+0000a890: 6f2e 6973 5f66 6964 5f7a 6572 6f62 6173  o.is_fid_zerobas
+0000a8a0: 6564 3a0a 2020 2020 2020 2020 2020 2020  ed:.            
+0000a8b0: 2020 2020 2320 6669 6420 696e 2073 6861      # fid in sha
+0000a8c0: 7065 6669 6c65 2069 7320 3020 6261 7365  pefile is 0 base
+0000a8d0: 642c 2073 6f20 6669 642d 310a 2020 2020  d, so fid-1.    
+0000a8e0: 2020 2020 2020 2020 2020 2020 6164 645f              add_
+0000a8f0: 636f 6c75 6d6e 2874 6d70 5f66 6964 5f70  column(tmp_fid_p
+0000a900: 6174 682c 2022 5f5f 544d 505f 4745 4f46  ath, "__TMP_GEOF
+0000a910: 494c 454f 5053 5f46 4944 222c 2022 494e  ILEOPS_FID", "IN
+0000a920: 5445 4745 5222 2c20 2266 6964 2d31 2229  TEGER", "fid-1")
+0000a930: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+0000a940: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000a950: 2020 2061 6464 5f63 6f6c 756d 6e28 746d     add_column(tm
+0000a960: 705f 6669 645f 7061 7468 2c20 225f 5f54  p_fid_path, "__T
+0000a970: 4d50 5f47 454f 4649 4c45 4f50 535f 4649  MP_GEOFILEOPS_FI
+0000a980: 4422 2c20 2249 4e54 4547 4552 222c 2022  D", "INTEGER", "
+0000a990: 6669 6422 290a 0a20 2020 2020 2020 2020  fid")..         
+0000a9a0: 2020 2070 6174 6820 3d20 746d 705f 6669     path = tmp_fi
+0000a9b0: 645f 7061 7468 0a20 2020 2020 2020 2066  d_path.        f
+0000a9c0: 696e 616c 6c79 3a0a 2020 2020 2020 2020  inally:.        
+0000a9d0: 2020 2020 6966 2074 6d70 5f66 6964 5f70      if tmp_fid_p
+0000a9e0: 6174 682e 7061 7265 6e74 2e65 7869 7374  ath.parent.exist
+0000a9f0: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
+0000aa00: 2020 2020 2073 6875 7469 6c2e 726d 7472       shutil.rmtr
+0000aa10: 6565 2874 6d70 5f66 6964 5f70 6174 682c  ee(tmp_fid_path,
+0000aa20: 2069 676e 6f72 655f 6572 726f 7273 3d54   ignore_errors=T
+0000aa30: 7275 6529 0a0a 2020 2020 2320 4368 6563  rue)..    # Chec
+0000aa40: 6b69 6e67 2069 6620 6669 656c 642f 636f  king if field/co
+0000aa50: 6c75 6d6e 206e 616d 6573 2073 686f 756c  lumn names shoul
+0000aa60: 6420 6265 2072 6561 6420 6973 2063 6173  d be read is cas
+0000aa70: 6520 7365 6e73 6974 6976 6520 696e 2066  e sensitive in f
+0000aa80: 696f 6e61 2c20 736f 0a20 2020 2023 206d  iona, so.    # m
+0000aa90: 616b 6520 7375 7265 2074 6865 2063 6f6c  ake sure the col
+0000aaa0: 756d 6e20 6e61 6d65 7320 7370 6563 6966  umn names specif
+0000aab0: 6965 6420 6861 7665 2074 6865 2073 616d  ied have the sam
+0000aac0: 6520 6361 7369 6e67 2e0a 2020 2020 636f  e casing..    co
+0000aad0: 6c75 6d6e 735f 7072 6570 6172 6564 203d  lumns_prepared =
+0000aae0: 204e 6f6e 650a 2020 2020 6966 2063 6f6c   None.    if col
+0000aaf0: 756d 6e73 2069 7320 6e6f 7420 4e6f 6e65  umns is not None
+0000ab00: 3a0a 2020 2020 2020 2020 6c61 7965 7269  :.        layeri
+0000ab10: 6e66 6f20 3d20 6765 745f 6c61 7965 7269  nfo = get_layeri
+0000ab20: 6e66 6f28 7061 7468 2c20 6c61 7965 723d  nfo(path, layer=
+0000ab30: 6c61 7965 722c 2072 6169 7365 5f6f 6e5f  layer, raise_on_
+0000ab40: 6e6f 6765 6f6d 3d46 616c 7365 290a 2020  nogeom=False).  
+0000ab50: 2020 2020 2020 636f 6c75 6d6e 735f 7570        columns_up
+0000ab60: 7065 725f 6c6f 6f6b 7570 203d 207b 636f  per_lookup = {co
+0000ab70: 6c75 6d6e 2e75 7070 6572 2829 3a20 636f  lumn.upper(): co
+0000ab80: 6c75 6d6e 2066 6f72 2063 6f6c 756d 6e20  lumn for column 
+0000ab90: 696e 2063 6f6c 756d 6e73 7d0a 2020 2020  in columns}.    
+0000aba0: 2020 2020 636f 6c75 6d6e 735f 7072 6570      columns_prep
+0000abb0: 6172 6564 203d 207b 0a20 2020 2020 2020  ared = {.       
+0000abc0: 2020 2020 2063 6f6c 756d 6e3a 2063 6f6c       column: col
+0000abd0: 756d 6e73 5f75 7070 6572 5f6c 6f6f 6b75  umns_upper_looku
+0000abe0: 705b 636f 6c75 6d6e 2e75 7070 6572 2829  p[column.upper()
+0000abf0: 5d0a 2020 2020 2020 2020 2020 2020 666f  ].            fo
+0000ac00: 7220 636f 6c75 6d6e 2069 6e20 6c61 7965  r column in laye
+0000ac10: 7269 6e66 6f2e 636f 6c75 6d6e 730a 2020  rinfo.columns.  
+0000ac20: 2020 2020 2020 2020 2020 6966 2063 6f6c            if col
+0000ac30: 756d 6e2e 7570 7065 7228 2920 696e 2063  umn.upper() in c
+0000ac40: 6f6c 756d 6e73 5f75 7070 6572 5f6c 6f6f  olumns_upper_loo
+0000ac50: 6b75 700a 2020 2020 2020 2020 7d0a 0a20  kup.        }.. 
+0000ac60: 2020 2023 2052 6561 642e 2e2e 0a20 2020     # Read....   
+0000ac70: 2063 6f6c 756d 6e73 5f6c 6973 7420 3d20   columns_list = 
+0000ac80: 4e6f 6e65 2069 6620 636f 6c75 6d6e 735f  None if columns_
+0000ac90: 7072 6570 6172 6564 2069 7320 4e6f 6e65  prepared is None
+0000aca0: 2065 6c73 6520 6c69 7374 2863 6f6c 756d   else list(colum
+0000acb0: 6e73 5f70 7265 7061 7265 6429 0a20 2020  ns_prepared).   
+0000acc0: 2072 6573 756c 745f 6764 6620 3d20 6770   result_gdf = gp
+0000acd0: 642e 7265 6164 5f66 696c 6528 0a20 2020  d.read_file(.   
+0000ace0: 2020 2020 2073 7472 2870 6174 6829 2c0a       str(path),.
+0000acf0: 2020 2020 2020 2020 6c61 7965 723d 6c61          layer=la
+0000ad00: 7965 722c 0a20 2020 2020 2020 2062 626f  yer,.        bbo
+0000ad10: 783d 6262 6f78 2c0a 2020 2020 2020 2020  x=bbox,.        
+0000ad20: 726f 7773 3d72 6f77 732c 0a20 2020 2020  rows=rows,.     
+0000ad30: 2020 2069 6e63 6c75 6465 5f66 6965 6c64     include_field
+0000ad40: 733d 636f 6c75 6d6e 735f 6c69 7374 2c0a  s=columns_list,.
+0000ad50: 2020 2020 2020 2020 7768 6572 653d 7768          where=wh
+0000ad60: 6572 652c 0a20 2020 2020 2020 2073 716c  ere,.        sql
+0000ad70: 3d73 716c 5f73 746d 742c 0a20 2020 2020  =sql_stmt,.     
+0000ad80: 2020 2073 716c 5f64 6961 6c65 6374 3d73     sql_dialect=s
+0000ad90: 716c 5f64 6961 6c65 6374 2c0a 2020 2020  ql_dialect,.    
+0000ada0: 2020 2020 6967 6e6f 7265 5f67 656f 6d65      ignore_geome
+0000adb0: 7472 793d 6967 6e6f 7265 5f67 656f 6d65  try=ignore_geome
+0000adc0: 7472 792c 0a20 2020 2029 0a0a 2020 2020  try,.    )..    
+0000add0: 2320 5365 7420 7468 6520 696e 6465 7820  # Set the index 
+0000ade0: 746f 2074 6865 2062 6163 6b65 642d 7570  to the backed-up
+0000adf0: 2066 6964 0a20 2020 2069 6620 6669 645f   fid.    if fid_
+0000ae00: 6173 5f69 6e64 6578 3a0a 2020 2020 2020  as_index:.      
+0000ae10: 2020 7265 7375 6c74 5f67 6466 203d 2072    result_gdf = r
+0000ae20: 6573 756c 745f 6764 662e 7365 745f 696e  esult_gdf.set_in
+0000ae30: 6465 7828 225f 5f54 4d50 5f47 454f 4649  dex("__TMP_GEOFI
+0000ae40: 4c45 4f50 535f 4649 4422 290a 2020 2020  LEOPS_FID").    
+0000ae50: 2020 2020 7265 7375 6c74 5f67 6466 2e69      result_gdf.i
+0000ae60: 6e64 6578 2e6e 616d 6520 3d20 2266 6964  ndex.name = "fid
+0000ae70: 220a 0a20 2020 2023 2052 656f 7264 6572  "..    # Reorder
+0000ae80: 2063 6f6c 756d 6e73 202b 2063 6861 6e67   columns + chang
+0000ae90: 6520 6361 7369 6e67 2073 6f20 7468 6579  e casing so they
+0000aea0: 2061 7265 2074 6865 2073 616d 6520 6173   are the same as
+0000aeb0: 2063 6f6c 756d 6e73 2070 6172 616d 6574   columns paramet
+0000aec0: 6572 0a20 2020 2069 6620 636f 6c75 6d6e  er.    if column
+0000aed0: 735f 7072 6570 6172 6564 2069 7320 6e6f  s_prepared is no
+0000aee0: 7420 4e6f 6e65 2061 6e64 206c 656e 2863  t None and len(c
+0000aef0: 6f6c 756d 6e73 5f70 7265 7061 7265 6429  olumns_prepared)
+0000af00: 203e 2030 3a0a 2020 2020 2020 2020 636f   > 0:.        co
+0000af10: 6c75 6d6e 735f 746f 5f6b 6565 7020 3d20  lumns_to_keep = 
+0000af20: 6c69 7374 2863 6f6c 756d 6e73 5f70 7265  list(columns_pre
+0000af30: 7061 7265 6429 0a20 2020 2020 2020 2069  pared).        i
+0000af40: 6620 2267 656f 6d65 7472 7922 2069 6e20  f "geometry" in 
+0000af50: 7265 7375 6c74 5f67 6466 2e63 6f6c 756d  result_gdf.colum
+0000af60: 6e73 3a0a 2020 2020 2020 2020 2020 2020  ns:.            
+0000af70: 636f 6c75 6d6e 735f 746f 5f6b 6565 7020  columns_to_keep 
+0000af80: 2b3d 205b 2267 656f 6d65 7472 7922 5d0a  += ["geometry"].
+0000af90: 2020 2020 2020 2020 7265 7375 6c74 5f67          result_g
+0000afa0: 6466 203d 2072 6573 756c 745f 6764 665b  df = result_gdf[
+0000afb0: 636f 6c75 6d6e 735f 746f 5f6b 6565 705d  columns_to_keep]
+0000afc0: 0a20 2020 2020 2020 2072 6573 756c 745f  .        result_
+0000afd0: 6764 6620 3d20 7265 7375 6c74 5f67 6466  gdf = result_gdf
+0000afe0: 2e72 656e 616d 6528 636f 6c75 6d6e 733d  .rename(columns=
+0000aff0: 636f 6c75 6d6e 735f 7072 6570 6172 6564  columns_prepared
+0000b000: 290a 0a20 2020 2023 2053 7461 7274 696e  )..    # Startin
+0000b010: 6720 6672 6f6d 2066 696f 6e61 2031 2e39  g from fiona 1.9
+0000b020: 2c20 7374 7269 6e67 2063 6f6c 756d 6e73  , string columns
+0000b030: 2077 6974 6820 616c 6c20 4e6f 6e65 2076   with all None v
+0000b040: 616c 7565 7320 6172 6520 7265 6164 2061  alues are read a
+0000b050: 7320 6265 696e 670a 2020 2020 2320 666c  s being.    # fl
+0000b060: 6f61 7420 636f 6c75 6d6e 732e 2043 6f6e  oat columns. Con
+0000b070: 7665 7274 2074 6865 6d20 746f 206f 626a  vert them to obj
+0000b080: 6563 7420 7479 7065 2e0a 2020 2020 666c  ect type..    fl
+0000b090: 6f61 745f 636f 6c73 203d 206c 6973 7428  oat_cols = list(
+0000b0a0: 7265 7375 6c74 5f67 6466 2e73 656c 6563  result_gdf.selec
+0000b0b0: 745f 6474 7970 6573 285b 2266 6c6f 6174  t_dtypes(["float
+0000b0c0: 3634 225d 292e 636f 6c75 6d6e 7329 0a20  64"]).columns). 
+0000b0d0: 2020 2069 6620 6c65 6e28 666c 6f61 745f     if len(float_
+0000b0e0: 636f 6c73 2920 3e20 303a 0a20 2020 2020  cols) > 0:.     
+0000b0f0: 2020 2023 2043 6865 636b 2066 6f72 2061     # Check for a
+0000b100: 6c6c 2066 6c6f 6174 2063 6f6c 756d 6e73  ll float columns
+0000b110: 2066 6f75 6e64 2069 6620 7468 6579 2073   found if they s
+0000b120: 686f 756c 6420 6265 206f 626a 6563 7420  hould be object 
+0000b130: 636f 6c75 6d6e 7320 696e 7374 6561 640a  columns instead.
+0000b140: 2020 2020 2020 2020 7769 7468 2066 696f          with fio
+0000b150: 6e61 2e6f 7065 6e28 7061 7468 2c20 6c61  na.open(path, la
+0000b160: 7965 723d 6c61 7965 7229 2061 7320 636f  yer=layer) as co
+0000b170: 6c6c 6563 7469 6f6e 3a0a 2020 2020 2020  llection:.      
+0000b180: 2020 2020 2020 6173 7365 7274 2063 6f6c        assert col
+0000b190: 6c65 6374 696f 6e2e 7363 6865 6d61 2069  lection.schema i
+0000b1a0: 7320 6e6f 7420 4e6f 6e65 0a20 2020 2020  s not None.     
+0000b1b0: 2020 2020 2020 2070 726f 7065 7274 6965         propertie
+0000b1c0: 7320 3d20 636f 6c6c 6563 7469 6f6e 2e73  s = collection.s
+0000b1d0: 6368 656d 615b 2270 726f 7065 7274 6965  chema["propertie
+0000b1e0: 7322 5d0a 2020 2020 2020 2020 2020 2020  s"].            
+0000b1f0: 666f 7220 636f 6c20 696e 2066 6c6f 6174  for col in float
+0000b200: 5f63 6f6c 733a 0a20 2020 2020 2020 2020  _cols:.         
+0000b210: 2020 2020 2020 2069 6620 636f 6c20 696e         if col in
+0000b220: 2070 726f 7065 7274 6965 7320 616e 6420   properties and 
+0000b230: 7072 6f70 6572 7469 6573 5b63 6f6c 5d2e  properties[col].
+0000b240: 7374 6172 7473 7769 7468 2822 7374 7222  startswith("str"
+0000b250: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000b260: 2020 2020 2020 2072 6573 756c 745f 6764         result_gd
+0000b270: 665b 636f 6c5d 203d 2028 0a20 2020 2020  f[col] = (.     
+0000b280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b290: 2020 2072 6573 756c 745f 6764 665b 636f     result_gdf[co
+0000b2a0: 6c5d 2e61 7374 7970 6528 6f62 6a65 6374  l].astype(object
+0000b2b0: 292e 7265 706c 6163 6528 6e70 2e6e 616e  ).replace(np.nan
+0000b2c0: 2c20 4e6f 6e65 290a 2020 2020 2020 2020  , None).        
+0000b2d0: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+0000b2e0: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
+0000b2f0: 5f67 6466 0a0a 0a64 6566 205f 7265 6164  _gdf...def _read
+0000b300: 5f66 696c 655f 6261 7365 5f70 796f 6772  _file_base_pyogr
+0000b310: 696f 280a 2020 2020 7061 7468 3a20 556e  io(.    path: Un
+0000b320: 696f 6e5b 7374 722c 2022 6f73 2e50 6174  ion[str, "os.Pat
+0000b330: 684c 696b 655b 416e 795d 225d 2c0a 2020  hLike[Any]"],.  
+0000b340: 2020 6c61 7965 723a 204f 7074 696f 6e61    layer: Optiona
+0000b350: 6c5b 7374 725d 203d 204e 6f6e 652c 0a20  l[str] = None,. 
+0000b360: 2020 2063 6f6c 756d 6e73 3a20 4f70 7469     columns: Opti
+0000b370: 6f6e 616c 5b49 7465 7261 626c 655b 7374  onal[Iterable[st
+0000b380: 725d 5d20 3d20 4e6f 6e65 2c0a 2020 2020  r]] = None,.    
+0000b390: 6262 6f78 3d4e 6f6e 652c 0a20 2020 2072  bbox=None,.    r
+0000b3a0: 6f77 733d 4e6f 6e65 2c0a 2020 2020 7768  ows=None,.    wh
+0000b3b0: 6572 653a 204f 7074 696f 6e61 6c5b 7374  ere: Optional[st
+0000b3c0: 725d 203d 204e 6f6e 652c 0a20 2020 2073  r] = None,.    s
+0000b3d0: 716c 5f73 746d 743a 204f 7074 696f 6e61  ql_stmt: Optiona
+0000b3e0: 6c5b 7374 725d 203d 204e 6f6e 652c 0a20  l[str] = None,. 
+0000b3f0: 2020 2073 716c 5f64 6961 6c65 6374 3a20     sql_dialect: 
+0000b400: 4f70 7469 6f6e 616c 5b4c 6974 6572 616c  Optional[Literal
+0000b410: 5b22 5351 4c49 5445 222c 2022 4f47 5253  ["SQLITE", "OGRS
+0000b420: 514c 225d 5d20 3d20 4e6f 6e65 2c0a 2020  QL"]] = None,.  
+0000b430: 2020 6967 6e6f 7265 5f67 656f 6d65 7472    ignore_geometr
+0000b440: 793a 2062 6f6f 6c20 3d20 4661 6c73 652c  y: bool = False,
+0000b450: 0a20 2020 2066 6964 5f61 735f 696e 6465  .    fid_as_inde
+0000b460: 783a 2062 6f6f 6c20 3d20 4661 6c73 652c  x: bool = False,
+0000b470: 0a29 202d 3e20 556e 696f 6e5b 7064 2e44  .) -> Union[pd.D
+0000b480: 6174 6146 7261 6d65 2c20 6770 642e 4765  ataFrame, gpd.Ge
+0000b490: 6f44 6174 6146 7261 6d65 5d3a 0a20 2020  oDataFrame]:.   
+0000b4a0: 2022 2222 0a20 2020 2052 6561 6473 2061   """.    Reads a
+0000b4b0: 2066 696c 6520 746f 2061 2070 616e 6461   file to a panda
+0000b4c0: 7320 4461 7461 6672 616d 6520 7573 696e  s Dataframe usin
+0000b4d0: 6720 7079 6f67 7269 6f2e 0a20 2020 2022  g pyogrio..    "
+0000b4e0: 2222 0a20 2020 2023 2049 6e69 740a 2020  "".    # Init.  
+0000b4f0: 2020 7061 7468 203d 2050 6174 6828 7061    path = Path(pa
+0000b500: 7468 290a 2020 2020 6966 2070 6174 682e  th).    if path.
+0000b510: 6578 6973 7473 2829 2069 7320 4661 6c73  exists() is Fals
+0000b520: 653a 0a20 2020 2020 2020 2072 6169 7365  e:.        raise
+0000b530: 2056 616c 7565 4572 726f 7228 6622 6669   ValueError(f"fi
+0000b540: 6c65 2064 6f65 736e 2774 2065 7869 7374  le doesn't exist
+0000b550: 3a20 7b70 6174 687d 2229 0a0a 2020 2020  : {path}")..    
+0000b560: 2320 436f 6e76 6572 7420 726f 7773 2073  # Convert rows s
+0000b570: 6c69 6365 206f 626a 6563 7420 746f 2070  lice object to p
+0000b580: 796f 6772 696f 2070 6172 616d 6574 6572  yogrio parameter
+0000b590: 730a 2020 2020 6966 2072 6f77 7320 6973  s.    if rows is
+0000b5a0: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+0000b5b0: 2020 2073 6b69 705f 6665 6174 7572 6573     skip_features
+0000b5c0: 203d 2072 6f77 732e 7374 6172 740a 2020   = rows.start.  
+0000b5d0: 2020 2020 2020 6d61 785f 6665 6174 7572        max_featur
+0000b5e0: 6573 203d 2072 6f77 732e 7374 6f70 202d  es = rows.stop -
+0000b5f0: 2072 6f77 732e 7374 6172 740a 2020 2020   rows.start.    
+0000b600: 656c 7365 3a0a 2020 2020 2020 2020 736b  else:.        sk
+0000b610: 6970 5f66 6561 7475 7265 7320 3d20 300a  ip_features = 0.
+0000b620: 2020 2020 2020 2020 6d61 785f 6665 6174          max_feat
+0000b630: 7572 6573 203d 204e 6f6e 650a 2020 2020  ures = None.    
+0000b640: 2320 4172 726f 7720 646f 6573 6e27 7420  # Arrow doesn't 
+0000b650: 7375 7070 6f72 7420 6669 6c74 6572 696e  support filterin
+0000b660: 6720 726f 7773 206c 696b 6520 7468 6973  g rows like this
+0000b670: 0a20 2020 2023 2075 7365 5f61 7272 6f77  .    # use_arrow
+0000b680: 203d 2054 7275 6520 6966 2072 6f77 7320   = True if rows 
+0000b690: 6973 204e 6f6e 6520 656c 7365 2046 616c  is None else Fal
+0000b6a0: 7365 0a0a 2020 2020 2320 4966 206e 6f20  se..    # If no 
+0000b6b0: 7371 6c5f 7374 6d74 2073 7065 6369 6669  sql_stmt specifi
+0000b6c0: 6564 0a20 2020 2063 6f6c 756d 6e73 5f70  ed.    columns_p
+0000b6d0: 7265 7061 7265 6420 3d20 4e6f 6e65 0a20  repared = None. 
+0000b6e0: 2020 2069 6620 7371 6c5f 7374 6d74 2069     if sql_stmt i
+0000b6f0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+0000b700: 2320 4966 206e 6f20 6c61 7965 7220 7370  # If no layer sp
+0000b710: 6563 6966 6965 642c 2074 6865 7265 2073  ecified, there s
+0000b720: 686f 756c 6420 6265 206f 6e6c 7920 6f6e  hould be only on
+0000b730: 6520 6c61 7965 7220 696e 2074 6865 2066  e layer in the f
+0000b740: 696c 652e 0a20 2020 2020 2020 2069 6620  ile..        if 
+0000b750: 6c61 7965 7220 6973 204e 6f6e 653a 0a20  layer is None:. 
+0000b760: 2020 2020 2020 2020 2020 206c 6179 6572             layer
+0000b770: 203d 2067 6574 5f6f 6e6c 795f 6c61 7965   = get_only_laye
+0000b780: 7228 7061 7468 290a 0a20 2020 2020 2020  r(path)..       
+0000b790: 2023 2043 6865 636b 696e 6720 6966 2063   # Checking if c
+0000b7a0: 6f6c 756d 6e20 6e61 6d65 7320 7368 6f75  olumn names shou
+0000b7b0: 6c64 2062 6520 7265 6164 2069 7320 6361  ld be read is ca
+0000b7c0: 7365 2073 656e 7369 7469 7665 2069 6e20  se sensitive in 
+0000b7d0: 7079 6f67 7269 6f2c 2073 6f0a 2020 2020  pyogrio, so.    
+0000b7e0: 2020 2020 2320 6d61 6b65 2073 7572 6520      # make sure 
+0000b7f0: 7468 6520 636f 6c75 6d6e 206e 616d 6573  the column names
+0000b800: 2073 7065 6369 6669 6564 2068 6176 6520   specified have 
+0000b810: 7468 6520 7361 6d65 2063 6173 696e 672e  the same casing.
+0000b820: 0a20 2020 2020 2020 2069 6620 636f 6c75  .        if colu
+0000b830: 6d6e 7320 6973 206e 6f74 204e 6f6e 653a  mns is not None:
+0000b840: 0a20 2020 2020 2020 2020 2020 206c 6179  .            lay
+0000b850: 6572 696e 666f 203d 2067 6574 5f6c 6179  erinfo = get_lay
+0000b860: 6572 696e 666f 2870 6174 682c 206c 6179  erinfo(path, lay
+0000b870: 6572 3d6c 6179 6572 2c20 7261 6973 655f  er=layer, raise_
+0000b880: 6f6e 5f6e 6f67 656f 6d3d 4661 6c73 6529  on_nogeom=False)
+0000b890: 0a20 2020 2020 2020 2020 2020 2063 6f6c  .            col
+0000b8a0: 756d 6e73 5f75 7070 6572 5f6c 6f6f 6b75  umns_upper_looku
+0000b8b0: 7020 3d20 7b63 6f6c 756d 6e2e 7570 7065  p = {column.uppe
+0000b8c0: 7228 293a 2063 6f6c 756d 6e20 666f 7220  r(): column for 
+0000b8d0: 636f 6c75 6d6e 2069 6e20 636f 6c75 6d6e  column in column
+0000b8e0: 737d 0a20 2020 2020 2020 2020 2020 2063  s}.            c
+0000b8f0: 6f6c 756d 6e73 5f70 7265 7061 7265 6420  olumns_prepared 
+0000b900: 3d20 7b0a 2020 2020 2020 2020 2020 2020  = {.            
+0000b910: 2020 2020 636f 6c75 6d6e 3a20 636f 6c75      column: colu
+0000b920: 6d6e 735f 7570 7065 725f 6c6f 6f6b 7570  mns_upper_lookup
+0000b930: 5b63 6f6c 756d 6e2e 7570 7065 7228 295d  [column.upper()]
+0000b940: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b950: 2066 6f72 2063 6f6c 756d 6e20 696e 206c   for column in l
+0000b960: 6179 6572 696e 666f 2e63 6f6c 756d 6e73  ayerinfo.columns
+0000b970: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b980: 2069 6620 636f 6c75 6d6e 2e75 7070 6572   if column.upper
+0000b990: 2829 2069 6e20 636f 6c75 6d6e 735f 7570  () in columns_up
+0000b9a0: 7065 725f 6c6f 6f6b 7570 0a20 2020 2020  per_lookup.     
+0000b9b0: 2020 2020 2020 207d 0a20 2020 2065 6c73         }.    els
+0000b9c0: 653a 0a20 2020 2020 2020 2023 2046 696c  e:.        # Fil
+0000b9d0: 6c20 6f75 7420 706c 6163 6568 6f6c 6465  l out placeholde
+0000b9e0: 7273 2c20 6b65 6570 2063 6f6c 756d 6e73  rs, keep columns
+0000b9f0: 5f70 7265 7061 7265 6420 4e6f 6e65 2062  _prepared None b
+0000ba00: 6563 6175 7365 2063 6f6c 756d 6e20 6669  ecause column fi
+0000ba10: 6c74 6572 696e 670a 2020 2020 2020 2020  ltering.        
+0000ba20: 2320 7368 6f75 6c64 2068 6170 7065 6e20  # should happen 
+0000ba30: 696e 2073 716c 5f73 746d 742e 0a20 2020  in sql_stmt..   
+0000ba40: 2020 2020 2073 716c 5f73 746d 7420 3d20       sql_stmt = 
+0000ba50: 5f66 696c 6c5f 6f75 745f 7371 6c5f 706c  _fill_out_sql_pl
+0000ba60: 6163 6568 6f6c 6465 7273 280a 2020 2020  aceholders(.    
+0000ba70: 2020 2020 2020 2020 7061 7468 3d70 6174          path=pat
+0000ba80: 682c 206c 6179 6572 3d6c 6179 6572 2c20  h, layer=layer, 
+0000ba90: 7371 6c5f 7374 6d74 3d73 716c 5f73 746d  sql_stmt=sql_stm
+0000baa0: 742c 2063 6f6c 756d 6e73 3d63 6f6c 756d  t, columns=colum
+0000bab0: 6e73 0a20 2020 2020 2020 2029 0a20 2020  ns.        ).   
+0000bac0: 2020 2020 2023 2053 7065 6369 6679 696e       # Specifyin
+0000bad0: 6720 6120 6c61 7965 7220 6173 2077 656c  g a layer as wel
+0000bae0: 6c20 6173 2061 6e20 5351 4c20 7374 6174  l as an SQL stat
+0000baf0: 656d 656e 7420 696e 2070 796f 6772 696f  ement in pyogrio
+0000bb00: 2069 7320 6e6f 7420 7375 7070 6f72 7465   is not supporte
+0000bb10: 642e 0a20 2020 2020 2020 206c 6179 6572  d..        layer
+0000bb20: 203d 204e 6f6e 650a 0a20 2020 2023 2052   = None..    # R
+0000bb30: 6561 6421 0a20 2020 2063 6f6c 756d 6e73  ead!.    columns
+0000bb40: 5f6c 6973 7420 3d20 4e6f 6e65 2069 6620  _list = None if 
+0000bb50: 636f 6c75 6d6e 735f 7072 6570 6172 6564  columns_prepared
+0000bb60: 2069 7320 4e6f 6e65 2065 6c73 6520 6c69   is None else li
+0000bb70: 7374 2863 6f6c 756d 6e73 5f70 7265 7061  st(columns_prepa
+0000bb80: 7265 6429 0a20 2020 2072 6573 756c 745f  red).    result_
+0000bb90: 6764 6620 3d20 7079 6f67 7269 6f2e 7265  gdf = pyogrio.re
+0000bba0: 6164 5f64 6174 6166 7261 6d65 280a 2020  ad_dataframe(.  
+0000bbb0: 2020 2020 2020 7061 7468 2c0a 2020 2020        path,.    
+0000bbc0: 2020 2020 6c61 7965 723d 6c61 7965 722c      layer=layer,
+0000bbd0: 0a20 2020 2020 2020 2063 6f6c 756d 6e73  .        columns
+0000bbe0: 3d63 6f6c 756d 6e73 5f6c 6973 742c 0a20  =columns_list,. 
+0000bbf0: 2020 2020 2020 2062 626f 783d 6262 6f78         bbox=bbox
+0000bc00: 2c0a 2020 2020 2020 2020 736b 6970 5f66  ,.        skip_f
+0000bc10: 6561 7475 7265 733d 736b 6970 5f66 6561  eatures=skip_fea
+0000bc20: 7475 7265 732c 0a20 2020 2020 2020 206d  tures,.        m
+0000bc30: 6178 5f66 6561 7475 7265 733d 6d61 785f  ax_features=max_
+0000bc40: 6665 6174 7572 6573 2c0a 2020 2020 2020  features,.      
+0000bc50: 2020 7768 6572 653d 7768 6572 652c 0a20    where=where,. 
+0000bc60: 2020 2020 2020 2073 716c 3d73 716c 5f73         sql=sql_s
+0000bc70: 746d 742c 0a20 2020 2020 2020 2073 716c  tmt,.        sql
+0000bc80: 5f64 6961 6c65 6374 3d73 716c 5f64 6961  _dialect=sql_dia
+0000bc90: 6c65 6374 2c0a 2020 2020 2020 2020 7265  lect,.        re
+0000bca0: 6164 5f67 656f 6d65 7472 793d 6e6f 7420  ad_geometry=not 
+0000bcb0: 6967 6e6f 7265 5f67 656f 6d65 7472 792c  ignore_geometry,
+0000bcc0: 0a20 2020 2020 2020 2066 6964 5f61 735f  .        fid_as_
+0000bcd0: 696e 6465 783d 6669 645f 6173 5f69 6e64  index=fid_as_ind
+0000bce0: 6578 2c0a 2020 2020 2020 2020 2320 7573  ex,.        # us
+0000bcf0: 655f 6172 726f 773d 7573 655f 6172 726f  e_arrow=use_arro
+0000bd00: 772c 0a20 2020 2029 0a0a 2020 2020 2320  w,.    )..    # 
+0000bd10: 5265 6f72 6465 7220 636f 6c75 6d6e 7320  Reorder columns 
+0000bd20: 2b20 6368 616e 6765 2063 6173 696e 6720  + change casing 
+0000bd30: 736f 2074 6865 7920 6172 6520 7468 6520  so they are the 
+0000bd40: 7361 6d65 2061 7320 636f 6c75 6d6e 7320  same as columns 
+0000bd50: 7061 7261 6d65 7465 720a 2020 2020 6966  parameter.    if
+0000bd60: 2063 6f6c 756d 6e73 5f70 7265 7061 7265   columns_prepare
+0000bd70: 6420 6973 206e 6f74 204e 6f6e 6520 616e  d is not None an
+0000bd80: 6420 6c65 6e28 636f 6c75 6d6e 735f 7072  d len(columns_pr
+0000bd90: 6570 6172 6564 2920 3e20 303a 0a20 2020  epared) > 0:.   
+0000bda0: 2020 2020 2063 6f6c 756d 6e73 5f74 6f5f       columns_to_
+0000bdb0: 6b65 6570 203d 206c 6973 7428 636f 6c75  keep = list(colu
+0000bdc0: 6d6e 735f 7072 6570 6172 6564 290a 2020  mns_prepared).  
+0000bdd0: 2020 2020 2020 6966 206c 6179 6572 696e        if layerin
+0000bde0: 666f 2e67 656f 6d65 7472 7963 6f6c 756d  fo.geometrycolum
+0000bdf0: 6e20 6973 206e 6f74 204e 6f6e 6520 616e  n is not None an
+0000be00: 6420 6e6f 7420 6967 6e6f 7265 5f67 656f  d not ignore_geo
+0000be10: 6d65 7472 793a 0a20 2020 2020 2020 2020  metry:.         
+0000be20: 2020 2063 6f6c 756d 6e73 5f74 6f5f 6b65     columns_to_ke
+0000be30: 6570 202b 3d20 5b22 6765 6f6d 6574 7279  ep += ["geometry
+0000be40: 225d 0a20 2020 2020 2020 2072 6573 756c  "].        resul
+0000be50: 745f 6764 6620 3d20 7265 7375 6c74 5f67  t_gdf = result_g
+0000be60: 6466 5b63 6f6c 756d 6e73 5f74 6f5f 6b65  df[columns_to_ke
+0000be70: 6570 5d0a 2020 2020 2020 2020 7265 7375  ep].        resu
+0000be80: 6c74 5f67 6466 203d 2072 6573 756c 745f  lt_gdf = result_
+0000be90: 6764 662e 7265 6e61 6d65 2863 6f6c 756d  gdf.rename(colum
+0000bea0: 6e73 3d63 6f6c 756d 6e73 5f70 7265 7061  ns=columns_prepa
+0000beb0: 7265 6429 0a0a 2020 2020 2320 4361 7374  red)..    # Cast
+0000bec0: 2063 6f6c 756d 6e73 2074 6861 7420 6172   columns that ar
+0000bed0: 6520 6f66 206f 626a 6563 7420 7479 7065  e of object type
+0000bee0: 2c20 6275 7420 636f 6e74 6169 6e20 6461  , but contain da
+0000bef0: 7465 7469 6d65 2e64 6174 6520 6f72 2064  tetime.date or d
+0000bf00: 6174 6574 696d 652e 6461 7465 0a20 2020  atetime.date.   
+0000bf10: 2023 2074 6f20 7072 6f70 6572 2064 6174   # to proper dat
+0000bf20: 6574 696d 6536 3420 636f 6c75 6d6e 732e  etime64 columns.
+0000bf30: 0a20 2020 2069 6620 6c65 6e28 7265 7375  .    if len(resu
+0000bf40: 6c74 5f67 6466 2920 3e20 303a 0a20 2020  lt_gdf) > 0:.   
+0000bf50: 2020 2020 2066 6f72 2063 6f6c 756d 6e20       for column 
+0000bf60: 696e 2072 6573 756c 745f 6764 662e 7365  in result_gdf.se
+0000bf70: 6c65 6374 5f64 7479 7065 7328 696e 636c  lect_dtypes(incl
+0000bf80: 7564 653d 5b22 6f62 6a65 6374 225d 293a  ude=["object"]):
+0000bf90: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000bfa0: 6973 696e 7374 616e 6365 280a 2020 2020  isinstance(.    
+0000bfb0: 2020 2020 2020 2020 2020 2020 7265 7375              resu
+0000bfc0: 6c74 5f67 6466 5b63 6f6c 756d 6e5d 2e69  lt_gdf[column].i
+0000bfd0: 6c6f 635b 305d 2c20 2864 6174 6574 696d  loc[0], (datetim
+0000bfe0: 652e 6461 7465 2c20 6461 7465 7469 6d65  e.date, datetime
+0000bff0: 2e64 6174 6574 696d 6529 0a20 2020 2020  .datetime).     
+0000c000: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
+0000c010: 2020 2020 2020 2020 2020 7265 7375 6c74            result
+0000c020: 5f67 6466 5b63 6f6c 756d 6e5d 203d 2070  _gdf[column] = p
+0000c030: 642e 746f 5f64 6174 6574 696d 6528 7265  d.to_datetime(re
+0000c040: 7375 6c74 5f67 6466 5b63 6f6c 756d 6e5d  sult_gdf[column]
+0000c050: 290a 0a20 2020 2061 7373 6572 7420 6973  )..    assert is
+0000c060: 696e 7374 616e 6365 2872 6573 756c 745f  instance(result_
+0000c070: 6764 662c 2028 6770 642e 4765 6f44 6174  gdf, (gpd.GeoDat
+0000c080: 6146 7261 6d65 2c20 7064 2e44 6174 6146  aFrame, pd.DataF
+0000c090: 7261 6d65 2929 0a20 2020 2072 6574 7572  rame)).    retur
+0000c0a0: 6e20 7265 7375 6c74 5f67 6466 0a0a 0a64  n result_gdf...d
+0000c0b0: 6566 205f 6669 6c6c 5f6f 7574 5f73 716c  ef _fill_out_sql
+0000c0c0: 5f70 6c61 6365 686f 6c64 6572 7328 0a20  _placeholders(. 
+0000c0d0: 2020 2070 6174 683a 2050 6174 682c 206c     path: Path, l
+0000c0e0: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
+0000c0f0: 7472 5d2c 2073 716c 5f73 746d 743a 2073  tr], sql_stmt: s
+0000c100: 7472 2c20 636f 6c75 6d6e 733a 204f 7074  tr, columns: Opt
+0000c110: 696f 6e61 6c5b 4974 6572 6162 6c65 5b73  ional[Iterable[s
+0000c120: 7472 5d5d 0a29 202d 3e20 7374 723a 0a20  tr]].) -> str:. 
+0000c130: 2020 2023 2046 696c 6c20 6f75 7420 706c     # Fill out pl
+0000c140: 6163 6568 6f6c 6465 7273 2069 6e20 7468  aceholders in th
+0000c150: 6520 7371 6c5f 7374 6d74 2069 6620 6e65  e sql_stmt if ne
+0000c160: 6564 6564 3a0a 2020 2020 706c 6163 6568  eded:.    placeh
+0000c170: 6f6c 6465 7273 203d 205b 0a20 2020 2020  olders = [.     
+0000c180: 2020 206e 616d 6520 666f 7220 5f2c 206e     name for _, n
+0000c190: 616d 652c 205f 2c20 5f20 696e 2073 7472  ame, _, _ in str
+0000c1a0: 696e 672e 466f 726d 6174 7465 7228 292e  ing.Formatter().
+0000c1b0: 7061 7273 6528 7371 6c5f 7374 6d74 2920  parse(sql_stmt) 
+0000c1c0: 6966 206e 616d 650a 2020 2020 5d0a 2020  if name.    ].  
+0000c1d0: 2020 6c61 7965 725f 746d 7020 3d20 6c61    layer_tmp = la
+0000c1e0: 7965 720a 2020 2020 6c61 7965 7269 6e66  yer.    layerinf
+0000c1f0: 6f20 3d20 4e6f 6e65 0a20 2020 2066 6f72  o = None.    for
+0000c200: 6d61 745f 6b77 6172 6773 3a20 4469 6374  mat_kwargs: Dict
+0000c210: 5b73 7472 2c20 416e 795d 203d 207b 7d0a  [str, Any] = {}.
+0000c220: 2020 2020 666f 7220 706c 6163 6568 6f6c      for placehol
+0000c230: 6465 7220 696e 2070 6c61 6365 686f 6c64  der in placehold
+0000c240: 6572 733a 0a20 2020 2020 2020 2069 6620  ers:.        if 
+0000c250: 6c61 7965 725f 746d 7020 6973 204e 6f6e  layer_tmp is Non
+0000c260: 653a 0a20 2020 2020 2020 2020 2020 206c  e:.            l
+0000c270: 6179 6572 5f74 6d70 203d 2067 6574 5f6f  ayer_tmp = get_o
+0000c280: 6e6c 795f 6c61 7965 7228 7061 7468 290a  nly_layer(path).
+0000c290: 0a20 2020 2020 2020 2069 6620 706c 6163  .        if plac
+0000c2a0: 6568 6f6c 6465 7220 3d3d 2022 696e 7075  eholder == "inpu
+0000c2b0: 745f 6c61 7965 7222 3a0a 2020 2020 2020  t_layer":.      
+0000c2c0: 2020 2020 2020 666f 726d 6174 5f6b 7761        format_kwa
+0000c2d0: 7267 735b 706c 6163 6568 6f6c 6465 725d  rgs[placeholder]
+0000c2e0: 203d 206c 6179 6572 5f74 6d70 0a20 2020   = layer_tmp.   
+0000c2f0: 2020 2020 2065 6c69 6620 706c 6163 6568       elif placeh
+0000c300: 6f6c 6465 7220 3d3d 2022 6765 6f6d 6574  older == "geomet
+0000c310: 7279 636f 6c75 6d6e 223a 0a20 2020 2020  rycolumn":.     
+0000c320: 2020 2020 2020 2069 6620 6c61 7965 7269         if layeri
+0000c330: 6e66 6f20 6973 204e 6f6e 653a 0a20 2020  nfo is None:.   
+0000c340: 2020 2020 2020 2020 2020 2020 206c 6179               lay
+0000c350: 6572 696e 666f 203d 2067 6574 5f6c 6179  erinfo = get_lay
+0000c360: 6572 696e 666f 2870 6174 682c 206c 6179  erinfo(path, lay
+0000c370: 6572 5f74 6d70 290a 2020 2020 2020 2020  er_tmp).        
+0000c380: 2020 2020 666f 726d 6174 5f6b 7761 7267      format_kwarg
+0000c390: 735b 706c 6163 6568 6f6c 6465 725d 203d  s[placeholder] =
+0000c3a0: 206c 6179 6572 696e 666f 2e67 656f 6d65   layerinfo.geome
+0000c3b0: 7472 7963 6f6c 756d 6e0a 2020 2020 2020  trycolumn.      
+0000c3c0: 2020 656c 6966 2070 6c61 6365 686f 6c64    elif placehold
+0000c3d0: 6572 203d 3d20 2263 6f6c 756d 6e73 5f74  er == "columns_t
+0000c3e0: 6f5f 7365 6c65 6374 5f73 7472 223a 0a20  o_select_str":. 
+0000c3f0: 2020 2020 2020 2020 2020 2069 6620 6c61             if la
+0000c400: 7965 7269 6e66 6f20 6973 204e 6f6e 653a  yerinfo is None:
+0000c410: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c420: 206c 6179 6572 696e 666f 203d 2067 6574   layerinfo = get
+0000c430: 5f6c 6179 6572 696e 666f 2870 6174 682c  _layerinfo(path,
+0000c440: 206c 6179 6572 5f74 6d70 290a 2020 2020   layer_tmp).    
+0000c450: 2020 2020 2020 2020 636f 6c75 6d6e 735f          columns_
+0000c460: 6173 6b65 6420 3d20 4e6f 6e65 2069 6620  asked = None if 
+0000c470: 636f 6c75 6d6e 7320 6973 204e 6f6e 6520  columns is None 
+0000c480: 656c 7365 206c 6973 7428 636f 6c75 6d6e  else list(column
+0000c490: 7329 0a20 2020 2020 2020 2020 2020 2066  s).            f
+0000c4a0: 6f72 6d61 7474 6572 203d 205f 6f67 725f  ormatter = _ogr_
+0000c4b0: 7371 6c5f 7574 696c 2e43 6f6c 756d 6e46  sql_util.ColumnF
+0000c4c0: 6f72 6d61 7474 6572 280a 2020 2020 2020  ormatter(.      
+0000c4d0: 2020 2020 2020 2020 2020 636f 6c75 6d6e            column
+0000c4e0: 735f 6173 6b65 643d 636f 6c75 6d6e 735f  s_asked=columns_
+0000c4f0: 6173 6b65 642c 0a20 2020 2020 2020 2020  asked,.         
+0000c500: 2020 2020 2020 2063 6f6c 756d 6e73 5f69         columns_i
+0000c510: 6e5f 6c61 7965 723d 6c61 7965 7269 6e66  n_layer=layerinf
+0000c520: 6f2e 636f 6c75 6d6e 732c 0a20 2020 2020  o.columns,.     
+0000c530: 2020 2020 2020 2020 2020 2066 6964 5f63             fid_c
+0000c540: 6f6c 756d 6e3d 6c61 7965 7269 6e66 6f2e  olumn=layerinfo.
+0000c550: 6669 645f 636f 6c75 6d6e 2c0a 2020 2020  fid_column,.    
+0000c560: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000c570: 2020 2020 2020 666f 726d 6174 5f6b 7761        format_kwa
+0000c580: 7267 735b 706c 6163 6568 6f6c 6465 725d  rgs[placeholder]
+0000c590: 203d 2066 6f72 6d61 7474 6572 2e70 7265   = formatter.pre
+0000c5a0: 6669 7865 645f 616c 6961 7365 6428 290a  fixed_aliased().
+0000c5b0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0000c5c0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+0000c5d0: 2056 616c 7565 4572 726f 7228 0a20 2020   ValueError(.   
+0000c5e0: 2020 2020 2020 2020 2020 2020 2066 2275               f"u
+0000c5f0: 6e6b 6e6f 776e 2070 6c61 6365 686f 6c64  nknown placehold
+0000c600: 6572 207b 706c 6163 6568 6f6c 6465 727d  er {placeholder}
+0000c610: 2069 6e20 7371 6c5f 7374 6d74 3a20 7b73   in sql_stmt: {s
+0000c620: 716c 5f73 746d 747d 220a 2020 2020 2020  ql_stmt}".      
+0000c630: 2020 2020 2020 290a 0a20 2020 2069 6620        )..    if 
+0000c640: 6c65 6e28 666f 726d 6174 5f6b 7761 7267  len(format_kwarg
+0000c650: 7329 203e 2030 3a0a 2020 2020 2020 2020  s) > 0:.        
+0000c660: 7371 6c5f 7374 6d74 203d 2073 716c 5f73  sql_stmt = sql_s
+0000c670: 746d 742e 666f 726d 6174 282a 2a66 6f72  tmt.format(**for
+0000c680: 6d61 745f 6b77 6172 6773 290a 2020 2020  mat_kwargs).    
+0000c690: 7265 7475 726e 2073 716c 5f73 746d 740a  return sql_stmt.
+0000c6a0: 0a0a 6465 6620 7265 6164 5f66 696c 655f  ..def read_file_
+0000c6b0: 7371 6c28 0a20 2020 2070 6174 683a 2055  sql(.    path: U
+0000c6c0: 6e69 6f6e 5b73 7472 2c20 226f 732e 5061  nion[str, "os.Pa
+0000c6d0: 7468 4c69 6b65 5b41 6e79 5d22 5d2c 0a20  thLike[Any]"],. 
+0000c6e0: 2020 2073 716c 5f73 746d 743a 2073 7472     sql_stmt: str
+0000c6f0: 2c0a 2020 2020 7371 6c5f 6469 616c 6563  ,.    sql_dialec
+0000c700: 743a 204f 7074 696f 6e61 6c5b 4c69 7465  t: Optional[Lite
+0000c710: 7261 6c5b 2253 514c 4954 4522 2c20 224f  ral["SQLITE", "O
+0000c720: 4752 5351 4c22 5d5d 203d 2022 5351 4c49  GRSQL"]] = "SQLI
+0000c730: 5445 222c 0a20 2020 206c 6179 6572 3a20  TE",.    layer: 
+0000c740: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
+0000c750: 4e6f 6e65 2c0a 2020 2020 6967 6e6f 7265  None,.    ignore
+0000c760: 5f67 656f 6d65 7472 793a 2062 6f6f 6c20  _geometry: bool 
+0000c770: 3d20 4661 6c73 652c 0a29 202d 3e20 556e  = False,.) -> Un
+0000c780: 696f 6e5b 7064 2e44 6174 6146 7261 6d65  ion[pd.DataFrame
+0000c790: 2c20 6770 642e 4765 6f44 6174 6146 7261  , gpd.GeoDataFra
+0000c7a0: 6d65 5d3a 0a20 2020 2022 2222 0a20 2020  me]:.    """.   
+0000c7b0: 2044 4550 5245 4341 5445 443a 2052 6561   DEPRECATED: Rea
+0000c7c0: 6473 2061 2066 696c 6520 7573 696e 6720  ds a file using 
+0000c7d0: 616e 2053 514c 2073 7461 7465 6d65 6e74  an SQL statement
+0000c7e0: 2e0a 0a20 2020 2041 7267 733a 0a20 2020  ...    Args:.   
+0000c7f0: 2020 2020 2070 6174 6820 2866 696c 6520       path (file 
+0000c800: 7061 7468 293a 2070 6174 6820 746f 2074  path): path to t
+0000c810: 6865 2066 696c 6520 746f 2072 6561 6420  he file to read 
+0000c820: 6672 6f6d 0a20 2020 2020 2020 2073 716c  from.        sql
+0000c830: 5f73 746d 7420 2873 7472 293a 2053 514c  _stmt (str): SQL
+0000c840: 2073 7461 7465 6d65 6e74 2074 6f20 7573   statement to us
+0000c850: 650a 2020 2020 2020 2020 7371 6c5f 6469  e.        sql_di
+0000c860: 616c 6563 7420 2873 7472 2c20 6f70 7469  alect (str, opti
+0000c870: 6f6e 616c 293a 2053 514c 2064 6961 6c65  onal): SQL diale
+0000c880: 6374 2075 7365 642e 2044 6566 6175 6c74  ct used. Default
+0000c890: 7320 746f 2027 5351 4c49 5445 272e 0a20  s to 'SQLITE'.. 
+0000c8a0: 2020 2020 2020 206c 6179 6572 2028 7374         layer (st
+0000c8b0: 722c 206f 7074 696f 6e61 6c29 3a20 5468  r, optional): Th
+0000c8c0: 6520 6c61 7965 7220 746f 2072 6561 642e  e layer to read.
+0000c8d0: 2049 6620 6e6f 206c 6179 6572 2069 7320   If no layer is 
+0000c8e0: 7370 6563 6966 6965 642c 0a20 2020 2020  specified,.     
+0000c8f0: 2020 2020 2020 2072 6561 6473 2074 6865         reads the
+0000c900: 206f 6e6c 7920 6c61 7965 7220 696e 2074   only layer in t
+0000c910: 6865 2066 696c 6520 6f72 2074 6872 6f77  he file or throw
+0000c920: 7320 616e 2045 7863 6570 7469 6f6e 2e0a  s an Exception..
+0000c930: 2020 2020 2020 2020 6967 6e6f 7265 5f67          ignore_g
+0000c940: 656f 6d65 7472 7920 2862 6f6f 6c2c 206f  eometry (bool, o
+0000c950: 7074 696f 6e61 6c29 3a20 5472 7565 206e  ptional): True n
+0000c960: 6f74 2074 6f20 7265 6164 2f72 6574 7572  ot to read/retur
+0000c970: 6e20 7468 6520 6765 6f6d 6174 7279 2e0a  n the geomatry..
+0000c980: 2020 2020 2020 2020 2020 2020 4465 6661              Defa
+0000c990: 756c 7473 2074 6f20 4661 6c73 652e 0a0a  ults to False...
+0000c9a0: 2020 2020 5265 7475 726e 733a 0a20 2020      Returns:.   
+0000c9b0: 2020 2020 2055 6e69 6f6e 5b70 642e 4461       Union[pd.Da
+0000c9c0: 7461 4672 616d 652c 2067 7064 2e47 656f  taFrame, gpd.Geo
+0000c9d0: 4461 7461 4672 616d 655d 3a20 5468 6520  DataFrame]: The 
+0000c9e0: 6461 7461 2072 6561 642e 0a20 2020 2022  data read..    "
+0000c9f0: 2222 0a20 2020 2077 6172 6e69 6e67 732e  "".    warnings.
+0000ca00: 7761 726e 280a 2020 2020 2020 2020 2772  warn(.        'r
+0000ca10: 6561 645f 6669 6c65 5f73 716c 2069 7320  ead_file_sql is 
+0000ca20: 6465 7072 6563 6174 6564 3a20 7573 6520  deprecated: use 
+0000ca30: 7265 6164 5f66 696c 6521 204d 696e 643a  read_file! Mind:
+0000ca40: 2073 716c 5f64 6961 6c65 6374 2069 7320   sql_dialect is 
+0000ca50: 6e6f 7420 2253 514c 4954 4522 2027 0a20  not "SQLITE" '. 
+0000ca60: 2020 2020 2020 2022 6279 2064 6566 6175         "by defau
+0000ca70: 6c74 2074 6865 7265 2122 2c0a 2020 2020  lt there!",.    
+0000ca80: 2020 2020 4675 7475 7265 5761 726e 696e      FutureWarnin
+0000ca90: 672c 0a20 2020 2020 2020 2073 7461 636b  g,.        stack
+0000caa0: 6c65 7665 6c3d 322c 0a20 2020 2029 0a0a  level=2,.    )..
+0000cab0: 2020 2020 2320 5275 6e0a 2020 2020 7265      # Run.    re
+0000cac0: 7475 726e 205f 7265 6164 5f66 696c 655f  turn _read_file_
+0000cad0: 6261 7365 280a 2020 2020 2020 2020 7061  base(.        pa
+0000cae0: 7468 2c0a 2020 2020 2020 2020 7371 6c5f  th,.        sql_
+0000caf0: 7374 6d74 3d73 716c 5f73 746d 742c 0a20  stmt=sql_stmt,. 
+0000cb00: 2020 2020 2020 2073 716c 5f64 6961 6c65         sql_diale
+0000cb10: 6374 3d73 716c 5f64 6961 6c65 6374 2c0a  ct=sql_dialect,.
+0000cb20: 2020 2020 2020 2020 6c61 7965 723d 6c61          layer=la
+0000cb30: 7965 722c 0a20 2020 2020 2020 2069 676e  yer,.        ign
+0000cb40: 6f72 655f 6765 6f6d 6574 7279 3d69 676e  ore_geometry=ign
+0000cb50: 6f72 655f 6765 6f6d 6574 7279 2c0a 2020  ore_geometry,.  
+0000cb60: 2020 290a 0a0a 6465 6620 746f 5f66 696c    )...def to_fil
+0000cb70: 6528 0a20 2020 2067 6466 3a20 556e 696f  e(.    gdf: Unio
+0000cb80: 6e5b 7064 2e44 6174 6146 7261 6d65 2c20  n[pd.DataFrame, 
+0000cb90: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
+0000cba0: 5d2c 0a20 2020 2070 6174 683a 2055 6e69  ],.    path: Uni
+0000cbb0: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
+0000cbc0: 4c69 6b65 5b41 6e79 5d22 5d2c 0a20 2020  Like[Any]"],.   
+0000cbd0: 206c 6179 6572 3a20 4f70 7469 6f6e 616c   layer: Optional
+0000cbe0: 5b73 7472 5d20 3d20 4e6f 6e65 2c0a 2020  [str] = None,.  
+0000cbf0: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
+0000cc00: 656f 6d65 7472 7974 7970 653a 2055 6e69  eometrytype: Uni
+0000cc10: 6f6e 5b47 656f 6d65 7472 7954 7970 652c  on[GeometryType,
+0000cc20: 2073 7472 2c20 4e6f 6e65 5d20 3d20 4e6f   str, None] = No
+0000cc30: 6e65 2c0a 2020 2020 666f 7263 655f 6d75  ne,.    force_mu
+0000cc40: 6c74 6974 7970 653a 2062 6f6f 6c20 3d20  ltitype: bool = 
+0000cc50: 4661 6c73 652c 0a20 2020 2061 7070 656e  False,.    appen
+0000cc60: 643a 2062 6f6f 6c20 3d20 4661 6c73 652c  d: bool = False,
+0000cc70: 0a20 2020 2061 7070 656e 645f 7469 6d65  .    append_time
+0000cc80: 6f75 745f 733a 2069 6e74 203d 2036 3030  out_s: int = 600
+0000cc90: 2c0a 2020 2020 696e 6465 783a 204f 7074  ,.    index: Opt
+0000cca0: 696f 6e61 6c5b 626f 6f6c 5d20 3d20 4e6f  ional[bool] = No
+0000ccb0: 6e65 2c0a 2020 2020 6372 6561 7465 5f73  ne,.    create_s
+0000ccc0: 7061 7469 616c 5f69 6e64 6578 3a20 4f70  patial_index: Op
+0000ccd0: 7469 6f6e 616c 5b62 6f6f 6c5d 203d 2054  tional[bool] = T
+0000cce0: 7275 652c 0a29 3a0a 2020 2020 2222 220a  rue,.):.    """.
+0000ccf0: 2020 2020 5772 6974 6573 2061 2070 616e      Writes a pan
+0000cd00: 6461 7320 6461 7461 6672 616d 6520 746f  das dataframe to
+0000cd10: 2066 696c 652e 0a0a 2020 2020 5468 6520   file...    The 
+0000cd20: 6669 6c65 666f 726d 6174 2069 7320 6465  fileformat is de
+0000cd30: 7465 6374 6564 2062 6173 6564 206f 6e20  tected based on 
+0000cd40: 7468 6520 6669 6c65 7061 7468 2065 7874  the filepath ext
+0000cd50: 656e 7369 6f6e 2e0a 0a20 2020 2054 6865  ension...    The
+0000cd60: 2075 6e64 6572 6c79 696e 6720 6c69 6272   underlying libr
+0000cd70: 6172 7920 7573 6564 2074 6f20 7772 6974  ary used to writ
+0000cd80: 6520 7468 6520 6669 6c65 2063 616e 2062  e the file can b
+0000cd90: 6520 6368 6f6f 7365 6e20 7573 696e 6720  e choosen using 
+0000cda0: 7468 650a 2020 2020 2247 464f 5f49 4f5f  the.    "GFO_IO_
+0000cdb0: 454e 4749 4e45 2220 656e 7669 726f 6e6d  ENGINE" environm
+0000cdc0: 656e 7420 7661 7269 6162 6c65 2e20 506f  ent variable. Po
+0000cdd0: 7373 6962 6c65 2076 616c 7565 7320 6172  ssible values ar
+0000cde0: 6520 2266 696f 6e61 2220 616e 6420 2270  e "fiona" and "p
+0000cdf0: 796f 6772 696f 222e 0a20 2020 2044 6566  yogrio"..    Def
+0000ce00: 6175 6c74 2065 6e67 696e 6520 6973 2022  ault engine is "
+0000ce10: 7079 6f67 7269 6f22 2e0a 0a20 2020 2041  pyogrio"...    A
+0000ce20: 7267 733a 0a20 2020 2020 2020 2067 6466  rgs:.        gdf
+0000ce30: 2028 6770 642e 4765 6f44 6174 6146 7261   (gpd.GeoDataFra
+0000ce40: 6d65 293a 2054 6865 2047 656f 4461 7461  me): The GeoData
+0000ce50: 4672 616d 6520 746f 2065 7870 6f72 7420  Frame to export 
+0000ce60: 746f 2066 696c 652e 0a20 2020 2020 2020  to file..       
+0000ce70: 2070 6174 6820 2855 6e69 6f6e 5b73 7472   path (Union[str
+0000ce80: 2c29 3a20 5468 6520 6669 6c65 2070 6174  ,): The file pat
+0000ce90: 6820 746f 2077 7269 7465 2074 6f2e 0a20  h to write to.. 
+0000cea0: 2020 2020 2020 206c 6179 6572 2028 7374         layer (st
+0000ceb0: 722c 206f 7074 696f 6e61 6c29 3a20 5468  r, optional): Th
+0000cec0: 6520 6c61 7965 7220 746f 2072 6561 642e  e layer to read.
+0000ced0: 2049 6620 6e6f 206c 6179 6572 2069 7320   If no layer is 
+0000cee0: 7370 6563 6966 6965 642c 0a20 2020 2020  specified,.     
+0000cef0: 2020 2020 2020 2072 6561 6473 2074 6865         reads the
+0000cf00: 206f 6e6c 7920 6c61 7965 7220 696e 2074   only layer in t
+0000cf10: 6865 2066 696c 6520 6f72 2074 6872 6f77  he file or throw
+0000cf20: 7320 616e 2045 7863 6570 7469 6f6e 2e0a  s an Exception..
+0000cf30: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
+0000cf40: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000cf50: 6520 2855 6e69 6f6e 5b47 656f 6d65 7472  e (Union[Geometr
+0000cf60: 7954 7970 652c 2073 7472 5d2c 206f 7074  yType, str], opt
+0000cf70: 696f 6e61 6c29 3a20 4765 6f6d 6574 7279  ional): Geometry
+0000cf80: 2074 7970 650a 2020 2020 2020 2020 2020   type.          
+0000cf90: 2020 746f 2028 7472 7920 746f 2920 666f    to (try to) fo
+0000cfa0: 7263 6520 7468 6520 6f75 7470 7574 2074  rce the output t
+0000cfb0: 6f2e 2044 6566 6175 6c74 7320 746f 204e  o. Defaults to N
+0000cfc0: 6f6e 652e 0a20 2020 2020 2020 2020 2020  one..           
+0000cfd0: 204d 6172 6b3a 2063 6f6d 7061 7265 6420   Mark: compared 
+0000cfe0: 746f 206f 7468 6572 2066 756e 6374 696f  to other functio
+0000cff0: 6e73 2069 6e20 6766 6f20 7769 7468 2074  ns in gfo with t
+0000d000: 6869 7320 7061 7261 6d65 7465 722c 2074  his parameter, t
+0000d010: 6865 2062 6568 6176 696f 7572 0a20 2020  he behaviour.   
+0000d020: 2020 2020 2020 2020 2068 6572 6520 6973           here is
+0000d030: 206c 696d 6974 6564 2074 6f20 7468 6520   limited to the 
+0000d040: 666f 6c6c 6f77 696e 673a 0a20 2020 2020  following:.     
+0000d050: 2020 2020 2020 2020 2020 202d 2066 6f72             - for
+0000d060: 2065 6d70 7479 2069 6e70 7574 2067 6466   empty input gdf
+0000d070: 2773 2c20 6120 7374 616e 6461 7264 2067  's, a standard g
+0000d080: 656f 6d65 7472 7920 7479 7065 2028 6567  eometry type (eg
+0000d090: 2e20 506f 6c79 676f 6e2c 2e2e 2e29 2063  . Polygon,...) c
+0000d0a0: 616e 0a20 2020 2020 2020 2020 2020 2020  an.             
+0000d0b0: 2020 2020 2062 6520 7573 6564 2074 6f20       be used to 
+0000d0c0: 666f 7263 6520 7468 6520 6765 6f6d 6574  force the geomet
+0000d0d0: 7279 2063 6f6c 756d 6e20 746f 2062 6520  ry column to be 
+0000d0e0: 6f66 2074 6861 7420 7479 7065 2e0a 2020  of that type..  
+0000d0f0: 2020 2020 2020 2020 2020 2020 2020 2d20                - 
+0000d100: 6966 2066 6f72 6365 5f6f 7574 7075 745f  if force_output_
+0000d110: 6765 6f6d 6574 7279 7479 7065 2069 7320  geometrytype is 
+0000d120: 6120 4d55 4c54 4920 7479 7065 2c20 7061  a MULTI type, pa
+0000d130: 7261 6d65 7465 720a 2020 2020 2020 2020  rameter.        
+0000d140: 2020 2020 2020 2020 2020 666f 7263 655f            force_
+0000d150: 6d75 6c74 6974 7970 6520 6265 636f 6d65  multitype become
+0000d160: 7320 5472 7565 2e0a 2020 2020 2020 2020  s True..        
+0000d170: 666f 7263 655f 6d75 6c74 6974 7970 6520  force_multitype 
+0000d180: 2862 6f6f 6c2c 206f 7074 696f 6e61 6c29  (bool, optional)
+0000d190: 3a20 666f 7263 6520 7468 6520 6765 6f6d  : force the geom
+0000d1a0: 6574 7279 2074 7970 6520 746f 2061 206d  etry type to a m
+0000d1b0: 756c 7469 7479 7065 0a20 2020 2020 2020  ultitype.       
+0000d1c0: 2020 2020 2066 6f72 2066 696c 6520 7479       for file ty
+0000d1d0: 7065 7320 7468 6174 2072 6571 7569 7265  pes that require
+0000d1e0: 206f 6e65 2067 656f 6d65 7472 7974 7970   one geometrytyp
+0000d1f0: 6520 7065 7220 6c61 7965 722e 0a20 2020  e per layer..   
+0000d200: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
+0000d210: 7320 746f 2046 616c 7365 2e0a 2020 2020  s to False..    
+0000d220: 2020 2020 6170 7065 6e64 2028 626f 6f6c      append (bool
+0000d230: 2c20 6f70 7469 6f6e 616c 293a 2054 7275  , optional): Tru
+0000d240: 6520 746f 2061 7070 656e 6420 746f 2074  e to append to t
+0000d250: 6865 2066 696c 652f 6c61 7965 7220 6966  he file/layer if
+0000d260: 2069 7420 6578 6973 7473 2061 6c72 6561   it exists alrea
+0000d270: 6479 2e0a 2020 2020 2020 2020 2020 2020  dy..            
+0000d280: 4966 2069 7420 646f 6573 6e27 7420 6578  If it doesn't ex
+0000d290: 6973 7420 7965 742c 2069 7420 6973 2063  ist yet, it is c
+0000d2a0: 7265 6174 6564 2e20 4465 6661 756c 7473  reated. Defaults
+0000d2b0: 2074 6f20 4661 6c73 652e 0a20 2020 2020   to False..     
+0000d2c0: 2020 2061 7070 656e 645f 7469 6d65 6f75     append_timeou
+0000d2d0: 745f 7320 2869 6e74 2c20 6f70 7469 6f6e  t_s (int, option
+0000d2e0: 616c 293a 2054 6865 206d 6178 696d 756d  al): The maximum
+0000d2f0: 2074 696d 656f 7574 2074 6f20 7761 6974   timeout to wait
+0000d300: 2077 6865 6e20 7468 650a 2020 2020 2020   when the.      
+0000d310: 2020 2020 2020 6f75 7470 7574 2066 696c        output fil
+0000d320: 6520 6973 2061 6c72 6561 6479 2062 6569  e is already bei
+0000d330: 6e67 2077 7269 7474 656e 2074 6f20 6279  ng written to by
+0000d340: 2061 6e6f 7468 6572 2070 726f 6365 7373   another process
+0000d350: 2e0a 2020 2020 2020 2020 2020 2020 4465  ..            De
+0000d360: 6661 756c 7473 2074 6f20 3630 302e 0a20  faults to 600.. 
+0000d370: 2020 2020 2020 2069 6e64 6578 2028 626f         index (bo
+0000d380: 6f6c 2c20 6f70 7469 6f6e 616c 293a 2049  ol, optional): I
+0000d390: 6620 5472 7565 2c20 7772 6974 6520 696e  f True, write in
+0000d3a0: 6465 7820 696e 746f 206f 6e65 206f 7220  dex into one or 
+0000d3b0: 6d6f 7265 2063 6f6c 756d 6e73 2028 666f  more columns (fo
+0000d3c0: 720a 2020 2020 2020 2020 2020 2020 4d75  r.            Mu
+0000d3d0: 6c74 6949 6e64 6578 292e 204e 6f6e 6520  ltiIndex). None 
+0000d3e0: 7772 6974 6573 2074 6865 2069 6e64 6578  writes the index
+0000d3f0: 2069 6e74 6f20 6f6e 6520 6f72 206d 6f72   into one or mor
+0000d400: 6520 636f 6c75 6d6e 7320 6f6e 6c79 2069  e columns only i
+0000d410: 6620 7468 650a 2020 2020 2020 2020 2020  f the.          
+0000d420: 2020 696e 6465 7820 6973 206e 616d 6564    index is named
+0000d430: 2c20 6973 2061 204d 756c 7469 496e 6465  , is a MultiInde
+0000d440: 782c 206f 7220 6861 7320 6120 6e6f 6e2d  x, or has a non-
+0000d450: 696e 7465 6765 7220 6461 7461 2074 7970  integer data typ
+0000d460: 652e 0a20 2020 2020 2020 2020 2020 2049  e..            I
+0000d470: 6620 4661 6c73 652c 206e 6f20 696e 6465  f False, no inde
+0000d480: 7820 6973 2077 7269 7474 656e 2e20 4465  x is written. De
+0000d490: 6661 756c 7473 2074 6f20 4e6f 6e65 2e0a  faults to None..
+0000d4a0: 2020 2020 2020 2020 6372 6561 7465 5f73          create_s
+0000d4b0: 7061 7469 616c 5f69 6e64 6578 2028 626f  patial_index (bo
+0000d4c0: 6f6c 2c20 6f70 7469 6f6e 616c 293a 2054  ol, optional): T
+0000d4d0: 7275 6520 746f 2066 6f72 6365 2063 7265  rue to force cre
+0000d4e0: 6174 696f 6e20 6f66 2073 7061 7469 616c  ation of spatial
+0000d4f0: 2069 6e64 6578 2c0a 2020 2020 2020 2020   index,.        
+0000d500: 2020 2020 4661 6c73 6520 746f 2061 766f      False to avo
+0000d510: 6964 2063 7265 6174 696f 6e2e 204e 6f6e  id creation. Non
+0000d520: 6520 6c65 6164 7320 746f 2074 6865 2064  e leads to the d
+0000d530: 6566 6175 6c74 2062 6568 6176 696f 7572  efault behaviour
+0000d540: 206f 6620 6764 616c 2e0a 2020 2020 2020   of gdal..      
+0000d550: 2020 2020 2020 4465 6661 756c 7473 2074        Defaults t
+0000d560: 6f20 5472 7565 2e0a 0a20 2020 2052 6169  o True...    Rai
+0000d570: 7365 733a 0a20 2020 2020 2020 2056 616c  ses:.        Val
+0000d580: 7565 4572 726f 723a 2061 6e20 696e 7661  ueError: an inva
+0000d590: 6c69 6420 7061 7261 6d65 7465 7220 7661  lid parameter va
+0000d5a0: 6c75 6520 7761 7320 7061 7373 6564 2e0a  lue was passed..
+0000d5b0: 2020 2020 2020 2020 5275 6e74 696d 6545          RuntimeE
+0000d5c0: 7272 6f72 3a20 7469 6d65 6f75 7420 7761  rror: timeout wa
+0000d5d0: 7320 7265 6163 6865 6420 7768 696c 6520  s reached while 
+0000d5e0: 7472 7969 6e67 2074 6f20 6170 7065 6e64  trying to append
+0000d5f0: 2064 6174 6120 746f 2070 6174 682e 0a20   data to path.. 
+0000d600: 2020 2022 2222 0a20 2020 2023 2043 6865     """.    # Che
+0000d610: 636b 2069 6e70 7574 2070 6172 616d 6574  ck input paramet
+0000d620: 6572 730a 2020 2020 2320 2d2d 2d2d 2d2d  ers.    # ------
+0000d630: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000d640: 0a20 2020 2070 6174 6820 3d20 5061 7468  .    path = Path
+0000d650: 2870 6174 6829 0a0a 2020 2020 2320 4966  (path)..    # If
+0000d660: 206e 6f20 6c61 7965 7220 6e61 6d65 2073   no layer name s
+0000d670: 7065 6369 6669 6564 2c20 6465 7465 726d  pecified, determ
+0000d680: 696e 6520 6f6e 650a 2020 2020 6966 206c  ine one.    if l
+0000d690: 6179 6572 2069 7320 4e6f 6e65 3a0a 2020  ayer is None:.  
+0000d6a0: 2020 2020 2020 6966 2061 7070 656e 6420        if append 
+0000d6b0: 616e 6420 7061 7468 2e65 7869 7374 7328  and path.exists(
+0000d6c0: 293a 0a20 2020 2020 2020 2020 2020 206c  ):.            l
+0000d6d0: 6179 6572 203d 2067 6574 5f6f 6e6c 795f  ayer = get_only_
+0000d6e0: 6c61 7965 7228 7061 7468 290a 2020 2020  layer(path).    
+0000d6f0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000d700: 2020 2020 2020 6c61 7965 7220 3d20 5061        layer = Pa
+0000d710: 7468 2870 6174 6829 2e73 7465 6d0a 0a20  th(path).stem.. 
+0000d720: 2020 2023 2049 6620 666f 7263 655f 6f75     # If force_ou
+0000d730: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000d740: 6520 6973 2061 2073 7472 696e 672c 2063  e is a string, c
+0000d750: 6865 636b 2069 6620 6974 2069 7320 6120  heck if it is a 
+0000d760: 2273 7461 6e64 6172 6422 2067 656f 6d65  "standard" geome
+0000d770: 7472 790a 2020 2020 2320 7479 7065 2c20  try.    # type, 
+0000d780: 6173 2047 4441 4c20 616c 736f 2073 7570  as GDAL also sup
+0000d790: 706f 7274 7320 7370 6563 6961 6c20 6765  ports special ge
+0000d7a0: 6f6d 6574 7279 2074 7970 6573 206c 696b  ometry types lik
+0000d7b0: 6520 2250 524f 4d4f 5445 5f54 4f5f 4d55  e "PROMOTE_TO_MU
+0000d7c0: 4c54 4922 0a20 2020 2069 6620 6973 696e  LTI".    if isin
+0000d7d0: 7374 616e 6365 2866 6f72 6365 5f6f 7574  stance(force_out
+0000d7e0: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
+0000d7f0: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
+0000d800: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
+0000d810: 6d65 7472 7974 7970 6520 3d20 666f 7263  metrytype = forc
+0000d820: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+0000d830: 7974 7970 652e 7570 7065 7228 290a 2020  ytype.upper().  
+0000d840: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+0000d850: 2020 2020 2020 2023 2056 6572 6966 7920         # Verify 
+0000d860: 6966 2069 7420 6973 2061 2022 7374 616e  if it is a "stan
+0000d870: 6461 7264 2220 6765 6f6d 6574 7279 2074  dard" geometry t
+0000d880: 7970 652c 2061 7320 4744 414c 2061 6c73  ype, as GDAL als
+0000d890: 6f20 7375 7070 6f72 7473 0a20 2020 2020  o supports.     
+0000d8a0: 2020 2020 2020 2023 2073 7065 6369 616c         # special
+0000d8b0: 2067 656f 6d65 7472 7920 7479 7065 7320   geometry types 
+0000d8c0: 6c69 6b65 2022 5052 4f4d 4f54 455f 544f  like "PROMOTE_TO
+0000d8d0: 5f4d 554c 5449 220a 2020 2020 2020 2020  _MULTI".        
+0000d8e0: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
+0000d8f0: 5f67 656f 6d65 7472 7974 7970 6520 3d20  _geometrytype = 
+0000d900: 4765 6f6d 6574 7279 5479 7065 5b66 6f72  GeometryType[for
+0000d910: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
+0000d920: 7279 7479 7065 5d0a 2020 2020 2020 2020  rytype].        
+0000d930: 6578 6365 7074 2045 7863 6570 7469 6f6e  except Exception
+0000d940: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+0000d950: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
+0000d960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d970: 6622 556e 7375 7070 6f72 7465 6420 666f  f"Unsupported fo
+0000d980: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
+0000d990: 7472 7974 7970 653a 207b 666f 7263 655f  trytype: {force_
+0000d9a0: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
+0000d9b0: 7970 657d 220a 2020 2020 2020 2020 2020  ype}".          
+0000d9c0: 2020 290a 2020 2020 6966 2066 6f72 6365    ).    if force
+0000d9d0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
+0000d9e0: 7479 7065 2069 7320 6e6f 7420 4e6f 6e65  type is not None
+0000d9f0: 2061 6e64 2066 6f72 6365 5f6f 7574 7075   and force_outpu
+0000da00: 745f 6765 6f6d 6574 7279 7479 7065 2e69  t_geometrytype.i
+0000da10: 735f 6d75 6c74 6974 7970 653a 0a20 2020  s_multitype:.   
+0000da20: 2020 2020 2066 6f72 6365 5f6d 756c 7469       force_multi
+0000da30: 7479 7065 203d 2054 7275 650a 0a20 2020  type = True..   
+0000da40: 2023 2049 6620 7468 6572 6520 6973 206e   # If there is n
+0000da50: 6f20 6765 6f6d 6574 7279 2063 6f6c 756d  o geometry colum
+0000da60: 6e20 696e 2074 6865 2069 6e70 7574 2c20  n in the input, 
+0000da70: 616c 7761 7973 2075 7365 2066 696f 6e61  always use fiona
+0000da80: 2c20 6173 2070 796f 6772 696f 2064 6f65  , as pyogrio doe
+0000da90: 736e 2774 0a20 2020 2023 2073 7570 706f  sn't.    # suppo
+0000daa0: 7274 2074 6861 7420 7965 7420 6174 2074  rt that yet at t
+0000dab0: 696d 6520 6f66 2077 7269 7469 6e67 2e0a  ime of writing..
+0000dac0: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+0000dad0: 6528 6764 662c 2067 7064 2e47 656f 4461  e(gdf, gpd.GeoDa
+0000dae0: 7461 4672 616d 6529 2069 7320 4661 6c73  taFrame) is Fals
+0000daf0: 6520 6f72 2028 0a20 2020 2020 2020 2069  e or (.        i
+0000db00: 7369 6e73 7461 6e63 6528 6764 662c 2067  sinstance(gdf, g
+0000db10: 7064 2e47 656f 4461 7461 4672 616d 6529  pd.GeoDataFrame)
+0000db20: 2061 6e64 2022 6765 6f6d 6574 7279 2220   and "geometry" 
+0000db30: 6e6f 7420 696e 2067 6466 2e63 6f6c 756d  not in gdf.colum
+0000db40: 6e73 0a20 2020 2029 3a0a 2020 2020 2020  ns.    ):.      
+0000db50: 2020 656e 6769 6e65 203d 2022 6669 6f6e    engine = "fion
+0000db60: 6122 0a20 2020 2020 2020 2063 7265 6174  a".        creat
+0000db70: 655f 7370 6174 6961 6c5f 696e 6465 7820  e_spatial_index 
+0000db80: 3d20 4661 6c73 650a 2020 2020 656c 7365  = False.    else
+0000db90: 3a0a 2020 2020 2020 2020 656e 6769 6e65  :.        engine
+0000dba0: 203d 205f 6765 745f 656e 6769 6e65 2829   = _get_engine()
+0000dbb0: 0a0a 2020 2020 2320 4e6f 7720 7772 6974  ..    # Now writ
+0000dbc0: 6520 7769 7468 2074 6865 2063 6f72 7265  e with the corre
+0000dbd0: 6374 2065 6e67 696e 650a 2020 2020 6966  ct engine.    if
+0000dbe0: 2065 6e67 696e 6520 3d3d 2022 7079 6f67   engine == "pyog
+0000dbf0: 7269 6f22 3a0a 2020 2020 2020 2020 6173  rio":.        as
+0000dc00: 7365 7274 2069 7369 6e73 7461 6e63 6528  sert isinstance(
+0000dc10: 6764 662c 2067 7064 2e47 656f 4461 7461  gdf, gpd.GeoData
+0000dc20: 4672 616d 6529 0a20 2020 2020 2020 2072  Frame).        r
+0000dc30: 6574 7572 6e20 5f74 6f5f 6669 6c65 5f70  eturn _to_file_p
+0000dc40: 796f 6772 696f 280a 2020 2020 2020 2020  yogrio(.        
+0000dc50: 2020 2020 6764 663d 6764 662c 0a20 2020      gdf=gdf,.   
+0000dc60: 2020 2020 2020 2020 2070 6174 683d 7061           path=pa
+0000dc70: 7468 2c0a 2020 2020 2020 2020 2020 2020  th,.            
+0000dc80: 6c61 7965 723d 6c61 7965 722c 0a20 2020  layer=layer,.   
+0000dc90: 2020 2020 2020 2020 2066 6f72 6365 5f6f           force_o
+0000dca0: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
+0000dcb0: 7065 3d66 6f72 6365 5f6f 7574 7075 745f  pe=force_output_
+0000dcc0: 6765 6f6d 6574 7279 7479 7065 2c0a 2020  geometrytype,.  
+0000dcd0: 2020 2020 2020 2020 2020 666f 7263 655f            force_
+0000dce0: 6d75 6c74 6974 7970 653d 666f 7263 655f  multitype=force_
+0000dcf0: 6d75 6c74 6974 7970 652c 0a20 2020 2020  multitype,.     
+0000dd00: 2020 2020 2020 2061 7070 656e 643d 6170         append=ap
+0000dd10: 7065 6e64 2c0a 2020 2020 2020 2020 2020  pend,.          
+0000dd20: 2020 6170 7065 6e64 5f74 696d 656f 7574    append_timeout
+0000dd30: 5f73 3d61 7070 656e 645f 7469 6d65 6f75  _s=append_timeou
+0000dd40: 745f 732c 0a20 2020 2020 2020 2020 2020  t_s,.           
+0000dd50: 2069 6e64 6578 3d69 6e64 6578 2c0a 2020   index=index,.  
+0000dd60: 2020 2020 2020 2020 2020 6372 6561 7465            create
+0000dd70: 5f73 7061 7469 616c 5f69 6e64 6578 3d63  _spatial_index=c
+0000dd80: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
+0000dd90: 6465 782c 0a20 2020 2020 2020 2029 0a20  dex,.        ). 
+0000dda0: 2020 2065 6c69 6620 656e 6769 6e65 203d     elif engine =
+0000ddb0: 3d20 2266 696f 6e61 223a 0a20 2020 2020  = "fiona":.     
+0000ddc0: 2020 2072 6574 7572 6e20 5f74 6f5f 6669     return _to_fi
+0000ddd0: 6c65 5f66 696f 6e61 280a 2020 2020 2020  le_fiona(.      
+0000dde0: 2020 2020 2020 6764 663d 6764 662c 0a20        gdf=gdf,. 
+0000ddf0: 2020 2020 2020 2020 2020 2070 6174 683d             path=
+0000de00: 7061 7468 2c0a 2020 2020 2020 2020 2020  path,.          
+0000de10: 2020 6c61 7965 723d 6c61 7965 722c 0a20    layer=layer,. 
+0000de20: 2020 2020 2020 2020 2020 2066 6f72 6365             force
+0000de30: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
+0000de40: 7479 7065 3d66 6f72 6365 5f6f 7574 7075  type=force_outpu
+0000de50: 745f 6765 6f6d 6574 7279 7479 7065 2c0a  t_geometrytype,.
+0000de60: 2020 2020 2020 2020 2020 2020 666f 7263              forc
+0000de70: 655f 6d75 6c74 6974 7970 653d 666f 7263  e_multitype=forc
+0000de80: 655f 6d75 6c74 6974 7970 652c 0a20 2020  e_multitype,.   
+0000de90: 2020 2020 2020 2020 2061 7070 656e 643d           append=
+0000dea0: 6170 7065 6e64 2c0a 2020 2020 2020 2020  append,.        
+0000deb0: 2020 2020 6170 7065 6e64 5f74 696d 656f      append_timeo
+0000dec0: 7574 5f73 3d61 7070 656e 645f 7469 6d65  ut_s=append_time
+0000ded0: 6f75 745f 732c 0a20 2020 2020 2020 2020  out_s,.         
+0000dee0: 2020 2069 6e64 6578 3d69 6e64 6578 2c0a     index=index,.
+0000def0: 2020 2020 2020 2020 2020 2020 6372 6561              crea
+0000df00: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
+0000df10: 3d63 7265 6174 655f 7370 6174 6961 6c5f  =create_spatial_
+0000df20: 696e 6465 782c 0a20 2020 2020 2020 2029  index,.        )
+0000df30: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+0000df40: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+0000df50: 726f 7228 6622 556e 7375 7070 6f72 7465  ror(f"Unsupporte
+0000df60: 6420 656e 6769 6e65 3a20 7b65 6e67 696e  d engine: {engin
+0000df70: 657d 2229 0a0a 0a64 6566 205f 6765 745f  e}")...def _get_
+0000df80: 656e 6769 6e65 2829 3a0a 2020 2020 7265  engine():.    re
+0000df90: 7475 726e 206f 732e 656e 7669 726f 6e2e  turn os.environ.
+0000dfa0: 6765 7428 2247 464f 5f49 4f5f 454e 4749  get("GFO_IO_ENGI
+0000dfb0: 4e45 222c 2022 7079 6f67 7269 6f22 290a  NE", "pyogrio").
+0000dfc0: 0a0a 6465 6620 5f74 6f5f 6669 6c65 5f66  ..def _to_file_f
+0000dfd0: 696f 6e61 280a 2020 2020 6764 663a 2055  iona(.    gdf: U
+0000dfe0: 6e69 6f6e 5b70 642e 4461 7461 4672 616d  nion[pd.DataFram
+0000dff0: 652c 2067 7064 2e47 656f 4461 7461 4672  e, gpd.GeoDataFr
+0000e000: 616d 655d 2c0a 2020 2020 7061 7468 3a20  ame],.    path: 
+0000e010: 5061 7468 2c0a 2020 2020 6c61 7965 723a  Path,.    layer:
+0000e020: 2073 7472 2c0a 2020 2020 666f 7263 655f   str,.    force_
+0000e030: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
+0000e040: 7970 653a 2055 6e69 6f6e 5b47 656f 6d65  ype: Union[Geome
+0000e050: 7472 7954 7970 652c 2073 7472 2c20 4e6f  tryType, str, No
+0000e060: 6e65 5d20 3d20 4e6f 6e65 2c0a 2020 2020  ne] = None,.    
+0000e070: 666f 7263 655f 6d75 6c74 6974 7970 653a  force_multitype:
+0000e080: 2062 6f6f 6c20 3d20 4661 6c73 652c 0a20   bool = False,. 
+0000e090: 2020 2061 7070 656e 643a 2062 6f6f 6c20     append: bool 
+0000e0a0: 3d20 4661 6c73 652c 0a20 2020 2061 7070  = False,.    app
+0000e0b0: 656e 645f 7469 6d65 6f75 745f 733a 2069  end_timeout_s: i
+0000e0c0: 6e74 203d 2036 3030 2c0a 2020 2020 696e  nt = 600,.    in
+0000e0d0: 6465 783a 204f 7074 696f 6e61 6c5b 626f  dex: Optional[bo
+0000e0e0: 6f6c 5d20 3d20 4e6f 6e65 2c0a 2020 2020  ol] = None,.    
+0000e0f0: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
+0000e100: 6e64 6578 3a20 4f70 7469 6f6e 616c 5b62  ndex: Optional[b
+0000e110: 6f6f 6c5d 203d 2054 7275 652c 0a29 3a0a  ool] = True,.):.
+0000e120: 2020 2020 2222 220a 2020 2020 5772 6974      """.    Writ
+0000e130: 6573 2061 2070 616e 6461 7320 6461 7461  es a pandas data
+0000e140: 6672 616d 6520 746f 2066 696c 6520 7573  frame to file us
+0000e150: 696e 6720 6669 6f6e 612e 0a20 2020 2022  ing fiona..    "
+0000e160: 2222 0a20 2020 2023 2053 6861 7065 6669  "".    # Shapefi
+0000e170: 6c65 2064 6f65 736e 2774 2073 7570 706f  le doesn't suppo
+0000e180: 7274 2064 6174 6574 696d 6520 636f 6c75  rt datetime colu
+0000e190: 6d6e 732c 2073 6f20 6669 7273 7420 6361  mns, so first ca
+0000e1a0: 7374 2074 6865 6d20 746f 2073 7472 696e  st them to strin
+0000e1b0: 670a 2020 2020 6966 2070 6174 682e 7375  g.    if path.su
+0000e1c0: 6666 6978 2e6c 6f77 6572 2829 2069 6e20  ffix.lower() in 
+0000e1d0: 5b22 2e73 6870 222c 2022 2e64 6266 225d  [".shp", ".dbf"]
+0000e1e0: 3a0a 2020 2020 2020 2020 6764 6620 3d20  :.        gdf = 
+0000e1f0: 6764 662e 636f 7079 2829 0a20 2020 2020  gdf.copy().     
+0000e200: 2020 2023 2043 6f6c 756d 6e73 2074 6861     # Columns tha
+0000e210: 7420 6861 7665 2061 2070 726f 7065 7220  t have a proper 
+0000e220: 6461 7465 7469 6d65 3634 2074 7970 650a  datetime64 type.
+0000e230: 2020 2020 2020 2020 666f 7220 636f 6c75          for colu
+0000e240: 6d6e 2069 6e20 6764 662e 7365 6c65 6374  mn in gdf.select
+0000e250: 5f64 7479 7065 7328 696e 636c 7564 653d  _dtypes(include=
+0000e260: 5b22 6461 7465 7469 6d65 3634 225d 293a  ["datetime64"]):
+0000e270: 0a20 2020 2020 2020 2020 2020 2067 6466  .            gdf
+0000e280: 5b63 6f6c 756d 6e5d 203d 2067 6466 5b63  [column] = gdf[c
+0000e290: 6f6c 756d 6e5d 2e61 7374 7970 6528 7374  olumn].astype(st
+0000e2a0: 7229 0a0a 2020 2020 2020 2020 2320 436f  r)..        # Co
+0000e2b0: 6c75 6d6e 7320 7468 6174 2061 7265 206f  lumns that are o
+0000e2c0: 6620 6f62 6a65 6374 2074 7970 652c 2062  f object type, b
+0000e2d0: 7574 2063 6f6e 7461 696e 2064 6174 6574  ut contain datet
+0000e2e0: 696d 652e 6461 7465 206f 7220 6461 7465  ime.date or date
+0000e2f0: 7469 6d65 2e64 6174 650a 2020 2020 2020  time.date.      
+0000e300: 2020 2320 7479 7065 2064 6174 6120 696e    # type data in
+0000e310: 7374 6561 6420 6f66 2073 7472 696e 6773  stead of strings
+0000e320: 2e0a 2020 2020 2020 2020 6966 206c 656e  ..        if len
+0000e330: 2867 6466 2920 3e20 303a 0a20 2020 2020  (gdf) > 0:.     
+0000e340: 2020 2020 2020 2066 6f72 2063 6f6c 756d         for colum
+0000e350: 6e20 696e 2067 6466 2e73 656c 6563 745f  n in gdf.select_
+0000e360: 6474 7970 6573 2869 6e63 6c75 6465 3d5b  dtypes(include=[
+0000e370: 226f 626a 6563 7422 5d29 3a0a 2020 2020  "object"]):.    
+0000e380: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+0000e390: 7369 6e73 7461 6e63 6528 6764 665b 636f  sinstance(gdf[co
+0000e3a0: 6c75 6d6e 5d5b 305d 2c20 2864 6174 6574  lumn][0], (datet
+0000e3b0: 696d 652e 6461 7465 2c20 6461 7465 7469  ime.date, dateti
+0000e3c0: 6d65 2e64 6174 6574 696d 6529 293a 0a20  me.datetime)):. 
+0000e3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e3e0: 2020 2067 6466 5b63 6f6c 756d 6e5d 203d     gdf[column] =
+0000e3f0: 2067 6466 5b63 6f6c 756d 6e5d 2e61 7374   gdf[column].ast
+0000e400: 7970 6528 7374 7229 0a0a 2020 2020 2320  ype(str)..    # 
+0000e410: 4861 6e64 6c65 2073 6f6d 6520 7370 6563  Handle some spec
+0000e420: 6966 6963 2063 6173 6573 2077 6865 7265  ific cases where
+0000e430: 2074 6865 2066 696c 6520 7363 6865 6d61   the file schema
+0000e440: 206e 6565 6473 2074 6f20 6265 206d 616e   needs to be man
+0000e450: 6970 756c 6174 6564 2e0a 2020 2020 7363  ipulated..    sc
+0000e460: 6865 6d61 203d 204e 6f6e 650a 2020 2020  hema = None.    
+0000e470: 6966 2069 7369 6e73 7461 6e63 6528 6764  if isinstance(gd
+0000e480: 662c 2067 7064 2e47 656f 4461 7461 4672  f, gpd.GeoDataFr
+0000e490: 616d 6529 2069 7320 4661 6c73 6520 6f72  ame) is False or
+0000e4a0: 2028 0a20 2020 2020 2020 2069 7369 6e73   (.        isins
+0000e4b0: 7461 6e63 6528 6764 662c 2067 7064 2e47  tance(gdf, gpd.G
+0000e4c0: 656f 4461 7461 4672 616d 6529 2061 6e64  eoDataFrame) and
+0000e4d0: 2022 6765 6f6d 6574 7279 2220 6e6f 7420   "geometry" not 
+0000e4e0: 696e 2067 6466 2e63 6f6c 756d 6e73 0a20  in gdf.columns. 
+0000e4f0: 2020 2029 3a0a 2020 2020 2020 2020 2320     ):.        # 
+0000e500: 4e6f 2067 656f 6d65 7472 792c 2073 6f20  No geometry, so 
+0000e510: 7072 6570 6172 6520 746f 2062 6520 7772  prepare to be wr
+0000e520: 6974 7465 6e20 6173 2061 7474 7269 6275  itten as attribu
+0000e530: 7465 2074 6162 6c65 3a20 6164 6420 6765  te table: add ge
+0000e540: 6f6d 6574 7279 2063 6f6c 756d 6e0a 2020  ometry column.  
+0000e550: 2020 2020 2020 2320 7769 7468 204e 6f6e        # with Non
+0000e560: 6520 6765 6f6d 6574 7279 2074 7970 6520  e geometry type 
+0000e570: 696e 2073 6368 656d 610a 2020 2020 2020  in schema.      
+0000e580: 2020 2320 5769 7468 206f 6c64 6572 2076    # With older v
+0000e590: 6572 7369 6f6e 7320 6f66 2070 616e 6461  ersions of panda
+0000e5a0: 7320 616e 642f 6f72 2067 656f 7061 6e64  s and/or geopand
+0000e5b0: 6173 2c20 7769 7468 6f75 7420 7468 6520  as, without the 
+0000e5c0: 636f 7079 2074 6865 2061 6374 7561 6c0a  copy the actual.
+0000e5d0: 2020 2020 2020 2020 2320 6764 6620 6973          # gdf is
+0000e5e0: 2063 6861 6e67 6564 2061 6e64 2072 6574   changed and ret
+0000e5f0: 7572 6e65 6420 7768 6963 6820 6973 6e27  urned which isn'
+0000e600: 7420 4f4b 2e0a 2020 2020 2020 2020 2320  t OK..        # 
+0000e610: 5468 6973 2063 6175 7365 6420 7465 7374  This caused test
+0000e620: 5f74 6f5f 6669 6c65 2077 6974 6820 2e63  _to_file with .c
+0000e630: 7376 2074 6f20 6661 696c 2066 6f72 2074  sv to fail for t
+0000e640: 6865 2022 6d69 6e69 6d61 6c22 2043 4920  he "minimal" CI 
+0000e650: 656e 762e 0a20 2020 2020 2020 2067 6466  env..        gdf
+0000e660: 203d 2067 7064 2e47 656f 4461 7461 4672   = gpd.GeoDataFr
+0000e670: 616d 6528 6764 662e 636f 7079 2829 2c20  ame(gdf.copy(), 
+0000e680: 6765 6f6d 6574 7279 3d5b 4e6f 6e65 2066  geometry=[None f
+0000e690: 6f72 2069 2069 6e20 6764 662e 696e 6465  or i in gdf.inde
+0000e6a0: 785d 290a 0a20 2020 2020 2020 2073 6368  x])..        sch
+0000e6b0: 656d 6120 3d20 6770 645f 696f 5f66 696c  ema = gpd_io_fil
+0000e6c0: 652e 696e 6665 725f 7363 6865 6d61 2867  e.infer_schema(g
+0000e6d0: 6466 290a 2020 2020 2020 2020 7363 6865  df).        sche
+0000e6e0: 6d61 5b22 6765 6f6d 6574 7279 225d 203d  ma["geometry"] =
+0000e6f0: 2022 4e6f 6e65 220a 2020 2020 656c 6966   "None".    elif
+0000e700: 2028 0a20 2020 2020 2020 206c 656e 2867   (.        len(g
+0000e710: 6466 2920 3d3d 2030 0a20 2020 2020 2020  df) == 0.       
+0000e720: 2061 6e64 2066 6f72 6365 5f6f 7574 7075   and force_outpu
+0000e730: 745f 6765 6f6d 6574 7279 7479 7065 2069  t_geometrytype i
+0000e740: 7320 6e6f 7420 4e6f 6e65 0a20 2020 2020  s not None.     
+0000e750: 2020 2061 6e64 2069 7369 6e73 7461 6e63     and isinstanc
+0000e760: 6528 666f 7263 655f 6f75 7470 7574 5f67  e(force_output_g
+0000e770: 656f 6d65 7472 7974 7970 652c 2047 656f  eometrytype, Geo
+0000e780: 6d65 7472 7954 7970 6529 0a20 2020 2029  metryType).    )
+0000e790: 3a0a 2020 2020 2020 2020 2320 4966 2074  :.        # If t
+0000e7a0: 6865 2067 6466 2069 7320 656d 7074 7920  he gdf is empty 
+0000e7b0: 6275 7420 6120 6765 6f6d 6574 7279 2074  but a geometry t
+0000e7c0: 7970 6520 6973 2073 7065 6369 6669 6564  ype is specified
+0000e7d0: 2c20 7573 6520 7468 6520 7370 6563 6966  , use the specif
+0000e7e0: 6965 6420 7479 7065 0a20 2020 2020 2020  ied type.       
+0000e7f0: 2073 6368 656d 6120 3d20 6770 645f 696f   schema = gpd_io
+0000e800: 5f66 696c 652e 696e 6665 725f 7363 6865  _file.infer_sche
+0000e810: 6d61 2867 6466 290a 2020 2020 2020 2020  ma(gdf).        
+0000e820: 2320 4765 6f6d 6574 7279 2074 7970 6520  # Geometry type 
+0000e830: 6d75 7374 2062 6520 696e 2063 616d 656c  must be in camel
+0000e840: 6361 7365 2066 6f72 2066 696f 6e61 0a20  case for fiona. 
+0000e850: 2020 2020 2020 2073 6368 656d 615b 2267         schema["g
+0000e860: 656f 6d65 7472 7922 5d20 3d20 666f 7263  eometry"] = forc
+0000e870: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+0000e880: 7974 7970 652e 6e61 6d65 5f63 616d 656c  ytype.name_camel
+0000e890: 6361 7365 0a20 2020 2061 7373 6572 7420  case.    assert 
+0000e8a0: 6973 696e 7374 616e 6365 2867 6466 2c20  isinstance(gdf, 
+0000e8b0: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
+0000e8c0: 290a 0a20 2020 2023 2043 6f6e 7665 7274  )..    # Convert
+0000e8d0: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
+0000e8e0: 6f6d 6574 7279 7479 7065 2074 6f20 7374  ometrytype to st
+0000e8f0: 7269 6e67 2074 6f20 7369 6d70 6c69 6679  ring to simplify
+0000e900: 2063 6f64 6520 6166 7465 7277 6172 6473   code afterwards
+0000e910: 0a20 2020 2069 6620 6973 696e 7374 616e  .    if isinstan
+0000e920: 6365 2866 6f72 6365 5f6f 7574 7075 745f  ce(force_output_
+0000e930: 6765 6f6d 6574 7279 7479 7065 2c20 4765  geometrytype, Ge
+0000e940: 6f6d 6574 7279 5479 7065 293a 0a20 2020  ometryType):.   
+0000e950: 2020 2020 2066 6f72 6365 5f6f 7574 7075       force_outpu
+0000e960: 745f 6765 6f6d 6574 7279 7479 7065 203d  t_geometrytype =
+0000e970: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
+0000e980: 6f6d 6574 7279 7479 7065 2e6e 616d 650a  ometrytype.name.
+0000e990: 0a20 2020 2023 204e 6f20 7468 6520 6669  .    # No the fi
+0000e9a0: 6c65 2063 616e 2061 6374 7561 6c6c 7920  le can actually 
+0000e9b0: 6265 2077 7269 7474 656e 0a20 2020 2023  be written.    #
+0000e9c0: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
+0000e9d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000e9e0: 2d2d 2d2d 0a20 2020 2023 2046 696f 6e61  ----.    # Fiona
+0000e9f0: 2064 6f65 736e 2774 2073 7570 706f 7274   doesn't support
+0000ea00: 2074 6865 206f 7574 7075 7420 6765 6f6d   the output geom
+0000ea10: 6574 7279 7479 7065 2070 6172 616d 6574  etrytype paramet
+0000ea20: 6572 2061 7320 7573 6564 2069 6e20 6764  er as used in gd
+0000ea30: 616c 2c20 736f 2061 7320 610a 2020 2020  al, so as a.    
+0000ea40: 2320 6c69 6768 7477 6569 6768 7420 696d  # lightweight im
+0000ea50: 706c 656d 656e 7461 7469 6f6e 206a 7573  plementation jus
+0000ea60: 7420 7365 7420 666f 7263 650a 2020 2020  t set force.    
+0000ea70: 6465 6620 7772 6974 655f 746f 5f66 696c  def write_to_fil
+0000ea80: 6528 0a20 2020 2020 2020 2067 6466 3a20  e(.        gdf: 
+0000ea90: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
+0000eaa0: 2c0a 2020 2020 2020 2020 7061 7468 3a20  ,.        path: 
+0000eab0: 5061 7468 2c0a 2020 2020 2020 2020 6c61  Path,.        la
+0000eac0: 7965 723a 2073 7472 2c0a 2020 2020 2020  yer: str,.      
+0000ead0: 2020 696e 6465 783a 204f 7074 696f 6e61    index: Optiona
+0000eae0: 6c5b 626f 6f6c 5d20 3d20 4e6f 6e65 2c0a  l[bool] = None,.
+0000eaf0: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
+0000eb00: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000eb10: 653a 204f 7074 696f 6e61 6c5b 7374 725d  e: Optional[str]
+0000eb20: 203d 204e 6f6e 652c 0a20 2020 2020 2020   = None,.       
+0000eb30: 2066 6f72 6365 5f6d 756c 7469 7479 7065   force_multitype
+0000eb40: 3a20 626f 6f6c 203d 2046 616c 7365 2c0a  : bool = False,.
+0000eb50: 2020 2020 2020 2020 6170 7065 6e64 3a20          append: 
+0000eb60: 626f 6f6c 203d 2046 616c 7365 2c0a 2020  bool = False,.  
+0000eb70: 2020 2020 2020 7363 6865 6d61 3a20 4f70        schema: Op
+0000eb80: 7469 6f6e 616c 5b64 6963 745d 203d 204e  tional[dict] = N
+0000eb90: 6f6e 652c 0a20 2020 2020 2020 2063 7265  one,.        cre
+0000eba0: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
+0000ebb0: 783a 204f 7074 696f 6e61 6c5b 626f 6f6c  x: Optional[bool
+0000ebc0: 5d20 3d20 5472 7565 2c0a 2020 2020 293a  ] = True,.    ):
+0000ebd0: 0a20 2020 2020 2020 2023 2050 7265 7061  .        # Prepa
+0000ebe0: 7265 2061 7267 7320 666f 7220 746f 5f66  re args for to_f
+0000ebf0: 696c 650a 2020 2020 2020 2020 6966 2061  ile.        if a
+0000ec00: 7070 656e 6420 6973 2054 7275 653a 0a20  ppend is True:. 
+0000ec10: 2020 2020 2020 2020 2020 2069 6620 7061             if pa
+0000ec20: 7468 2e65 7869 7374 7328 293a 0a20 2020  th.exists():.   
+0000ec30: 2020 2020 2020 2020 2020 2020 206d 6f64               mod
+0000ec40: 6520 3d20 2261 220a 2020 2020 2020 2020  e = "a".        
+0000ec50: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000ec60: 2020 2020 2020 2020 2020 6d6f 6465 203d            mode =
+0000ec70: 2022 7722 0a20 2020 2020 2020 2065 6c73   "w".        els
+0000ec80: 653a 0a20 2020 2020 2020 2020 2020 206d  e:.            m
+0000ec90: 6f64 6520 3d20 2277 220a 0a20 2020 2020  ode = "w"..     
+0000eca0: 2020 206b 7761 7267 733a 2044 6963 745b     kwargs: Dict[
+0000ecb0: 7374 722c 2041 6e79 5d20 3d20 7b7d 0a20  str, Any] = {}. 
+0000ecc0: 2020 2020 2020 206b 7761 7267 735b 2265         kwargs["e
+0000ecd0: 6e67 696e 6522 5d20 3d20 2266 696f 6e61  ngine"] = "fiona
+0000ece0: 220a 2020 2020 2020 2020 6b77 6172 6773  ".        kwargs
+0000ecf0: 5b22 6d6f 6465 225d 203d 206d 6f64 650a  ["mode"] = mode.
+0000ed00: 2020 2020 2020 2020 6472 6976 6572 6e61          driverna
+0000ed10: 6d65 203d 205f 6765 6f66 696c 6569 6e66  me = _geofileinf
+0000ed20: 6f2e 6765 745f 6472 6976 6572 2870 6174  o.get_driver(pat
+0000ed30: 6829 0a20 2020 2020 2020 206b 7761 7267  h).        kwarg
+0000ed40: 735b 2264 7269 7665 7222 5d20 3d20 6472  s["driver"] = dr
+0000ed50: 6976 6572 6e61 6d65 0a20 2020 2020 2020  ivername.       
+0000ed60: 206b 7761 7267 735b 2269 6e64 6578 225d   kwargs["index"]
+0000ed70: 203d 2069 6e64 6578 0a20 2020 2020 2020   = index.       
+0000ed80: 2069 6620 6372 6561 7465 5f73 7061 7469   if create_spati
+0000ed90: 616c 5f69 6e64 6578 2069 7320 6e6f 7420  al_index is not 
+0000eda0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0000edb0: 2020 6b77 6172 6773 5b22 5350 4154 4941    kwargs["SPATIA
+0000edc0: 4c5f 494e 4445 5822 5d20 3d20 6372 6561  L_INDEX"] = crea
+0000edd0: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
+0000ede0: 0a20 2020 2020 2020 2069 6620 666f 7263  .        if forc
+0000edf0: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+0000ee00: 7974 7970 6520 6973 206e 6f74 204e 6f6e  ytype is not Non
+0000ee10: 653a 0a20 2020 2020 2020 2020 2020 206b  e:.            k
+0000ee20: 7761 7267 735b 2267 656f 6d65 7472 7974  wargs["geometryt
+0000ee30: 7970 6522 5d20 3d20 666f 7263 655f 6f75  ype"] = force_ou
+0000ee40: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000ee50: 650a 2020 2020 2020 2020 6966 2073 6368  e.        if sch
+0000ee60: 656d 6120 6973 206e 6f74 204e 6f6e 653a  ema is not None:
+0000ee70: 0a20 2020 2020 2020 2020 2020 206b 7761  .            kwa
+0000ee80: 7267 735b 2273 6368 656d 6122 5d20 3d20  rgs["schema"] = 
+0000ee90: 7363 6865 6d61 0a0a 2020 2020 2020 2020  schema..        
+0000eea0: 2320 4e6f 7720 7765 2063 616e 2077 7269  # Now we can wri
+0000eeb0: 7465 0a20 2020 2020 2020 2069 6620 6472  te.        if dr
+0000eec0: 6976 6572 6e61 6d65 203d 3d20 2247 504b  ivername == "GPK
+0000eed0: 4722 3a0a 2020 2020 2020 2020 2020 2020  G":.            
+0000eee0: 2320 5472 7920 746f 2068 6172 6d6f 6e69  # Try to harmoni
+0000eef0: 7a65 2074 6865 2067 656f 6d65 7472 7974  ze the geometryt
+0000ef00: 7970 6520 746f 206f 6e65 2028 6d75 6c74  ype to one (mult
+0000ef10: 6929 7479 7065 2c20 6173 2047 504b 470a  i)type, as GPKG.
+0000ef20: 2020 2020 2020 2020 2020 2020 2320 646f              # do
+0000ef30: 6573 6e27 7420 6c69 6b65 203e 2031 2074  esn't like > 1 t
+0000ef40: 7970 6520 696e 2061 206c 6179 6572 0a20  ype in a layer. 
+0000ef50: 2020 2020 2020 2020 2020 2069 6620 7363             if sc
+0000ef60: 6865 6d61 2069 7320 4e6f 6e65 206f 7220  hema is None or 
+0000ef70: 286c 656e 2867 6466 2920 3e20 3020 616e  (len(gdf) > 0 an
+0000ef80: 6420 7363 6865 6d61 5b22 6765 6f6d 6574  d schema["geomet
+0000ef90: 7279 225d 2021 3d20 224e 6f6e 6522 293a  ry"] != "None"):
+0000efa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000efb0: 2067 6466 203d 2067 6466 2e63 6f70 7928   gdf = gdf.copy(
+0000efc0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000efd0: 2020 6764 662e 6765 6f6d 6574 7279 203d    gdf.geometry =
+0000efe0: 205f 6765 6f73 6572 6965 735f 7574 696c   _geoseries_util
+0000eff0: 2e68 6172 6d6f 6e69 7a65 5f67 656f 6d65  .harmonize_geome
+0000f000: 7472 7974 7970 6573 280a 2020 2020 2020  trytypes(.      
+0000f010: 2020 2020 2020 2020 2020 2020 2020 6764                gd
+0000f020: 662e 6765 6f6d 6574 7279 2c20 666f 7263  f.geometry, forc
+0000f030: 655f 6d75 6c74 6974 7970 653d 666f 7263  e_multitype=forc
+0000f040: 655f 6d75 6c74 6974 7970 650a 2020 2020  e_multitype.    
+0000f050: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0000f060: 2020 2020 2020 2020 2020 6764 662e 746f            gdf.to
+0000f070: 5f66 696c 6528 7374 7228 7061 7468 292c  _file(str(path),
+0000f080: 206c 6179 6572 3d6c 6179 6572 2c20 2a2a   layer=layer, **
+0000f090: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
+0000f0a0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0000f0b0: 2020 6764 662e 746f 5f66 696c 6528 7374    gdf.to_file(st
+0000f0c0: 7228 7061 7468 292c 206c 6179 6572 3d6c  r(path), layer=l
+0000f0d0: 6179 6572 2c20 2a2a 6b77 6172 6773 290a  ayer, **kwargs).
+0000f0e0: 0a20 2020 2023 2049 6620 6e6f 2061 7070  .    # If no app
+0000f0f0: 656e 642c 206a 7573 7420 7772 6974 6520  end, just write 
+0000f100: 746f 206f 7574 7075 7420 7061 7468 0a20  to output path. 
+0000f110: 2020 2069 6620 6e6f 7420 6170 7065 6e64     if not append
+0000f120: 3a0a 2020 2020 2020 2020 7772 6974 655f  :.        write_
+0000f130: 746f 5f66 696c 6528 0a20 2020 2020 2020  to_file(.       
+0000f140: 2020 2020 2067 6466 3d67 6466 2c0a 2020       gdf=gdf,.  
+0000f150: 2020 2020 2020 2020 2020 7061 7468 3d70            path=p
+0000f160: 6174 682c 0a20 2020 2020 2020 2020 2020  ath,.           
+0000f170: 206c 6179 6572 3d6c 6179 6572 2c0a 2020   layer=layer,.  
+0000f180: 2020 2020 2020 2020 2020 696e 6465 783d            index=
+0000f190: 696e 6465 782c 0a20 2020 2020 2020 2020  index,.         
+0000f1a0: 2020 2066 6f72 6365 5f6f 7574 7075 745f     force_output_
+0000f1b0: 6765 6f6d 6574 7279 7479 7065 3d66 6f72  geometrytype=for
+0000f1c0: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
+0000f1d0: 7279 7479 7065 2c0a 2020 2020 2020 2020  rytype,.        
+0000f1e0: 2020 2020 666f 7263 655f 6d75 6c74 6974      force_multit
+0000f1f0: 7970 653d 666f 7263 655f 6d75 6c74 6974  ype=force_multit
+0000f200: 7970 652c 0a20 2020 2020 2020 2020 2020  ype,.           
+0000f210: 2061 7070 656e 643d 6170 7065 6e64 2c0a   append=append,.
+0000f220: 2020 2020 2020 2020 2020 2020 7363 6865              sche
+0000f230: 6d61 3d73 6368 656d 612c 0a20 2020 2020  ma=schema,.     
+0000f240: 2020 2020 2020 2063 7265 6174 655f 7370         create_sp
+0000f250: 6174 6961 6c5f 696e 6465 783d 6372 6561  atial_index=crea
+0000f260: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
+0000f270: 2c0a 2020 2020 2020 2020 290a 2020 2020  ,.        ).    
+0000f280: 656c 7365 3a0a 2020 2020 2020 2020 2320  else:.        # 
+0000f290: 4170 7065 6e64 2069 7320 6173 6b65 642c  Append is asked,
+0000f2a0: 2063 6865 636b 2069 6620 7468 6520 6669   check if the fi
+0000f2b0: 6f6e 6120 6472 6976 6572 2073 7570 706f  ona driver suppo
+0000f2c0: 7274 7320 6170 7065 6e64 696e 672e 2049  rts appending. I
+0000f2d0: 660a 2020 2020 2020 2020 2320 6e6f 742c  f.        # not,
+0000f2e0: 2077 7269 7465 2074 6f20 7465 6d70 6f72   write to tempor
+0000f2f0: 6172 7920 6f75 7470 7574 2066 696c 650a  ary output file.
+0000f300: 0a20 2020 2020 2020 2023 2052 656d 6172  .        # Remar
+0000f310: 6b3a 2066 696f 6e61 2070 7265 2d31 2e38  k: fiona pre-1.8
+0000f320: 2e31 3420 6469 646e 2774 2073 7570 706f  .14 didn't suppo
+0000f330: 7274 2061 7070 656e 6469 6e67 2074 6f20  rt appending to 
+0000f340: 6765 6f70 6163 6b61 6765 2e20 4f6e 6365  geopackage. Once
+0000f350: 0a20 2020 2020 2020 2023 206f 6c64 6572  .        # older
+0000f360: 2076 6572 7369 6f6e 7320 6265 636f 6d65   versions become
+0000f370: 7320 7261 7265 2c20 6465 7065 6e64 656e  s rare, dependen
+0000f380: 6379 2063 616e 2062 6520 7075 7420 746f  cy can be put to
+0000f390: 2074 6869 7320 7665 7273 696f 6e2c 2061   this version, a
+0000f3a0: 6e64 0a20 2020 2020 2020 2023 2074 6869  nd.        # thi
+0000f3b0: 7320 636f 6465 2063 616e 2062 6520 636c  s code can be cl
+0000f3c0: 6561 6e65 6420 7570 2e2e 2e0a 2020 2020  eaned up....    
+0000f3d0: 2020 2020 7061 7468 5f69 6e66 6f20 3d20      path_info = 
+0000f3e0: 5f67 656f 6669 6c65 696e 666f 2e67 6574  _geofileinfo.get
+0000f3f0: 5f67 656f 6669 6c65 696e 666f 2870 6174  _geofileinfo(pat
+0000f400: 6829 0a20 2020 2020 2020 2067 6466 7465  h).        gdfte
+0000f410: 6d70 5f70 6174 6820 3d20 4e6f 6e65 0a20  mp_path = None. 
+0000f420: 2020 2020 2020 2067 6466 7465 6d70 5f6c         gdftemp_l
+0000f430: 6f63 6b70 6174 6820 3d20 4e6f 6e65 0a20  ockpath = None. 
+0000f440: 2020 2020 2020 2069 6620 2261 2220 6e6f         if "a" no
+0000f450: 7420 696e 2066 696f 6e61 2e73 7570 706f  t in fiona.suppo
+0000f460: 7274 6564 5f64 7269 7665 7273 5b70 6174  rted_drivers[pat
+0000f470: 685f 696e 666f 2e64 7269 7665 725d 3a0a  h_info.driver]:.
+0000f480: 2020 2020 2020 2020 2020 2020 2320 4765              # Ge
+0000f490: 7420 6120 756e 6971 7565 2074 656d 7020  t a unique temp 
+0000f4a0: 6669 6c65 2070 6174 682e 2054 6865 2066  file path. The f
+0000f4b0: 696c 6520 6361 6e6e 6f74 2062 6520 6372  ile cannot be cr
+0000f4c0: 6561 7465 6420 7965 742c 2073 6f0a 2020  eated yet, so.  
+0000f4d0: 2020 2020 2020 2020 2020 2320 6f6e 6c79            # only
+0000f4e0: 2063 7265 6174 6520 6120 6c6f 636b 2066   create a lock f
+0000f4f0: 696c 6520 746f 2061 766f 6964 206f 7468  ile to avoid oth
+0000f500: 6572 2070 726f 6365 7373 6573 2075 7369  er processes usi
+0000f510: 6e67 2074 6865 2073 616d 650a 2020 2020  ng the same.    
+0000f520: 2020 2020 2020 2020 2320 7465 6d70 2066          # temp f
+0000f530: 696c 6520 6e61 6d65 0a20 2020 2020 2020  ile name.       
+0000f540: 2020 2020 2067 6466 7465 6d70 5f70 6174       gdftemp_pat
+0000f550: 682c 2067 6466 7465 6d70 5f6c 6f63 6b70  h, gdftemp_lockp
+0000f560: 6174 6820 3d20 5f69 6f5f 7574 696c 2e67  ath = _io_util.g
+0000f570: 6574 5f74 656d 7066 696c 655f 6c6f 636b  et_tempfile_lock
+0000f580: 6564 280a 2020 2020 2020 2020 2020 2020  ed(.            
+0000f590: 2020 2020 6261 7365 5f66 696c 656e 616d      base_filenam
+0000f5a0: 653d 2267 6466 7465 6d70 222c 2073 7566  e="gdftemp", suf
+0000f5b0: 6669 783d 7061 7468 2e73 7566 6669 782c  fix=path.suffix,
+0000f5c0: 2064 6972 6e61 6d65 3d22 6765 6f66 696c   dirname="geofil
+0000f5d0: 655f 746f 5f66 696c 6522 0a20 2020 2020  e_to_file".     
+0000f5e0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0000f5f0: 2020 2020 2077 7269 7465 5f74 6f5f 6669       write_to_fi
+0000f600: 6c65 280a 2020 2020 2020 2020 2020 2020  le(.            
+0000f610: 2020 2020 6764 662c 0a20 2020 2020 2020      gdf,.       
+0000f620: 2020 2020 2020 2020 2070 6174 683d 6764           path=gd
+0000f630: 6674 656d 705f 7061 7468 2c0a 2020 2020  ftemp_path,.    
+0000f640: 2020 2020 2020 2020 2020 2020 6c61 7965              laye
+0000f650: 723d 6c61 7965 722c 0a20 2020 2020 2020  r=layer,.       
+0000f660: 2020 2020 2020 2020 2069 6e64 6578 3d69           index=i
+0000f670: 6e64 6578 2c0a 2020 2020 2020 2020 2020  ndex,.          
+0000f680: 2020 2020 2020 666f 7263 655f 6f75 7470        force_outp
+0000f690: 7574 5f67 656f 6d65 7472 7974 7970 653d  ut_geometrytype=
+0000f6a0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
+0000f6b0: 6d65 7472 7974 7970 652c 0a20 2020 2020  metrytype,.     
+0000f6c0: 2020 2020 2020 2020 2020 2066 6f72 6365             force
+0000f6d0: 5f6d 756c 7469 7479 7065 3d66 6f72 6365  _multitype=force
+0000f6e0: 5f6d 756c 7469 7479 7065 2c0a 2020 2020  _multitype,.    
+0000f6f0: 2020 2020 2020 2020 2020 2020 7363 6865              sche
+0000f700: 6d61 3d73 6368 656d 612c 0a20 2020 2020  ma=schema,.     
+0000f710: 2020 2020 2020 2020 2020 2063 7265 6174             creat
+0000f720: 655f 7370 6174 6961 6c5f 696e 6465 783d  e_spatial_index=
+0000f730: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
+0000f740: 6e64 6578 2c0a 2020 2020 2020 2020 2020  ndex,.          
+0000f750: 2020 290a 0a20 2020 2020 2020 2023 2046    )..        # F
+0000f760: 696c 6573 2064 6f6e 2774 2074 7970 6963  iles don't typic
+0000f770: 616c 6c79 2073 7570 706f 7274 2068 6176  ally support hav
+0000f780: 696e 6720 6d75 6c74 6970 6c65 2070 726f  ing multiple pro
+0000f790: 6365 7373 6573 2077 7269 7469 6e67 0a20  cesses writing. 
+0000f7a0: 2020 2020 2020 2023 2073 696d 756c 7461         # simulta
+0000f7b0: 6e6f 7573 6c79 2074 6f20 7468 656d 2c20  nously to them, 
+0000f7c0: 736f 2075 7365 206c 6f63 6b20 6669 6c65  so use lock file
+0000f7d0: 2074 6f20 7379 6e63 6872 6f6e 697a 6520   to synchronize 
+0000f7e0: 6163 6365 7373 2e0a 2020 2020 2020 2020  access..        
+0000f7f0: 6c6f 636b 6669 6c65 203d 2050 6174 6828  lockfile = Path(
+0000f800: 6622 7b73 7472 2870 6174 6829 7d2e 6c6f  f"{str(path)}.lo
+0000f810: 636b 2229 0a20 2020 2020 2020 2073 7461  ck").        sta
+0000f820: 7274 5f74 696d 6520 3d20 6461 7465 7469  rt_time = dateti
+0000f830: 6d65 2e64 6174 6574 696d 652e 6e6f 7728  me.datetime.now(
+0000f840: 290a 2020 2020 2020 2020 7265 6164 7920  ).        ready 
+0000f850: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+0000f860: 7768 696c 6520 6e6f 7420 7265 6164 793a  while not ready:
+0000f870: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000f880: 5f69 6f5f 7574 696c 2e63 7265 6174 655f  _io_util.create_
+0000f890: 6669 6c65 5f61 746f 6d69 6328 6c6f 636b  file_atomic(lock
+0000f8a0: 6669 6c65 2920 6973 2054 7275 653a 0a20  file) is True:. 
+0000f8b0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0000f8c0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+0000f8d0: 2020 2020 2020 2020 2320 4966 2067 6466          # If gdf
+0000f8e0: 2077 6173 6e27 7420 7772 6974 7465 6e20   wasn't written 
+0000f8f0: 746f 2074 656d 7020 6669 6c65 2c20 7573  to temp file, us
+0000f900: 6520 7374 616e 6461 7264 2077 7269 7465  e standard write
+0000f910: 2d74 6f2d 6669 6c65 0a20 2020 2020 2020  -to-file.       
+0000f920: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000f930: 6764 6674 656d 705f 7061 7468 2069 7320  gdftemp_path is 
+0000f940: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0000f950: 2020 2020 2020 2020 2020 2020 2020 7772                wr
+0000f960: 6974 655f 746f 5f66 696c 6528 0a20 2020  ite_to_file(.   
+0000f970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f980: 2020 2020 2020 2020 2067 6466 3d67 6466           gdf=gdf
+0000f990: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000f9a0: 2020 2020 2020 2020 2020 2020 2020 7061                pa
+0000f9b0: 7468 3d70 6174 682c 0a20 2020 2020 2020  th=path,.       
+0000f9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f9d0: 2020 2020 206c 6179 6572 3d6c 6179 6572       layer=layer
+0000f9e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000f9f0: 2020 2020 2020 2020 2020 2020 2020 696e                in
+0000fa00: 6465 783d 696e 6465 782c 0a20 2020 2020  dex=index,.     
+0000fa10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fa20: 2020 2020 2020 2066 6f72 6365 5f6f 7574         force_out
+0000fa30: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
+0000fa40: 3d66 6f72 6365 5f6f 7574 7075 745f 6765  =force_output_ge
+0000fa50: 6f6d 6574 7279 7479 7065 2c0a 2020 2020  ometrytype,.    
+0000fa60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fa70: 2020 2020 2020 2020 666f 7263 655f 6d75          force_mu
+0000fa80: 6c74 6974 7970 653d 666f 7263 655f 6d75  ltitype=force_mu
+0000fa90: 6c74 6974 7970 652c 0a20 2020 2020 2020  ltitype,.       
+0000faa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fab0: 2020 2020 2061 7070 656e 643d 5472 7565       append=True
+0000fac0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000fad0: 2020 2020 2020 2020 2020 2020 2020 7363                sc
+0000fae0: 6865 6d61 3d73 6368 656d 612c 0a20 2020  hema=schema,.   
+0000faf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fb00: 2020 2020 2020 2020 2063 7265 6174 655f           create_
+0000fb10: 7370 6174 6961 6c5f 696e 6465 783d 6372  spatial_index=cr
+0000fb20: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
+0000fb30: 6578 2c0a 2020 2020 2020 2020 2020 2020  ex,.            
+0000fb40: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0000fb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fb60: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000fb70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fb80: 2320 4966 2067 6466 2077 7269 7474 656e  # If gdf written
+0000fb90: 2074 6f20 7465 6d70 2066 696c 652c 2075   to temp file, u
+0000fba0: 7365 2061 7070 656e 645f 746f 5f6e 6f6c  se append_to_nol
+0000fbb0: 6f63 6b20 2b20 636c 6561 6e75 700a 2020  ock + cleanup.  
+0000fbc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fbd0: 2020 2020 2020 5f61 7070 656e 645f 746f        _append_to
+0000fbe0: 5f6e 6f6c 6f63 6b28 0a20 2020 2020 2020  _nolock(.       
+0000fbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fc00: 2020 2020 2073 7263 3d67 6466 7465 6d70       src=gdftemp
+0000fc10: 5f70 6174 682c 0a20 2020 2020 2020 2020  _path,.         
+0000fc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fc30: 2020 2064 7374 3d70 6174 682c 0a20 2020     dst=path,.   
+0000fc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fc50: 2020 2020 2020 2020 2064 7374 5f6c 6179           dst_lay
+0000fc60: 6572 3d6c 6179 6572 2c0a 2020 2020 2020  er=layer,.      
+0000fc70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fc80: 2020 2020 2020 666f 7263 655f 6f75 7470        force_outp
+0000fc90: 7574 5f67 656f 6d65 7472 7974 7970 653d  ut_geometrytype=
+0000fca0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
+0000fcb0: 6d65 7472 7974 7970 652c 0a20 2020 2020  metrytype,.     
+0000fcc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fcd0: 2020 2020 2020 2063 7265 6174 655f 7370         create_sp
+0000fce0: 6174 6961 6c5f 696e 6465 783d 6372 6561  atial_index=crea
+0000fcf0: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
+0000fd00: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000fd10: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+0000fd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fd30: 2020 2020 7265 6d6f 7665 2867 6466 7465      remove(gdfte
+0000fd40: 6d70 5f70 6174 6829 0a20 2020 2020 2020  mp_path).       
+0000fd50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fd60: 2069 6620 6764 6674 656d 705f 6c6f 636b   if gdftemp_lock
+0000fd70: 7061 7468 2069 7320 6e6f 7420 4e6f 6e65  path is not None
+0000fd80: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000fd90: 2020 2020 2020 2020 2020 2020 2020 6764                gd
+0000fda0: 6674 656d 705f 6c6f 636b 7061 7468 2e75  ftemp_lockpath.u
+0000fdb0: 6e6c 696e 6b28 290a 2020 2020 2020 2020  nlink().        
+0000fdc0: 2020 2020 2020 2020 6578 6365 7074 2045          except E
+0000fdd0: 7863 6570 7469 6f6e 2061 7320 6578 3a0a  xception as ex:.
+0000fde0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fdf0: 2020 2020 2320 4966 2073 716c 6974 6520      # If sqlite 
+0000fe00: 6f75 7470 7574 2066 696c 6520 6c6f 636b  output file lock
+0000fe10: 6564 2c20 616c 736f 2072 6574 7279 0a20  ed, also retry. 
+0000fe20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fe30: 2020 2069 6620 7061 7468 5f69 6e66 6f2e     if path_info.
+0000fe40: 6973 5f73 7061 7469 616c 6974 655f 6261  is_spatialite_ba
+0000fe50: 7365 6420 616e 6420 7374 7228 6578 2920  sed and str(ex) 
+0000fe60: 6e6f 7420 696e 205b 0a20 2020 2020 2020  not in [.       
+0000fe70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fe80: 2022 6461 7461 6261 7365 2069 7320 6c6f   "database is lo
+0000fe90: 636b 6564 222c 0a20 2020 2020 2020 2020  cked",.         
+0000fea0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000feb0: 6174 7465 6d70 7420 746f 2077 7269 7465  attempt to write
+0000fec0: 2061 2072 6561 646f 6e6c 7920 6461 7461   a readonly data
+0000fed0: 6261 7365 222c 0a20 2020 2020 2020 2020  base",.         
+0000fee0: 2020 2020 2020 2020 2020 205d 3a0a 2020             ]:.  
+0000fef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ff00: 2020 2020 2020 7261 6973 6520 6578 0a20        raise ex. 
+0000ff10: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000ff20: 696e 616c 6c79 3a0a 2020 2020 2020 2020  inally:.        
+0000ff30: 2020 2020 2020 2020 2020 2020 7265 6164              read
+0000ff40: 7920 3d20 5472 7565 0a20 2020 2020 2020  y = True.       
+0000ff50: 2020 2020 2020 2020 2020 2020 206c 6f63               loc
+0000ff60: 6b66 696c 652e 756e 6c69 6e6b 2829 0a20  kfile.unlink(). 
+0000ff70: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0000ff80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ff90: 2074 696d 655f 7761 6974 696e 6720 3d20   time_waiting = 
+0000ffa0: 2864 6174 6574 696d 652e 6461 7465 7469  (datetime.dateti
+0000ffb0: 6d65 2e6e 6f77 2829 202d 2073 7461 7274  me.now() - start
+0000ffc0: 5f74 696d 6529 2e74 6f74 616c 5f73 6563  _time).total_sec
+0000ffd0: 6f6e 6473 2829 0a20 2020 2020 2020 2020  onds().         
+0000ffe0: 2020 2020 2020 2069 6620 7469 6d65 5f77         if time_w
+0000fff0: 6169 7469 6e67 203e 2061 7070 656e 645f  aiting > append_
+00010000: 7469 6d65 6f75 745f 733a 0a20 2020 2020  timeout_s:.     
+00010010: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00010020: 6169 7365 2052 756e 7469 6d65 4572 726f  aise RuntimeErro
+00010030: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
+00010040: 2020 2020 2020 2020 2020 2066 2274 6f5f             f"to_
+00010050: 6669 6c65 2074 696d 656f 7574 206f 6620  file timeout of 
+00010060: 7b61 7070 656e 645f 7469 6d65 6f75 745f  {append_timeout_
+00010070: 737d 2072 6561 6368 6564 2c20 7374 6f70  s} reached, stop
+00010080: 2061 7070 656e 6420 220a 2020 2020 2020   append ".      
 00010090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000100a0: 2020 2020 2020 2020 2020 6c61 7965 723d            layer=
-000100b0: 6c61 7965 722c 0d0a 2020 2020 2020 2020  layer,..        
-000100c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000100d0: 2020 2020 696e 6465 783d 696e 6465 782c      index=index,
-000100e0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000100f0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00010100: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-00010110: 7472 7974 7970 653d 666f 7263 655f 6f75  trytype=force_ou
-00010120: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
-00010130: 652c 0d0a 2020 2020 2020 2020 2020 2020  e,..            
-00010140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010150: 666f 7263 655f 6d75 6c74 6974 7970 653d  force_multitype=
-00010160: 666f 7263 655f 6d75 6c74 6974 7970 652c  force_multitype,
-00010170: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00010180: 2020 2020 2020 2020 2020 2020 2020 6170                ap
-00010190: 7065 6e64 3d54 7275 652c 0d0a 2020 2020  pend=True,..    
-000101a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000101b0: 2020 2020 2020 2020 7363 6865 6d61 3d73          schema=s
-000101c0: 6368 656d 612c 0d0a 2020 2020 2020 2020  chema,..        
-000101d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000101e0: 2020 2020 6372 6561 7465 5f73 7061 7469      create_spati
-000101f0: 616c 5f69 6e64 6578 3d63 7265 6174 655f  al_index=create_
-00010200: 7370 6174 6961 6c5f 696e 6465 782c 0d0a  spatial_index,..
-00010210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010220: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-00010230: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00010240: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-00010250: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00010260: 4966 2067 6466 2077 7269 7474 656e 2074  If gdf written t
-00010270: 6f20 7465 6d70 2066 696c 652c 2075 7365  o temp file, use
-00010280: 2061 7070 656e 645f 746f 5f6e 6f6c 6f63   append_to_noloc
-00010290: 6b20 2b20 636c 6561 6e75 700d 0a20 2020  k + cleanup..   
-000102a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000102b0: 2020 2020 205f 6170 7065 6e64 5f74 6f5f       _append_to_
-000102c0: 6e6f 6c6f 636b 280d 0a20 2020 2020 2020  nolock(..       
-000102d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000102e0: 2020 2020 2073 7263 3d67 6466 7465 6d70       src=gdftemp
-000102f0: 5f70 6174 682c 0d0a 2020 2020 2020 2020  _path,..        
-00010300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010310: 2020 2020 6473 743d 7061 7468 2c0d 0a20      dst=path,.. 
-00010320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010330: 2020 2020 2020 2020 2020 2064 7374 5f6c             dst_l
-00010340: 6179 6572 3d6c 6179 6572 2c0d 0a20 2020  ayer=layer,..   
-00010350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010360: 2020 2020 2020 2020 2066 6f72 6365 5f6f           force_o
-00010370: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-00010380: 7065 3d66 6f72 6365 5f6f 7574 7075 745f  pe=force_output_
-00010390: 6765 6f6d 6574 7279 7479 7065 2c0d 0a20  geometrytype,.. 
-000103a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000103b0: 2020 2020 2020 2020 2020 2063 7265 6174             creat
-000103c0: 655f 7370 6174 6961 6c5f 696e 6465 783d  e_spatial_index=
-000103d0: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-000103e0: 6e64 6578 2c0d 0a20 2020 2020 2020 2020  ndex,..         
-000103f0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00010400: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00010410: 2020 2020 2020 2020 2020 7265 6d6f 7665            remove
-00010420: 2867 6466 7465 6d70 5f70 6174 6829 0d0a  (gdftemp_path)..
-00010430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010440: 2020 2020 2020 2020 6966 2067 6466 7465          if gdfte
-00010450: 6d70 5f6c 6f63 6b70 6174 6820 6973 206e  mp_lockpath is n
-00010460: 6f74 204e 6f6e 653a 0d0a 2020 2020 2020  ot None:..      
-00010470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010480: 2020 2020 2020 6764 6674 656d 705f 6c6f        gdftemp_lo
-00010490: 636b 7061 7468 2e75 6e6c 696e 6b28 290d  ckpath.unlink().
-000104a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000104b0: 2065 7863 6570 7420 4578 6365 7074 696f   except Exceptio
-000104c0: 6e20 6173 2065 783a 0d0a 2020 2020 2020  n as ex:..      
-000104d0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-000104e0: 4966 2073 716c 6974 6520 6f75 7470 7574  If sqlite output
-000104f0: 2066 696c 6520 6c6f 636b 6564 2c20 616c   file locked, al
-00010500: 736f 2072 6574 7279 0d0a 2020 2020 2020  so retry..      
-00010510: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00010520: 2070 6174 685f 696e 666f 2e69 735f 7370   path_info.is_sp
-00010530: 6174 6961 6c69 7465 5f62 6173 6564 2061  atialite_based a
-00010540: 6e64 2073 7472 2865 7829 206e 6f74 2069  nd str(ex) not i
-00010550: 6e20 5b0d 0a20 2020 2020 2020 2020 2020  n [..           
-00010560: 2020 2020 2020 2020 2020 2020 2022 6461               "da
-00010570: 7461 6261 7365 2069 7320 6c6f 636b 6564  tabase is locked
-00010580: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-00010590: 2020 2020 2020 2020 2020 2020 2261 7474              "att
-000105a0: 656d 7074 2074 6f20 7772 6974 6520 6120  empt to write a 
-000105b0: 7265 6164 6f6e 6c79 2064 6174 6162 6173  readonly databas
-000105c0: 6522 2c0d 0a20 2020 2020 2020 2020 2020  e",..           
-000105d0: 2020 2020 2020 2020 205d 3a0d 0a20 2020           ]:..   
-000105e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000105f0: 2020 2020 2072 6169 7365 2065 780d 0a20       raise ex.. 
-00010600: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00010610: 696e 616c 6c79 3a0d 0a20 2020 2020 2020  inally:..       
-00010620: 2020 2020 2020 2020 2020 2020 2072 6561               rea
-00010630: 6479 203d 2054 7275 650d 0a20 2020 2020  dy = True..     
-00010640: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00010650: 6f63 6b66 696c 652e 756e 6c69 6e6b 2829  ockfile.unlink()
-00010660: 0d0a 2020 2020 2020 2020 2020 2020 656c  ..            el
-00010670: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-00010680: 2020 2020 2074 696d 655f 7761 6974 696e       time_waitin
-00010690: 6720 3d20 2864 6174 6574 696d 652e 6461  g = (datetime.da
-000106a0: 7465 7469 6d65 2e6e 6f77 2829 202d 2073  tetime.now() - s
-000106b0: 7461 7274 5f74 696d 6529 2e74 6f74 616c  tart_time).total
-000106c0: 5f73 6563 6f6e 6473 2829 0d0a 2020 2020  _seconds()..    
-000106d0: 2020 2020 2020 2020 2020 2020 6966 2074              if t
-000106e0: 696d 655f 7761 6974 696e 6720 3e20 6170  ime_waiting > ap
-000106f0: 7065 6e64 5f74 696d 656f 7574 5f73 3a0d  pend_timeout_s:.
-00010700: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010710: 2020 2020 2072 6169 7365 2052 756e 7469       raise Runti
-00010720: 6d65 4572 726f 7228 0d0a 2020 2020 2020  meError(..      
-00010730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010740: 2020 6622 746f 5f66 696c 6520 7469 6d65    f"to_file time
-00010750: 6f75 7420 6f66 207b 6170 7065 6e64 5f74  out of {append_t
-00010760: 696d 656f 7574 5f73 7d20 7265 6163 6865  imeout_s} reache
-00010770: 642c 2073 746f 7020 6170 7065 6e64 2022  d, stop append "
-00010780: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00010790: 2020 2020 2020 2020 2020 6622 746f 207b            f"to {
-000107a0: 7061 7468 7d21 220d 0a20 2020 2020 2020  path}!"..       
-000107b0: 2020 2020 2020 2020 2020 2020 2029 0d0a               )..
-000107c0: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-000107d0: 536c 6565 7020 666f 7220 6120 7365 636f  Sleep for a seco
-000107e0: 6e64 2062 6566 6f72 6520 7472 7969 6e67  nd before trying
-000107f0: 2061 6761 696e 0d0a 2020 2020 2020 2020   again..        
-00010800: 2020 2020 7469 6d65 2e73 6c65 6570 2831      time.sleep(1
-00010810: 290d 0a0d 0a0d 0a64 6566 205f 746f 5f66  )......def _to_f
-00010820: 696c 655f 7079 6f67 7269 6f28 0d0a 2020  ile_pyogrio(..  
-00010830: 2020 6764 663a 2067 7064 2e47 656f 4461    gdf: gpd.GeoDa
-00010840: 7461 4672 616d 652c 0d0a 2020 2020 7061  taFrame,..    pa
-00010850: 7468 3a20 5061 7468 2c0d 0a20 2020 206c  th: Path,..    l
-00010860: 6179 6572 3a20 7374 722c 0d0a 2020 2020  ayer: str,..    
-00010870: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
-00010880: 6d65 7472 7974 7970 653a 2055 6e69 6f6e  metrytype: Union
-00010890: 5b47 656f 6d65 7472 7954 7970 652c 2073  [GeometryType, s
-000108a0: 7472 2c20 4e6f 6e65 5d20 3d20 4e6f 6e65  tr, None] = None
-000108b0: 2c0d 0a20 2020 2066 6f72 6365 5f6d 756c  ,..    force_mul
-000108c0: 7469 7479 7065 3a20 626f 6f6c 203d 2046  titype: bool = F
-000108d0: 616c 7365 2c0d 0a20 2020 2061 7070 656e  alse,..    appen
-000108e0: 643a 2062 6f6f 6c20 3d20 4661 6c73 652c  d: bool = False,
-000108f0: 0d0a 2020 2020 6170 7065 6e64 5f74 696d  ..    append_tim
-00010900: 656f 7574 5f73 3a20 696e 7420 3d20 3630  eout_s: int = 60
-00010910: 302c 0d0a 2020 2020 696e 6465 783a 204f  0,..    index: O
-00010920: 7074 696f 6e61 6c5b 626f 6f6c 5d20 3d20  ptional[bool] = 
-00010930: 4e6f 6e65 2c0d 0a20 2020 2063 7265 6174  None,..    creat
-00010940: 655f 7370 6174 6961 6c5f 696e 6465 783a  e_spatial_index:
-00010950: 204f 7074 696f 6e61 6c5b 626f 6f6c 5d20   Optional[bool] 
-00010960: 3d20 5472 7565 2c0d 0a29 3a0d 0a20 2020  = True,..):..   
-00010970: 2022 2222 0d0a 2020 2020 5772 6974 6573   """..    Writes
-00010980: 2061 2070 616e 6461 7320 6461 7461 6672   a pandas datafr
-00010990: 616d 6520 746f 2066 696c 6520 7573 696e  ame to file usin
-000109a0: 6720 7079 6f67 7269 6f2e 0d0a 0d0a 2020  g pyogrio.....  
-000109b0: 2020 5265 6d61 726b 3a20 7468 6973 2066    Remark: this f
-000109c0: 756e 6374 696f 6e20 6f6e 6c79 2073 7570  unction only sup
-000109d0: 706f 7274 7320 7772 6974 696e 6720 4765  ports writing Ge
-000109e0: 6f44 6174 6146 7261 6d65 7320 6174 2074  oDataFrames at t
-000109f0: 6865 206d 6f6d 656e 742e 0d0a 2020 2020  he moment...    
-00010a00: 2222 220d 0a20 2020 2023 2050 7265 7061  """..    # Prepa
-00010a10: 7265 2061 7267 7320 666f 7220 7772 6974  re args for writ
-00010a20: 655f 6461 7461 6672 616d 650d 0a20 2020  e_dataframe..   
-00010a30: 206b 7761 7267 733a 2044 6963 745b 7374   kwargs: Dict[st
-00010a40: 722c 2041 6e79 5d20 3d20 7b7d 0d0a 2020  r, Any] = {}..  
-00010a50: 2020 6b77 6172 6773 5b22 656e 6769 6e65    kwargs["engine
-00010a60: 225d 203d 2022 7079 6f67 7269 6f22 0d0a  "] = "pyogrio"..
-00010a70: 0d0a 2020 2020 2320 4368 6563 6b20 7570  ..    # Check up
-00010a80: 6672 6f6e 7420 6966 2061 7070 656e 6420  front if append 
-00010a90: 6973 2067 6f69 6e67 2074 6f20 776f 726b  is going to work
-00010aa0: 2074 6f20 6769 7665 206e 6963 6520 6572   to give nice er
-00010ab0: 726f 720d 0a20 2020 2069 6620 6170 7065  ror..    if appe
-00010ac0: 6e64 2069 7320 5472 7565 2061 6e64 2070  nd is True and p
-00010ad0: 6174 682e 6578 6973 7473 2829 3a0d 0a20  ath.exists():.. 
-00010ae0: 2020 2020 2020 206b 7761 7267 735b 2261         kwargs["a
-00010af0: 7070 656e 6422 5d20 3d20 5472 7565 0d0a  ppend"] = True..
-00010b00: 2020 2020 2020 2020 6c61 7965 7269 6e66          layerinf
-00010b10: 6f20 3d20 6765 745f 6c61 7965 7269 6e66  o = get_layerinf
-00010b20: 6f28 7061 7468 2c20 6c61 7965 7229 0d0a  o(path, layer)..
-00010b30: 2020 2020 2020 2020 6669 6c65 5f63 6f6c          file_col
-00010b40: 7320 3d20 5b63 6f6c 2e75 7070 6572 2829  s = [col.upper()
-00010b50: 2066 6f72 2063 6f6c 2069 6e20 6c61 7965   for col in laye
-00010b60: 7269 6e66 6f2e 636f 6c75 6d6e 735d 0d0a  rinfo.columns]..
-00010b70: 2020 2020 2020 2020 6764 665f 636f 6c73          gdf_cols
-00010b80: 203d 205b 636f 6c2e 7570 7065 7228 2920   = [col.upper() 
-00010b90: 666f 7220 636f 6c20 696e 2067 6466 2e63  for col in gdf.c
-00010ba0: 6f6c 756d 6e73 2069 6620 636f 6c20 213d  olumns if col !=
-00010bb0: 2067 6466 2e67 656f 6d65 7472 792e 6e61   gdf.geometry.na
-00010bc0: 6d65 5d0d 0a20 2020 2020 2020 2069 6620  me]..        if 
-00010bd0: 6764 665f 636f 6c73 2021 3d20 6669 6c65  gdf_cols != file
-00010be0: 5f63 6f6c 733a 0d0a 2020 2020 2020 2020  _cols:..        
-00010bf0: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-00010c00: 7272 6f72 280d 0a20 2020 2020 2020 2020  rror(..         
-00010c10: 2020 2020 2020 2022 6465 7374 696e 6174         "destinat
-00010c20: 696f 6e20 6c61 7965 7220 646f 6573 6e27  ion layer doesn'
-00010c30: 7420 6861 7665 2074 6865 2073 616d 6520  t have the same 
-00010c40: 636f 6c75 6d6e 7320 6173 2067 6466 3a20  columns as gdf: 
-00010c50: 220d 0a20 2020 2020 2020 2020 2020 2020  "..             
-00010c60: 2020 2066 227b 6669 6c65 5f63 6f6c 737d     f"{file_cols}
-00010c70: 2076 7320 7b67 6466 5f63 6f6c 737d 220d   vs {gdf_cols}".
-00010c80: 0a20 2020 2020 2020 2020 2020 2029 0d0a  .            )..
-00010c90: 0d0a 2020 2020 2320 5072 6570 6172 6520  ..    # Prepare 
-00010ca0: 6b77 6172 6773 2074 6f20 7573 6520 696e  kwargs to use in
-00010cb0: 2067 656f 7061 6e64 6173 2e74 6f5f 6669   geopandas.to_fi
-00010cc0: 6c65 0d0a 2020 2020 6966 2063 7265 6174  le..    if creat
-00010cd0: 655f 7370 6174 6961 6c5f 696e 6465 7820  e_spatial_index 
-00010ce0: 6973 206e 6f74 204e 6f6e 653a 0d0a 2020  is not None:..  
-00010cf0: 2020 2020 2020 6b77 6172 6773 5b22 5350        kwargs["SP
-00010d00: 4154 4941 4c5f 494e 4445 5822 5d20 3d20  ATIAL_INDEX"] = 
-00010d10: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-00010d20: 6e64 6578 0d0a 2020 2020 7061 7468 5f69  ndex..    path_i
-00010d30: 6e66 6f20 3d20 5f67 656f 6669 6c65 696e  nfo = _geofilein
-00010d40: 666f 2e67 6574 5f67 656f 6669 6c65 696e  fo.get_geofilein
-00010d50: 666f 2870 6174 6829 0d0a 2020 2020 6b77  fo(path)..    kw
-00010d60: 6172 6773 5b22 6472 6976 6572 225d 203d  args["driver"] =
-00010d70: 2070 6174 685f 696e 666f 2e64 7269 7665   path_info.drive
-00010d80: 720d 0a20 2020 206b 7761 7267 735b 2269  r..    kwargs["i
-00010d90: 6e64 6578 225d 203d 2069 6e64 6578 0d0a  ndex"] = index..
-00010da0: 2020 2020 6966 2063 7265 6174 655f 7370      if create_sp
-00010db0: 6174 6961 6c5f 696e 6465 7820 6973 206e  atial_index is n
-00010dc0: 6f74 204e 6f6e 653a 0d0a 2020 2020 2020  ot None:..      
-00010dd0: 2020 6b77 6172 6773 5b22 5350 4154 4941    kwargs["SPATIA
-00010de0: 4c5f 494e 4445 5822 5d20 3d20 6372 6561  L_INDEX"] = crea
-00010df0: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
-00010e00: 0d0a 2020 2020 6966 2066 6f72 6365 5f6f  ..    if force_o
-00010e10: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-00010e20: 7065 2069 7320 6e6f 7420 4e6f 6e65 3a0d  pe is not None:.
-00010e30: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
-00010e40: 7374 616e 6365 2866 6f72 6365 5f6f 7574  stance(force_out
-00010e50: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-00010e60: 2c20 4765 6f6d 6574 7279 5479 7065 293a  , GeometryType):
-00010e70: 0d0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
-00010e80: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-00010e90: 7472 7974 7970 6520 3d20 666f 7263 655f  trytype = force_
-00010ea0: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-00010eb0: 7970 652e 6e61 6d65 5f63 616d 656c 6361  ype.name_camelca
-00010ec0: 7365 0d0a 2020 2020 2020 2020 6b77 6172  se..        kwar
-00010ed0: 6773 5b22 6765 6f6d 6574 7279 5f74 7970  gs["geometry_typ
-00010ee0: 6522 5d20 3d20 666f 7263 655f 6f75 7470  e"] = force_outp
-00010ef0: 7574 5f67 656f 6d65 7472 7974 7970 650d  ut_geometrytype.
-00010f00: 0a20 2020 2069 6620 666f 7263 655f 6d75  .    if force_mu
-00010f10: 6c74 6974 7970 653a 0d0a 2020 2020 2020  ltitype:..      
-00010f20: 2020 6b77 6172 6773 5b22 7072 6f6d 6f74    kwargs["promot
-00010f30: 655f 746f 5f6d 756c 7469 225d 203d 2054  e_to_multi"] = T
-00010f40: 7275 650d 0a0d 0a20 2020 2023 2054 656d  rue....    # Tem
-00010f50: 7020 6669 7820 666f 7220 6275 6720 696e  p fix for bug in
-00010f60: 2070 796f 6772 696f 2030 2e37 2e32 2028   pyogrio 0.7.2 (
-00010f70: 6874 7470 733a 2f2f 6769 7468 7562 2e63  https://github.c
-00010f80: 6f6d 2f67 656f 7061 6e64 6173 2f70 796f  om/geopandas/pyo
-00010f90: 6772 696f 2f70 756c 6c2f 3332 3429 0d0a  grio/pull/324)..
-00010fa0: 2020 2020 2320 4c6f 6769 6320 6261 7365      # Logic base
-00010fb0: 6420 6f6e 2067 656f 7061 6e64 6173 2e74  d on geopandas.t
-00010fc0: 6f5f 6669 6c65 0d0a 2020 2020 6966 206c  o_file..    if l
-00010fd0: 6973 7428 6764 662e 696e 6465 782e 6e61  ist(gdf.index.na
-00010fe0: 6d65 7329 203d 3d20 5b4e 6f6e 655d 2061  mes) == [None] a
-00010ff0: 6e64 2069 735f 696e 7465 6765 725f 6474  nd is_integer_dt
-00011000: 7970 6528 6764 662e 696e 6465 782e 6474  ype(gdf.index.dt
-00011010: 7970 6529 3a0d 0a20 2020 2020 2020 2067  ype):..        g
-00011020: 6466 203d 2067 6466 2e72 6573 6574 5f69  df = gdf.reset_i
-00011030: 6e64 6578 2864 726f 703d 5472 7565 290d  ndex(drop=True).
-00011040: 0a0d 0a20 2020 2023 204e 6f77 2077 6520  ...    # Now we 
-00011050: 6361 6e20 7772 6974 650d 0a20 2020 2069  can write..    i
-00011060: 6620 7061 7468 5f69 6e66 6f2e 6973 5f73  f path_info.is_s
-00011070: 696e 676c 656c 6179 6572 3a0d 0a20 2020  inglelayer:..   
-00011080: 2020 2020 2067 6466 2e74 6f5f 6669 6c65       gdf.to_file
-00011090: 2873 7472 2870 6174 6829 2c20 2a2a 6b77  (str(path), **kw
-000110a0: 6172 6773 290d 0a20 2020 2065 6c73 653a  args)..    else:
-000110b0: 0d0a 2020 2020 2020 2020 6764 662e 746f  ..        gdf.to
-000110c0: 5f66 696c 6528 7374 7228 7061 7468 292c  _file(str(path),
-000110d0: 206c 6179 6572 3d6c 6179 6572 2c20 2a2a   layer=layer, **
-000110e0: 6b77 6172 6773 290d 0a0d 0a0d 0a64 6566  kwargs)......def
-000110f0: 2067 6574 5f63 7273 2870 6174 683a 2055   get_crs(path: U
-00011100: 6e69 6f6e 5b73 7472 2c20 226f 732e 5061  nion[str, "os.Pa
-00011110: 7468 4c69 6b65 5b41 6e79 5d22 5d29 202d  thLike[Any]"]) -
-00011120: 3e20 7079 7072 6f6a 2e43 5253 3a0d 0a20  > pyproj.CRS:.. 
-00011130: 2020 2022 2222 0d0a 2020 2020 4765 7420     """..    Get 
-00011140: 7468 6520 4352 5320 2870 726f 6a65 6374  the CRS (project
-00011150: 696f 6e29 206f 6620 7468 6520 6669 6c65  ion) of the file
-00011160: 2e0d 0a0d 0a20 2020 2041 7267 733a 0d0a  .....    Args:..
-00011170: 2020 2020 2020 2020 7061 7468 2028 5061          path (Pa
-00011180: 7468 4c69 6b65 293a 2050 6174 6820 746f  thLike): Path to
-00011190: 2074 6865 2066 696c 652e 0d0a 0d0a 2020   the file.....  
-000111a0: 2020 5265 7475 726e 733a 0d0a 2020 2020    Returns:..    
-000111b0: 2020 2020 7079 7072 6f6a 2e43 5253 3a20      pyproj.CRS: 
-000111c0: 5468 6520 7072 6f6a 6563 7469 6f6e 206f  The projection o
-000111d0: 6620 7468 6520 6669 6c65 0d0a 2020 2020  f the file..    
-000111e0: 2222 220d 0a20 2020 2023 2054 4f44 4f3a  """..    # TODO:
-000111f0: 2073 6565 6d73 206c 696b 6520 7375 7070   seems like supp
-00011200: 6f72 7420 666f 7220 6d75 6c74 6970 6c65  ort for multiple
-00011210: 206c 6179 6572 7320 696e 2074 6865 2066   layers in the f
-00011220: 696c 6520 6973 6e27 7420 6865 7265 2079  ile isn't here y
-00011230: 6574 3f3f 3f0d 0a20 2020 2077 6974 6820  et???..    with 
-00011240: 6669 6f6e 612e 6f70 656e 2873 7472 2870  fiona.open(str(p
-00011250: 6174 6829 2c20 2272 2229 2061 7320 6765  ath), "r") as ge
-00011260: 6f66 696c 653a 0d0a 2020 2020 2020 2020  ofile:..        
-00011270: 6173 7365 7274 2067 656f 6669 6c65 2069  assert geofile i
-00011280: 7320 6e6f 7420 4e6f 6e65 0d0a 2020 2020  s not None..    
-00011290: 2020 2020 7265 7475 726e 2070 7970 726f      return pypro
-000112a0: 6a2e 4352 5328 6765 6f66 696c 652e 6372  j.CRS(geofile.cr
-000112b0: 7329 0d0a 0d0a 0d0a 6465 6620 6973 5f67  s)......def is_g
-000112c0: 656f 6669 6c65 2870 6174 683a 2055 6e69  eofile(path: Uni
-000112d0: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
-000112e0: 4c69 6b65 5b41 6e79 5d22 5d29 202d 3e20  Like[Any]"]) -> 
-000112f0: 626f 6f6c 3a0d 0a20 2020 2022 2222 0d0a  bool:..    """..
-00011300: 2020 2020 4465 7465 726d 696e 6573 2062      Determines b
-00011310: 6173 6564 206f 6e20 7468 6520 6669 6c65  ased on the file
-00011320: 7061 7468 2069 6620 7468 6973 2069 7320  path if this is 
-00011330: 6120 6765 6f66 696c 652e 0d0a 0d0a 2020  a geofile.....  
-00011340: 2020 4445 5052 4543 4154 4544 2e0d 0a0d    DEPRECATED....
-00011350: 0a20 2020 2041 7267 733a 0d0a 2020 2020  .    Args:..    
-00011360: 2020 2020 7061 7468 2028 5061 7468 4c69      path (PathLi
-00011370: 6b65 293a 2054 6865 2066 696c 6520 7061  ke): The file pa
-00011380: 7468 2e0d 0a0d 0a20 2020 2052 6574 7572  th.....    Retur
-00011390: 6e73 3a0d 0a20 2020 2020 2020 2062 6f6f  ns:..        boo
-000113a0: 6c3a 2054 7275 6520 6966 2069 7420 6973  l: True if it is
-000113b0: 2061 2067 656f 2066 696c 652e 0d0a 2020   a geo file...  
-000113c0: 2020 2222 220d 0a20 2020 2077 6172 6e69    """..    warni
-000113d0: 6e67 732e 7761 726e 280d 0a20 2020 2020  ngs.warn(..     
-000113e0: 2020 2022 6973 5f67 656f 6669 6c65 2069     "is_geofile i
-000113f0: 7320 6465 7072 6563 6174 6564 2061 6e64  s deprecated and
-00011400: 2077 696c 6c20 6265 2072 656d 6f76 6564   will be removed
-00011410: 2069 6e20 6120 6675 7475 7265 2076 6572   in a future ver
-00011420: 7369 6f6e 222c 0d0a 2020 2020 2020 2020  sion",..        
-00011430: 4675 7475 7265 5761 726e 696e 672c 0d0a  FutureWarning,..
-00011440: 2020 2020 2020 2020 7374 6163 6b6c 6576          stacklev
-00011450: 656c 3d32 2c0d 0a20 2020 2029 0d0a 2020  el=2,..    )..  
-00011460: 2020 7265 7475 726e 2069 735f 6765 6f66    return is_geof
-00011470: 696c 655f 6578 7428 5061 7468 2870 6174  ile_ext(Path(pat
-00011480: 6829 2e73 7566 6669 7829 0d0a 0d0a 0d0a  h).suffix)......
-00011490: 6465 6620 6973 5f67 656f 6669 6c65 5f65  def is_geofile_e
-000114a0: 7874 2866 696c 655f 6578 743a 2073 7472  xt(file_ext: str
-000114b0: 2920 2d3e 2062 6f6f 6c3a 0d0a 2020 2020  ) -> bool:..    
-000114c0: 2222 220d 0a20 2020 2044 6574 6572 6d69  """..    Determi
-000114d0: 6e65 7320 6261 7365 6420 6f6e 2074 6865  nes based on the
-000114e0: 2066 696c 6520 6578 7465 6e73 696f 6e20   file extension 
-000114f0: 6966 2074 6869 7320 6973 2061 2067 656f  if this is a geo
-00011500: 6669 6c65 2e0d 0a0d 0a20 2020 2044 4550  file.....    DEP
-00011510: 5245 4341 5445 442e 0d0a 0d0a 2020 2020  RECATED.....    
-00011520: 4172 6773 3a0d 0a20 2020 2020 2020 2066  Args:..        f
-00011530: 696c 655f 6578 7420 2873 7472 293a 2074  ile_ext (str): t
-00011540: 6865 2065 7874 656e 7369 6f6e 2e0d 0a0d  he extension....
-00011550: 0a20 2020 2052 6574 7572 6e73 3a0d 0a20  .    Returns:.. 
-00011560: 2020 2020 2020 2062 6f6f 6c3a 2054 7275         bool: Tru
-00011570: 6520 6966 2069 7420 6973 2061 2067 656f  e if it is a geo
-00011580: 6669 6c65 2e0d 0a20 2020 2022 2222 0d0a  file...    """..
-00011590: 2020 2020 7761 726e 696e 6773 2e77 6172      warnings.war
-000115a0: 6e28 0d0a 2020 2020 2020 2020 2269 735f  n(..        "is_
-000115b0: 6765 6f66 696c 655f 6578 7420 6973 2064  geofile_ext is d
-000115c0: 6570 7265 6361 7465 6420 616e 6420 7769  eprecated and wi
-000115d0: 6c6c 2062 6520 7265 6d6f 7665 6420 696e  ll be removed in
-000115e0: 2061 2066 7574 7572 6520 7665 7273 696f   a future versio
-000115f0: 6e22 2c0d 0a20 2020 2020 2020 2046 7574  n",..        Fut
-00011600: 7572 6557 6172 6e69 6e67 2c0d 0a20 2020  ureWarning,..   
-00011610: 2020 2020 2073 7461 636b 6c65 7665 6c3d       stacklevel=
-00011620: 322c 0d0a 2020 2020 290d 0a20 2020 2074  2,..    )..    t
-00011630: 7279 3a0d 0a20 2020 2020 2020 2023 2049  ry:..        # I
-00011640: 6620 7468 6520 6472 6976 6572 2063 616e  f the driver can
-00011650: 2062 6520 6465 7465 726d 696e 6564 2c20   be determined, 
-00011660: 6974 2069 7320 6120 2873 7570 706f 7274  it is a (support
-00011670: 6564 2920 6765 6f20 6669 6c65 2e0d 0a20  ed) geo file... 
-00011680: 2020 2020 2020 205f 203d 205f 6765 6f66         _ = _geof
-00011690: 696c 6569 6e66 6f2e 4765 6f66 696c 6554  ileinfo.GeofileT
-000116a0: 7970 6528 6669 6c65 5f65 7874 290d 0a20  ype(file_ext).. 
-000116b0: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
-000116c0: 7565 0d0a 2020 2020 6578 6365 7074 2045  ue..    except E
-000116d0: 7863 6570 7469 6f6e 3a0d 0a20 2020 2020  xception:..     
-000116e0: 2020 2072 6574 7572 6e20 4661 6c73 650d     return False.
-000116f0: 0a0d 0a0d 0a64 6566 2063 6d70 280d 0a20  .....def cmp(.. 
-00011700: 2020 2070 6174 6831 3a20 556e 696f 6e5b     path1: Union[
-00011710: 7374 722c 2022 6f73 2e50 6174 684c 696b  str, "os.PathLik
-00011720: 655b 416e 795d 225d 2c20 7061 7468 323a  e[Any]"], path2:
-00011730: 2055 6e69 6f6e 5b73 7472 2c20 226f 732e   Union[str, "os.
-00011740: 5061 7468 4c69 6b65 5b41 6e79 5d22 5d0d  PathLike[Any]"].
-00011750: 0a29 202d 3e20 626f 6f6c 3a0d 0a20 2020  .) -> bool:..   
-00011760: 2022 2222 0d0a 2020 2020 436f 6d70 6172   """..    Compar
-00011770: 6520 6966 2074 776f 2067 656f 6669 6c65  e if two geofile
-00011780: 7320 6172 6520 6964 656e 7469 6361 6c2e  s are identical.
-00011790: 0d0a 0d0a 2020 2020 466f 7220 6765 6f66  ....    For geof
-000117a0: 696c 6573 2074 6861 7420 7573 6520 6d75  iles that use mu
-000117b0: 6c74 6970 6c65 2066 696c 6573 2c20 616c  ltiple files, al
-000117c0: 6c20 7265 6c65 7661 6e74 2066 696c 6573  l relevant files
-000117d0: 206d 7573 7420 6265 2069 6465 6e74 6963   must be identic
-000117e0: 616c 2e0d 0a20 2020 2045 672e 2066 6f72  al...    Eg. for
-000117f0: 2073 6861 7065 6669 6c65 732c 2074 6865   shapefiles, the
-00011800: 202e 7368 702c 202e 7368 7820 616e 6420   .shp, .shx and 
-00011810: 2e64 6266 2066 696c 6520 6d75 7374 2062  .dbf file must b
-00011820: 6520 6964 656e 7469 6361 6c2e 0d0a 0d0a  e identical.....
-00011830: 2020 2020 4172 6773 3a0d 0a20 2020 2020      Args:..     
-00011840: 2020 2070 6174 6831 2028 5061 7468 4c69     path1 (PathLi
-00011850: 6b65 293a 2070 6174 6820 746f 2074 6865  ke): path to the
-00011860: 2066 6972 7374 2066 696c 652e 0d0a 2020   first file...  
-00011870: 2020 2020 2020 7061 7468 3220 2850 6174        path2 (Pat
-00011880: 684c 696b 6529 3a20 7061 7468 2074 6f20  hLike): path to 
-00011890: 7468 6520 7365 636f 6e64 2066 696c 652e  the second file.
-000118a0: 0d0a 0d0a 2020 2020 5265 7475 726e 733a  ....    Returns:
-000118b0: 0d0a 2020 2020 2020 2020 626f 6f6c 3a20  ..        bool: 
-000118c0: 5472 7565 2069 6620 7468 6520 6669 6c65  True if the file
-000118d0: 7320 6172 6520 6964 656e 7469 6361 6c0d  s are identical.
-000118e0: 0a20 2020 2022 2222 0d0a 2020 2020 2320  .    """..    # 
-000118f0: 4368 6563 6b20 696e 7075 7420 7061 7261  Check input para
-00011900: 6d65 7465 7273 0d0a 2020 2020 7061 7468  meters..    path
-00011910: 3120 3d20 5061 7468 2870 6174 6831 290d  1 = Path(path1).
-00011920: 0a20 2020 2070 6174 6832 203d 2050 6174  .    path2 = Pat
-00011930: 6828 7061 7468 3229 0d0a 0d0a 2020 2020  h(path2)....    
-00011940: 2320 466f 7220 6120 7368 6170 6566 696c  # For a shapefil
-00011950: 652c 206d 756c 7469 706c 6520 6669 6c65  e, multiple file
-00011960: 7320 6e65 6564 2074 6f20 6265 2063 6f6d  s need to be com
-00011970: 7061 7265 640d 0a20 2020 2069 6620 7061  pared..    if pa
-00011980: 7468 312e 7375 6666 6978 2e6c 6f77 6572  th1.suffix.lower
-00011990: 2829 203d 3d20 222e 7368 7022 3a0d 0a20  () == ".shp":.. 
-000119a0: 2020 2020 2020 2073 6861 7065 6669 6c65         shapefile
-000119b0: 5f62 6173 655f 7375 6666 6978 6573 203d  _base_suffixes =
-000119c0: 205b 222e 7368 7022 2c20 222e 6462 6622   [".shp", ".dbf"
-000119d0: 2c20 222e 7368 7822 5d0d 0a20 2020 2020  , ".shx"]..     
-000119e0: 2020 2066 6f72 2073 7566 6669 7820 696e     for suffix in
-000119f0: 2073 6861 7065 6669 6c65 5f62 6173 655f   shapefile_base_
-00011a00: 7375 6666 6978 6573 3a0d 0a20 2020 2020  suffixes:..     
-00011a10: 2020 2020 2020 2069 6620 6e6f 7420 6669         if not fi
-00011a20: 6c65 636d 702e 636d 7028 7061 7468 312e  lecmp.cmp(path1.
-00011a30: 7769 7468 5f73 7566 6669 7828 7375 6666  with_suffix(suff
-00011a40: 6978 292c 2070 6174 6832 2e77 6974 685f  ix), path2.with_
-00011a50: 7375 6666 6978 2873 7566 6669 7829 293a  suffix(suffix)):
-00011a60: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00011a70: 2020 6c6f 6767 6572 2e69 6e66 6f28 0d0a    logger.info(..
-00011a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011a90: 2020 2020 6622 4669 6c65 207b 7061 7468      f"File {path
-00011aa0: 312e 7769 7468 5f73 7566 6669 7828 7375  1.with_suffix(su
-00011ab0: 6666 6978 297d 2069 7320 6469 6666 6572  ffix)} is differ
-00011ac0: 656e 7420 6672 6f6d 2022 0d0a 2020 2020  ent from "..    
-00011ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011ae0: 6622 7b70 6174 6832 2e77 6974 685f 7375  f"{path2.with_su
-00011af0: 6666 6978 2873 7566 6669 7829 7d22 0d0a  ffix(suffix)}"..
-00011b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b10: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-00011b20: 2020 2072 6574 7572 6e20 4661 6c73 650d     return False.
-00011b30: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00011b40: 5472 7565 0d0a 2020 2020 656c 7365 3a0d  True..    else:.
-00011b50: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00011b60: 6669 6c65 636d 702e 636d 7028 7374 7228  filecmp.cmp(str(
-00011b70: 7061 7468 3129 2c20 7374 7228 7061 7468  path1), str(path
-00011b80: 3229 290d 0a0d 0a0d 0a64 6566 2063 6f70  2))......def cop
-00011b90: 7928 7372 633a 2055 6e69 6f6e 5b73 7472  y(src: Union[str
-00011ba0: 2c20 226f 732e 5061 7468 4c69 6b65 5b41  , "os.PathLike[A
-00011bb0: 6e79 5d22 5d2c 2064 7374 3a20 556e 696f  ny]"], dst: Unio
-00011bc0: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
-00011bd0: 696b 655b 416e 795d 225d 293a 0d0a 2020  ike[Any]"]):..  
-00011be0: 2020 2222 220d 0a20 2020 2043 6f70 6965    """..    Copie
-00011bf0: 7320 7468 6520 6765 6f66 696c 6520 6672  s the geofile fr
-00011c00: 6f6d 2073 7263 2074 6f20 6473 742e 0d0a  om src to dst...
-00011c10: 0d0a 2020 2020 4966 2074 6865 2073 6f75  ..    If the sou
-00011c20: 7263 6520 6669 6c65 2069 7320 6120 6765  rce file is a ge
-00011c30: 6f66 696c 6520 636f 6e74 6169 6e69 6e67  ofile containing
-00011c40: 206f 6620 6d75 6c74 6970 6c65 2066 696c   of multiple fil
-00011c50: 6573 2028 6567 2e20 2e73 6870 2920 616c  es (eg. .shp) al
-00011c60: 6c20 6669 6c65 730d 0a20 2020 2061 7265  l files..    are
-00011c70: 2063 6f70 6965 642e 0d0a 0d0a 2020 2020   copied.....    
-00011c80: 4172 6773 3a0d 0a20 2020 2020 2020 2073  Args:..        s
-00011c90: 7263 2028 5061 7468 4c69 6b65 293a 2074  rc (PathLike): t
-00011ca0: 6865 2066 696c 6520 746f 2063 6f70 792e  he file to copy.
-00011cb0: 0d0a 2020 2020 2020 2020 6473 7420 2850  ..        dst (P
-00011cc0: 6174 684c 696b 6529 3a20 7468 6520 6c6f  athLike): the lo
-00011cd0: 6361 7469 6f6e 2074 6f20 636f 7079 2074  cation to copy t
-00011ce0: 6865 2066 696c 6528 7329 2074 6f2e 0d0a  he file(s) to...
-00011cf0: 2020 2020 2222 220d 0a20 2020 2023 2043      """..    # C
-00011d00: 6865 636b 2069 6e70 7574 2070 6172 616d  heck input param
-00011d10: 6574 6572 730d 0a20 2020 2073 7263 203d  eters..    src =
-00011d20: 2050 6174 6828 7372 6329 0d0a 2020 2020   Path(src)..    
-00011d30: 6473 7420 3d20 5061 7468 2864 7374 290d  dst = Path(dst).
-00011d40: 0a20 2020 2073 7263 5f69 6e66 6f20 3d20  .    src_info = 
-00011d50: 5f67 656f 6669 6c65 696e 666f 2e67 6574  _geofileinfo.get
-00011d60: 5f67 656f 6669 6c65 696e 666f 2873 7263  _geofileinfo(src
-00011d70: 290d 0a0d 0a20 2020 2023 2043 6f70 7920  )....    # Copy 
-00011d80: 7468 6520 6d61 696e 2066 696c 650d 0a20  the main file.. 
-00011d90: 2020 2073 6875 7469 6c2e 636f 7079 2873     shutil.copy(s
-00011da0: 7472 2873 7263 292c 2064 7374 290d 0a0d  tr(src), dst)...
-00011db0: 0a20 2020 2023 2046 6f72 2073 6f6d 6520  .    # For some 
-00011dc0: 6669 6c65 2074 7970 6573 2c20 6578 7472  file types, extr
-00011dd0: 6120 6669 6c65 7320 6e65 6564 2074 6f20  a files need to 
-00011de0: 6265 2063 6f70 6965 640d 0a20 2020 2023  be copied..    #
-00011df0: 2049 6620 6465 7374 2069 7320 6120 6469   If dest is a di
-00011e00: 722c 206a 7573 7420 7573 6520 6d6f 7665  r, just use move
-00011e10: 2e20 4f74 6865 7277 6973 6520 636f 6e63  . Otherwise conc
-00011e20: 6174 2064 6573 7420 6669 6c65 7061 7468  at dest filepath
-00011e30: 730d 0a20 2020 2069 6620 7372 635f 696e  s..    if src_in
-00011e40: 666f 2e73 7566 6669 7865 735f 6578 7472  fo.suffixes_extr
-00011e50: 6166 696c 6573 2069 7320 6e6f 7420 4e6f  afiles is not No
-00011e60: 6e65 3a0d 0a20 2020 2020 2020 2069 6620  ne:..        if 
-00011e70: 6473 742e 6973 5f64 6972 2829 3a0d 0a20  dst.is_dir():.. 
-00011e80: 2020 2020 2020 2020 2020 2066 6f72 2073             for s
-00011e90: 7566 6669 7820 696e 2073 7263 5f69 6e66  uffix in src_inf
-00011ea0: 6f2e 7375 6666 6978 6573 5f65 7874 7261  o.suffixes_extra
-00011eb0: 6669 6c65 733a 0d0a 2020 2020 2020 2020  files:..        
-00011ec0: 2020 2020 2020 2020 7372 6366 696c 6520          srcfile 
-00011ed0: 3d20 7372 632e 7061 7265 6e74 202f 2066  = src.parent / f
-00011ee0: 227b 7372 632e 7374 656d 7d7b 7375 6666  "{src.stem}{suff
-00011ef0: 6978 7d22 0d0a 2020 2020 2020 2020 2020  ix}"..          
-00011f00: 2020 2020 2020 6966 2073 7263 6669 6c65        if srcfile
-00011f10: 2e65 7869 7374 7328 293a 0d0a 2020 2020  .exists():..    
-00011f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011f30: 7368 7574 696c 2e63 6f70 7928 7374 7228  shutil.copy(str(
-00011f40: 7372 6366 696c 6529 2c20 6473 7429 0d0a  srcfile), dst)..
-00011f50: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-00011f60: 2020 2020 2020 2020 2020 2066 6f72 2073             for s
-00011f70: 7566 6669 7820 696e 2073 7263 5f69 6e66  uffix in src_inf
-00011f80: 6f2e 7375 6666 6978 6573 5f65 7874 7261  o.suffixes_extra
-00011f90: 6669 6c65 733a 0d0a 2020 2020 2020 2020  files:..        
-00011fa0: 2020 2020 2020 2020 7372 6366 696c 6520          srcfile 
-00011fb0: 3d20 7372 632e 7061 7265 6e74 202f 2066  = src.parent / f
-00011fc0: 227b 7372 632e 7374 656d 7d7b 7375 6666  "{src.stem}{suff
-00011fd0: 6978 7d22 0d0a 2020 2020 2020 2020 2020  ix}"..          
-00011fe0: 2020 2020 2020 6473 7466 696c 6520 3d20        dstfile = 
-00011ff0: 6473 742e 7061 7265 6e74 202f 2066 227b  dst.parent / f"{
-00012000: 6473 742e 7374 656d 7d7b 7375 6666 6978  dst.stem}{suffix
-00012010: 7d22 0d0a 2020 2020 2020 2020 2020 2020  }"..            
-00012020: 2020 2020 6966 2073 7263 6669 6c65 2e65      if srcfile.e
-00012030: 7869 7374 7328 293a 0d0a 2020 2020 2020  xists():..      
-00012040: 2020 2020 2020 2020 2020 2020 2020 7368                sh
-00012050: 7574 696c 2e63 6f70 7928 7374 7228 7372  util.copy(str(sr
-00012060: 6366 696c 6529 2c20 6473 7466 696c 6529  cfile), dstfile)
-00012070: 0d0a 0d0a 0d0a 6465 6620 6d6f 7665 2873  ......def move(s
-00012080: 7263 3a20 556e 696f 6e5b 7374 722c 2022  rc: Union[str, "
-00012090: 6f73 2e50 6174 684c 696b 655b 416e 795d  os.PathLike[Any]
-000120a0: 225d 2c20 6473 743a 2055 6e69 6f6e 5b73  "], dst: Union[s
-000120b0: 7472 2c20 226f 732e 5061 7468 4c69 6b65  tr, "os.PathLike
-000120c0: 5b41 6e79 5d22 5d29 3a0d 0a20 2020 2022  [Any]"]):..    "
-000120d0: 2222 0d0a 2020 2020 4d6f 7665 7320 7468  ""..    Moves th
-000120e0: 6520 6765 6f66 696c 6520 6672 6f6d 2073  e geofile from s
-000120f0: 7263 2074 6f20 6473 742e 0d0a 0d0a 2020  rc to dst.....  
-00012100: 2020 4966 2074 6865 2073 6f75 7263 6520    If the source 
-00012110: 6669 6c65 2069 7320 6120 6765 6f66 696c  file is a geofil
-00012120: 6520 636f 6e74 6169 6e69 6e67 206f 6620  e containing of 
-00012130: 6d75 6c74 6970 6c65 2066 696c 6573 2028  multiple files (
-00012140: 6567 2e20 2e73 6870 2920 616c 6c20 6669  eg. .shp) all fi
-00012150: 6c65 730d 0a20 2020 2061 7265 206d 6f76  les..    are mov
-00012160: 6564 2e0d 0a0d 0a20 2020 2041 7267 733a  ed.....    Args:
-00012170: 0d0a 2020 2020 2020 2020 7372 6320 2850  ..        src (P
-00012180: 6174 684c 696b 6529 3a20 7468 6520 6669  athLike): the fi
-00012190: 6c65 2074 6f20 6d6f 7665 0d0a 2020 2020  le to move..    
-000121a0: 2020 2020 6473 7420 2850 6174 684c 696b      dst (PathLik
-000121b0: 6529 3a20 7468 6520 6c6f 6361 7469 6f6e  e): the location
-000121c0: 2074 6f20 6d6f 7665 2074 6865 2066 696c   to move the fil
-000121d0: 6528 7329 2074 6f0d 0a20 2020 2022 2222  e(s) to..    """
-000121e0: 0d0a 2020 2020 2320 4368 6563 6b20 696e  ..    # Check in
-000121f0: 7075 7420 7061 7261 6d65 7465 7273 0d0a  put parameters..
-00012200: 2020 2020 7372 6320 3d20 5061 7468 2873      src = Path(s
-00012210: 7263 290d 0a20 2020 2064 7374 203d 2050  rc)..    dst = P
-00012220: 6174 6828 6473 7429 0d0a 2020 2020 7372  ath(dst)..    sr
-00012230: 635f 696e 666f 203d 205f 6765 6f66 696c  c_info = _geofil
-00012240: 6569 6e66 6f2e 6765 745f 6765 6f66 696c  einfo.get_geofil
-00012250: 6569 6e66 6f28 7372 6329 0d0a 0d0a 2020  einfo(src)....  
-00012260: 2020 2320 4d6f 7665 2074 6865 206d 6169    # Move the mai
-00012270: 6e20 6669 6c65 0d0a 2020 2020 7368 7574  n file..    shut
-00012280: 696c 2e6d 6f76 6528 7374 7228 7372 6329  il.move(str(src)
-00012290: 2c20 6473 7429 0d0a 0d0a 2020 2020 2320  , dst)....    # 
-000122a0: 466f 7220 736f 6d65 2066 696c 6520 7479  For some file ty
-000122b0: 7065 732c 2065 7874 7261 2066 696c 6573  pes, extra files
-000122c0: 206e 6565 6420 746f 2062 6520 6d6f 7665   need to be move
-000122d0: 640d 0a20 2020 2023 2049 6620 6465 7374  d..    # If dest
-000122e0: 2069 7320 6120 6469 722c 206a 7573 7420   is a dir, just 
-000122f0: 7573 6520 6d6f 7665 2e20 4f74 6865 7277  use move. Otherw
-00012300: 6973 6520 636f 6e63 6174 2064 6573 7420  ise concat dest 
-00012310: 6669 6c65 7061 7468 730d 0a20 2020 2069  filepaths..    i
-00012320: 6620 7372 635f 696e 666f 2e73 7566 6669  f src_info.suffi
-00012330: 7865 735f 6578 7472 6166 696c 6573 2069  xes_extrafiles i
-00012340: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
-00012350: 2020 2020 2069 6620 6473 742e 6973 5f64       if dst.is_d
-00012360: 6972 2829 3a0d 0a20 2020 2020 2020 2020  ir():..         
-00012370: 2020 2066 6f72 2073 7566 6669 7820 696e     for suffix in
-00012380: 2073 7263 5f69 6e66 6f2e 7375 6666 6978   src_info.suffix
-00012390: 6573 5f65 7874 7261 6669 6c65 733a 0d0a  es_extrafiles:..
-000123a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000123b0: 7372 6366 696c 6520 3d20 7372 632e 7061  srcfile = src.pa
-000123c0: 7265 6e74 202f 2066 227b 7372 632e 7374  rent / f"{src.st
-000123d0: 656d 7d7b 7375 6666 6978 7d22 0d0a 2020  em}{suffix}"..  
-000123e0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-000123f0: 2073 7263 6669 6c65 2e65 7869 7374 7328   srcfile.exists(
-00012400: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-00012410: 2020 2020 2020 2020 7368 7574 696c 2e6d          shutil.m
-00012420: 6f76 6528 7374 7228 7372 6366 696c 6529  ove(str(srcfile)
-00012430: 2c20 6473 7429 0d0a 2020 2020 2020 2020  , dst)..        
-00012440: 656c 7365 3a0d 0a20 2020 2020 2020 2020  else:..         
-00012450: 2020 2066 6f72 2073 7566 6669 7820 696e     for suffix in
-00012460: 2073 7263 5f69 6e66 6f2e 7375 6666 6978   src_info.suffix
-00012470: 6573 5f65 7874 7261 6669 6c65 733a 0d0a  es_extrafiles:..
-00012480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012490: 7372 6366 696c 6520 3d20 7372 632e 7061  srcfile = src.pa
-000124a0: 7265 6e74 202f 2066 227b 7372 632e 7374  rent / f"{src.st
-000124b0: 656d 7d7b 7375 6666 6978 7d22 0d0a 2020  em}{suffix}"..  
-000124c0: 2020 2020 2020 2020 2020 2020 2020 6473                ds
-000124d0: 7466 696c 6520 3d20 6473 742e 7061 7265  tfile = dst.pare
-000124e0: 6e74 202f 2066 227b 6473 742e 7374 656d  nt / f"{dst.stem
-000124f0: 7d7b 7375 6666 6978 7d22 0d0a 2020 2020  }{suffix}"..    
-00012500: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-00012510: 7263 6669 6c65 2e65 7869 7374 7328 293a  rcfile.exists():
-00012520: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00012530: 2020 2020 2020 7368 7574 696c 2e6d 6f76        shutil.mov
-00012540: 6528 7374 7228 7372 6366 696c 6529 2c20  e(str(srcfile), 
-00012550: 6473 7466 696c 6529 0d0a 0d0a 0d0a 6465  dstfile)......de
-00012560: 6620 7265 6d6f 7665 2870 6174 683a 2055  f remove(path: U
-00012570: 6e69 6f6e 5b73 7472 2c20 226f 732e 5061  nion[str, "os.Pa
-00012580: 7468 4c69 6b65 5b41 6e79 5d22 5d2c 206d  thLike[Any]"], m
-00012590: 6973 7369 6e67 5f6f 6b3a 2062 6f6f 6c20  issing_ok: bool 
-000125a0: 3d20 4661 6c73 6529 3a0d 0a20 2020 2022  = False):..    "
-000125b0: 2222 0d0a 2020 2020 5265 6d6f 7665 7320  ""..    Removes 
-000125c0: 7468 6520 6765 6f66 696c 652e 0d0a 0d0a  the geofile.....
-000125d0: 2020 2020 4973 2069 7420 6973 2061 2067      Is it is a g
-000125e0: 656f 6669 6c65 2063 6f6d 706f 7365 6420  eofile composed 
-000125f0: 6f66 206d 756c 7469 706c 6520 6669 6c65  of multiple file
-00012600: 7320 2865 672e 202e 7368 7029 2061 6c6c  s (eg. .shp) all
-00012610: 2066 696c 6573 2061 7265 2072 656d 6f76   files are remov
-00012620: 6564 2e0d 0a20 2020 2049 6620 2e6c 6f63  ed...    If .loc
-00012630: 6b20 6669 6c65 7320 6172 6520 7072 6573  k files are pres
-00012640: 656e 742c 2074 6865 7920 6172 6520 7265  ent, they are re
-00012650: 6d6f 7665 6420 6173 2077 656c 6c2e 0d0a  moved as well...
-00012660: 0d0a 2020 2020 4172 6773 3a0d 0a20 2020  ..    Args:..   
-00012670: 2020 2020 2070 6174 6820 2850 6174 684c       path (PathL
-00012680: 696b 6529 3a20 7468 6520 6669 6c65 2074  ike): the file t
-00012690: 6f20 7265 6d6f 7665 0d0a 2020 2020 2020  o remove..      
-000126a0: 2020 6d69 7373 696e 675f 6f6b 2028 626f    missing_ok (bo
-000126b0: 6f6c 2c20 6f70 7469 6f6e 616c 293a 2054  ol, optional): T
-000126c0: 7275 6520 6e6f 7420 746f 2067 6976 6520  rue not to give 
-000126d0: 616e 2065 7272 6f72 2069 6620 7468 6520  an error if the 
-000126e0: 6669 6c65 2074 6f20 6265 2072 656d 6f76  file to be remov
-000126f0: 6564 0d0a 2020 2020 2020 2020 2020 2020  ed..            
-00012700: 646f 6573 6e27 7420 6578 6973 742e 2044  doesn't exist. D
-00012710: 6566 6175 6c74 7320 746f 2046 616c 7365  efaults to False
-00012720: 2e0d 0a20 2020 2022 2222 0d0a 2020 2020  ...    """..    
-00012730: 2320 4368 6563 6b20 696e 7075 7420 7061  # Check input pa
-00012740: 7261 6d65 7465 7273 0d0a 2020 2020 7061  rameters..    pa
-00012750: 7468 203d 2050 6174 6828 7061 7468 290d  th = Path(path).
-00012760: 0a20 2020 2070 6174 685f 696e 666f 203d  .    path_info =
-00012770: 205f 6765 6f66 696c 6569 6e66 6f2e 6765   _geofileinfo.ge
-00012780: 745f 6765 6f66 696c 6569 6e66 6f28 7061  t_geofileinfo(pa
-00012790: 7468 290d 0a0d 0a20 2020 2023 2049 6620  th)....    # If 
-000127a0: 7468 6572 6520 6973 2061 206c 6f63 6b20  there is a lock 
-000127b0: 6669 6c65 2c20 7265 6d6f 7665 2069 740d  file, remove it.
-000127c0: 0a20 2020 206c 6f63 6b66 696c 655f 7061  .    lockfile_pa
-000127d0: 7468 203d 2070 6174 682e 7061 7265 6e74  th = path.parent
-000127e0: 202f 2066 227b 7061 7468 2e6e 616d 657d   / f"{path.name}
-000127f0: 2e6c 6f63 6b22 0d0a 2020 2020 6c6f 636b  .lock"..    lock
-00012800: 6669 6c65 5f70 6174 682e 756e 6c69 6e6b  file_path.unlink
-00012810: 286d 6973 7369 6e67 5f6f 6b3d 5472 7565  (missing_ok=True
-00012820: 290d 0a0d 0a20 2020 2023 2052 656d 6f76  )....    # Remov
-00012830: 6520 7468 6520 6d61 696e 2066 696c 650d  e the main file.
-00012840: 0a20 2020 2069 6620 7061 7468 2e65 7869  .    if path.exi
-00012850: 7374 7328 293a 0d0a 2020 2020 2020 2020  sts():..        
-00012860: 7061 7468 2e75 6e6c 696e 6b28 6d69 7373  path.unlink(miss
-00012870: 696e 675f 6f6b 3d6d 6973 7369 6e67 5f6f  ing_ok=missing_o
-00012880: 6b29 0d0a 0d0a 2020 2020 2320 466f 7220  k)....    # For 
-00012890: 736f 6d65 2066 696c 6520 7479 7065 732c  some file types,
-000128a0: 2065 7874 7261 2066 696c 6573 206e 6565   extra files nee
-000128b0: 6420 746f 2062 6520 7265 6d6f 7665 640d  d to be removed.
-000128c0: 0a20 2020 2069 6620 7061 7468 5f69 6e66  .    if path_inf
-000128d0: 6f2e 7375 6666 6978 6573 5f65 7874 7261  o.suffixes_extra
-000128e0: 6669 6c65 7320 6973 206e 6f74 204e 6f6e  files is not Non
-000128f0: 653a 0d0a 2020 2020 2020 2020 666f 7220  e:..        for 
-00012900: 7375 6666 6978 2069 6e20 7061 7468 5f69  suffix in path_i
-00012910: 6e66 6f2e 7375 6666 6978 6573 5f65 7874  nfo.suffixes_ext
-00012920: 7261 6669 6c65 733a 0d0a 2020 2020 2020  rafiles:..      
-00012930: 2020 2020 2020 6375 7272 5f70 6174 6820        curr_path 
-00012940: 3d20 7061 7468 2e70 6172 656e 7420 2f20  = path.parent / 
-00012950: 6622 7b70 6174 682e 7374 656d 7d7b 7375  f"{path.stem}{su
-00012960: 6666 6978 7d22 0d0a 2020 2020 2020 2020  ffix}"..        
-00012970: 2020 2020 6375 7272 5f70 6174 682e 756e      curr_path.un
-00012980: 6c69 6e6b 286d 6973 7369 6e67 5f6f 6b3d  link(missing_ok=
-00012990: 5472 7565 290d 0a0d 0a0d 0a64 6566 2061  True)......def a
-000129a0: 7070 656e 645f 746f 280d 0a20 2020 2073  ppend_to(..    s
-000129b0: 7263 3a20 556e 696f 6e5b 7374 722c 2022  rc: Union[str, "
-000129c0: 6f73 2e50 6174 684c 696b 655b 416e 795d  os.PathLike[Any]
-000129d0: 225d 2c0d 0a20 2020 2064 7374 3a20 556e  "],..    dst: Un
-000129e0: 696f 6e5b 7374 722c 2022 6f73 2e50 6174  ion[str, "os.Pat
-000129f0: 684c 696b 655b 416e 795d 225d 2c0d 0a20  hLike[Any]"],.. 
-00012a00: 2020 2073 7263 5f6c 6179 6572 3a20 4f70     src_layer: Op
-00012a10: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
-00012a20: 6e65 2c0d 0a20 2020 2064 7374 5f6c 6179  ne,..    dst_lay
-00012a30: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
-00012a40: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2073  ] = None,..    s
-00012a50: 7263 5f63 7273 3a20 556e 696f 6e5b 696e  rc_crs: Union[in
-00012a60: 742c 2073 7472 2c20 4e6f 6e65 5d20 3d20  t, str, None] = 
-00012a70: 4e6f 6e65 2c0d 0a20 2020 2064 7374 5f63  None,..    dst_c
-00012a80: 7273 3a20 556e 696f 6e5b 696e 742c 2073  rs: Union[int, s
-00012a90: 7472 2c20 4e6f 6e65 5d20 3d20 4e6f 6e65  tr, None] = None
-00012aa0: 2c0d 0a20 2020 2063 6f6c 756d 6e73 3a20  ,..    columns: 
-00012ab0: 4f70 7469 6f6e 616c 5b49 7465 7261 626c  Optional[Iterabl
-00012ac0: 655b 7374 725d 5d20 3d20 4e6f 6e65 2c0d  e[str]] = None,.
-00012ad0: 0a20 2020 2077 6865 7265 3a20 4f70 7469  .    where: Opti
-00012ae0: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
-00012af0: 2c0d 0a20 2020 2073 716c 5f73 746d 743a  ,..    sql_stmt:
-00012b00: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
-00012b10: 204e 6f6e 652c 0d0a 2020 2020 7371 6c5f   None,..    sql_
-00012b20: 6469 616c 6563 743a 204f 7074 696f 6e61  dialect: Optiona
-00012b30: 6c5b 4c69 7465 7261 6c5b 2253 514c 4954  l[Literal["SQLIT
-00012b40: 4522 2c20 224f 4752 5351 4c22 5d5d 203d  E", "OGRSQL"]] =
-00012b50: 204e 6f6e 652c 0d0a 2020 2020 7265 7072   None,..    repr
-00012b60: 6f6a 6563 743a 2062 6f6f 6c20 3d20 4661  oject: bool = Fa
-00012b70: 6c73 652c 0d0a 2020 2020 6578 706c 6f64  lse,..    explod
-00012b80: 6563 6f6c 6c65 6374 696f 6e73 3a20 626f  ecollections: bo
-00012b90: 6f6c 203d 2046 616c 7365 2c0d 0a20 2020  ol = False,..   
-00012ba0: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-00012bb0: 6f6d 6574 7279 7479 7065 3a20 556e 696f  ometrytype: Unio
-00012bc0: 6e5b 4765 6f6d 6574 7279 5479 7065 2c20  n[GeometryType, 
-00012bd0: 7374 722c 204e 6f6e 655d 203d 204e 6f6e  str, None] = Non
-00012be0: 652c 0d0a 2020 2020 6372 6561 7465 5f73  e,..    create_s
-00012bf0: 7061 7469 616c 5f69 6e64 6578 3a20 4f70  patial_index: Op
-00012c00: 7469 6f6e 616c 5b62 6f6f 6c5d 203d 2054  tional[bool] = T
-00012c10: 7275 652c 0d0a 2020 2020 6170 7065 6e64  rue,..    append
-00012c20: 5f74 696d 656f 7574 5f73 3a20 696e 7420  _timeout_s: int 
-00012c30: 3d20 3630 302c 0d0a 2020 2020 7472 616e  = 600,..    tran
-00012c40: 7361 6374 696f 6e5f 7369 7a65 3a20 696e  saction_size: in
-00012c50: 7420 3d20 3530 3030 302c 0d0a 2020 2020  t = 50000,..    
-00012c60: 7072 6573 6572 7665 5f66 6964 3a20 4f70  preserve_fid: Op
-00012c70: 7469 6f6e 616c 5b62 6f6f 6c5d 203d 204e  tional[bool] = N
-00012c80: 6f6e 652c 0d0a 2020 2020 6473 745f 6469  one,..    dst_di
-00012c90: 6d65 6e73 696f 6e73 3a20 4f70 7469 6f6e  mensions: Option
-00012ca0: 616c 5b73 7472 5d20 3d20 4e6f 6e65 2c0d  al[str] = None,.
-00012cb0: 0a20 2020 206f 7074 696f 6e73 3a20 6469  .    options: di
-00012cc0: 6374 203d 207b 7d2c 0d0a 293a 0d0a 2020  ct = {},..):..  
-00012cd0: 2020 2222 220d 0a20 2020 2041 7070 656e    """..    Appen
-00012ce0: 6420 7372 6320 6669 6c65 2074 6f20 7468  d src file to th
-00012cf0: 6520 6473 7420 6669 6c65 2e0d 0a0d 0a20  e dst file..... 
-00012d00: 2020 2049 6620 616e 2073 716c 5f73 746d     If an sql_stm
-00012d10: 7420 6973 2073 7065 6369 6669 6564 2c20  t is specified, 
-00012d20: 7468 6520 7371 6c69 7465 2071 7565 7279  the sqlite query
-00012d30: 2063 616e 2063 6f6e 7461 696e 2066 6f6c   can contain fol
-00012d40: 6c6f 7769 6e67 2070 6c61 6365 686f 6c64  lowing placehold
-00012d50: 6572 730d 0a20 2020 2074 6861 7420 7769  ers..    that wi
-00012d60: 6c6c 2062 6520 6175 746f 6d61 7469 6361  ll be automatica
-00012d70: 6c6c 7920 7265 706c 6163 6564 2066 6f72  lly replaced for
-00012d80: 2079 6f75 3a0d 0a0d 0a20 2020 2020 202a   you:....      *
-00012d90: 207b 6765 6f6d 6574 7279 636f 6c75 6d6e   {geometrycolumn
-00012da0: 7d3a 2074 6865 2063 6f6c 756d 6e20 7768  }: the column wh
-00012db0: 6572 6520 7468 6520 7072 696d 6172 7920  ere the primary 
-00012dc0: 6765 6f6d 6574 7279 2069 7320 7374 6f72  geometry is stor
-00012dd0: 6564 2e0d 0a20 2020 2020 202a 207b 636f  ed...      * {co
-00012de0: 6c75 6d6e 735f 746f 5f73 656c 6563 745f  lumns_to_select_
-00012df0: 7374 727d 3a20 6966 2027 636f 6c75 6d6e  str}: if 'column
-00012e00: 7327 2069 7320 6e6f 7420 4e6f 6e65 2c20  s' is not None, 
-00012e10: 7468 6f73 6520 636f 6c75 6d6e 732c 0d0a  those columns,..
-00012e20: 2020 2020 2020 2020 6f74 6865 7277 6973          otherwis
-00012e30: 6520 616c 6c20 636f 6c75 6d6e 7320 6f66  e all columns of
-00012e40: 2074 6865 206c 6179 6572 2e0d 0a20 2020   the layer...   
-00012e50: 2020 202a 207b 696e 7075 745f 6c61 7965     * {input_laye
-00012e60: 727d 3a20 7468 6520 6c61 7965 7220 6e61  r}: the layer na
-00012e70: 6d65 206f 6620 7468 6520 696e 7075 7420  me of the input 
-00012e80: 6c61 7965 722e 0d0a 0d0a 2020 2020 4578  layer.....    Ex
-00012e90: 616d 706c 6520 5351 4c20 7374 6174 656d  ample SQL statem
-00012ea0: 656e 7420 7769 7468 2070 6c61 6365 686f  ent with placeho
-00012eb0: 6c64 6572 733a 0d0a 2020 2020 3a3a 0d0a  lders:..    ::..
-00012ec0: 0d0a 2020 2020 2020 2020 5345 4c45 4354  ..        SELECT
-00012ed0: 207b 6765 6f6d 6574 7279 636f 6c75 6d6e   {geometrycolumn
-00012ee0: 7d0d 0a20 2020 2020 2020 2020 2020 2020  }..             
-00012ef0: 207b 636f 6c75 6d6e 735f 746f 5f73 656c   {columns_to_sel
-00012f00: 6563 745f 7374 727d 0d0a 2020 2020 2020  ect_str}..      
-00012f10: 2020 2020 4652 4f4d 2022 7b69 6e70 7574      FROM "{input
-00012f20: 5f6c 6179 6572 7d22 206c 6179 6572 0d0a  _layer}" layer..
-00012f30: 0d0a 2020 2020 5468 6520 6f70 7469 6f6e  ..    The option
-00012f40: 7320 7061 7261 6d65 7465 7220 6361 6e20  s parameter can 
-00012f50: 6265 2075 7365 6420 746f 2070 6173 7320  be used to pass 
-00012f60: 616e 7920 7479 7065 206f 6620 6f70 7469  any type of opti
-00012f70: 6f6e 7320 746f 2047 4441 4c20 696e 0d0a  ons to GDAL in..
-00012f80: 2020 2020 7468 6520 666f 6c6c 6f77 696e      the followin
-00012f90: 6720 666f 726d 3a0d 0a20 2020 2020 2020  g form:..       
-00012fa0: 207b 2022 3c6f 7074 696f 6e5f 7479 7065   { "<option_type
-00012fb0: 3e2e 3c6f 7074 696f 6e5f 6e61 6d65 3e22  >.<option_name>"
-00012fc0: 3a20 3c6f 7074 696f 6e5f 7661 6c75 653e  : <option_value>
-00012fd0: 207d 0d0a 0d0a 2020 2020 5468 6520 6f70   }....    The op
-00012fe0: 7469 6f6e 2074 7970 6573 2063 616e 2062  tion types can b
-00012ff0: 6520 616e 7920 6f66 2074 6865 2066 6f6c  e any of the fol
-00013000: 6c6f 7769 6e67 3a0d 0a20 2020 2020 2020  lowing:..       
-00013010: 202d 204c 4159 4552 5f43 5245 4154 494f   - LAYER_CREATIO
-00013020: 4e3a 206c 6179 6572 2063 7265 6174 696f  N: layer creatio
-00013030: 6e20 6f70 7469 6f6e 2028 6c63 6f29 0d0a  n option (lco)..
-00013040: 2020 2020 2020 2020 2d20 4441 5441 5345          - DATASE
-00013050: 545f 4352 4541 5449 4f4e 3a20 6461 7461  T_CREATION: data
-00013060: 7365 7420 6372 6561 7469 6f6e 206f 7074  set creation opt
-00013070: 696f 6e20 2864 7363 6f29 0d0a 2020 2020  ion (dsco)..    
-00013080: 2020 2020 2d20 494e 5055 545f 4f50 454e      - INPUT_OPEN
-00013090: 3a20 696e 7075 7420 6461 7461 7365 7420  : input dataset 
-000130a0: 6f70 656e 206f 7074 696f 6e20 286f 6f29  open option (oo)
-000130b0: 0d0a 2020 2020 2020 2020 2d20 4445 5354  ..        - DEST
-000130c0: 494e 4154 494f 4e5f 4f50 454e 3a20 6465  INATION_OPEN: de
-000130d0: 7374 696e 6174 696f 6e20 6461 7461 7365  stination datase
-000130e0: 7420 6f70 656e 206f 7074 696f 6e20 2864  t open option (d
-000130f0: 6f6f 290d 0a20 2020 2020 2020 202d 2043  oo)..        - C
-00013100: 4f4e 4649 473a 2063 6f6e 6669 6720 6f70  ONFIG: config op
-00013110: 7469 6f6e 2028 636f 6e66 6967 290d 0a0d  tion (config)...
-00013120: 0a20 2020 2054 6865 206f 7074 696f 6e73  .    The options
-00013130: 2063 616e 2062 6520 666f 756e 6420 696e   can be found in
-00013140: 2074 6865 207c 4744 414c 5f76 6563 746f   the |GDAL_vecto
-00013150: 725f 6472 6976 6572 5f64 6f63 756d 656e  r_driver_documen
-00013160: 7461 7469 6f6e 7c2e 0d0a 0d0a 2020 2020  tation|.....    
-00013170: 4172 6773 3a0d 0a20 2020 2020 2020 2073  Args:..        s
-00013180: 7263 2028 556e 696f 6e5b 7374 722c 293a  rc (Union[str,):
-00013190: 2073 6f75 7263 6520 6669 6c65 2070 6174   source file pat
-000131a0: 682e 0d0a 2020 2020 2020 2020 6473 7420  h...        dst 
-000131b0: 2855 6e69 6f6e 5b73 7472 2c29 3a20 6465  (Union[str,): de
-000131c0: 7374 696e 6174 696f 6e20 6669 6c65 2070  stination file p
-000131d0: 6174 682e 0d0a 2020 2020 2020 2020 7372  ath...        sr
-000131e0: 635f 6c61 7965 7220 2873 7472 2c20 6f70  c_layer (str, op
-000131f0: 7469 6f6e 616c 293a 2073 6f75 7263 6520  tional): source 
-00013200: 6c61 7965 722e 2044 6566 6175 6c74 7320  layer. Defaults 
-00013210: 746f 204e 6f6e 652e 0d0a 2020 2020 2020  to None...      
-00013220: 2020 6473 745f 6c61 7965 7220 2873 7472    dst_layer (str
-00013230: 2c20 6f70 7469 6f6e 616c 293a 2064 6573  , optional): des
-00013240: 7469 6e61 7469 6f6e 206c 6179 6572 2e20  tination layer. 
-00013250: 4465 6661 756c 7473 2074 6f20 4e6f 6e65  Defaults to None
-00013260: 2e0d 0a20 2020 2020 2020 2073 7263 5f63  ...        src_c
-00013270: 7273 2028 7374 722c 206f 7074 696f 6e61  rs (str, optiona
-00013280: 6c29 3a20 616e 2065 7073 6720 696e 7420  l): an epsg int 
-00013290: 6f72 2061 6e79 7468 696e 6720 7375 7070  or anything supp
-000132a0: 6f72 7465 640d 0a20 2020 2020 2020 2020  orted..         
-000132b0: 2020 2062 7920 7468 6520 4f47 5253 7061     by the OGRSpa
-000132c0: 7469 616c 5265 6665 7265 6e63 652e 5365  tialReference.Se
-000132d0: 7446 726f 6d55 7365 7249 6e70 7574 2829  tFromUserInput()
-000132e0: 2063 616c 6c2c 2077 6869 6368 2069 6e63   call, which inc
-000132f0: 6c75 6465 730d 0a20 2020 2020 2020 2020  ludes..         
-00013300: 2020 2061 6e20 4550 5347 2073 7472 696e     an EPSG strin
-00013310: 6720 2865 672e 2022 4550 5347 3a34 3332  g (eg. "EPSG:432
-00013320: 3622 292c 2061 2077 656c 6c20 6b6e 6f77  6"), a well know
-00013330: 6e20 7465 7874 2028 574b 5429 2043 5253  n text (WKT) CRS
-00013340: 0d0a 2020 2020 2020 2020 2020 2020 6465  ..            de
-00013350: 6669 6e69 7469 6f6e 2c2e 2e2e 2044 6566  finition,... Def
-00013360: 6175 6c74 7320 746f 204e 6f6e 652e 0d0a  aults to None...
-00013370: 2020 2020 2020 2020 6473 745f 6372 7320          dst_crs 
-00013380: 2873 7472 2c20 6f70 7469 6f6e 616c 293a  (str, optional):
-00013390: 2061 6e20 6570 7367 2069 6e74 206f 7220   an epsg int or 
-000133a0: 616e 7974 6869 6e67 2073 7570 706f 7274  anything support
-000133b0: 6564 0d0a 2020 2020 2020 2020 2020 2020  ed..            
-000133c0: 6279 2074 6865 204f 4752 5370 6174 6961  by the OGRSpatia
-000133d0: 6c52 6566 6572 656e 6365 2e53 6574 4672  lReference.SetFr
-000133e0: 6f6d 5573 6572 496e 7075 7428 2920 6361  omUserInput() ca
-000133f0: 6c6c 2c20 7768 6963 6820 696e 636c 7564  ll, which includ
-00013400: 6573 0d0a 2020 2020 2020 2020 2020 2020  es..            
-00013410: 616e 2045 5053 4720 7374 7269 6e67 2028  an EPSG string (
-00013420: 6567 2e20 2245 5053 473a 3433 3236 2229  eg. "EPSG:4326")
-00013430: 2c20 6120 7765 6c6c 206b 6e6f 776e 2074  , a well known t
-00013440: 6578 7420 2857 4b54 2920 4352 530d 0a20  ext (WKT) CRS.. 
-00013450: 2020 2020 2020 2020 2020 2064 6566 696e             defin
-00013460: 6974 696f 6e2c 2e2e 2e20 4465 6661 756c  ition,... Defaul
-00013470: 7473 2074 6f20 4e6f 6e65 2e0d 0a20 2020  ts to None...   
-00013480: 2020 2020 2063 6f6c 756d 6e73 2028 4974       columns (It
-00013490: 6572 6162 6c65 5b73 7472 5d2c 206f 7074  erable[str], opt
-000134a0: 696f 6e61 6c29 3a20 5468 6520 286e 6f6e  ional): The (non
-000134b0: 2d67 656f 6d65 7472 7929 2063 6f6c 756d  -geometry) colum
-000134c0: 6e73 2074 6f20 7265 6164 2077 696c 6c0d  ns to read will.
-000134d0: 0a20 2020 2020 2020 2020 2020 2062 6520  .            be 
-000134e0: 7265 7475 726e 6564 2069 6e20 7468 6520  returned in the 
-000134f0: 6f72 6465 7220 7370 6563 6966 6965 642e  order specified.
-00013500: 2049 6620 4e6f 6e65 2c20 616c 6c20 7374   If None, all st
-00013510: 616e 6461 7264 2063 6f6c 756d 6e73 2061  andard columns a
-00013520: 7265 2072 6561 642e 0d0a 2020 2020 2020  re read...      
-00013530: 2020 2020 2020 496e 2061 6464 6974 696f        In additio
-00013540: 6e20 746f 2073 7461 6e64 6172 6420 636f  n to standard co
-00013550: 6c75 6d6e 732c 2069 7420 6973 2061 6c73  lumns, it is als
-00013560: 6f20 706f 7373 6962 6c65 0d0a 2020 2020  o possible..    
-00013570: 2020 2020 2020 2020 746f 2073 7065 6369          to speci
-00013580: 6679 2022 6669 6422 2c20 6120 756e 6971  fy "fid", a uniq
-00013590: 7565 2069 6e64 6578 2061 7661 696c 6162  ue index availab
-000135a0: 6c65 2069 6e20 616c 6c20 696e 7075 7420  le in all input 
-000135b0: 6669 6c65 732e 204e 6f74 6520 7468 6174  files. Note that
-000135c0: 2074 6865 0d0a 2020 2020 2020 2020 2020   the..          
-000135d0: 2020 2266 6964 2220 7769 6c6c 2062 6520    "fid" will be 
-000135e0: 616c 6961 7365 6420 6567 2e20 746f 2022  aliased eg. to "
-000135f0: 6669 645f 3122 2e20 4465 6661 756c 7473  fid_1". Defaults
-00013600: 2074 6f20 4e6f 6e65 2e0d 0a20 2020 2020   to None...     
-00013610: 2020 2077 6865 7265 2028 7374 722c 206f     where (str, o
-00013620: 7074 696f 6e61 6c29 3a20 6f6e 6c79 2061  ptional): only a
-00013630: 7070 656e 6420 7468 6520 726f 7773 2066  ppend the rows f
-00013640: 726f 6d20 7372 6320 7468 6174 2063 6f6d  rom src that com
-00013650: 706c 7920 746f 2074 6865 2066 696c 7465  ply to the filte
-00013660: 720d 0a20 2020 2020 2020 2020 2020 2073  r..            s
-00013670: 7065 6369 6669 6564 2e20 4170 706c 6965  pecified. Applie
-00013680: 6420 6265 666f 7265 2065 7870 6c6f 6465  d before explode
-00013690: 636f 6c6c 6563 7469 6f6e 732e 2046 696c  collections. Fil
-000136a0: 7465 7220 7368 6f75 6c64 2062 6520 696e  ter should be in
-000136b0: 2073 716c 6974 650d 0a20 2020 2020 2020   sqlite..       
-000136c0: 2020 2020 2053 514c 2057 4845 5245 2073       SQL WHERE s
-000136d0: 796e 7461 7820 616e 6420 7c73 7061 7469  yntax and |spati
-000136e0: 616c 6974 655f 7265 6665 7265 6e63 655f  alite_reference_
-000136f0: 6c69 6e6b 7c20 6675 6e63 7469 6f6e 7320  link| functions 
-00013700: 6361 6e20 6265 2075 7365 642e 2049 660d  can be used. If.
-00013710: 0a20 2020 2020 2020 2020 2020 2077 6865  .            whe
-00013720: 7265 2063 6f6e 7461 696e 7320 7468 6520  re contains the 
-00013730: 7b67 656f 6d65 7472 7963 6f6c 756d 6e7d  {geometrycolumn}
-00013740: 2070 6c61 6365 686f 6c64 6572 2c20 6974   placeholder, it
-00013750: 2069 7320 6669 6c6c 6564 206f 7574 2077   is filled out w
-00013760: 6974 6820 7468 650d 0a20 2020 2020 2020  ith the..       
-00013770: 2020 2020 2067 656f 6d65 7472 7920 636f       geometry co
-00013780: 6c75 6d6e 206e 616d 6520 6f66 2074 6865  lumn name of the
-00013790: 2073 7263 2066 696c 652e 2044 6566 6175   src file. Defau
-000137a0: 6c74 7320 746f 204e 6f6e 652e 0d0a 2020  lts to None...  
-000137b0: 2020 2020 2020 7371 6c5f 7374 6d74 2028        sql_stmt (
-000137c0: 7374 7229 3a20 5351 4c20 7374 6174 656d  str): SQL statem
-000137d0: 656e 7420 746f 2075 7365 2e20 4f6e 6c79  ent to use. Only
-000137e0: 2073 7570 706f 7274 6564 2077 6974 6820   supported with 
-000137f0: 2270 796f 6772 696f 2220 656e 6769 6e65  "pyogrio" engine
-00013800: 2e0d 0a20 2020 2020 2020 2073 716c 5f64  ...        sql_d
-00013810: 6961 6c65 6374 2028 7374 722c 206f 7074  ialect (str, opt
-00013820: 696f 6e61 6c29 3a20 5351 4c20 6469 616c  ional): SQL dial
-00013830: 6563 7420 7573 6564 2e20 4f70 7469 6f6e  ect used. Option
-00013840: 7320 6172 6520 4e6f 6e65 2c20 2253 514c  s are None, "SQL
-00013850: 4954 4522 206f 720d 0a20 2020 2020 2020  ITE" or..       
-00013860: 2020 2020 2022 4f47 5253 514c 222e 2049       "OGRSQL". I
-00013870: 6620 4e6f 6e65 2c20 666f 7220 6461 7461  f None, for data
-00013880: 2073 6f75 7263 6573 2077 6974 6820 6578   sources with ex
-00013890: 706c 6963 6974 2053 514c 2073 7570 706f  plicit SQL suppo
-000138a0: 7274 2074 6865 2073 7461 7465 6d65 6e74  rt the statement
-000138b0: 0d0a 2020 2020 2020 2020 2020 2020 6973  ..            is
-000138c0: 2070 726f 6365 7373 6564 2062 7920 7468   processed by th
-000138d0: 6520 6465 6661 756c 7420 5351 4c20 656e  e default SQL en
-000138e0: 6769 6e65 2028 652e 672e 2066 6f72 2047  gine (e.g. for G
-000138f0: 656f 7061 636b 6167 6520 616e 6420 5370  eopackage and Sp
-00013900: 6174 6961 6c69 7465 0d0a 2020 2020 2020  atialite..      
-00013910: 2020 2020 2020 7468 6973 2069 7320 2253        this is "S
-00013920: 514c 4954 4522 292e 2046 6f72 2064 6174  QLITE"). For dat
-00013930: 6120 736f 7572 6365 7320 7769 7468 6f75  a sources withou
-00013940: 7420 6e61 7469 7665 2053 514c 2073 7570  t native SQL sup
-00013950: 706f 7274 2028 652e 672e 202e 7368 7029  port (e.g. .shp)
-00013960: 2c0d 0a20 2020 2020 2020 2020 2020 2074  ,..            t
-00013970: 6865 2022 4f47 5253 514c 2220 6469 616c  he "OGRSQL" dial
-00013980: 6563 7420 6973 2074 6865 2064 6566 6175  ect is the defau
-00013990: 6c74 2e20 4966 2074 6865 2022 5351 4c49  lt. If the "SQLI
-000139a0: 5445 2220 6469 616c 6563 7420 6973 2073  TE" dialect is s
-000139b0: 7065 6369 6669 6564 2c0d 0a20 2020 2020  pecified,..     
-000139c0: 2020 2020 2020 207c 7370 6174 6961 6c69         |spatiali
-000139d0: 7465 5f72 6566 6572 656e 6365 5f6c 696e  te_reference_lin
-000139e0: 6b7c 2066 756e 6374 696f 6e73 2063 616e  k| functions can
-000139f0: 2061 6c73 6f20 6265 2075 7365 642e 2044   also be used. D
-00013a00: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
-00013a10: 0d0a 2020 2020 2020 2020 7265 7072 6f6a  ..        reproj
-00013a20: 6563 7420 2862 6f6f 6c2c 206f 7074 696f  ect (bool, optio
-00013a30: 6e61 6c29 3a20 5472 7565 2074 6f20 7265  nal): True to re
-00013a40: 7072 6f6a 6563 7420 7768 696c 6520 636f  project while co
-00013a50: 6e76 6572 7469 6e67 2074 6865 0d0a 2020  nverting the..  
-00013a60: 2020 2020 2020 2020 2020 6669 6c65 2e20            file. 
-00013a70: 4465 6661 756c 7473 2074 6f20 4661 6c73  Defaults to Fals
-00013a80: 652e 0d0a 2020 2020 2020 2020 6578 706c  e...        expl
-00013a90: 6f64 6563 6f6c 6c65 6374 696f 6e73 2028  odecollections (
-00013aa0: 626f 6f6c 292c 206f 7074 696f 6e61 6c29  bool), optional)
-00013ab0: 3a20 5472 7565 2074 6f20 6f75 7470 7574  : True to output
-00013ac0: 206f 6e6c 7920 7369 6d70 6c65 2067 656f   only simple geo
-00013ad0: 6d65 7472 6965 732e 0d0a 2020 2020 2020  metries...      
-00013ae0: 2020 2020 2020 4465 6661 756c 7473 2074        Defaults t
-00013af0: 6f20 4661 6c73 652e 0d0a 2020 2020 2020  o False...      
-00013b00: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
-00013b10: 656f 6d65 7472 7974 7970 6520 2855 6e69  eometrytype (Uni
-00013b20: 6f6e 5b47 656f 6d65 7472 7954 7970 652c  on[GeometryType,
-00013b30: 2073 7472 5d2c 206f 7074 696f 6e61 6c29   str], optional)
-00013b40: 3a20 4765 6f6d 6574 7279 2074 7970 652e  : Geometry type.
-00013b50: 0d0a 2020 2020 2020 2020 2020 2020 746f  ..            to
-00013b60: 2028 7472 7920 746f 2920 666f 7263 6520   (try to) force 
-00013b70: 7468 6520 6f75 7470 7574 2074 6f2e 2044  the output to. D
-00013b80: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
-00013b90: 0d0a 2020 2020 2020 2020 6372 6561 7465  ..        create
-00013ba0: 5f73 7061 7469 616c 5f69 6e64 6578 2028  _spatial_index (
-00013bb0: 626f 6f6c 2c20 6f70 7469 6f6e 616c 293a  bool, optional):
-00013bc0: 2054 7275 6520 746f 2063 7265 6174 6520   True to create 
-00013bd0: 6120 7370 6174 6961 6c20 696e 6465 780d  a spatial index.
-00013be0: 0a20 2020 2020 2020 2020 2020 206f 6e20  .            on 
-00013bf0: 7468 6520 6465 7374 696e 6174 696f 6e20  the destination 
-00013c00: 6669 6c65 2f6c 6179 6572 2e20 4966 204e  file/layer. If N
-00013c10: 6f6e 652c 2074 6865 2064 6566 6175 6c74  one, the default
-00013c20: 2062 6568 6176 696f 7572 2062 7920 6764   behaviour by gd
-00013c30: 616c 2066 6f72 0d0a 2020 2020 2020 2020  al for..        
-00013c40: 2020 2020 7468 6174 2066 696c 6520 7479      that file ty
-00013c50: 7065 2069 7320 7265 7370 6563 7465 642e  pe is respected.
-00013c60: 2049 6620 7468 6520 604c 4159 4552 5f43   If the `LAYER_C
-00013c70: 5245 4154 494f 4e2e 5350 4154 4941 4c5f  REATION.SPATIAL_
-00013c80: 494e 4445 5860 0d0a 2020 2020 2020 2020  INDEX`..        
-00013c90: 2020 2020 7061 7261 6d65 7465 7220 6973      parameter is
-00013ca0: 2073 7065 6369 6669 6564 2069 6e20 6f70   specified in op
-00013cb0: 7469 6f6e 732c 2060 6372 6561 7465 5f73  tions, `create_s
-00013cc0: 7061 7469 616c 5f69 6e64 6578 6020 6973  patial_index` is
-00013cd0: 2069 676e 6f72 6564 2e20 4966 2074 6865   ignored. If the
-00013ce0: 0d0a 2020 2020 2020 2020 2020 2020 6465  ..            de
-00013cf0: 7374 696e 6174 696f 6e20 6c61 7965 7220  stination layer 
-00013d00: 6578 6973 7473 2061 6c72 6561 6479 2c20  exists already, 
-00013d10: 6063 7265 6174 655f 7370 6174 6961 6c5f  `create_spatial_
-00013d20: 696e 6465 7860 2069 7320 616c 736f 2069  index` is also i
-00013d30: 676e 6f72 6564 2e0d 0a20 2020 2020 2020  gnored...       
-00013d40: 2020 2020 2044 6566 6175 6c74 7320 746f       Defaults to
-00013d50: 2054 7275 652e 0d0a 2020 2020 2020 2020   True...        
-00013d60: 6170 7065 6e64 5f74 696d 656f 7574 5f73  append_timeout_s
-00013d70: 2028 696e 742c 206f 7074 696f 6e61 6c29   (int, optional)
-00013d80: 3a20 7469 6d65 6f75 7420 746f 2075 7365  : timeout to use
-00013d90: 2069 6620 7468 6520 6f75 7470 7574 2066   if the output f
-00013da0: 696c 6520 6973 0d0a 2020 2020 2020 2020  ile is..        
-00013db0: 2020 2020 6265 696e 6720 7772 6974 7465      being writte
-00013dc0: 6e20 746f 2062 7920 616e 6f74 6865 7220  n to by another 
-00013dd0: 7072 6f63 6573 7320 616c 7265 6164 792e  process already.
-00013de0: 2044 6566 6175 6c74 7320 746f 2036 3030   Defaults to 600
-00013df0: 2e0d 0a20 2020 2020 2020 2074 7261 6e73  ...        trans
-00013e00: 6163 7469 6f6e 5f73 697a 6520 2869 6e74  action_size (int
-00013e10: 2c20 6f70 7469 6f6e 616c 293a 2054 7261  , optional): Tra
-00013e20: 6e73 6163 7469 6f6e 2073 697a 652e 2044  nsaction size. D
-00013e30: 6566 6175 6c74 7320 746f 2035 3030 3030  efaults to 50000
-00013e40: 2e0d 0a20 2020 2020 2020 2070 7265 7365  ...        prese
-00013e50: 7276 655f 6669 6420 2862 6f6f 6c2c 206f  rve_fid (bool, o
-00013e60: 7074 696f 6e61 6c29 3a20 5472 7565 2074  ptional): True t
-00013e70: 6f20 6d61 6b65 2061 6e20 6578 7472 6120  o make an extra 
-00013e80: 6566 666f 7274 2074 6f20 7072 6573 6572  effort to preser
-00013e90: 7665 2066 6964 2773 206f 660d 0a20 2020  ve fid's of..   
-00013ea0: 2020 2020 2020 2020 2074 6865 2073 6f75           the sou
-00013eb0: 7263 6520 6c61 7965 7220 746f 2074 6865  rce layer to the
-00013ec0: 2064 6573 7469 6e61 7469 6f6e 206c 6179   destination lay
-00013ed0: 6572 2e20 4661 6c73 6520 6e6f 7420 746f  er. False not to
-00013ee0: 2064 6f20 616e 7920 6566 666f 7274 2e20   do any effort. 
-00013ef0: 4e6f 6e65 0d0a 2020 2020 2020 2020 2020  None..          
-00013f00: 2020 746f 2075 7365 2074 6865 2064 6566    to use the def
-00013f10: 6175 6c74 2062 6568 6176 696f 7572 206f  ault behaviour o
-00013f20: 6620 6764 616c 2c20 7468 6174 2061 6c72  f gdal, that alr
-00013f30: 6561 6479 2070 7265 7365 7276 6573 2069  eady preserves i
-00013f40: 6e20 736f 6d65 2063 6173 6573 2e0d 0a20  n some cases... 
-00013f50: 2020 2020 2020 2020 2020 2053 6f6d 6520             Some 
-00013f60: 6669 6c65 2066 6f72 6d61 7473 2064 6f6e  file formats don
-00013f70: 2774 2065 7870 6c69 6369 746c 7920 7374  't explicitly st
-00013f80: 6f72 6520 7468 6520 6669 6420 2865 2e67  ore the fid (e.g
-00013f90: 2e20 7368 6170 6566 696c 6529 2c20 736f  . shapefile), so
-00013fa0: 2074 6865 790d 0a20 2020 2020 2020 2020   they..         
-00013fb0: 2020 2077 696c 6c20 6e65 7665 7220 6265     will never be
-00013fc0: 2061 626c 6520 746f 2070 7265 7365 7276   able to preserv
-00013fd0: 6520 6669 6473 2e20 4465 6661 756c 7473  e fids. Defaults
-00013fe0: 2074 6f20 4e6f 6e65 2e0d 0a20 2020 2020   to None...     
-00013ff0: 2020 2064 7374 5f64 696d 656e 7369 6f6e     dst_dimension
-00014000: 7320 2873 7472 2c20 6f70 7469 6f6e 616c  s (str, optional
-00014010: 293a 2046 6f72 6365 2074 6865 2064 696d  ): Force the dim
-00014020: 656e 7369 6f6e 7320 6f66 2074 6865 2064  ensions of the d
-00014030: 6573 7469 6e61 7469 6f6e 206c 6179 6572  estination layer
-00014040: 2074 6f0d 0a20 2020 2020 2020 2020 2020   to..           
-00014050: 2074 6865 2076 616c 7565 2073 7065 6369   the value speci
-00014060: 6669 6564 2e20 5661 6c69 6420 7661 6c75  fied. Valid valu
-00014070: 6573 3a20 2258 5922 2c20 2258 595a 222c  es: "XY", "XYZ",
-00014080: 2022 5859 4d22 206f 7220 2258 595a 4d22   "XYM" or "XYZM"
-00014090: 2e0d 0a20 2020 2020 2020 2020 2020 2044  ...            D
-000140a0: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
-000140b0: 0d0a 2020 2020 2020 2020 6f70 7469 6f6e  ..        option
-000140c0: 7320 2864 6963 742c 206f 7074 696f 6e61  s (dict, optiona
-000140d0: 6c29 3a20 6f70 7469 6f6e 7320 746f 2070  l): options to p
-000140e0: 6173 7320 746f 2067 6461 6c2e 0d0a 0d0a  ass to gdal.....
-000140f0: 2020 2020 5261 6973 6573 3a0d 0a20 2020      Raises:..   
-00014100: 2020 2020 2056 616c 7565 4572 726f 723a       ValueError:
-00014110: 2061 6e20 696e 7661 6c69 6420 7061 7261   an invalid para
-00014120: 6d65 7465 7220 7661 6c75 6520 7761 7320  meter value was 
-00014130: 7061 7373 6564 2e0d 0a20 2020 2020 2020  passed...       
-00014140: 2052 756e 7469 6d65 4572 726f 723a 2074   RuntimeError: t
-00014150: 696d 656f 7574 2077 6173 2072 6561 6368  imeout was reach
-00014160: 6564 2077 6869 6c65 2074 7279 696e 6720  ed while trying 
-00014170: 746f 2061 7070 656e 6420 6461 7461 2074  to append data t
-00014180: 6f20 7061 7468 2e0d 0a0d 0a20 2020 202e  o path.....    .
-00014190: 2e20 7c73 7061 7469 616c 6974 655f 7265  . |spatialite_re
-000141a0: 6665 7265 6e63 655f 6c69 6e6b 7c20 7261  ference_link| ra
-000141b0: 773a 3a20 6874 6d6c 0d0a 0d0a 2020 2020  w:: html....    
-000141c0: 2020 2020 3c61 2068 7265 663d 2268 7474      <a href="htt
-000141d0: 7073 3a2f 2f77 7777 2e67 6169 612d 6769  ps://www.gaia-gi
-000141e0: 732e 6974 2f67 6169 612d 7369 6e73 2f73  s.it/gaia-sins/s
-000141f0: 7061 7469 616c 6974 652d 7371 6c2d 6c61  patialite-sql-la
-00014200: 7465 7374 2e68 746d 6c22 2074 6172 6765  test.html" targe
-00014210: 743d 225f 626c 616e 6b22 3e73 7061 7469  t="_blank">spati
-00014220: 616c 6974 6520 7265 6665 7265 6e63 653c  alite reference<
-00014230: 2f61 3e0d 0a0d 0a20 2020 202e 2e20 7c47  /a>....    .. |G
-00014240: 4441 4c5f 7665 6374 6f72 5f64 7269 7665  DAL_vector_drive
-00014250: 725f 646f 6375 6d65 6e74 6174 696f 6e7c  r_documentation|
-00014260: 2072 6177 3a3a 2068 746d 6c0d 0a0d 0a20   raw:: html.... 
-00014270: 2020 2020 2020 203c 6120 6872 6566 3d22         <a href="
-00014280: 6874 7470 733a 2f2f 6764 616c 2e6f 7267  https://gdal.org
-00014290: 2f64 7269 7665 7273 2f76 6563 746f 722f  /drivers/vector/
-000142a0: 696e 6465 782e 6874 6d6c 2220 7461 7267  index.html" targ
-000142b0: 6574 3d22 5f62 6c61 6e6b 223e 4744 414c  et="_blank">GDAL
-000142c0: 2076 6563 746f 7220 6472 6976 6572 2064   vector driver d
-000142d0: 6f63 756d 656e 7461 7469 6f6e 3c2f 613e  ocumentation</a>
-000142e0: 0d0a 0d0a 2020 2020 2222 2220 2023 206e  ....    """  # n
-000142f0: 6f71 613a 2045 3530 310d 0a20 2020 2023  oqa: E501..    #
-00014300: 2043 6865 636b 2f63 6c65 616e 2069 6e70   Check/clean inp
-00014310: 7574 2070 6172 616d 730d 0a20 2020 2073  ut params..    s
-00014320: 7263 203d 2050 6174 6828 7372 6329 0d0a  rc = Path(src)..
-00014330: 2020 2020 6473 7420 3d20 5061 7468 2864      dst = Path(d
-00014340: 7374 290d 0a20 2020 2069 6620 666f 7263  st)..    if forc
-00014350: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-00014360: 7974 7970 6520 6973 206e 6f74 204e 6f6e  ytype is not Non
-00014370: 653a 0d0a 2020 2020 2020 2020 666f 7263  e:..        forc
-00014380: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-00014390: 7974 7970 6520 3d20 4765 6f6d 6574 7279  ytype = Geometry
-000143a0: 5479 7065 2866 6f72 6365 5f6f 7574 7075  Type(force_outpu
-000143b0: 745f 6765 6f6d 6574 7279 7479 7065 290d  t_geometrytype).
-000143c0: 0a0d 0a20 2020 2023 2046 696c 6573 2064  ...    # Files d
-000143d0: 6f6e 2774 2074 7970 6963 616c 6c79 2073  on't typically s
-000143e0: 7570 706f 7274 2068 6176 696e 6720 6d75  upport having mu
-000143f0: 6c74 6970 6c65 2070 726f 6365 7373 6573  ltiple processes
-00014400: 2077 7269 7469 6e67 0d0a 2020 2020 2320   writing..    # 
-00014410: 7369 6d75 6c74 616e 6f75 736c 7920 746f  simultanously to
-00014420: 2074 6865 6d2c 2073 6f20 7573 6520 6c6f   them, so use lo
-00014430: 636b 2066 696c 6520 746f 2073 796e 6368  ck file to synch
-00014440: 726f 6e69 7a65 2061 6363 6573 732e 0d0a  ronize access...
-00014450: 2020 2020 6c6f 636b 6669 6c65 203d 2050      lockfile = P
-00014460: 6174 6828 6622 7b73 7472 2864 7374 297d  ath(f"{str(dst)}
-00014470: 2e6c 6f63 6b22 290d 0a0d 0a20 2020 2023  .lock")....    #
-00014480: 2049 6620 7468 6520 6465 7374 696e 6174   If the destinat
-00014490: 696f 6e20 6669 6c65 2064 6f65 736e 2774  ion file doesn't
-000144a0: 2065 7869 7374 2079 6574 2c20 6275 7420   exist yet, but 
-000144b0: 7468 6520 6c6f 636b 6669 6c65 2064 6f65  the lockfile doe
-000144c0: 732c 0d0a 2020 2020 2320 7472 7920 7265  s,..    # try re
-000144d0: 6d6f 7669 6e67 2074 6865 206c 6f63 6b66  moving the lockf
-000144e0: 696c 6520 6173 2069 7420 6d69 6768 7420  ile as it might 
-000144f0: 6265 2061 2067 686f 7374 206c 6f63 6b66  be a ghost lockf
-00014500: 696c 652e 0d0a 2020 2020 6966 206e 6f74  ile...    if not
-00014510: 2064 7374 2e65 7869 7374 7328 2920 616e   dst.exists() an
-00014520: 6420 6c6f 636b 6669 6c65 2e65 7869 7374  d lockfile.exist
-00014530: 7328 293a 0d0a 2020 2020 2020 2020 7472  s():..        tr
-00014540: 793a 0d0a 2020 2020 2020 2020 2020 2020  y:..            
-00014550: 6c6f 636b 6669 6c65 2e75 6e6c 696e 6b28  lockfile.unlink(
-00014560: 290d 0a20 2020 2020 2020 2065 7863 6570  )..        excep
-00014570: 7420 4578 6365 7074 696f 6e3a 0d0a 2020  t Exception:..  
-00014580: 2020 2020 2020 2020 2020 5f20 3d20 4e6f            _ = No
-00014590: 6e65 0d0a 0d0a 2020 2020 2320 4372 6561  ne....    # Crea
-000145a0: 7469 6e67 206c 6f63 6b66 696c 6520 616e  ting lockfile an
-000145b0: 6420 6170 7065 6e64 0d0a 2020 2020 7374  d append..    st
-000145c0: 6172 745f 7469 6d65 203d 2064 6174 6574  art_time = datet
-000145d0: 696d 652e 6461 7465 7469 6d65 2e6e 6f77  ime.datetime.now
-000145e0: 2829 0d0a 2020 2020 7265 6164 7920 3d20  ()..    ready = 
-000145f0: 4661 6c73 650d 0a20 2020 2077 6869 6c65  False..    while
-00014600: 206e 6f74 2072 6561 6479 3a0d 0a20 2020   not ready:..   
-00014610: 2020 2020 2069 6620 5f69 6f5f 7574 696c       if _io_util
-00014620: 2e63 7265 6174 655f 6669 6c65 5f61 746f  .create_file_ato
-00014630: 6d69 6328 6c6f 636b 6669 6c65 2920 6973  mic(lockfile) is
-00014640: 2054 7275 653a 0d0a 2020 2020 2020 2020   True:..        
-00014650: 2020 2020 7472 793a 0d0a 2020 2020 2020      try:..      
-00014660: 2020 2020 2020 2020 2020 2320 6170 7065            # appe
-00014670: 6e64 0d0a 2020 2020 2020 2020 2020 2020  nd..            
-00014680: 2020 2020 5f61 7070 656e 645f 746f 5f6e      _append_to_n
-00014690: 6f6c 6f63 6b28 0d0a 2020 2020 2020 2020  olock(..        
-000146a0: 2020 2020 2020 2020 2020 2020 7372 633d              src=
-000146b0: 7372 632c 0d0a 2020 2020 2020 2020 2020  src,..          
-000146c0: 2020 2020 2020 2020 2020 6473 743d 6473            dst=ds
-000146d0: 742c 0d0a 2020 2020 2020 2020 2020 2020  t,..            
-000146e0: 2020 2020 2020 2020 7372 635f 6c61 7965          src_laye
-000146f0: 723d 7372 635f 6c61 7965 722c 0d0a 2020  r=src_layer,..  
-00014700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014710: 2020 6473 745f 6c61 7965 723d 6473 745f    dst_layer=dst_
-00014720: 6c61 7965 722c 0d0a 2020 2020 2020 2020  layer,..        
-00014730: 2020 2020 2020 2020 2020 2020 7372 635f              src_
-00014740: 6372 733d 7372 635f 6372 732c 0d0a 2020  crs=src_crs,..  
-00014750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014760: 2020 6473 745f 6372 733d 6473 745f 6372    dst_crs=dst_cr
-00014770: 732c 0d0a 2020 2020 2020 2020 2020 2020  s,..            
-00014780: 2020 2020 2020 2020 636f 6c75 6d6e 733d          columns=
-00014790: 636f 6c75 6d6e 732c 0d0a 2020 2020 2020  columns,..      
-000147a0: 2020 2020 2020 2020 2020 2020 2020 7768                wh
-000147b0: 6572 653d 7768 6572 652c 0d0a 2020 2020  ere=where,..    
-000147c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000147d0: 7371 6c5f 7374 6d74 3d73 716c 5f73 746d  sql_stmt=sql_stm
-000147e0: 742c 0d0a 2020 2020 2020 2020 2020 2020  t,..            
-000147f0: 2020 2020 2020 2020 7371 6c5f 6469 616c          sql_dial
-00014800: 6563 743d 7371 6c5f 6469 616c 6563 742c  ect=sql_dialect,
-00014810: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00014820: 2020 2020 2020 7265 7072 6f6a 6563 743d        reproject=
-00014830: 7265 7072 6f6a 6563 742c 0d0a 2020 2020  reproject,..    
-00014840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014850: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
-00014860: 6e73 3d65 7870 6c6f 6465 636f 6c6c 6563  ns=explodecollec
-00014870: 7469 6f6e 732c 0d0a 2020 2020 2020 2020  tions,..        
-00014880: 2020 2020 2020 2020 2020 2020 666f 7263              forc
-00014890: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-000148a0: 7974 7970 653d 666f 7263 655f 6f75 7470  ytype=force_outp
-000148b0: 7574 5f67 656f 6d65 7472 7974 7970 652c  ut_geometrytype,
-000148c0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000148d0: 2020 2020 2020 6372 6561 7465 5f73 7061        create_spa
-000148e0: 7469 616c 5f69 6e64 6578 3d63 7265 6174  tial_index=creat
-000148f0: 655f 7370 6174 6961 6c5f 696e 6465 782c  e_spatial_index,
-00014900: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00014910: 2020 2020 2020 7472 616e 7361 6374 696f        transactio
-00014920: 6e5f 7369 7a65 3d74 7261 6e73 6163 7469  n_size=transacti
-00014930: 6f6e 5f73 697a 652c 0d0a 2020 2020 2020  on_size,..      
-00014940: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00014950: 6573 6572 7665 5f66 6964 3d70 7265 7365  eserve_fid=prese
-00014960: 7276 655f 6669 642c 0d0a 2020 2020 2020  rve_fid,..      
-00014970: 2020 2020 2020 2020 2020 2020 2020 6473                ds
-00014980: 745f 6469 6d65 6e73 696f 6e73 3d64 7374  t_dimensions=dst
-00014990: 5f64 696d 656e 7369 6f6e 732c 0d0a 2020  _dimensions,..  
-000149a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000149b0: 2020 6f70 7469 6f6e 733d 6f70 7469 6f6e    options=option
-000149c0: 732c 0d0a 2020 2020 2020 2020 2020 2020  s,..            
-000149d0: 2020 2020 290d 0a20 2020 2020 2020 2020      )..         
-000149e0: 2020 2066 696e 616c 6c79 3a0d 0a20 2020     finally:..   
-000149f0: 2020 2020 2020 2020 2020 2020 2072 6561               rea
-00014a00: 6479 203d 2054 7275 650d 0a20 2020 2020  dy = True..     
-00014a10: 2020 2020 2020 2020 2020 206c 6f63 6b66             lockf
-00014a20: 696c 652e 756e 6c69 6e6b 2829 0d0a 2020  ile.unlink()..  
-00014a30: 2020 2020 2020 656c 7365 3a0d 0a20 2020        else:..   
-00014a40: 2020 2020 2020 2020 2074 696d 655f 7761           time_wa
-00014a50: 6974 696e 6720 3d20 2864 6174 6574 696d  iting = (datetim
-00014a60: 652e 6461 7465 7469 6d65 2e6e 6f77 2829  e.datetime.now()
-00014a70: 202d 2073 7461 7274 5f74 696d 6529 2e74   - start_time).t
-00014a80: 6f74 616c 5f73 6563 6f6e 6473 2829 0d0a  otal_seconds()..
-00014a90: 2020 2020 2020 2020 2020 2020 6966 2074              if t
-00014aa0: 696d 655f 7761 6974 696e 6720 3e20 6170  ime_waiting > ap
-00014ab0: 7065 6e64 5f74 696d 656f 7574 5f73 3a0d  pend_timeout_s:.
-00014ac0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014ad0: 2072 6169 7365 2052 756e 7469 6d65 4572   raise RuntimeEr
-00014ae0: 726f 7228 0d0a 2020 2020 2020 2020 2020  ror(..          
-00014af0: 2020 2020 2020 2020 2020 6622 6170 7065            f"appe
-00014b00: 6e64 5f74 6f20 7469 6d65 6f75 7420 6f66  nd_to timeout of
-00014b10: 207b 6170 7065 6e64 5f74 696d 656f 7574   {append_timeout
-00014b20: 5f73 7d20 7265 6163 6865 642c 2073 6f20  _s} reached, so 
-00014b30: 7374 6f70 2077 7269 7465 2022 0d0a 2020  stop write "..  
-00014b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014b50: 2020 6622 746f 207b 6473 747d 2122 0d0a    f"to {dst}!"..
-00014b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014b70: 290d 0a0d 0a20 2020 2020 2020 2023 2053  )....        # S
-00014b80: 6c65 6570 2066 6f72 2061 2073 6563 6f6e  leep for a secon
-00014b90: 6420 6265 666f 7265 2074 7279 696e 6720  d before trying 
-00014ba0: 6167 6169 6e0d 0a20 2020 2020 2020 2074  again..        t
-00014bb0: 696d 652e 736c 6565 7028 3129 0d0a 0d0a  ime.sleep(1)....
-00014bc0: 0d0a 6465 6620 5f61 7070 656e 645f 746f  ..def _append_to
-00014bd0: 5f6e 6f6c 6f63 6b28 0d0a 2020 2020 7372  _nolock(..    sr
-00014be0: 633a 2050 6174 682c 0d0a 2020 2020 6473  c: Path,..    ds
-00014bf0: 743a 2050 6174 682c 0d0a 2020 2020 7372  t: Path,..    sr
-00014c00: 635f 6c61 7965 723a 204f 7074 696f 6e61  c_layer: Optiona
-00014c10: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
-00014c20: 2020 2020 6473 745f 6c61 7965 723a 204f      dst_layer: O
-00014c30: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
-00014c40: 6f6e 652c 0d0a 2020 2020 7372 635f 6372  one,..    src_cr
-00014c50: 733a 2055 6e69 6f6e 5b69 6e74 2c20 7374  s: Union[int, st
-00014c60: 722c 204e 6f6e 655d 203d 204e 6f6e 652c  r, None] = None,
-00014c70: 0d0a 2020 2020 6473 745f 6372 733a 2055  ..    dst_crs: U
-00014c80: 6e69 6f6e 5b69 6e74 2c20 7374 722c 204e  nion[int, str, N
-00014c90: 6f6e 655d 203d 204e 6f6e 652c 0d0a 2020  one] = None,..  
-00014ca0: 2020 636f 6c75 6d6e 733a 204f 7074 696f    columns: Optio
-00014cb0: 6e61 6c5b 4974 6572 6162 6c65 5b73 7472  nal[Iterable[str
-00014cc0: 5d5d 203d 204e 6f6e 652c 0d0a 2020 2020  ]] = None,..    
-00014cd0: 7768 6572 653a 204f 7074 696f 6e61 6c5b  where: Optional[
-00014ce0: 7374 725d 203d 204e 6f6e 652c 0d0a 2020  str] = None,..  
-00014cf0: 2020 7371 6c5f 7374 6d74 3a20 4f70 7469    sql_stmt: Opti
-00014d00: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
-00014d10: 2c0d 0a20 2020 2073 716c 5f64 6961 6c65  ,..    sql_diale
-00014d20: 6374 3a20 4f70 7469 6f6e 616c 5b4c 6974  ct: Optional[Lit
-00014d30: 6572 616c 5b22 5351 4c49 5445 222c 2022  eral["SQLITE", "
-00014d40: 4f47 5253 514c 225d 5d20 3d20 4e6f 6e65  OGRSQL"]] = None
-00014d50: 2c0d 0a20 2020 2072 6570 726f 6a65 6374  ,..    reproject
-00014d60: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-00014d70: 0a20 2020 2065 7870 6c6f 6465 636f 6c6c  .    explodecoll
-00014d80: 6563 7469 6f6e 733a 2062 6f6f 6c20 3d20  ections: bool = 
-00014d90: 4661 6c73 652c 0d0a 2020 2020 6372 6561  False,..    crea
-00014da0: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
-00014db0: 3a20 4f70 7469 6f6e 616c 5b62 6f6f 6c5d  : Optional[bool]
-00014dc0: 203d 2054 7275 652c 0d0a 2020 2020 666f   = True,..    fo
-00014dd0: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-00014de0: 7472 7974 7970 653a 2055 6e69 6f6e 5b47  trytype: Union[G
-00014df0: 656f 6d65 7472 7954 7970 652c 2073 7472  eometryType, str
-00014e00: 2c20 4e6f 6e65 5d20 3d20 4e6f 6e65 2c0d  , None] = None,.
-00014e10: 0a20 2020 2074 7261 6e73 6163 7469 6f6e  .    transaction
-00014e20: 5f73 697a 653a 2069 6e74 203d 2035 3030  _size: int = 500
-00014e30: 3030 2c0d 0a20 2020 2070 7265 7365 7276  00,..    preserv
-00014e40: 655f 6669 643a 204f 7074 696f 6e61 6c5b  e_fid: Optional[
-00014e50: 626f 6f6c 5d20 3d20 4e6f 6e65 2c0d 0a20  bool] = None,.. 
-00014e60: 2020 2064 7374 5f64 696d 656e 7369 6f6e     dst_dimension
-00014e70: 733a 204f 7074 696f 6e61 6c5b 7374 725d  s: Optional[str]
-00014e80: 203d 204e 6f6e 652c 0d0a 2020 2020 6f70   = None,..    op
-00014e90: 7469 6f6e 733a 2064 6963 7420 3d20 7b7d  tions: dict = {}
-00014ea0: 2c0d 0a29 3a0d 0a20 2020 2023 2043 6865  ,..):..    # Che
-00014eb0: 636b 2f63 6c65 616e 2069 6e70 7574 2070  ck/clean input p
-00014ec0: 6172 616d 730d 0a20 2020 206f 7074 696f  arams..    optio
-00014ed0: 6e73 203d 205f 6f67 725f 7574 696c 2e5f  ns = _ogr_util._
-00014ee0: 7072 6570 6172 655f 6764 616c 5f6f 7074  prepare_gdal_opt
-00014ef0: 696f 6e73 286f 7074 696f 6e73 290d 0a20  ions(options).. 
-00014f00: 2020 2069 6620 280d 0a20 2020 2020 2020     if (..       
-00014f10: 2063 7265 6174 655f 7370 6174 6961 6c5f   create_spatial_
-00014f20: 696e 6465 7820 6973 206e 6f74 204e 6f6e  index is not Non
-00014f30: 650d 0a20 2020 2020 2020 2061 6e64 2022  e..        and "
-00014f40: 4c41 5945 525f 4352 4541 5449 4f4e 2e53  LAYER_CREATION.S
-00014f50: 5041 5449 414c 5f49 4e44 4558 2220 6e6f  PATIAL_INDEX" no
-00014f60: 7420 696e 206f 7074 696f 6e73 0d0a 2020  t in options..  
-00014f70: 2020 293a 0d0a 2020 2020 2020 2020 6f70    ):..        op
-00014f80: 7469 6f6e 735b 224c 4159 4552 5f43 5245  tions["LAYER_CRE
-00014f90: 4154 494f 4e2e 5350 4154 4941 4c5f 494e  ATION.SPATIAL_IN
-00014fa0: 4445 5822 5d20 3d20 6372 6561 7465 5f73  DEX"] = create_s
-00014fb0: 7061 7469 616c 5f69 6e64 6578 0d0a 0d0a  patial_index....
-00014fc0: 2020 2020 7372 635f 6c61 7965 7220 3d20      src_layer = 
-00014fd0: 7372 635f 6c61 7965 7220 6966 2073 7263  src_layer if src
-00014fe0: 5f6c 6179 6572 2069 7320 6e6f 7420 4e6f  _layer is not No
-00014ff0: 6e65 2065 6c73 6520 6765 745f 6f6e 6c79  ne else get_only
-00015000: 5f6c 6179 6572 2873 7263 290d 0a20 2020  _layer(src)..   
-00015010: 2073 7263 5f6c 6179 6572 696e 666f 203d   src_layerinfo =
-00015020: 204e 6f6e 650d 0a20 2020 2069 6620 7768   None..    if wh
-00015030: 6572 6520 6973 206e 6f74 204e 6f6e 653a  ere is not None:
-00015040: 0d0a 2020 2020 2020 2020 7372 635f 6c61  ..        src_la
-00015050: 7965 7269 6e66 6f20 3d20 6765 745f 6c61  yerinfo = get_la
-00015060: 7965 7269 6e66 6f28 7372 632c 2073 7263  yerinfo(src, src
-00015070: 5f6c 6179 6572 2c20 7261 6973 655f 6f6e  _layer, raise_on
-00015080: 5f6e 6f67 656f 6d3d 4661 6c73 6529 0d0a  _nogeom=False)..
-00015090: 2020 2020 2020 2020 7768 6572 6520 3d20          where = 
-000150a0: 7768 6572 652e 666f 726d 6174 2867 656f  where.format(geo
-000150b0: 6d65 7472 7963 6f6c 756d 6e3d 7372 635f  metrycolumn=src_
-000150c0: 6c61 7965 7269 6e66 6f2e 6765 6f6d 6574  layerinfo.geomet
-000150d0: 7279 636f 6c75 6d6e 290d 0a0d 0a20 2020  rycolumn)....   
-000150e0: 2069 6620 7371 6c5f 7374 6d74 2069 7320   if sql_stmt is 
-000150f0: 6e6f 7420 4e6f 6e65 3a0d 0a20 2020 2020  not None:..     
-00015100: 2020 2023 2046 696c 6c20 6f75 7420 706c     # Fill out pl
-00015110: 6163 6568 6f6c 6465 7273 2e0d 0a20 2020  aceholders...   
-00015120: 2020 2020 2073 716c 5f73 746d 7420 3d20       sql_stmt = 
-00015130: 5f66 696c 6c5f 6f75 745f 7371 6c5f 706c  _fill_out_sql_pl
-00015140: 6163 6568 6f6c 6465 7273 280d 0a20 2020  aceholders(..   
-00015150: 2020 2020 2020 2020 2070 6174 683d 7372           path=sr
-00015160: 632c 206c 6179 6572 3d73 7263 5f6c 6179  c, layer=src_lay
-00015170: 6572 2c20 7371 6c5f 7374 6d74 3d73 716c  er, sql_stmt=sql
-00015180: 5f73 746d 742c 2063 6f6c 756d 6e73 3d63  _stmt, columns=c
-00015190: 6f6c 756d 6e73 0d0a 2020 2020 2020 2020  olumns..        
-000151a0: 290d 0a0d 0a20 2020 2023 2057 6865 6e20  )....    # When 
-000151b0: 6372 6561 7469 6e67 2f61 7070 656e 6469  creating/appendi
-000151c0: 6e67 2074 6f20 6120 7368 6170 6566 696c  ng to a shapefil
-000151d0: 652c 2073 6f6d 6520 6578 7472 6120 7468  e, some extra th
-000151e0: 696e 6773 206e 6565 6420 746f 2062 6520  ings need to be 
-000151f0: 646f 6e65 2f63 6865 636b 6564 2e0d 0a20  done/checked... 
-00015200: 2020 2069 6620 7371 6c5f 7374 6d74 2069     if sql_stmt i
-00015210: 7320 4e6f 6e65 2061 6e64 2064 7374 2e73  s None and dst.s
-00015220: 7566 6669 782e 6c6f 7765 7228 2920 3d3d  uffix.lower() ==
-00015230: 2022 2e73 6870 223a 0d0a 2020 2020 2020   ".shp":..      
-00015240: 2020 2320 4966 2074 6865 2064 6573 7469    # If the desti
-00015250: 6e61 7469 6f6e 2066 696c 6520 646f 6573  nation file does
-00015260: 6e27 7420 6578 6973 7420 7965 742c 2061  n't exist yet, a
-00015270: 6e64 2074 6865 2073 6f75 7263 6520 6669  nd the source fi
-00015280: 6c65 2068 6173 0d0a 2020 2020 2020 2020  le has..        
-00015290: 2320 6765 6f6d 6574 7279 7479 7065 2022  # geometrytype "
-000152a0: 4765 6f6d 6574 7279 222c 2072 6169 7365  Geometry", raise
-000152b0: 2062 6563 6175 7365 2074 7970 6520 6973   because type is
-000152c0: 206e 6f74 2073 7570 706f 7274 6564 2062   not supported b
-000152d0: 7920 7368 7020 2861 6e64 2077 696c 6c0d  y shp (and will.
-000152e0: 0a20 2020 2020 2020 2023 2064 6566 6175  .        # defau
-000152f0: 6c74 2074 6f20 6c69 6e65 7374 7269 6e67  lt to linestring
-00015300: 292e 0d0a 2020 2020 2020 2020 6966 2073  )...        if s
-00015310: 7263 5f6c 6179 6572 696e 666f 2069 7320  rc_layerinfo is 
-00015320: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2020  None:..         
-00015330: 2020 2073 7263 5f6c 6179 6572 696e 666f     src_layerinfo
-00015340: 203d 2067 6574 5f6c 6179 6572 696e 666f   = get_layerinfo
-00015350: 2873 7263 2c20 7372 635f 6c61 7965 722c  (src, src_layer,
-00015360: 2072 6169 7365 5f6f 6e5f 6e6f 6765 6f6d   raise_on_nogeom
-00015370: 3d46 616c 7365 290d 0a20 2020 2020 2020  =False)..       
-00015380: 2069 6620 280d 0a20 2020 2020 2020 2020   if (..         
-00015390: 2020 2066 6f72 6365 5f6f 7574 7075 745f     force_output_
-000153a0: 6765 6f6d 6574 7279 7479 7065 2069 7320  geometrytype is 
-000153b0: 4e6f 6e65 0d0a 2020 2020 2020 2020 2020  None..          
-000153c0: 2020 616e 6420 7372 635f 6c61 7965 7269    and src_layeri
-000153d0: 6e66 6f2e 6765 6f6d 6574 7279 7479 7065  nfo.geometrytype
-000153e0: 0d0a 2020 2020 2020 2020 2020 2020 696e  ..            in
-000153f0: 205b 4765 6f6d 6574 7279 5479 7065 2e47   [GeometryType.G
-00015400: 454f 4d45 5452 592c 2047 656f 6d65 7472  EOMETRY, Geometr
-00015410: 7954 7970 652e 4745 4f4d 4554 5259 434f  yType.GEOMETRYCO
-00015420: 4c4c 4543 5449 4f4e 5d0d 0a20 2020 2020  LLECTION]..     
-00015430: 2020 2020 2020 2061 6e64 206e 6f74 2064         and not d
-00015440: 7374 2e65 7869 7374 7328 290d 0a20 2020  st.exists()..   
-00015450: 2020 2020 2029 3a0d 0a20 2020 2020 2020       ):..       
-00015460: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-00015470: 4572 726f 7228 0d0a 2020 2020 2020 2020  Error(..        
-00015480: 2020 2020 2020 2020 6622 7372 6320 6669          f"src fi
-00015490: 6c65 207b 7372 637d 2068 6173 2067 656f  le {src} has geo
-000154a0: 6d65 7472 7974 7970 6520 7b73 7263 5f6c  metrytype {src_l
-000154b0: 6179 6572 696e 666f 2e67 656f 6d65 7472  ayerinfo.geometr
-000154c0: 7974 7970 656e 616d 657d 2022 0d0a 2020  ytypename} "..  
-000154d0: 2020 2020 2020 2020 2020 2020 2020 2277                "w
-000154e0: 6869 6368 2069 7320 6e6f 7420 7375 7070  hich is not supp
-000154f0: 6f72 7465 6420 696e 202e 7368 702e 204d  orted in .shp. M
-00015500: 6179 6265 2075 7365 2066 6f72 6365 5f6f  aybe use force_o
-00015510: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-00015520: 7065 3f22 0d0a 2020 2020 2020 2020 2020  pe?"..          
-00015530: 2020 290d 0a0d 0a20 2020 2020 2020 2023    )....        #
-00015540: 204c 6175 6e64 6572 2074 6865 2063 6f6c   Launder the col
-00015550: 756d 6e73 206e 616d 6573 2076 6961 2061  umns names via a
-00015560: 2053 514c 2073 7461 7465 6d65 6e74 2c20   SQL statement, 
-00015570: 6f74 6865 7277 6973 6520 7768 656e 2061  otherwise when a
-00015580: 7070 656e 6469 6e67 2074 6865 0d0a 2020  ppending the..  
-00015590: 2020 2020 2020 2320 6c61 756e 6465 7265        # laundere
-000155a0: 6420 636f 6c75 6d6e 7320 7769 6c6c 2067  d columns will g
-000155b0: 6574 204e 554c 4c20 7661 6c75 6573 2069  et NULL values i
-000155c0: 6e73 7465 6164 206f 6620 7468 6520 6461  nstead of the da
-000155d0: 7461 2e0d 0a20 2020 2020 2020 2069 6620  ta...        if 
-000155e0: 636f 6c75 6d6e 7320 6973 204e 6f6e 653a  columns is None:
-000155f0: 0d0a 2020 2020 2020 2020 2020 2020 636f  ..            co
-00015600: 6c75 6d6e 7320 3d20 7372 635f 6c61 7965  lumns = src_laye
-00015610: 7269 6e66 6f2e 636f 6c75 6d6e 730d 0a20  rinfo.columns.. 
-00015620: 2020 2020 2020 2063 6f6c 756d 6e73 5f6c         columns_l
-00015630: 6175 6e64 6572 6564 203d 205f 6c61 756e  aundered = _laun
-00015640: 6465 725f 636f 6c75 6d6e 5f6e 616d 6573  der_column_names
-00015650: 2863 6f6c 756d 6e73 290d 0a20 2020 2020  (columns)..     
-00015660: 2020 2063 6f6c 756d 6e73 5f61 6c69 6173     columns_alias
-00015670: 6564 203d 205b 0d0a 2020 2020 2020 2020  ed = [..        
-00015680: 2020 2020 6627 227b 636f 6c75 6d6e 7d22      f'"{column}"
-00015690: 2041 5320 227b 6c61 756e 6465 7265 647d   AS "{laundered}
-000156a0: 2227 2066 6f72 2063 6f6c 756d 6e2c 206c  "' for column, l
-000156b0: 6175 6e64 6572 6564 2069 6e20 636f 6c75  aundered in colu
-000156c0: 6d6e 735f 6c61 756e 6465 7265 640d 0a20  mns_laundered.. 
-000156d0: 2020 2020 2020 205d 0d0a 2020 2020 2020         ]..      
-000156e0: 2020 2320 4966 2074 6865 7265 2069 7320    # If there is 
-000156f0: 6120 7768 6572 6520 7370 6563 6966 6965  a where specifie
-00015700: 642c 2069 6e74 6567 7261 7465 2069 742e  d, integrate it.
-00015710: 2e2e 0d0a 2020 2020 2020 2020 7768 6572  ....        wher
-00015720: 655f 636c 6175 7365 203d 2022 220d 0a20  e_clause = "".. 
-00015730: 2020 2020 2020 2069 6620 7768 6572 6520         if where 
-00015740: 6973 206e 6f74 204e 6f6e 653a 0d0a 2020  is not None:..  
-00015750: 2020 2020 2020 2020 2020 7768 6572 655f            where_
-00015760: 636c 6175 7365 203d 2066 2257 4845 5245  clause = f"WHERE
-00015770: 207b 7768 6572 657d 220d 0a20 2020 2020   {where}"..     
-00015780: 2020 2020 2020 2077 6865 7265 203d 204e         where = N
-00015790: 6f6e 650d 0a20 2020 2020 2020 2067 656f  one..        geo
-000157a0: 6d65 7472 7963 6f6c 756d 6e20 3d20 2222  metrycolumn = ""
-000157b0: 0d0a 2020 2020 2020 2020 6966 2073 7263  ..        if src
-000157c0: 5f6c 6179 6572 696e 666f 2e67 656f 6d65  _layerinfo.geome
-000157d0: 7472 7963 6f6c 756d 6e20 6973 206e 6f74  trycolumn is not
-000157e0: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-000157f0: 2020 2020 6765 6f6d 6574 7279 636f 6c75      geometrycolu
-00015800: 6d6e 203d 2066 227b 7372 635f 6c61 7965  mn = f"{src_laye
-00015810: 7269 6e66 6f2e 6765 6f6d 6574 7279 636f  rinfo.geometryco
-00015820: 6c75 6d6e 7d2c 2022 0d0a 2020 2020 2020  lumn}, "..      
-00015830: 2020 7371 6c5f 7374 6d74 203d 2066 2222    sql_stmt = f""
-00015840: 220d 0a20 2020 2020 2020 2020 2020 2053  "..            S
-00015850: 454c 4543 5420 7b67 656f 6d65 7472 7963  ELECT {geometryc
-00015860: 6f6c 756d 6e7d 7b22 2c20 222e 6a6f 696e  olumn}{", ".join
-00015870: 2863 6f6c 756d 6e73 5f61 6c69 6173 6564  (columns_aliased
-00015880: 297d 0d0a 2020 2020 2020 2020 2020 2020  )}..            
-00015890: 2020 4652 4f4d 2022 7b73 7263 5f6c 6179    FROM "{src_lay
-000158a0: 6572 7d22 0d0a 2020 2020 2020 2020 2020  er}"..          
-000158b0: 2020 207b 7768 6572 655f 636c 6175 7365     {where_clause
-000158c0: 7d0d 0a20 2020 2020 2020 2022 2222 0d0a  }..        """..
-000158d0: 2020 2020 2020 2020 7371 6c5f 6469 616c          sql_dial
-000158e0: 6563 7420 3d20 2253 514c 4954 4522 0d0a  ect = "SQLITE"..
-000158f0: 2020 2020 2020 2020 636f 6c75 6d6e 7320          columns 
-00015900: 3d20 4e6f 6e65 0d0a 0d0a 2020 2020 2320  = None....    # 
-00015910: 5768 656e 2064 7374 2066 696c 6520 646f  When dst file do
-00015920: 6573 6e27 7420 6578 6973 7420 616e 6420  esn't exist and 
-00015930: 7372 6320 6973 2065 6d70 7479 2066 6f72  src is empty for
-00015940: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-00015950: 7279 7479 7065 2073 686f 756c 6420 6265  rytype should be
-00015960: 0d0a 2020 2020 2320 7370 6563 6966 6965  ..    # specifie
-00015970: 642c 206f 7468 6572 7769 7365 2069 6e76  d, otherwise inv
-00015980: 616c 6964 206f 7574 7075 742e 0d0a 2020  alid output...  
-00015990: 2020 6966 2066 6f72 6365 5f6f 7574 7075    if force_outpu
-000159a0: 745f 6765 6f6d 6574 7279 7479 7065 2069  t_geometrytype i
-000159b0: 7320 4e6f 6e65 2061 6e64 206e 6f74 2064  s None and not d
-000159c0: 7374 2e65 7869 7374 7328 293a 0d0a 2020  st.exists():..  
-000159d0: 2020 2020 2020 6966 2073 7263 5f6c 6179        if src_lay
-000159e0: 6572 696e 666f 2069 7320 4e6f 6e65 3a0d  erinfo is None:.
-000159f0: 0a20 2020 2020 2020 2020 2020 2073 7263  .            src
-00015a00: 5f6c 6179 6572 696e 666f 203d 2067 6574  _layerinfo = get
-00015a10: 5f6c 6179 6572 696e 666f 2873 7263 2c20  _layerinfo(src, 
-00015a20: 7372 635f 6c61 7965 722c 2072 6169 7365  src_layer, raise
-00015a30: 5f6f 6e5f 6e6f 6765 6f6d 3d46 616c 7365  _on_nogeom=False
-00015a40: 290d 0a20 2020 2020 2020 2066 6f72 6365  )..        force
-00015a50: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
-00015a60: 7479 7065 203d 2073 7263 5f6c 6179 6572  type = src_layer
-00015a70: 696e 666f 2e67 656f 6d65 7472 7974 7970  info.geometrytyp
-00015a80: 650d 0a0d 0a20 2020 2023 2047 6f21 0d0a  e....    # Go!..
-00015a90: 2020 2020 7472 616e 736c 6174 655f 696e      translate_in
-00015aa0: 666f 203d 205f 6f67 725f 7574 696c 2e56  fo = _ogr_util.V
-00015ab0: 6563 746f 7254 7261 6e73 6c61 7465 496e  ectorTranslateIn
-00015ac0: 666f 280d 0a20 2020 2020 2020 2069 6e70  fo(..        inp
-00015ad0: 7574 5f70 6174 683d 7372 632c 0d0a 2020  ut_path=src,..  
-00015ae0: 2020 2020 2020 6f75 7470 7574 5f70 6174        output_pat
-00015af0: 683d 6473 742c 0d0a 2020 2020 2020 2020  h=dst,..        
-00015b00: 696e 7075 745f 6c61 7965 7273 3d73 7263  input_layers=src
-00015b10: 5f6c 6179 6572 2c0d 0a20 2020 2020 2020  _layer,..       
-00015b20: 206f 7574 7075 745f 6c61 7965 723d 6473   output_layer=ds
-00015b30: 745f 6c61 7965 722c 0d0a 2020 2020 2020  t_layer,..      
-00015b40: 2020 696e 7075 745f 7372 733d 7372 635f    input_srs=src_
-00015b50: 6372 732c 0d0a 2020 2020 2020 2020 6f75  crs,..        ou
-00015b60: 7470 7574 5f73 7273 3d64 7374 5f63 7273  tput_srs=dst_crs
-00015b70: 2c0d 0a20 2020 2020 2020 2063 6f6c 756d  ,..        colum
-00015b80: 6e73 3d63 6f6c 756d 6e73 2c0d 0a20 2020  ns=columns,..   
-00015b90: 2020 2020 2073 716c 5f73 746d 743d 7371       sql_stmt=sq
-00015ba0: 6c5f 7374 6d74 2c0d 0a20 2020 2020 2020  l_stmt,..       
-00015bb0: 2073 716c 5f64 6961 6c65 6374 3d73 716c   sql_dialect=sql
-00015bc0: 5f64 6961 6c65 6374 2c0d 0a20 2020 2020  _dialect,..     
-00015bd0: 2020 2077 6865 7265 3d77 6865 7265 2c0d     where=where,.
-00015be0: 0a20 2020 2020 2020 2072 6570 726f 6a65  .        reproje
-00015bf0: 6374 3d72 6570 726f 6a65 6374 2c0d 0a20  ct=reproject,.. 
-00015c00: 2020 2020 2020 2074 7261 6e73 6163 7469         transacti
-00015c10: 6f6e 5f73 697a 653d 7472 616e 7361 6374  on_size=transact
-00015c20: 696f 6e5f 7369 7a65 2c0d 0a20 2020 2020  ion_size,..     
-00015c30: 2020 2061 7070 656e 643d 5472 7565 2c0d     append=True,.
-00015c40: 0a20 2020 2020 2020 2075 7064 6174 653d  .        update=
-00015c50: 5472 7565 2c0d 0a20 2020 2020 2020 2065  True,..        e
-00015c60: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
-00015c70: 733d 6578 706c 6f64 6563 6f6c 6c65 6374  s=explodecollect
-00015c80: 696f 6e73 2c0d 0a20 2020 2020 2020 2066  ions,..        f
-00015c90: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-00015ca0: 6574 7279 7479 7065 3d66 6f72 6365 5f6f  etrytype=force_o
-00015cb0: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-00015cc0: 7065 2c0d 0a20 2020 2020 2020 206f 7074  pe,..        opt
-00015cd0: 696f 6e73 3d6f 7074 696f 6e73 2c0d 0a20  ions=options,.. 
-00015ce0: 2020 2020 2020 2070 7265 7365 7276 655f         preserve_
-00015cf0: 6669 643d 7072 6573 6572 7665 5f66 6964  fid=preserve_fid
-00015d00: 2c0d 0a20 2020 2020 2020 2064 7374 5f64  ,..        dst_d
-00015d10: 696d 656e 7369 6f6e 733d 6473 745f 6469  imensions=dst_di
-00015d20: 6d65 6e73 696f 6e73 2c0d 0a20 2020 2029  mensions,..    )
-00015d30: 0d0a 2020 2020 5f6f 6772 5f75 7469 6c2e  ..    _ogr_util.
-00015d40: 7665 6374 6f72 5f74 7261 6e73 6c61 7465  vector_translate
-00015d50: 5f62 795f 696e 666f 2869 6e66 6f3d 7472  _by_info(info=tr
-00015d60: 616e 736c 6174 655f 696e 666f 290d 0a0d  anslate_info)...
-00015d70: 0a0d 0a64 6566 2063 6f6e 7665 7274 280d  ...def convert(.
-00015d80: 0a20 2020 2073 7263 3a20 556e 696f 6e5b  .    src: Union[
-00015d90: 7374 722c 2022 6f73 2e50 6174 684c 696b  str, "os.PathLik
-00015da0: 655b 416e 795d 225d 2c0d 0a20 2020 2064  e[Any]"],..    d
-00015db0: 7374 3a20 556e 696f 6e5b 7374 722c 2022  st: Union[str, "
-00015dc0: 6f73 2e50 6174 684c 696b 655b 416e 795d  os.PathLike[Any]
-00015dd0: 225d 2c0d 0a20 2020 2073 7263 5f6c 6179  "],..    src_lay
-00015de0: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
-00015df0: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2064  ] = None,..    d
-00015e00: 7374 5f6c 6179 6572 3a20 4f70 7469 6f6e  st_layer: Option
-00015e10: 616c 5b73 7472 5d20 3d20 4e6f 6e65 2c0d  al[str] = None,.
-00015e20: 0a20 2020 2073 7263 5f63 7273 3a20 556e  .    src_crs: Un
-00015e30: 696f 6e5b 7374 722c 2069 6e74 2c20 4e6f  ion[str, int, No
-00015e40: 6e65 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  ne] = None,..   
-00015e50: 2064 7374 5f63 7273 3a20 556e 696f 6e5b   dst_crs: Union[
-00015e60: 7374 722c 2069 6e74 2c20 4e6f 6e65 5d20  str, int, None] 
-00015e70: 3d20 4e6f 6e65 2c0d 0a20 2020 2077 6865  = None,..    whe
-00015e80: 7265 3a20 4f70 7469 6f6e 616c 5b73 7472  re: Optional[str
-00015e90: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2072  ] = None,..    r
-00015ea0: 6570 726f 6a65 6374 3a20 626f 6f6c 203d  eproject: bool =
-00015eb0: 2046 616c 7365 2c0d 0a20 2020 2065 7870   False,..    exp
-00015ec0: 6c6f 6465 636f 6c6c 6563 7469 6f6e 733a  lodecollections:
-00015ed0: 2062 6f6f 6c20 3d20 4661 6c73 652c 0d0a   bool = False,..
-00015ee0: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
-00015ef0: 5f67 656f 6d65 7472 7974 7970 653a 2055  _geometrytype: U
-00015f00: 6e69 6f6e 5b47 656f 6d65 7472 7954 7970  nion[GeometryTyp
-00015f10: 652c 2073 7472 2c20 4e6f 6e65 5d20 3d20  e, str, None] = 
-00015f20: 4e6f 6e65 2c0d 0a20 2020 2063 7265 6174  None,..    creat
-00015f30: 655f 7370 6174 6961 6c5f 696e 6465 783a  e_spatial_index:
-00015f40: 204f 7074 696f 6e61 6c5b 626f 6f6c 5d20   Optional[bool] 
-00015f50: 3d20 5472 7565 2c0d 0a20 2020 2070 7265  = True,..    pre
-00015f60: 7365 7276 655f 6669 643a 204f 7074 696f  serve_fid: Optio
-00015f70: 6e61 6c5b 626f 6f6c 5d20 3d20 4e6f 6e65  nal[bool] = None
-00015f80: 2c0d 0a20 2020 206f 7074 696f 6e73 3a20  ,..    options: 
-00015f90: 6469 6374 203d 207b 7d2c 0d0a 2020 2020  dict = {},..    
-00015fa0: 6170 7065 6e64 3a20 626f 6f6c 203d 2046  append: bool = F
-00015fb0: 616c 7365 2c0d 0a20 2020 2066 6f72 6365  alse,..    force
-00015fc0: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-00015fd0: 0a29 3a0d 0a20 2020 2022 2222 0d0a 2020  .):..    """..  
-00015fe0: 2020 4445 5052 4543 4154 4544 3a20 706c    DEPRECATED: pl
-00015ff0: 6561 7365 2075 7365 2063 6f70 795f 6c61  ease use copy_la
-00016000: 7965 722e 0d0a 2020 2020 2222 220d 0a20  yer...    """.. 
-00016010: 2020 2077 6172 6e69 6e67 732e 7761 726e     warnings.warn
-00016020: 2822 636f 6e76 6572 7420 6973 2064 6570  ("convert is dep
-00016030: 7265 6361 7465 643a 2075 7365 2063 6f70  recated: use cop
-00016040: 795f 6c61 7965 722e 222c 2046 7574 7572  y_layer.", Futur
-00016050: 6557 6172 6e69 6e67 2c20 7374 6163 6b6c  eWarning, stackl
-00016060: 6576 656c 3d32 290d 0a20 2020 2072 6574  evel=2)..    ret
-00016070: 7572 6e20 636f 7079 5f6c 6179 6572 280d  urn copy_layer(.
-00016080: 0a20 2020 2020 2020 2073 7263 3d73 7263  .        src=src
-00016090: 2c0d 0a20 2020 2020 2020 2064 7374 3d64  ,..        dst=d
-000160a0: 7374 2c0d 0a20 2020 2020 2020 2073 7263  st,..        src
-000160b0: 5f6c 6179 6572 3d73 7263 5f6c 6179 6572  _layer=src_layer
-000160c0: 2c0d 0a20 2020 2020 2020 2064 7374 5f6c  ,..        dst_l
-000160d0: 6179 6572 3d64 7374 5f6c 6179 6572 2c0d  ayer=dst_layer,.
-000160e0: 0a20 2020 2020 2020 2073 7263 5f63 7273  .        src_crs
-000160f0: 3d73 7263 5f63 7273 2c0d 0a20 2020 2020  =src_crs,..     
-00016100: 2020 2064 7374 5f63 7273 3d64 7374 5f63     dst_crs=dst_c
-00016110: 7273 2c0d 0a20 2020 2020 2020 2077 6865  rs,..        whe
-00016120: 7265 3d77 6865 7265 2c0d 0a20 2020 2020  re=where,..     
-00016130: 2020 2072 6570 726f 6a65 6374 3d72 6570     reproject=rep
-00016140: 726f 6a65 6374 2c0d 0a20 2020 2020 2020  roject,..       
-00016150: 2065 7870 6c6f 6465 636f 6c6c 6563 7469   explodecollecti
-00016160: 6f6e 733d 6578 706c 6f64 6563 6f6c 6c65  ons=explodecolle
-00016170: 6374 696f 6e73 2c0d 0a20 2020 2020 2020  ctions,..       
-00016180: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-00016190: 6f6d 6574 7279 7479 7065 3d66 6f72 6365  ometrytype=force
-000161a0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
-000161b0: 7479 7065 2c0d 0a20 2020 2020 2020 2063  type,..        c
-000161c0: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
-000161d0: 6465 783d 6372 6561 7465 5f73 7061 7469  dex=create_spati
-000161e0: 616c 5f69 6e64 6578 2c0d 0a20 2020 2020  al_index,..     
-000161f0: 2020 2070 7265 7365 7276 655f 6669 643d     preserve_fid=
-00016200: 7072 6573 6572 7665 5f66 6964 2c0d 0a20  preserve_fid,.. 
-00016210: 2020 2020 2020 206f 7074 696f 6e73 3d6f         options=o
-00016220: 7074 696f 6e73 2c0d 0a20 2020 2020 2020  ptions,..       
-00016230: 2061 7070 656e 643d 6170 7065 6e64 2c0d   append=append,.
-00016240: 0a20 2020 2020 2020 2066 6f72 6365 3d66  .        force=f
-00016250: 6f72 6365 2c0d 0a20 2020 2029 0d0a 0d0a  orce,..    )....
-00016260: 0d0a 6465 6620 636f 7079 5f6c 6179 6572  ..def copy_layer
-00016270: 280d 0a20 2020 2073 7263 3a20 556e 696f  (..    src: Unio
-00016280: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
-00016290: 696b 655b 416e 795d 225d 2c0d 0a20 2020  ike[Any]"],..   
-000162a0: 2064 7374 3a20 556e 696f 6e5b 7374 722c   dst: Union[str,
-000162b0: 2022 6f73 2e50 6174 684c 696b 655b 416e   "os.PathLike[An
-000162c0: 795d 225d 2c0d 0a20 2020 2073 7263 5f6c  y]"],..    src_l
-000162d0: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
-000162e0: 7472 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  tr] = None,..   
-000162f0: 2064 7374 5f6c 6179 6572 3a20 4f70 7469   dst_layer: Opti
-00016300: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
-00016310: 2c0d 0a20 2020 2073 7263 5f63 7273 3a20  ,..    src_crs: 
-00016320: 556e 696f 6e5b 7374 722c 2069 6e74 2c20  Union[str, int, 
-00016330: 4e6f 6e65 5d20 3d20 4e6f 6e65 2c0d 0a20  None] = None,.. 
-00016340: 2020 2064 7374 5f63 7273 3a20 556e 696f     dst_crs: Unio
-00016350: 6e5b 7374 722c 2069 6e74 2c20 4e6f 6e65  n[str, int, None
-00016360: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2063  ] = None,..    c
-00016370: 6f6c 756d 6e73 3a20 4f70 7469 6f6e 616c  olumns: Optional
-00016380: 5b49 7465 7261 626c 655b 7374 725d 5d20  [Iterable[str]] 
-00016390: 3d20 4e6f 6e65 2c0d 0a20 2020 2077 6865  = None,..    whe
-000163a0: 7265 3a20 4f70 7469 6f6e 616c 5b73 7472  re: Optional[str
-000163b0: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2073  ] = None,..    s
-000163c0: 716c 5f73 746d 743a 204f 7074 696f 6e61  ql_stmt: Optiona
-000163d0: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
-000163e0: 2020 2020 7371 6c5f 6469 616c 6563 743a      sql_dialect:
-000163f0: 204f 7074 696f 6e61 6c5b 4c69 7465 7261   Optional[Litera
-00016400: 6c5b 2253 514c 4954 4522 2c20 224f 4752  l["SQLITE", "OGR
-00016410: 5351 4c22 5d5d 203d 204e 6f6e 652c 0d0a  SQL"]] = None,..
-00016420: 2020 2020 7265 7072 6f6a 6563 743a 2062      reproject: b
-00016430: 6f6f 6c20 3d20 4661 6c73 652c 0d0a 2020  ool = False,..  
-00016440: 2020 6578 706c 6f64 6563 6f6c 6c65 6374    explodecollect
-00016450: 696f 6e73 3a20 626f 6f6c 203d 2046 616c  ions: bool = Fal
-00016460: 7365 2c0d 0a20 2020 2066 6f72 6365 5f6f  se,..    force_o
-00016470: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
-00016480: 7065 3a20 556e 696f 6e5b 4765 6f6d 6574  pe: Union[Geomet
-00016490: 7279 5479 7065 2c20 7374 722c 204e 6f6e  ryType, str, Non
-000164a0: 655d 203d 204e 6f6e 652c 0d0a 2020 2020  e] = None,..    
-000164b0: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-000164c0: 6e64 6578 3a20 4f70 7469 6f6e 616c 5b62  ndex: Optional[b
-000164d0: 6f6f 6c5d 203d 2054 7275 652c 0d0a 2020  ool] = True,..  
-000164e0: 2020 7072 6573 6572 7665 5f66 6964 3a20    preserve_fid: 
-000164f0: 4f70 7469 6f6e 616c 5b62 6f6f 6c5d 203d  Optional[bool] =
-00016500: 204e 6f6e 652c 0d0a 2020 2020 6473 745f   None,..    dst_
-00016510: 6469 6d65 6e73 696f 6e73 3a20 4f70 7469  dimensions: Opti
-00016520: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
-00016530: 2c0d 0a20 2020 206f 7074 696f 6e73 3a20  ,..    options: 
-00016540: 6469 6374 203d 207b 7d2c 0d0a 2020 2020  dict = {},..    
-00016550: 6170 7065 6e64 3a20 626f 6f6c 203d 2046  append: bool = F
-00016560: 616c 7365 2c0d 0a20 2020 2066 6f72 6365  alse,..    force
-00016570: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-00016580: 0a29 3a0d 0a20 2020 2022 2222 0d0a 2020  .):..    """..  
-00016590: 2020 5265 6164 2061 206c 6179 6572 2066    Read a layer f
-000165a0: 726f 6d20 6120 736f 7572 6365 2066 696c  rom a source fil
-000165b0: 6520 616e 6420 7772 6974 6520 6974 2074  e and write it t
-000165c0: 6f20 6120 6e65 7720 6465 7374 696e 6174  o a new destinat
-000165d0: 696f 6e20 6669 6c65 2e0d 0a0d 0a20 2020  ion file.....   
-000165e0: 2054 7970 6963 616c 6c79 2075 7365 6420   Typically used 
-000165f0: 746f 2063 6f6e 7665 7274 2066 726f 6d20  to convert from 
-00016600: 6f6e 6520 6669 6c65 666f 726d 6174 2074  one fileformat t
-00016610: 6f20 616e 6f74 6865 7220 6f72 2074 6f20  o another or to 
-00016620: 7265 7072 6f6a 6563 742e 0d0a 0d0a 2020  reproject.....  
-00016630: 2020 5468 6520 6f70 7469 6f6e 7320 7061    The options pa
-00016640: 7261 6d65 7465 7220 6361 6e20 6265 2075  rameter can be u
-00016650: 7365 6420 746f 2070 6173 7320 616e 7920  sed to pass any 
-00016660: 7479 7065 206f 6620 6f70 7469 6f6e 7320  type of options 
-00016670: 746f 2047 4441 4c20 696e 0d0a 2020 2020  to GDAL in..    
-00016680: 7468 6520 666f 6c6c 6f77 696e 6720 666f  the following fo
-00016690: 726d 3a0d 0a20 2020 2020 2020 207b 2022  rm:..        { "
-000166a0: 3c6f 7074 696f 6e5f 7479 7065 3e2e 3c6f  <option_type>.<o
-000166b0: 7074 696f 6e5f 6e61 6d65 3e22 3a20 3c6f  ption_name>": <o
-000166c0: 7074 696f 6e5f 7661 6c75 653e 207d 0d0a  ption_value> }..
-000166d0: 0d0a 2020 2020 5468 6520 6f70 7469 6f6e  ..    The option
-000166e0: 2074 7970 6573 2063 616e 2062 6520 616e   types can be an
-000166f0: 7920 6f66 2074 6865 2066 6f6c 6c6f 7769  y of the followi
-00016700: 6e67 3a0d 0a20 2020 2020 2020 202d 204c  ng:..        - L
-00016710: 4159 4552 5f43 5245 4154 494f 4e3a 206c  AYER_CREATION: l
-00016720: 6179 6572 2063 7265 6174 696f 6e20 6f70  ayer creation op
-00016730: 7469 6f6e 2028 6c63 6f29 0d0a 2020 2020  tion (lco)..    
-00016740: 2020 2020 2d20 4441 5441 5345 545f 4352      - DATASET_CR
-00016750: 4541 5449 4f4e 3a20 6461 7461 7365 7420  EATION: dataset 
-00016760: 6372 6561 7469 6f6e 206f 7074 696f 6e20  creation option 
-00016770: 2864 7363 6f29 0d0a 2020 2020 2020 2020  (dsco)..        
-00016780: 2d20 494e 5055 545f 4f50 454e 3a20 696e  - INPUT_OPEN: in
-00016790: 7075 7420 6461 7461 7365 7420 6f70 656e  put dataset open
-000167a0: 206f 7074 696f 6e20 286f 6f29 0d0a 2020   option (oo)..  
-000167b0: 2020 2020 2020 2d20 4445 5354 494e 4154        - DESTINAT
-000167c0: 494f 4e5f 4f50 454e 3a20 6465 7374 696e  ION_OPEN: destin
-000167d0: 6174 696f 6e20 6461 7461 7365 7420 6f70  ation dataset op
-000167e0: 656e 206f 7074 696f 6e20 2864 6f6f 290d  en option (doo).
-000167f0: 0a20 2020 2020 2020 202d 2043 4f4e 4649  .        - CONFI
-00016800: 473a 2063 6f6e 6669 6720 6f70 7469 6f6e  G: config option
-00016810: 2028 636f 6e66 6967 290d 0a0d 0a20 2020   (config)....   
-00016820: 2054 6865 206f 7074 696f 6e73 2063 616e   The options can
-00016830: 2062 6520 666f 756e 6420 696e 2074 6865   be found in the
-00016840: 207c 4744 414c 5f76 6563 746f 725f 6472   |GDAL_vector_dr
-00016850: 6976 6572 5f64 6f63 756d 656e 7461 7469  iver_documentati
-00016860: 6f6e 7c2e 0d0a 0d0a 2020 2020 4172 6773  on|.....    Args
-00016870: 3a0d 0a20 2020 2020 2020 2073 7263 2028  :..        src (
-00016880: 5061 7468 4c69 6b65 293a 2054 6865 2073  PathLike): The s
-00016890: 6f75 7263 6520 6669 6c65 2070 6174 682e  ource file path.
-000168a0: 0d0a 2020 2020 2020 2020 6473 7420 2850  ..        dst (P
-000168b0: 6174 684c 696b 6529 3a20 5468 6520 6465  athLike): The de
-000168c0: 7374 696e 6174 696f 6e20 6669 6c65 2070  stination file p
-000168d0: 6174 682e 0d0a 2020 2020 2020 2020 7372  ath...        sr
-000168e0: 635f 6c61 7965 7220 2873 7472 2c20 6f70  c_layer (str, op
-000168f0: 7469 6f6e 616c 293a 2054 6865 2073 6f75  tional): The sou
-00016900: 7263 6520 6c61 7965 722e 2049 6620 4e6f  rce layer. If No
-00016910: 6e65 2061 6e64 2074 6865 7265 2069 7320  ne and there is 
-00016920: 6f6e 6c79 0d0a 2020 2020 2020 2020 2020  only..          
-00016930: 2020 6f6e 6520 6c61 7965 7220 696e 2074    one layer in t
-00016940: 6865 2073 7263 2066 696c 652c 2074 6861  he src file, tha
-00016950: 7420 6c61 7965 7220 6973 2074 616b 656e  t layer is taken
-00016960: 2e20 4465 6661 756c 7473 2074 6f20 4e6f  . Defaults to No
-00016970: 6e65 2e0d 0a20 2020 2020 2020 2064 7374  ne...        dst
-00016980: 5f6c 6179 6572 2028 7374 722c 206f 7074  _layer (str, opt
-00016990: 696f 6e61 6c29 3a20 5468 6520 6465 7374  ional): The dest
-000169a0: 696e 6174 696f 6e20 6c61 7965 722e 2049  ination layer. I
-000169b0: 6620 4e6f 6e65 2c20 7468 6520 6669 6c65  f None, the file
-000169c0: 0d0a 2020 2020 2020 2020 2020 2020 7374  ..            st
-000169d0: 656d 2069 7320 7461 6b65 6e20 6173 206c  em is taken as l
-000169e0: 6179 6572 206e 616d 652e 2044 6566 6175  ayer name. Defau
-000169f0: 6c74 7320 746f 204e 6f6e 652e 0d0a 2020  lts to None...  
-00016a00: 2020 2020 2020 7372 635f 6372 7320 2855        src_crs (U
-00016a10: 6e69 6f6e 5b73 7472 2c20 696e 745d 2c20  nion[str, int], 
-00016a20: 6f70 7469 6f6e 616c 293a 2061 6e20 6570  optional): an ep
-00016a30: 7367 2069 6e74 206f 7220 616e 7974 6869  sg int or anythi
-00016a40: 6e67 2073 7570 706f 7274 6564 0d0a 2020  ng supported..  
-00016a50: 2020 2020 2020 2020 2020 6279 2074 6865            by the
-00016a60: 204f 4752 5370 6174 6961 6c52 6566 6572   OGRSpatialRefer
-00016a70: 656e 6365 2e53 6574 4672 6f6d 5573 6572  ence.SetFromUser
-00016a80: 496e 7075 7428 2920 6361 6c6c 2c20 7768  Input() call, wh
-00016a90: 6963 6820 696e 636c 7564 6573 0d0a 2020  ich includes..  
-00016aa0: 2020 2020 2020 2020 2020 616e 2045 5053            an EPS
-00016ab0: 4720 7374 7269 6e67 2028 6567 2e20 2245  G string (eg. "E
-00016ac0: 5053 473a 3433 3236 2229 2c20 6120 7765  PSG:4326"), a we
-00016ad0: 6c6c 206b 6e6f 776e 2074 6578 7420 2857  ll known text (W
-00016ae0: 4b54 2920 4352 530d 0a20 2020 2020 2020  KT) CRS..       
-00016af0: 2020 2020 2064 6566 696e 6974 696f 6e2c       definition,
-00016b00: 2e2e 2e20 4465 6661 756c 7473 2074 6f20  ... Defaults to 
-00016b10: 4e6f 6e65 2e0d 0a20 2020 2020 2020 2064  None...        d
-00016b20: 7374 5f63 7273 2028 556e 696f 6e5b 7374  st_crs (Union[st
-00016b30: 722c 2069 6e74 5d2c 206f 7074 696f 6e61  r, int], optiona
-00016b40: 6c29 3a20 616e 2065 7073 6720 696e 7420  l): an epsg int 
-00016b50: 6f72 2061 6e79 7468 696e 6720 7375 7070  or anything supp
-00016b60: 6f72 7465 640d 0a20 2020 2020 2020 2020  orted..         
-00016b70: 2020 2062 7920 7468 6520 4f47 5253 7061     by the OGRSpa
-00016b80: 7469 616c 5265 6665 7265 6e63 652e 5365  tialReference.Se
-00016b90: 7446 726f 6d55 7365 7249 6e70 7574 2829  tFromUserInput()
-00016ba0: 2063 616c 6c2c 2077 6869 6368 2069 6e63   call, which inc
-00016bb0: 6c75 6465 730d 0a20 2020 2020 2020 2020  ludes..         
-00016bc0: 2020 2061 6e20 4550 5347 2073 7472 696e     an EPSG strin
-00016bd0: 6720 2865 672e 2022 4550 5347 3a34 3332  g (eg. "EPSG:432
-00016be0: 3622 292c 2061 2077 656c 6c20 6b6e 6f77  6"), a well know
-00016bf0: 6e20 7465 7874 2028 574b 5429 2043 5253  n text (WKT) CRS
-00016c00: 0d0a 2020 2020 2020 2020 2020 2020 6465  ..            de
-00016c10: 6669 6e69 7469 6f6e 2c2e 2e2e 2044 6566  finition,... Def
-00016c20: 6175 6c74 7320 746f 204e 6f6e 652e 0d0a  aults to None...
-00016c30: 2020 2020 2020 2020 636f 6c75 6d6e 7320          columns 
-00016c40: 2849 7465 7261 626c 655b 7374 725d 2c20  (Iterable[str], 
-00016c50: 6f70 7469 6f6e 616c 293a 2054 6865 2028  optional): The (
-00016c60: 6e6f 6e2d 6765 6f6d 6574 7279 2920 636f  non-geometry) co
-00016c70: 6c75 6d6e 7320 746f 2072 6561 6420 7769  lumns to read wi
-00016c80: 6c6c 0d0a 2020 2020 2020 2020 2020 2020  ll..            
-00016c90: 6265 2072 6574 7572 6e65 6420 696e 2074  be returned in t
-00016ca0: 6865 206f 7264 6572 2073 7065 6369 6669  he order specifi
-00016cb0: 6564 2e20 4966 204e 6f6e 652c 2061 6c6c  ed. If None, all
-00016cc0: 2073 7461 6e64 6172 6420 636f 6c75 6d6e   standard column
-00016cd0: 7320 6172 6520 7265 6164 2e0d 0a20 2020  s are read...   
-00016ce0: 2020 2020 2020 2020 2049 6e20 6164 6469           In addi
-00016cf0: 7469 6f6e 2074 6f20 7374 616e 6461 7264  tion to standard
-00016d00: 2063 6f6c 756d 6e73 2c20 6974 2069 7320   columns, it is 
-00016d10: 616c 736f 2070 6f73 7369 626c 650d 0a20  also possible.. 
-00016d20: 2020 2020 2020 2020 2020 2074 6f20 7370             to sp
-00016d30: 6563 6966 7920 2266 6964 222c 2061 2075  ecify "fid", a u
-00016d40: 6e69 7175 6520 696e 6465 7820 6176 6169  nique index avai
-00016d50: 6c61 626c 6520 696e 2061 6c6c 2069 6e70  lable in all inp
-00016d60: 7574 2066 696c 6573 2e20 4e6f 7465 2074  ut files. Note t
-00016d70: 6861 7420 7468 650d 0a20 2020 2020 2020  hat the..       
-00016d80: 2020 2020 2022 6669 6422 2077 696c 6c20       "fid" will 
-00016d90: 6265 2061 6c69 6173 6564 2065 672e 2074  be aliased eg. t
-00016da0: 6f20 2266 6964 5f31 222e 2044 6566 6175  o "fid_1". Defau
-00016db0: 6c74 7320 746f 204e 6f6e 652e 0d0a 2020  lts to None...  
-00016dc0: 2020 2020 2020 7768 6572 6520 2873 7472        where (str
-00016dd0: 2c20 6f70 7469 6f6e 616c 293a 206f 6e6c  , optional): onl
-00016de0: 7920 6170 7065 6e64 2074 6865 2072 6f77  y append the row
-00016df0: 7320 6672 6f6d 2073 7263 2074 6861 7420  s from src that 
-00016e00: 636f 6d70 6c79 2074 6f20 7468 6520 6669  comply to the fi
-00016e10: 6c74 6572 0d0a 2020 2020 2020 2020 2020  lter..          
-00016e20: 2020 7370 6563 6966 6965 642e 2041 7070    specified. App
-00016e30: 6c69 6564 2062 6566 6f72 6520 6060 6578  lied before ``ex
-00016e40: 706c 6f64 6563 6f6c 6c65 6374 696f 6e73  plodecollections
-00016e50: 6060 2e20 4669 6c74 6572 2073 686f 756c  ``. Filter shoul
-00016e60: 6420 6265 2069 6e20 7371 6c69 7465 0d0a  d be in sqlite..
-00016e70: 2020 2020 2020 2020 2020 2020 5351 4c20              SQL 
-00016e80: 5748 4552 4520 7379 6e74 6178 2061 6e64  WHERE syntax and
-00016e90: 207c 7370 6174 6961 6c69 7465 5f72 6566   |spatialite_ref
-00016ea0: 6572 656e 6365 5f6c 696e 6b7c 2066 756e  erence_link| fun
-00016eb0: 6374 696f 6e73 2063 616e 2062 6520 7573  ctions can be us
-00016ec0: 6564 2e20 4966 0d0a 2020 2020 2020 2020  ed. If..        
-00016ed0: 2020 2020 7768 6572 6520 636f 6e74 6169      where contai
-00016ee0: 6e73 2074 6865 207b 6765 6f6d 6574 7279  ns the {geometry
-00016ef0: 636f 6c75 6d6e 7d20 706c 6163 6568 6f6c  column} placehol
-00016f00: 6465 722c 2069 7420 6973 2066 696c 6c65  der, it is fille
-00016f10: 6420 6f75 7420 7769 7468 2074 6865 0d0a  d out with the..
-00016f20: 2020 2020 2020 2020 2020 2020 6765 6f6d              geom
-00016f30: 6574 7279 2063 6f6c 756d 6e20 6e61 6d65  etry column name
-00016f40: 206f 6620 7468 6520 7372 6320 6669 6c65   of the src file
-00016f50: 2e20 4465 6661 756c 7473 2074 6f20 4e6f  . Defaults to No
-00016f60: 6e65 2e0d 0a20 2020 2020 2020 2073 716c  ne...        sql
-00016f70: 5f73 746d 7420 2873 7472 293a 2053 514c  _stmt (str): SQL
-00016f80: 2073 7461 7465 6d65 6e74 2074 6f20 7573   statement to us
-00016f90: 652e 204f 6e6c 7920 7375 7070 6f72 7465  e. Only supporte
-00016fa0: 6420 7769 7468 2022 7079 6f67 7269 6f22  d with "pyogrio"
-00016fb0: 2065 6e67 696e 652e 0d0a 2020 2020 2020   engine...      
-00016fc0: 2020 7371 6c5f 6469 616c 6563 7420 2873    sql_dialect (s
-00016fd0: 7472 2c20 6f70 7469 6f6e 616c 293a 2053  tr, optional): S
-00016fe0: 514c 2064 6961 6c65 6374 2075 7365 642e  QL dialect used.
-00016ff0: 204f 7074 696f 6e73 2061 7265 204e 6f6e   Options are Non
-00017000: 652c 2022 5351 4c49 5445 2220 6f72 0d0a  e, "SQLITE" or..
-00017010: 2020 2020 2020 2020 2020 2020 224f 4752              "OGR
-00017020: 5351 4c22 2e20 4966 204e 6f6e 652c 2066  SQL". If None, f
-00017030: 6f72 2064 6174 6120 736f 7572 6365 7320  or data sources 
-00017040: 7769 7468 2065 7870 6c69 6369 7420 5351  with explicit SQ
-00017050: 4c20 7375 7070 6f72 7420 7468 6520 7374  L support the st
-00017060: 6174 656d 656e 740d 0a20 2020 2020 2020  atement..       
-00017070: 2020 2020 2069 7320 7072 6f63 6573 7365       is processe
-00017080: 6420 6279 2074 6865 2064 6566 6175 6c74  d by the default
-00017090: 2053 514c 2065 6e67 696e 6520 2865 2e67   SQL engine (e.g
-000170a0: 2e20 666f 7220 4765 6f70 6163 6b61 6765  . for Geopackage
-000170b0: 2061 6e64 2053 7061 7469 616c 6974 650d   and Spatialite.
-000170c0: 0a20 2020 2020 2020 2020 2020 2074 6869  .            thi
-000170d0: 7320 6973 2022 5351 4c49 5445 2229 2e20  s is "SQLITE"). 
-000170e0: 466f 7220 6461 7461 2073 6f75 7263 6573  For data sources
-000170f0: 2077 6974 686f 7574 206e 6174 6976 6520   without native 
-00017100: 5351 4c20 7375 7070 6f72 7420 2865 2e67  SQL support (e.g
-00017110: 2e20 2e73 6870 292c 0d0a 2020 2020 2020  . .shp),..      
-00017120: 2020 2020 2020 7468 6520 224f 4752 5351        the "OGRSQ
-00017130: 4c22 2064 6961 6c65 6374 2069 7320 7468  L" dialect is th
-00017140: 6520 6465 6661 756c 742e 2049 6620 7468  e default. If th
-00017150: 6520 2253 514c 4954 4522 2064 6961 6c65  e "SQLITE" diale
-00017160: 6374 2069 7320 7370 6563 6966 6965 642c  ct is specified,
-00017170: 0d0a 2020 2020 2020 2020 2020 2020 7c73  ..            |s
-00017180: 7061 7469 616c 6974 655f 7265 6665 7265  patialite_refere
-00017190: 6e63 655f 6c69 6e6b 7c20 6675 6e63 7469  nce_link| functi
-000171a0: 6f6e 7320 6361 6e20 616c 736f 2062 6520  ons can also be 
-000171b0: 7573 6564 2e20 4465 6661 756c 7473 2074  used. Defaults t
-000171c0: 6f20 4e6f 6e65 2e0d 0a20 2020 2020 2020  o None...       
-000171d0: 2072 6570 726f 6a65 6374 2028 626f 6f6c   reproject (bool
-000171e0: 2c20 6f70 7469 6f6e 616c 293a 2054 7275  , optional): Tru
-000171f0: 6520 746f 2072 6570 726f 6a65 6374 2077  e to reproject w
-00017200: 6869 6c65 2063 6f6e 7665 7274 696e 6720  hile converting 
-00017210: 7468 650d 0a20 2020 2020 2020 2020 2020  the..           
-00017220: 2066 696c 652e 2044 6566 6175 6c74 7320   file. Defaults 
-00017230: 746f 2046 616c 7365 2e0d 0a20 2020 2020  to False...     
-00017240: 2020 2065 7870 6c6f 6465 636f 6c6c 6563     explodecollec
-00017250: 7469 6f6e 7320 2862 6f6f 6c2c 206f 7074  tions (bool, opt
-00017260: 696f 6e61 6c29 3a20 5472 7565 2074 6f20  ional): True to 
-00017270: 6f75 7470 7574 206f 6e6c 7920 7369 6d70  output only simp
-00017280: 6c65 0d0a 2020 2020 2020 2020 2020 2020  le..            
-00017290: 6765 6f6d 6574 7269 6573 2e20 4465 6661  geometries. Defa
-000172a0: 756c 7473 2074 6f20 4661 6c73 652e 0d0a  ults to False...
-000172b0: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
-000172c0: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
-000172d0: 6520 2855 6e69 6f6e 5b47 656f 6d65 7472  e (Union[Geometr
-000172e0: 7954 7970 652c 2073 7472 5d2c 206f 7074  yType, str], opt
-000172f0: 696f 6e61 6c29 3a20 4765 6f6d 6574 7279  ional): Geometry
-00017300: 2074 7970 652e 0d0a 2020 2020 2020 2020   type...        
-00017310: 2020 2020 746f 2028 7472 7920 746f 2920      to (try to) 
-00017320: 666f 7263 6520 7468 6520 6f75 7470 7574  force the output
-00017330: 2074 6f2e 2044 6566 6175 6c74 7320 746f   to. Defaults to
-00017340: 204e 6f6e 652e 0d0a 2020 2020 2020 2020   None...        
-00017350: 6372 6561 7465 5f73 7061 7469 616c 5f69  create_spatial_i
-00017360: 6e64 6578 2028 626f 6f6c 2c20 6f70 7469  ndex (bool, opti
-00017370: 6f6e 616c 293a 2054 7275 6520 746f 2063  onal): True to c
-00017380: 7265 6174 6520 6120 7370 6174 6961 6c20  reate a spatial 
-00017390: 696e 6465 780d 0a20 2020 2020 2020 2020  index..         
-000173a0: 2020 206f 6e20 7468 6520 6465 7374 696e     on the destin
-000173b0: 6174 696f 6e20 6669 6c65 2f6c 6179 6572  ation file/layer
-000173c0: 2e20 4966 204e 6f6e 652c 2074 6865 2064  . If None, the d
-000173d0: 6566 6175 6c74 2062 6568 6176 696f 7572  efault behaviour
-000173e0: 2062 7920 6764 616c 2066 6f72 0d0a 2020   by gdal for..  
-000173f0: 2020 2020 2020 2020 2020 7468 6174 2066            that f
-00017400: 696c 6520 7479 7065 2069 7320 7265 7370  ile type is resp
-00017410: 6563 7465 642e 2049 6620 7468 6520 4c41  ected. If the LA
-00017420: 5945 525f 4352 4541 5449 4f4e 2e53 5041  YER_CREATION.SPA
-00017430: 5449 414c 5f49 4e44 4558 0d0a 2020 2020  TIAL_INDEX..    
-00017440: 2020 2020 2020 2020 7061 7261 6d65 7465          paramete
-00017450: 7220 6973 2073 7065 6369 6669 6564 2069  r is specified i
-00017460: 6e20 6f70 7469 6f6e 732c 2063 7265 6174  n options, creat
-00017470: 655f 7370 6174 6961 6c5f 696e 6465 7820  e_spatial_index 
-00017480: 6973 2069 676e 6f72 6564 2e0d 0a20 2020  is ignored...   
-00017490: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
-000174a0: 7320 746f 2054 7275 652e 0d0a 2020 2020  s to True...    
-000174b0: 2020 2020 7072 6573 6572 7665 5f66 6964      preserve_fid
-000174c0: 2028 626f 6f6c 2c20 6f70 7469 6f6e 616c   (bool, optional
-000174d0: 293a 2054 7275 6520 746f 206d 616b 6520  ): True to make 
-000174e0: 616e 2065 7874 7261 2065 6666 6f72 7420  an extra effort 
-000174f0: 746f 2070 7265 7365 7276 6520 6669 6427  to preserve fid'
-00017500: 7320 6f66 0d0a 2020 2020 2020 2020 2020  s of..          
-00017510: 2020 7468 6520 736f 7572 6365 206c 6179    the source lay
-00017520: 6572 2074 6f20 7468 6520 6465 7374 696e  er to the destin
-00017530: 6174 696f 6e20 6c61 7965 722e 2046 616c  ation layer. Fal
-00017540: 7365 206e 6f74 2074 6f20 646f 2061 6e79  se not to do any
-00017550: 2065 6666 6f72 742e 204e 6f6e 650d 0a20   effort. None.. 
-00017560: 2020 2020 2020 2020 2020 2074 6f20 7573             to us
-00017570: 6520 7468 6520 6465 6661 756c 7420 6265  e the default be
-00017580: 6861 7669 6f75 7220 6f66 2067 6461 6c2c  haviour of gdal,
-00017590: 2074 6861 7420 616c 7265 6164 7920 7072   that already pr
-000175a0: 6573 6572 7665 7320 696e 2073 6f6d 6520  eserves in some 
-000175b0: 6361 7365 732e 0d0a 2020 2020 2020 2020  cases...        
-000175c0: 2020 2020 536f 6d65 2066 696c 6520 666f      Some file fo
-000175d0: 726d 6174 7320 646f 6e27 7420 6578 706c  rmats don't expl
-000175e0: 6963 6974 6c79 2073 746f 7265 2074 6865  icitly store the
-000175f0: 2066 6964 2028 652e 672e 2073 6861 7065   fid (e.g. shape
-00017600: 6669 6c65 292c 2073 6f20 7468 6579 0d0a  file), so they..
-00017610: 2020 2020 2020 2020 2020 2020 7769 6c6c              will
-00017620: 206e 6576 6572 2062 6520 6162 6c65 2074   never be able t
-00017630: 6f20 7072 6573 6572 7665 2066 6964 732e  o preserve fids.
-00017640: 2044 6566 6175 6c74 7320 746f 204e 6f6e   Defaults to Non
-00017650: 652e 0d0a 2020 2020 2020 2020 6473 745f  e...        dst_
-00017660: 6469 6d65 6e73 696f 6e73 2028 7374 722c  dimensions (str,
-00017670: 206f 7074 696f 6e61 6c29 3a20 466f 7263   optional): Forc
-00017680: 6520 7468 6520 6469 6d65 6e73 696f 6e73  e the dimensions
-00017690: 206f 6620 7468 6520 6465 7374 696e 6174   of the destinat
-000176a0: 696f 6e20 6c61 7965 7220 746f 0d0a 2020  ion layer to..  
-000176b0: 2020 2020 2020 2020 2020 7468 6520 7661            the va
-000176c0: 6c75 6520 7370 6563 6966 6965 642e 2056  lue specified. V
-000176d0: 616c 6964 2076 616c 7565 733a 2022 5859  alid values: "XY
-000176e0: 222c 2022 5859 5a22 2c20 2258 594d 2220  ", "XYZ", "XYM" 
-000176f0: 6f72 2022 5859 5a4d 222e 0d0a 2020 2020  or "XYZM"...    
-00017700: 2020 2020 2020 2020 4465 6661 756c 7473          Defaults
-00017710: 2074 6f20 4e6f 6e65 2e0d 0a20 2020 2020   to None...     
-00017720: 2020 206f 7074 696f 6e73 2028 6469 6374     options (dict
-00017730: 2c20 6f70 7469 6f6e 616c 293a 206f 7074  , optional): opt
-00017740: 696f 6e73 2074 6f20 7061 7373 2074 6f20  ions to pass to 
-00017750: 6764 616c 2e0d 0a20 2020 2020 2020 2061  gdal...        a
-00017760: 7070 656e 6420 2862 6f6f 6c2c 206f 7074  ppend (bool, opt
-00017770: 696f 6e61 6c29 3a20 5472 7565 2074 6f20  ional): True to 
-00017780: 6170 7065 6e64 2074 6f20 7468 6520 6f75  append to the ou
-00017790: 7470 7574 2066 696c 6520 6966 2069 7420  tput file if it 
-000177a0: 6578 6973 7473 2e0d 0a20 2020 2020 2020  exists...       
-000177b0: 2020 2020 2044 6566 6175 6c74 7320 746f       Defaults to
-000177c0: 2046 616c 7365 2e0d 0a20 2020 2020 2020   False...       
-000177d0: 2066 6f72 6365 2028 626f 6f6c 2c20 6f70   force (bool, op
-000177e0: 7469 6f6e 616c 293a 206f 7665 7277 7269  tional): overwri
-000177f0: 7465 2065 7869 7374 696e 6720 6f75 7470  te existing outp
-00017800: 7574 2066 696c 6528 7329 0d0a 2020 2020  ut file(s)..    
-00017810: 2020 2020 2020 2020 4465 6661 756c 7473          Defaults
-00017820: 2074 6f20 4661 6c73 652e 0d0a 0d0a 2020   to False.....  
-00017830: 2020 2e2e 207c 7370 6174 6961 6c69 7465    .. |spatialite
-00017840: 5f72 6566 6572 656e 6365 5f6c 696e 6b7c  _reference_link|
-00017850: 2072 6177 3a3a 2068 746d 6c0d 0a0d 0a20   raw:: html.... 
-00017860: 2020 2020 2020 203c 6120 6872 6566 3d22         <a href="
-00017870: 6874 7470 733a 2f2f 7777 772e 6761 6961  https://www.gaia
-00017880: 2d67 6973 2e69 742f 6761 6961 2d73 696e  -gis.it/gaia-sin
-00017890: 732f 7370 6174 6961 6c69 7465 2d73 716c  s/spatialite-sql
-000178a0: 2d6c 6174 6573 742e 6874 6d6c 2220 7461  -latest.html" ta
-000178b0: 7267 6574 3d22 5f62 6c61 6e6b 223e 7370  rget="_blank">sp
-000178c0: 6174 6961 6c69 7465 2072 6566 6572 656e  atialite referen
-000178d0: 6365 3c2f 613e 0d0a 0d0a 2020 2020 2e2e  ce</a>....    ..
-000178e0: 207c 4744 414c 5f76 6563 746f 725f 6472   |GDAL_vector_dr
-000178f0: 6976 6572 5f64 6f63 756d 656e 7461 7469  iver_documentati
-00017900: 6f6e 7c20 7261 773a 3a20 6874 6d6c 0d0a  on| raw:: html..
-00017910: 0d0a 2020 2020 2020 2020 3c61 2068 7265  ..        <a hre
-00017920: 663d 2268 7474 7073 3a2f 2f67 6461 6c2e  f="https://gdal.
-00017930: 6f72 672f 6472 6976 6572 732f 7665 6374  org/drivers/vect
-00017940: 6f72 2f69 6e64 6578 2e68 746d 6c22 2074  or/index.html" t
-00017950: 6172 6765 743d 225f 626c 616e 6b22 3e47  arget="_blank">G
-00017960: 4441 4c20 7665 6374 6f72 2064 7269 7665  DAL vector drive
-00017970: 7220 646f 6375 6d65 6e74 6174 696f 6e3c  r documentation<
-00017980: 2f61 3e0d 0a0d 0a20 2020 2022 2222 2020  /a>....    """  
-00017990: 2320 6e6f 7161 3a20 4535 3031 0d0a 2020  # noqa: E501..  
-000179a0: 2020 2320 496e 6974 0d0a 2020 2020 7372    # Init..    sr
-000179b0: 6320 3d20 5061 7468 2873 7263 290d 0a20  c = Path(src).. 
-000179c0: 2020 2064 7374 203d 2050 6174 6828 6473     dst = Path(ds
-000179d0: 7429 0d0a 0d0a 2020 2020 2320 4966 2073  t)....    # If s
-000179e0: 6f75 7263 6520 6669 6c65 2064 6f65 736e  ource file doesn
-000179f0: 2774 2065 7869 7374 2c20 7261 6973 6520  't exist, raise 
-00017a00: 6572 726f 720d 0a20 2020 2069 6620 6e6f  error..    if no
-00017a10: 7420 7372 632e 6578 6973 7473 2829 3a0d  t src.exists():.
-00017a20: 0a20 2020 2020 2020 2072 6169 7365 2056  .        raise V
-00017a30: 616c 7565 4572 726f 7228 6622 7372 6320  alueError(f"src 
-00017a40: 6669 6c65 2064 6f65 736e 2774 2065 7869  file doesn't exi
-00017a50: 7374 3a20 7b73 7263 7d22 290d 0a20 2020  st: {src}")..   
-00017a60: 2023 2049 6620 6465 7374 2066 696c 6520   # If dest file 
-00017a70: 6578 6973 7473 2061 6c72 6561 6479 2061  exists already a
-00017a80: 6e64 206e 6f20 6170 7065 6e64 0d0a 2020  nd no append..  
-00017a90: 2020 6966 206e 6f74 2061 7070 656e 6420    if not append 
-00017aa0: 616e 6420 6473 742e 6578 6973 7473 2829  and dst.exists()
-00017ab0: 3a0d 0a20 2020 2020 2020 2069 6620 666f  :..        if fo
-00017ac0: 7263 6520 6973 2054 7275 653a 0d0a 2020  rce is True:..  
-00017ad0: 2020 2020 2020 2020 2020 7265 6d6f 7665            remove
-00017ae0: 2864 7374 290d 0a20 2020 2020 2020 2065  (dst)..        e
-00017af0: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-00017b00: 2020 6c6f 6767 6572 2e69 6e66 6f28 6622    logger.info(f"
-00017b10: 4f75 7470 7574 2066 696c 6520 6578 6973  Output file exis
-00017b20: 7473 2061 6c72 6561 6479 2c20 736f 2073  ts already, so s
-00017b30: 746f 703a 207b 6473 747d 2229 0d0a 2020  top: {dst}")..  
-00017b40: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00017b50: 0d0a 0d0a 2020 2020 2320 436f 6e76 6572  ....    # Conver
-00017b60: 740d 0a20 2020 206c 6f67 6765 722e 696e  t..    logger.in
-00017b70: 666f 2866 2243 6f70 7920 6c61 7965 7220  fo(f"Copy layer 
-00017b80: 6672 6f6d 207b 7372 637d 2074 6f20 7b64  from {src} to {d
-00017b90: 7374 7d22 290d 0a20 2020 205f 6170 7065  st}")..    _appe
-00017ba0: 6e64 5f74 6f5f 6e6f 6c6f 636b 280d 0a20  nd_to_nolock(.. 
-00017bb0: 2020 2020 2020 2073 7263 2c0d 0a20 2020         src,..   
-00017bc0: 2020 2020 2064 7374 2c0d 0a20 2020 2020       dst,..     
-00017bd0: 2020 2073 7263 5f6c 6179 6572 2c0d 0a20     src_layer,.. 
-00017be0: 2020 2020 2020 2064 7374 5f6c 6179 6572         dst_layer
-00017bf0: 2c0d 0a20 2020 2020 2020 2073 7263 5f63  ,..        src_c
-00017c00: 7273 3d73 7263 5f63 7273 2c0d 0a20 2020  rs=src_crs,..   
-00017c10: 2020 2020 2064 7374 5f63 7273 3d64 7374       dst_crs=dst
-00017c20: 5f63 7273 2c0d 0a20 2020 2020 2020 2063  _crs,..        c
-00017c30: 6f6c 756d 6e73 3d63 6f6c 756d 6e73 2c0d  olumns=columns,.
-00017c40: 0a20 2020 2020 2020 2077 6865 7265 3d77  .        where=w
-00017c50: 6865 7265 2c0d 0a20 2020 2020 2020 2073  here,..        s
-00017c60: 716c 5f73 746d 743d 7371 6c5f 7374 6d74  ql_stmt=sql_stmt
-00017c70: 2c0d 0a20 2020 2020 2020 2073 716c 5f64  ,..        sql_d
-00017c80: 6961 6c65 6374 3d73 716c 5f64 6961 6c65  ialect=sql_diale
-00017c90: 6374 2c0d 0a20 2020 2020 2020 2072 6570  ct,..        rep
-00017ca0: 726f 6a65 6374 3d72 6570 726f 6a65 6374  roject=reproject
-00017cb0: 2c0d 0a20 2020 2020 2020 2065 7870 6c6f  ,..        explo
-00017cc0: 6465 636f 6c6c 6563 7469 6f6e 733d 6578  decollections=ex
-00017cd0: 706c 6f64 6563 6f6c 6c65 6374 696f 6e73  plodecollections
-00017ce0: 2c0d 0a20 2020 2020 2020 2066 6f72 6365  ,..        force
-00017cf0: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
-00017d00: 7479 7065 3d66 6f72 6365 5f6f 7574 7075  type=force_outpu
-00017d10: 745f 6765 6f6d 6574 7279 7479 7065 2c0d  t_geometrytype,.
-00017d20: 0a20 2020 2020 2020 2063 7265 6174 655f  .        create_
-00017d30: 7370 6174 6961 6c5f 696e 6465 783d 6372  spatial_index=cr
-00017d40: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
-00017d50: 6578 2c0d 0a20 2020 2020 2020 2070 7265  ex,..        pre
-00017d60: 7365 7276 655f 6669 643d 7072 6573 6572  serve_fid=preser
-00017d70: 7665 5f66 6964 2c0d 0a20 2020 2020 2020  ve_fid,..       
-00017d80: 2064 7374 5f64 696d 656e 7369 6f6e 733d   dst_dimensions=
-00017d90: 6473 745f 6469 6d65 6e73 696f 6e73 2c0d  dst_dimensions,.
-00017da0: 0a20 2020 2020 2020 206f 7074 696f 6e73  .        options
-00017db0: 3d6f 7074 696f 6e73 2c0d 0a20 2020 2029  =options,..    )
-00017dc0: 0d0a 0d0a 0d0a 6465 6620 5f6c 6175 6e64  ......def _laund
-00017dd0: 6572 5f63 6f6c 756d 6e5f 6e61 6d65 7328  er_column_names(
-00017de0: 636f 6c75 6d6e 733a 2049 7465 7261 626c  columns: Iterabl
-00017df0: 6529 202d 3e20 4c69 7374 5b54 7570 6c65  e) -> List[Tuple
-00017e00: 5b73 7472 2c20 7374 725d 5d3a 0d0a 2020  [str, str]]:..  
-00017e10: 2020 2222 220d 0a20 2020 204c 6175 6e64    """..    Laund
-00017e20: 6572 7320 7468 6520 636f 6c75 6d6e 206e  ers the column n
-00017e30: 616d 6573 2070 6173 7365 6420 746f 2063  ames passed to c
-00017e40: 6f6d 706c 7920 7769 7468 2073 6861 7065  omply with shape
-00017e50: 6669 6c65 2072 6573 7472 6963 7469 6f6e  file restriction
-00017e60: 732e 0d0a 0d0a 2020 2020 5261 7469 6f6e  s.....    Ration
-00017e70: 616c 653a 206e 6f72 6d61 6c6c 7920 6764  ale: normally gd
-00017e80: 616c 206c 6175 6e64 6572 7320 7468 656d  al launders them
-00017e90: 2069 6620 6e65 6564 6564 2c20 6275 7420   if needed, but 
-00017ea0: 7768 656e 2079 6f75 2061 7070 656e 640d  when you append.
-00017eb0: 0a20 2020 206d 756c 7469 706c 6520 6669  .    multiple fi
-00017ec0: 6c65 7320 746f 2061 2073 6861 7065 6669  les to a shapefi
-00017ed0: 6c65 2077 6974 6820 636f 6c75 6d6e 7320  le with columns 
-00017ee0: 7468 6174 206e 6565 6420 746f 2062 6520  that need to be 
-00017ef0: 6c61 756e 6465 7265 640d 0a20 2020 2074  laundered..    t
-00017f00: 6865 7920 6172 6520 6e6f 7420 6d61 7463  hey are not matc
-00017f10: 6865 6420 616e 6420 736f 2061 7265 2061  hed and so are a
-00017f20: 7070 656e 6465 6420 7769 7468 204e 554c  ppended with NUL
-00017f30: 4c20 7661 6c75 6573 2066 6f72 2074 6865  L values for the
-00017f40: 7365 0d0a 2020 2020 636f 6c75 6d6e 732e  se..    columns.
-00017f50: 204e 6f72 6d61 6c6c 7920 7468 6520 2d72   Normally the -r
-00017f60: 656c 6178 6564 4669 656c 644e 616d 654d  elaxedFieldNameM
-00017f70: 6174 6368 2070 6172 616d 6574 6572 2069  atch parameter i
-00017f80: 6e20 6f67 7232 6f67 720d 0a20 2020 2073  n ogr2ogr..    s
-00017f90: 686f 756c 6420 6669 7820 7468 6973 2c20  hould fix this, 
-00017fa0: 6275 7420 6974 2073 6565 6d73 2074 6861  but it seems tha
-00017fb0: 7420 7468 6973 2069 736e 2774 2073 7570  t this isn't sup
-00017fc0: 706f 7274 6564 2066 6f72 2073 6861 7065  ported for shape
-00017fd0: 6669 6c65 732e 0d0a 0d0a 2020 2020 4c61  files.....    La
-00017fe0: 756e 6465 7269 6e67 2069 7320 6261 7365  undering is base
-00017ff0: 6420 6f6e 2074 6869 7320 7465 7874 2066  d on this text f
-00018000: 726f 6d20 7468 6520 6764 616c 2073 6861  rom the gdal sha
-00018010: 7065 6669 6c65 2064 7269 7665 720d 0a20  pefile driver.. 
-00018020: 2020 2064 6f63 756d 656e 7461 7469 6f6e     documentation
-00018030: 3a0d 0a0d 0a20 2020 2053 6861 7065 6669  :....    Shapefi
-00018040: 6c65 2066 6561 7475 7265 2061 7474 7269  le feature attri
-00018050: 6275 7465 7320 6172 6520 7374 6f72 6564  butes are stored
-00018060: 2069 6e20 616e 2061 7373 6f63 6961 7465   in an associate
-00018070: 6420 2e64 6266 2066 696c 652c 2061 6e64  d .dbf file, and
-00018080: 0d0a 2020 2020 736f 2061 7474 7269 6275  ..    so attribu
-00018090: 7465 7320 7375 6666 6572 2061 206e 756d  tes suffer a num
-000180a0: 6265 7220 6f66 206c 696d 6974 6174 696f  ber of limitatio
-000180b0: 6e73 3a0d 0a20 2020 202d 2020 2041 7474  ns:..    -   Att
-000180c0: 7269 6275 7465 206e 616d 6573 2063 616e  ribute names can
-000180d0: 206f 6e6c 7920 6265 2075 7020 746f 2031   only be up to 1
-000180e0: 3020 6368 6172 6163 7465 7273 206c 6f6e  0 characters lon
-000180f0: 672e 0d0a 2020 2020 2020 2020 5468 6520  g...        The 
-00018100: 4f47 5220 5368 6170 6566 696c 6520 6472  OGR Shapefile dr
-00018110: 6976 6572 2074 7269 6573 2074 6f20 6765  iver tries to ge
-00018120: 6e65 7261 7465 2075 6e69 7175 6520 6669  nerate unique fi
-00018130: 656c 640d 0a20 2020 2020 2020 206e 616d  eld..        nam
-00018140: 6573 2e20 5375 6363 6573 7369 7665 2064  es. Successive d
-00018150: 7570 6c69 6361 7465 2066 6965 6c64 206e  uplicate field n
-00018160: 616d 6573 2c20 696e 636c 7564 696e 6720  ames, including 
-00018170: 7468 6f73 6520 6372 6561 7465 6420 6279  those created by
-00018180: 0d0a 2020 2020 2020 2020 7472 756e 6361  ..        trunca
-00018190: 7469 6f6e 2074 6f20 3130 2063 6861 7261  tion to 10 chara
-000181a0: 6374 6572 732c 2077 696c 6c20 6265 2074  cters, will be t
-000181b0: 7275 6e63 6174 6564 2074 6f20 3820 6368  runcated to 8 ch
-000181c0: 6172 6163 7465 7273 2061 6e64 0d0a 2020  aracters and..  
-000181d0: 2020 2020 2020 6170 7065 6e64 6564 2077        appended w
-000181e0: 6974 6820 6120 7365 7269 616c 206e 756d  ith a serial num
-000181f0: 6265 7220 6672 6f6d 2031 2074 6f20 3939  ber from 1 to 99
-00018200: 2e0d 0a0d 0a20 2020 2020 2020 2046 6f72  .....        For
-00018210: 2065 7861 6d70 6c65 3a0d 0a0d 0a20 2020   example:....   
-00018220: 2020 2020 202d 2020 6120 e286 9220 612c       -  a ... a,
-00018230: 2061 20e2 8692 2061 5f31 2c20 4120 e286   a ... a_1, A ..
-00018240: 9220 415f 323b 0d0a 2020 2020 2020 2020  . A_2;..        
-00018250: 2d20 2061 6263 6465 6667 6869 6a6b 20e2  -  abcdefghijk .
-00018260: 8692 2061 6263 6465 6667 6869 6a2c 2061  .. abcdefghij, a
-00018270: 6263 6465 6667 6869 6a6b 6c20 e286 9220  bcdefghijkl ... 
-00018280: 6162 6364 6566 6768 5f31 0d0a 0d0a 2020  abcdefgh_1....  
-00018290: 2020 2d20 2020 4f6e 6c79 2049 6e74 6567    -   Only Integ
-000182a0: 6572 2c20 496e 7465 6765 7236 342c 2052  er, Integer64, R
-000182b0: 6561 6c2c 2053 7472 696e 6720 616e 6420  eal, String and 
-000182c0: 4461 7465 2028 6e6f 7420 4461 7465 5469  Date (not DateTi
-000182d0: 6d65 2c20 6a75 7374 0d0a 2020 2020 2020  me, just..      
-000182e0: 2020 7965 6172 2f6d 6f6e 7468 2f64 6179    year/month/day
-000182f0: 2920 6669 656c 6420 7479 7065 7320 6172  ) field types ar
-00018300: 6520 7375 7070 6f72 7465 642e 2054 6865  e supported. The
-00018310: 2076 6172 696f 7573 206c 6973 742c 2061   various list, a
-00018320: 6e64 0d0a 2020 2020 2020 2020 6269 6e61  nd..        bina
-00018330: 7279 2066 6965 6c64 2074 7970 6573 2063  ry field types c
-00018340: 616e 6e6f 7420 6265 2063 7265 6174 6564  annot be created
-00018350: 2e0d 0a20 2020 202d 2020 2054 6865 2066  ...    -   The f
-00018360: 6965 6c64 2077 6964 7468 2061 6e64 2070  ield width and p
-00018370: 7265 6369 7369 6f6e 2061 7265 2064 6972  recision are dir
-00018380: 6563 746c 7920 7573 6564 2074 6f20 6573  ectly used to es
-00018390: 7461 626c 6973 6820 7374 6f72 6167 650d  tablish storage.
-000183a0: 0a20 2020 2020 2020 2073 697a 6520 696e  .        size in
-000183b0: 2074 6865 202e 6462 6620 6669 6c65 2e20   the .dbf file. 
-000183c0: 5468 6973 206d 6561 6e73 2074 6861 7420  This means that 
-000183d0: 7374 7269 6e67 7320 6c6f 6e67 6572 2074  strings longer t
-000183e0: 6861 6e20 7468 6520 6669 656c 640d 0a20  han the field.. 
-000183f0: 2020 2020 2020 2077 6964 7468 2c20 6f72         width, or
-00018400: 206e 756d 6265 7273 2074 6861 7420 646f   numbers that do
-00018410: 6e27 7420 6669 7420 696e 746f 2074 6865  n't fit into the
-00018420: 2069 6e64 6963 6174 6564 2066 6965 6c64   indicated field
-00018430: 2066 6f72 6d61 7420 7769 6c6c 0d0a 2020   format will..  
-00018440: 2020 2020 2020 7375 6666 6572 2074 7275        suffer tru
-00018450: 6e63 6174 696f 6e2e 0d0a 2020 2020 2d20  ncation...    - 
-00018460: 2020 496e 7465 6765 7220 6669 656c 6473    Integer fields
-00018470: 2077 6974 686f 7574 2061 6e20 6578 706c   without an expl
-00018480: 6963 6974 2077 6964 7468 2061 7265 2074  icit width are t
-00018490: 7265 6174 6564 2061 7320 7769 6474 6820  reated as width 
-000184a0: 392c 2061 6e64 0d0a 2020 2020 2020 2020  9, and..        
-000184b0: 6578 7465 6e64 6564 2074 6f20 3130 206f  extended to 10 o
-000184c0: 7220 3131 2069 6620 6e65 6564 6564 2e0d  r 11 if needed..
-000184d0: 0a20 2020 202d 2020 2049 6e74 6567 6572  .    -   Integer
-000184e0: 3634 2066 6965 6c64 7320 7769 7468 6f75  64 fields withou
-000184f0: 7420 616e 2065 7870 6c69 6369 7420 7769  t an explicit wi
-00018500: 6474 6820 6172 6520 7472 6561 7465 6420  dth are treated 
-00018510: 6173 2077 6964 7468 2031 382c 0d0a 2020  as width 18,..  
-00018520: 2020 2020 2020 616e 6420 6578 7465 6e64        and extend
-00018530: 6564 2074 6f20 3139 206f 7220 3230 2069  ed to 19 or 20 i
-00018540: 6620 6e65 6564 6564 2e0d 0a20 2020 202d  f needed...    -
-00018550: 2020 2052 6561 6c20 2866 6c6f 6174 696e     Real (floatin
-00018560: 6720 706f 696e 7429 2066 6965 6c64 7320  g point) fields 
-00018570: 7769 7468 6f75 7420 616e 2065 7870 6c69  without an expli
-00018580: 6369 7420 7769 6474 6820 6172 6520 7472  cit width are tr
-00018590: 6561 7465 6420 6173 0d0a 2020 2020 2020  eated as..      
-000185a0: 2020 7769 6474 6820 3234 2077 6974 6820    width 24 with 
-000185b0: 3135 2064 6563 696d 616c 2070 6c61 6365  15 decimal place
-000185c0: 7320 6f66 2070 7265 6369 7369 6f6e 2e0d  s of precision..
-000185d0: 0a20 2020 202d 2020 2053 7472 696e 6720  .    -   String 
-000185e0: 6669 656c 6473 2077 6974 686f 7574 2061  fields without a
-000185f0: 6e20 6173 7369 676e 6564 2077 6964 7468  n assigned width
-00018600: 2061 7265 2074 7265 6174 6564 2061 7320   are treated as 
-00018610: 3830 2063 6861 7261 6374 6572 732e 0d0a  80 characters...
-00018620: 0d0a 2020 2020 4172 6773 3a0d 0a20 2020  ..    Args:..   
-00018630: 2020 2020 2063 6f6c 756d 6e73 2028 4974       columns (It
-00018640: 6572 6162 6c65 293a 2074 6865 2063 6f6c  erable): the col
-00018650: 756d 6e73 2074 6f20 6c61 756e 6465 722e  umns to launder.
-00018660: 0d0a 0d0a 2020 2020 5265 7475 726e 733a  ....    Returns:
-00018670: 2061 204c 6973 7420 6f66 2074 7570 706c   a List of tuppl
-00018680: 6573 2077 6974 6820 7468 6520 6f72 6967  es with the orig
-00018690: 696e 616c 2061 6e64 206c 6175 6e64 6572  inal and launder
-000186a0: 6564 2063 6f6c 756d 6e20 6e61 6d65 732e  ed column names.
-000186b0: 0d0a 2020 2020 2222 220d 0a20 2020 206c  ..    """..    l
-000186c0: 6175 6e64 6572 6564 203d 205b 5d0d 0a20  aundered = [].. 
-000186d0: 2020 206c 6175 6e64 6572 6564 5f75 7070     laundered_upp
-000186e0: 6572 203d 205b 5d0d 0a20 2020 2066 6f72  er = []..    for
-000186f0: 2063 6f6c 756d 6e20 696e 2063 6f6c 756d   column in colum
-00018700: 6e73 3a0d 0a20 2020 2020 2020 2023 2044  ns:..        # D
-00018710: 6f75 626c 6573 2069 6e20 6361 7369 6e67  oubles in casing
-00018720: 2061 7265 6520 6e6f 7420 616c 6c6f 7765   aree not allowe
-00018730: 6420 6569 7468 6572 0d0a 2020 2020 2020  d either..      
-00018740: 2020 6966 206c 656e 2863 6f6c 756d 6e29    if len(column)
-00018750: 203c 3d20 3130 3a0d 0a20 2020 2020 2020   <= 10:..       
-00018760: 2020 2020 2069 6620 636f 6c75 6d6e 2e75       if column.u
-00018770: 7070 6572 2829 206e 6f74 2069 6e20 6c61  pper() not in la
-00018780: 756e 6465 7265 645f 7570 7065 723a 0d0a  undered_upper:..
-00018790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000187a0: 6c61 756e 6465 7265 645f 7570 7065 722e  laundered_upper.
-000187b0: 6170 7065 6e64 2863 6f6c 756d 6e2e 7570  append(column.up
-000187c0: 7065 7228 2929 0d0a 2020 2020 2020 2020  per())..        
-000187d0: 2020 2020 2020 2020 6c61 756e 6465 7265          laundere
-000187e0: 642e 6170 7065 6e64 2828 636f 6c75 6d6e  d.append((column
-000187f0: 2c20 636f 6c75 6d6e 2929 0d0a 2020 2020  , column))..    
-00018800: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
-00018810: 696e 7565 0d0a 0d0a 2020 2020 2020 2020  inue....        
-00018820: 2320 4c61 756e 6465 7269 6e67 2069 7320  # Laundering is 
-00018830: 6e65 6564 6564 0d0a 2020 2020 2020 2020  needed..        
-00018840: 636f 6c75 6d6e 5f6c 6175 6e64 6572 6564  column_laundered
-00018850: 203d 2063 6f6c 756d 6e5b 3a31 305d 0d0a   = column[:10]..
-00018860: 2020 2020 2020 2020 6966 2063 6f6c 756d          if colum
-00018870: 6e5f 6c61 756e 6465 7265 642e 7570 7065  n_laundered.uppe
-00018880: 7228 2920 6e6f 7420 696e 206c 6175 6e64  r() not in laund
-00018890: 6572 6564 5f75 7070 6572 3a0d 0a20 2020  ered_upper:..   
-000188a0: 2020 2020 2020 2020 206c 6175 6e64 6572           launder
-000188b0: 6564 5f75 7070 6572 2e61 7070 656e 6428  ed_upper.append(
-000188c0: 636f 6c75 6d6e 5f6c 6175 6e64 6572 6564  column_laundered
-000188d0: 2e75 7070 6572 2829 290d 0a20 2020 2020  .upper())..     
-000188e0: 2020 2020 2020 206c 6175 6e64 6572 6564         laundered
-000188f0: 2e61 7070 656e 6428 2863 6f6c 756d 6e2c  .append((column,
-00018900: 2063 6f6c 756d 6e5f 6c61 756e 6465 7265   column_laundere
-00018910: 6429 290d 0a20 2020 2020 2020 2065 6c73  d))..        els
-00018920: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-00018930: 2320 4a75 7374 2074 616b 696e 6720 6669  # Just taking fi
-00018940: 7273 7420 3130 2063 6861 7261 6374 6572  rst 10 character
-00018950: 7320 6469 646e 2774 2068 656c 700d 0a20  s didn't help.. 
-00018960: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
-00018970: 6e64 6578 2069 6e20 7261 6e67 6528 312c  ndex in range(1,
-00018980: 2031 3031 293a 0d0a 2020 2020 2020 2020   101):..        
-00018990: 2020 2020 2020 2020 6966 2069 6e64 6578          if index
-000189a0: 203e 3d20 3130 303a 0d0a 2020 2020 2020   >= 100:..      
-000189b0: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-000189c0: 6973 6520 4e6f 7449 6d70 6c65 6d65 6e74  ise NotImplement
-000189d0: 6564 4572 726f 7228 0d0a 2020 2020 2020  edError(..      
-000189e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000189f0: 2020 224e 6f74 2073 7570 706f 7274 6564    "Not supported
-00018a00: 2074 6f20 6c61 756e 6465 7220 3e20 3939   to launder > 99
-00018a10: 2063 6f6c 756d 6e73 2073 7461 7274 696e   columns startin
-00018a20: 6720 220d 0a20 2020 2020 2020 2020 2020  g "..           
-00018a30: 2020 2020 2020 2020 2020 2020 2066 2277               f"w
-00018a40: 6974 6820 7b63 6f6c 756d 6e5f 6c61 756e  ith {column_laun
-00018a50: 6465 7265 645b 3a38 5d7d 220d 0a20 2020  dered[:8]}"..   
-00018a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018a70: 2029 0d0a 2020 2020 2020 2020 2020 2020   )..            
-00018a80: 2020 2020 6966 2069 6e64 6578 203c 3d20      if index <= 
-00018a90: 393a 0d0a 2020 2020 2020 2020 2020 2020  9:..            
-00018aa0: 2020 2020 2020 2020 636f 6c75 6d6e 5f6c          column_l
-00018ab0: 6175 6e64 6572 6564 203d 2066 227b 636f  aundered = f"{co
-00018ac0: 6c75 6d6e 5f6c 6175 6e64 6572 6564 5b3a  lumn_laundered[:
-00018ad0: 385d 7d5f 7b69 6e64 6578 7d22 0d0a 2020  8]}_{index}"..  
-00018ae0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00018af0: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-00018b00: 2020 2020 2020 2020 2063 6f6c 756d 6e5f           column_
-00018b10: 6c61 756e 6465 7265 6420 3d20 6622 7b63  laundered = f"{c
-00018b20: 6f6c 756d 6e5f 6c61 756e 6465 7265 645b  olumn_laundered[
-00018b30: 3a38 5d7d 7b69 6e64 6578 7d22 0d0a 2020  :8]}{index}"..  
-00018b40: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00018b50: 2063 6f6c 756d 6e5f 6c61 756e 6465 7265   column_laundere
-00018b60: 642e 7570 7065 7228 2920 6e6f 7420 696e  d.upper() not in
-00018b70: 206c 6175 6e64 6572 6564 5f75 7070 6572   laundered_upper
-00018b80: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00018b90: 2020 2020 2020 206c 6175 6e64 6572 6564         laundered
-00018ba0: 5f75 7070 6572 2e61 7070 656e 6428 636f  _upper.append(co
-00018bb0: 6c75 6d6e 5f6c 6175 6e64 6572 6564 2e75  lumn_laundered.u
-00018bc0: 7070 6572 2829 290d 0a20 2020 2020 2020  pper())..       
-00018bd0: 2020 2020 2020 2020 2020 2020 206c 6175               lau
-00018be0: 6e64 6572 6564 2e61 7070 656e 6428 2863  ndered.append((c
-00018bf0: 6f6c 756d 6e2c 2063 6f6c 756d 6e5f 6c61  olumn, column_la
-00018c00: 756e 6465 7265 6429 290d 0a20 2020 2020  undered))..     
-00018c10: 2020 2020 2020 2020 2020 2020 2020 2062                 b
-00018c20: 7265 616b 0d0a 0d0a 2020 2020 7265 7475  reak....    retu
-00018c30: 726e 206c 6175 6e64 6572 6564 0d0a       rn laundered..
+000100a0: 2020 6622 746f 207b 7061 7468 7d21 220a    f"to {path}!".
+000100b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000100c0: 2020 2020 290a 0a20 2020 2020 2020 2020      )..         
+000100d0: 2020 2023 2053 6c65 6570 2066 6f72 2061     # Sleep for a
+000100e0: 2073 6563 6f6e 6420 6265 666f 7265 2074   second before t
+000100f0: 7279 696e 6720 6167 6169 6e0a 2020 2020  rying again.    
+00010100: 2020 2020 2020 2020 7469 6d65 2e73 6c65          time.sle
+00010110: 6570 2831 290a 0a0a 6465 6620 5f74 6f5f  ep(1)...def _to_
+00010120: 6669 6c65 5f70 796f 6772 696f 280a 2020  file_pyogrio(.  
+00010130: 2020 6764 663a 2067 7064 2e47 656f 4461    gdf: gpd.GeoDa
+00010140: 7461 4672 616d 652c 0a20 2020 2070 6174  taFrame,.    pat
+00010150: 683a 2050 6174 682c 0a20 2020 206c 6179  h: Path,.    lay
+00010160: 6572 3a20 7374 722c 0a20 2020 2066 6f72  er: str,.    for
+00010170: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
+00010180: 7279 7479 7065 3a20 556e 696f 6e5b 4765  rytype: Union[Ge
+00010190: 6f6d 6574 7279 5479 7065 2c20 7374 722c  ometryType, str,
+000101a0: 204e 6f6e 655d 203d 204e 6f6e 652c 0a20   None] = None,. 
+000101b0: 2020 2066 6f72 6365 5f6d 756c 7469 7479     force_multity
+000101c0: 7065 3a20 626f 6f6c 203d 2046 616c 7365  pe: bool = False
+000101d0: 2c0a 2020 2020 6170 7065 6e64 3a20 626f  ,.    append: bo
+000101e0: 6f6c 203d 2046 616c 7365 2c0a 2020 2020  ol = False,.    
+000101f0: 6170 7065 6e64 5f74 696d 656f 7574 5f73  append_timeout_s
+00010200: 3a20 696e 7420 3d20 3630 302c 0a20 2020  : int = 600,.   
+00010210: 2069 6e64 6578 3a20 4f70 7469 6f6e 616c   index: Optional
+00010220: 5b62 6f6f 6c5d 203d 204e 6f6e 652c 0a20  [bool] = None,. 
+00010230: 2020 2063 7265 6174 655f 7370 6174 6961     create_spatia
+00010240: 6c5f 696e 6465 783a 204f 7074 696f 6e61  l_index: Optiona
+00010250: 6c5b 626f 6f6c 5d20 3d20 5472 7565 2c0a  l[bool] = True,.
+00010260: 293a 0a20 2020 2022 2222 0a20 2020 2057  ):.    """.    W
+00010270: 7269 7465 7320 6120 7061 6e64 6173 2064  rites a pandas d
+00010280: 6174 6166 7261 6d65 2074 6f20 6669 6c65  ataframe to file
+00010290: 2075 7369 6e67 2070 796f 6772 696f 2e0a   using pyogrio..
+000102a0: 0a20 2020 2052 656d 6172 6b3a 2074 6869  .    Remark: thi
+000102b0: 7320 6675 6e63 7469 6f6e 206f 6e6c 7920  s function only 
+000102c0: 7375 7070 6f72 7473 2077 7269 7469 6e67  supports writing
+000102d0: 2047 656f 4461 7461 4672 616d 6573 2061   GeoDataFrames a
+000102e0: 7420 7468 6520 6d6f 6d65 6e74 2e0a 2020  t the moment..  
+000102f0: 2020 2222 220a 2020 2020 2320 5072 6570    """.    # Prep
+00010300: 6172 6520 6172 6773 2066 6f72 2077 7269  are args for wri
+00010310: 7465 5f64 6174 6166 7261 6d65 0a20 2020  te_dataframe.   
+00010320: 206b 7761 7267 733a 2044 6963 745b 7374   kwargs: Dict[st
+00010330: 722c 2041 6e79 5d20 3d20 7b7d 0a20 2020  r, Any] = {}.   
+00010340: 206b 7761 7267 735b 2265 6e67 696e 6522   kwargs["engine"
+00010350: 5d20 3d20 2270 796f 6772 696f 220a 0a20  ] = "pyogrio".. 
+00010360: 2020 2023 2043 6865 636b 2075 7066 726f     # Check upfro
+00010370: 6e74 2069 6620 6170 7065 6e64 2069 7320  nt if append is 
+00010380: 676f 696e 6720 746f 2077 6f72 6b20 746f  going to work to
+00010390: 2067 6976 6520 6e69 6365 2065 7272 6f72   give nice error
+000103a0: 0a20 2020 2069 6620 6170 7065 6e64 2069  .    if append i
+000103b0: 7320 5472 7565 2061 6e64 2070 6174 682e  s True and path.
+000103c0: 6578 6973 7473 2829 3a0a 2020 2020 2020  exists():.      
+000103d0: 2020 6b77 6172 6773 5b22 6170 7065 6e64    kwargs["append
+000103e0: 225d 203d 2054 7275 650a 2020 2020 2020  "] = True.      
+000103f0: 2020 6c61 7965 7269 6e66 6f20 3d20 6765    layerinfo = ge
+00010400: 745f 6c61 7965 7269 6e66 6f28 7061 7468  t_layerinfo(path
+00010410: 2c20 6c61 7965 7229 0a20 2020 2020 2020  , layer).       
+00010420: 2066 696c 655f 636f 6c73 203d 205b 636f   file_cols = [co
+00010430: 6c2e 7570 7065 7228 2920 666f 7220 636f  l.upper() for co
+00010440: 6c20 696e 206c 6179 6572 696e 666f 2e63  l in layerinfo.c
+00010450: 6f6c 756d 6e73 5d0a 2020 2020 2020 2020  olumns].        
+00010460: 6764 665f 636f 6c73 203d 205b 636f 6c2e  gdf_cols = [col.
+00010470: 7570 7065 7228 2920 666f 7220 636f 6c20  upper() for col 
+00010480: 696e 2067 6466 2e63 6f6c 756d 6e73 2069  in gdf.columns i
+00010490: 6620 636f 6c20 213d 2067 6466 2e67 656f  f col != gdf.geo
+000104a0: 6d65 7472 792e 6e61 6d65 5d0a 2020 2020  metry.name].    
+000104b0: 2020 2020 6966 2067 6466 5f63 6f6c 7320      if gdf_cols 
+000104c0: 213d 2066 696c 655f 636f 6c73 3a0a 2020  != file_cols:.  
+000104d0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+000104e0: 5661 6c75 6545 7272 6f72 280a 2020 2020  ValueError(.    
+000104f0: 2020 2020 2020 2020 2020 2020 2264 6573              "des
+00010500: 7469 6e61 7469 6f6e 206c 6179 6572 2064  tination layer d
+00010510: 6f65 736e 2774 2068 6176 6520 7468 6520  oesn't have the 
+00010520: 7361 6d65 2063 6f6c 756d 6e73 2061 7320  same columns as 
+00010530: 6764 663a 2022 0a20 2020 2020 2020 2020  gdf: ".         
+00010540: 2020 2020 2020 2066 227b 6669 6c65 5f63         f"{file_c
+00010550: 6f6c 737d 2076 7320 7b67 6466 5f63 6f6c  ols} vs {gdf_col
+00010560: 737d 220a 2020 2020 2020 2020 2020 2020  s}".            
+00010570: 290a 0a20 2020 2023 2050 7265 7061 7265  )..    # Prepare
+00010580: 206b 7761 7267 7320 746f 2075 7365 2069   kwargs to use i
+00010590: 6e20 6765 6f70 616e 6461 732e 746f 5f66  n geopandas.to_f
+000105a0: 696c 650a 2020 2020 6966 2063 7265 6174  ile.    if creat
+000105b0: 655f 7370 6174 6961 6c5f 696e 6465 7820  e_spatial_index 
+000105c0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+000105d0: 2020 2020 206b 7761 7267 735b 2253 5041       kwargs["SPA
+000105e0: 5449 414c 5f49 4e44 4558 225d 203d 2063  TIAL_INDEX"] = c
+000105f0: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
+00010600: 6465 780a 2020 2020 7061 7468 5f69 6e66  dex.    path_inf
+00010610: 6f20 3d20 5f67 656f 6669 6c65 696e 666f  o = _geofileinfo
+00010620: 2e67 6574 5f67 656f 6669 6c65 696e 666f  .get_geofileinfo
+00010630: 2870 6174 6829 0a20 2020 206b 7761 7267  (path).    kwarg
+00010640: 735b 2264 7269 7665 7222 5d20 3d20 7061  s["driver"] = pa
+00010650: 7468 5f69 6e66 6f2e 6472 6976 6572 0a20  th_info.driver. 
+00010660: 2020 206b 7761 7267 735b 2269 6e64 6578     kwargs["index
+00010670: 225d 203d 2069 6e64 6578 0a20 2020 2069  "] = index.    i
+00010680: 6620 6372 6561 7465 5f73 7061 7469 616c  f create_spatial
+00010690: 5f69 6e64 6578 2069 7320 6e6f 7420 4e6f  _index is not No
+000106a0: 6e65 3a0a 2020 2020 2020 2020 6b77 6172  ne:.        kwar
+000106b0: 6773 5b22 5350 4154 4941 4c5f 494e 4445  gs["SPATIAL_INDE
+000106c0: 5822 5d20 3d20 6372 6561 7465 5f73 7061  X"] = create_spa
+000106d0: 7469 616c 5f69 6e64 6578 0a20 2020 2069  tial_index.    i
+000106e0: 6620 666f 7263 655f 6f75 7470 7574 5f67  f force_output_g
+000106f0: 656f 6d65 7472 7974 7970 6520 6973 206e  eometrytype is n
+00010700: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+00010710: 2069 6620 6973 696e 7374 616e 6365 2866   if isinstance(f
+00010720: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+00010730: 6574 7279 7479 7065 2c20 4765 6f6d 6574  etrytype, Geomet
+00010740: 7279 5479 7065 293a 0a20 2020 2020 2020  ryType):.       
+00010750: 2020 2020 2066 6f72 6365 5f6f 7574 7075       force_outpu
+00010760: 745f 6765 6f6d 6574 7279 7479 7065 203d  t_geometrytype =
+00010770: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
+00010780: 6f6d 6574 7279 7479 7065 2e6e 616d 655f  ometrytype.name_
+00010790: 6361 6d65 6c63 6173 650a 2020 2020 2020  camelcase.      
+000107a0: 2020 6b77 6172 6773 5b22 6765 6f6d 6574    kwargs["geomet
+000107b0: 7279 5f74 7970 6522 5d20 3d20 666f 7263  ry_type"] = forc
+000107c0: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+000107d0: 7974 7970 650a 2020 2020 6966 2066 6f72  ytype.    if for
+000107e0: 6365 5f6d 756c 7469 7479 7065 3a0a 2020  ce_multitype:.  
+000107f0: 2020 2020 2020 6b77 6172 6773 5b22 7072        kwargs["pr
+00010800: 6f6d 6f74 655f 746f 5f6d 756c 7469 225d  omote_to_multi"]
+00010810: 203d 2054 7275 650a 0a20 2020 2023 2054   = True..    # T
+00010820: 656d 7020 6669 7820 666f 7220 6275 6720  emp fix for bug 
+00010830: 696e 2070 796f 6772 696f 2030 2e37 2e32  in pyogrio 0.7.2
+00010840: 2028 6874 7470 733a 2f2f 6769 7468 7562   (https://github
+00010850: 2e63 6f6d 2f67 656f 7061 6e64 6173 2f70  .com/geopandas/p
+00010860: 796f 6772 696f 2f70 756c 6c2f 3332 3429  yogrio/pull/324)
+00010870: 0a20 2020 2023 204c 6f67 6963 2062 6173  .    # Logic bas
+00010880: 6564 206f 6e20 6765 6f70 616e 6461 732e  ed on geopandas.
+00010890: 746f 5f66 696c 650a 2020 2020 6966 206c  to_file.    if l
+000108a0: 6973 7428 6764 662e 696e 6465 782e 6e61  ist(gdf.index.na
+000108b0: 6d65 7329 203d 3d20 5b4e 6f6e 655d 2061  mes) == [None] a
+000108c0: 6e64 2069 735f 696e 7465 6765 725f 6474  nd is_integer_dt
+000108d0: 7970 6528 6764 662e 696e 6465 782e 6474  ype(gdf.index.dt
+000108e0: 7970 6529 3a0a 2020 2020 2020 2020 6764  ype):.        gd
+000108f0: 6620 3d20 6764 662e 7265 7365 745f 696e  f = gdf.reset_in
+00010900: 6465 7828 6472 6f70 3d54 7275 6529 0a0a  dex(drop=True)..
+00010910: 2020 2020 2320 4e6f 7720 7765 2063 616e      # Now we can
+00010920: 2077 7269 7465 0a20 2020 2069 6620 7061   write.    if pa
+00010930: 7468 5f69 6e66 6f2e 6973 5f73 696e 676c  th_info.is_singl
+00010940: 656c 6179 6572 3a0a 2020 2020 2020 2020  elayer:.        
+00010950: 6764 662e 746f 5f66 696c 6528 7374 7228  gdf.to_file(str(
+00010960: 7061 7468 292c 202a 2a6b 7761 7267 7329  path), **kwargs)
+00010970: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+00010980: 2020 2067 6466 2e74 6f5f 6669 6c65 2873     gdf.to_file(s
+00010990: 7472 2870 6174 6829 2c20 6c61 7965 723d  tr(path), layer=
+000109a0: 6c61 7965 722c 202a 2a6b 7761 7267 7329  layer, **kwargs)
+000109b0: 0a0a 0a64 6566 2067 6574 5f63 7273 2870  ...def get_crs(p
+000109c0: 6174 683a 2055 6e69 6f6e 5b73 7472 2c20  ath: Union[str, 
+000109d0: 226f 732e 5061 7468 4c69 6b65 5b41 6e79  "os.PathLike[Any
+000109e0: 5d22 5d29 202d 3e20 7079 7072 6f6a 2e43  ]"]) -> pyproj.C
+000109f0: 5253 3a0a 2020 2020 2222 220a 2020 2020  RS:.    """.    
+00010a00: 4765 7420 7468 6520 4352 5320 2870 726f  Get the CRS (pro
+00010a10: 6a65 6374 696f 6e29 206f 6620 7468 6520  jection) of the 
+00010a20: 6669 6c65 2e0a 0a20 2020 2041 7267 733a  file...    Args:
+00010a30: 0a20 2020 2020 2020 2070 6174 6820 2850  .        path (P
+00010a40: 6174 684c 696b 6529 3a20 5061 7468 2074  athLike): Path t
+00010a50: 6f20 7468 6520 6669 6c65 2e0a 0a20 2020  o the file...   
+00010a60: 2052 6574 7572 6e73 3a0a 2020 2020 2020   Returns:.      
+00010a70: 2020 7079 7072 6f6a 2e43 5253 3a20 5468    pyproj.CRS: Th
+00010a80: 6520 7072 6f6a 6563 7469 6f6e 206f 6620  e projection of 
+00010a90: 7468 6520 6669 6c65 0a20 2020 2022 2222  the file.    """
+00010aa0: 0a20 2020 2023 2054 4f44 4f3a 2073 6565  .    # TODO: see
+00010ab0: 6d73 206c 696b 6520 7375 7070 6f72 7420  ms like support 
+00010ac0: 666f 7220 6d75 6c74 6970 6c65 206c 6179  for multiple lay
+00010ad0: 6572 7320 696e 2074 6865 2066 696c 6520  ers in the file 
+00010ae0: 6973 6e27 7420 6865 7265 2079 6574 3f3f  isn't here yet??
+00010af0: 3f0a 2020 2020 7769 7468 2066 696f 6e61  ?.    with fiona
+00010b00: 2e6f 7065 6e28 7374 7228 7061 7468 292c  .open(str(path),
+00010b10: 2022 7222 2920 6173 2067 656f 6669 6c65   "r") as geofile
+00010b20: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
+00010b30: 2067 656f 6669 6c65 2069 7320 6e6f 7420   geofile is not 
+00010b40: 4e6f 6e65 0a20 2020 2020 2020 2072 6574  None.        ret
+00010b50: 7572 6e20 7079 7072 6f6a 2e43 5253 2867  urn pyproj.CRS(g
+00010b60: 656f 6669 6c65 2e63 7273 290a 0a0a 6465  eofile.crs)...de
+00010b70: 6620 6973 5f67 656f 6669 6c65 2870 6174  f is_geofile(pat
+00010b80: 683a 2055 6e69 6f6e 5b73 7472 2c20 226f  h: Union[str, "o
+00010b90: 732e 5061 7468 4c69 6b65 5b41 6e79 5d22  s.PathLike[Any]"
+00010ba0: 5d29 202d 3e20 626f 6f6c 3a0a 2020 2020  ]) -> bool:.    
+00010bb0: 2222 220a 2020 2020 4465 7465 726d 696e  """.    Determin
+00010bc0: 6573 2062 6173 6564 206f 6e20 7468 6520  es based on the 
+00010bd0: 6669 6c65 7061 7468 2069 6620 7468 6973  filepath if this
+00010be0: 2069 7320 6120 6765 6f66 696c 652e 0a0a   is a geofile...
+00010bf0: 2020 2020 4445 5052 4543 4154 4544 2e0a      DEPRECATED..
+00010c00: 0a20 2020 2041 7267 733a 0a20 2020 2020  .    Args:.     
+00010c10: 2020 2070 6174 6820 2850 6174 684c 696b     path (PathLik
+00010c20: 6529 3a20 5468 6520 6669 6c65 2070 6174  e): The file pat
+00010c30: 682e 0a0a 2020 2020 5265 7475 726e 733a  h...    Returns:
+00010c40: 0a20 2020 2020 2020 2062 6f6f 6c3a 2054  .        bool: T
+00010c50: 7275 6520 6966 2069 7420 6973 2061 2067  rue if it is a g
+00010c60: 656f 2066 696c 652e 0a20 2020 2022 2222  eo file..    """
+00010c70: 0a20 2020 2077 6172 6e69 6e67 732e 7761  .    warnings.wa
+00010c80: 726e 280a 2020 2020 2020 2020 2269 735f  rn(.        "is_
+00010c90: 6765 6f66 696c 6520 6973 2064 6570 7265  geofile is depre
+00010ca0: 6361 7465 6420 616e 6420 7769 6c6c 2062  cated and will b
+00010cb0: 6520 7265 6d6f 7665 6420 696e 2061 2066  e removed in a f
+00010cc0: 7574 7572 6520 7665 7273 696f 6e22 2c0a  uture version",.
+00010cd0: 2020 2020 2020 2020 4675 7475 7265 5761          FutureWa
+00010ce0: 726e 696e 672c 0a20 2020 2020 2020 2073  rning,.        s
+00010cf0: 7461 636b 6c65 7665 6c3d 322c 0a20 2020  tacklevel=2,.   
+00010d00: 2029 0a20 2020 2072 6574 7572 6e20 6973   ).    return is
+00010d10: 5f67 656f 6669 6c65 5f65 7874 2850 6174  _geofile_ext(Pat
+00010d20: 6828 7061 7468 292e 7375 6666 6978 290a  h(path).suffix).
+00010d30: 0a0a 6465 6620 6973 5f67 656f 6669 6c65  ..def is_geofile
+00010d40: 5f65 7874 2866 696c 655f 6578 743a 2073  _ext(file_ext: s
+00010d50: 7472 2920 2d3e 2062 6f6f 6c3a 0a20 2020  tr) -> bool:.   
+00010d60: 2022 2222 0a20 2020 2044 6574 6572 6d69   """.    Determi
+00010d70: 6e65 7320 6261 7365 6420 6f6e 2074 6865  nes based on the
+00010d80: 2066 696c 6520 6578 7465 6e73 696f 6e20   file extension 
+00010d90: 6966 2074 6869 7320 6973 2061 2067 656f  if this is a geo
+00010da0: 6669 6c65 2e0a 0a20 2020 2044 4550 5245  file...    DEPRE
+00010db0: 4341 5445 442e 0a0a 2020 2020 4172 6773  CATED...    Args
+00010dc0: 3a0a 2020 2020 2020 2020 6669 6c65 5f65  :.        file_e
+00010dd0: 7874 2028 7374 7229 3a20 7468 6520 6578  xt (str): the ex
+00010de0: 7465 6e73 696f 6e2e 0a0a 2020 2020 5265  tension...    Re
+00010df0: 7475 726e 733a 0a20 2020 2020 2020 2062  turns:.        b
+00010e00: 6f6f 6c3a 2054 7275 6520 6966 2069 7420  ool: True if it 
+00010e10: 6973 2061 2067 656f 6669 6c65 2e0a 2020  is a geofile..  
+00010e20: 2020 2222 220a 2020 2020 7761 726e 696e    """.    warnin
+00010e30: 6773 2e77 6172 6e28 0a20 2020 2020 2020  gs.warn(.       
+00010e40: 2022 6973 5f67 656f 6669 6c65 5f65 7874   "is_geofile_ext
+00010e50: 2069 7320 6465 7072 6563 6174 6564 2061   is deprecated a
+00010e60: 6e64 2077 696c 6c20 6265 2072 656d 6f76  nd will be remov
+00010e70: 6564 2069 6e20 6120 6675 7475 7265 2076  ed in a future v
+00010e80: 6572 7369 6f6e 222c 0a20 2020 2020 2020  ersion",.       
+00010e90: 2046 7574 7572 6557 6172 6e69 6e67 2c0a   FutureWarning,.
+00010ea0: 2020 2020 2020 2020 7374 6163 6b6c 6576          stacklev
+00010eb0: 656c 3d32 2c0a 2020 2020 290a 2020 2020  el=2,.    ).    
+00010ec0: 7472 793a 0a20 2020 2020 2020 2023 2049  try:.        # I
+00010ed0: 6620 7468 6520 6472 6976 6572 2063 616e  f the driver can
+00010ee0: 2062 6520 6465 7465 726d 696e 6564 2c20   be determined, 
+00010ef0: 6974 2069 7320 6120 2873 7570 706f 7274  it is a (support
+00010f00: 6564 2920 6765 6f20 6669 6c65 2e0a 2020  ed) geo file..  
+00010f10: 2020 2020 2020 5f20 3d20 5f67 656f 6669        _ = _geofi
+00010f20: 6c65 696e 666f 2e47 656f 6669 6c65 5479  leinfo.GeofileTy
+00010f30: 7065 2866 696c 655f 6578 7429 0a20 2020  pe(file_ext).   
+00010f40: 2020 2020 2072 6574 7572 6e20 5472 7565       return True
+00010f50: 0a20 2020 2065 7863 6570 7420 4578 6365  .    except Exce
+00010f60: 7074 696f 6e3a 0a20 2020 2020 2020 2072  ption:.        r
+00010f70: 6574 7572 6e20 4661 6c73 650a 0a0a 6465  eturn False...de
+00010f80: 6620 636d 7028 0a20 2020 2070 6174 6831  f cmp(.    path1
+00010f90: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
+00010fa0: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
+00010fb0: 2c20 7061 7468 323a 2055 6e69 6f6e 5b73  , path2: Union[s
+00010fc0: 7472 2c20 226f 732e 5061 7468 4c69 6b65  tr, "os.PathLike
+00010fd0: 5b41 6e79 5d22 5d0a 2920 2d3e 2062 6f6f  [Any]"].) -> boo
+00010fe0: 6c3a 0a20 2020 2022 2222 0a20 2020 2043  l:.    """.    C
+00010ff0: 6f6d 7061 7265 2069 6620 7477 6f20 6765  ompare if two ge
+00011000: 6f66 696c 6573 2061 7265 2069 6465 6e74  ofiles are ident
+00011010: 6963 616c 2e0a 0a20 2020 2046 6f72 2067  ical...    For g
+00011020: 656f 6669 6c65 7320 7468 6174 2075 7365  eofiles that use
+00011030: 206d 756c 7469 706c 6520 6669 6c65 732c   multiple files,
+00011040: 2061 6c6c 2072 656c 6576 616e 7420 6669   all relevant fi
+00011050: 6c65 7320 6d75 7374 2062 6520 6964 656e  les must be iden
+00011060: 7469 6361 6c2e 0a20 2020 2045 672e 2066  tical..    Eg. f
+00011070: 6f72 2073 6861 7065 6669 6c65 732c 2074  or shapefiles, t
+00011080: 6865 202e 7368 702c 202e 7368 7820 616e  he .shp, .shx an
+00011090: 6420 2e64 6266 2066 696c 6520 6d75 7374  d .dbf file must
+000110a0: 2062 6520 6964 656e 7469 6361 6c2e 0a0a   be identical...
+000110b0: 2020 2020 4172 6773 3a0a 2020 2020 2020      Args:.      
+000110c0: 2020 7061 7468 3120 2850 6174 684c 696b    path1 (PathLik
+000110d0: 6529 3a20 7061 7468 2074 6f20 7468 6520  e): path to the 
+000110e0: 6669 7273 7420 6669 6c65 2e0a 2020 2020  first file..    
+000110f0: 2020 2020 7061 7468 3220 2850 6174 684c      path2 (PathL
+00011100: 696b 6529 3a20 7061 7468 2074 6f20 7468  ike): path to th
+00011110: 6520 7365 636f 6e64 2066 696c 652e 0a0a  e second file...
+00011120: 2020 2020 5265 7475 726e 733a 0a20 2020      Returns:.   
+00011130: 2020 2020 2062 6f6f 6c3a 2054 7275 6520       bool: True 
+00011140: 6966 2074 6865 2066 696c 6573 2061 7265  if the files are
+00011150: 2069 6465 6e74 6963 616c 0a20 2020 2022   identical.    "
+00011160: 2222 0a20 2020 2023 2043 6865 636b 2069  "".    # Check i
+00011170: 6e70 7574 2070 6172 616d 6574 6572 730a  nput parameters.
+00011180: 2020 2020 7061 7468 3120 3d20 5061 7468      path1 = Path
+00011190: 2870 6174 6831 290a 2020 2020 7061 7468  (path1).    path
+000111a0: 3220 3d20 5061 7468 2870 6174 6832 290a  2 = Path(path2).
+000111b0: 0a20 2020 2023 2046 6f72 2061 2073 6861  .    # For a sha
+000111c0: 7065 6669 6c65 2c20 6d75 6c74 6970 6c65  pefile, multiple
+000111d0: 2066 696c 6573 206e 6565 6420 746f 2062   files need to b
+000111e0: 6520 636f 6d70 6172 6564 0a20 2020 2069  e compared.    i
+000111f0: 6620 7061 7468 312e 7375 6666 6978 2e6c  f path1.suffix.l
+00011200: 6f77 6572 2829 203d 3d20 222e 7368 7022  ower() == ".shp"
+00011210: 3a0a 2020 2020 2020 2020 7368 6170 6566  :.        shapef
+00011220: 696c 655f 6261 7365 5f73 7566 6669 7865  ile_base_suffixe
+00011230: 7320 3d20 5b22 2e73 6870 222c 2022 2e64  s = [".shp", ".d
+00011240: 6266 222c 2022 2e73 6878 225d 0a20 2020  bf", ".shx"].   
+00011250: 2020 2020 2066 6f72 2073 7566 6669 7820       for suffix 
+00011260: 696e 2073 6861 7065 6669 6c65 5f62 6173  in shapefile_bas
+00011270: 655f 7375 6666 6978 6573 3a0a 2020 2020  e_suffixes:.    
+00011280: 2020 2020 2020 2020 6966 206e 6f74 2066          if not f
+00011290: 696c 6563 6d70 2e63 6d70 2870 6174 6831  ilecmp.cmp(path1
+000112a0: 2e77 6974 685f 7375 6666 6978 2873 7566  .with_suffix(suf
+000112b0: 6669 7829 2c20 7061 7468 322e 7769 7468  fix), path2.with
+000112c0: 5f73 7566 6669 7828 7375 6666 6978 2929  _suffix(suffix))
+000112d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000112e0: 2020 6c6f 6767 6572 2e69 6e66 6f28 0a20    logger.info(. 
+000112f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011300: 2020 2066 2246 696c 6520 7b70 6174 6831     f"File {path1
+00011310: 2e77 6974 685f 7375 6666 6978 2873 7566  .with_suffix(suf
+00011320: 6669 7829 7d20 6973 2064 6966 6665 7265  fix)} is differe
+00011330: 6e74 2066 726f 6d20 220a 2020 2020 2020  nt from ".      
+00011340: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+00011350: 7b70 6174 6832 2e77 6974 685f 7375 6666  {path2.with_suff
+00011360: 6978 2873 7566 6669 7829 7d22 0a20 2020  ix(suffix)}".   
+00011370: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+00011380: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00011390: 6574 7572 6e20 4661 6c73 650a 2020 2020  eturn False.    
+000113a0: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
+000113b0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+000113c0: 2020 7265 7475 726e 2066 696c 6563 6d70    return filecmp
+000113d0: 2e63 6d70 2873 7472 2870 6174 6831 292c  .cmp(str(path1),
+000113e0: 2073 7472 2870 6174 6832 2929 0a0a 0a64   str(path2))...d
+000113f0: 6566 2063 6f70 7928 7372 633a 2055 6e69  ef copy(src: Uni
+00011400: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
+00011410: 4c69 6b65 5b41 6e79 5d22 5d2c 2064 7374  Like[Any]"], dst
+00011420: 3a20 556e 696f 6e5b 7374 722c 2022 6f73  : Union[str, "os
+00011430: 2e50 6174 684c 696b 655b 416e 795d 225d  .PathLike[Any]"]
+00011440: 293a 0a20 2020 2022 2222 0a20 2020 2043  ):.    """.    C
+00011450: 6f70 6965 7320 7468 6520 6765 6f66 696c  opies the geofil
+00011460: 6520 6672 6f6d 2073 7263 2074 6f20 6473  e from src to ds
+00011470: 742e 0a0a 2020 2020 4966 2074 6865 2073  t...    If the s
+00011480: 6f75 7263 6520 6669 6c65 2069 7320 6120  ource file is a 
+00011490: 6765 6f66 696c 6520 636f 6e74 6169 6e69  geofile containi
+000114a0: 6e67 206f 6620 6d75 6c74 6970 6c65 2066  ng of multiple f
+000114b0: 696c 6573 2028 6567 2e20 2e73 6870 2920  iles (eg. .shp) 
+000114c0: 616c 6c20 6669 6c65 730a 2020 2020 6172  all files.    ar
+000114d0: 6520 636f 7069 6564 2e0a 0a20 2020 2041  e copied...    A
+000114e0: 7267 733a 0a20 2020 2020 2020 2073 7263  rgs:.        src
+000114f0: 2028 5061 7468 4c69 6b65 293a 2074 6865   (PathLike): the
+00011500: 2066 696c 6520 746f 2063 6f70 792e 0a20   file to copy.. 
+00011510: 2020 2020 2020 2064 7374 2028 5061 7468         dst (Path
+00011520: 4c69 6b65 293a 2074 6865 206c 6f63 6174  Like): the locat
+00011530: 696f 6e20 746f 2063 6f70 7920 7468 6520  ion to copy the 
+00011540: 6669 6c65 2873 2920 746f 2e0a 2020 2020  file(s) to..    
+00011550: 2222 220a 2020 2020 2320 4368 6563 6b20  """.    # Check 
+00011560: 696e 7075 7420 7061 7261 6d65 7465 7273  input parameters
+00011570: 0a20 2020 2073 7263 203d 2050 6174 6828  .    src = Path(
+00011580: 7372 6329 0a20 2020 2064 7374 203d 2050  src).    dst = P
+00011590: 6174 6828 6473 7429 0a20 2020 2073 7263  ath(dst).    src
+000115a0: 5f69 6e66 6f20 3d20 5f67 656f 6669 6c65  _info = _geofile
+000115b0: 696e 666f 2e67 6574 5f67 656f 6669 6c65  info.get_geofile
+000115c0: 696e 666f 2873 7263 290a 0a20 2020 2023  info(src)..    #
+000115d0: 2043 6f70 7920 7468 6520 6d61 696e 2066   Copy the main f
+000115e0: 696c 650a 2020 2020 7368 7574 696c 2e63  ile.    shutil.c
+000115f0: 6f70 7928 7374 7228 7372 6329 2c20 6473  opy(str(src), ds
+00011600: 7429 0a0a 2020 2020 2320 466f 7220 736f  t)..    # For so
+00011610: 6d65 2066 696c 6520 7479 7065 732c 2065  me file types, e
+00011620: 7874 7261 2066 696c 6573 206e 6565 6420  xtra files need 
+00011630: 746f 2062 6520 636f 7069 6564 0a20 2020  to be copied.   
+00011640: 2023 2049 6620 6465 7374 2069 7320 6120   # If dest is a 
+00011650: 6469 722c 206a 7573 7420 7573 6520 6d6f  dir, just use mo
+00011660: 7665 2e20 4f74 6865 7277 6973 6520 636f  ve. Otherwise co
+00011670: 6e63 6174 2064 6573 7420 6669 6c65 7061  ncat dest filepa
+00011680: 7468 730a 2020 2020 6966 2073 7263 5f69  ths.    if src_i
+00011690: 6e66 6f2e 7375 6666 6978 6573 5f65 7874  nfo.suffixes_ext
+000116a0: 7261 6669 6c65 7320 6973 206e 6f74 204e  rafiles is not N
+000116b0: 6f6e 653a 0a20 2020 2020 2020 2069 6620  one:.        if 
+000116c0: 6473 742e 6973 5f64 6972 2829 3a0a 2020  dst.is_dir():.  
+000116d0: 2020 2020 2020 2020 2020 666f 7220 7375            for su
+000116e0: 6666 6978 2069 6e20 7372 635f 696e 666f  ffix in src_info
+000116f0: 2e73 7566 6669 7865 735f 6578 7472 6166  .suffixes_extraf
+00011700: 696c 6573 3a0a 2020 2020 2020 2020 2020  iles:.          
+00011710: 2020 2020 2020 7372 6366 696c 6520 3d20        srcfile = 
+00011720: 7372 632e 7061 7265 6e74 202f 2066 227b  src.parent / f"{
+00011730: 7372 632e 7374 656d 7d7b 7375 6666 6978  src.stem}{suffix
+00011740: 7d22 0a20 2020 2020 2020 2020 2020 2020  }".             
+00011750: 2020 2069 6620 7372 6366 696c 652e 6578     if srcfile.ex
+00011760: 6973 7473 2829 3a0a 2020 2020 2020 2020  ists():.        
+00011770: 2020 2020 2020 2020 2020 2020 7368 7574              shut
+00011780: 696c 2e63 6f70 7928 7374 7228 7372 6366  il.copy(str(srcf
+00011790: 696c 6529 2c20 6473 7429 0a20 2020 2020  ile), dst).     
+000117a0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000117b0: 2020 2020 2066 6f72 2073 7566 6669 7820       for suffix 
+000117c0: 696e 2073 7263 5f69 6e66 6f2e 7375 6666  in src_info.suff
+000117d0: 6978 6573 5f65 7874 7261 6669 6c65 733a  ixes_extrafiles:
+000117e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000117f0: 2073 7263 6669 6c65 203d 2073 7263 2e70   srcfile = src.p
+00011800: 6172 656e 7420 2f20 6622 7b73 7263 2e73  arent / f"{src.s
+00011810: 7465 6d7d 7b73 7566 6669 787d 220a 2020  tem}{suffix}".  
+00011820: 2020 2020 2020 2020 2020 2020 2020 6473                ds
+00011830: 7466 696c 6520 3d20 6473 742e 7061 7265  tfile = dst.pare
+00011840: 6e74 202f 2066 227b 6473 742e 7374 656d  nt / f"{dst.stem
+00011850: 7d7b 7375 6666 6978 7d22 0a20 2020 2020  }{suffix}".     
+00011860: 2020 2020 2020 2020 2020 2069 6620 7372             if sr
+00011870: 6366 696c 652e 6578 6973 7473 2829 3a0a  cfile.exists():.
+00011880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011890: 2020 2020 7368 7574 696c 2e63 6f70 7928      shutil.copy(
+000118a0: 7374 7228 7372 6366 696c 6529 2c20 6473  str(srcfile), ds
+000118b0: 7466 696c 6529 0a0a 0a64 6566 206d 6f76  tfile)...def mov
+000118c0: 6528 7372 633a 2055 6e69 6f6e 5b73 7472  e(src: Union[str
+000118d0: 2c20 226f 732e 5061 7468 4c69 6b65 5b41  , "os.PathLike[A
+000118e0: 6e79 5d22 5d2c 2064 7374 3a20 556e 696f  ny]"], dst: Unio
+000118f0: 6e5b 7374 722c 2022 6f73 2e50 6174 684c  n[str, "os.PathL
+00011900: 696b 655b 416e 795d 225d 293a 0a20 2020  ike[Any]"]):.   
+00011910: 2022 2222 0a20 2020 204d 6f76 6573 2074   """.    Moves t
+00011920: 6865 2067 656f 6669 6c65 2066 726f 6d20  he geofile from 
+00011930: 7372 6320 746f 2064 7374 2e0a 0a20 2020  src to dst...   
+00011940: 2049 6620 7468 6520 736f 7572 6365 2066   If the source f
+00011950: 696c 6520 6973 2061 2067 656f 6669 6c65  ile is a geofile
+00011960: 2063 6f6e 7461 696e 696e 6720 6f66 206d   containing of m
+00011970: 756c 7469 706c 6520 6669 6c65 7320 2865  ultiple files (e
+00011980: 672e 202e 7368 7029 2061 6c6c 2066 696c  g. .shp) all fil
+00011990: 6573 0a20 2020 2061 7265 206d 6f76 6564  es.    are moved
+000119a0: 2e0a 0a20 2020 2041 7267 733a 0a20 2020  ...    Args:.   
+000119b0: 2020 2020 2073 7263 2028 5061 7468 4c69       src (PathLi
+000119c0: 6b65 293a 2074 6865 2066 696c 6520 746f  ke): the file to
+000119d0: 206d 6f76 650a 2020 2020 2020 2020 6473   move.        ds
+000119e0: 7420 2850 6174 684c 696b 6529 3a20 7468  t (PathLike): th
+000119f0: 6520 6c6f 6361 7469 6f6e 2074 6f20 6d6f  e location to mo
+00011a00: 7665 2074 6865 2066 696c 6528 7329 2074  ve the file(s) t
+00011a10: 6f0a 2020 2020 2222 220a 2020 2020 2320  o.    """.    # 
+00011a20: 4368 6563 6b20 696e 7075 7420 7061 7261  Check input para
+00011a30: 6d65 7465 7273 0a20 2020 2073 7263 203d  meters.    src =
+00011a40: 2050 6174 6828 7372 6329 0a20 2020 2064   Path(src).    d
+00011a50: 7374 203d 2050 6174 6828 6473 7429 0a20  st = Path(dst). 
+00011a60: 2020 2073 7263 5f69 6e66 6f20 3d20 5f67     src_info = _g
+00011a70: 656f 6669 6c65 696e 666f 2e67 6574 5f67  eofileinfo.get_g
+00011a80: 656f 6669 6c65 696e 666f 2873 7263 290a  eofileinfo(src).
+00011a90: 0a20 2020 2023 204d 6f76 6520 7468 6520  .    # Move the 
+00011aa0: 6d61 696e 2066 696c 650a 2020 2020 7368  main file.    sh
+00011ab0: 7574 696c 2e6d 6f76 6528 7374 7228 7372  util.move(str(sr
+00011ac0: 6329 2c20 6473 7429 0a0a 2020 2020 2320  c), dst)..    # 
+00011ad0: 466f 7220 736f 6d65 2066 696c 6520 7479  For some file ty
+00011ae0: 7065 732c 2065 7874 7261 2066 696c 6573  pes, extra files
+00011af0: 206e 6565 6420 746f 2062 6520 6d6f 7665   need to be move
+00011b00: 640a 2020 2020 2320 4966 2064 6573 7420  d.    # If dest 
+00011b10: 6973 2061 2064 6972 2c20 6a75 7374 2075  is a dir, just u
+00011b20: 7365 206d 6f76 652e 204f 7468 6572 7769  se move. Otherwi
+00011b30: 7365 2063 6f6e 6361 7420 6465 7374 2066  se concat dest f
+00011b40: 696c 6570 6174 6873 0a20 2020 2069 6620  ilepaths.    if 
+00011b50: 7372 635f 696e 666f 2e73 7566 6669 7865  src_info.suffixe
+00011b60: 735f 6578 7472 6166 696c 6573 2069 7320  s_extrafiles is 
+00011b70: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+00011b80: 2020 6966 2064 7374 2e69 735f 6469 7228    if dst.is_dir(
+00011b90: 293a 0a20 2020 2020 2020 2020 2020 2066  ):.            f
+00011ba0: 6f72 2073 7566 6669 7820 696e 2073 7263  or suffix in src
+00011bb0: 5f69 6e66 6f2e 7375 6666 6978 6573 5f65  _info.suffixes_e
+00011bc0: 7874 7261 6669 6c65 733a 0a20 2020 2020  xtrafiles:.     
+00011bd0: 2020 2020 2020 2020 2020 2073 7263 6669             srcfi
+00011be0: 6c65 203d 2073 7263 2e70 6172 656e 7420  le = src.parent 
+00011bf0: 2f20 6622 7b73 7263 2e73 7465 6d7d 7b73  / f"{src.stem}{s
+00011c00: 7566 6669 787d 220a 2020 2020 2020 2020  uffix}".        
+00011c10: 2020 2020 2020 2020 6966 2073 7263 6669          if srcfi
+00011c20: 6c65 2e65 7869 7374 7328 293a 0a20 2020  le.exists():.   
+00011c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011c40: 2073 6875 7469 6c2e 6d6f 7665 2873 7472   shutil.move(str
+00011c50: 2873 7263 6669 6c65 292c 2064 7374 290a  (srcfile), dst).
+00011c60: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00011c70: 2020 2020 2020 2020 2020 666f 7220 7375            for su
+00011c80: 6666 6978 2069 6e20 7372 635f 696e 666f  ffix in src_info
+00011c90: 2e73 7566 6669 7865 735f 6578 7472 6166  .suffixes_extraf
+00011ca0: 696c 6573 3a0a 2020 2020 2020 2020 2020  iles:.          
+00011cb0: 2020 2020 2020 7372 6366 696c 6520 3d20        srcfile = 
+00011cc0: 7372 632e 7061 7265 6e74 202f 2066 227b  src.parent / f"{
+00011cd0: 7372 632e 7374 656d 7d7b 7375 6666 6978  src.stem}{suffix
+00011ce0: 7d22 0a20 2020 2020 2020 2020 2020 2020  }".             
+00011cf0: 2020 2064 7374 6669 6c65 203d 2064 7374     dstfile = dst
+00011d00: 2e70 6172 656e 7420 2f20 6622 7b64 7374  .parent / f"{dst
+00011d10: 2e73 7465 6d7d 7b73 7566 6669 787d 220a  .stem}{suffix}".
+00011d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011d30: 6966 2073 7263 6669 6c65 2e65 7869 7374  if srcfile.exist
+00011d40: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
+00011d50: 2020 2020 2020 2020 2073 6875 7469 6c2e           shutil.
+00011d60: 6d6f 7665 2873 7472 2873 7263 6669 6c65  move(str(srcfile
+00011d70: 292c 2064 7374 6669 6c65 290a 0a0a 6465  ), dstfile)...de
+00011d80: 6620 7265 6d6f 7665 2870 6174 683a 2055  f remove(path: U
+00011d90: 6e69 6f6e 5b73 7472 2c20 226f 732e 5061  nion[str, "os.Pa
+00011da0: 7468 4c69 6b65 5b41 6e79 5d22 5d2c 206d  thLike[Any]"], m
+00011db0: 6973 7369 6e67 5f6f 6b3a 2062 6f6f 6c20  issing_ok: bool 
+00011dc0: 3d20 4661 6c73 6529 3a0a 2020 2020 2222  = False):.    ""
+00011dd0: 220a 2020 2020 5265 6d6f 7665 7320 7468  ".    Removes th
+00011de0: 6520 6765 6f66 696c 652e 0a0a 2020 2020  e geofile...    
+00011df0: 4973 2069 7420 6973 2061 2067 656f 6669  Is it is a geofi
+00011e00: 6c65 2063 6f6d 706f 7365 6420 6f66 206d  le composed of m
+00011e10: 756c 7469 706c 6520 6669 6c65 7320 2865  ultiple files (e
+00011e20: 672e 202e 7368 7029 2061 6c6c 2066 696c  g. .shp) all fil
+00011e30: 6573 2061 7265 2072 656d 6f76 6564 2e0a  es are removed..
+00011e40: 2020 2020 4966 202e 6c6f 636b 2066 696c      If .lock fil
+00011e50: 6573 2061 7265 2070 7265 7365 6e74 2c20  es are present, 
+00011e60: 7468 6579 2061 7265 2072 656d 6f76 6564  they are removed
+00011e70: 2061 7320 7765 6c6c 2e0a 0a20 2020 2041   as well...    A
+00011e80: 7267 733a 0a20 2020 2020 2020 2070 6174  rgs:.        pat
+00011e90: 6820 2850 6174 684c 696b 6529 3a20 7468  h (PathLike): th
+00011ea0: 6520 6669 6c65 2074 6f20 7265 6d6f 7665  e file to remove
+00011eb0: 0a20 2020 2020 2020 206d 6973 7369 6e67  .        missing
+00011ec0: 5f6f 6b20 2862 6f6f 6c2c 206f 7074 696f  _ok (bool, optio
+00011ed0: 6e61 6c29 3a20 5472 7565 206e 6f74 2074  nal): True not t
+00011ee0: 6f20 6769 7665 2061 6e20 6572 726f 7220  o give an error 
+00011ef0: 6966 2074 6865 2066 696c 6520 746f 2062  if the file to b
+00011f00: 6520 7265 6d6f 7665 640a 2020 2020 2020  e removed.      
+00011f10: 2020 2020 2020 646f 6573 6e27 7420 6578        doesn't ex
+00011f20: 6973 742e 2044 6566 6175 6c74 7320 746f  ist. Defaults to
+00011f30: 2046 616c 7365 2e0a 2020 2020 2222 220a   False..    """.
+00011f40: 2020 2020 2320 4368 6563 6b20 696e 7075      # Check inpu
+00011f50: 7420 7061 7261 6d65 7465 7273 0a20 2020  t parameters.   
+00011f60: 2070 6174 6820 3d20 5061 7468 2870 6174   path = Path(pat
+00011f70: 6829 0a20 2020 2070 6174 685f 696e 666f  h).    path_info
+00011f80: 203d 205f 6765 6f66 696c 6569 6e66 6f2e   = _geofileinfo.
+00011f90: 6765 745f 6765 6f66 696c 6569 6e66 6f28  get_geofileinfo(
+00011fa0: 7061 7468 290a 0a20 2020 2023 2049 6620  path)..    # If 
+00011fb0: 7468 6572 6520 6973 2061 206c 6f63 6b20  there is a lock 
+00011fc0: 6669 6c65 2c20 7265 6d6f 7665 2069 740a  file, remove it.
+00011fd0: 2020 2020 6c6f 636b 6669 6c65 5f70 6174      lockfile_pat
+00011fe0: 6820 3d20 7061 7468 2e70 6172 656e 7420  h = path.parent 
+00011ff0: 2f20 6622 7b70 6174 682e 6e61 6d65 7d2e  / f"{path.name}.
+00012000: 6c6f 636b 220a 2020 2020 6c6f 636b 6669  lock".    lockfi
+00012010: 6c65 5f70 6174 682e 756e 6c69 6e6b 286d  le_path.unlink(m
+00012020: 6973 7369 6e67 5f6f 6b3d 5472 7565 290a  issing_ok=True).
+00012030: 0a20 2020 2023 2052 656d 6f76 6520 7468  .    # Remove th
+00012040: 6520 6d61 696e 2066 696c 650a 2020 2020  e main file.    
+00012050: 6966 2070 6174 682e 6578 6973 7473 2829  if path.exists()
+00012060: 3a0a 2020 2020 2020 2020 7061 7468 2e75  :.        path.u
+00012070: 6e6c 696e 6b28 6d69 7373 696e 675f 6f6b  nlink(missing_ok
+00012080: 3d6d 6973 7369 6e67 5f6f 6b29 0a0a 2020  =missing_ok)..  
+00012090: 2020 2320 466f 7220 736f 6d65 2066 696c    # For some fil
+000120a0: 6520 7479 7065 732c 2065 7874 7261 2066  e types, extra f
+000120b0: 696c 6573 206e 6565 6420 746f 2062 6520  iles need to be 
+000120c0: 7265 6d6f 7665 640a 2020 2020 6966 2070  removed.    if p
+000120d0: 6174 685f 696e 666f 2e73 7566 6669 7865  ath_info.suffixe
+000120e0: 735f 6578 7472 6166 696c 6573 2069 7320  s_extrafiles is 
+000120f0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+00012100: 2020 666f 7220 7375 6666 6978 2069 6e20    for suffix in 
+00012110: 7061 7468 5f69 6e66 6f2e 7375 6666 6978  path_info.suffix
+00012120: 6573 5f65 7874 7261 6669 6c65 733a 0a20  es_extrafiles:. 
+00012130: 2020 2020 2020 2020 2020 2063 7572 725f             curr_
+00012140: 7061 7468 203d 2070 6174 682e 7061 7265  path = path.pare
+00012150: 6e74 202f 2066 227b 7061 7468 2e73 7465  nt / f"{path.ste
+00012160: 6d7d 7b73 7566 6669 787d 220a 2020 2020  m}{suffix}".    
+00012170: 2020 2020 2020 2020 6375 7272 5f70 6174          curr_pat
+00012180: 682e 756e 6c69 6e6b 286d 6973 7369 6e67  h.unlink(missing
+00012190: 5f6f 6b3d 5472 7565 290a 0a0a 6465 6620  _ok=True)...def 
+000121a0: 6170 7065 6e64 5f74 6f28 0a20 2020 2073  append_to(.    s
+000121b0: 7263 3a20 556e 696f 6e5b 7374 722c 2022  rc: Union[str, "
+000121c0: 6f73 2e50 6174 684c 696b 655b 416e 795d  os.PathLike[Any]
+000121d0: 225d 2c0a 2020 2020 6473 743a 2055 6e69  "],.    dst: Uni
+000121e0: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
+000121f0: 4c69 6b65 5b41 6e79 5d22 5d2c 0a20 2020  Like[Any]"],.   
+00012200: 2073 7263 5f6c 6179 6572 3a20 4f70 7469   src_layer: Opti
+00012210: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+00012220: 2c0a 2020 2020 6473 745f 6c61 7965 723a  ,.    dst_layer:
+00012230: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
+00012240: 204e 6f6e 652c 0a20 2020 2073 7263 5f63   None,.    src_c
+00012250: 7273 3a20 556e 696f 6e5b 696e 742c 2073  rs: Union[int, s
+00012260: 7472 2c20 4e6f 6e65 5d20 3d20 4e6f 6e65  tr, None] = None
+00012270: 2c0a 2020 2020 6473 745f 6372 733a 2055  ,.    dst_crs: U
+00012280: 6e69 6f6e 5b69 6e74 2c20 7374 722c 204e  nion[int, str, N
+00012290: 6f6e 655d 203d 204e 6f6e 652c 0a20 2020  one] = None,.   
+000122a0: 2063 6f6c 756d 6e73 3a20 4f70 7469 6f6e   columns: Option
+000122b0: 616c 5b49 7465 7261 626c 655b 7374 725d  al[Iterable[str]
+000122c0: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 7768  ] = None,.    wh
+000122d0: 6572 653a 204f 7074 696f 6e61 6c5b 7374  ere: Optional[st
+000122e0: 725d 203d 204e 6f6e 652c 0a20 2020 2073  r] = None,.    s
+000122f0: 716c 5f73 746d 743a 204f 7074 696f 6e61  ql_stmt: Optiona
+00012300: 6c5b 7374 725d 203d 204e 6f6e 652c 0a20  l[str] = None,. 
+00012310: 2020 2073 716c 5f64 6961 6c65 6374 3a20     sql_dialect: 
+00012320: 4f70 7469 6f6e 616c 5b4c 6974 6572 616c  Optional[Literal
+00012330: 5b22 5351 4c49 5445 222c 2022 4f47 5253  ["SQLITE", "OGRS
+00012340: 514c 225d 5d20 3d20 4e6f 6e65 2c0a 2020  QL"]] = None,.  
+00012350: 2020 7265 7072 6f6a 6563 743a 2062 6f6f    reproject: boo
+00012360: 6c20 3d20 4661 6c73 652c 0a20 2020 2065  l = False,.    e
+00012370: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
+00012380: 733a 2062 6f6f 6c20 3d20 4661 6c73 652c  s: bool = False,
+00012390: 0a20 2020 2066 6f72 6365 5f6f 7574 7075  .    force_outpu
+000123a0: 745f 6765 6f6d 6574 7279 7479 7065 3a20  t_geometrytype: 
+000123b0: 556e 696f 6e5b 4765 6f6d 6574 7279 5479  Union[GeometryTy
+000123c0: 7065 2c20 7374 722c 204e 6f6e 655d 203d  pe, str, None] =
+000123d0: 204e 6f6e 652c 0a20 2020 2063 7265 6174   None,.    creat
+000123e0: 655f 7370 6174 6961 6c5f 696e 6465 783a  e_spatial_index:
+000123f0: 204f 7074 696f 6e61 6c5b 626f 6f6c 5d20   Optional[bool] 
+00012400: 3d20 5472 7565 2c0a 2020 2020 6170 7065  = True,.    appe
+00012410: 6e64 5f74 696d 656f 7574 5f73 3a20 696e  nd_timeout_s: in
+00012420: 7420 3d20 3630 302c 0a20 2020 2074 7261  t = 600,.    tra
+00012430: 6e73 6163 7469 6f6e 5f73 697a 653a 2069  nsaction_size: i
+00012440: 6e74 203d 2035 3030 3030 2c0a 2020 2020  nt = 50000,.    
+00012450: 7072 6573 6572 7665 5f66 6964 3a20 4f70  preserve_fid: Op
+00012460: 7469 6f6e 616c 5b62 6f6f 6c5d 203d 204e  tional[bool] = N
+00012470: 6f6e 652c 0a20 2020 2064 7374 5f64 696d  one,.    dst_dim
+00012480: 656e 7369 6f6e 733a 204f 7074 696f 6e61  ensions: Optiona
+00012490: 6c5b 7374 725d 203d 204e 6f6e 652c 0a20  l[str] = None,. 
+000124a0: 2020 206f 7074 696f 6e73 3a20 6469 6374     options: dict
+000124b0: 203d 207b 7d2c 0a29 3a0a 2020 2020 2222   = {},.):.    ""
+000124c0: 220a 2020 2020 4170 7065 6e64 2073 7263  ".    Append src
+000124d0: 2066 696c 6520 746f 2074 6865 2064 7374   file to the dst
+000124e0: 2066 696c 652e 0a0a 2020 2020 4966 2061   file...    If a
+000124f0: 6e20 7371 6c5f 7374 6d74 2069 7320 7370  n sql_stmt is sp
+00012500: 6563 6966 6965 642c 2074 6865 2073 716c  ecified, the sql
+00012510: 6974 6520 7175 6572 7920 6361 6e20 636f  ite query can co
+00012520: 6e74 6169 6e20 666f 6c6c 6f77 696e 6720  ntain following 
+00012530: 706c 6163 6568 6f6c 6465 7273 0a20 2020  placeholders.   
+00012540: 2074 6861 7420 7769 6c6c 2062 6520 6175   that will be au
+00012550: 746f 6d61 7469 6361 6c6c 7920 7265 706c  tomatically repl
+00012560: 6163 6564 2066 6f72 2079 6f75 3a0a 0a20  aced for you:.. 
+00012570: 2020 2020 202a 207b 6765 6f6d 6574 7279       * {geometry
+00012580: 636f 6c75 6d6e 7d3a 2074 6865 2063 6f6c  column}: the col
+00012590: 756d 6e20 7768 6572 6520 7468 6520 7072  umn where the pr
+000125a0: 696d 6172 7920 6765 6f6d 6574 7279 2069  imary geometry i
+000125b0: 7320 7374 6f72 6564 2e0a 2020 2020 2020  s stored..      
+000125c0: 2a20 7b63 6f6c 756d 6e73 5f74 6f5f 7365  * {columns_to_se
+000125d0: 6c65 6374 5f73 7472 7d3a 2069 6620 2763  lect_str}: if 'c
+000125e0: 6f6c 756d 6e73 2720 6973 206e 6f74 204e  olumns' is not N
+000125f0: 6f6e 652c 2074 686f 7365 2063 6f6c 756d  one, those colum
+00012600: 6e73 2c0a 2020 2020 2020 2020 6f74 6865  ns,.        othe
+00012610: 7277 6973 6520 616c 6c20 636f 6c75 6d6e  rwise all column
+00012620: 7320 6f66 2074 6865 206c 6179 6572 2e0a  s of the layer..
+00012630: 2020 2020 2020 2a20 7b69 6e70 7574 5f6c        * {input_l
+00012640: 6179 6572 7d3a 2074 6865 206c 6179 6572  ayer}: the layer
+00012650: 206e 616d 6520 6f66 2074 6865 2069 6e70   name of the inp
+00012660: 7574 206c 6179 6572 2e0a 0a20 2020 2045  ut layer...    E
+00012670: 7861 6d70 6c65 2053 514c 2073 7461 7465  xample SQL state
+00012680: 6d65 6e74 2077 6974 6820 706c 6163 6568  ment with placeh
+00012690: 6f6c 6465 7273 3a0a 2020 2020 3a3a 0a0a  olders:.    ::..
+000126a0: 2020 2020 2020 2020 5345 4c45 4354 207b          SELECT {
+000126b0: 6765 6f6d 6574 7279 636f 6c75 6d6e 7d0a  geometrycolumn}.
+000126c0: 2020 2020 2020 2020 2020 2020 2020 7b63                {c
+000126d0: 6f6c 756d 6e73 5f74 6f5f 7365 6c65 6374  olumns_to_select
+000126e0: 5f73 7472 7d0a 2020 2020 2020 2020 2020  _str}.          
+000126f0: 4652 4f4d 2022 7b69 6e70 7574 5f6c 6179  FROM "{input_lay
+00012700: 6572 7d22 206c 6179 6572 0a0a 2020 2020  er}" layer..    
+00012710: 5468 6520 6f70 7469 6f6e 7320 7061 7261  The options para
+00012720: 6d65 7465 7220 6361 6e20 6265 2075 7365  meter can be use
+00012730: 6420 746f 2070 6173 7320 616e 7920 7479  d to pass any ty
+00012740: 7065 206f 6620 6f70 7469 6f6e 7320 746f  pe of options to
+00012750: 2047 4441 4c20 696e 0a20 2020 2074 6865   GDAL in.    the
+00012760: 2066 6f6c 6c6f 7769 6e67 2066 6f72 6d3a   following form:
+00012770: 0a20 2020 2020 2020 207b 2022 3c6f 7074  .        { "<opt
+00012780: 696f 6e5f 7479 7065 3e2e 3c6f 7074 696f  ion_type>.<optio
+00012790: 6e5f 6e61 6d65 3e22 3a20 3c6f 7074 696f  n_name>": <optio
+000127a0: 6e5f 7661 6c75 653e 207d 0a0a 2020 2020  n_value> }..    
+000127b0: 5468 6520 6f70 7469 6f6e 2074 7970 6573  The option types
+000127c0: 2063 616e 2062 6520 616e 7920 6f66 2074   can be any of t
+000127d0: 6865 2066 6f6c 6c6f 7769 6e67 3a0a 2020  he following:.  
+000127e0: 2020 2020 2020 2d20 4c41 5945 525f 4352        - LAYER_CR
+000127f0: 4541 5449 4f4e 3a20 6c61 7965 7220 6372  EATION: layer cr
+00012800: 6561 7469 6f6e 206f 7074 696f 6e20 286c  eation option (l
+00012810: 636f 290a 2020 2020 2020 2020 2d20 4441  co).        - DA
+00012820: 5441 5345 545f 4352 4541 5449 4f4e 3a20  TASET_CREATION: 
+00012830: 6461 7461 7365 7420 6372 6561 7469 6f6e  dataset creation
+00012840: 206f 7074 696f 6e20 2864 7363 6f29 0a20   option (dsco). 
+00012850: 2020 2020 2020 202d 2049 4e50 5554 5f4f         - INPUT_O
+00012860: 5045 4e3a 2069 6e70 7574 2064 6174 6173  PEN: input datas
+00012870: 6574 206f 7065 6e20 6f70 7469 6f6e 2028  et open option (
+00012880: 6f6f 290a 2020 2020 2020 2020 2d20 4445  oo).        - DE
+00012890: 5354 494e 4154 494f 4e5f 4f50 454e 3a20  STINATION_OPEN: 
+000128a0: 6465 7374 696e 6174 696f 6e20 6461 7461  destination data
+000128b0: 7365 7420 6f70 656e 206f 7074 696f 6e20  set open option 
+000128c0: 2864 6f6f 290a 2020 2020 2020 2020 2d20  (doo).        - 
+000128d0: 434f 4e46 4947 3a20 636f 6e66 6967 206f  CONFIG: config o
+000128e0: 7074 696f 6e20 2863 6f6e 6669 6729 0a0a  ption (config)..
+000128f0: 2020 2020 5468 6520 6f70 7469 6f6e 7320      The options 
+00012900: 6361 6e20 6265 2066 6f75 6e64 2069 6e20  can be found in 
+00012910: 7468 6520 7c47 4441 4c5f 7665 6374 6f72  the |GDAL_vector
+00012920: 5f64 7269 7665 725f 646f 6375 6d65 6e74  _driver_document
+00012930: 6174 696f 6e7c 2e0a 0a20 2020 2041 7267  ation|...    Arg
+00012940: 733a 0a20 2020 2020 2020 2073 7263 2028  s:.        src (
+00012950: 556e 696f 6e5b 7374 722c 293a 2073 6f75  Union[str,): sou
+00012960: 7263 6520 6669 6c65 2070 6174 682e 0a20  rce file path.. 
+00012970: 2020 2020 2020 2064 7374 2028 556e 696f         dst (Unio
+00012980: 6e5b 7374 722c 293a 2064 6573 7469 6e61  n[str,): destina
+00012990: 7469 6f6e 2066 696c 6520 7061 7468 2e0a  tion file path..
+000129a0: 2020 2020 2020 2020 7372 635f 6c61 7965          src_laye
+000129b0: 7220 2873 7472 2c20 6f70 7469 6f6e 616c  r (str, optional
+000129c0: 293a 2073 6f75 7263 6520 6c61 7965 722e  ): source layer.
+000129d0: 2044 6566 6175 6c74 7320 746f 204e 6f6e   Defaults to Non
+000129e0: 652e 0a20 2020 2020 2020 2064 7374 5f6c  e..        dst_l
+000129f0: 6179 6572 2028 7374 722c 206f 7074 696f  ayer (str, optio
+00012a00: 6e61 6c29 3a20 6465 7374 696e 6174 696f  nal): destinatio
+00012a10: 6e20 6c61 7965 722e 2044 6566 6175 6c74  n layer. Default
+00012a20: 7320 746f 204e 6f6e 652e 0a20 2020 2020  s to None..     
+00012a30: 2020 2073 7263 5f63 7273 2028 7374 722c     src_crs (str,
+00012a40: 206f 7074 696f 6e61 6c29 3a20 616e 2065   optional): an e
+00012a50: 7073 6720 696e 7420 6f72 2061 6e79 7468  psg int or anyth
+00012a60: 696e 6720 7375 7070 6f72 7465 640a 2020  ing supported.  
+00012a70: 2020 2020 2020 2020 2020 6279 2074 6865            by the
+00012a80: 204f 4752 5370 6174 6961 6c52 6566 6572   OGRSpatialRefer
+00012a90: 656e 6365 2e53 6574 4672 6f6d 5573 6572  ence.SetFromUser
+00012aa0: 496e 7075 7428 2920 6361 6c6c 2c20 7768  Input() call, wh
+00012ab0: 6963 6820 696e 636c 7564 6573 0a20 2020  ich includes.   
+00012ac0: 2020 2020 2020 2020 2061 6e20 4550 5347           an EPSG
+00012ad0: 2073 7472 696e 6720 2865 672e 2022 4550   string (eg. "EP
+00012ae0: 5347 3a34 3332 3622 292c 2061 2077 656c  SG:4326"), a wel
+00012af0: 6c20 6b6e 6f77 6e20 7465 7874 2028 574b  l known text (WK
+00012b00: 5429 2043 5253 0a20 2020 2020 2020 2020  T) CRS.         
+00012b10: 2020 2064 6566 696e 6974 696f 6e2c 2e2e     definition,..
+00012b20: 2e20 4465 6661 756c 7473 2074 6f20 4e6f  . Defaults to No
+00012b30: 6e65 2e0a 2020 2020 2020 2020 6473 745f  ne..        dst_
+00012b40: 6372 7320 2873 7472 2c20 6f70 7469 6f6e  crs (str, option
+00012b50: 616c 293a 2061 6e20 6570 7367 2069 6e74  al): an epsg int
+00012b60: 206f 7220 616e 7974 6869 6e67 2073 7570   or anything sup
+00012b70: 706f 7274 6564 0a20 2020 2020 2020 2020  ported.         
+00012b80: 2020 2062 7920 7468 6520 4f47 5253 7061     by the OGRSpa
+00012b90: 7469 616c 5265 6665 7265 6e63 652e 5365  tialReference.Se
+00012ba0: 7446 726f 6d55 7365 7249 6e70 7574 2829  tFromUserInput()
+00012bb0: 2063 616c 6c2c 2077 6869 6368 2069 6e63   call, which inc
+00012bc0: 6c75 6465 730a 2020 2020 2020 2020 2020  ludes.          
+00012bd0: 2020 616e 2045 5053 4720 7374 7269 6e67    an EPSG string
+00012be0: 2028 6567 2e20 2245 5053 473a 3433 3236   (eg. "EPSG:4326
+00012bf0: 2229 2c20 6120 7765 6c6c 206b 6e6f 776e  "), a well known
+00012c00: 2074 6578 7420 2857 4b54 2920 4352 530a   text (WKT) CRS.
+00012c10: 2020 2020 2020 2020 2020 2020 6465 6669              defi
+00012c20: 6e69 7469 6f6e 2c2e 2e2e 2044 6566 6175  nition,... Defau
+00012c30: 6c74 7320 746f 204e 6f6e 652e 0a20 2020  lts to None..   
+00012c40: 2020 2020 2063 6f6c 756d 6e73 2028 4974       columns (It
+00012c50: 6572 6162 6c65 5b73 7472 5d2c 206f 7074  erable[str], opt
+00012c60: 696f 6e61 6c29 3a20 5468 6520 286e 6f6e  ional): The (non
+00012c70: 2d67 656f 6d65 7472 7929 2063 6f6c 756d  -geometry) colum
+00012c80: 6e73 2074 6f20 7265 6164 2077 696c 6c0a  ns to read will.
+00012c90: 2020 2020 2020 2020 2020 2020 6265 2072              be r
+00012ca0: 6574 7572 6e65 6420 696e 2074 6865 206f  eturned in the o
+00012cb0: 7264 6572 2073 7065 6369 6669 6564 2e20  rder specified. 
+00012cc0: 4966 204e 6f6e 652c 2061 6c6c 2073 7461  If None, all sta
+00012cd0: 6e64 6172 6420 636f 6c75 6d6e 7320 6172  ndard columns ar
+00012ce0: 6520 7265 6164 2e0a 2020 2020 2020 2020  e read..        
+00012cf0: 2020 2020 496e 2061 6464 6974 696f 6e20      In addition 
+00012d00: 746f 2073 7461 6e64 6172 6420 636f 6c75  to standard colu
+00012d10: 6d6e 732c 2069 7420 6973 2061 6c73 6f20  mns, it is also 
+00012d20: 706f 7373 6962 6c65 0a20 2020 2020 2020  possible.       
+00012d30: 2020 2020 2074 6f20 7370 6563 6966 7920       to specify 
+00012d40: 2266 6964 222c 2061 2075 6e69 7175 6520  "fid", a unique 
+00012d50: 696e 6465 7820 6176 6169 6c61 626c 6520  index available 
+00012d60: 696e 2061 6c6c 2069 6e70 7574 2066 696c  in all input fil
+00012d70: 6573 2e20 4e6f 7465 2074 6861 7420 7468  es. Note that th
+00012d80: 650a 2020 2020 2020 2020 2020 2020 2266  e.            "f
+00012d90: 6964 2220 7769 6c6c 2062 6520 616c 6961  id" will be alia
+00012da0: 7365 6420 6567 2e20 746f 2022 6669 645f  sed eg. to "fid_
+00012db0: 3122 2e20 4465 6661 756c 7473 2074 6f20  1". Defaults to 
+00012dc0: 4e6f 6e65 2e0a 2020 2020 2020 2020 7768  None..        wh
+00012dd0: 6572 6520 2873 7472 2c20 6f70 7469 6f6e  ere (str, option
+00012de0: 616c 293a 206f 6e6c 7920 6170 7065 6e64  al): only append
+00012df0: 2074 6865 2072 6f77 7320 6672 6f6d 2073   the rows from s
+00012e00: 7263 2074 6861 7420 636f 6d70 6c79 2074  rc that comply t
+00012e10: 6f20 7468 6520 6669 6c74 6572 0a20 2020  o the filter.   
+00012e20: 2020 2020 2020 2020 2073 7065 6369 6669           specifi
+00012e30: 6564 2e20 4170 706c 6965 6420 6265 666f  ed. Applied befo
+00012e40: 7265 2065 7870 6c6f 6465 636f 6c6c 6563  re explodecollec
+00012e50: 7469 6f6e 732e 2046 696c 7465 7220 7368  tions. Filter sh
+00012e60: 6f75 6c64 2062 6520 696e 2073 716c 6974  ould be in sqlit
+00012e70: 650a 2020 2020 2020 2020 2020 2020 5351  e.            SQ
+00012e80: 4c20 5748 4552 4520 7379 6e74 6178 2061  L WHERE syntax a
+00012e90: 6e64 207c 7370 6174 6961 6c69 7465 5f72  nd |spatialite_r
+00012ea0: 6566 6572 656e 6365 5f6c 696e 6b7c 2066  eference_link| f
+00012eb0: 756e 6374 696f 6e73 2063 616e 2062 6520  unctions can be 
+00012ec0: 7573 6564 2e20 4966 0a20 2020 2020 2020  used. If.       
+00012ed0: 2020 2020 2077 6865 7265 2063 6f6e 7461       where conta
+00012ee0: 696e 7320 7468 6520 7b67 656f 6d65 7472  ins the {geometr
+00012ef0: 7963 6f6c 756d 6e7d 2070 6c61 6365 686f  ycolumn} placeho
+00012f00: 6c64 6572 2c20 6974 2069 7320 6669 6c6c  lder, it is fill
+00012f10: 6564 206f 7574 2077 6974 6820 7468 650a  ed out with the.
+00012f20: 2020 2020 2020 2020 2020 2020 6765 6f6d              geom
+00012f30: 6574 7279 2063 6f6c 756d 6e20 6e61 6d65  etry column name
+00012f40: 206f 6620 7468 6520 7372 6320 6669 6c65   of the src file
+00012f50: 2e20 4465 6661 756c 7473 2074 6f20 4e6f  . Defaults to No
+00012f60: 6e65 2e0a 2020 2020 2020 2020 7371 6c5f  ne..        sql_
+00012f70: 7374 6d74 2028 7374 7229 3a20 5351 4c20  stmt (str): SQL 
+00012f80: 7374 6174 656d 656e 7420 746f 2075 7365  statement to use
+00012f90: 2e20 4f6e 6c79 2073 7570 706f 7274 6564  . Only supported
+00012fa0: 2077 6974 6820 2270 796f 6772 696f 2220   with "pyogrio" 
+00012fb0: 656e 6769 6e65 2e0a 2020 2020 2020 2020  engine..        
+00012fc0: 7371 6c5f 6469 616c 6563 7420 2873 7472  sql_dialect (str
+00012fd0: 2c20 6f70 7469 6f6e 616c 293a 2053 514c  , optional): SQL
+00012fe0: 2064 6961 6c65 6374 2075 7365 642e 204f   dialect used. O
+00012ff0: 7074 696f 6e73 2061 7265 204e 6f6e 652c  ptions are None,
+00013000: 2022 5351 4c49 5445 2220 6f72 0a20 2020   "SQLITE" or.   
+00013010: 2020 2020 2020 2020 2022 4f47 5253 514c           "OGRSQL
+00013020: 222e 2049 6620 4e6f 6e65 2c20 666f 7220  ". If None, for 
+00013030: 6461 7461 2073 6f75 7263 6573 2077 6974  data sources wit
+00013040: 6820 6578 706c 6963 6974 2053 514c 2073  h explicit SQL s
+00013050: 7570 706f 7274 2074 6865 2073 7461 7465  upport the state
+00013060: 6d65 6e74 0a20 2020 2020 2020 2020 2020  ment.           
+00013070: 2069 7320 7072 6f63 6573 7365 6420 6279   is processed by
+00013080: 2074 6865 2064 6566 6175 6c74 2053 514c   the default SQL
+00013090: 2065 6e67 696e 6520 2865 2e67 2e20 666f   engine (e.g. fo
+000130a0: 7220 4765 6f70 6163 6b61 6765 2061 6e64  r Geopackage and
+000130b0: 2053 7061 7469 616c 6974 650a 2020 2020   Spatialite.    
+000130c0: 2020 2020 2020 2020 7468 6973 2069 7320          this is 
+000130d0: 2253 514c 4954 4522 292e 2046 6f72 2064  "SQLITE"). For d
+000130e0: 6174 6120 736f 7572 6365 7320 7769 7468  ata sources with
+000130f0: 6f75 7420 6e61 7469 7665 2053 514c 2073  out native SQL s
+00013100: 7570 706f 7274 2028 652e 672e 202e 7368  upport (e.g. .sh
+00013110: 7029 2c0a 2020 2020 2020 2020 2020 2020  p),.            
+00013120: 7468 6520 224f 4752 5351 4c22 2064 6961  the "OGRSQL" dia
+00013130: 6c65 6374 2069 7320 7468 6520 6465 6661  lect is the defa
+00013140: 756c 742e 2049 6620 7468 6520 2253 514c  ult. If the "SQL
+00013150: 4954 4522 2064 6961 6c65 6374 2069 7320  ITE" dialect is 
+00013160: 7370 6563 6966 6965 642c 0a20 2020 2020  specified,.     
+00013170: 2020 2020 2020 207c 7370 6174 6961 6c69         |spatiali
+00013180: 7465 5f72 6566 6572 656e 6365 5f6c 696e  te_reference_lin
+00013190: 6b7c 2066 756e 6374 696f 6e73 2063 616e  k| functions can
+000131a0: 2061 6c73 6f20 6265 2075 7365 642e 2044   also be used. D
+000131b0: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
+000131c0: 0a20 2020 2020 2020 2072 6570 726f 6a65  .        reproje
+000131d0: 6374 2028 626f 6f6c 2c20 6f70 7469 6f6e  ct (bool, option
+000131e0: 616c 293a 2054 7275 6520 746f 2072 6570  al): True to rep
+000131f0: 726f 6a65 6374 2077 6869 6c65 2063 6f6e  roject while con
+00013200: 7665 7274 696e 6720 7468 650a 2020 2020  verting the.    
+00013210: 2020 2020 2020 2020 6669 6c65 2e20 4465          file. De
+00013220: 6661 756c 7473 2074 6f20 4661 6c73 652e  faults to False.
+00013230: 0a20 2020 2020 2020 2065 7870 6c6f 6465  .        explode
+00013240: 636f 6c6c 6563 7469 6f6e 7320 2862 6f6f  collections (boo
+00013250: 6c29 2c20 6f70 7469 6f6e 616c 293a 2054  l), optional): T
+00013260: 7275 6520 746f 206f 7574 7075 7420 6f6e  rue to output on
+00013270: 6c79 2073 696d 706c 6520 6765 6f6d 6574  ly simple geomet
+00013280: 7269 6573 2e0a 2020 2020 2020 2020 2020  ries..          
+00013290: 2020 4465 6661 756c 7473 2074 6f20 4661    Defaults to Fa
+000132a0: 6c73 652e 0a20 2020 2020 2020 2066 6f72  lse..        for
+000132b0: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
+000132c0: 7279 7479 7065 2028 556e 696f 6e5b 4765  rytype (Union[Ge
+000132d0: 6f6d 6574 7279 5479 7065 2c20 7374 725d  ometryType, str]
+000132e0: 2c20 6f70 7469 6f6e 616c 293a 2047 656f  , optional): Geo
+000132f0: 6d65 7472 7920 7479 7065 2e0a 2020 2020  metry type..    
+00013300: 2020 2020 2020 2020 746f 2028 7472 7920          to (try 
+00013310: 746f 2920 666f 7263 6520 7468 6520 6f75  to) force the ou
+00013320: 7470 7574 2074 6f2e 2044 6566 6175 6c74  tput to. Default
+00013330: 7320 746f 204e 6f6e 652e 0a20 2020 2020  s to None..     
+00013340: 2020 2063 7265 6174 655f 7370 6174 6961     create_spatia
+00013350: 6c5f 696e 6465 7820 2862 6f6f 6c2c 206f  l_index (bool, o
+00013360: 7074 696f 6e61 6c29 3a20 5472 7565 2074  ptional): True t
+00013370: 6f20 6372 6561 7465 2061 2073 7061 7469  o create a spati
+00013380: 616c 2069 6e64 6578 0a20 2020 2020 2020  al index.       
+00013390: 2020 2020 206f 6e20 7468 6520 6465 7374       on the dest
+000133a0: 696e 6174 696f 6e20 6669 6c65 2f6c 6179  ination file/lay
+000133b0: 6572 2e20 4966 204e 6f6e 652c 2074 6865  er. If None, the
+000133c0: 2064 6566 6175 6c74 2062 6568 6176 696f   default behavio
+000133d0: 7572 2062 7920 6764 616c 2066 6f72 0a20  ur by gdal for. 
+000133e0: 2020 2020 2020 2020 2020 2074 6861 7420             that 
+000133f0: 6669 6c65 2074 7970 6520 6973 2072 6573  file type is res
+00013400: 7065 6374 6564 2e20 4966 2074 6865 2060  pected. If the `
+00013410: 4c41 5945 525f 4352 4541 5449 4f4e 2e53  LAYER_CREATION.S
+00013420: 5041 5449 414c 5f49 4e44 4558 600a 2020  PATIAL_INDEX`.  
+00013430: 2020 2020 2020 2020 2020 7061 7261 6d65            parame
+00013440: 7465 7220 6973 2073 7065 6369 6669 6564  ter is specified
+00013450: 2069 6e20 6f70 7469 6f6e 732c 2060 6372   in options, `cr
+00013460: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
+00013470: 6578 6020 6973 2069 676e 6f72 6564 2e20  ex` is ignored. 
+00013480: 4966 2074 6865 0a20 2020 2020 2020 2020  If the.         
+00013490: 2020 2064 6573 7469 6e61 7469 6f6e 206c     destination l
+000134a0: 6179 6572 2065 7869 7374 7320 616c 7265  ayer exists alre
+000134b0: 6164 792c 2060 6372 6561 7465 5f73 7061  ady, `create_spa
+000134c0: 7469 616c 5f69 6e64 6578 6020 6973 2061  tial_index` is a
+000134d0: 6c73 6f20 6967 6e6f 7265 642e 0a20 2020  lso ignored..   
+000134e0: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
+000134f0: 7320 746f 2054 7275 652e 0a20 2020 2020  s to True..     
+00013500: 2020 2061 7070 656e 645f 7469 6d65 6f75     append_timeou
+00013510: 745f 7320 2869 6e74 2c20 6f70 7469 6f6e  t_s (int, option
+00013520: 616c 293a 2074 696d 656f 7574 2074 6f20  al): timeout to 
+00013530: 7573 6520 6966 2074 6865 206f 7574 7075  use if the outpu
+00013540: 7420 6669 6c65 2069 730a 2020 2020 2020  t file is.      
+00013550: 2020 2020 2020 6265 696e 6720 7772 6974        being writ
+00013560: 7465 6e20 746f 2062 7920 616e 6f74 6865  ten to by anothe
+00013570: 7220 7072 6f63 6573 7320 616c 7265 6164  r process alread
+00013580: 792e 2044 6566 6175 6c74 7320 746f 2036  y. Defaults to 6
+00013590: 3030 2e0a 2020 2020 2020 2020 7472 616e  00..        tran
+000135a0: 7361 6374 696f 6e5f 7369 7a65 2028 696e  saction_size (in
+000135b0: 742c 206f 7074 696f 6e61 6c29 3a20 5472  t, optional): Tr
+000135c0: 616e 7361 6374 696f 6e20 7369 7a65 2e20  ansaction size. 
+000135d0: 4465 6661 756c 7473 2074 6f20 3530 3030  Defaults to 5000
+000135e0: 302e 0a20 2020 2020 2020 2070 7265 7365  0..        prese
+000135f0: 7276 655f 6669 6420 2862 6f6f 6c2c 206f  rve_fid (bool, o
+00013600: 7074 696f 6e61 6c29 3a20 5472 7565 2074  ptional): True t
+00013610: 6f20 6d61 6b65 2061 6e20 6578 7472 6120  o make an extra 
+00013620: 6566 666f 7274 2074 6f20 7072 6573 6572  effort to preser
+00013630: 7665 2066 6964 2773 206f 660a 2020 2020  ve fid's of.    
+00013640: 2020 2020 2020 2020 7468 6520 736f 7572          the sour
+00013650: 6365 206c 6179 6572 2074 6f20 7468 6520  ce layer to the 
+00013660: 6465 7374 696e 6174 696f 6e20 6c61 7965  destination laye
+00013670: 722e 2046 616c 7365 206e 6f74 2074 6f20  r. False not to 
+00013680: 646f 2061 6e79 2065 6666 6f72 742e 204e  do any effort. N
+00013690: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
+000136a0: 746f 2075 7365 2074 6865 2064 6566 6175  to use the defau
+000136b0: 6c74 2062 6568 6176 696f 7572 206f 6620  lt behaviour of 
+000136c0: 6764 616c 2c20 7468 6174 2061 6c72 6561  gdal, that alrea
+000136d0: 6479 2070 7265 7365 7276 6573 2069 6e20  dy preserves in 
+000136e0: 736f 6d65 2063 6173 6573 2e0a 2020 2020  some cases..    
+000136f0: 2020 2020 2020 2020 536f 6d65 2066 696c          Some fil
+00013700: 6520 666f 726d 6174 7320 646f 6e27 7420  e formats don't 
+00013710: 6578 706c 6963 6974 6c79 2073 746f 7265  explicitly store
+00013720: 2074 6865 2066 6964 2028 652e 672e 2073   the fid (e.g. s
+00013730: 6861 7065 6669 6c65 292c 2073 6f20 7468  hapefile), so th
+00013740: 6579 0a20 2020 2020 2020 2020 2020 2077  ey.            w
+00013750: 696c 6c20 6e65 7665 7220 6265 2061 626c  ill never be abl
+00013760: 6520 746f 2070 7265 7365 7276 6520 6669  e to preserve fi
+00013770: 6473 2e20 4465 6661 756c 7473 2074 6f20  ds. Defaults to 
+00013780: 4e6f 6e65 2e0a 2020 2020 2020 2020 6473  None..        ds
+00013790: 745f 6469 6d65 6e73 696f 6e73 2028 7374  t_dimensions (st
+000137a0: 722c 206f 7074 696f 6e61 6c29 3a20 466f  r, optional): Fo
+000137b0: 7263 6520 7468 6520 6469 6d65 6e73 696f  rce the dimensio
+000137c0: 6e73 206f 6620 7468 6520 6465 7374 696e  ns of the destin
+000137d0: 6174 696f 6e20 6c61 7965 7220 746f 0a20  ation layer to. 
+000137e0: 2020 2020 2020 2020 2020 2074 6865 2076             the v
+000137f0: 616c 7565 2073 7065 6369 6669 6564 2e20  alue specified. 
+00013800: 5661 6c69 6420 7661 6c75 6573 3a20 2258  Valid values: "X
+00013810: 5922 2c20 2258 595a 222c 2022 5859 4d22  Y", "XYZ", "XYM"
+00013820: 206f 7220 2258 595a 4d22 2e0a 2020 2020   or "XYZM"..    
+00013830: 2020 2020 2020 2020 4465 6661 756c 7473          Defaults
+00013840: 2074 6f20 4e6f 6e65 2e0a 2020 2020 2020   to None..      
+00013850: 2020 6f70 7469 6f6e 7320 2864 6963 742c    options (dict,
+00013860: 206f 7074 696f 6e61 6c29 3a20 6f70 7469   optional): opti
+00013870: 6f6e 7320 746f 2070 6173 7320 746f 2067  ons to pass to g
+00013880: 6461 6c2e 0a0a 2020 2020 5261 6973 6573  dal...    Raises
+00013890: 3a0a 2020 2020 2020 2020 5661 6c75 6545  :.        ValueE
+000138a0: 7272 6f72 3a20 616e 2069 6e76 616c 6964  rror: an invalid
+000138b0: 2070 6172 616d 6574 6572 2076 616c 7565   parameter value
+000138c0: 2077 6173 2070 6173 7365 642e 0a20 2020   was passed..   
+000138d0: 2020 2020 2052 756e 7469 6d65 4572 726f       RuntimeErro
+000138e0: 723a 2074 696d 656f 7574 2077 6173 2072  r: timeout was r
+000138f0: 6561 6368 6564 2077 6869 6c65 2074 7279  eached while try
+00013900: 696e 6720 746f 2061 7070 656e 6420 6461  ing to append da
+00013910: 7461 2074 6f20 7061 7468 2e0a 0a20 2020  ta to path...   
+00013920: 202e 2e20 7c73 7061 7469 616c 6974 655f   .. |spatialite_
+00013930: 7265 6665 7265 6e63 655f 6c69 6e6b 7c20  reference_link| 
+00013940: 7261 773a 3a20 6874 6d6c 0a0a 2020 2020  raw:: html..    
+00013950: 2020 2020 3c61 2068 7265 663d 2268 7474      <a href="htt
+00013960: 7073 3a2f 2f77 7777 2e67 6169 612d 6769  ps://www.gaia-gi
+00013970: 732e 6974 2f67 6169 612d 7369 6e73 2f73  s.it/gaia-sins/s
+00013980: 7061 7469 616c 6974 652d 7371 6c2d 6c61  patialite-sql-la
+00013990: 7465 7374 2e68 746d 6c22 2074 6172 6765  test.html" targe
+000139a0: 743d 225f 626c 616e 6b22 3e73 7061 7469  t="_blank">spati
+000139b0: 616c 6974 6520 7265 6665 7265 6e63 653c  alite reference<
+000139c0: 2f61 3e0a 0a20 2020 202e 2e20 7c47 4441  /a>..    .. |GDA
+000139d0: 4c5f 7665 6374 6f72 5f64 7269 7665 725f  L_vector_driver_
+000139e0: 646f 6375 6d65 6e74 6174 696f 6e7c 2072  documentation| r
+000139f0: 6177 3a3a 2068 746d 6c0a 0a20 2020 2020  aw:: html..     
+00013a00: 2020 203c 6120 6872 6566 3d22 6874 7470     <a href="http
+00013a10: 733a 2f2f 6764 616c 2e6f 7267 2f64 7269  s://gdal.org/dri
+00013a20: 7665 7273 2f76 6563 746f 722f 696e 6465  vers/vector/inde
+00013a30: 782e 6874 6d6c 2220 7461 7267 6574 3d22  x.html" target="
+00013a40: 5f62 6c61 6e6b 223e 4744 414c 2076 6563  _blank">GDAL vec
+00013a50: 746f 7220 6472 6976 6572 2064 6f63 756d  tor driver docum
+00013a60: 656e 7461 7469 6f6e 3c2f 613e 0a0a 2020  entation</a>..  
+00013a70: 2020 2222 2220 2023 206e 6f71 613a 2045    """  # noqa: E
+00013a80: 3530 310a 2020 2020 2320 4368 6563 6b2f  501.    # Check/
+00013a90: 636c 6561 6e20 696e 7075 7420 7061 7261  clean input para
+00013aa0: 6d73 0a20 2020 2073 7263 203d 2050 6174  ms.    src = Pat
+00013ab0: 6828 7372 6329 0a20 2020 2064 7374 203d  h(src).    dst =
+00013ac0: 2050 6174 6828 6473 7429 0a20 2020 2069   Path(dst).    i
+00013ad0: 6620 666f 7263 655f 6f75 7470 7574 5f67  f force_output_g
+00013ae0: 656f 6d65 7472 7974 7970 6520 6973 206e  eometrytype is n
+00013af0: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+00013b00: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
+00013b10: 6f6d 6574 7279 7479 7065 203d 2047 656f  ometrytype = Geo
+00013b20: 6d65 7472 7954 7970 6528 666f 7263 655f  metryType(force_
+00013b30: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
+00013b40: 7970 6529 0a0a 2020 2020 2320 4669 6c65  ype)..    # File
+00013b50: 7320 646f 6e27 7420 7479 7069 6361 6c6c  s don't typicall
+00013b60: 7920 7375 7070 6f72 7420 6861 7669 6e67  y support having
+00013b70: 206d 756c 7469 706c 6520 7072 6f63 6573   multiple proces
+00013b80: 7365 7320 7772 6974 696e 670a 2020 2020  ses writing.    
+00013b90: 2320 7369 6d75 6c74 616e 6f75 736c 7920  # simultanously 
+00013ba0: 746f 2074 6865 6d2c 2073 6f20 7573 6520  to them, so use 
+00013bb0: 6c6f 636b 2066 696c 6520 746f 2073 796e  lock file to syn
+00013bc0: 6368 726f 6e69 7a65 2061 6363 6573 732e  chronize access.
+00013bd0: 0a20 2020 206c 6f63 6b66 696c 6520 3d20  .    lockfile = 
+00013be0: 5061 7468 2866 227b 7374 7228 6473 7429  Path(f"{str(dst)
+00013bf0: 7d2e 6c6f 636b 2229 0a0a 2020 2020 2320  }.lock")..    # 
+00013c00: 4966 2074 6865 2064 6573 7469 6e61 7469  If the destinati
+00013c10: 6f6e 2066 696c 6520 646f 6573 6e27 7420  on file doesn't 
+00013c20: 6578 6973 7420 7965 742c 2062 7574 2074  exist yet, but t
+00013c30: 6865 206c 6f63 6b66 696c 6520 646f 6573  he lockfile does
+00013c40: 2c0a 2020 2020 2320 7472 7920 7265 6d6f  ,.    # try remo
+00013c50: 7669 6e67 2074 6865 206c 6f63 6b66 696c  ving the lockfil
+00013c60: 6520 6173 2069 7420 6d69 6768 7420 6265  e as it might be
+00013c70: 2061 2067 686f 7374 206c 6f63 6b66 696c   a ghost lockfil
+00013c80: 652e 0a20 2020 2069 6620 6e6f 7420 6473  e..    if not ds
+00013c90: 742e 6578 6973 7473 2829 2061 6e64 206c  t.exists() and l
+00013ca0: 6f63 6b66 696c 652e 6578 6973 7473 2829  ockfile.exists()
+00013cb0: 3a0a 2020 2020 2020 2020 7472 793a 0a20  :.        try:. 
+00013cc0: 2020 2020 2020 2020 2020 206c 6f63 6b66             lockf
+00013cd0: 696c 652e 756e 6c69 6e6b 2829 0a20 2020  ile.unlink().   
+00013ce0: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
+00013cf0: 7074 696f 6e3a 0a20 2020 2020 2020 2020  ption:.         
+00013d00: 2020 205f 203d 204e 6f6e 650a 0a20 2020     _ = None..   
+00013d10: 2023 2043 7265 6174 696e 6720 6c6f 636b   # Creating lock
+00013d20: 6669 6c65 2061 6e64 2061 7070 656e 640a  file and append.
+00013d30: 2020 2020 7374 6172 745f 7469 6d65 203d      start_time =
+00013d40: 2064 6174 6574 696d 652e 6461 7465 7469   datetime.dateti
+00013d50: 6d65 2e6e 6f77 2829 0a20 2020 2072 6561  me.now().    rea
+00013d60: 6479 203d 2046 616c 7365 0a20 2020 2077  dy = False.    w
+00013d70: 6869 6c65 206e 6f74 2072 6561 6479 3a0a  hile not ready:.
+00013d80: 2020 2020 2020 2020 6966 205f 696f 5f75          if _io_u
+00013d90: 7469 6c2e 6372 6561 7465 5f66 696c 655f  til.create_file_
+00013da0: 6174 6f6d 6963 286c 6f63 6b66 696c 6529  atomic(lockfile)
+00013db0: 2069 7320 5472 7565 3a0a 2020 2020 2020   is True:.      
+00013dc0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+00013dd0: 2020 2020 2020 2020 2020 2023 2061 7070             # app
+00013de0: 656e 640a 2020 2020 2020 2020 2020 2020  end.            
+00013df0: 2020 2020 5f61 7070 656e 645f 746f 5f6e      _append_to_n
+00013e00: 6f6c 6f63 6b28 0a20 2020 2020 2020 2020  olock(.         
+00013e10: 2020 2020 2020 2020 2020 2073 7263 3d73             src=s
+00013e20: 7263 2c0a 2020 2020 2020 2020 2020 2020  rc,.            
+00013e30: 2020 2020 2020 2020 6473 743d 6473 742c          dst=dst,
+00013e40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013e50: 2020 2020 2073 7263 5f6c 6179 6572 3d73       src_layer=s
+00013e60: 7263 5f6c 6179 6572 2c0a 2020 2020 2020  rc_layer,.      
+00013e70: 2020 2020 2020 2020 2020 2020 2020 6473                ds
+00013e80: 745f 6c61 7965 723d 6473 745f 6c61 7965  t_layer=dst_laye
+00013e90: 722c 0a20 2020 2020 2020 2020 2020 2020  r,.             
+00013ea0: 2020 2020 2020 2073 7263 5f63 7273 3d73         src_crs=s
+00013eb0: 7263 5f63 7273 2c0a 2020 2020 2020 2020  rc_crs,.        
+00013ec0: 2020 2020 2020 2020 2020 2020 6473 745f              dst_
+00013ed0: 6372 733d 6473 745f 6372 732c 0a20 2020  crs=dst_crs,.   
+00013ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013ef0: 2063 6f6c 756d 6e73 3d63 6f6c 756d 6e73   columns=columns
+00013f00: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00013f10: 2020 2020 2020 7768 6572 653d 7768 6572        where=wher
+00013f20: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+00013f30: 2020 2020 2020 2073 716c 5f73 746d 743d         sql_stmt=
+00013f40: 7371 6c5f 7374 6d74 2c0a 2020 2020 2020  sql_stmt,.      
+00013f50: 2020 2020 2020 2020 2020 2020 2020 7371                sq
+00013f60: 6c5f 6469 616c 6563 743d 7371 6c5f 6469  l_dialect=sql_di
+00013f70: 616c 6563 742c 0a20 2020 2020 2020 2020  alect,.         
+00013f80: 2020 2020 2020 2020 2020 2072 6570 726f             repro
+00013f90: 6a65 6374 3d72 6570 726f 6a65 6374 2c0a  ject=reproject,.
+00013fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013fb0: 2020 2020 6578 706c 6f64 6563 6f6c 6c65      explodecolle
+00013fc0: 6374 696f 6e73 3d65 7870 6c6f 6465 636f  ctions=explodeco
+00013fd0: 6c6c 6563 7469 6f6e 732c 0a20 2020 2020  llections,.     
+00013fe0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00013ff0: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+00014000: 6574 7279 7479 7065 3d66 6f72 6365 5f6f  etrytype=force_o
+00014010: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
+00014020: 7065 2c0a 2020 2020 2020 2020 2020 2020  pe,.            
+00014030: 2020 2020 2020 2020 6372 6561 7465 5f73          create_s
+00014040: 7061 7469 616c 5f69 6e64 6578 3d63 7265  patial_index=cre
+00014050: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
+00014060: 782c 0a20 2020 2020 2020 2020 2020 2020  x,.             
+00014070: 2020 2020 2020 2074 7261 6e73 6163 7469         transacti
+00014080: 6f6e 5f73 697a 653d 7472 616e 7361 6374  on_size=transact
+00014090: 696f 6e5f 7369 7a65 2c0a 2020 2020 2020  ion_size,.      
+000140a0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+000140b0: 6573 6572 7665 5f66 6964 3d70 7265 7365  eserve_fid=prese
+000140c0: 7276 655f 6669 642c 0a20 2020 2020 2020  rve_fid,.       
+000140d0: 2020 2020 2020 2020 2020 2020 2064 7374               dst
+000140e0: 5f64 696d 656e 7369 6f6e 733d 6473 745f  _dimensions=dst_
+000140f0: 6469 6d65 6e73 696f 6e73 2c0a 2020 2020  dimensions,.    
+00014100: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014110: 6f70 7469 6f6e 733d 6f70 7469 6f6e 732c  options=options,
+00014120: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014130: 2029 0a20 2020 2020 2020 2020 2020 2066   ).            f
+00014140: 696e 616c 6c79 3a0a 2020 2020 2020 2020  inally:.        
+00014150: 2020 2020 2020 2020 7265 6164 7920 3d20          ready = 
+00014160: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+00014170: 2020 2020 206c 6f63 6b66 696c 652e 756e       lockfile.un
+00014180: 6c69 6e6b 2829 0a20 2020 2020 2020 2065  link().        e
+00014190: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000141a0: 2074 696d 655f 7761 6974 696e 6720 3d20   time_waiting = 
+000141b0: 2864 6174 6574 696d 652e 6461 7465 7469  (datetime.dateti
+000141c0: 6d65 2e6e 6f77 2829 202d 2073 7461 7274  me.now() - start
+000141d0: 5f74 696d 6529 2e74 6f74 616c 5f73 6563  _time).total_sec
+000141e0: 6f6e 6473 2829 0a20 2020 2020 2020 2020  onds().         
+000141f0: 2020 2069 6620 7469 6d65 5f77 6169 7469     if time_waiti
+00014200: 6e67 203e 2061 7070 656e 645f 7469 6d65  ng > append_time
+00014210: 6f75 745f 733a 0a20 2020 2020 2020 2020  out_s:.         
+00014220: 2020 2020 2020 2072 6169 7365 2052 756e         raise Run
+00014230: 7469 6d65 4572 726f 7228 0a20 2020 2020  timeError(.     
+00014240: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00014250: 2261 7070 656e 645f 746f 2074 696d 656f  "append_to timeo
+00014260: 7574 206f 6620 7b61 7070 656e 645f 7469  ut of {append_ti
+00014270: 6d65 6f75 745f 737d 2072 6561 6368 6564  meout_s} reached
+00014280: 2c20 736f 2073 746f 7020 7772 6974 6520  , so stop write 
+00014290: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+000142a0: 2020 2020 2020 6622 746f 207b 6473 747d        f"to {dst}
+000142b0: 2122 0a20 2020 2020 2020 2020 2020 2020  !".             
+000142c0: 2020 2029 0a0a 2020 2020 2020 2020 2320     )..        # 
+000142d0: 536c 6565 7020 666f 7220 6120 7365 636f  Sleep for a seco
+000142e0: 6e64 2062 6566 6f72 6520 7472 7969 6e67  nd before trying
+000142f0: 2061 6761 696e 0a20 2020 2020 2020 2074   again.        t
+00014300: 696d 652e 736c 6565 7028 3129 0a0a 0a64  ime.sleep(1)...d
+00014310: 6566 205f 6170 7065 6e64 5f74 6f5f 6e6f  ef _append_to_no
+00014320: 6c6f 636b 280a 2020 2020 7372 633a 2050  lock(.    src: P
+00014330: 6174 682c 0a20 2020 2064 7374 3a20 5061  ath,.    dst: Pa
+00014340: 7468 2c0a 2020 2020 7372 635f 6c61 7965  th,.    src_laye
+00014350: 723a 204f 7074 696f 6e61 6c5b 7374 725d  r: Optional[str]
+00014360: 203d 204e 6f6e 652c 0a20 2020 2064 7374   = None,.    dst
+00014370: 5f6c 6179 6572 3a20 4f70 7469 6f6e 616c  _layer: Optional
+00014380: 5b73 7472 5d20 3d20 4e6f 6e65 2c0a 2020  [str] = None,.  
+00014390: 2020 7372 635f 6372 733a 2055 6e69 6f6e    src_crs: Union
+000143a0: 5b69 6e74 2c20 7374 722c 204e 6f6e 655d  [int, str, None]
+000143b0: 203d 204e 6f6e 652c 0a20 2020 2064 7374   = None,.    dst
+000143c0: 5f63 7273 3a20 556e 696f 6e5b 696e 742c  _crs: Union[int,
+000143d0: 2073 7472 2c20 4e6f 6e65 5d20 3d20 4e6f   str, None] = No
+000143e0: 6e65 2c0a 2020 2020 636f 6c75 6d6e 733a  ne,.    columns:
+000143f0: 204f 7074 696f 6e61 6c5b 4974 6572 6162   Optional[Iterab
+00014400: 6c65 5b73 7472 5d5d 203d 204e 6f6e 652c  le[str]] = None,
+00014410: 0a20 2020 2077 6865 7265 3a20 4f70 7469  .    where: Opti
+00014420: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+00014430: 2c0a 2020 2020 7371 6c5f 7374 6d74 3a20  ,.    sql_stmt: 
+00014440: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
+00014450: 4e6f 6e65 2c0a 2020 2020 7371 6c5f 6469  None,.    sql_di
+00014460: 616c 6563 743a 204f 7074 696f 6e61 6c5b  alect: Optional[
+00014470: 4c69 7465 7261 6c5b 2253 514c 4954 4522  Literal["SQLITE"
+00014480: 2c20 224f 4752 5351 4c22 5d5d 203d 204e  , "OGRSQL"]] = N
+00014490: 6f6e 652c 0a20 2020 2072 6570 726f 6a65  one,.    reproje
+000144a0: 6374 3a20 626f 6f6c 203d 2046 616c 7365  ct: bool = False
+000144b0: 2c0a 2020 2020 6578 706c 6f64 6563 6f6c  ,.    explodecol
+000144c0: 6c65 6374 696f 6e73 3a20 626f 6f6c 203d  lections: bool =
+000144d0: 2046 616c 7365 2c0a 2020 2020 6372 6561   False,.    crea
+000144e0: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
+000144f0: 3a20 4f70 7469 6f6e 616c 5b62 6f6f 6c5d  : Optional[bool]
+00014500: 203d 2054 7275 652c 0a20 2020 2066 6f72   = True,.    for
+00014510: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
+00014520: 7279 7479 7065 3a20 556e 696f 6e5b 4765  rytype: Union[Ge
+00014530: 6f6d 6574 7279 5479 7065 2c20 7374 722c  ometryType, str,
+00014540: 204e 6f6e 655d 203d 204e 6f6e 652c 0a20   None] = None,. 
+00014550: 2020 2074 7261 6e73 6163 7469 6f6e 5f73     transaction_s
+00014560: 697a 653a 2069 6e74 203d 2035 3030 3030  ize: int = 50000
+00014570: 2c0a 2020 2020 7072 6573 6572 7665 5f66  ,.    preserve_f
+00014580: 6964 3a20 4f70 7469 6f6e 616c 5b62 6f6f  id: Optional[boo
+00014590: 6c5d 203d 204e 6f6e 652c 0a20 2020 2064  l] = None,.    d
+000145a0: 7374 5f64 696d 656e 7369 6f6e 733a 204f  st_dimensions: O
+000145b0: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
+000145c0: 6f6e 652c 0a20 2020 206f 7074 696f 6e73  one,.    options
+000145d0: 3a20 6469 6374 203d 207b 7d2c 0a29 3a0a  : dict = {},.):.
+000145e0: 2020 2020 2320 4368 6563 6b2f 636c 6561      # Check/clea
+000145f0: 6e20 696e 7075 7420 7061 7261 6d73 0a20  n input params. 
+00014600: 2020 206f 7074 696f 6e73 203d 205f 6f67     options = _og
+00014610: 725f 7574 696c 2e5f 7072 6570 6172 655f  r_util._prepare_
+00014620: 6764 616c 5f6f 7074 696f 6e73 286f 7074  gdal_options(opt
+00014630: 696f 6e73 290a 2020 2020 6966 2028 0a20  ions).    if (. 
+00014640: 2020 2020 2020 2063 7265 6174 655f 7370         create_sp
+00014650: 6174 6961 6c5f 696e 6465 7820 6973 206e  atial_index is n
+00014660: 6f74 204e 6f6e 650a 2020 2020 2020 2020  ot None.        
+00014670: 616e 6420 224c 4159 4552 5f43 5245 4154  and "LAYER_CREAT
+00014680: 494f 4e2e 5350 4154 4941 4c5f 494e 4445  ION.SPATIAL_INDE
+00014690: 5822 206e 6f74 2069 6e20 6f70 7469 6f6e  X" not in option
+000146a0: 730a 2020 2020 293a 0a20 2020 2020 2020  s.    ):.       
+000146b0: 206f 7074 696f 6e73 5b22 4c41 5945 525f   options["LAYER_
+000146c0: 4352 4541 5449 4f4e 2e53 5041 5449 414c  CREATION.SPATIAL
+000146d0: 5f49 4e44 4558 225d 203d 2063 7265 6174  _INDEX"] = creat
+000146e0: 655f 7370 6174 6961 6c5f 696e 6465 780a  e_spatial_index.
+000146f0: 0a20 2020 2073 7263 5f6c 6179 6572 203d  .    src_layer =
+00014700: 2073 7263 5f6c 6179 6572 2069 6620 7372   src_layer if sr
+00014710: 635f 6c61 7965 7220 6973 206e 6f74 204e  c_layer is not N
+00014720: 6f6e 6520 656c 7365 2067 6574 5f6f 6e6c  one else get_onl
+00014730: 795f 6c61 7965 7228 7372 6329 0a20 2020  y_layer(src).   
+00014740: 2073 7263 5f6c 6179 6572 696e 666f 203d   src_layerinfo =
+00014750: 204e 6f6e 650a 2020 2020 6966 2077 6865   None.    if whe
+00014760: 7265 2069 7320 6e6f 7420 4e6f 6e65 3a0a  re is not None:.
+00014770: 2020 2020 2020 2020 7372 635f 6c61 7965          src_laye
+00014780: 7269 6e66 6f20 3d20 6765 745f 6c61 7965  rinfo = get_laye
+00014790: 7269 6e66 6f28 7372 632c 2073 7263 5f6c  rinfo(src, src_l
+000147a0: 6179 6572 2c20 7261 6973 655f 6f6e 5f6e  ayer, raise_on_n
+000147b0: 6f67 656f 6d3d 4661 6c73 6529 0a20 2020  ogeom=False).   
+000147c0: 2020 2020 2077 6865 7265 203d 2077 6865       where = whe
+000147d0: 7265 2e66 6f72 6d61 7428 6765 6f6d 6574  re.format(geomet
+000147e0: 7279 636f 6c75 6d6e 3d73 7263 5f6c 6179  rycolumn=src_lay
+000147f0: 6572 696e 666f 2e67 656f 6d65 7472 7963  erinfo.geometryc
+00014800: 6f6c 756d 6e29 0a0a 2020 2020 6966 2073  olumn)..    if s
+00014810: 716c 5f73 746d 7420 6973 206e 6f74 204e  ql_stmt is not N
+00014820: 6f6e 653a 0a20 2020 2020 2020 2023 2046  one:.        # F
+00014830: 696c 6c20 6f75 7420 706c 6163 6568 6f6c  ill out placehol
+00014840: 6465 7273 2e0a 2020 2020 2020 2020 7371  ders..        sq
+00014850: 6c5f 7374 6d74 203d 205f 6669 6c6c 5f6f  l_stmt = _fill_o
+00014860: 7574 5f73 716c 5f70 6c61 6365 686f 6c64  ut_sql_placehold
+00014870: 6572 7328 0a20 2020 2020 2020 2020 2020  ers(.           
+00014880: 2070 6174 683d 7372 632c 206c 6179 6572   path=src, layer
+00014890: 3d73 7263 5f6c 6179 6572 2c20 7371 6c5f  =src_layer, sql_
+000148a0: 7374 6d74 3d73 716c 5f73 746d 742c 2063  stmt=sql_stmt, c
+000148b0: 6f6c 756d 6e73 3d63 6f6c 756d 6e73 0a20  olumns=columns. 
+000148c0: 2020 2020 2020 2029 0a0a 2020 2020 2320         )..    # 
+000148d0: 5768 656e 2063 7265 6174 696e 672f 6170  When creating/ap
+000148e0: 7065 6e64 696e 6720 746f 2061 2073 6861  pending to a sha
+000148f0: 7065 6669 6c65 2c20 736f 6d65 2065 7874  pefile, some ext
+00014900: 7261 2074 6869 6e67 7320 6e65 6564 2074  ra things need t
+00014910: 6f20 6265 2064 6f6e 652f 6368 6563 6b65  o be done/checke
+00014920: 642e 0a20 2020 2069 6620 7371 6c5f 7374  d..    if sql_st
+00014930: 6d74 2069 7320 4e6f 6e65 2061 6e64 2064  mt is None and d
+00014940: 7374 2e73 7566 6669 782e 6c6f 7765 7228  st.suffix.lower(
+00014950: 2920 3d3d 2022 2e73 6870 223a 0a20 2020  ) == ".shp":.   
+00014960: 2020 2020 2023 2049 6620 7468 6520 6465       # If the de
+00014970: 7374 696e 6174 696f 6e20 6669 6c65 2064  stination file d
+00014980: 6f65 736e 2774 2065 7869 7374 2079 6574  oesn't exist yet
+00014990: 2c20 616e 6420 7468 6520 736f 7572 6365  , and the source
+000149a0: 2066 696c 6520 6861 730a 2020 2020 2020   file has.      
+000149b0: 2020 2320 6765 6f6d 6574 7279 7479 7065    # geometrytype
+000149c0: 2022 4765 6f6d 6574 7279 222c 2072 6169   "Geometry", rai
+000149d0: 7365 2062 6563 6175 7365 2074 7970 6520  se because type 
+000149e0: 6973 206e 6f74 2073 7570 706f 7274 6564  is not supported
+000149f0: 2062 7920 7368 7020 2861 6e64 2077 696c   by shp (and wil
+00014a00: 6c0a 2020 2020 2020 2020 2320 6465 6661  l.        # defa
+00014a10: 756c 7420 746f 206c 696e 6573 7472 696e  ult to linestrin
+00014a20: 6729 2e0a 2020 2020 2020 2020 6966 2073  g)..        if s
+00014a30: 7263 5f6c 6179 6572 696e 666f 2069 7320  rc_layerinfo is 
+00014a40: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00014a50: 2020 7372 635f 6c61 7965 7269 6e66 6f20    src_layerinfo 
+00014a60: 3d20 6765 745f 6c61 7965 7269 6e66 6f28  = get_layerinfo(
+00014a70: 7372 632c 2073 7263 5f6c 6179 6572 2c20  src, src_layer, 
+00014a80: 7261 6973 655f 6f6e 5f6e 6f67 656f 6d3d  raise_on_nogeom=
+00014a90: 4661 6c73 6529 0a20 2020 2020 2020 2069  False).        i
+00014aa0: 6620 280a 2020 2020 2020 2020 2020 2020  f (.            
+00014ab0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
+00014ac0: 6d65 7472 7974 7970 6520 6973 204e 6f6e  metrytype is Non
+00014ad0: 650a 2020 2020 2020 2020 2020 2020 616e  e.            an
+00014ae0: 6420 7372 635f 6c61 7965 7269 6e66 6f2e  d src_layerinfo.
+00014af0: 6765 6f6d 6574 7279 7479 7065 0a20 2020  geometrytype.   
+00014b00: 2020 2020 2020 2020 2069 6e20 5b47 656f           in [Geo
+00014b10: 6d65 7472 7954 7970 652e 4745 4f4d 4554  metryType.GEOMET
+00014b20: 5259 2c20 4765 6f6d 6574 7279 5479 7065  RY, GeometryType
+00014b30: 2e47 454f 4d45 5452 5943 4f4c 4c45 4354  .GEOMETRYCOLLECT
+00014b40: 494f 4e5d 0a20 2020 2020 2020 2020 2020  ION].           
+00014b50: 2061 6e64 206e 6f74 2064 7374 2e65 7869   and not dst.exi
+00014b60: 7374 7328 290a 2020 2020 2020 2020 293a  sts().        ):
+00014b70: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00014b80: 7365 2056 616c 7565 4572 726f 7228 0a20  se ValueError(. 
+00014b90: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00014ba0: 2273 7263 2066 696c 6520 7b73 7263 7d20  "src file {src} 
+00014bb0: 6861 7320 6765 6f6d 6574 7279 7479 7065  has geometrytype
+00014bc0: 207b 7372 635f 6c61 7965 7269 6e66 6f2e   {src_layerinfo.
+00014bd0: 6765 6f6d 6574 7279 7479 7065 6e61 6d65  geometrytypename
+00014be0: 7d20 220a 2020 2020 2020 2020 2020 2020  } ".            
+00014bf0: 2020 2020 2277 6869 6368 2069 7320 6e6f      "which is no
+00014c00: 7420 7375 7070 6f72 7465 6420 696e 202e  t supported in .
+00014c10: 7368 702e 204d 6179 6265 2075 7365 2066  shp. Maybe use f
+00014c20: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+00014c30: 6574 7279 7479 7065 3f22 0a20 2020 2020  etrytype?".     
+00014c40: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+00014c50: 2020 2320 4c61 756e 6465 7220 7468 6520    # Launder the 
+00014c60: 636f 6c75 6d6e 7320 6e61 6d65 7320 7669  columns names vi
+00014c70: 6120 6120 5351 4c20 7374 6174 656d 656e  a a SQL statemen
+00014c80: 742c 206f 7468 6572 7769 7365 2077 6865  t, otherwise whe
+00014c90: 6e20 6170 7065 6e64 696e 6720 7468 650a  n appending the.
+00014ca0: 2020 2020 2020 2020 2320 6c61 756e 6465          # launde
+00014cb0: 7265 6420 636f 6c75 6d6e 7320 7769 6c6c  red columns will
+00014cc0: 2067 6574 204e 554c 4c20 7661 6c75 6573   get NULL values
+00014cd0: 2069 6e73 7465 6164 206f 6620 7468 6520   instead of the 
+00014ce0: 6461 7461 2e0a 2020 2020 2020 2020 6966  data..        if
+00014cf0: 2063 6f6c 756d 6e73 2069 7320 4e6f 6e65   columns is None
+00014d00: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
+00014d10: 6c75 6d6e 7320 3d20 7372 635f 6c61 7965  lumns = src_laye
+00014d20: 7269 6e66 6f2e 636f 6c75 6d6e 730a 2020  rinfo.columns.  
+00014d30: 2020 2020 2020 636f 6c75 6d6e 735f 6c61        columns_la
+00014d40: 756e 6465 7265 6420 3d20 5f6c 6175 6e64  undered = _laund
+00014d50: 6572 5f63 6f6c 756d 6e5f 6e61 6d65 7328  er_column_names(
+00014d60: 636f 6c75 6d6e 7329 0a20 2020 2020 2020  columns).       
+00014d70: 2063 6f6c 756d 6e73 5f61 6c69 6173 6564   columns_aliased
+00014d80: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
+00014d90: 2066 2722 7b63 6f6c 756d 6e7d 2220 4153   f'"{column}" AS
+00014da0: 2022 7b6c 6175 6e64 6572 6564 7d22 2720   "{laundered}"' 
+00014db0: 666f 7220 636f 6c75 6d6e 2c20 6c61 756e  for column, laun
+00014dc0: 6465 7265 6420 696e 2063 6f6c 756d 6e73  dered in columns
+00014dd0: 5f6c 6175 6e64 6572 6564 0a20 2020 2020  _laundered.     
+00014de0: 2020 205d 0a20 2020 2020 2020 2023 2049     ].        # I
+00014df0: 6620 7468 6572 6520 6973 2061 2077 6865  f there is a whe
+00014e00: 7265 2073 7065 6369 6669 6564 2c20 696e  re specified, in
+00014e10: 7465 6772 6174 6520 6974 2e2e 2e0a 2020  tegrate it....  
+00014e20: 2020 2020 2020 7768 6572 655f 636c 6175        where_clau
+00014e30: 7365 203d 2022 220a 2020 2020 2020 2020  se = "".        
+00014e40: 6966 2077 6865 7265 2069 7320 6e6f 7420  if where is not 
+00014e50: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00014e60: 2020 7768 6572 655f 636c 6175 7365 203d    where_clause =
+00014e70: 2066 2257 4845 5245 207b 7768 6572 657d   f"WHERE {where}
+00014e80: 220a 2020 2020 2020 2020 2020 2020 7768  ".            wh
+00014e90: 6572 6520 3d20 4e6f 6e65 0a20 2020 2020  ere = None.     
+00014ea0: 2020 2067 656f 6d65 7472 7963 6f6c 756d     geometrycolum
+00014eb0: 6e20 3d20 2222 0a20 2020 2020 2020 2069  n = "".        i
+00014ec0: 6620 7372 635f 6c61 7965 7269 6e66 6f2e  f src_layerinfo.
+00014ed0: 6765 6f6d 6574 7279 636f 6c75 6d6e 2069  geometrycolumn i
+00014ee0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00014ef0: 2020 2020 2020 2020 6765 6f6d 6574 7279          geometry
+00014f00: 636f 6c75 6d6e 203d 2066 227b 7372 635f  column = f"{src_
+00014f10: 6c61 7965 7269 6e66 6f2e 6765 6f6d 6574  layerinfo.geomet
+00014f20: 7279 636f 6c75 6d6e 7d2c 2022 0a20 2020  rycolumn}, ".   
+00014f30: 2020 2020 2073 716c 5f73 746d 7420 3d20       sql_stmt = 
+00014f40: 6622 2222 0a20 2020 2020 2020 2020 2020  f""".           
+00014f50: 2053 454c 4543 5420 7b67 656f 6d65 7472   SELECT {geometr
+00014f60: 7963 6f6c 756d 6e7d 7b22 2c20 222e 6a6f  ycolumn}{", ".jo
+00014f70: 696e 2863 6f6c 756d 6e73 5f61 6c69 6173  in(columns_alias
+00014f80: 6564 297d 0a20 2020 2020 2020 2020 2020  ed)}.           
+00014f90: 2020 2046 524f 4d20 227b 7372 635f 6c61     FROM "{src_la
+00014fa0: 7965 727d 220a 2020 2020 2020 2020 2020  yer}".          
+00014fb0: 2020 207b 7768 6572 655f 636c 6175 7365     {where_clause
+00014fc0: 7d0a 2020 2020 2020 2020 2222 220a 2020  }.        """.  
+00014fd0: 2020 2020 2020 7371 6c5f 6469 616c 6563        sql_dialec
+00014fe0: 7420 3d20 2253 514c 4954 4522 0a20 2020  t = "SQLITE".   
+00014ff0: 2020 2020 2063 6f6c 756d 6e73 203d 204e       columns = N
+00015000: 6f6e 650a 0a20 2020 2023 2057 6865 6e20  one..    # When 
+00015010: 6473 7420 6669 6c65 2064 6f65 736e 2774  dst file doesn't
+00015020: 2065 7869 7374 2061 6e64 2073 7263 2069   exist and src i
+00015030: 7320 656d 7074 7920 666f 7263 655f 6f75  s empty force_ou
+00015040: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+00015050: 6520 7368 6f75 6c64 2062 650a 2020 2020  e should be.    
+00015060: 2320 7370 6563 6966 6965 642c 206f 7468  # specified, oth
+00015070: 6572 7769 7365 2069 6e76 616c 6964 206f  erwise invalid o
+00015080: 7574 7075 742e 0a20 2020 2069 6620 666f  utput..    if fo
+00015090: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
+000150a0: 7472 7974 7970 6520 6973 204e 6f6e 6520  trytype is None 
+000150b0: 616e 6420 6e6f 7420 6473 742e 6578 6973  and not dst.exis
+000150c0: 7473 2829 3a0a 2020 2020 2020 2020 6966  ts():.        if
+000150d0: 2073 7263 5f6c 6179 6572 696e 666f 2069   src_layerinfo i
+000150e0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+000150f0: 2020 2020 7372 635f 6c61 7965 7269 6e66      src_layerinf
+00015100: 6f20 3d20 6765 745f 6c61 7965 7269 6e66  o = get_layerinf
+00015110: 6f28 7372 632c 2073 7263 5f6c 6179 6572  o(src, src_layer
+00015120: 2c20 7261 6973 655f 6f6e 5f6e 6f67 656f  , raise_on_nogeo
+00015130: 6d3d 4661 6c73 6529 0a20 2020 2020 2020  m=False).       
+00015140: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
+00015150: 6f6d 6574 7279 7479 7065 203d 2073 7263  ometrytype = src
+00015160: 5f6c 6179 6572 696e 666f 2e67 656f 6d65  _layerinfo.geome
+00015170: 7472 7974 7970 650a 0a20 2020 2023 2047  trytype..    # G
+00015180: 6f21 0a20 2020 2074 7261 6e73 6c61 7465  o!.    translate
+00015190: 5f69 6e66 6f20 3d20 5f6f 6772 5f75 7469  _info = _ogr_uti
+000151a0: 6c2e 5665 6374 6f72 5472 616e 736c 6174  l.VectorTranslat
+000151b0: 6549 6e66 6f28 0a20 2020 2020 2020 2069  eInfo(.        i
+000151c0: 6e70 7574 5f70 6174 683d 7372 632c 0a20  nput_path=src,. 
+000151d0: 2020 2020 2020 206f 7574 7075 745f 7061         output_pa
+000151e0: 7468 3d64 7374 2c0a 2020 2020 2020 2020  th=dst,.        
+000151f0: 696e 7075 745f 6c61 7965 7273 3d73 7263  input_layers=src
+00015200: 5f6c 6179 6572 2c0a 2020 2020 2020 2020  _layer,.        
+00015210: 6f75 7470 7574 5f6c 6179 6572 3d64 7374  output_layer=dst
+00015220: 5f6c 6179 6572 2c0a 2020 2020 2020 2020  _layer,.        
+00015230: 696e 7075 745f 7372 733d 7372 635f 6372  input_srs=src_cr
+00015240: 732c 0a20 2020 2020 2020 206f 7574 7075  s,.        outpu
+00015250: 745f 7372 733d 6473 745f 6372 732c 0a20  t_srs=dst_crs,. 
+00015260: 2020 2020 2020 2063 6f6c 756d 6e73 3d63         columns=c
+00015270: 6f6c 756d 6e73 2c0a 2020 2020 2020 2020  olumns,.        
+00015280: 7371 6c5f 7374 6d74 3d73 716c 5f73 746d  sql_stmt=sql_stm
+00015290: 742c 0a20 2020 2020 2020 2073 716c 5f64  t,.        sql_d
+000152a0: 6961 6c65 6374 3d73 716c 5f64 6961 6c65  ialect=sql_diale
+000152b0: 6374 2c0a 2020 2020 2020 2020 7768 6572  ct,.        wher
+000152c0: 653d 7768 6572 652c 0a20 2020 2020 2020  e=where,.       
+000152d0: 2072 6570 726f 6a65 6374 3d72 6570 726f   reproject=repro
+000152e0: 6a65 6374 2c0a 2020 2020 2020 2020 7472  ject,.        tr
+000152f0: 616e 7361 6374 696f 6e5f 7369 7a65 3d74  ansaction_size=t
+00015300: 7261 6e73 6163 7469 6f6e 5f73 697a 652c  ransaction_size,
+00015310: 0a20 2020 2020 2020 2061 7070 656e 643d  .        append=
+00015320: 5472 7565 2c0a 2020 2020 2020 2020 7570  True,.        up
+00015330: 6461 7465 3d54 7275 652c 0a20 2020 2020  date=True,.     
+00015340: 2020 2065 7870 6c6f 6465 636f 6c6c 6563     explodecollec
+00015350: 7469 6f6e 733d 6578 706c 6f64 6563 6f6c  tions=explodecol
+00015360: 6c65 6374 696f 6e73 2c0a 2020 2020 2020  lections,.      
+00015370: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
+00015380: 656f 6d65 7472 7974 7970 653d 666f 7263  eometrytype=forc
+00015390: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+000153a0: 7974 7970 652c 0a20 2020 2020 2020 206f  ytype,.        o
+000153b0: 7074 696f 6e73 3d6f 7074 696f 6e73 2c0a  ptions=options,.
+000153c0: 2020 2020 2020 2020 7072 6573 6572 7665          preserve
+000153d0: 5f66 6964 3d70 7265 7365 7276 655f 6669  _fid=preserve_fi
+000153e0: 642c 0a20 2020 2020 2020 2064 7374 5f64  d,.        dst_d
+000153f0: 696d 656e 7369 6f6e 733d 6473 745f 6469  imensions=dst_di
+00015400: 6d65 6e73 696f 6e73 2c0a 2020 2020 290a  mensions,.    ).
+00015410: 2020 2020 5f6f 6772 5f75 7469 6c2e 7665      _ogr_util.ve
+00015420: 6374 6f72 5f74 7261 6e73 6c61 7465 5f62  ctor_translate_b
+00015430: 795f 696e 666f 2869 6e66 6f3d 7472 616e  y_info(info=tran
+00015440: 736c 6174 655f 696e 666f 290a 0a0a 6465  slate_info)...de
+00015450: 6620 636f 6e76 6572 7428 0a20 2020 2073  f convert(.    s
+00015460: 7263 3a20 556e 696f 6e5b 7374 722c 2022  rc: Union[str, "
+00015470: 6f73 2e50 6174 684c 696b 655b 416e 795d  os.PathLike[Any]
+00015480: 225d 2c0a 2020 2020 6473 743a 2055 6e69  "],.    dst: Uni
+00015490: 6f6e 5b73 7472 2c20 226f 732e 5061 7468  on[str, "os.Path
+000154a0: 4c69 6b65 5b41 6e79 5d22 5d2c 0a20 2020  Like[Any]"],.   
+000154b0: 2073 7263 5f6c 6179 6572 3a20 4f70 7469   src_layer: Opti
+000154c0: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+000154d0: 2c0a 2020 2020 6473 745f 6c61 7965 723a  ,.    dst_layer:
+000154e0: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
+000154f0: 204e 6f6e 652c 0a20 2020 2073 7263 5f63   None,.    src_c
+00015500: 7273 3a20 556e 696f 6e5b 7374 722c 2069  rs: Union[str, i
+00015510: 6e74 2c20 4e6f 6e65 5d20 3d20 4e6f 6e65  nt, None] = None
+00015520: 2c0a 2020 2020 6473 745f 6372 733a 2055  ,.    dst_crs: U
+00015530: 6e69 6f6e 5b73 7472 2c20 696e 742c 204e  nion[str, int, N
+00015540: 6f6e 655d 203d 204e 6f6e 652c 0a20 2020  one] = None,.   
+00015550: 2077 6865 7265 3a20 4f70 7469 6f6e 616c   where: Optional
+00015560: 5b73 7472 5d20 3d20 4e6f 6e65 2c0a 2020  [str] = None,.  
+00015570: 2020 7265 7072 6f6a 6563 743a 2062 6f6f    reproject: boo
+00015580: 6c20 3d20 4661 6c73 652c 0a20 2020 2065  l = False,.    e
+00015590: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
+000155a0: 733a 2062 6f6f 6c20 3d20 4661 6c73 652c  s: bool = False,
+000155b0: 0a20 2020 2066 6f72 6365 5f6f 7574 7075  .    force_outpu
+000155c0: 745f 6765 6f6d 6574 7279 7479 7065 3a20  t_geometrytype: 
+000155d0: 556e 696f 6e5b 4765 6f6d 6574 7279 5479  Union[GeometryTy
+000155e0: 7065 2c20 7374 722c 204e 6f6e 655d 203d  pe, str, None] =
+000155f0: 204e 6f6e 652c 0a20 2020 2063 7265 6174   None,.    creat
+00015600: 655f 7370 6174 6961 6c5f 696e 6465 783a  e_spatial_index:
+00015610: 204f 7074 696f 6e61 6c5b 626f 6f6c 5d20   Optional[bool] 
+00015620: 3d20 5472 7565 2c0a 2020 2020 7072 6573  = True,.    pres
+00015630: 6572 7665 5f66 6964 3a20 4f70 7469 6f6e  erve_fid: Option
+00015640: 616c 5b62 6f6f 6c5d 203d 204e 6f6e 652c  al[bool] = None,
+00015650: 0a20 2020 206f 7074 696f 6e73 3a20 6469  .    options: di
+00015660: 6374 203d 207b 7d2c 0a20 2020 2061 7070  ct = {},.    app
+00015670: 656e 643a 2062 6f6f 6c20 3d20 4661 6c73  end: bool = Fals
+00015680: 652c 0a20 2020 2066 6f72 6365 3a20 626f  e,.    force: bo
+00015690: 6f6c 203d 2046 616c 7365 2c0a 293a 0a20  ol = False,.):. 
+000156a0: 2020 2022 2222 0a20 2020 2044 4550 5245     """.    DEPRE
+000156b0: 4341 5445 443a 2070 6c65 6173 6520 7573  CATED: please us
+000156c0: 6520 636f 7079 5f6c 6179 6572 2e0a 2020  e copy_layer..  
+000156d0: 2020 2222 220a 2020 2020 7761 726e 696e    """.    warnin
+000156e0: 6773 2e77 6172 6e28 2263 6f6e 7665 7274  gs.warn("convert
+000156f0: 2069 7320 6465 7072 6563 6174 6564 3a20   is deprecated: 
+00015700: 7573 6520 636f 7079 5f6c 6179 6572 2e22  use copy_layer."
+00015710: 2c20 4675 7475 7265 5761 726e 696e 672c  , FutureWarning,
+00015720: 2073 7461 636b 6c65 7665 6c3d 3229 0a20   stacklevel=2). 
+00015730: 2020 2072 6574 7572 6e20 636f 7079 5f6c     return copy_l
+00015740: 6179 6572 280a 2020 2020 2020 2020 7372  ayer(.        sr
+00015750: 633d 7372 632c 0a20 2020 2020 2020 2064  c=src,.        d
+00015760: 7374 3d64 7374 2c0a 2020 2020 2020 2020  st=dst,.        
+00015770: 7372 635f 6c61 7965 723d 7372 635f 6c61  src_layer=src_la
+00015780: 7965 722c 0a20 2020 2020 2020 2064 7374  yer,.        dst
+00015790: 5f6c 6179 6572 3d64 7374 5f6c 6179 6572  _layer=dst_layer
+000157a0: 2c0a 2020 2020 2020 2020 7372 635f 6372  ,.        src_cr
+000157b0: 733d 7372 635f 6372 732c 0a20 2020 2020  s=src_crs,.     
+000157c0: 2020 2064 7374 5f63 7273 3d64 7374 5f63     dst_crs=dst_c
+000157d0: 7273 2c0a 2020 2020 2020 2020 7768 6572  rs,.        wher
+000157e0: 653d 7768 6572 652c 0a20 2020 2020 2020  e=where,.       
+000157f0: 2072 6570 726f 6a65 6374 3d72 6570 726f   reproject=repro
+00015800: 6a65 6374 2c0a 2020 2020 2020 2020 6578  ject,.        ex
+00015810: 706c 6f64 6563 6f6c 6c65 6374 696f 6e73  plodecollections
+00015820: 3d65 7870 6c6f 6465 636f 6c6c 6563 7469  =explodecollecti
+00015830: 6f6e 732c 0a20 2020 2020 2020 2066 6f72  ons,.        for
+00015840: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
+00015850: 7279 7479 7065 3d66 6f72 6365 5f6f 7574  rytype=force_out
+00015860: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
+00015870: 2c0a 2020 2020 2020 2020 6372 6561 7465  ,.        create
+00015880: 5f73 7061 7469 616c 5f69 6e64 6578 3d63  _spatial_index=c
+00015890: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
+000158a0: 6465 782c 0a20 2020 2020 2020 2070 7265  dex,.        pre
+000158b0: 7365 7276 655f 6669 643d 7072 6573 6572  serve_fid=preser
+000158c0: 7665 5f66 6964 2c0a 2020 2020 2020 2020  ve_fid,.        
+000158d0: 6f70 7469 6f6e 733d 6f70 7469 6f6e 732c  options=options,
+000158e0: 0a20 2020 2020 2020 2061 7070 656e 643d  .        append=
+000158f0: 6170 7065 6e64 2c0a 2020 2020 2020 2020  append,.        
+00015900: 666f 7263 653d 666f 7263 652c 0a20 2020  force=force,.   
+00015910: 2029 0a0a 0a64 6566 2063 6f70 795f 6c61   )...def copy_la
+00015920: 7965 7228 0a20 2020 2073 7263 3a20 556e  yer(.    src: Un
+00015930: 696f 6e5b 7374 722c 2022 6f73 2e50 6174  ion[str, "os.Pat
+00015940: 684c 696b 655b 416e 795d 225d 2c0a 2020  hLike[Any]"],.  
+00015950: 2020 6473 743a 2055 6e69 6f6e 5b73 7472    dst: Union[str
+00015960: 2c20 226f 732e 5061 7468 4c69 6b65 5b41  , "os.PathLike[A
+00015970: 6e79 5d22 5d2c 0a20 2020 2073 7263 5f6c  ny]"],.    src_l
+00015980: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
+00015990: 7472 5d20 3d20 4e6f 6e65 2c0a 2020 2020  tr] = None,.    
+000159a0: 6473 745f 6c61 7965 723a 204f 7074 696f  dst_layer: Optio
+000159b0: 6e61 6c5b 7374 725d 203d 204e 6f6e 652c  nal[str] = None,
+000159c0: 0a20 2020 2073 7263 5f63 7273 3a20 556e  .    src_crs: Un
+000159d0: 696f 6e5b 7374 722c 2069 6e74 2c20 4e6f  ion[str, int, No
+000159e0: 6e65 5d20 3d20 4e6f 6e65 2c0a 2020 2020  ne] = None,.    
+000159f0: 6473 745f 6372 733a 2055 6e69 6f6e 5b73  dst_crs: Union[s
+00015a00: 7472 2c20 696e 742c 204e 6f6e 655d 203d  tr, int, None] =
+00015a10: 204e 6f6e 652c 0a20 2020 2063 6f6c 756d   None,.    colum
+00015a20: 6e73 3a20 4f70 7469 6f6e 616c 5b49 7465  ns: Optional[Ite
+00015a30: 7261 626c 655b 7374 725d 5d20 3d20 4e6f  rable[str]] = No
+00015a40: 6e65 2c0a 2020 2020 7768 6572 653a 204f  ne,.    where: O
+00015a50: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
+00015a60: 6f6e 652c 0a20 2020 2073 716c 5f73 746d  one,.    sql_stm
+00015a70: 743a 204f 7074 696f 6e61 6c5b 7374 725d  t: Optional[str]
+00015a80: 203d 204e 6f6e 652c 0a20 2020 2073 716c   = None,.    sql
+00015a90: 5f64 6961 6c65 6374 3a20 4f70 7469 6f6e  _dialect: Option
+00015aa0: 616c 5b4c 6974 6572 616c 5b22 5351 4c49  al[Literal["SQLI
+00015ab0: 5445 222c 2022 4f47 5253 514c 225d 5d20  TE", "OGRSQL"]] 
+00015ac0: 3d20 4e6f 6e65 2c0a 2020 2020 7265 7072  = None,.    repr
+00015ad0: 6f6a 6563 743a 2062 6f6f 6c20 3d20 4661  oject: bool = Fa
+00015ae0: 6c73 652c 0a20 2020 2065 7870 6c6f 6465  lse,.    explode
+00015af0: 636f 6c6c 6563 7469 6f6e 733a 2062 6f6f  collections: boo
+00015b00: 6c20 3d20 4661 6c73 652c 0a20 2020 2066  l = False,.    f
+00015b10: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+00015b20: 6574 7279 7479 7065 3a20 556e 696f 6e5b  etrytype: Union[
+00015b30: 4765 6f6d 6574 7279 5479 7065 2c20 7374  GeometryType, st
+00015b40: 722c 204e 6f6e 655d 203d 204e 6f6e 652c  r, None] = None,
+00015b50: 0a20 2020 2063 7265 6174 655f 7370 6174  .    create_spat
+00015b60: 6961 6c5f 696e 6465 783a 204f 7074 696f  ial_index: Optio
+00015b70: 6e61 6c5b 626f 6f6c 5d20 3d20 5472 7565  nal[bool] = True
+00015b80: 2c0a 2020 2020 7072 6573 6572 7665 5f66  ,.    preserve_f
+00015b90: 6964 3a20 4f70 7469 6f6e 616c 5b62 6f6f  id: Optional[boo
+00015ba0: 6c5d 203d 204e 6f6e 652c 0a20 2020 2064  l] = None,.    d
+00015bb0: 7374 5f64 696d 656e 7369 6f6e 733a 204f  st_dimensions: O
+00015bc0: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
+00015bd0: 6f6e 652c 0a20 2020 206f 7074 696f 6e73  one,.    options
+00015be0: 3a20 6469 6374 203d 207b 7d2c 0a20 2020  : dict = {},.   
+00015bf0: 2061 7070 656e 643a 2062 6f6f 6c20 3d20   append: bool = 
+00015c00: 4661 6c73 652c 0a20 2020 2066 6f72 6365  False,.    force
+00015c10: 3a20 626f 6f6c 203d 2046 616c 7365 2c0a  : bool = False,.
+00015c20: 293a 0a20 2020 2022 2222 0a20 2020 2052  ):.    """.    R
+00015c30: 6561 6420 6120 6c61 7965 7220 6672 6f6d  ead a layer from
+00015c40: 2061 2073 6f75 7263 6520 6669 6c65 2061   a source file a
+00015c50: 6e64 2077 7269 7465 2069 7420 746f 2061  nd write it to a
+00015c60: 206e 6577 2064 6573 7469 6e61 7469 6f6e   new destination
+00015c70: 2066 696c 652e 0a0a 2020 2020 5479 7069   file...    Typi
+00015c80: 6361 6c6c 7920 7573 6564 2074 6f20 636f  cally used to co
+00015c90: 6e76 6572 7420 6672 6f6d 206f 6e65 2066  nvert from one f
+00015ca0: 696c 6566 6f72 6d61 7420 746f 2061 6e6f  ileformat to ano
+00015cb0: 7468 6572 206f 7220 746f 2072 6570 726f  ther or to repro
+00015cc0: 6a65 6374 2e0a 0a20 2020 2054 6865 206f  ject...    The o
+00015cd0: 7074 696f 6e73 2070 6172 616d 6574 6572  ptions parameter
+00015ce0: 2063 616e 2062 6520 7573 6564 2074 6f20   can be used to 
+00015cf0: 7061 7373 2061 6e79 2074 7970 6520 6f66  pass any type of
+00015d00: 206f 7074 696f 6e73 2074 6f20 4744 414c   options to GDAL
+00015d10: 2069 6e0a 2020 2020 7468 6520 666f 6c6c   in.    the foll
+00015d20: 6f77 696e 6720 666f 726d 3a0a 2020 2020  owing form:.    
+00015d30: 2020 2020 7b20 223c 6f70 7469 6f6e 5f74      { "<option_t
+00015d40: 7970 653e 2e3c 6f70 7469 6f6e 5f6e 616d  ype>.<option_nam
+00015d50: 653e 223a 203c 6f70 7469 6f6e 5f76 616c  e>": <option_val
+00015d60: 7565 3e20 7d0a 0a20 2020 2054 6865 206f  ue> }..    The o
+00015d70: 7074 696f 6e20 7479 7065 7320 6361 6e20  ption types can 
+00015d80: 6265 2061 6e79 206f 6620 7468 6520 666f  be any of the fo
+00015d90: 6c6c 6f77 696e 673a 0a20 2020 2020 2020  llowing:.       
+00015da0: 202d 204c 4159 4552 5f43 5245 4154 494f   - LAYER_CREATIO
+00015db0: 4e3a 206c 6179 6572 2063 7265 6174 696f  N: layer creatio
+00015dc0: 6e20 6f70 7469 6f6e 2028 6c63 6f29 0a20  n option (lco). 
+00015dd0: 2020 2020 2020 202d 2044 4154 4153 4554         - DATASET
+00015de0: 5f43 5245 4154 494f 4e3a 2064 6174 6173  _CREATION: datas
+00015df0: 6574 2063 7265 6174 696f 6e20 6f70 7469  et creation opti
+00015e00: 6f6e 2028 6473 636f 290a 2020 2020 2020  on (dsco).      
+00015e10: 2020 2d20 494e 5055 545f 4f50 454e 3a20    - INPUT_OPEN: 
+00015e20: 696e 7075 7420 6461 7461 7365 7420 6f70  input dataset op
+00015e30: 656e 206f 7074 696f 6e20 286f 6f29 0a20  en option (oo). 
+00015e40: 2020 2020 2020 202d 2044 4553 5449 4e41         - DESTINA
+00015e50: 5449 4f4e 5f4f 5045 4e3a 2064 6573 7469  TION_OPEN: desti
+00015e60: 6e61 7469 6f6e 2064 6174 6173 6574 206f  nation dataset o
+00015e70: 7065 6e20 6f70 7469 6f6e 2028 646f 6f29  pen option (doo)
+00015e80: 0a20 2020 2020 2020 202d 2043 4f4e 4649  .        - CONFI
+00015e90: 473a 2063 6f6e 6669 6720 6f70 7469 6f6e  G: config option
+00015ea0: 2028 636f 6e66 6967 290a 0a20 2020 2054   (config)..    T
+00015eb0: 6865 206f 7074 696f 6e73 2063 616e 2062  he options can b
+00015ec0: 6520 666f 756e 6420 696e 2074 6865 207c  e found in the |
+00015ed0: 4744 414c 5f76 6563 746f 725f 6472 6976  GDAL_vector_driv
+00015ee0: 6572 5f64 6f63 756d 656e 7461 7469 6f6e  er_documentation
+00015ef0: 7c2e 0a0a 2020 2020 4172 6773 3a0a 2020  |...    Args:.  
+00015f00: 2020 2020 2020 7372 6320 2850 6174 684c        src (PathL
+00015f10: 696b 6529 3a20 5468 6520 736f 7572 6365  ike): The source
+00015f20: 2066 696c 6520 7061 7468 2e0a 2020 2020   file path..    
+00015f30: 2020 2020 6473 7420 2850 6174 684c 696b      dst (PathLik
+00015f40: 6529 3a20 5468 6520 6465 7374 696e 6174  e): The destinat
+00015f50: 696f 6e20 6669 6c65 2070 6174 682e 0a20  ion file path.. 
+00015f60: 2020 2020 2020 2073 7263 5f6c 6179 6572         src_layer
+00015f70: 2028 7374 722c 206f 7074 696f 6e61 6c29   (str, optional)
+00015f80: 3a20 5468 6520 736f 7572 6365 206c 6179  : The source lay
+00015f90: 6572 2e20 4966 204e 6f6e 6520 616e 6420  er. If None and 
+00015fa0: 7468 6572 6520 6973 206f 6e6c 790a 2020  there is only.  
+00015fb0: 2020 2020 2020 2020 2020 6f6e 6520 6c61            one la
+00015fc0: 7965 7220 696e 2074 6865 2073 7263 2066  yer in the src f
+00015fd0: 696c 652c 2074 6861 7420 6c61 7965 7220  ile, that layer 
+00015fe0: 6973 2074 616b 656e 2e20 4465 6661 756c  is taken. Defaul
+00015ff0: 7473 2074 6f20 4e6f 6e65 2e0a 2020 2020  ts to None..    
+00016000: 2020 2020 6473 745f 6c61 7965 7220 2873      dst_layer (s
+00016010: 7472 2c20 6f70 7469 6f6e 616c 293a 2054  tr, optional): T
+00016020: 6865 2064 6573 7469 6e61 7469 6f6e 206c  he destination l
+00016030: 6179 6572 2e20 4966 204e 6f6e 652c 2074  ayer. If None, t
+00016040: 6865 2066 696c 650a 2020 2020 2020 2020  he file.        
+00016050: 2020 2020 7374 656d 2069 7320 7461 6b65      stem is take
+00016060: 6e20 6173 206c 6179 6572 206e 616d 652e  n as layer name.
+00016070: 2044 6566 6175 6c74 7320 746f 204e 6f6e   Defaults to Non
+00016080: 652e 0a20 2020 2020 2020 2073 7263 5f63  e..        src_c
+00016090: 7273 2028 556e 696f 6e5b 7374 722c 2069  rs (Union[str, i
+000160a0: 6e74 5d2c 206f 7074 696f 6e61 6c29 3a20  nt], optional): 
+000160b0: 616e 2065 7073 6720 696e 7420 6f72 2061  an epsg int or a
+000160c0: 6e79 7468 696e 6720 7375 7070 6f72 7465  nything supporte
+000160d0: 640a 2020 2020 2020 2020 2020 2020 6279  d.            by
+000160e0: 2074 6865 204f 4752 5370 6174 6961 6c52   the OGRSpatialR
+000160f0: 6566 6572 656e 6365 2e53 6574 4672 6f6d  eference.SetFrom
+00016100: 5573 6572 496e 7075 7428 2920 6361 6c6c  UserInput() call
+00016110: 2c20 7768 6963 6820 696e 636c 7564 6573  , which includes
+00016120: 0a20 2020 2020 2020 2020 2020 2061 6e20  .            an 
+00016130: 4550 5347 2073 7472 696e 6720 2865 672e  EPSG string (eg.
+00016140: 2022 4550 5347 3a34 3332 3622 292c 2061   "EPSG:4326"), a
+00016150: 2077 656c 6c20 6b6e 6f77 6e20 7465 7874   well known text
+00016160: 2028 574b 5429 2043 5253 0a20 2020 2020   (WKT) CRS.     
+00016170: 2020 2020 2020 2064 6566 696e 6974 696f         definitio
+00016180: 6e2c 2e2e 2e20 4465 6661 756c 7473 2074  n,... Defaults t
+00016190: 6f20 4e6f 6e65 2e0a 2020 2020 2020 2020  o None..        
+000161a0: 6473 745f 6372 7320 2855 6e69 6f6e 5b73  dst_crs (Union[s
+000161b0: 7472 2c20 696e 745d 2c20 6f70 7469 6f6e  tr, int], option
+000161c0: 616c 293a 2061 6e20 6570 7367 2069 6e74  al): an epsg int
+000161d0: 206f 7220 616e 7974 6869 6e67 2073 7570   or anything sup
+000161e0: 706f 7274 6564 0a20 2020 2020 2020 2020  ported.         
+000161f0: 2020 2062 7920 7468 6520 4f47 5253 7061     by the OGRSpa
+00016200: 7469 616c 5265 6665 7265 6e63 652e 5365  tialReference.Se
+00016210: 7446 726f 6d55 7365 7249 6e70 7574 2829  tFromUserInput()
+00016220: 2063 616c 6c2c 2077 6869 6368 2069 6e63   call, which inc
+00016230: 6c75 6465 730a 2020 2020 2020 2020 2020  ludes.          
+00016240: 2020 616e 2045 5053 4720 7374 7269 6e67    an EPSG string
+00016250: 2028 6567 2e20 2245 5053 473a 3433 3236   (eg. "EPSG:4326
+00016260: 2229 2c20 6120 7765 6c6c 206b 6e6f 776e  "), a well known
+00016270: 2074 6578 7420 2857 4b54 2920 4352 530a   text (WKT) CRS.
+00016280: 2020 2020 2020 2020 2020 2020 6465 6669              defi
+00016290: 6e69 7469 6f6e 2c2e 2e2e 2044 6566 6175  nition,... Defau
+000162a0: 6c74 7320 746f 204e 6f6e 652e 0a20 2020  lts to None..   
+000162b0: 2020 2020 2063 6f6c 756d 6e73 2028 4974       columns (It
+000162c0: 6572 6162 6c65 5b73 7472 5d2c 206f 7074  erable[str], opt
+000162d0: 696f 6e61 6c29 3a20 5468 6520 286e 6f6e  ional): The (non
+000162e0: 2d67 656f 6d65 7472 7929 2063 6f6c 756d  -geometry) colum
+000162f0: 6e73 2074 6f20 7265 6164 2077 696c 6c0a  ns to read will.
+00016300: 2020 2020 2020 2020 2020 2020 6265 2072              be r
+00016310: 6574 7572 6e65 6420 696e 2074 6865 206f  eturned in the o
+00016320: 7264 6572 2073 7065 6369 6669 6564 2e20  rder specified. 
+00016330: 4966 204e 6f6e 652c 2061 6c6c 2073 7461  If None, all sta
+00016340: 6e64 6172 6420 636f 6c75 6d6e 7320 6172  ndard columns ar
+00016350: 6520 7265 6164 2e0a 2020 2020 2020 2020  e read..        
+00016360: 2020 2020 496e 2061 6464 6974 696f 6e20      In addition 
+00016370: 746f 2073 7461 6e64 6172 6420 636f 6c75  to standard colu
+00016380: 6d6e 732c 2069 7420 6973 2061 6c73 6f20  mns, it is also 
+00016390: 706f 7373 6962 6c65 0a20 2020 2020 2020  possible.       
+000163a0: 2020 2020 2074 6f20 7370 6563 6966 7920       to specify 
+000163b0: 2266 6964 222c 2061 2075 6e69 7175 6520  "fid", a unique 
+000163c0: 696e 6465 7820 6176 6169 6c61 626c 6520  index available 
+000163d0: 696e 2061 6c6c 2069 6e70 7574 2066 696c  in all input fil
+000163e0: 6573 2e20 4e6f 7465 2074 6861 7420 7468  es. Note that th
+000163f0: 650a 2020 2020 2020 2020 2020 2020 2266  e.            "f
+00016400: 6964 2220 7769 6c6c 2062 6520 616c 6961  id" will be alia
+00016410: 7365 6420 6567 2e20 746f 2022 6669 645f  sed eg. to "fid_
+00016420: 3122 2e20 4465 6661 756c 7473 2074 6f20  1". Defaults to 
+00016430: 4e6f 6e65 2e0a 2020 2020 2020 2020 7768  None..        wh
+00016440: 6572 6520 2873 7472 2c20 6f70 7469 6f6e  ere (str, option
+00016450: 616c 293a 206f 6e6c 7920 6170 7065 6e64  al): only append
+00016460: 2074 6865 2072 6f77 7320 6672 6f6d 2073   the rows from s
+00016470: 7263 2074 6861 7420 636f 6d70 6c79 2074  rc that comply t
+00016480: 6f20 7468 6520 6669 6c74 6572 0a20 2020  o the filter.   
+00016490: 2020 2020 2020 2020 2073 7065 6369 6669           specifi
+000164a0: 6564 2e20 4170 706c 6965 6420 6265 666f  ed. Applied befo
+000164b0: 7265 2060 6065 7870 6c6f 6465 636f 6c6c  re ``explodecoll
+000164c0: 6563 7469 6f6e 7360 602e 2046 696c 7465  ections``. Filte
+000164d0: 7220 7368 6f75 6c64 2062 6520 696e 2073  r should be in s
+000164e0: 716c 6974 650a 2020 2020 2020 2020 2020  qlite.          
+000164f0: 2020 5351 4c20 5748 4552 4520 7379 6e74    SQL WHERE synt
+00016500: 6178 2061 6e64 207c 7370 6174 6961 6c69  ax and |spatiali
+00016510: 7465 5f72 6566 6572 656e 6365 5f6c 696e  te_reference_lin
+00016520: 6b7c 2066 756e 6374 696f 6e73 2063 616e  k| functions can
+00016530: 2062 6520 7573 6564 2e20 4966 0a20 2020   be used. If.   
+00016540: 2020 2020 2020 2020 2077 6865 7265 2063           where c
+00016550: 6f6e 7461 696e 7320 7468 6520 7b67 656f  ontains the {geo
+00016560: 6d65 7472 7963 6f6c 756d 6e7d 2070 6c61  metrycolumn} pla
+00016570: 6365 686f 6c64 6572 2c20 6974 2069 7320  ceholder, it is 
+00016580: 6669 6c6c 6564 206f 7574 2077 6974 6820  filled out with 
+00016590: 7468 650a 2020 2020 2020 2020 2020 2020  the.            
+000165a0: 6765 6f6d 6574 7279 2063 6f6c 756d 6e20  geometry column 
+000165b0: 6e61 6d65 206f 6620 7468 6520 7372 6320  name of the src 
+000165c0: 6669 6c65 2e20 4465 6661 756c 7473 2074  file. Defaults t
+000165d0: 6f20 4e6f 6e65 2e0a 2020 2020 2020 2020  o None..        
+000165e0: 7371 6c5f 7374 6d74 2028 7374 7229 3a20  sql_stmt (str): 
+000165f0: 5351 4c20 7374 6174 656d 656e 7420 746f  SQL statement to
+00016600: 2075 7365 2e20 4f6e 6c79 2073 7570 706f   use. Only suppo
+00016610: 7274 6564 2077 6974 6820 2270 796f 6772  rted with "pyogr
+00016620: 696f 2220 656e 6769 6e65 2e0a 2020 2020  io" engine..    
+00016630: 2020 2020 7371 6c5f 6469 616c 6563 7420      sql_dialect 
+00016640: 2873 7472 2c20 6f70 7469 6f6e 616c 293a  (str, optional):
+00016650: 2053 514c 2064 6961 6c65 6374 2075 7365   SQL dialect use
+00016660: 642e 204f 7074 696f 6e73 2061 7265 204e  d. Options are N
+00016670: 6f6e 652c 2022 5351 4c49 5445 2220 6f72  one, "SQLITE" or
+00016680: 0a20 2020 2020 2020 2020 2020 2022 4f47  .            "OG
+00016690: 5253 514c 222e 2049 6620 4e6f 6e65 2c20  RSQL". If None, 
+000166a0: 666f 7220 6461 7461 2073 6f75 7263 6573  for data sources
+000166b0: 2077 6974 6820 6578 706c 6963 6974 2053   with explicit S
+000166c0: 514c 2073 7570 706f 7274 2074 6865 2073  QL support the s
+000166d0: 7461 7465 6d65 6e74 0a20 2020 2020 2020  tatement.       
+000166e0: 2020 2020 2069 7320 7072 6f63 6573 7365       is processe
+000166f0: 6420 6279 2074 6865 2064 6566 6175 6c74  d by the default
+00016700: 2053 514c 2065 6e67 696e 6520 2865 2e67   SQL engine (e.g
+00016710: 2e20 666f 7220 4765 6f70 6163 6b61 6765  . for Geopackage
+00016720: 2061 6e64 2053 7061 7469 616c 6974 650a   and Spatialite.
+00016730: 2020 2020 2020 2020 2020 2020 7468 6973              this
+00016740: 2069 7320 2253 514c 4954 4522 292e 2046   is "SQLITE"). F
+00016750: 6f72 2064 6174 6120 736f 7572 6365 7320  or data sources 
+00016760: 7769 7468 6f75 7420 6e61 7469 7665 2053  without native S
+00016770: 514c 2073 7570 706f 7274 2028 652e 672e  QL support (e.g.
+00016780: 202e 7368 7029 2c0a 2020 2020 2020 2020   .shp),.        
+00016790: 2020 2020 7468 6520 224f 4752 5351 4c22      the "OGRSQL"
+000167a0: 2064 6961 6c65 6374 2069 7320 7468 6520   dialect is the 
+000167b0: 6465 6661 756c 742e 2049 6620 7468 6520  default. If the 
+000167c0: 2253 514c 4954 4522 2064 6961 6c65 6374  "SQLITE" dialect
+000167d0: 2069 7320 7370 6563 6966 6965 642c 0a20   is specified,. 
+000167e0: 2020 2020 2020 2020 2020 207c 7370 6174             |spat
+000167f0: 6961 6c69 7465 5f72 6566 6572 656e 6365  ialite_reference
+00016800: 5f6c 696e 6b7c 2066 756e 6374 696f 6e73  _link| functions
+00016810: 2063 616e 2061 6c73 6f20 6265 2075 7365   can also be use
+00016820: 642e 2044 6566 6175 6c74 7320 746f 204e  d. Defaults to N
+00016830: 6f6e 652e 0a20 2020 2020 2020 2072 6570  one..        rep
+00016840: 726f 6a65 6374 2028 626f 6f6c 2c20 6f70  roject (bool, op
+00016850: 7469 6f6e 616c 293a 2054 7275 6520 746f  tional): True to
+00016860: 2072 6570 726f 6a65 6374 2077 6869 6c65   reproject while
+00016870: 2063 6f6e 7665 7274 696e 6720 7468 650a   converting the.
+00016880: 2020 2020 2020 2020 2020 2020 6669 6c65              file
+00016890: 2e20 4465 6661 756c 7473 2074 6f20 4661  . Defaults to Fa
+000168a0: 6c73 652e 0a20 2020 2020 2020 2065 7870  lse..        exp
+000168b0: 6c6f 6465 636f 6c6c 6563 7469 6f6e 7320  lodecollections 
+000168c0: 2862 6f6f 6c2c 206f 7074 696f 6e61 6c29  (bool, optional)
+000168d0: 3a20 5472 7565 2074 6f20 6f75 7470 7574  : True to output
+000168e0: 206f 6e6c 7920 7369 6d70 6c65 0a20 2020   only simple.   
+000168f0: 2020 2020 2020 2020 2067 656f 6d65 7472           geometr
+00016900: 6965 732e 2044 6566 6175 6c74 7320 746f  ies. Defaults to
+00016910: 2046 616c 7365 2e0a 2020 2020 2020 2020   False..        
+00016920: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
+00016930: 6d65 7472 7974 7970 6520 2855 6e69 6f6e  metrytype (Union
+00016940: 5b47 656f 6d65 7472 7954 7970 652c 2073  [GeometryType, s
+00016950: 7472 5d2c 206f 7074 696f 6e61 6c29 3a20  tr], optional): 
+00016960: 4765 6f6d 6574 7279 2074 7970 652e 0a20  Geometry type.. 
+00016970: 2020 2020 2020 2020 2020 2074 6f20 2874             to (t
+00016980: 7279 2074 6f29 2066 6f72 6365 2074 6865  ry to) force the
+00016990: 206f 7574 7075 7420 746f 2e20 4465 6661   output to. Defa
+000169a0: 756c 7473 2074 6f20 4e6f 6e65 2e0a 2020  ults to None..  
+000169b0: 2020 2020 2020 6372 6561 7465 5f73 7061        create_spa
+000169c0: 7469 616c 5f69 6e64 6578 2028 626f 6f6c  tial_index (bool
+000169d0: 2c20 6f70 7469 6f6e 616c 293a 2054 7275  , optional): Tru
+000169e0: 6520 746f 2063 7265 6174 6520 6120 7370  e to create a sp
+000169f0: 6174 6961 6c20 696e 6465 780a 2020 2020  atial index.    
+00016a00: 2020 2020 2020 2020 6f6e 2074 6865 2064          on the d
+00016a10: 6573 7469 6e61 7469 6f6e 2066 696c 652f  estination file/
+00016a20: 6c61 7965 722e 2049 6620 4e6f 6e65 2c20  layer. If None, 
+00016a30: 7468 6520 6465 6661 756c 7420 6265 6861  the default beha
+00016a40: 7669 6f75 7220 6279 2067 6461 6c20 666f  viour by gdal fo
+00016a50: 720a 2020 2020 2020 2020 2020 2020 7468  r.            th
+00016a60: 6174 2066 696c 6520 7479 7065 2069 7320  at file type is 
+00016a70: 7265 7370 6563 7465 642e 2049 6620 7468  respected. If th
+00016a80: 6520 4c41 5945 525f 4352 4541 5449 4f4e  e LAYER_CREATION
+00016a90: 2e53 5041 5449 414c 5f49 4e44 4558 0a20  .SPATIAL_INDEX. 
+00016aa0: 2020 2020 2020 2020 2020 2070 6172 616d             param
+00016ab0: 6574 6572 2069 7320 7370 6563 6966 6965  eter is specifie
+00016ac0: 6420 696e 206f 7074 696f 6e73 2c20 6372  d in options, cr
+00016ad0: 6561 7465 5f73 7061 7469 616c 5f69 6e64  eate_spatial_ind
+00016ae0: 6578 2069 7320 6967 6e6f 7265 642e 0a20  ex is ignored.. 
+00016af0: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
+00016b00: 6c74 7320 746f 2054 7275 652e 0a20 2020  lts to True..   
+00016b10: 2020 2020 2070 7265 7365 7276 655f 6669       preserve_fi
+00016b20: 6420 2862 6f6f 6c2c 206f 7074 696f 6e61  d (bool, optiona
+00016b30: 6c29 3a20 5472 7565 2074 6f20 6d61 6b65  l): True to make
+00016b40: 2061 6e20 6578 7472 6120 6566 666f 7274   an extra effort
+00016b50: 2074 6f20 7072 6573 6572 7665 2066 6964   to preserve fid
+00016b60: 2773 206f 660a 2020 2020 2020 2020 2020  's of.          
+00016b70: 2020 7468 6520 736f 7572 6365 206c 6179    the source lay
+00016b80: 6572 2074 6f20 7468 6520 6465 7374 696e  er to the destin
+00016b90: 6174 696f 6e20 6c61 7965 722e 2046 616c  ation layer. Fal
+00016ba0: 7365 206e 6f74 2074 6f20 646f 2061 6e79  se not to do any
+00016bb0: 2065 6666 6f72 742e 204e 6f6e 650a 2020   effort. None.  
+00016bc0: 2020 2020 2020 2020 2020 746f 2075 7365            to use
+00016bd0: 2074 6865 2064 6566 6175 6c74 2062 6568   the default beh
+00016be0: 6176 696f 7572 206f 6620 6764 616c 2c20  aviour of gdal, 
+00016bf0: 7468 6174 2061 6c72 6561 6479 2070 7265  that already pre
+00016c00: 7365 7276 6573 2069 6e20 736f 6d65 2063  serves in some c
+00016c10: 6173 6573 2e0a 2020 2020 2020 2020 2020  ases..          
+00016c20: 2020 536f 6d65 2066 696c 6520 666f 726d    Some file form
+00016c30: 6174 7320 646f 6e27 7420 6578 706c 6963  ats don't explic
+00016c40: 6974 6c79 2073 746f 7265 2074 6865 2066  itly store the f
+00016c50: 6964 2028 652e 672e 2073 6861 7065 6669  id (e.g. shapefi
+00016c60: 6c65 292c 2073 6f20 7468 6579 0a20 2020  le), so they.   
+00016c70: 2020 2020 2020 2020 2077 696c 6c20 6e65           will ne
+00016c80: 7665 7220 6265 2061 626c 6520 746f 2070  ver be able to p
+00016c90: 7265 7365 7276 6520 6669 6473 2e20 4465  reserve fids. De
+00016ca0: 6661 756c 7473 2074 6f20 4e6f 6e65 2e0a  faults to None..
+00016cb0: 2020 2020 2020 2020 6473 745f 6469 6d65          dst_dime
+00016cc0: 6e73 696f 6e73 2028 7374 722c 206f 7074  nsions (str, opt
+00016cd0: 696f 6e61 6c29 3a20 466f 7263 6520 7468  ional): Force th
+00016ce0: 6520 6469 6d65 6e73 696f 6e73 206f 6620  e dimensions of 
+00016cf0: 7468 6520 6465 7374 696e 6174 696f 6e20  the destination 
+00016d00: 6c61 7965 7220 746f 0a20 2020 2020 2020  layer to.       
+00016d10: 2020 2020 2074 6865 2076 616c 7565 2073       the value s
+00016d20: 7065 6369 6669 6564 2e20 5661 6c69 6420  pecified. Valid 
+00016d30: 7661 6c75 6573 3a20 2258 5922 2c20 2258  values: "XY", "X
+00016d40: 595a 222c 2022 5859 4d22 206f 7220 2258  YZ", "XYM" or "X
+00016d50: 595a 4d22 2e0a 2020 2020 2020 2020 2020  YZM"..          
+00016d60: 2020 4465 6661 756c 7473 2074 6f20 4e6f    Defaults to No
+00016d70: 6e65 2e0a 2020 2020 2020 2020 6f70 7469  ne..        opti
+00016d80: 6f6e 7320 2864 6963 742c 206f 7074 696f  ons (dict, optio
+00016d90: 6e61 6c29 3a20 6f70 7469 6f6e 7320 746f  nal): options to
+00016da0: 2070 6173 7320 746f 2067 6461 6c2e 0a20   pass to gdal.. 
+00016db0: 2020 2020 2020 2061 7070 656e 6420 2862         append (b
+00016dc0: 6f6f 6c2c 206f 7074 696f 6e61 6c29 3a20  ool, optional): 
+00016dd0: 5472 7565 2074 6f20 6170 7065 6e64 2074  True to append t
+00016de0: 6f20 7468 6520 6f75 7470 7574 2066 696c  o the output fil
+00016df0: 6520 6966 2069 7420 6578 6973 7473 2e0a  e if it exists..
+00016e00: 2020 2020 2020 2020 2020 2020 4465 6661              Defa
+00016e10: 756c 7473 2074 6f20 4661 6c73 652e 0a20  ults to False.. 
+00016e20: 2020 2020 2020 2066 6f72 6365 2028 626f         force (bo
+00016e30: 6f6c 2c20 6f70 7469 6f6e 616c 293a 206f  ol, optional): o
+00016e40: 7665 7277 7269 7465 2065 7869 7374 696e  verwrite existin
+00016e50: 6720 6f75 7470 7574 2066 696c 6528 7329  g output file(s)
+00016e60: 0a20 2020 2020 2020 2020 2020 2044 6566  .            Def
+00016e70: 6175 6c74 7320 746f 2046 616c 7365 2e0a  aults to False..
+00016e80: 0a20 2020 202e 2e20 7c73 7061 7469 616c  .    .. |spatial
+00016e90: 6974 655f 7265 6665 7265 6e63 655f 6c69  ite_reference_li
+00016ea0: 6e6b 7c20 7261 773a 3a20 6874 6d6c 0a0a  nk| raw:: html..
+00016eb0: 2020 2020 2020 2020 3c61 2068 7265 663d          <a href=
+00016ec0: 2268 7474 7073 3a2f 2f77 7777 2e67 6169  "https://www.gai
+00016ed0: 612d 6769 732e 6974 2f67 6169 612d 7369  a-gis.it/gaia-si
+00016ee0: 6e73 2f73 7061 7469 616c 6974 652d 7371  ns/spatialite-sq
+00016ef0: 6c2d 6c61 7465 7374 2e68 746d 6c22 2074  l-latest.html" t
+00016f00: 6172 6765 743d 225f 626c 616e 6b22 3e73  arget="_blank">s
+00016f10: 7061 7469 616c 6974 6520 7265 6665 7265  patialite refere
+00016f20: 6e63 653c 2f61 3e0a 0a20 2020 202e 2e20  nce</a>..    .. 
+00016f30: 7c47 4441 4c5f 7665 6374 6f72 5f64 7269  |GDAL_vector_dri
+00016f40: 7665 725f 646f 6375 6d65 6e74 6174 696f  ver_documentatio
+00016f50: 6e7c 2072 6177 3a3a 2068 746d 6c0a 0a20  n| raw:: html.. 
+00016f60: 2020 2020 2020 203c 6120 6872 6566 3d22         <a href="
+00016f70: 6874 7470 733a 2f2f 6764 616c 2e6f 7267  https://gdal.org
+00016f80: 2f64 7269 7665 7273 2f76 6563 746f 722f  /drivers/vector/
+00016f90: 696e 6465 782e 6874 6d6c 2220 7461 7267  index.html" targ
+00016fa0: 6574 3d22 5f62 6c61 6e6b 223e 4744 414c  et="_blank">GDAL
+00016fb0: 2076 6563 746f 7220 6472 6976 6572 2064   vector driver d
+00016fc0: 6f63 756d 656e 7461 7469 6f6e 3c2f 613e  ocumentation</a>
+00016fd0: 0a0a 2020 2020 2222 2220 2023 206e 6f71  ..    """  # noq
+00016fe0: 613a 2045 3530 310a 2020 2020 2320 496e  a: E501.    # In
+00016ff0: 6974 0a20 2020 2073 7263 203d 2050 6174  it.    src = Pat
+00017000: 6828 7372 6329 0a20 2020 2064 7374 203d  h(src).    dst =
+00017010: 2050 6174 6828 6473 7429 0a0a 2020 2020   Path(dst)..    
+00017020: 2320 4966 2073 6f75 7263 6520 6669 6c65  # If source file
+00017030: 2064 6f65 736e 2774 2065 7869 7374 2c20   doesn't exist, 
+00017040: 7261 6973 6520 6572 726f 720a 2020 2020  raise error.    
+00017050: 6966 206e 6f74 2073 7263 2e65 7869 7374  if not src.exist
+00017060: 7328 293a 0a20 2020 2020 2020 2072 6169  s():.        rai
+00017070: 7365 2056 616c 7565 4572 726f 7228 6622  se ValueError(f"
+00017080: 7372 6320 6669 6c65 2064 6f65 736e 2774  src file doesn't
+00017090: 2065 7869 7374 3a20 7b73 7263 7d22 290a   exist: {src}").
+000170a0: 2020 2020 2320 4966 2064 6573 7420 6669      # If dest fi
+000170b0: 6c65 2065 7869 7374 7320 616c 7265 6164  le exists alread
+000170c0: 7920 616e 6420 6e6f 2061 7070 656e 640a  y and no append.
+000170d0: 2020 2020 6966 206e 6f74 2061 7070 656e      if not appen
+000170e0: 6420 616e 6420 6473 742e 6578 6973 7473  d and dst.exists
+000170f0: 2829 3a0a 2020 2020 2020 2020 6966 2066  ():.        if f
+00017100: 6f72 6365 2069 7320 5472 7565 3a0a 2020  orce is True:.  
+00017110: 2020 2020 2020 2020 2020 7265 6d6f 7665            remove
+00017120: 2864 7374 290a 2020 2020 2020 2020 656c  (dst).        el
+00017130: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00017140: 6c6f 6767 6572 2e69 6e66 6f28 6622 4f75  logger.info(f"Ou
+00017150: 7470 7574 2066 696c 6520 6578 6973 7473  tput file exists
+00017160: 2061 6c72 6561 6479 2c20 736f 2073 746f   already, so sto
+00017170: 703a 207b 6473 747d 2229 0a20 2020 2020  p: {dst}").     
+00017180: 2020 2020 2020 2072 6574 7572 6e0a 0a20         return.. 
+00017190: 2020 2023 2043 6f6e 7665 7274 0a20 2020     # Convert.   
+000171a0: 206c 6f67 6765 722e 696e 666f 2866 2243   logger.info(f"C
+000171b0: 6f70 7920 6c61 7965 7220 6672 6f6d 207b  opy layer from {
+000171c0: 7372 637d 2074 6f20 7b64 7374 7d22 290a  src} to {dst}").
+000171d0: 2020 2020 5f61 7070 656e 645f 746f 5f6e      _append_to_n
+000171e0: 6f6c 6f63 6b28 0a20 2020 2020 2020 2073  olock(.        s
+000171f0: 7263 2c0a 2020 2020 2020 2020 6473 742c  rc,.        dst,
+00017200: 0a20 2020 2020 2020 2073 7263 5f6c 6179  .        src_lay
+00017210: 6572 2c0a 2020 2020 2020 2020 6473 745f  er,.        dst_
+00017220: 6c61 7965 722c 0a20 2020 2020 2020 2073  layer,.        s
+00017230: 7263 5f63 7273 3d73 7263 5f63 7273 2c0a  rc_crs=src_crs,.
+00017240: 2020 2020 2020 2020 6473 745f 6372 733d          dst_crs=
+00017250: 6473 745f 6372 732c 0a20 2020 2020 2020  dst_crs,.       
+00017260: 2063 6f6c 756d 6e73 3d63 6f6c 756d 6e73   columns=columns
+00017270: 2c0a 2020 2020 2020 2020 7768 6572 653d  ,.        where=
+00017280: 7768 6572 652c 0a20 2020 2020 2020 2073  where,.        s
+00017290: 716c 5f73 746d 743d 7371 6c5f 7374 6d74  ql_stmt=sql_stmt
+000172a0: 2c0a 2020 2020 2020 2020 7371 6c5f 6469  ,.        sql_di
+000172b0: 616c 6563 743d 7371 6c5f 6469 616c 6563  alect=sql_dialec
+000172c0: 742c 0a20 2020 2020 2020 2072 6570 726f  t,.        repro
+000172d0: 6a65 6374 3d72 6570 726f 6a65 6374 2c0a  ject=reproject,.
+000172e0: 2020 2020 2020 2020 6578 706c 6f64 6563          explodec
+000172f0: 6f6c 6c65 6374 696f 6e73 3d65 7870 6c6f  ollections=explo
+00017300: 6465 636f 6c6c 6563 7469 6f6e 732c 0a20  decollections,. 
+00017310: 2020 2020 2020 2066 6f72 6365 5f6f 7574         force_out
+00017320: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
+00017330: 3d66 6f72 6365 5f6f 7574 7075 745f 6765  =force_output_ge
+00017340: 6f6d 6574 7279 7479 7065 2c0a 2020 2020  ometrytype,.    
+00017350: 2020 2020 6372 6561 7465 5f73 7061 7469      create_spati
+00017360: 616c 5f69 6e64 6578 3d63 7265 6174 655f  al_index=create_
+00017370: 7370 6174 6961 6c5f 696e 6465 782c 0a20  spatial_index,. 
+00017380: 2020 2020 2020 2070 7265 7365 7276 655f         preserve_
+00017390: 6669 643d 7072 6573 6572 7665 5f66 6964  fid=preserve_fid
+000173a0: 2c0a 2020 2020 2020 2020 6473 745f 6469  ,.        dst_di
+000173b0: 6d65 6e73 696f 6e73 3d64 7374 5f64 696d  mensions=dst_dim
+000173c0: 656e 7369 6f6e 732c 0a20 2020 2020 2020  ensions,.       
+000173d0: 206f 7074 696f 6e73 3d6f 7074 696f 6e73   options=options
+000173e0: 2c0a 2020 2020 290a 0a0a 6465 6620 5f6c  ,.    )...def _l
+000173f0: 6175 6e64 6572 5f63 6f6c 756d 6e5f 6e61  aunder_column_na
+00017400: 6d65 7328 636f 6c75 6d6e 733a 2049 7465  mes(columns: Ite
+00017410: 7261 626c 6529 202d 3e20 4c69 7374 5b54  rable) -> List[T
+00017420: 7570 6c65 5b73 7472 2c20 7374 725d 5d3a  uple[str, str]]:
+00017430: 0a20 2020 2022 2222 0a20 2020 204c 6175  .    """.    Lau
+00017440: 6e64 6572 7320 7468 6520 636f 6c75 6d6e  nders the column
+00017450: 206e 616d 6573 2070 6173 7365 6420 746f   names passed to
+00017460: 2063 6f6d 706c 7920 7769 7468 2073 6861   comply with sha
+00017470: 7065 6669 6c65 2072 6573 7472 6963 7469  pefile restricti
+00017480: 6f6e 732e 0a0a 2020 2020 5261 7469 6f6e  ons...    Ration
+00017490: 616c 653a 206e 6f72 6d61 6c6c 7920 6764  ale: normally gd
+000174a0: 616c 206c 6175 6e64 6572 7320 7468 656d  al launders them
+000174b0: 2069 6620 6e65 6564 6564 2c20 6275 7420   if needed, but 
+000174c0: 7768 656e 2079 6f75 2061 7070 656e 640a  when you append.
+000174d0: 2020 2020 6d75 6c74 6970 6c65 2066 696c      multiple fil
+000174e0: 6573 2074 6f20 6120 7368 6170 6566 696c  es to a shapefil
+000174f0: 6520 7769 7468 2063 6f6c 756d 6e73 2074  e with columns t
+00017500: 6861 7420 6e65 6564 2074 6f20 6265 206c  hat need to be l
+00017510: 6175 6e64 6572 6564 0a20 2020 2074 6865  aundered.    the
+00017520: 7920 6172 6520 6e6f 7420 6d61 7463 6865  y are not matche
+00017530: 6420 616e 6420 736f 2061 7265 2061 7070  d and so are app
+00017540: 656e 6465 6420 7769 7468 204e 554c 4c20  ended with NULL 
+00017550: 7661 6c75 6573 2066 6f72 2074 6865 7365  values for these
+00017560: 0a20 2020 2063 6f6c 756d 6e73 2e20 4e6f  .    columns. No
+00017570: 726d 616c 6c79 2074 6865 202d 7265 6c61  rmally the -rela
+00017580: 7865 6446 6965 6c64 4e61 6d65 4d61 7463  xedFieldNameMatc
+00017590: 6820 7061 7261 6d65 7465 7220 696e 206f  h parameter in o
+000175a0: 6772 326f 6772 0a20 2020 2073 686f 756c  gr2ogr.    shoul
+000175b0: 6420 6669 7820 7468 6973 2c20 6275 7420  d fix this, but 
+000175c0: 6974 2073 6565 6d73 2074 6861 7420 7468  it seems that th
+000175d0: 6973 2069 736e 2774 2073 7570 706f 7274  is isn't support
+000175e0: 6564 2066 6f72 2073 6861 7065 6669 6c65  ed for shapefile
+000175f0: 732e 0a0a 2020 2020 4c61 756e 6465 7269  s...    Launderi
+00017600: 6e67 2069 7320 6261 7365 6420 6f6e 2074  ng is based on t
+00017610: 6869 7320 7465 7874 2066 726f 6d20 7468  his text from th
+00017620: 6520 6764 616c 2073 6861 7065 6669 6c65  e gdal shapefile
+00017630: 2064 7269 7665 720a 2020 2020 646f 6375   driver.    docu
+00017640: 6d65 6e74 6174 696f 6e3a 0a0a 2020 2020  mentation:..    
+00017650: 5368 6170 6566 696c 6520 6665 6174 7572  Shapefile featur
+00017660: 6520 6174 7472 6962 7574 6573 2061 7265  e attributes are
+00017670: 2073 746f 7265 6420 696e 2061 6e20 6173   stored in an as
+00017680: 736f 6369 6174 6564 202e 6462 6620 6669  sociated .dbf fi
+00017690: 6c65 2c20 616e 640a 2020 2020 736f 2061  le, and.    so a
+000176a0: 7474 7269 6275 7465 7320 7375 6666 6572  ttributes suffer
+000176b0: 2061 206e 756d 6265 7220 6f66 206c 696d   a number of lim
+000176c0: 6974 6174 696f 6e73 3a0a 2020 2020 2d20  itations:.    - 
+000176d0: 2020 4174 7472 6962 7574 6520 6e61 6d65    Attribute name
+000176e0: 7320 6361 6e20 6f6e 6c79 2062 6520 7570  s can only be up
+000176f0: 2074 6f20 3130 2063 6861 7261 6374 6572   to 10 character
+00017700: 7320 6c6f 6e67 2e0a 2020 2020 2020 2020  s long..        
+00017710: 5468 6520 4f47 5220 5368 6170 6566 696c  The OGR Shapefil
+00017720: 6520 6472 6976 6572 2074 7269 6573 2074  e driver tries t
+00017730: 6f20 6765 6e65 7261 7465 2075 6e69 7175  o generate uniqu
+00017740: 6520 6669 656c 640a 2020 2020 2020 2020  e field.        
+00017750: 6e61 6d65 732e 2053 7563 6365 7373 6976  names. Successiv
+00017760: 6520 6475 706c 6963 6174 6520 6669 656c  e duplicate fiel
+00017770: 6420 6e61 6d65 732c 2069 6e63 6c75 6469  d names, includi
+00017780: 6e67 2074 686f 7365 2063 7265 6174 6564  ng those created
+00017790: 2062 790a 2020 2020 2020 2020 7472 756e   by.        trun
+000177a0: 6361 7469 6f6e 2074 6f20 3130 2063 6861  cation to 10 cha
+000177b0: 7261 6374 6572 732c 2077 696c 6c20 6265  racters, will be
+000177c0: 2074 7275 6e63 6174 6564 2074 6f20 3820   truncated to 8 
+000177d0: 6368 6172 6163 7465 7273 2061 6e64 0a20  characters and. 
+000177e0: 2020 2020 2020 2061 7070 656e 6465 6420         appended 
+000177f0: 7769 7468 2061 2073 6572 6961 6c20 6e75  with a serial nu
+00017800: 6d62 6572 2066 726f 6d20 3120 746f 2039  mber from 1 to 9
+00017810: 392e 0a0a 2020 2020 2020 2020 466f 7220  9...        For 
+00017820: 6578 616d 706c 653a 0a0a 2020 2020 2020  example:..      
+00017830: 2020 2d20 2061 20e2 8692 2061 2c20 6120    -  a ... a, a 
+00017840: e286 9220 615f 312c 2041 20e2 8692 2041  ... a_1, A ... A
+00017850: 5f32 3b0a 2020 2020 2020 2020 2d20 2061  _2;.        -  a
+00017860: 6263 6465 6667 6869 6a6b 20e2 8692 2061  bcdefghijk ... a
+00017870: 6263 6465 6667 6869 6a2c 2061 6263 6465  bcdefghij, abcde
+00017880: 6667 6869 6a6b 6c20 e286 9220 6162 6364  fghijkl ... abcd
+00017890: 6566 6768 5f31 0a0a 2020 2020 2d20 2020  efgh_1..    -   
+000178a0: 4f6e 6c79 2049 6e74 6567 6572 2c20 496e  Only Integer, In
+000178b0: 7465 6765 7236 342c 2052 6561 6c2c 2053  teger64, Real, S
+000178c0: 7472 696e 6720 616e 6420 4461 7465 2028  tring and Date (
+000178d0: 6e6f 7420 4461 7465 5469 6d65 2c20 6a75  not DateTime, ju
+000178e0: 7374 0a20 2020 2020 2020 2079 6561 722f  st.        year/
+000178f0: 6d6f 6e74 682f 6461 7929 2066 6965 6c64  month/day) field
+00017900: 2074 7970 6573 2061 7265 2073 7570 706f   types are suppo
+00017910: 7274 6564 2e20 5468 6520 7661 7269 6f75  rted. The variou
+00017920: 7320 6c69 7374 2c20 616e 640a 2020 2020  s list, and.    
+00017930: 2020 2020 6269 6e61 7279 2066 6965 6c64      binary field
+00017940: 2074 7970 6573 2063 616e 6e6f 7420 6265   types cannot be
+00017950: 2063 7265 6174 6564 2e0a 2020 2020 2d20   created..    - 
+00017960: 2020 5468 6520 6669 656c 6420 7769 6474    The field widt
+00017970: 6820 616e 6420 7072 6563 6973 696f 6e20  h and precision 
+00017980: 6172 6520 6469 7265 6374 6c79 2075 7365  are directly use
+00017990: 6420 746f 2065 7374 6162 6c69 7368 2073  d to establish s
+000179a0: 746f 7261 6765 0a20 2020 2020 2020 2073  torage.        s
+000179b0: 697a 6520 696e 2074 6865 202e 6462 6620  ize in the .dbf 
+000179c0: 6669 6c65 2e20 5468 6973 206d 6561 6e73  file. This means
+000179d0: 2074 6861 7420 7374 7269 6e67 7320 6c6f   that strings lo
+000179e0: 6e67 6572 2074 6861 6e20 7468 6520 6669  nger than the fi
+000179f0: 656c 640a 2020 2020 2020 2020 7769 6474  eld.        widt
+00017a00: 682c 206f 7220 6e75 6d62 6572 7320 7468  h, or numbers th
+00017a10: 6174 2064 6f6e 2774 2066 6974 2069 6e74  at don't fit int
+00017a20: 6f20 7468 6520 696e 6469 6361 7465 6420  o the indicated 
+00017a30: 6669 656c 6420 666f 726d 6174 2077 696c  field format wil
+00017a40: 6c0a 2020 2020 2020 2020 7375 6666 6572  l.        suffer
+00017a50: 2074 7275 6e63 6174 696f 6e2e 0a20 2020   truncation..   
+00017a60: 202d 2020 2049 6e74 6567 6572 2066 6965   -   Integer fie
+00017a70: 6c64 7320 7769 7468 6f75 7420 616e 2065  lds without an e
+00017a80: 7870 6c69 6369 7420 7769 6474 6820 6172  xplicit width ar
+00017a90: 6520 7472 6561 7465 6420 6173 2077 6964  e treated as wid
+00017aa0: 7468 2039 2c20 616e 640a 2020 2020 2020  th 9, and.      
+00017ab0: 2020 6578 7465 6e64 6564 2074 6f20 3130    extended to 10
+00017ac0: 206f 7220 3131 2069 6620 6e65 6564 6564   or 11 if needed
+00017ad0: 2e0a 2020 2020 2d20 2020 496e 7465 6765  ..    -   Intege
+00017ae0: 7236 3420 6669 656c 6473 2077 6974 686f  r64 fields witho
+00017af0: 7574 2061 6e20 6578 706c 6963 6974 2077  ut an explicit w
+00017b00: 6964 7468 2061 7265 2074 7265 6174 6564  idth are treated
+00017b10: 2061 7320 7769 6474 6820 3138 2c0a 2020   as width 18,.  
+00017b20: 2020 2020 2020 616e 6420 6578 7465 6e64        and extend
+00017b30: 6564 2074 6f20 3139 206f 7220 3230 2069  ed to 19 or 20 i
+00017b40: 6620 6e65 6564 6564 2e0a 2020 2020 2d20  f needed..    - 
+00017b50: 2020 5265 616c 2028 666c 6f61 7469 6e67    Real (floating
+00017b60: 2070 6f69 6e74 2920 6669 656c 6473 2077   point) fields w
+00017b70: 6974 686f 7574 2061 6e20 6578 706c 6963  ithout an explic
+00017b80: 6974 2077 6964 7468 2061 7265 2074 7265  it width are tre
+00017b90: 6174 6564 2061 730a 2020 2020 2020 2020  ated as.        
+00017ba0: 7769 6474 6820 3234 2077 6974 6820 3135  width 24 with 15
+00017bb0: 2064 6563 696d 616c 2070 6c61 6365 7320   decimal places 
+00017bc0: 6f66 2070 7265 6369 7369 6f6e 2e0a 2020  of precision..  
+00017bd0: 2020 2d20 2020 5374 7269 6e67 2066 6965    -   String fie
+00017be0: 6c64 7320 7769 7468 6f75 7420 616e 2061  lds without an a
+00017bf0: 7373 6967 6e65 6420 7769 6474 6820 6172  ssigned width ar
+00017c00: 6520 7472 6561 7465 6420 6173 2038 3020  e treated as 80 
+00017c10: 6368 6172 6163 7465 7273 2e0a 0a20 2020  characters...   
+00017c20: 2041 7267 733a 0a20 2020 2020 2020 2063   Args:.        c
+00017c30: 6f6c 756d 6e73 2028 4974 6572 6162 6c65  olumns (Iterable
+00017c40: 293a 2074 6865 2063 6f6c 756d 6e73 2074  ): the columns t
+00017c50: 6f20 6c61 756e 6465 722e 0a0a 2020 2020  o launder...    
+00017c60: 5265 7475 726e 733a 2061 204c 6973 7420  Returns: a List 
+00017c70: 6f66 2074 7570 706c 6573 2077 6974 6820  of tupples with 
+00017c80: 7468 6520 6f72 6967 696e 616c 2061 6e64  the original and
+00017c90: 206c 6175 6e64 6572 6564 2063 6f6c 756d   laundered colum
+00017ca0: 6e20 6e61 6d65 732e 0a20 2020 2022 2222  n names..    """
+00017cb0: 0a20 2020 206c 6175 6e64 6572 6564 203d  .    laundered =
+00017cc0: 205b 5d0a 2020 2020 6c61 756e 6465 7265   [].    laundere
+00017cd0: 645f 7570 7065 7220 3d20 5b5d 0a20 2020  d_upper = [].   
+00017ce0: 2066 6f72 2063 6f6c 756d 6e20 696e 2063   for column in c
+00017cf0: 6f6c 756d 6e73 3a0a 2020 2020 2020 2020  olumns:.        
+00017d00: 2320 446f 7562 6c65 7320 696e 2063 6173  # Doubles in cas
+00017d10: 696e 6720 6172 6565 206e 6f74 2061 6c6c  ing aree not all
+00017d20: 6f77 6564 2065 6974 6865 720a 2020 2020  owed either.    
+00017d30: 2020 2020 6966 206c 656e 2863 6f6c 756d      if len(colum
+00017d40: 6e29 203c 3d20 3130 3a0a 2020 2020 2020  n) <= 10:.      
+00017d50: 2020 2020 2020 6966 2063 6f6c 756d 6e2e        if column.
+00017d60: 7570 7065 7228 2920 6e6f 7420 696e 206c  upper() not in l
+00017d70: 6175 6e64 6572 6564 5f75 7070 6572 3a0a  aundered_upper:.
+00017d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017d90: 6c61 756e 6465 7265 645f 7570 7065 722e  laundered_upper.
+00017da0: 6170 7065 6e64 2863 6f6c 756d 6e2e 7570  append(column.up
+00017db0: 7065 7228 2929 0a20 2020 2020 2020 2020  per()).         
+00017dc0: 2020 2020 2020 206c 6175 6e64 6572 6564         laundered
+00017dd0: 2e61 7070 656e 6428 2863 6f6c 756d 6e2c  .append((column,
+00017de0: 2063 6f6c 756d 6e29 290a 2020 2020 2020   column)).      
+00017df0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
+00017e00: 7565 0a0a 2020 2020 2020 2020 2320 4c61  ue..        # La
+00017e10: 756e 6465 7269 6e67 2069 7320 6e65 6564  undering is need
+00017e20: 6564 0a20 2020 2020 2020 2063 6f6c 756d  ed.        colum
+00017e30: 6e5f 6c61 756e 6465 7265 6420 3d20 636f  n_laundered = co
+00017e40: 6c75 6d6e 5b3a 3130 5d0a 2020 2020 2020  lumn[:10].      
+00017e50: 2020 6966 2063 6f6c 756d 6e5f 6c61 756e    if column_laun
+00017e60: 6465 7265 642e 7570 7065 7228 2920 6e6f  dered.upper() no
+00017e70: 7420 696e 206c 6175 6e64 6572 6564 5f75  t in laundered_u
+00017e80: 7070 6572 3a0a 2020 2020 2020 2020 2020  pper:.          
+00017e90: 2020 6c61 756e 6465 7265 645f 7570 7065    laundered_uppe
+00017ea0: 722e 6170 7065 6e64 2863 6f6c 756d 6e5f  r.append(column_
+00017eb0: 6c61 756e 6465 7265 642e 7570 7065 7228  laundered.upper(
+00017ec0: 2929 0a20 2020 2020 2020 2020 2020 206c  )).            l
+00017ed0: 6175 6e64 6572 6564 2e61 7070 656e 6428  aundered.append(
+00017ee0: 2863 6f6c 756d 6e2c 2063 6f6c 756d 6e5f  (column, column_
+00017ef0: 6c61 756e 6465 7265 6429 290a 2020 2020  laundered)).    
+00017f00: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00017f10: 2020 2020 2020 2320 4a75 7374 2074 616b        # Just tak
+00017f20: 696e 6720 6669 7273 7420 3130 2063 6861  ing first 10 cha
+00017f30: 7261 6374 6572 7320 6469 646e 2774 2068  racters didn't h
+00017f40: 656c 700a 2020 2020 2020 2020 2020 2020  elp.            
+00017f50: 666f 7220 696e 6465 7820 696e 2072 616e  for index in ran
+00017f60: 6765 2831 2c20 3130 3129 3a0a 2020 2020  ge(1, 101):.    
+00017f70: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+00017f80: 6e64 6578 203e 3d20 3130 303a 0a20 2020  ndex >= 100:.   
+00017f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017fa0: 2072 6169 7365 204e 6f74 496d 706c 656d   raise NotImplem
+00017fb0: 656e 7465 6445 7272 6f72 280a 2020 2020  entedError(.    
+00017fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017fd0: 2020 2020 224e 6f74 2073 7570 706f 7274      "Not support
+00017fe0: 6564 2074 6f20 6c61 756e 6465 7220 3e20  ed to launder > 
+00017ff0: 3939 2063 6f6c 756d 6e73 2073 7461 7274  99 columns start
+00018000: 696e 6720 220a 2020 2020 2020 2020 2020  ing ".          
+00018010: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+00018020: 7769 7468 207b 636f 6c75 6d6e 5f6c 6175  with {column_lau
+00018030: 6e64 6572 6564 5b3a 385d 7d22 0a20 2020  ndered[:8]}".   
+00018040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018050: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+00018060: 2020 2069 6620 696e 6465 7820 3c3d 2039     if index <= 9
+00018070: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00018080: 2020 2020 2020 636f 6c75 6d6e 5f6c 6175        column_lau
+00018090: 6e64 6572 6564 203d 2066 227b 636f 6c75  ndered = f"{colu
+000180a0: 6d6e 5f6c 6175 6e64 6572 6564 5b3a 385d  mn_laundered[:8]
+000180b0: 7d5f 7b69 6e64 6578 7d22 0a20 2020 2020  }_{index}".     
+000180c0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+000180d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000180e0: 2020 2020 2063 6f6c 756d 6e5f 6c61 756e       column_laun
+000180f0: 6465 7265 6420 3d20 6622 7b63 6f6c 756d  dered = f"{colum
+00018100: 6e5f 6c61 756e 6465 7265 645b 3a38 5d7d  n_laundered[:8]}
+00018110: 7b69 6e64 6578 7d22 0a20 2020 2020 2020  {index}".       
+00018120: 2020 2020 2020 2020 2069 6620 636f 6c75           if colu
+00018130: 6d6e 5f6c 6175 6e64 6572 6564 2e75 7070  mn_laundered.upp
+00018140: 6572 2829 206e 6f74 2069 6e20 6c61 756e  er() not in laun
+00018150: 6465 7265 645f 7570 7065 723a 0a20 2020  dered_upper:.   
+00018160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018170: 206c 6175 6e64 6572 6564 5f75 7070 6572   laundered_upper
+00018180: 2e61 7070 656e 6428 636f 6c75 6d6e 5f6c  .append(column_l
+00018190: 6175 6e64 6572 6564 2e75 7070 6572 2829  aundered.upper()
+000181a0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000181b0: 2020 2020 2020 6c61 756e 6465 7265 642e        laundered.
+000181c0: 6170 7065 6e64 2828 636f 6c75 6d6e 2c20  append((column, 
+000181d0: 636f 6c75 6d6e 5f6c 6175 6e64 6572 6564  column_laundered
+000181e0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+000181f0: 2020 2020 2020 2062 7265 616b 0a0a 2020         break..  
+00018200: 2020 7265 7475 726e 206c 6175 6e64 6572    return launder
+00018210: 6564 0a                                  ed.
```

### Comparing `geofileops-0.8.1a0/geofileops/geoops.py` & `geofileops-0.8.2/geofileops/geoops.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,2947 +1,2953 @@
-"""
-Module exposing all supported operations on geomatries in geofiles.
-"""
-
-from datetime import datetime
-import logging
-import logging.config
-from pathlib import Path
-import shutil
-from typing import Any, Callable, List, Literal, Optional, Tuple, Union, TYPE_CHECKING
-import warnings
-
-from pygeoops import GeometryType
-
-from geofileops._compat import SPATIALITE_GTE_51
-from geofileops import fileops
-from geofileops.util import _geofileinfo
-from geofileops.util import _geoops_gpd
-from geofileops.util import _geoops_sql
-from geofileops.util import _geoops_ogr
-from geofileops.util import _io_util
-from geofileops.util import _sqlite_util
-from geofileops.util._geometry_util import (
-    BufferEndCapStyle,
-    BufferJoinStyle,
-    SimplifyAlgorithm,
-)
-
-if TYPE_CHECKING:
-    import os
-
-logger = logging.getLogger(__name__)
-
-
-def dissolve_within_distance(
-    input_path: Path,
-    output_path: Path,
-    distance: float,
-    gridsize: float,
-    close_internal_gaps: bool = False,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Dissolve geometries that are within the distance specified.
-
-    The output layer will contain the dissolved geometries where all gaps between the
-    input geometries up to ``distance`` are closed.
-
-    Notes:
-      - Only tested on polygon input.
-      - Gaps between the individual polygons of multipolygon input features will also
-        be closed.
-      - The polygons in the output file are exploded to simple geometries.
-      - No attributes from the input layer are retained.
-      - If ``close_internal_gaps`` is False, the default, a ``gridsize`` > 0
-        (E.g. 0.000001) should be specified, otherwise some input boundary gaps could
-        still be closed due to rounding side effects.
-
-    Alternative names:
-      - ArcMap: aggregate_polygons (similar functionality)
-      - Keywords: merge, dissolve, aggregate, snap, close gaps, union
-
-    Args:
-        input_path (PathLike): the input file.
-        output_path (PathLike): the file to write the result to.
-        distance (float): the maximum distance between geometries to be dissolved.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. If ``close_boundary_gaps`` is False, the default, a
-            ``gridsize`` > 0 (E.g. 0.000001) should be specified, otherwise some
-            boundary gaps in the input geometries could still be closed due to rounding
-            side effects.
-        close_internal_gaps (bool, optional): also close gaps, strips or holes in the
-            input geometries that are narrower than the ``distance`` specified. E.g.
-            small holes, narrow strips starting at the boundary,... Defaults to False.
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    start_time = datetime.now()
-    operation_name = "dissolve_within_distance"
-    logger = logging.getLogger(f"geofileops.{operation_name}")
-    nb_steps = 4
-    if not close_internal_gaps:
-        # 3 extra steps if boundary gaps not to be closed.
-        nb_steps += 3
-
-    # Already check here if it is useful to continue
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop, output exists already {output_path}")
-            return
-        else:
-            fileops.remove(output_path)
-
-    tempdir = _io_util.create_tempdir(f"geofileops/{operation_name}")
-    try:
-        # First dissolve the input.
-        #
-        # Note: this reduces the complexity of operations to be executed later on.
-        # Note2: this already applies the gridsize, which needs to be applied anyway to
-        # avoid issues when determining the addedpieces_1neighbour later on.
-        logger.info(f"Start, with input file {input_path}")
-        step = 1
-        logger.info(f"Step {step} of {nb_steps}")
-        diss_path = tempdir / "100_diss.gpkg"
-        _geoops_gpd.dissolve(
-            input_path=input_path,
-            output_path=diss_path,
-            explodecollections=True,
-            input_layer=input_layer,
-            gridsize=gridsize,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            operation_prefix=f"{operation_name}-",
-        )
-
-        # Positive buffer of distance / 2 to close all gaps.
-        #
-        # Note: gridsize is not applied to preserve all possible accuracy for these
-        # temporary boundaries, otherwise the polygons are sometimes enlarged slightly,
-        # which isn't wanted + creates issues when determining the
-        # addedpieces_1neighbour later on.
-        step += 1
-        logger.info(f"Step {step} of {nb_steps}")
-        buff_path = tempdir / "110_diss_bufp.gpkg"
-        _geoops_gpd.buffer(
-            input_path=diss_path,
-            output_path=buff_path,
-            distance=distance / 2,
-            endcap_style=BufferEndCapStyle.SQUARE,
-            join_style=BufferJoinStyle.MITRE,
-            mitre_limit=1.25,
-            # gridsize=gridsize,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            operation_prefix=f"{operation_name}-",
-        )
-
-        # Dissolve the buffered input
-        #
-        # Note: gridsize is not applied to preserve all possible accuracy for these
-        # temporary boundaries, otherwise the polygons are sometimes enlarged slightly,
-        # which isn't wanted + creates issues when determining the
-        # addedpieces_1neighbour later on.
-        step += 1
-        logger.info(f"Step {step} of {nb_steps}")
-        buff_diss_path = tempdir / "120_diss_bufp_diss.gpkg"
-        _geoops_gpd.dissolve(
-            input_path=buff_path,
-            output_path=buff_diss_path,
-            explodecollections=True,
-            # gridsize=gridsize,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            operation_prefix=f"{operation_name}-",
-        )
-
-        # Negative buffer to get back to the borders of the input geometries
-        # Use a larger mitre limit, otherwise there are a lot of small triangles that
-        # don't dissappear again.
-        step += 1
-        logger.info(f"Step {step} of {nb_steps}")
-        buff_diss_bufm_path = tempdir / "130_diss_bufp_diss_bufm.gpkg"
-        _geoops_gpd.buffer(
-            input_path=buff_diss_path,
-            output_path=buff_diss_bufm_path,
-            distance=-(distance / 2),
-            endcap_style=BufferEndCapStyle.SQUARE,
-            join_style=BufferJoinStyle.MITRE,
-            mitre_limit=2,
-            gridsize=gridsize,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            operation_prefix=f"{operation_name}-",
-        )
-
-        # Determine which parts that were added were actually gaps within 'distance' in
-        # the original polygons, so they can be removed again.
-
-        # Determine all pieces added to the input in the process above.
-        step += 1
-        logger.info(f"Step {step} of {nb_steps}")
-        added_pieces_path = tempdir / "200_addedpieces.gpkg"
-        _geoops_sql.erase(
-            input_path=buff_diss_bufm_path,
-            erase_path=diss_path,
-            output_path=added_pieces_path,
-            explodecollections=True,
-            gridsize=gridsize,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            operation_prefix=f"{operation_name}-",
-        )
-
-        # Build a filter to select the pieces that we want to erase again from the
-        # result because they were incorrectly added.
-        # The filter will depend on input parameters.
-        if close_internal_gaps:
-            # True, so also gaps in the original input boundaries should be closed.
-            # This means that in theory all pieces can be retained, but in practice
-            # there are some cases where the above algorithm adds unwanted area, so that
-            # needs to be erased again.
-            #
-            # Parameters that indicate that added pieces won't need to be erased:
-            #   - large areas (>= distance²) seem OK.
-            #   - if > 1 neighbour, seems OK.
-            #
-            # For all pieces that don't comply to the above, the following parameters
-            # indicate that they need to be selected to erase them:
-            #   - pieces can be very narrow slivers. E.g. alongside a long boundary with
-            #     a small bend, probably due to rounding side effects in the +/- buffer.
-            #   - pieces can be spikes. E.g. when a "road" of ~ 'distance' width is not
-            #     filled up between two input geometries has a bend. Depending on the
-            #     angle, the mitre of the negative buffer can leave a spike in place.
-            pieces_to_erase_filter = f"""
-                neighbours_count_distinct <= 1
-                AND geom_area < {distance} * {distance}
-                AND neighbours_perimeter/2 + neighbours_length <= 0.8 * geom_perimeter
-            """
-        else:
-            # False, so we want to keep all pieces that intersect with only 1 neighbour
-            # in the input, so they can be remove again from the result.
-            pieces_to_erase_filter = "neighbours_count_distinct <= 1"
-
-        # Notes:
-        # - The conversion to json followed by extraction from json allows to use a
-        #   correlated subquery to return multiple columns. Joining the subquery gives
-        #   very bad performance.
-        # - Every level of nesting of SQL queries is needed to get good performance, in
-        #   combination with "LIMIT -1 OFFSET 0" to avoid the subquery flattening.
-        #   Flattening e.g. "geom IS NOT NULL" leads to geom operation to be calculated
-        #   twice!
-        input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-        input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-        sql_stmt = f"""
-            WITH neighbours AS (
-                SELECT layer1_sub.rowid AS layer1_rowid
-                      ,layer2_sub.rowid AS layer2_rowid
-                      ,ST_Intersection(
-                          layer1_sub.{{input1_geometrycolumn}},
-                          layer2_sub.{{input2_geometrycolumn}}
-                       ) AS intersect_geom
-                  FROM {{input1_databasename}}."{{input1_layer}}" layer1_sub
-                  JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                    ON layer1_sub.rowid = layer1tree.id
-                  JOIN {{input2_databasename}}."{{input2_layer}}" layer2_sub
-                  JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                    ON layer2_sub.rowid = layer2tree.id
-                 WHERE 1=1
-                   AND layer1tree.minx <= layer2tree.maxx
-                   AND layer1tree.maxx >= layer2tree.minx
-                   AND layer1tree.miny <= layer2tree.maxy
-                   AND layer1tree.maxy >= layer2tree.miny
-                   AND ST_Intersects(
-                          layer1_sub.{{input1_geometrycolumn}},
-                          layer2_sub.{{input2_geometrycolumn}}) = 1
-              )
-            SELECT * FROM (
-              SELECT geom
-                    ,ST_Perimeter(geom) AS geom_perimeter
-                    ,ST_Area(geom) AS geom_area
-                    ,neighbours_json ->> '$.nb_distinct' AS neighbours_count_distinct
-                    ,neighbours_json ->> '$.length' AS neighbours_length
-                    ,neighbours_json ->> '$.perimeter' AS neighbours_perimeter
-                FROM (
-                  SELECT layer1.{{input1_geometrycolumn}} AS geom
-                        ,( SELECT json_object(
-                                    'nb_distinct', COUNT(DISTINCT layer2_rowid),
-                                    'length', SUM(ST_Length(intersect_geom)),
-                                    'perimeter', SUM(ST_Perimeter(intersect_geom))
-                                  )
-                             FROM neighbours
-                            WHERE neighbours.layer1_rowid = layer1.rowid
-                              AND neighbours.intersect_geom IS NOT NULL
-                            GROUP BY neighbours.layer1_rowid
-                            LIMIT -1 OFFSET 0
-                         ) AS neighbours_json
-                    FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                   WHERE 1=1
-                     {{batch_filter}}
-                   LIMIT -1 OFFSET 0
-                  )
-                  LIMIT -1 OFFSET 0
-               )
-             WHERE geom IS NOT NULL
-               AND ({pieces_to_erase_filter})
-        """
-
-        step += 1
-        logger.info(f"Step {step} of {nb_steps}")
-        added_pieces_to_be_erased_input = tempdir / "210_addedpieces_to_be_erased.gpkg"
-        _geoops_sql.select_two_layers(
-            input1_path=added_pieces_path,
-            input2_path=input_path,
-            output_path=added_pieces_to_be_erased_input,
-            sql_stmt=sql_stmt,
-            input2_layer=input_layer,
-            # gridsize=gridsize,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            operation_prefix=f"{operation_name}-",
-        )
-
-        step += 1
-        logger.info(f"Step {step} of {nb_steps}")
-        _geoops_sql.erase(
-            input_path=buff_diss_bufm_path,
-            erase_path=added_pieces_to_be_erased_input,
-            output_path=output_path,
-            output_layer=output_layer,
-            explodecollections=True,
-            gridsize=gridsize,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-            operation_prefix=f"{operation_name}-",
-        )
-
-    finally:
-        shutil.rmtree(tempdir, ignore_errors=True)
-
-    logger.info(f"Ready, took {datetime.now()-start_time}")
-
-
-def apply(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    func: Callable[[Any], Any],
-    only_geom_input: bool = True,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Union[GeometryType, str, None] = None,
-    gridsize: float = 0.0,
-    keep_empty_geoms: Optional[bool] = None,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Apply a python lambda function on the geometry column of the input file.
-
-    The result is written to the output file specified.
-
-    If ``explodecollections`` is False and the input and output file type is GeoPackage,
-    the fid will be preserved. In other cases this will typically not be the case.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        func (Callable): lambda function to apply to the geometry column.
-        only_geom_input (bool, optional): If True, only the geometry
-            column is available. If False, the entire row is input.
-            Remark: when False, the operation is 50% slower. Defaults to True.
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        force_output_geometrytype (GeometryType, optional): The output geometry type to
-            force. If None, a best-effort guess is made and will always result in a
-            multi-type. Defaults to None.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
-            in the output. Defaults to False.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    Examples:
-        This example shows the basic usage of ``gfo.apply``:
-
-        .. code-block:: python
-
-            import geofileops as gfo
-
-            gfo.apply(
-                input_path=...,
-                output_path=...,
-                func=lambda geom: pygeoops.remove_inner_rings(geom, min_area_to_keep=1),
-            )
-
-        If you need to use the contents of other columns in your lambda function, you can
-        call ``gfo.apply`` like this:
-
-        .. code-block:: python
-
-            import geofileops as gfo
-
-            gfo.apply(
-                input_path=...,
-                output_path=...,
-                func=lambda row: pygeoops.remove_inner_rings(
-                    row.geometry, min_area_to_keep=row.min_area_to_keep
-                ),
-                only_geom_input=False,
-            )
-
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.apply")
-    logger.info(f"Start on {input_path}")
-
-    return _geoops_gpd.apply(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        func=func,
-        only_geom_input=only_geom_input,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        gridsize=gridsize,
-        keep_empty_geoms=keep_empty_geoms,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def buffer(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    distance: float,
-    quadrantsegments: int = 5,
-    endcap_style: BufferEndCapStyle = BufferEndCapStyle.ROUND,
-    join_style: BufferJoinStyle = BufferJoinStyle.ROUND,
-    mitre_limit: float = 5.0,
-    single_sided: bool = False,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    keep_empty_geoms: Optional[bool] = None,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Applies a buffer operation on geometry column of the input file.
-
-    The result is written to the output file specified.
-
-    If ``explodecollections`` is False and the input and output file type is GeoPackage,
-    the fid will be preserved. In other cases this will typically not be the case.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        distance (float): the buffer size to apply. In projected coordinate
-            systems this is typically in meter, in geodetic systems this is
-            typically in degrees.
-        quadrantsegments (int): the number of points a quadrant needs to be
-            approximated with for rounded styles. Defaults to 5.
-        endcap_style (BufferEndCapStyle, optional): buffer style to use for a
-            point or the end points of a line. Defaults to ROUND.
-
-              * ROUND: for points and lines the ends are buffered rounded.
-              * FLAT: a point stays a point, a buffered line will end flat
-                at the end points
-              * SQUARE: a point becomes a square, a buffered line will end
-                flat at the end points, but elongated by ``distance``
-        join_style (BufferJoinStyle, optional): buffer style to use for
-            corners in a line or a polygon boundary. Defaults to ROUND.
-
-              * ROUND: corners in the result are rounded
-              * MITRE: corners in the result are sharp
-              * BEVEL: are flattened
-        mitre_limit (float, optional): in case of ``join_style`` MITRE, if the
-            spiky result for a sharp angle becomes longer than this ratio limit, it
-            is "beveled" using this maximum ratio. Defaults to 5.0.
-        single_sided (bool, optional): only one side of the line is buffered,
-            if distance is negative, the left side, if distance is positive,
-            the right hand side. Only relevant for line geometries.
-            Defaults to False.
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
-            in the output. Defaults to False.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    Notes:
-        Using the different buffer style option parameters you can control how the
-        buffer is created:
-
-        - **quadrantsegments** *(int)*
-
-        .. list-table::
-            :header-rows: 1
-
-            * - 5 (default)
-              - 2
-              - 1
-            * - |buffer_quadrantsegm_5|
-              - |buffer_quadrantsegm_2|
-              - |buffer_quadrantsegm_1|
-
-        - **endcap_style** *(BufferEndCapStyle)*
-
-        .. list-table::
-            :header-rows: 1
-
-            * - ROUND (default)
-              - FLAT
-              - SQUARE
-            * - |buffer_endcap_round|
-              - |buffer_endcap_flat|
-              - |buffer_endcap_square|
-
-        - **join_style** *(BufferJoinStyle)*
-
-        .. list-table::
-            :header-rows: 1
-
-            * - ROUND (default)
-              - MITRE
-              - BEVEL
-            * - |buffer_joinstyle_round|
-              - |buffer_joinstyle_mitre|
-              - |buffer_joinstyle_bevel|
-
-        - **mitre** *(float)*
-
-        .. list-table::
-            :header-rows: 1
-
-            * - 5.0 (default)
-              - 2.5
-              - 1.0
-            * - |buffer_mitre_50|
-              - |buffer_mitre_25|
-              - |buffer_mitre_10|
-
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite</a>
-
-    .. |buffer_quadrantsegm_5| image:: ../_static/images/buffer_quadrantsegments_5.png
-        :alt: Buffer with quadrantsegments=5
-    .. |buffer_quadrantsegm_2| image:: ../_static/images/buffer_quadrantsegments_2.png
-        :alt: Buffer with quadrantsegments=2
-    .. |buffer_quadrantsegm_1| image:: ../_static/images/buffer_quadrantsegments_1.png
-        :alt: Buffer with quadrantsegments=1
-    .. |buffer_endcap_round| image:: ../_static/images/buffer_endcap_round.png
-        :alt: Buffer with endcap_style=BufferEndCapStyle.ROUND (default)
-    .. |buffer_endcap_flat| image:: ../_static/images/buffer_endcap_flat.png
-        :alt: Buffer with endcap_style=BufferEndCapStyle.FLAT
-    .. |buffer_endcap_square| image:: ../_static/images/buffer_endcap_square.png
-        :alt: Buffer with endcap_style=BufferEndCapStyle.SQUARE
-    .. |buffer_joinstyle_round| image:: ../_static/images/buffer_joinstyle_round.png
-        :alt: Buffer with joinstyle=BufferJoinStyle.ROUND (default)
-    .. |buffer_joinstyle_mitre| image:: ../_static/images/buffer_joinstyle_mitre.png
-        :alt: Buffer with joinstyle=BufferJoinStyle.MITRE
-    .. |buffer_joinstyle_bevel| image:: ../_static/images/buffer_joinstyle_bevel.png
-        :alt: Buffer with joinstyle=BufferJoinStyle.BEVEL
-    .. |buffer_mitre_50| image:: ../_static/images/buffer_mitre_50.png
-        :alt: Buffer with mitre=5.0
-    .. |buffer_mitre_25| image:: ../_static/images/buffer_mitre_25.png
-        :alt: Buffer with mitre=2.5
-    .. |buffer_mitre_10| image:: ../_static/images/buffer_mitre_10.png
-        :alt: Buffer with mitre=1.0
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.buffer")
-    logger.info(
-        f"Start, on {input_path} "
-        f"(distance: {distance}, quadrantsegments: {quadrantsegments})"
-    )
-
-    if (
-        endcap_style == BufferEndCapStyle.ROUND
-        and join_style == BufferJoinStyle.ROUND
-        and single_sided is False
-    ):
-        # If default buffer options for spatialite, use the faster SQL version
-        return _geoops_sql.buffer(
-            input_path=Path(input_path),
-            output_path=Path(output_path),
-            distance=distance,
-            quadrantsegments=quadrantsegments,
-            input_layer=input_layer,
-            output_layer=output_layer,
-            columns=columns,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            keep_empty_geoms=keep_empty_geoms,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-        )
-    else:
-        # If special buffer options, use geopandas version
-        return _geoops_gpd.buffer(
-            input_path=Path(input_path),
-            output_path=Path(output_path),
-            distance=distance,
-            quadrantsegments=quadrantsegments,
-            endcap_style=endcap_style,
-            join_style=join_style,
-            mitre_limit=mitre_limit,
-            single_sided=single_sided,
-            input_layer=input_layer,
-            output_layer=output_layer,
-            columns=columns,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            keep_empty_geoms=keep_empty_geoms,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-        )
-
-
-def clip_by_geometry(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    clip_geometry: Union[Tuple[float, float, float, float], str],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    """
-    Clip all geometries in the imput file by the geometry provided.
-
-    If ``explodecollections`` is False and the input and output file type is GeoPackage,
-    the fid will be preserved. In other cases this will typically not be the case.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        clip_geometry (Union[Tuple[float, float, float, float], str]): the bounds
-            or WKT geometry to clip with.
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger = logging.getLogger("geofileops.clip_by_geometry")
-    logger.info(f"Start, on {input_path}")
-    return _geoops_ogr.clip_by_geometry(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        clip_geometry=clip_geometry,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force=force,
-    )
-
-
-def convexhull(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    keep_empty_geoms: Optional[bool] = None,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Applies a convexhull operation on the input file.
-
-    The result is written to the output file specified.
-
-    If ``explodecollections`` is False and the input and output file type is GeoPackage,
-    the fid will be preserved. In other cases this will typically not be the case.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
-            in the output. Defaults to False.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.convexhull")
-    logger.info(f"Start, on {input_path}")
-
-    return _geoops_sql.convexhull(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        gridsize=gridsize,
-        keep_empty_geoms=keep_empty_geoms,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def delete_duplicate_geometries(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    keep_empty_geoms: Optional[bool] = None,
-    where_post: Optional[str] = None,
-    force: bool = False,
-):
-    """
-    Copy all rows to the output file, except for duplicate geometries.
-
-    If ``explodecollections`` is False and the input and output file type is GeoPackage,
-    the fid will be preserved. In other cases this will typically not be the case.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
-            in the output. Defaults to False.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.delete_duplicate_geometries")
-    logger.info(f"Start, on {input_path}")
-
-    return _geoops_sql.delete_duplicate_geometries(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        keep_empty_geoms=keep_empty_geoms,
-        where_post=where_post,
-        force=force,
-    )
-
-
-def dissolve(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    explodecollections: bool,
-    groupby_columns: Union[List[str], str, None] = None,
-    agg_columns: Optional[dict] = None,
-    tiles_path: Union[str, "os.PathLike[Any]", None] = None,
-    nb_squarish_tiles: int = 1,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Applies a dissolve operation on the input file.
-
-    If columns are specified with ``groupby_columns``, the data is first grouped
-    on those columns before the geometries are merged.
-
-    Data in other columns can be retained in the output by specifying the
-    ``agg_columns`` parameter.
-
-    Because the input layer is tiled using a grid to speed up, extra collinear points
-    will typically be present in the output geometries. Rows with null or empty
-    geometries are ignored.
-
-    This is an example of how data in the columns that isn't grouped on can be
-    aggregated to be added to the output file:
-
-    .. code-block:: python
-
-        import geofileops as gfo
-
-        gfo.dissolve(
-            input_path=...,
-            output_path=...,
-            groupby_columns=["cropgroup"],
-            agg_columns={
-                "columns": [
-                    {"column": "crop", "agg": "max", "as": "crop_max"},
-                    {"column": "crop", "agg": "count", "as": "crop_count"},
-                    {
-                        "column": "crop",
-                        "agg": "concat",
-                        "as": "crop_concat",
-                        "distinct": True,
-                        "sep": ";",
-                    },
-                    {"column": "area", "agg": "mean", "as": "area_mean"},
-                ]
-            },
-            explodecollections=False,
-        )
-
-    The following example will save all detailed data for the columns
-    "crop_label" and "area" in the output file. The detailed data is encoded
-    per group/row in a "json" text field. Shapefiles only support up to 254
-    characters in a text field, so this format won't be very suited as output
-    format for this option.
-
-    .. code-block:: python
-
-        import geofileops as gfo
-
-        gfo.dissolve(
-            input_path=...,
-            output_path=...,
-            groupby_columns=["cropgroup"],
-            agg_columns={"json": ["crop", "area"]},
-            explodecollections=False,
-        )
-
-    This results in this type of output:
-    ::
-
-        cropgroup  json
-        Grasses    ["{"crop":"Meadow","area":1290,"fid_orig":5}","{"crop":"Pasture",...
-        Maize      ["{"crop":"Silo","area":3889.29,"fid_orig":2}","{"crop":"Fodder",...
-
-    If the output is tiled (by specifying ``tiles_path`` or ``nb_squarish_tiles`` > 1),
-    the result will be clipped on the output tiles and the tile borders are
-    never crossed.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        explodecollections (bool): True to output only simple geometries. If
-            False, this can result in huge geometries for large files,
-            especially if no ``groupby_columns`` are specified.
-        groupby_columns (Union[List[str], str], optional): columns (case insensitive) to
-            group on while aggregating. Defaults to None, resulting in a spatial union
-            of all geometries that touch.
-        agg_columns (dict, optional): columns to aggregate based on
-            the groupings by groupby columns. Depending on the top-level key
-            value of the dict, the output for the aggregation is different:
-
-                - "json": dump all data per group to one "json" column. The
-                  value can be None (= all columns) or a list of columns to include.
-                - "columns": aggregate to seperate columns. The value should
-                  be a list of dicts with the following keys:
-
-                    - "column": column name (case insensitive) in the input file. In
-                      addition to standard columns, it is also possible to specify
-                      "fid", a unique index available in all input files.
-                    - "agg": aggregation to use:
-
-                        - count: the number of values in the group
-                        - sum: the sum of the values in the group
-                        - mean: the mean/average of the values in the group
-                        - min: the minimum value in the group
-                        - max: the maximum value in the group
-                        - median: the median value in the group
-                        - concat: all non-null values in the group concatenated (in
-                          arbitrary order)
-
-                    - "as": column name in the output file. Note: using "fid" as alias
-                      is not recommended: it can cause errors or odd behaviour.
-                    - "distinct" (optional): True to distinct the values before
-                      aggregation.
-                    - "sep" (optional): the separator to use for concat. Default: ",".
-
-        tiles_path (PathLike, optional): a path to a geofile containing tiles.
-            If specified, the output will be dissolved/unioned only within the
-            tiles provided.
-            Can be used to avoid huge geometries being created if the input
-            geometries are very interconnected.
-            Defaults to None (= the output is not tiled).
-        nb_squarish_tiles (int, optional): the approximate number of tiles the
-            output should be dissolved/unioned to. If > 1, a tiling grid is
-            automatically created based on the total bounds of the input file.
-            The input geometries will be dissolved/unioned only within the
-            tiles generated.
-            Can be used to avoid huge geometries being created if the input
-            geometries are very interconnected.
-            Defaults to 1 (= the output is not tiled).
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    # Init
-    if tiles_path is not None:
-        tiles_path = Path(tiles_path)
-
-    # Standardize parameter to simplify the rest of the code
-    if groupby_columns is not None:
-        if isinstance(groupby_columns, str):
-            # If a string is passed, convert to list
-            groupby_columns = [groupby_columns]
-        elif len(groupby_columns) == 0:
-            # If an empty list of geometry columns is passed, convert it to None
-            groupby_columns = None
-
-    logger = logging.getLogger("geofileops.dissolve")
-    logger.info(f"Start, on {input_path} to {output_path}")
-    return _geoops_gpd.dissolve(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        explodecollections=explodecollections,
-        groupby_columns=groupby_columns,
-        agg_columns=agg_columns,
-        tiles_path=tiles_path,
-        nb_squarish_tiles=nb_squarish_tiles,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def export_by_bounds(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    bounds: Tuple[float, float, float, float],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    """
-    Export the rows that intersect with the bounds specified.
-
-    If ``explodecollections`` is False and the input and output file type is GeoPackage,
-    the fid will be preserved. In other cases this will typically not be the case.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        bounds (Tuple[float, float, float, float]): the bounds to filter on.
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger = logging.getLogger("geofileops.export_by_bounds")
-    logger.info(f"Start, on {input_path}")
-    return _geoops_ogr.export_by_bounds(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        bounds=bounds,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force=force,
-    )
-
-
-def isvalid(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]", None] = None,
-    only_invalid: bool = True,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    validate_attribute_data: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-) -> bool:
-    """
-    Checks for all geometries in the geofile if they are valid.
-
-    The results are written to the output file.
-
-    If ``explodecollections`` is False and the input and output file type is GeoPackage,
-    the fid will be preserved. In other cases this will typically not be the case.
-
-    Args:
-        input_path (PathLike): The input file.
-        output_path (PathLike, optional): The output file path. If not
-            specified the result will be written in a new file alongside the
-            input file. Defaults to None.
-        only_invalid (bool, optional): if True, only put invalid results in the
-            output file. Deprecated: always treated as True.
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        validate_attribute_data (bool, optional): True to validate if all attribute data
-            can be read. Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    Returns:
-        bool: True if all geometries were valid.
-    """
-    # Check parameters
-    if output_path is not None:
-        output_path = Path(output_path)
-    else:
-        input_path = Path(input_path)
-        output_path = (
-            input_path.parent / f"{input_path.stem}_isvalid{input_path.suffix}"
-        )
-
-    # Go!
-    logger = logging.getLogger("geofileops.isvalid")
-    logger.info(f"Start, on {input_path}")
-    return _geoops_sql.isvalid(
-        input_path=Path(input_path),
-        output_path=output_path,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        validate_attribute_data=validate_attribute_data,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def makevalid(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Union[str, None, GeometryType] = None,
-    gridsize: float = 0.0,
-    keep_empty_geoms: Optional[bool] = None,
-    where_post: Optional[str] = None,
-    precision: Optional[float] = None,
-    validate_attribute_data: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Makes all geometries in the input file valid.
-
-    Writes the result to the output path.
-
-    Alternative names:
-        - QGIS: fix geometries
-        - shapely, geopandas: make_valid
-
-    If ``explodecollections`` is False and the input and output file type is GeoPackage,
-    the fid will be preserved. In other cases this will typically not be the case.
-
-    Args:
-        input_path (PathLike): The input file.
-        output_path (PathLike): The file to write the result to.
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        force_output_geometrytype (GeometryType, optional): The output geometry type to
-            force the output to. If None, the geometry type of the input is retained.
-            Defaults to None.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        precision (float, optional): deprecated. Use ``gridsize``.
-        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
-            in the output. Defaults to False.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        validate_attribute_data (bool, optional): True to validate if all attribute data
-            can be read. Raises an exception if an error is found, as this type of error
-            cannot be fixed using makevalid. Defaults to False.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.makevalid")
-    logger.info(f"Start, on {input_path}")
-
-    if gridsize is None:
-        gridsize = 0.0
-    if precision is not None and gridsize != 0.0:
-        raise ValueError(
-            "the precision parameter is deprecated and cannot be combined with gridsize"
-        )
-    if precision is not None:
-        gridsize = precision
-        warnings.warn(
-            "the precision parameter is deprecated and will be removed in a future "
-            "version: please use gridsize",
-            FutureWarning,
-            stacklevel=2,
-        )
-
-    if SPATIALITE_GTE_51 and gridsize == 0.0:
-        # If spatialite >= 5.1 available use faster/less memory using SQL implementation
-        # Only use this version if gridsize is 0.0, because when gridsize applied it is
-        # less robust than the gpd implementation.
-        _geoops_sql.makevalid(
-            input_path=Path(input_path),
-            output_path=Path(output_path),
-            input_layer=input_layer,
-            output_layer=output_layer,
-            columns=columns,
-            explodecollections=explodecollections,
-            force_output_geometrytype=force_output_geometrytype,
-            gridsize=gridsize,
-            keep_empty_geoms=keep_empty_geoms,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-        )
-    else:
-        _geoops_gpd.makevalid(
-            input_path=Path(input_path),
-            output_path=Path(output_path),
-            input_layer=input_layer,
-            output_layer=output_layer,
-            columns=columns,
-            explodecollections=explodecollections,
-            force_output_geometrytype=force_output_geometrytype,
-            gridsize=gridsize,
-            keep_empty_geoms=keep_empty_geoms,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-        )
-
-    # If asked and output is spatialite based, check if all data can be read
-    if validate_attribute_data:
-        output_geofileinfo = _geofileinfo.get_geofileinfo(input_path)
-        if output_geofileinfo.is_spatialite_based:
-            _sqlite_util.test_data_integrity(path=input_path)
-
-
-def warp(
-    input_path: Path,
-    output_path: Path,
-    gcps: List[Tuple[float, float, float, float, Optional[float]]],
-    algorithm: str = "polynomial",
-    order: Optional[int] = None,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    """
-    Warp all input features to the output file according to the gcps specified.
-
-    Alternative names:
-        - rubbersheet, rubbersheeting
-
-    Args:
-        input_path (PathLike): The input file.
-        output_path (PathLike): The file to write the result to.
-        gcps (List[Tuple[float, float, float, float]]): ground control points to
-            use to warp the input geometries. This is a list of tuples like this:
-            [(x_orig, y_orig, x_dest, y_dest, elevation), ...].
-        algorithm (str, optional): algorithm to use to warp:
-            - "polynomial": use a polynomial transformation
-            - "tps": use a thin plate spline transformer
-            Defaults to "polynomial".
-        order (int, optional): if algorithm is "polynomial", the order of the
-            polynomial to use for warping.
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger = logging.getLogger("geofileops.warp")
-    logger.info(f"Start, on {input_path}")
-    _geoops_ogr.warp(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        gcps=gcps,
-        algorithm=algorithm,
-        order=order,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force=force,
-    )
-
-
-def select(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    sql_stmt: str,
-    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = "SQLITE",
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Union[GeometryType, str, None] = None,
-    gridsize: float = 0.0,
-    keep_empty_geoms: bool = True,
-    nb_parallel: int = 1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    '''
-    Execute a SELECT SQL statement on the input file.
-
-    The ``sql_stmt`` must be in SQLite dialect and can contain placeholders that will be
-    replaced automatically. More details can be found in the notes and examples below.
-
-    The result is written to the output file specified.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        sql_stmt (str): the SELECT SQL statement to execute
-        sql_dialect (str, optional): the SQL dialect to use. If None, the default SQL
-            dialect of the underlying source is used. Defaults to "SQLITE".
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain, if
-            {columns_to_select_str} is used. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones. Defaults to False.
-        force_output_geometrytype (GeometryType, optional): The output geometry type to
-            force. Defaults to None, and then the geometry type of the input is used
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
-            in the output. Defaults to True.
-        nb_parallel (int, optional): the number of parallel processes to use. If -1, all
-            available cores are used. Defaults to 1.
-            If ``nb_parallel`` != 1, make sure your query still returns correct results
-            if it is executed per batch of rows instead of in one go on the entire
-            layer.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage. If batchsize != -1,
-            make sure your query still returns correct results if it is executed per
-            batch of rows instead of in one go on the entire layer.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s). Defaults to False.
-
-    Notes:
-        By convention, the sqlite query can contain following placeholders that
-        will be automatically replaced for you:
-
-        * {geometrycolumn}: the column where the primary geometry is stored.
-        * {columns_to_select_str}: if ``columns`` is not None, those columns, otherwise
-          all columns of the layer.
-        * {input_layer}: the layer name of the input layer.
-        * {batch_filter}: the filter used to process in parallel per batch.
-
-        Hint: often you will want to use f"" formatting on the SQL statement to fill out
-        some parameters of your own as well. You can easily escape the placeholders
-        above by doubling the "{" and "}", e.g. use {{geometrycolumn}} for
-        {geometrycolumn}. Also check out the example below.
-
-        Example: buffer all rows with a certain minimum area to the output file.
-
-        .. code-block:: python
-
-            import geofileops as gfo
-
-            minimum_area = 100
-            sql_stmt = f"""
-                SELECT ST_Buffer({{geometrycolumn}}, 1) AS {{geometrycolumn}}
-                      {{columns_to_select_str}}
-                  FROM "{{input_layer}}" layer
-                 WHERE 1=1
-                   {{batch_filter}}
-                   AND ST_Area({{geometrycolumn}}) > {minimum_area}
-            """
-            gfo.select(
-                input_path=...,
-                output_path=...,
-                sql_stmt=sql_stmt,
-            )
-
-        Some important remarks:
-
-        * Because some SQL statements won't give the same result when parallelized
-          (eg. when using a group by statement), ``nb_parallel`` is 1 by default.
-          If you do want to use parallel processing, specify ``nb_parallel`` + make
-          sure to include the placeholder {batch_filter} in your ``sql_stmt``.
-          This placeholder will be replaced with a filter of the form
-          "AND rowid >= x AND rowid < y".
-        * The name of the geometry column depends on the file format of the input file.
-          E.g. for .shp files the column will be called "geometry", for .gpkg files the
-          default name is "geom". If you use the {geometrycolumn} placeholder,
-          geofileops will replace it with the correct column name for the input file.
-        * If you apply (spatialite) functions on the geometry column always alias them
-          again to its original column name, e.g. with "AS {geometrycolumn}".
-        * Some SQL statements won't give correct results when parallelized/ran in
-          multiple batches, e.g. when using a group by statement. This is why the
-          default value for nb_parallel is 1. If you want to parallelize or run the
-          query in multiple batches (by specifying ``nb_parallel`` != 1 or ``batchsize``
-          > 0), you should make sure your query will give correct results if it is
-          executed per batch of rows instead of once on the entire layer.
-          Additionally, if you do so, make sure to include the placeholder
-          {batch_filter} in your ``sql_stmt``. This placeholder will be replaced with a
-          filter of the form "AND rowid >= x AND rowid < y" and will ensure every row is
-          only treated once.
-        * Table names are best double quoted as in the example, because some
-          characters are otherwise not supported in the table name, eg. '-'.
-        * It is recommend to give the table you select from "layer" as alias. If
-          you use the {batch_filter} placeholder this is even mandatory.
-        * When using the (default) "SQLITE" SQL dialect, you can also use the spatialite
-          functions as documented here: |spatialite_reference_link|.
-        * It is supported to use an attribute table (= table without geometry column) as
-          input layer and/or not to include the geometry column in the selected columns.
-          Note though that if the {columns_to_select_str} placeholder is used, it will
-          start with a "," and if no column precedes it the SQL statement will be
-          invalid.
-
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    '''  # noqa: E501
-    logger = logging.getLogger("geofileops.select")
-    logger.info(f"Start, on {input_path}")
-
-    # Convert force_output_geometrytype to GeometryType (if necessary)
-    if force_output_geometrytype is not None:
-        force_output_geometrytype = GeometryType(force_output_geometrytype)
-
-    return _geoops_sql.select(
-        input_path=Path(input_path),
-        output_path=Path(output_path),
-        sql_stmt=sql_stmt,
-        sql_dialect=sql_dialect,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        keep_empty_geoms=keep_empty_geoms,
-        gridsize=gridsize,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def simplify(
-    input_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    tolerance: float,
-    algorithm: Union[str, SimplifyAlgorithm] = "rdp",
-    lookahead: int = 8,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    keep_empty_geoms: Optional[bool] = None,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Applies a simplify operation on geometry column of the input file.
-
-    The result is written to the output file specified.
-
-    If ``explodecollections`` is False and the input and output file type is GeoPackage,
-    the fid will be preserved. In other cases this will typically not be the case.
-
-    Args:
-        input_path (PathLike): the input file
-        output_path (PathLike): the file to write the result to
-        tolerance (float): mandatory for the following algorithms:
-
-                * RAMER_DOUGLAS_PEUCKER: distance to use as tolerance.
-                * LANG: distance to use as tolerance.
-                * VISVALINGAM_WHYATT: area to use as tolerance.
-
-            In projected coordinate systems this tolerance will typically be
-            in meter, in geodetic systems this is typically in degrees.
-        algorithm (str, optional): algorithm to use. Defaults to "rdp"
-            (Ramer Douglas Peucker).
-        lookahead (int, optional): used for LANG algorithm. Defaults to 8.
-        input_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        output_layer (str, optional): input layer name. Optional if the input
-            file only contains one layer.
-        columns (List[str], optional): list of columns to retain. If None, all standard
-            columns are retained. In addition to standard columns, it is also possible
-            to specify "fid", a unique index available in all input files. Note that the
-            "fid" will be aliased eg. to "fid_1". Defaults to None.
-        explodecollections (bool, optional): True to output only simple geometries.
-            Defaults to False.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
-            in the output. Defaults to False.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.simplify")
-    logger.info(f"Start, on {input_path} with tolerance {tolerance}")
-    if isinstance(algorithm, str):
-        algorithm = SimplifyAlgorithm(algorithm)
-
-    if algorithm == SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER:
-        return _geoops_sql.simplify(
-            input_path=Path(input_path),
-            output_path=Path(output_path),
-            tolerance=tolerance,
-            input_layer=input_layer,
-            output_layer=output_layer,
-            columns=columns,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            keep_empty_geoms=keep_empty_geoms,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-        )
-    else:
-        return _geoops_gpd.simplify(
-            input_path=Path(input_path),
-            output_path=Path(output_path),
-            tolerance=tolerance,
-            algorithm=algorithm,
-            lookahead=lookahead,
-            input_layer=input_layer,
-            output_layer=output_layer,
-            columns=columns,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            keep_empty_geoms=keep_empty_geoms,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-        )
-
-
-# ------------------------
-# Operations on two layers
-# ------------------------
-
-
-def clip(
-    input_path: Union[str, "os.PathLike[Any]"],
-    clip_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input_layer: Optional[str] = None,
-    input_columns: Optional[List[str]] = None,
-    clip_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Clip the input layer with the clip layer.
-
-    The resulting layer will contain the parts of the geometries in the
-    input layer that overlap with the dissolved geometries in the clip layer.
-
-    Clarifications:
-        - every row in the input layer will result in maximum one row in the
-          output layer.
-        - geometries in the input layer that overlap with multiple adjacent
-          geometries in the clip layer won't result in the input geometries
-          getting split.
-
-    This is the result you can expect when clipping a polygon layer (yellow)
-    with another polygon layer (purple):
-
-    .. list-table::
-       :header-rows: 1
-
-       * - Input
-         - Clip result
-       * - |clip_input|
-         - |clip_result|
-
-    Args:
-        input_path (PathLike): The file to clip.
-        clip_path (PathLike): The file with the geometries to clip with.
-        output_path (PathLike): the file to write the result to
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        input_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
-        clip_layer (str, optional): clip layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): output layer name. Optional if the
-            file only contains one layer.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    .. |clip_input| image:: ../_static/images/clip_input.png
-        :alt: Clip input
-    .. |clip_result| image:: ../_static/images/clip_result.png
-        :alt: Clip result
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.clip")
-    logger.info(f"Start on {input_path} with {clip_path} to {output_path}")
-    return _geoops_sql.clip(
-        input_path=Path(input_path),
-        clip_path=Path(clip_path),
-        output_path=Path(output_path),
-        input_layer=input_layer,
-        input_columns=input_columns,
-        clip_layer=clip_layer,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def erase(
-    input_path: Union[str, "os.PathLike[Any]"],
-    erase_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input_layer: Optional[str] = None,
-    input_columns: Optional[List[str]] = None,
-    erase_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    subdivide_coords: int = 2000,
-    force: bool = False,
-):
-    """
-    Erase all geometries in the erase layer from the input layer.
-
-    Clarifications:
-        - every row in the input layer will result in maximum one row in the
-          output layer.
-        - columns from the erase layer cannot be retained.
-
-    Alternative names:
-        - QGIS: difference
-
-    Args:
-        input_path (PathLike): The file to erase from.
-        erase_path (PathLike): The file with the geometries to erase with.
-        output_path (PathLike): the file to write the result to
-        input_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        input_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
-        erase_layer (str, optional): erase layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): output layer name. Optional if the
-            file only contains one layer.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        subdivide_coords (int, optional): the input geometries will be subdivided to
-            parts with about ``subdivide_coords`` coordinates during processing which
-            can offer a large speed up for complex geometries. Subdividing can result in
-            extra collinear points being added to the boundaries of the output. If < 0,
-            no subdividing is applied. Defaults to 2000.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.erase")
-    logger.info(f"Start, on {input_path} with {erase_path} to {output_path}")
-    return _geoops_sql.erase(
-        input_path=Path(input_path),
-        erase_path=Path(erase_path),
-        output_path=Path(output_path),
-        input_layer=input_layer,
-        input_columns=input_columns,
-        erase_layer=erase_layer,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        subdivide_coords=subdivide_coords,
-        force=force,
-    )
-
-
-def export_by_location(
-    input_to_select_from_path: Union[str, "os.PathLike[Any]"],
-    input_to_compare_with_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    min_area_intersect: Optional[float] = None,
-    area_inters_column_name: Optional[str] = None,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input2_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Exports all intersecting features.
-
-    All features in ``input_to_select_from_path`` that intersect with any features in
-    ``input_to_compare_with_path`` are exported.
-
-    Alternative names:
-        - QGIS: extract by location
-
-    Args:
-        input_to_select_from_path (PathLike): the 1st input file
-        input_to_compare_with_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        min_area_intersect (float, optional): minimum area of the intersection.
-            Defaults to None.
-        area_inters_column_name (str, optional): column name of the intersect
-            area. If None, no area column is added. Defaults to None.
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        input2_columns (List[str], optional): NA.
-        output_layer (str, optional): output layer name. Optional if the
-            file only contains one layer.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.export_by_location")
-    logger.info(
-        f"export_by_location: select from {input_to_select_from_path} "
-        f"interacting with {input_to_compare_with_path} to {output_path}"
-    )
-    return _geoops_sql.export_by_location(
-        input_path=Path(input_to_select_from_path),
-        input_to_compare_with_path=Path(input_to_compare_with_path),
-        output_path=Path(output_path),
-        min_area_intersect=min_area_intersect,
-        area_inters_column_name=area_inters_column_name,
-        input_layer=input1_layer,
-        input_columns=input1_columns,
-        input_to_compare_with_layer=input2_layer,
-        output_layer=output_layer,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def export_by_distance(
-    input_to_select_from_path: Union[str, "os.PathLike[Any]"],
-    input_to_compare_with_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    max_distance: float,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input2_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    Exports all features within the distance specified.
-
-    Features in ``input_to_select_from_path`` that are within the distance specified of
-    any features in ``input_to_compare_with_path``.
-
-    Args:
-        input_to_select_from_path (PathLike): the 1st input file
-        input_to_compare_with_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        max_distance (float): maximum distance
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer.
-        output_layer (str, optional): output layer name. Optional if the
-            file only contains one layer.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.export_by_distance")
-    logger.info(
-        f"select from {input_to_select_from_path} within "
-        f"max_distance of {max_distance} from {input_to_compare_with_path} "
-        f"to {output_path}"
-    )
-    return _geoops_sql.export_by_distance(
-        input_to_select_from_path=Path(input_to_select_from_path),
-        input_to_compare_with_path=Path(input_to_compare_with_path),
-        output_path=Path(output_path),
-        max_distance=max_distance,
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input2_layer=input2_layer,
-        output_layer=output_layer,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def identity(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    subdivide_coords: int = 2000,
-    force: bool = False,
-):
-    r"""
-    Intersection of the input layers, but retain the non-intersecting parts of input1.
-
-    The result is the equivalent of an intersect between the two layers + layer
-    1 erased with layer 2.
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
-            to "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1\_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for ``input1_columns``, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2\_".
-        output_layer (str, optional): output layer name. If None, the ``output_path``
-            stem is used. Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        subdivide_coords (int, optional): the input geometries will be subdivided to
-            parts with about ``subdivide_coords`` coordinates during processing which
-            can offer a large speed up for complex geometries. Subdividing can result in
-            extra collinear points being added to the boundaries of the output. If < 0,
-            no subdividing is applied. Defaults to 2000.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.identity")
-    logger.info(f"Start, between {input1_path} and {input2_path} to {output_path}")
-    return _geoops_sql.identity(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        subdivide_coords=subdivide_coords,
-        force=force,
-    )
-
-
-def split(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    subdivide_coords: int = 2000,
-    force: bool = False,
-):
-    """
-    DEPRECATED: please use identity.
-    """
-    warnings.warn(
-        "split() is deprecated because it was renamed to identity(). "
-        "Will be removed in a future version",
-        FutureWarning,
-        stacklevel=2,
-    )
-    logger = logging.getLogger("geofileops.identity")
-    logger.info(f"Start,  between {input1_path} and {input2_path} to {output_path}")
-    return _geoops_sql.identity(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        subdivide_coords=subdivide_coords,
-        force=force,
-    )
-
-
-def intersect(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    """
-    DEPRECATED: please use intersection.
-    """
-    warnings.warn(  # pragma: no cover
-        "intersect() is deprecated because it was renamed intersection(). "
-        "Will be removed in a future version",
-        FutureWarning,
-        stacklevel=2,
-    )
-    return intersection(  # pragma: no cover
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        gridsize=gridsize,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def intersection(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    r"""
-    Calculate the pairwise intersection of alle features.
-
-    Alternative names:
-        - GeoPandas: overlay(how="intersection")
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
-            to "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1\_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for ``input1_columns``, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2\_".
-        output_layer (str, optional): output layer name. If None, the ``output_path``
-            stem is used. Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.intersection")
-    logger.info(f"Start, between {input1_path} and {input2_path} to {output_path}")
-    return _geoops_sql.intersection(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def join_by_location(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    spatial_relations_query: str = "intersects is True",
-    discard_nonmatching: bool = True,
-    min_area_intersect: Optional[float] = None,
-    area_inters_column_name: Optional[str] = None,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    r"""
-    Joins all features in input1 with all features in input2.
-
-    The output will contain the geometries of input1. The ``spatial_relations_query``
-    and ``min_area_intersect`` parameters will determine which geometries of input1 will
-    be matched with input2.
-
-    The ``spatial_relations_query`` is a filter string where you can use the following
-    "named spatial predicates": equals, touches, within, overlaps, crosses, intersects,
-    contains, covers, coveredby.
-
-    If you want even more control, you can also use "spatial masks" as defined by the
-    |DE-9IM| model.
-
-    Examples for valid ``spatial_relations_query`` values:
-
-        - "overlaps is True and contains is False"
-        - "(T*T***T** is True or 1*T***T** is True) and T*****FF* is False"
-
-
-    Alternative names:
-        - GeoPandas: sjoin
-        - ArcGIS: spatial join
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        spatial_relations_query (str, optional): a query that specifies the
-            spatial relations to match between the 2 layers.
-            Defaults to "intersects is True".
-        discard_nonmatching (bool, optional): True to only keep rows that
-            match with the spatial_relations_query. False to keep rows all
-            rows in the ``input1_layer`` (=left outer join). Defaults to True
-            (=inner join).
-        min_area_intersect (float, optional): minimum area of the intersection
-            to match. Defaults to None.
-        area_inters_column_name (str, optional): column name of the intersect
-            area. If None no area column is added. Defaults to None.
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
-            to "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1\_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for input1_columns, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2\_".
-        output_layer (str, optional): output layer name. If None, the output_path stem
-            is used. Defaults to None.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    .. |DE-9IM| raw:: html
-
-        <a href="https://en.wikipedia.org/wiki/DE-9IM" target="_blank">DE-9IM</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.join_by_location")
-    logger.info(f"select from {input1_path} joined with {input2_path} to {output_path}")
-    return _geoops_sql.join_by_location(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        spatial_relations_query=spatial_relations_query,
-        discard_nonmatching=discard_nonmatching,
-        min_area_intersect=min_area_intersect,
-        area_inters_column_name=area_inters_column_name,
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=False,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def join_nearest(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    nb_nearest: int,
-    distance: Optional[float] = None,
-    expand: Optional[bool] = None,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    r"""
-    Joins features of ``input1`` with the ``nb_nearest`` closest features of ``input2``.
-
-    In addition to the columns requested via the ``input*_columns`` parameters, the
-    following columns will be in the output file as well:
-        - pos (int): relative rank (sorted by distance): the closest item will be #1,
-          the second closest item will be #2 and so on.
-        - distance (float): if the dataset is in a planar (= projected) crs,
-          ``distance`` will be in the unit defined by the projection (meters, feet,
-          chains etc.). For a geographic dataset (longitude and latitude degrees),
-          ``distance`` will be in meters, with the most precise geodetic formulas being
-          applied.
-        - distance_crs (float): if the dataset is in a planar (= projected) crs,
-          ``distance_crs`` will be in the unit defined by the projection (meters, feet,
-          chains etc.). For a geographic dataset (longitude and latitude degrees),
-          ``distance_crs`` will be in angles. Only available with spatialite >= 5.1.
-
-    Note: if spatialite version >= 5.1 is used, parameters ``distance`` and ``expand``
-    are mandatory.
-
-    Args:
-        input1_path (PathLike): the input file to join to nb_nearest features.
-        input2_path (PathLike): the file where nb_nearest features are looked for.
-        output_path (PathLike): the file to write the result to
-        nb_nearest (int): the number of nearest features from input 2 to join
-            to input1.
-        distance (float): maximum distance to search for the nearest items. If
-            ``expand`` is True, this is the initial search distance, which will be
-            gradually expanded (doubled) till ``nb_nearest`` are found. For optimal
-            performance, it is important to choose the typical value that will be needed
-            to find ``nb_nearest`` items. If ``distance`` is too large, performance can
-            be bad. Parameter is only relevant if spatialite version >= 5.1 is used.
-        expand (bool): True to keep searching till ``nb_nearest`` items are found. If
-            False, only items found within ``distance`` are returned (False is only
-            supported if spatialite version >= 5.1 is used).
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
-            to "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1\_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for ``input1_columns``, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2\_".
-        output_layer (str, optional): output layer name. If None, the ``output_path``
-            stem is used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-    """
-    logger = logging.getLogger("geofileops.join_nearest")
-    logger.info(f"select from {input1_path} joined with {input2_path} to {output_path}")
-    return _geoops_sql.join_nearest(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        nb_nearest=nb_nearest,
-        distance=distance,
-        expand=expand,
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=False,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def select_two_layers(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    sql_stmt: str,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = 1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    r'''
-    Execute a SELECT SQL statement on the input files.
-
-    The ``sql_stmt`` must be in SQLite dialect and can contain placeholders that will be
-    replaced automatically. More details can be found in the notes and examples below.
-
-    The result is written to the output file specified.
-
-    Args:
-        input1_path (PathLike): the 1st input file.
-        input2_path (PathLike): the 2nd input file.
-        output_path (PathLike): the file to write the result to.
-        sql_stmt (str): the SELECT SQL statement to be executed. Must be in SQLite
-            dialect.
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain if one of the
-            {layer1\_columns_...} placeholders is used in ``sql_stmt``. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
-            to "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1\_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): list of columns to retain if one of the
-            {layer2\_columns_...} placeholders is used in ``sql_stmt``. If None is
-            specified, all columns are selected. As explained for ``input1_columns``, it
-            is also possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2\_".
-        output_layer (str, optional): output layer name. If None, the ``output_path``
-            stem is used. Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        force_output_geometrytype (GeometryType, optional): The output geometry
-            type to force. Defaults to None, and then the geometry type of the
-            input1 layer is used.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use. If -1, all
-            available cores are used. Defaults to 1. If ``nb_parallel`` != 1, make sure
-            your query still returns correct results if it is executed per batch of rows
-            instead of in one go on the entire layer.
-        batchsize (int, optional): indicative number of rows to process per batch.
-            A smaller batch size, possibly in combination with a smaller
-            ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    Notes:
-        By convention, the ``sql_stmt`` can contain following placeholders that
-        will be automatically replaced for you:
-
-        * {input1_layer}: name of input layer 1
-        * {input1_geometrycolumn}: name of input geometry column 1
-        * {layer1_columns_prefix_str}: komma seperated columns of
-          layer 1, prefixed with "layer1"
-        * {layer1_columns_prefix_alias_str}: komma seperated columns of
-          layer 1, prefixed with "layer1" and with column name aliases
-        * {layer1_columns_from_subselect_str}: komma seperated columns of
-          layer 1, prefixed with "sub"
-        * {input1_databasename}: the database alias for input 1
-        * {input2_layer}: name of input layer 1
-        * {input2_geometrycolumn}: name of input geometry column 2
-        * {layer2_columns_prefix_str}: komma seperated columns of
-          layer 2, prefixed with "layer2"
-        * {layer2_columns_prefix_alias_str}: komma seperated columns of
-          layer 2, prefixed with "layer2" and with column name aliases
-        * {layer2_columns_from_subselect_str}: komma seperated columns of
-          layer 2, prefixed with "sub"
-        * {layer2_columns_prefix_alias_null_str}: komma seperated columns of
-          layer 2, but with NULL for all values and with column aliases
-        * {input2_databasename}: the database alias for input 2
-        * {batch_filter}: the filter to be applied per batch when using parallel
-          processing
-
-        Example: left outer join all features in input1 layer with all rows
-        in input2 on join_id.
-
-        .. code-block:: python
-
-            import geofileops as gfo
-
-            minimum_area = 100
-            sql_stmt = f"""
-                SELECT layer1.{{input1_geometrycolumn}}
-                      {{layer1_columns_prefix_alias_str}}
-                      {{layer2_columns_prefix_alias_str}}
-                  FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                  LEFT OUTER JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                       ON layer1.join_id = layer2.join_id
-                 WHERE 1=1
-                   {{batch_filter}}
-                   AND ST_Area(layer1.{{input1_geometrycolumn}}) > {minimum_area}
-            """
-            gfo.select_two_layers(
-                input1_path=...,
-                input2_path=...,
-                output_path=...,
-                sql_stmt=sql_stmt,
-            )
-
-        Some important remarks:
-
-        * Because some SQL statements won't give the same result when parallelized
-          (eg. when using a group by statement), ``nb_parallel`` is 1 by default.
-          If you do want to use parallel processing, specify ``nb_parallel`` + make
-          sure to include the placeholder {batch_filter} in your ``sql_stmt``.
-          This placeholder will be replaced with a filter of the form
-          "AND rowid >= x AND rowid < y".
-        * Table names are best double quoted as in the example, because some
-          characters are otherwise not supported in the table name, eg. "-".
-        * When using supported placeholders, make sure you give the tables you
-          select from the appropriate table aliases (layer1, layer2).
-        * Besides the standard sqlite SQL syntacs, you can use the spatialite
-          functions as documented here: |spatialite_reference_link|
-        * It is supported to use attribute tables (= table without geometry column)
-          as input layers and/or not to include the geometry column in the selected
-          columns. Note though that if the column placeholders are used (e.g.
-          {layer1_columns_prefix_str}), they will start with a "," and if no column
-          precedes it the SQL statement will be invalid.
-
-    Examples:
-        An ideal place to get inspiration to write you own advanced queries
-        is in the following source code file: |geofileops_sql_link|.
-
-        Additionally, there are some examples listed here that highlight
-        other features/possibilities.
-
-        **Join nearest features with filter**
-
-        To join nearest features, geofileops has a specific :meth:`~join_nearest`
-        function. This provides a fast way to find the nearest feature(s) if there
-        doesn't need to be a filter on the features to be found.
-
-        For a use case where for each element in layer 1, you want to find the nearest
-        features in layer 2 while applying a filter that eliminates many kandidates,
-        the query below will be a better solution.
-
-        Note: Using ``MIN(ST_Distance(layer1.geom, layer2.geom)`` sometimes seems to
-        round the distances calculated slightly resulting in some nearest features not
-        being found. Using ``RANK`` avoids this issue.
-
-        .. code-block:: python
-
-            sql_stmt = f"""
-                WITH join_with_dist AS (
-                    SELECT layer1.{{input1_geometrycolumn}} AS geom
-                          {{layer1_columns_prefix_alias_str}}
-                          {{layer2_columns_prefix_alias_str}}
-                          ,ST_Distance(
-                                layer1.{{input1_geometrycolumn}},
-                                layer2.{{input2_geometrycolumn}}
-                           ) AS distance
-                          ,RANK() OVER ( PARTITION BY layer1.rowid ORDER BY ST_Distance(
-                                            layer1.{{input1_geometrycolumn}},
-                                            layer2.{{input2_geometrycolumn}}
-                                       )
-                           ) AS pos
-                      FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                      JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                        ON layer1.join_id = layer2.join_id
-                     WHERE 1=1
-                       {{batch_filter}}
-                )
-                SELECT *
-                  FROM join_with_dist jwd
-                 WHERE pos = 1
-            """
-
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    .. |geofileops_sql_link| raw:: html
-
-        <a href="https://github.com/geofileops/geofileops/blob/main/geofileops/util/geofileops_sql.py" target="_blank">geofileops_sql.py</a>
-
-    '''  # noqa: E501
-    logger = logging.getLogger("geofileops.select_two_layers")
-    logger.info(f"select from {input1_path} and {input2_path} to {output_path}")
-    return _geoops_sql.select_two_layers(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        sql_stmt=sql_stmt,
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def symmetric_difference(
-    input1_path: Union[str, "os.PathLike[Any]"],
-    input2_path: Union[str, "os.PathLike[Any]"],
-    output_path: Union[str, "os.PathLike[Any]"],
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    subdivide_coords: int = 2000,
-    force: bool = False,
-):
-    r"""
-    Calculates the "symmetric difference" of the two input layers.
-
-    Alternative names:
-        - GeoPandas: overlay(how="symmetric_difference")
-        - QGIS, ArcMap: symmetrical difference
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg. to
-            "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1\_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for input1_columns, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2\_".
-        output_layer (str, optional): output layer name. If None, the ``output_path``
-            stem is used. Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. explodecollections. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        subdivide_coords (int, optional): the input geometries will be subdivided to
-            parts with about ``subdivide_coords`` coordinates during processing which
-            can offer a large speed up for complex geometries. Subdividing can result in
-            extra collinear points being added to the boundaries of the output. If < 0,
-            no subdividing is applied. Defaults to 2000.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.symmetric_difference")
-    logger.info(
-        f"Start, with input1: {input1_path}, "
-        f"input2 {input2_path}, output: {output_path}"
-    )
-    return _geoops_sql.symmetric_difference(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        subdivide_coords=subdivide_coords,
-        force=force,
-    )
-
-
-def union(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    subdivide_coords: int = 2000,
-    force: bool = False,
-):
-    r"""
-    Calculates the pairwise "union" of the two input layers.
-
-    Alternative names:
-        - GeoPandas: overlay(how="union")
-
-    Args:
-        input1_path (PathLike): the 1st input file
-        input2_path (PathLike): the 2nd input file
-        output_path (PathLike): the file to write the result to
-        input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input1_columns (List[str], optional): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
-            to "fid_1". Defaults to None.
-        input1_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l1\_".
-        input2_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        input2_columns (List[str], optional): columns to select. If None is specified,
-            all columns are selected. As explained for ``input1_columns``, it is also
-            possible to specify "fid". Defaults to None.
-        input2_columns_prefix (str, optional): prefix to use in the column aliases.
-            Defaults to "l2\_".
-        output_layer (str, optional): output layer name. If None, the ``output_path``
-            stem is used. Defaults to None.
-        explodecollections (bool, optional): True to convert all multi-geometries to
-            singular ones after the dissolve. Defaults to False.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): SQL filter to apply after all other processing,
-            including e.g. ``explodecollections``. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): the number of parallel processes to use.
-            Defaults to -1: use all available CPUs.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller ``nb_parallel``, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        subdivide_coords (int, optional): the input geometries will be subdivided to
-            parts with about ``subdivide_coords`` coordinates during processing which
-            can offer a large speed up for complex geometries. Subdividing can result in
-            extra collinear points being added to the boundaries of the output. If < 0,
-            no subdividing is applied. Defaults to 2000.
-        force (bool, optional): overwrite existing output file(s).
-            Defaults to False.
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    logger = logging.getLogger("geofileops.union")
-    logger.info(
-        f"Start, with input1: {input1_path}, input2: {input2_path}, output: "
-        f"{output_path}"
-    )
-    return _geoops_sql.union(
-        input1_path=Path(input1_path),
-        input2_path=Path(input2_path),
-        output_path=Path(output_path),
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        subdivide_coords=subdivide_coords,
-        force=force,
-    )
+"""
+Module exposing all supported operations on geometries in geofiles.
+"""
+
+from datetime import datetime
+import logging
+import logging.config
+from pathlib import Path
+import shutil
+from typing import Any, Callable, List, Literal, Optional, Tuple, Union, TYPE_CHECKING
+import warnings
+
+from pygeoops import GeometryType
+
+from geofileops._compat import SPATIALITE_GTE_51
+from geofileops import fileops
+from geofileops.util import _geofileinfo
+from geofileops.util import _geoops_gpd
+from geofileops.util import _geoops_sql
+from geofileops.util import _geoops_ogr
+from geofileops.util import _io_util
+from geofileops.util import _sqlite_util
+from geofileops.util._geometry_util import (
+    BufferEndCapStyle,
+    BufferJoinStyle,
+    SimplifyAlgorithm,
+)
+
+if TYPE_CHECKING:
+    import os
+
+logger = logging.getLogger(__name__)
+
+
+def dissolve_within_distance(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    distance: float,
+    gridsize: float,
+    close_internal_gaps: bool = False,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Dissolve geometries that are within the distance specified.
+
+    The output layer will contain the dissolved geometries where all gaps between the
+    input geometries up to ``distance`` are closed.
+
+    Notes:
+      - Only tested on polygon input.
+      - Gaps between the individual polygons of multipolygon input features will also
+        be closed.
+      - The polygons in the output file are exploded to simple geometries.
+      - No attributes from the input layer are retained.
+      - If ``close_internal_gaps`` is False, the default, a ``gridsize`` > 0
+        (E.g. 0.000001) should be specified, otherwise some input boundary gaps could
+        still be closed due to rounding side effects.
+
+    Alternative names:
+      - ArcMap: aggregate_polygons (similar functionality)
+      - Keywords: merge, dissolve, aggregate, snap, close gaps, union
+
+    Args:
+        input_path (PathLike): the input file.
+        output_path (PathLike): the file to write the result to.
+        distance (float): the maximum distance between geometries to be dissolved.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. If ``close_boundary_gaps`` is False, the default, a
+            ``gridsize`` > 0 (E.g. 0.000001) should be specified, otherwise some
+            boundary gaps in the input geometries could still be closed due to rounding
+            side effects.
+        close_internal_gaps (bool, optional): also close gaps, strips or holes in the
+            input geometries that are narrower than the ``distance`` specified. E.g.
+            small holes, narrow strips starting at the boundary,... Defaults to False.
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    input_path = Path(input_path)
+    output_path = Path(output_path)
+
+    start_time = datetime.now()
+    operation_name = "dissolve_within_distance"
+    logger = logging.getLogger(f"geofileops.{operation_name}")
+    nb_steps = 4
+    if not close_internal_gaps:
+        # 3 extra steps if boundary gaps not to be closed.
+        nb_steps += 3
+
+    # Already check here if it is useful to continue
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop, output exists already {output_path}")
+            return
+        else:
+            fileops.remove(output_path)
+
+    tempdir = _io_util.create_tempdir(f"geofileops/{operation_name}")
+    try:
+        # First dissolve the input.
+        #
+        # Note: this reduces the complexity of operations to be executed later on.
+        # Note2: this already applies the gridsize, which needs to be applied anyway to
+        # avoid issues when determining the addedpieces_1neighbour later on.
+        logger.info(f"Start, with input file {input_path}")
+        step = 1
+        logger.info(f"Step {step} of {nb_steps}")
+        diss_path = tempdir / "100_diss.gpkg"
+        _geoops_gpd.dissolve(
+            input_path=input_path,
+            output_path=diss_path,
+            explodecollections=True,
+            input_layer=input_layer,
+            gridsize=gridsize,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            operation_prefix=f"{operation_name}-",
+        )
+
+        # Positive buffer of distance / 2 to close all gaps.
+        #
+        # Note: gridsize is not applied to preserve all possible accuracy for these
+        # temporary boundaries, otherwise the polygons are sometimes enlarged slightly,
+        # which isn't wanted + creates issues when determining the
+        # addedpieces_1neighbour later on.
+        step += 1
+        logger.info(f"Step {step} of {nb_steps}")
+        buff_path = tempdir / "110_diss_bufp.gpkg"
+        _geoops_gpd.buffer(
+            input_path=diss_path,
+            output_path=buff_path,
+            distance=distance / 2,
+            endcap_style=BufferEndCapStyle.SQUARE,
+            join_style=BufferJoinStyle.MITRE,
+            mitre_limit=1.25,
+            # gridsize=gridsize,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            operation_prefix=f"{operation_name}-",
+        )
+
+        # Dissolve the buffered input
+        #
+        # Note: gridsize is not applied to preserve all possible accuracy for these
+        # temporary boundaries, otherwise the polygons are sometimes enlarged slightly,
+        # which isn't wanted + creates issues when determining the
+        # addedpieces_1neighbour later on.
+        step += 1
+        logger.info(f"Step {step} of {nb_steps}")
+        buff_diss_path = tempdir / "120_diss_bufp_diss.gpkg"
+        _geoops_gpd.dissolve(
+            input_path=buff_path,
+            output_path=buff_diss_path,
+            explodecollections=True,
+            # gridsize=gridsize,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            operation_prefix=f"{operation_name}-",
+        )
+
+        # Negative buffer to get back to the borders of the input geometries
+        # Use a larger mitre limit, otherwise there are a lot of small triangles that
+        # don't dissappear again.
+        step += 1
+        logger.info(f"Step {step} of {nb_steps}")
+        buff_diss_bufm_path = tempdir / "130_diss_bufp_diss_bufm.gpkg"
+        _geoops_gpd.buffer(
+            input_path=buff_diss_path,
+            output_path=buff_diss_bufm_path,
+            distance=-(distance / 2),
+            endcap_style=BufferEndCapStyle.SQUARE,
+            join_style=BufferJoinStyle.MITRE,
+            mitre_limit=2,
+            gridsize=gridsize,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            operation_prefix=f"{operation_name}-",
+        )
+
+        # Determine which parts that were added were actually gaps within 'distance' in
+        # the original polygons, so they can be removed again.
+
+        # Determine all pieces added to the input in the process above.
+        step += 1
+        logger.info(f"Step {step} of {nb_steps}")
+        added_pieces_path = tempdir / "200_addedpieces.gpkg"
+        _geoops_sql.erase(
+            input_path=buff_diss_bufm_path,
+            erase_path=diss_path,
+            output_path=added_pieces_path,
+            explodecollections=True,
+            gridsize=gridsize,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            operation_prefix=f"{operation_name}-",
+        )
+
+        # Build a filter to select the pieces that we want to erase again from the
+        # result because they were incorrectly added.
+        # The filter will depend on input parameters.
+        if close_internal_gaps:
+            # True, so also gaps in the original input boundaries should be closed.
+            # This means that in theory all pieces can be retained, but in practice
+            # there are some cases where the above algorithm adds unwanted area, so that
+            # needs to be erased again.
+            #
+            # Parameters that indicate that added pieces won't need to be erased:
+            #   - large areas (>= distance²) seem OK.
+            #   - if > 1 neighbour, seems OK.
+            #
+            # For all pieces that don't comply to the above, the following parameters
+            # indicate that they need to be selected to erase them:
+            #   - pieces can be very narrow slivers. E.g. alongside a long boundary with
+            #     a small bend, probably due to rounding side effects in the +/- buffer.
+            #   - pieces can be spikes. E.g. when a "road" of ~ 'distance' width is not
+            #     filled up between two input geometries has a bend. Depending on the
+            #     angle, the mitre of the negative buffer can leave a spike in place.
+            pieces_to_erase_filter = f"""
+                neighbours_count_distinct <= 1
+                AND geom_area < {distance} * {distance}
+                AND neighbours_perimeter/2 + neighbours_length <= 0.8 * geom_perimeter
+            """
+        else:
+            # False, so we want to keep all pieces that intersect with only 1 neighbour
+            # in the input, so they can be remove again from the result.
+            pieces_to_erase_filter = "neighbours_count_distinct <= 1"
+
+        # Notes:
+        # - The conversion to json followed by extraction from json allows to use a
+        #   correlated subquery to return multiple columns. Joining the subquery gives
+        #   very bad performance.
+        # - Every level of nesting of SQL queries is needed to get good performance, in
+        #   combination with "LIMIT -1 OFFSET 0" to avoid the subquery flattening.
+        #   Flattening e.g. "geom IS NOT NULL" leads to geom operation to be calculated
+        #   twice!
+        input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+        input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+        sql_stmt = f"""
+            WITH neighbours AS (
+                SELECT layer1_sub.rowid AS layer1_rowid
+                      ,layer2_sub.rowid AS layer2_rowid
+                      ,ST_Intersection(
+                          layer1_sub.{{input1_geometrycolumn}},
+                          layer2_sub.{{input2_geometrycolumn}}
+                       ) AS intersect_geom
+                  FROM {{input1_databasename}}."{{input1_layer}}" layer1_sub
+                  JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                    ON layer1_sub.rowid = layer1tree.id
+                  JOIN {{input2_databasename}}."{{input2_layer}}" layer2_sub
+                  JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                    ON layer2_sub.rowid = layer2tree.id
+                 WHERE 1=1
+                   AND layer1tree.minx <= layer2tree.maxx
+                   AND layer1tree.maxx >= layer2tree.minx
+                   AND layer1tree.miny <= layer2tree.maxy
+                   AND layer1tree.maxy >= layer2tree.miny
+                   AND ST_Intersects(
+                          layer1_sub.{{input1_geometrycolumn}},
+                          layer2_sub.{{input2_geometrycolumn}}) = 1
+              )
+            SELECT * FROM (
+              SELECT geom
+                    ,ST_Perimeter(geom) AS geom_perimeter
+                    ,ST_Area(geom) AS geom_area
+                    ,neighbours_json ->> '$.nb_distinct' AS neighbours_count_distinct
+                    ,neighbours_json ->> '$.length' AS neighbours_length
+                    ,neighbours_json ->> '$.perimeter' AS neighbours_perimeter
+                FROM (
+                  SELECT layer1.{{input1_geometrycolumn}} AS geom
+                        ,( SELECT json_object(
+                                    'nb_distinct', COUNT(DISTINCT layer2_rowid),
+                                    'length', SUM(ST_Length(intersect_geom)),
+                                    'perimeter', SUM(ST_Perimeter(intersect_geom))
+                                  )
+                             FROM neighbours
+                            WHERE neighbours.layer1_rowid = layer1.rowid
+                              AND neighbours.intersect_geom IS NOT NULL
+                            GROUP BY neighbours.layer1_rowid
+                            LIMIT -1 OFFSET 0
+                         ) AS neighbours_json
+                    FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                   WHERE 1=1
+                     {{batch_filter}}
+                   LIMIT -1 OFFSET 0
+                  )
+                  LIMIT -1 OFFSET 0
+               )
+             WHERE geom IS NOT NULL
+               AND ({pieces_to_erase_filter})
+        """
+
+        step += 1
+        logger.info(f"Step {step} of {nb_steps}")
+        added_pieces_to_be_erased_input = tempdir / "210_addedpieces_to_be_erased.gpkg"
+        _geoops_sql.select_two_layers(
+            input1_path=added_pieces_path,
+            input2_path=input_path,
+            output_path=added_pieces_to_be_erased_input,
+            sql_stmt=sql_stmt,
+            input2_layer=input_layer,
+            # gridsize=gridsize,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            operation_prefix=f"{operation_name}-",
+        )
+
+        step += 1
+        logger.info(f"Step {step} of {nb_steps}")
+        _geoops_sql.erase(
+            input_path=buff_diss_bufm_path,
+            erase_path=added_pieces_to_be_erased_input,
+            output_path=output_path,
+            output_layer=output_layer,
+            explodecollections=True,
+            gridsize=gridsize,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+            operation_prefix=f"{operation_name}-",
+        )
+
+    finally:
+        shutil.rmtree(tempdir, ignore_errors=True)
+
+    logger.info(f"Ready, took {datetime.now()-start_time}")
+
+
+def apply(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    func: Callable[[Any], Any],
+    only_geom_input: bool = True,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Union[GeometryType, str, None] = None,
+    gridsize: float = 0.0,
+    keep_empty_geoms: Optional[bool] = None,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Apply a python lambda function on the geometry column of the input file.
+
+    The result is written to the output file specified.
+
+    If ``explodecollections`` is False and the input and output file type is GeoPackage,
+    the fid will be preserved. In other cases this will typically not be the case.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        func (Callable): lambda function to apply to the geometry column.
+        only_geom_input (bool, optional): If True, only the geometry
+            column is available. If False, the entire row is input.
+            Remark: when False, the operation is 50% slower. Defaults to True.
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        force_output_geometrytype (GeometryType, optional): The output geometry type to
+            force. If None, a best-effort guess is made and will always result in a
+            multi-type. Defaults to None.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
+            in the output. Defaults to False.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    Examples:
+        This example shows the basic usage of ``gfo.apply``:
+
+        .. code-block:: python
+
+            import geofileops as gfo
+
+            gfo.apply(
+                input_path=...,
+                output_path=...,
+                func=lambda geom: pygeoops.remove_inner_rings(geom, min_area_to_keep=1),
+            )
+
+        If you need to use the contents of other columns in your lambda function, you can
+        call ``gfo.apply`` like this:
+
+        .. code-block:: python
+
+            import geofileops as gfo
+
+            gfo.apply(
+                input_path=...,
+                output_path=...,
+                func=lambda row: pygeoops.remove_inner_rings(
+                    row.geometry, min_area_to_keep=row.min_area_to_keep
+                ),
+                only_geom_input=False,
+            )
+
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.apply")
+    logger.info(f"Start on {input_path}")
+
+    return _geoops_gpd.apply(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        func=func,
+        only_geom_input=only_geom_input,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        gridsize=gridsize,
+        keep_empty_geoms=keep_empty_geoms,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def buffer(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    distance: float,
+    quadrantsegments: int = 5,
+    endcap_style: BufferEndCapStyle = BufferEndCapStyle.ROUND,
+    join_style: BufferJoinStyle = BufferJoinStyle.ROUND,
+    mitre_limit: float = 5.0,
+    single_sided: bool = False,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    keep_empty_geoms: Optional[bool] = None,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Applies a buffer operation on geometry column of the input file.
+
+    The result is written to the output file specified.
+
+    If ``explodecollections`` is False and the input and output file type is GeoPackage,
+    the fid will be preserved. In other cases this will typically not be the case.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        distance (float): the buffer size to apply. In projected coordinate
+            systems this is typically in meter, in geodetic systems this is
+            typically in degrees.
+        quadrantsegments (int): the number of points a quadrant needs to be
+            approximated with for rounded styles. Defaults to 5.
+        endcap_style (BufferEndCapStyle, optional): buffer style to use for a
+            point or the end points of a line. Defaults to ROUND.
+
+              * ROUND: for points and lines the ends are buffered rounded.
+              * FLAT: a point stays a point, a buffered line will end flat
+                at the end points
+              * SQUARE: a point becomes a square, a buffered line will end
+                flat at the end points, but elongated by ``distance``
+        join_style (BufferJoinStyle, optional): buffer style to use for
+            corners in a line or a polygon boundary. Defaults to ROUND.
+
+              * ROUND: corners in the result are rounded
+              * MITRE: corners in the result are sharp
+              * BEVEL: are flattened
+        mitre_limit (float, optional): in case of ``join_style`` MITRE, if the
+            spiky result for a sharp angle becomes longer than this ratio limit, it
+            is "beveled" using this maximum ratio. Defaults to 5.0.
+        single_sided (bool, optional): only one side of the line is buffered,
+            if distance is negative, the left side, if distance is positive,
+            the right hand side. Only relevant for line geometries.
+            Defaults to False.
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
+            in the output. Defaults to False.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    Notes:
+        Using the different buffer style option parameters you can control how the
+        buffer is created:
+
+        - **quadrantsegments** *(int)*
+
+        .. list-table::
+            :header-rows: 1
+
+            * - 5 (default)
+              - 2
+              - 1
+            * - |buffer_quadrantsegm_5|
+              - |buffer_quadrantsegm_2|
+              - |buffer_quadrantsegm_1|
+
+        - **endcap_style** *(BufferEndCapStyle)*
+
+        .. list-table::
+            :header-rows: 1
+
+            * - ROUND (default)
+              - FLAT
+              - SQUARE
+            * - |buffer_endcap_round|
+              - |buffer_endcap_flat|
+              - |buffer_endcap_square|
+
+        - **join_style** *(BufferJoinStyle)*
+
+        .. list-table::
+            :header-rows: 1
+
+            * - ROUND (default)
+              - MITRE
+              - BEVEL
+            * - |buffer_joinstyle_round|
+              - |buffer_joinstyle_mitre|
+              - |buffer_joinstyle_bevel|
+
+        - **mitre** *(float)*
+
+        .. list-table::
+            :header-rows: 1
+
+            * - 5.0 (default)
+              - 2.5
+              - 1.0
+            * - |buffer_mitre_50|
+              - |buffer_mitre_25|
+              - |buffer_mitre_10|
+
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite</a>
+
+    .. |buffer_quadrantsegm_5| image:: ../_static/images/buffer_quadrantsegments_5.png
+        :alt: Buffer with quadrantsegments=5
+    .. |buffer_quadrantsegm_2| image:: ../_static/images/buffer_quadrantsegments_2.png
+        :alt: Buffer with quadrantsegments=2
+    .. |buffer_quadrantsegm_1| image:: ../_static/images/buffer_quadrantsegments_1.png
+        :alt: Buffer with quadrantsegments=1
+    .. |buffer_endcap_round| image:: ../_static/images/buffer_endcap_round.png
+        :alt: Buffer with endcap_style=BufferEndCapStyle.ROUND (default)
+    .. |buffer_endcap_flat| image:: ../_static/images/buffer_endcap_flat.png
+        :alt: Buffer with endcap_style=BufferEndCapStyle.FLAT
+    .. |buffer_endcap_square| image:: ../_static/images/buffer_endcap_square.png
+        :alt: Buffer with endcap_style=BufferEndCapStyle.SQUARE
+    .. |buffer_joinstyle_round| image:: ../_static/images/buffer_joinstyle_round.png
+        :alt: Buffer with joinstyle=BufferJoinStyle.ROUND (default)
+    .. |buffer_joinstyle_mitre| image:: ../_static/images/buffer_joinstyle_mitre.png
+        :alt: Buffer with joinstyle=BufferJoinStyle.MITRE
+    .. |buffer_joinstyle_bevel| image:: ../_static/images/buffer_joinstyle_bevel.png
+        :alt: Buffer with joinstyle=BufferJoinStyle.BEVEL
+    .. |buffer_mitre_50| image:: ../_static/images/buffer_mitre_50.png
+        :alt: Buffer with mitre=5.0
+    .. |buffer_mitre_25| image:: ../_static/images/buffer_mitre_25.png
+        :alt: Buffer with mitre=2.5
+    .. |buffer_mitre_10| image:: ../_static/images/buffer_mitre_10.png
+        :alt: Buffer with mitre=1.0
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.buffer")
+    logger.info(
+        f"Start, on {input_path} "
+        f"(distance: {distance}, quadrantsegments: {quadrantsegments})"
+    )
+
+    if (
+        endcap_style == BufferEndCapStyle.ROUND
+        and join_style == BufferJoinStyle.ROUND
+        and single_sided is False
+    ):
+        # If default buffer options for spatialite, use the faster SQL version
+        return _geoops_sql.buffer(
+            input_path=Path(input_path),
+            output_path=Path(output_path),
+            distance=distance,
+            quadrantsegments=quadrantsegments,
+            input_layer=input_layer,
+            output_layer=output_layer,
+            columns=columns,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            keep_empty_geoms=keep_empty_geoms,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+        )
+    else:
+        # If special buffer options, use geopandas version
+        return _geoops_gpd.buffer(
+            input_path=Path(input_path),
+            output_path=Path(output_path),
+            distance=distance,
+            quadrantsegments=quadrantsegments,
+            endcap_style=endcap_style,
+            join_style=join_style,
+            mitre_limit=mitre_limit,
+            single_sided=single_sided,
+            input_layer=input_layer,
+            output_layer=output_layer,
+            columns=columns,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            keep_empty_geoms=keep_empty_geoms,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+        )
+
+
+def clip_by_geometry(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    clip_geometry: Union[Tuple[float, float, float, float], str],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    """
+    Clip all geometries in the imput file by the geometry provided.
+
+    If ``explodecollections`` is False and the input and output file type is GeoPackage,
+    the fid will be preserved. In other cases this will typically not be the case.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        clip_geometry (Union[Tuple[float, float, float, float], str]): the bounds
+            or WKT geometry to clip with.
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger = logging.getLogger("geofileops.clip_by_geometry")
+    logger.info(f"Start, on {input_path}")
+    return _geoops_ogr.clip_by_geometry(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        clip_geometry=clip_geometry,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force=force,
+    )
+
+
+def convexhull(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    keep_empty_geoms: Optional[bool] = None,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Applies a convexhull operation on the input file.
+
+    The result is written to the output file specified.
+
+    If ``explodecollections`` is False and the input and output file type is GeoPackage,
+    the fid will be preserved. In other cases this will typically not be the case.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
+            in the output. Defaults to False.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.convexhull")
+    logger.info(f"Start, on {input_path}")
+
+    return _geoops_sql.convexhull(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        gridsize=gridsize,
+        keep_empty_geoms=keep_empty_geoms,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def delete_duplicate_geometries(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    keep_empty_geoms: Optional[bool] = None,
+    where_post: Optional[str] = None,
+    force: bool = False,
+):
+    """
+    Copy all rows to the output file, except for duplicate geometries.
+
+    If ``explodecollections`` is False and the input and output file type is GeoPackage,
+    the fid will be preserved. In other cases this will typically not be the case.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
+            in the output. Defaults to False.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.delete_duplicate_geometries")
+    logger.info(f"Start, on {input_path}")
+
+    return _geoops_sql.delete_duplicate_geometries(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        keep_empty_geoms=keep_empty_geoms,
+        where_post=where_post,
+        force=force,
+    )
+
+
+def dissolve(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    explodecollections: bool,
+    groupby_columns: Union[List[str], str, None] = None,
+    agg_columns: Optional[dict] = None,
+    tiles_path: Union[str, "os.PathLike[Any]", None] = None,
+    nb_squarish_tiles: int = 1,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Applies a dissolve operation on the input file.
+
+    If columns are specified with ``groupby_columns``, the data is first grouped
+    on those columns before the geometries are merged.
+
+    Data in other columns can be retained in the output by specifying the
+    ``agg_columns`` parameter.
+
+    Because the input layer is tiled using a grid to speed up, extra collinear points
+    will typically be present in the output geometries. Rows with null or empty
+    geometries are ignored.
+
+    This is an example of how data in the columns that isn't grouped on can be
+    aggregated to be added to the output file:
+
+    .. code-block:: python
+
+        import geofileops as gfo
+
+        gfo.dissolve(
+            input_path=...,
+            output_path=...,
+            groupby_columns=["cropgroup"],
+            agg_columns={
+                "columns": [
+                    {"column": "crop", "agg": "max", "as": "crop_max"},
+                    {"column": "crop", "agg": "count", "as": "crop_count"},
+                    {
+                        "column": "crop",
+                        "agg": "concat",
+                        "as": "crop_concat",
+                        "distinct": True,
+                        "sep": ";",
+                    },
+                    {"column": "area", "agg": "mean", "as": "area_mean"},
+                ]
+            },
+            explodecollections=False,
+        )
+
+    The following example will save all detailed data for the columns
+    "crop_label" and "area" in the output file. The detailed data is encoded
+    per group/row in a "json" text field. Shapefiles only support up to 254
+    characters in a text field, so this format won't be very suited as output
+    format for this option.
+
+    .. code-block:: python
+
+        import geofileops as gfo
+
+        gfo.dissolve(
+            input_path=...,
+            output_path=...,
+            groupby_columns=["cropgroup"],
+            agg_columns={"json": ["crop", "area"]},
+            explodecollections=False,
+        )
+
+    This results in this type of output:
+    ::
+
+        cropgroup  json
+        Grasses    ["{"crop":"Meadow","area":1290,"fid_orig":5}","{"crop":"Pasture",...
+        Maize      ["{"crop":"Silo","area":3889.29,"fid_orig":2}","{"crop":"Fodder",...
+
+    If the output is tiled (by specifying ``tiles_path`` or ``nb_squarish_tiles`` > 1),
+    the result will be clipped on the output tiles and the tile borders are
+    never crossed.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        explodecollections (bool): True to output only simple geometries. If
+            False, this can result in huge geometries for large files,
+            especially if no ``groupby_columns`` are specified.
+        groupby_columns (Union[List[str], str], optional): columns (case insensitive) to
+            group on while aggregating. Defaults to None, resulting in a spatial union
+            of all geometries that touch.
+        agg_columns (dict, optional): columns to aggregate based on
+            the groupings by groupby columns. Depending on the top-level key
+            value of the dict, the output for the aggregation is different:
+
+                - "json": dump all data per group to one "json" column. The
+                  value can be None (= all columns) or a list of columns to include.
+                - "columns": aggregate to seperate columns. The value should
+                  be a list of dicts with the following keys:
+
+                    - "column": column name (case insensitive) in the input file. In
+                      addition to standard columns, it is also possible to specify
+                      "fid", a unique index available in all input files.
+                    - "agg": aggregation to use:
+
+                        - count: the number of values in the group
+                        - sum: the sum of the values in the group
+                        - mean: the mean/average of the values in the group
+                        - min: the minimum value in the group
+                        - max: the maximum value in the group
+                        - median: the median value in the group
+                        - concat: all non-null values in the group concatenated (in
+                          arbitrary order)
+
+                    - "as": column name in the output file. Note: using "fid" as alias
+                      is not recommended: it can cause errors or odd behaviour.
+                    - "distinct" (optional): True to distinct the values before
+                      aggregation.
+                    - "sep" (optional): the separator to use for concat. Default: ",".
+
+        tiles_path (PathLike, optional): a path to a geofile containing tiles.
+            If specified, the output will be dissolved/unioned only within the
+            tiles provided.
+            Can be used to avoid huge geometries being created if the input
+            geometries are very interconnected.
+            Defaults to None (= the output is not tiled).
+        nb_squarish_tiles (int, optional): the approximate number of tiles the
+            output should be dissolved/unioned to. If > 1, a tiling grid is
+            automatically created based on the total bounds of the input file.
+            The input geometries will be dissolved/unioned only within the
+            tiles generated.
+            Can be used to avoid huge geometries being created if the input
+            geometries are very interconnected.
+            Defaults to 1 (= the output is not tiled).
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    # Init
+    if tiles_path is not None:
+        tiles_path = Path(tiles_path)
+
+    # Standardize parameter to simplify the rest of the code
+    if groupby_columns is not None:
+        if isinstance(groupby_columns, str):
+            # If a string is passed, convert to list
+            groupby_columns = [groupby_columns]
+        elif len(groupby_columns) == 0:
+            # If an empty list of geometry columns is passed, convert it to None
+            groupby_columns = None
+
+    logger = logging.getLogger("geofileops.dissolve")
+    logger.info(f"Start, on {input_path} to {output_path}")
+    return _geoops_gpd.dissolve(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        explodecollections=explodecollections,
+        groupby_columns=groupby_columns,
+        agg_columns=agg_columns,
+        tiles_path=tiles_path,
+        nb_squarish_tiles=nb_squarish_tiles,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def export_by_bounds(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    bounds: Tuple[float, float, float, float],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    """
+    Export the rows that intersect with the bounds specified.
+
+    If ``explodecollections`` is False and the input and output file type is GeoPackage,
+    the fid will be preserved. In other cases this will typically not be the case.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        bounds (Tuple[float, float, float, float]): the bounds to filter on.
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger = logging.getLogger("geofileops.export_by_bounds")
+    logger.info(f"Start, on {input_path}")
+    return _geoops_ogr.export_by_bounds(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        bounds=bounds,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force=force,
+    )
+
+
+def isvalid(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]", None] = None,
+    only_invalid: bool = True,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    validate_attribute_data: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+) -> bool:
+    """
+    Checks for all geometries in the geofile if they are valid.
+
+    The results are written to the output file.
+
+    If ``explodecollections`` is False and the input and output file type is GeoPackage,
+    the fid will be preserved. In other cases this will typically not be the case.
+
+    Args:
+        input_path (PathLike): The input file.
+        output_path (PathLike, optional): The output file path. If not
+            specified the result will be written in a new file alongside the
+            input file. Defaults to None.
+        only_invalid (bool, optional): if True, only put invalid results in the
+            output file. Deprecated: always treated as True.
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        validate_attribute_data (bool, optional): True to validate if all attribute data
+            can be read. Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    Returns:
+        bool: True if all geometries were valid.
+    """
+    # Check parameters
+    if output_path is not None:
+        output_path = Path(output_path)
+    else:
+        input_path = Path(input_path)
+        output_path = (
+            input_path.parent / f"{input_path.stem}_isvalid{input_path.suffix}"
+        )
+
+    # Go!
+    logger = logging.getLogger("geofileops.isvalid")
+    logger.info(f"Start, on {input_path}")
+    return _geoops_sql.isvalid(
+        input_path=Path(input_path),
+        output_path=output_path,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        validate_attribute_data=validate_attribute_data,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def makevalid(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Union[str, None, GeometryType] = None,
+    gridsize: float = 0.0,
+    keep_empty_geoms: Optional[bool] = None,
+    where_post: Optional[str] = None,
+    precision: Optional[float] = None,
+    validate_attribute_data: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Makes all geometries in the input file valid.
+
+    Writes the result to the output path.
+
+    Alternative names:
+        - QGIS: fix geometries
+        - shapely, geopandas: make_valid
+
+    If ``explodecollections`` is False and the input and output file type is GeoPackage,
+    the fid will be preserved. In other cases this will typically not be the case.
+
+    Args:
+        input_path (PathLike): The input file.
+        output_path (PathLike): The file to write the result to.
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        force_output_geometrytype (GeometryType, optional): The output geometry type to
+            force the output to. If None, the geometry type of the input is retained.
+            Defaults to None.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        precision (float, optional): deprecated. Use ``gridsize``.
+        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
+            in the output. Defaults to False.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        validate_attribute_data (bool, optional): True to validate if all attribute data
+            can be read. Raises an exception if an error is found, as this type of error
+            cannot be fixed using makevalid. Defaults to False.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.makevalid")
+    logger.info(f"Start, on {input_path}")
+
+    if gridsize is None:
+        gridsize = 0.0
+    if precision is not None and gridsize != 0.0:
+        raise ValueError(
+            "the precision parameter is deprecated and cannot be combined with gridsize"
+        )
+    if precision is not None:
+        gridsize = precision
+        warnings.warn(
+            "the precision parameter is deprecated and will be removed in a future "
+            "version: please use gridsize",
+            FutureWarning,
+            stacklevel=2,
+        )
+
+    if SPATIALITE_GTE_51 and gridsize == 0.0:
+        # If spatialite >= 5.1 available use faster/less memory using SQL implementation
+        # Only use this version if gridsize is 0.0, because when gridsize applied it is
+        # less robust than the gpd implementation.
+        _geoops_sql.makevalid(
+            input_path=Path(input_path),
+            output_path=Path(output_path),
+            input_layer=input_layer,
+            output_layer=output_layer,
+            columns=columns,
+            explodecollections=explodecollections,
+            force_output_geometrytype=force_output_geometrytype,
+            gridsize=gridsize,
+            keep_empty_geoms=keep_empty_geoms,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+        )
+    else:
+        _geoops_gpd.makevalid(
+            input_path=Path(input_path),
+            output_path=Path(output_path),
+            input_layer=input_layer,
+            output_layer=output_layer,
+            columns=columns,
+            explodecollections=explodecollections,
+            force_output_geometrytype=force_output_geometrytype,
+            gridsize=gridsize,
+            keep_empty_geoms=keep_empty_geoms,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+        )
+
+    # If asked and output is spatialite based, check if all data can be read
+    if validate_attribute_data:
+        output_geofileinfo = _geofileinfo.get_geofileinfo(input_path)
+        if output_geofileinfo.is_spatialite_based:
+            _sqlite_util.test_data_integrity(path=input_path)
+
+
+def warp(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    gcps: List[Tuple[float, float, float, float, Optional[float]]],
+    algorithm: str = "polynomial",
+    order: Optional[int] = None,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    """
+    Warp all input features to the output file according to the gcps specified.
+
+    Alternative names:
+        - rubbersheet, rubbersheeting
+
+    Args:
+        input_path (PathLike): The input file.
+        output_path (PathLike): The file to write the result to.
+        gcps (List[Tuple[float, float, float, float]]): ground control points to
+            use to warp the input geometries. This is a list of tuples like this:
+            [(x_orig, y_orig, x_dest, y_dest, elevation), ...].
+        algorithm (str, optional): algorithm to use to warp:
+            - "polynomial": use a polynomial transformation
+            - "tps": use a thin plate spline transformer
+            Defaults to "polynomial".
+        order (int, optional): if algorithm is "polynomial", the order of the
+            polynomial to use for warping.
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger = logging.getLogger("geofileops.warp")
+    logger.info(f"Start, on {input_path}")
+    _geoops_ogr.warp(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        gcps=gcps,
+        algorithm=algorithm,
+        order=order,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force=force,
+    )
+
+
+def select(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    sql_stmt: str,
+    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = "SQLITE",
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Union[GeometryType, str, None] = None,
+    gridsize: float = 0.0,
+    keep_empty_geoms: bool = True,
+    nb_parallel: int = 1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    '''
+    Execute a SELECT SQL statement on the input file.
+
+    The ``sql_stmt`` must be in SQLite dialect and can contain placeholders that will be
+    replaced automatically. More details can be found in the notes and examples below.
+
+    The result is written to the output file specified.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        sql_stmt (str): the SELECT SQL statement to execute
+        sql_dialect (str, optional): the SQL dialect to use. If None, the default SQL
+            dialect of the underlying source is used. Defaults to "SQLITE".
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain, if
+            {columns_to_select_str} is used. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones. Defaults to False.
+        force_output_geometrytype (GeometryType, optional): The output geometry type to
+            force. Defaults to None, and then the geometry type of the input is used
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
+            in the output. Defaults to True.
+        nb_parallel (int, optional): the number of parallel processes to use. If -1, all
+            available cores are used. Defaults to 1.
+            If ``nb_parallel`` != 1, make sure your query still returns correct results
+            if it is executed per batch of rows instead of in one go on the entire
+            layer.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage. If batchsize != -1,
+            make sure your query still returns correct results if it is executed per
+            batch of rows instead of in one go on the entire layer.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s). Defaults to False.
+
+    Notes:
+        By convention, the sqlite query can contain following placeholders that
+        will be automatically replaced for you:
+
+        * {geometrycolumn}: the column where the primary geometry is stored.
+        * {columns_to_select_str}: if ``columns`` is not None, those columns, otherwise
+          all columns of the layer.
+        * {input_layer}: the layer name of the input layer.
+        * {batch_filter}: the filter used to process in parallel per batch.
+
+        Hint: often you will want to use f"" formatting on the SQL statement to fill out
+        some parameters of your own as well. You can easily escape the placeholders
+        above by doubling the "{" and "}", e.g. use {{geometrycolumn}} for
+        {geometrycolumn}. Also check out the example below.
+
+        Example: buffer all rows with a certain minimum area to the output file.
+
+        .. code-block:: python
+
+            import geofileops as gfo
+
+            minimum_area = 100
+            sql_stmt = f"""
+                SELECT ST_Buffer({{geometrycolumn}}, 1) AS {{geometrycolumn}}
+                      {{columns_to_select_str}}
+                  FROM "{{input_layer}}" layer
+                 WHERE 1=1
+                   {{batch_filter}}
+                   AND ST_Area({{geometrycolumn}}) > {minimum_area}
+            """
+            gfo.select(
+                input_path=...,
+                output_path=...,
+                sql_stmt=sql_stmt,
+            )
+
+        Some important remarks:
+
+        * Because some SQL statements won't give the same result when parallelized
+          (eg. when using a group by statement), ``nb_parallel`` is 1 by default.
+          If you do want to use parallel processing, specify ``nb_parallel`` + make
+          sure to include the placeholder {batch_filter} in your ``sql_stmt``.
+          This placeholder will be replaced with a filter of the form
+          "AND rowid >= x AND rowid < y".
+        * The name of the geometry column depends on the file format of the input file.
+          E.g. for .shp files the column will be called "geometry", for .gpkg files the
+          default name is "geom". If you use the {geometrycolumn} placeholder,
+          geofileops will replace it with the correct column name for the input file.
+        * If you apply (spatialite) functions on the geometry column always alias them
+          again to its original column name, e.g. with "AS {geometrycolumn}".
+        * Some SQL statements won't give correct results when parallelized/ran in
+          multiple batches, e.g. when using a group by statement. This is why the
+          default value for nb_parallel is 1. If you want to parallelize or run the
+          query in multiple batches (by specifying ``nb_parallel`` != 1 or ``batchsize``
+          > 0), you should make sure your query will give correct results if it is
+          executed per batch of rows instead of once on the entire layer.
+          Additionally, if you do so, make sure to include the placeholder
+          {batch_filter} in your ``sql_stmt``. This placeholder will be replaced with a
+          filter of the form "AND rowid >= x AND rowid < y" and will ensure every row is
+          only treated once.
+        * Table names are best double quoted as in the example, because some
+          characters are otherwise not supported in the table name, eg. '-'.
+        * It is recommend to give the table you select from "layer" as alias. If
+          you use the {batch_filter} placeholder this is even mandatory.
+        * When using the (default) "SQLITE" SQL dialect, you can also use the spatialite
+          functions as documented here: |spatialite_reference_link|.
+        * It is supported to use an attribute table (= table without geometry column) as
+          input layer and/or not to include the geometry column in the selected columns.
+          Note though that if the {columns_to_select_str} placeholder is used, it will
+          start with a "," and if no column precedes it the SQL statement will be
+          invalid.
+
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    '''  # noqa: E501
+    logger = logging.getLogger("geofileops.select")
+    logger.info(f"Start, on {input_path}")
+
+    # Convert force_output_geometrytype to GeometryType (if necessary)
+    if force_output_geometrytype is not None:
+        force_output_geometrytype = GeometryType(force_output_geometrytype)
+
+    return _geoops_sql.select(
+        input_path=Path(input_path),
+        output_path=Path(output_path),
+        sql_stmt=sql_stmt,
+        sql_dialect=sql_dialect,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        keep_empty_geoms=keep_empty_geoms,
+        gridsize=gridsize,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def simplify(
+    input_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    tolerance: float,
+    algorithm: Union[str, SimplifyAlgorithm] = "rdp",
+    lookahead: int = 8,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    keep_empty_geoms: Optional[bool] = None,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Applies a simplify operation on geometry column of the input file.
+
+    The result is written to the output file specified.
+
+    Several `algorithm`s are available.
+
+    If ``explodecollections`` is False and the input and output file type is GeoPackage,
+    the fid will be preserved. In other cases this will typically not be the case.
+
+    Args:
+        input_path (PathLike): the input file
+        output_path (PathLike): the file to write the result to
+        tolerance (float): tolerance to use for the simplification. Depends on the
+            ``algorithm`` specified.
+            In projected coordinate systems this tolerance will typically be
+            in meter, in geodetic systems this is typically in degrees.
+        algorithm (str, optional): algorithm to use. Defaults to "rdp".
+
+                * **"rdp"**: Ramer Douglas Peucker: tolerance is a distance
+                * **"lang"**: Lang: tolerance is a distance
+                * **"lang+"**: Lang, with extensions to increase number of points reduced.
+                * **"vw"**: Visvalingam Whyatt: tolerance is an area.
+
+        lookahead (int, optional): used for Lang algorithms. Defaults to 8.
+        input_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        output_layer (str, optional): input layer name. Optional if the input
+            file only contains one layer.
+        columns (List[str], optional): list of columns to retain. If None, all standard
+            columns are retained. In addition to standard columns, it is also possible
+            to specify "fid", a unique index available in all input files. Note that the
+            "fid" will be aliased eg. to "fid_1". Defaults to None.
+        explodecollections (bool, optional): True to output only simple geometries.
+            Defaults to False.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        keep_empty_geoms (bool, optional): True to keep rows with empty/null geometries
+            in the output. Defaults to False.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.simplify")
+    logger.info(f"Start, on {input_path} with tolerance {tolerance}")
+    if isinstance(algorithm, str):
+        algorithm = SimplifyAlgorithm(algorithm)
+
+    if algorithm == SimplifyAlgorithm.RAMER_DOUGLAS_PEUCKER:
+        return _geoops_sql.simplify(
+            input_path=Path(input_path),
+            output_path=Path(output_path),
+            tolerance=tolerance,
+            input_layer=input_layer,
+            output_layer=output_layer,
+            columns=columns,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            keep_empty_geoms=keep_empty_geoms,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+        )
+    else:
+        return _geoops_gpd.simplify(
+            input_path=Path(input_path),
+            output_path=Path(output_path),
+            tolerance=tolerance,
+            algorithm=algorithm,
+            lookahead=lookahead,
+            input_layer=input_layer,
+            output_layer=output_layer,
+            columns=columns,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            keep_empty_geoms=keep_empty_geoms,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+        )
+
+
+# ------------------------
+# Operations on two layers
+# ------------------------
+
+
+def clip(
+    input_path: Union[str, "os.PathLike[Any]"],
+    clip_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input_layer: Optional[str] = None,
+    input_columns: Optional[List[str]] = None,
+    clip_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Clip the input layer with the clip layer.
+
+    The resulting layer will contain the parts of the geometries in the
+    input layer that overlap with the dissolved geometries in the clip layer.
+
+    Clarifications:
+        - every row in the input layer will result in maximum one row in the
+          output layer.
+        - geometries in the input layer that overlap with multiple adjacent
+          geometries in the clip layer won't result in the input geometries
+          getting split.
+
+    This is the result you can expect when clipping a polygon layer (yellow)
+    with another polygon layer (purple):
+
+    .. list-table::
+       :header-rows: 1
+
+       * - Input
+         - Clip result
+       * - |clip_input|
+         - |clip_result|
+
+    Args:
+        input_path (PathLike): The file to clip.
+        clip_path (PathLike): The file with the geometries to clip with.
+        output_path (PathLike): the file to write the result to
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        input_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
+        clip_layer (str, optional): clip layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): output layer name. Optional if the
+            file only contains one layer.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    .. |clip_input| image:: ../_static/images/clip_input.png
+        :alt: Clip input
+    .. |clip_result| image:: ../_static/images/clip_result.png
+        :alt: Clip result
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.clip")
+    logger.info(f"Start on {input_path} with {clip_path} to {output_path}")
+    return _geoops_sql.clip(
+        input_path=Path(input_path),
+        clip_path=Path(clip_path),
+        output_path=Path(output_path),
+        input_layer=input_layer,
+        input_columns=input_columns,
+        clip_layer=clip_layer,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def erase(
+    input_path: Union[str, "os.PathLike[Any]"],
+    erase_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input_layer: Optional[str] = None,
+    input_columns: Optional[List[str]] = None,
+    erase_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    subdivide_coords: int = 2000,
+    force: bool = False,
+):
+    """
+    Erase all geometries in the erase layer from the input layer.
+
+    Clarifications:
+        - every row in the input layer will result in maximum one row in the
+          output layer.
+        - columns from the erase layer cannot be retained.
+
+    Alternative names:
+        - QGIS: difference
+
+    Args:
+        input_path (PathLike): The file to erase from.
+        erase_path (PathLike): The file with the geometries to erase with.
+        output_path (PathLike): the file to write the result to
+        input_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        input_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
+        erase_layer (str, optional): erase layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): output layer name. Optional if the
+            file only contains one layer.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        subdivide_coords (int, optional): the input geometries will be subdivided to
+            parts with about ``subdivide_coords`` coordinates during processing which
+            can offer a large speed up for complex geometries. Subdividing can result in
+            extra collinear points being added to the boundaries of the output. If 0, no
+            subdividing is applied. Defaults to 2000.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.erase")
+    logger.info(f"Start, on {input_path} with {erase_path} to {output_path}")
+    return _geoops_sql.erase(
+        input_path=Path(input_path),
+        erase_path=Path(erase_path),
+        output_path=Path(output_path),
+        input_layer=input_layer,
+        input_columns=input_columns,
+        erase_layer=erase_layer,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        subdivide_coords=subdivide_coords,
+        force=force,
+    )
+
+
+def export_by_location(
+    input_to_select_from_path: Union[str, "os.PathLike[Any]"],
+    input_to_compare_with_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    min_area_intersect: Optional[float] = None,
+    area_inters_column_name: Optional[str] = None,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input2_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Exports all intersecting features.
+
+    All features in ``input_to_select_from_path`` that intersect with any features in
+    ``input_to_compare_with_path`` are exported.
+
+    Alternative names:
+        - QGIS: extract by location
+
+    Args:
+        input_to_select_from_path (PathLike): the 1st input file
+        input_to_compare_with_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        min_area_intersect (float, optional): minimum area of the intersection.
+            Defaults to None.
+        area_inters_column_name (str, optional): column name of the intersect
+            area. If None, no area column is added. Defaults to None.
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        input2_columns (List[str], optional): NA.
+        output_layer (str, optional): output layer name. Optional if the
+            file only contains one layer.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.export_by_location")
+    logger.info(
+        f"export_by_location: select from {input_to_select_from_path} "
+        f"interacting with {input_to_compare_with_path} to {output_path}"
+    )
+    return _geoops_sql.export_by_location(
+        input_path=Path(input_to_select_from_path),
+        input_to_compare_with_path=Path(input_to_compare_with_path),
+        output_path=Path(output_path),
+        min_area_intersect=min_area_intersect,
+        area_inters_column_name=area_inters_column_name,
+        input_layer=input1_layer,
+        input_columns=input1_columns,
+        input_to_compare_with_layer=input2_layer,
+        output_layer=output_layer,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def export_by_distance(
+    input_to_select_from_path: Union[str, "os.PathLike[Any]"],
+    input_to_compare_with_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    max_distance: float,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input2_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    Exports all features within the distance specified.
+
+    Features in ``input_to_select_from_path`` that are within the distance specified of
+    any features in ``input_to_compare_with_path``.
+
+    Args:
+        input_to_select_from_path (PathLike): the 1st input file
+        input_to_compare_with_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        max_distance (float): maximum distance
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased eg. to "fid_1". Defaults to None.
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer.
+        output_layer (str, optional): output layer name. Optional if the
+            file only contains one layer.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.export_by_distance")
+    logger.info(
+        f"select from {input_to_select_from_path} within "
+        f"max_distance of {max_distance} from {input_to_compare_with_path} "
+        f"to {output_path}"
+    )
+    return _geoops_sql.export_by_distance(
+        input_to_select_from_path=Path(input_to_select_from_path),
+        input_to_compare_with_path=Path(input_to_compare_with_path),
+        output_path=Path(output_path),
+        max_distance=max_distance,
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input2_layer=input2_layer,
+        output_layer=output_layer,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def identity(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    subdivide_coords: int = 2000,
+    force: bool = False,
+):
+    r"""
+    Intersection of the input layers, but retain the non-intersecting parts of input1.
+
+    The result is the equivalent of an intersect between the two layers + layer
+    1 erased with layer 2.
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
+            to "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1\_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for ``input1_columns``, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2\_".
+        output_layer (str, optional): output layer name. If None, the ``output_path``
+            stem is used. Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        subdivide_coords (int, optional): the input geometries will be subdivided to
+            parts with about ``subdivide_coords`` coordinates during processing which
+            can offer a large speed up for complex geometries. Subdividing can result in
+            extra collinear points being added to the boundaries of the output. If 0, no
+            subdividing is applied. Defaults to 2000.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.identity")
+    logger.info(f"Start, between {input1_path} and {input2_path} to {output_path}")
+    return _geoops_sql.identity(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        subdivide_coords=subdivide_coords,
+        force=force,
+    )
+
+
+def split(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    subdivide_coords: int = 2000,
+    force: bool = False,
+):
+    """
+    DEPRECATED: please use identity.
+    """
+    warnings.warn(
+        "split() is deprecated because it was renamed to identity(). "
+        "Will be removed in a future version",
+        FutureWarning,
+        stacklevel=2,
+    )
+    logger = logging.getLogger("geofileops.identity")
+    logger.info(f"Start,  between {input1_path} and {input2_path} to {output_path}")
+    return _geoops_sql.identity(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        subdivide_coords=subdivide_coords,
+        force=force,
+    )
+
+
+def intersect(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    """
+    DEPRECATED: please use intersection.
+    """
+    warnings.warn(  # pragma: no cover
+        "intersect() is deprecated because it was renamed intersection(). "
+        "Will be removed in a future version",
+        FutureWarning,
+        stacklevel=2,
+    )
+    return intersection(  # pragma: no cover
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        gridsize=gridsize,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def intersection(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    r"""
+    Calculate the pairwise intersection of alle features.
+
+    Alternative names:
+        - GeoPandas: overlay(how="intersection")
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
+            to "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1\_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for ``input1_columns``, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2\_".
+        output_layer (str, optional): output layer name. If None, the ``output_path``
+            stem is used. Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.intersection")
+    logger.info(f"Start, between {input1_path} and {input2_path} to {output_path}")
+    return _geoops_sql.intersection(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def join_by_location(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    spatial_relations_query: str = "intersects is True",
+    discard_nonmatching: bool = True,
+    min_area_intersect: Optional[float] = None,
+    area_inters_column_name: Optional[str] = None,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    r"""
+    Joins all features in input1 with all features in input2.
+
+    The output will contain the geometries of input1. The ``spatial_relations_query``
+    and ``min_area_intersect`` parameters will determine which geometries of input1 will
+    be matched with input2.
+
+    The ``spatial_relations_query`` is a filter string where you can use the following
+    "named spatial predicates": equals, touches, within, overlaps, crosses, intersects,
+    contains, covers, coveredby.
+
+    If you want even more control, you can also use "spatial masks" as defined by the
+    |DE-9IM| model.
+
+    Examples for valid ``spatial_relations_query`` values:
+
+        - "overlaps is True and contains is False"
+        - "(T*T***T** is True or 1*T***T** is True) and T*****FF* is False"
+
+
+    Alternative names:
+        - GeoPandas: sjoin
+        - ArcGIS: spatial join
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        spatial_relations_query (str, optional): a query that specifies the
+            spatial relations to match between the 2 layers.
+            Defaults to "intersects is True".
+        discard_nonmatching (bool, optional): True to only keep rows that
+            match with the spatial_relations_query. False to keep rows all
+            rows in the ``input1_layer`` (=left outer join). Defaults to True
+            (=inner join).
+        min_area_intersect (float, optional): minimum area of the intersection
+            to match. Defaults to None.
+        area_inters_column_name (str, optional): column name of the intersect
+            area. If None no area column is added. Defaults to None.
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
+            to "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1\_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for input1_columns, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2\_".
+        output_layer (str, optional): output layer name. If None, the output_path stem
+            is used. Defaults to None.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    .. |DE-9IM| raw:: html
+
+        <a href="https://en.wikipedia.org/wiki/DE-9IM" target="_blank">DE-9IM</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.join_by_location")
+    logger.info(f"select from {input1_path} joined with {input2_path} to {output_path}")
+    return _geoops_sql.join_by_location(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        spatial_relations_query=spatial_relations_query,
+        discard_nonmatching=discard_nonmatching,
+        min_area_intersect=min_area_intersect,
+        area_inters_column_name=area_inters_column_name,
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=False,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def join_nearest(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    nb_nearest: int,
+    distance: Optional[float] = None,
+    expand: Optional[bool] = None,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    r"""
+    Joins features of ``input1`` with the ``nb_nearest`` closest features of ``input2``.
+
+    In addition to the columns requested via the ``input*_columns`` parameters, the
+    following columns will be in the output file as well:
+        - pos (int): relative rank (sorted by distance): the closest item will be #1,
+          the second closest item will be #2 and so on.
+        - distance (float): if the dataset is in a planar (= projected) crs,
+          ``distance`` will be in the unit defined by the projection (meters, feet,
+          chains etc.). For a geographic dataset (longitude and latitude degrees),
+          ``distance`` will be in meters, with the most precise geodetic formulas being
+          applied.
+        - distance_crs (float): if the dataset is in a planar (= projected) crs,
+          ``distance_crs`` will be in the unit defined by the projection (meters, feet,
+          chains etc.). For a geographic dataset (longitude and latitude degrees),
+          ``distance_crs`` will be in angles. Only available with spatialite >= 5.1.
+
+    Note: if spatialite version >= 5.1 is used, parameters ``distance`` and ``expand``
+    are mandatory.
+
+    Args:
+        input1_path (PathLike): the input file to join to nb_nearest features.
+        input2_path (PathLike): the file where nb_nearest features are looked for.
+        output_path (PathLike): the file to write the result to
+        nb_nearest (int): the number of nearest features from input 2 to join
+            to input1.
+        distance (float): maximum distance to search for the nearest items. If
+            ``expand`` is True, this is the initial search distance, which will be
+            gradually expanded (doubled) till ``nb_nearest`` are found. For optimal
+            performance, it is important to choose the typical value that will be needed
+            to find ``nb_nearest`` items. If ``distance`` is too large, performance can
+            be bad. Parameter is only relevant if spatialite version >= 5.1 is used.
+        expand (bool): True to keep searching till ``nb_nearest`` items are found. If
+            False, only items found within ``distance`` are returned (False is only
+            supported if spatialite version >= 5.1 is used).
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
+            to "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1\_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for ``input1_columns``, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2\_".
+        output_layer (str, optional): output layer name. If None, the ``output_path``
+            stem is used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+    """
+    logger = logging.getLogger("geofileops.join_nearest")
+    logger.info(f"select from {input1_path} joined with {input2_path} to {output_path}")
+    return _geoops_sql.join_nearest(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        nb_nearest=nb_nearest,
+        distance=distance,
+        expand=expand,
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=False,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def select_two_layers(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    sql_stmt: str,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = 1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    r'''
+    Execute a SELECT SQL statement on the input files.
+
+    The ``sql_stmt`` must be in SQLite dialect and can contain placeholders that will be
+    replaced automatically. More details can be found in the notes and examples below.
+
+    The result is written to the output file specified.
+
+    Args:
+        input1_path (PathLike): the 1st input file.
+        input2_path (PathLike): the 2nd input file.
+        output_path (PathLike): the file to write the result to.
+        sql_stmt (str): the SELECT SQL statement to be executed. Must be in SQLite
+            dialect.
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain if one of the
+            {layer1\_columns_...} placeholders is used in ``sql_stmt``. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
+            to "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1\_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): list of columns to retain if one of the
+            {layer2\_columns_...} placeholders is used in ``sql_stmt``. If None is
+            specified, all columns are selected. As explained for ``input1_columns``, it
+            is also possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2\_".
+        output_layer (str, optional): output layer name. If None, the ``output_path``
+            stem is used. Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        force_output_geometrytype (GeometryType, optional): The output geometry
+            type to force. Defaults to None, and then the geometry type of the
+            input1 layer is used.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use. If -1, all
+            available cores are used. Defaults to 1. If ``nb_parallel`` != 1, make sure
+            your query still returns correct results if it is executed per batch of rows
+            instead of in one go on the entire layer.
+        batchsize (int, optional): indicative number of rows to process per batch.
+            A smaller batch size, possibly in combination with a smaller
+            ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    Notes:
+        By convention, the ``sql_stmt`` can contain following placeholders that
+        will be automatically replaced for you:
+
+        * {input1_layer}: name of input layer 1
+        * {input1_geometrycolumn}: name of input geometry column 1
+        * {layer1_columns_prefix_str}: komma seperated columns of
+          layer 1, prefixed with "layer1"
+        * {layer1_columns_prefix_alias_str}: komma seperated columns of
+          layer 1, prefixed with "layer1" and with column name aliases
+        * {layer1_columns_from_subselect_str}: komma seperated columns of
+          layer 1, prefixed with "sub"
+        * {input1_databasename}: the database alias for input 1
+        * {input2_layer}: name of input layer 1
+        * {input2_geometrycolumn}: name of input geometry column 2
+        * {layer2_columns_prefix_str}: komma seperated columns of
+          layer 2, prefixed with "layer2"
+        * {layer2_columns_prefix_alias_str}: komma seperated columns of
+          layer 2, prefixed with "layer2" and with column name aliases
+        * {layer2_columns_from_subselect_str}: komma seperated columns of
+          layer 2, prefixed with "sub"
+        * {layer2_columns_prefix_alias_null_str}: komma seperated columns of
+          layer 2, but with NULL for all values and with column aliases
+        * {input2_databasename}: the database alias for input 2
+        * {batch_filter}: the filter to be applied per batch when using parallel
+          processing
+
+        Example: left outer join all features in input1 layer with all rows
+        in input2 on join_id.
+
+        .. code-block:: python
+
+            import geofileops as gfo
+
+            minimum_area = 100
+            sql_stmt = f"""
+                SELECT layer1.{{input1_geometrycolumn}}
+                      {{layer1_columns_prefix_alias_str}}
+                      {{layer2_columns_prefix_alias_str}}
+                  FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                  LEFT OUTER JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                       ON layer1.join_id = layer2.join_id
+                 WHERE 1=1
+                   {{batch_filter}}
+                   AND ST_Area(layer1.{{input1_geometrycolumn}}) > {minimum_area}
+            """
+            gfo.select_two_layers(
+                input1_path=...,
+                input2_path=...,
+                output_path=...,
+                sql_stmt=sql_stmt,
+            )
+
+        Some important remarks:
+
+        * Because some SQL statements won't give the same result when parallelized
+          (eg. when using a group by statement), ``nb_parallel`` is 1 by default.
+          If you do want to use parallel processing, specify ``nb_parallel`` + make
+          sure to include the placeholder {batch_filter} in your ``sql_stmt``.
+          This placeholder will be replaced with a filter of the form
+          "AND rowid >= x AND rowid < y".
+        * Table names are best double quoted as in the example, because some
+          characters are otherwise not supported in the table name, eg. "-".
+        * When using supported placeholders, make sure you give the tables you
+          select from the appropriate table aliases (layer1, layer2).
+        * Besides the standard sqlite SQL syntacs, you can use the spatialite
+          functions as documented here: |spatialite_reference_link|
+        * It is supported to use attribute tables (= table without geometry column)
+          as input layers and/or not to include the geometry column in the selected
+          columns. Note though that if the column placeholders are used (e.g.
+          {layer1_columns_prefix_str}), they will start with a "," and if no column
+          precedes it the SQL statement will be invalid.
+
+    Examples:
+        An ideal place to get inspiration to write you own advanced queries
+        is in the following source code file: |geofileops_sql_link|.
+
+        Additionally, there are some examples listed here that highlight
+        other features/possibilities.
+
+        **Join nearest features with filter**
+
+        To join nearest features, geofileops has a specific :meth:`~join_nearest`
+        function. This provides a fast way to find the nearest feature(s) if there
+        doesn't need to be a filter on the features to be found.
+
+        For a use case where for each element in layer 1, you want to find the nearest
+        features in layer 2 while applying a filter that eliminates many kandidates,
+        the query below will be a better solution.
+
+        Note: Using ``MIN(ST_Distance(layer1.geom, layer2.geom)`` sometimes seems to
+        round the distances calculated slightly resulting in some nearest features not
+        being found. Using ``RANK`` avoids this issue.
+
+        .. code-block:: python
+
+            sql_stmt = f"""
+                WITH join_with_dist AS (
+                    SELECT layer1.{{input1_geometrycolumn}} AS geom
+                          {{layer1_columns_prefix_alias_str}}
+                          {{layer2_columns_prefix_alias_str}}
+                          ,ST_Distance(
+                                layer1.{{input1_geometrycolumn}},
+                                layer2.{{input2_geometrycolumn}}
+                           ) AS distance
+                          ,RANK() OVER ( PARTITION BY layer1.rowid ORDER BY ST_Distance(
+                                            layer1.{{input1_geometrycolumn}},
+                                            layer2.{{input2_geometrycolumn}}
+                                       )
+                           ) AS pos
+                      FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                      JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                        ON layer1.join_id = layer2.join_id
+                     WHERE 1=1
+                       {{batch_filter}}
+                )
+                SELECT *
+                  FROM join_with_dist jwd
+                 WHERE pos = 1
+            """
+
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    .. |geofileops_sql_link| raw:: html
+
+        <a href="https://github.com/geofileops/geofileops/blob/main/geofileops/util/geofileops_sql.py" target="_blank">geofileops_sql.py</a>
+
+    '''  # noqa: E501
+    logger = logging.getLogger("geofileops.select_two_layers")
+    logger.info(f"select from {input1_path} and {input2_path} to {output_path}")
+    return _geoops_sql.select_two_layers(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        sql_stmt=sql_stmt,
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def symmetric_difference(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    subdivide_coords: int = 2000,
+    force: bool = False,
+):
+    r"""
+    Calculates the "symmetric difference" of the two input layers.
+
+    Alternative names:
+        - GeoPandas: overlay(how="symmetric_difference")
+        - QGIS, ArcMap: symmetrical difference
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg. to
+            "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1\_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for input1_columns, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2\_".
+        output_layer (str, optional): output layer name. If None, the ``output_path``
+            stem is used. Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. explodecollections. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        subdivide_coords (int, optional): the input geometries will be subdivided to
+            parts with about ``subdivide_coords`` coordinates during processing which
+            can offer a large speed up for complex geometries. Subdividing can result in
+            extra collinear points being added to the boundaries of the output. If 0, no
+            subdividing is applied. Defaults to 2000.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.symmetric_difference")
+    logger.info(
+        f"Start, with input1: {input1_path}, "
+        f"input2 {input2_path}, output: {output_path}"
+    )
+    return _geoops_sql.symmetric_difference(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        subdivide_coords=subdivide_coords,
+        force=force,
+    )
+
+
+def union(
+    input1_path: Union[str, "os.PathLike[Any]"],
+    input2_path: Union[str, "os.PathLike[Any]"],
+    output_path: Union[str, "os.PathLike[Any]"],
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    subdivide_coords: int = 2000,
+    force: bool = False,
+):
+    r"""
+    Calculates the pairwise "union" of the two input layers.
+
+    Alternative names:
+        - GeoPandas: overlay(how="union")
+
+    Args:
+        input1_path (PathLike): the 1st input file
+        input2_path (PathLike): the 2nd input file
+        output_path (PathLike): the file to write the result to
+        input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input1_columns (List[str], optional): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if ``input1_columns_prefix`` is "", eg.
+            to "fid_1". Defaults to None.
+        input1_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l1\_".
+        input2_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        input2_columns (List[str], optional): columns to select. If None is specified,
+            all columns are selected. As explained for ``input1_columns``, it is also
+            possible to specify "fid". Defaults to None.
+        input2_columns_prefix (str, optional): prefix to use in the column aliases.
+            Defaults to "l2\_".
+        output_layer (str, optional): output layer name. If None, the ``output_path``
+            stem is used. Defaults to None.
+        explodecollections (bool, optional): True to convert all multi-geometries to
+            singular ones after the dissolve. Defaults to False.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): SQL filter to apply after all other processing,
+            including e.g. ``explodecollections``. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): the number of parallel processes to use.
+            Defaults to -1: use all available CPUs.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller ``nb_parallel``, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        subdivide_coords (int, optional): the input geometries will be subdivided to
+            parts with about ``subdivide_coords`` coordinates during processing which
+            can offer a large speed up for complex geometries. Subdividing can result in
+            extra collinear points being added to the boundaries of the output. If 0, no
+            subdividing is applied. Defaults to 2000.
+        force (bool, optional): overwrite existing output file(s).
+            Defaults to False.
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    logger = logging.getLogger("geofileops.union")
+    logger.info(
+        f"Start, with input1: {input1_path}, input2: {input2_path}, output: "
+        f"{output_path}"
+    )
+    return _geoops_sql.union(
+        input1_path=Path(input1_path),
+        input2_path=Path(input2_path),
+        output_path=Path(output_path),
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        subdivide_coords=subdivide_coords,
+        force=force,
+    )
```

### Comparing `geofileops-0.8.1a0/geofileops/helpers/_parameter_helper.py` & `geofileops-0.8.2/geofileops/helpers/_parameter_helper.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,100 +1,100 @@
-"""
-Module with some helpers functions to validate, parse,... parameters.
-
-Mainly used for parameters with a complex structure that are typically reused in
-different functions in geofileops.
-"""
-
-
-def validate_agg_columns(agg_columns: dict):
-    """
-    Validates if the agg_columns parameter is properly formed.
-
-    If an problem is found, an error is raised.
-
-    Typically used in dissolve functions.
-
-    Args:
-        agg_columns (dict): the agg_columns parameter value dict to check.
-
-    Raises:
-        ValueError: if any error is encountered.
-    """
-    # Check agg_columns param
-    if agg_columns is None:
-        return
-
-    base_message = (
-        '{"json": [<list_columns>]} '
-        'or {"columns": [{"column": "...", "agg": "...", "as": "..."}, ...]}'
-    )
-
-    # It should be a dict with one key
-    if (
-        agg_columns is None
-        or not isinstance(agg_columns, dict)
-        or len(agg_columns) != 1
-    ):
-        message = "agg_columns must be a dict with exactly one top-level key"
-        raise ValueError(f"{message}: {base_message}")
-
-    if "json" in agg_columns:
-        # The value should be a list or None
-        if agg_columns["json"] is None:
-            return
-        if not isinstance(agg_columns["json"], list):
-            message = 'agg_columns["json"] does not contain a list of strings'
-            raise ValueError(f"{message}: {agg_columns['json']}: {base_message}")
-
-        # Loop through all elements
-        for agg_column in agg_columns["json"]:
-            # It should be a str
-            if not isinstance(agg_column, str):
-                message = 'agg_columns["json"] list contains a non-string element'
-                raise ValueError(f"{message}: {agg_column}: {base_message}")
-    elif "columns" in agg_columns:
-        supported_aggfuncs = [
-            "count",
-            "sum",
-            "mean",
-            "min",
-            "max",
-            "median",
-            "concat",
-        ]
-        # The value should be a list
-        if not isinstance(agg_columns["columns"], list):
-            message = 'agg_columns["columns"] does not contain a list of dicts'
-            raise ValueError(f"{message}: {agg_columns['columns']}: {base_message}")
-
-        # Loop through all elements
-        for agg_column in agg_columns["columns"]:
-            # It should be a dict
-            if not isinstance(agg_column, dict):
-                message = 'agg_columns["columns"] list contains a non-dict element'
-                raise ValueError(f"{message}: {agg_column}: {base_message}")
-
-            # Check if column exists + set casing same as in data
-            if "column" not in agg_column:
-                message = 'each dict in agg_columns["columns"] needs a "column" element'
-                raise ValueError(f"{message}: {agg_column}")
-            if "agg" not in agg_column:
-                message = 'each dict in agg_columns["columns"] needs an "agg" element'
-                raise ValueError(f"{message}: {agg_column}")
-            if "as" not in agg_column:
-                message = 'each dict in agg_columns["columns"] needs an "as" element'
-                raise ValueError(f"{message}: {agg_column}")
-            if agg_column["agg"].lower() not in supported_aggfuncs:
-                raise ValueError(
-                    'agg_columns["columns"] contains unsupported aggregation '
-                    f'{agg_column["agg"]}, use one of {supported_aggfuncs}'
-                )
-            if not isinstance(agg_column["as"], str):
-                raise ValueError(
-                    f'agg_columns["columns"], "as" value should be string: {agg_column}'
-                )
-    else:
-        message = (
-            f"agg_columns has invalid top-level key: {next(iter(agg_columns.keys()))}"
-        )
-        raise ValueError(f"{message}: {base_message}")
+"""
+Module with some helpers functions to validate, parse,... parameters.
+
+Mainly used for parameters with a complex structure that are typically reused in
+different functions in geofileops.
+"""
+
+
+def validate_agg_columns(agg_columns: dict):
+    """
+    Validates if the agg_columns parameter is properly formed.
+
+    If an problem is found, an error is raised.
+
+    Typically used in dissolve functions.
+
+    Args:
+        agg_columns (dict): the agg_columns parameter value dict to check.
+
+    Raises:
+        ValueError: if any error is encountered.
+    """
+    # Check agg_columns param
+    if agg_columns is None:
+        return
+
+    base_message = (
+        '{"json": [<list_columns>]} '
+        'or {"columns": [{"column": "...", "agg": "...", "as": "..."}, ...]}'
+    )
+
+    # It should be a dict with one key
+    if (
+        agg_columns is None
+        or not isinstance(agg_columns, dict)
+        or len(agg_columns) != 1
+    ):
+        message = "agg_columns must be a dict with exactly one top-level key"
+        raise ValueError(f"{message}: {base_message}")
+
+    if "json" in agg_columns:
+        # The value should be a list or None
+        if agg_columns["json"] is None:
+            return
+        if not isinstance(agg_columns["json"], list):
+            message = 'agg_columns["json"] does not contain a list of strings'
+            raise ValueError(f"{message}: {agg_columns['json']}: {base_message}")
+
+        # Loop through all elements
+        for agg_column in agg_columns["json"]:
+            # It should be a str
+            if not isinstance(agg_column, str):
+                message = 'agg_columns["json"] list contains a non-string element'
+                raise ValueError(f"{message}: {agg_column}: {base_message}")
+    elif "columns" in agg_columns:
+        supported_aggfuncs = [
+            "count",
+            "sum",
+            "mean",
+            "min",
+            "max",
+            "median",
+            "concat",
+        ]
+        # The value should be a list
+        if not isinstance(agg_columns["columns"], list):
+            message = 'agg_columns["columns"] does not contain a list of dicts'
+            raise ValueError(f"{message}: {agg_columns['columns']}: {base_message}")
+
+        # Loop through all elements
+        for agg_column in agg_columns["columns"]:
+            # It should be a dict
+            if not isinstance(agg_column, dict):
+                message = 'agg_columns["columns"] list contains a non-dict element'
+                raise ValueError(f"{message}: {agg_column}: {base_message}")
+
+            # Check if column exists + set casing same as in data
+            if "column" not in agg_column:
+                message = 'each dict in agg_columns["columns"] needs a "column" element'
+                raise ValueError(f"{message}: {agg_column}")
+            if "agg" not in agg_column:
+                message = 'each dict in agg_columns["columns"] needs an "agg" element'
+                raise ValueError(f"{message}: {agg_column}")
+            if "as" not in agg_column:
+                message = 'each dict in agg_columns["columns"] needs an "as" element'
+                raise ValueError(f"{message}: {agg_column}")
+            if agg_column["agg"].lower() not in supported_aggfuncs:
+                raise ValueError(
+                    'agg_columns["columns"] contains unsupported aggregation '
+                    f'{agg_column["agg"]}, use one of {supported_aggfuncs}'
+                )
+            if not isinstance(agg_column["as"], str):
+                raise ValueError(
+                    f'agg_columns["columns"], "as" value should be string: {agg_column}'
+                )
+    else:
+        message = (
+            f"agg_columns has invalid top-level key: {next(iter(agg_columns.keys()))}"
+        )
+        raise ValueError(f"{message}: {base_message}")
```

### Comparing `geofileops-0.8.1a0/geofileops/helpers/layerstyles.py` & `geofileops-0.8.2/geofileops/helpers/layerstyles.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,231 +1,231 @@
-"""
-Module to save layer styles in Geopackage files.
-"""
-
-from pathlib import Path
-import sqlite3
-from typing import Optional
-
-from osgeo import gdal
-from osgeo import ogr
-import pandas as pd
-
-from geofileops import fileops
-
-gdal.UseExceptions()
-ogr.UseExceptions()
-
-
-def get_layerstyles(
-    path: Path, layer: Optional[str] = None, name: Optional[str] = None
-) -> pd.DataFrame:
-    """
-    Get the layer styles saved in the geofile.
-
-    Only styles saved according to the QGIS Geopackage styling extension are read:
-    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
-
-    Args:
-        path (Path): path to the geofile.
-        layer (str, optional): the layer to get the styles for. If None, all styles
-            regardless of the layer they belong to are returned. Defaults to None.
-        name (str, optional): the name of the style to get. If None, all styles
-            regardless of their name are returned. Defaults to None.
-
-    Returns:
-        pd.DataFrame: the styles found.
-    """
-    layer_styles_df = fileops.read_file(path, layer="layer_styles", fid_as_index=True)
-    layer_styles_df.index.name = "id"
-    if layer is not None:
-        layer_styles_df = layer_styles_df.loc[layer_styles_df["f_table_name"] == layer]
-    if name is not None:
-        layer_styles_df = layer_styles_df.loc[layer_styles_df["styleName"] == name]
-
-    return layer_styles_df
-
-
-def add_layerstyle(
-    path: Path,
-    layer: str,
-    name: str,
-    qml: str,
-    sld: str = "",
-    use_as_default: bool = False,
-    description: str = "",
-    owner: str = "",
-    ui: str = "",
-):
-    """
-    Add the layer style to the geofile.
-
-    Remark: at the time of writing, QGIS only uses the qml field to interprete the
-    style, so this field is mandatory and sld is not.
-
-    The style is saved according to the QGIS Geopackage styling extension:
-    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
-
-    Args:
-        path (Path): path to the geofile.
-        layer (str): the layer the style is meant for.
-        name (str): the name of the style.
-        qml (str): the styling in qml format.
-        sld (str, optional): the styling in sld format. Defaults to "" as it is not used
-            by QGIS at the time of writing.
-        use_as_default(bool, optional): True to use the style by default when opening
-            the layer in QGIS.
-        description (str, optional): description of the style, Defaults to "".
-        owner (str, optional): owner of the style, Defaults to "".
-        ui (str, optional): ui specification in ui format, Defaults to "".
-    """
-    # Make sure the layer_styles table exists
-    _init_layerstyles(path, exist_ok=True)
-    if use_as_default:
-        use_as_default_str = 1
-    else:
-        use_as_default_str = 0
-
-    # Get existing layer styles
-    layer_styles_df = get_layerstyles(path, layer=layer, name=name)
-
-    # If the layer style already exists: error
-    if len(layer_styles_df) > 0:
-        styles_found = (
-            layer_styles_df[["f_table_name", "styleName"]]
-            .reset_index()
-            .to_dict(orient="records")
-        )
-        raise ValueError(f"layer style exists already: {styles_found}")
-
-    # Insert style
-    conn = sqlite3.connect(path)
-    sql = """
-        INSERT INTO layer_styles (
-                id, f_table_catalog, f_table_schema, f_table_name,
-                f_geometry_column, styleName, styleQML, styleSLD, useAsDefault,
-                description, owner, ui
-            )
-            VALUES (NULL, '', '', ?, ?, ?, ?, ?, ?, ?, ?, ?)
-    """
-    try:
-        conn.execute(
-            sql,
-            (layer, "geom", name, qml, sld, use_as_default_str, description, owner, ui),
-        )
-        conn.commit()
-    except Exception as ex:
-        conn.rollback()
-        raise Exception(f"Error {ex} executing {sql}") from ex
-    finally:
-        conn.close()
-
-
-def remove_layerstyle(path: Path, id: int):
-    """
-    Remove a layer style.
-
-    Only styles saved according to the QGIS Geopackage styling extension are removed:
-    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
-
-    Args:
-        path (Path): path to the geo file.
-        id (int): the id of the layer style to remove.
-    """
-    if not _has_layerstyles_table(path):
-        return
-
-    try:
-        datasource = gdal.OpenEx(str(path), nOpenFlags=gdal.OF_UPDATE)
-
-        sql = f"DELETE FROM layer_styles WHERE id = {id}"
-        result = datasource.ExecuteSQL(sql, dialect="SQLITE")
-        datasource.ReleaseResultSet(result)
-
-    finally:
-        datasource = None
-
-
-def _has_layerstyles_table(path: Path) -> bool:
-    """
-    Check if the layer_styles table exists for the geo file specified.
-
-    Args:
-        path (Path): the path to the geofile.
-
-    Returns:
-        bool: True of the layer_styles table exists, False if not.
-    """
-    try:
-        datasource = gdal.OpenEx(str(path))
-        sql = """
-            SELECT count(1) FROM sqlite_master
-             WHERE name = 'layer_styles'
-               AND type = 'table'
-        """
-        result = datasource.ExecuteSQL(sql, dialect="SQLITE")
-        table_exists = result.GetNextFeature().GetField(0) == 1
-        datasource.ReleaseResultSet(result)
-    finally:
-        datasource = None
-
-    return table_exists
-
-
-def _init_layerstyles(path: Path, exist_ok: bool = False):
-    """
-    Create a layer_styles attribute table to store style information in the QGIS way.
-
-    The table is created according to the QGIS Geopackage styling extension:
-    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
-
-    Args:
-        path (Path): the file to create the table in.
-        exist_ok (bool, options): If True and the index exists already, don't
-            throw an error.
-    """
-    try:
-        # First check if it exists already
-        if _has_layerstyles_table(path):
-            if exist_ok:
-                return
-            else:
-                raise ValueError(f"layer_styles table exists already in {path}")
-
-        # Doesn't exist yet, so create the table
-        datasource = gdal.OpenEx(str(path), nOpenFlags=gdal.OF_UPDATE)
-        layer = datasource.CreateLayer(
-            "layer_styles", geom_type=ogr.wkbNone, options=["FID=id"]
-        )
-
-        # Add the fields we're interested in
-        field_name = ogr.FieldDefn("f_table_catalog", ogr.OFTString)
-        field_name.SetWidth(256)
-        layer.CreateField(field_name)
-        field_region = ogr.FieldDefn("f_table_schema", ogr.OFTString)
-        field_region.SetWidth(256)
-        layer.CreateField(field_region)
-        field_region = ogr.FieldDefn("f_table_name", ogr.OFTString)
-        field_region.SetWidth(256)
-        layer.CreateField(field_region)
-        field_region = ogr.FieldDefn("f_geometry_column", ogr.OFTString)
-        field_region.SetWidth(256)
-        layer.CreateField(field_region)
-        field_region = ogr.FieldDefn("styleName", ogr.OFTString)
-        field_region.SetWidth(30)
-        layer.CreateField(field_region)
-        layer.CreateField(ogr.FieldDefn("styleQML", ogr.OFTString))
-        layer.CreateField(ogr.FieldDefn("styleSLD", ogr.OFTString))
-        layer.CreateField(ogr.FieldDefn("useAsDefault", ogr.OFSTBoolean))
-        layer.CreateField(ogr.FieldDefn("description", ogr.OFTString))
-        field_region = ogr.FieldDefn("owner", ogr.OFTString)
-        field_region.SetWidth(30)
-        layer.CreateField(field_region)
-        field_region = ogr.FieldDefn("ui", ogr.OFTString)
-        field_region.SetWidth(30)
-        layer.CreateField(field_region)
-        field_region = ogr.FieldDefn("update_time", ogr.OFTDateTime)
-        field_region.SetDefault("CURRENT_TIMESTAMP")
-        layer.CreateField(field_region)
-    finally:
-        datasource = None
-        layer = None
+"""
+Module to save layer styles in Geopackage files.
+"""
+
+from pathlib import Path
+import sqlite3
+from typing import Optional
+
+from osgeo import gdal
+from osgeo import ogr
+import pandas as pd
+
+from geofileops import fileops
+
+gdal.UseExceptions()
+ogr.UseExceptions()
+
+
+def get_layerstyles(
+    path: Path, layer: Optional[str] = None, name: Optional[str] = None
+) -> pd.DataFrame:
+    """
+    Get the layer styles saved in the geofile.
+
+    Only styles saved according to the QGIS Geopackage styling extension are read:
+    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
+
+    Args:
+        path (Path): path to the geofile.
+        layer (str, optional): the layer to get the styles for. If None, all styles
+            regardless of the layer they belong to are returned. Defaults to None.
+        name (str, optional): the name of the style to get. If None, all styles
+            regardless of their name are returned. Defaults to None.
+
+    Returns:
+        pd.DataFrame: the styles found.
+    """
+    layer_styles_df = fileops.read_file(path, layer="layer_styles", fid_as_index=True)
+    layer_styles_df.index.name = "id"
+    if layer is not None:
+        layer_styles_df = layer_styles_df.loc[layer_styles_df["f_table_name"] == layer]
+    if name is not None:
+        layer_styles_df = layer_styles_df.loc[layer_styles_df["styleName"] == name]
+
+    return layer_styles_df
+
+
+def add_layerstyle(
+    path: Path,
+    layer: str,
+    name: str,
+    qml: str,
+    sld: str = "",
+    use_as_default: bool = False,
+    description: str = "",
+    owner: str = "",
+    ui: str = "",
+):
+    """
+    Add the layer style to the geofile.
+
+    Remark: at the time of writing, QGIS only uses the qml field to interprete the
+    style, so this field is mandatory and sld is not.
+
+    The style is saved according to the QGIS Geopackage styling extension:
+    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
+
+    Args:
+        path (Path): path to the geofile.
+        layer (str): the layer the style is meant for.
+        name (str): the name of the style.
+        qml (str): the styling in qml format.
+        sld (str, optional): the styling in sld format. Defaults to "" as it is not used
+            by QGIS at the time of writing.
+        use_as_default(bool, optional): True to use the style by default when opening
+            the layer in QGIS.
+        description (str, optional): description of the style, Defaults to "".
+        owner (str, optional): owner of the style, Defaults to "".
+        ui (str, optional): ui specification in ui format, Defaults to "".
+    """
+    # Make sure the layer_styles table exists
+    _init_layerstyles(path, exist_ok=True)
+    if use_as_default:
+        use_as_default_str = 1
+    else:
+        use_as_default_str = 0
+
+    # Get existing layer styles
+    layer_styles_df = get_layerstyles(path, layer=layer, name=name)
+
+    # If the layer style already exists: error
+    if len(layer_styles_df) > 0:
+        styles_found = (
+            layer_styles_df[["f_table_name", "styleName"]]
+            .reset_index()
+            .to_dict(orient="records")
+        )
+        raise ValueError(f"layer style exists already: {styles_found}")
+
+    # Insert style
+    conn = sqlite3.connect(path)
+    sql = """
+        INSERT INTO layer_styles (
+                id, f_table_catalog, f_table_schema, f_table_name,
+                f_geometry_column, styleName, styleQML, styleSLD, useAsDefault,
+                description, owner, ui
+            )
+            VALUES (NULL, '', '', ?, ?, ?, ?, ?, ?, ?, ?, ?)
+    """
+    try:
+        conn.execute(
+            sql,
+            (layer, "geom", name, qml, sld, use_as_default_str, description, owner, ui),
+        )
+        conn.commit()
+    except Exception as ex:
+        conn.rollback()
+        raise Exception(f"Error {ex} executing {sql}") from ex
+    finally:
+        conn.close()
+
+
+def remove_layerstyle(path: Path, id: int):
+    """
+    Remove a layer style.
+
+    Only styles saved according to the QGIS Geopackage styling extension are removed:
+    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
+
+    Args:
+        path (Path): path to the geo file.
+        id (int): the id of the layer style to remove.
+    """
+    if not _has_layerstyles_table(path):
+        return
+
+    try:
+        datasource = gdal.OpenEx(str(path), nOpenFlags=gdal.OF_UPDATE)
+
+        sql = f"DELETE FROM layer_styles WHERE id = {id}"
+        result = datasource.ExecuteSQL(sql, dialect="SQLITE")
+        datasource.ReleaseResultSet(result)
+
+    finally:
+        datasource = None
+
+
+def _has_layerstyles_table(path: Path) -> bool:
+    """
+    Check if the layer_styles table exists for the geo file specified.
+
+    Args:
+        path (Path): the path to the geofile.
+
+    Returns:
+        bool: True of the layer_styles table exists, False if not.
+    """
+    try:
+        datasource = gdal.OpenEx(str(path))
+        sql = """
+            SELECT count(1) FROM sqlite_master
+             WHERE name = 'layer_styles'
+               AND type = 'table'
+        """
+        result = datasource.ExecuteSQL(sql, dialect="SQLITE")
+        table_exists = result.GetNextFeature().GetField(0) == 1
+        datasource.ReleaseResultSet(result)
+    finally:
+        datasource = None
+
+    return table_exists
+
+
+def _init_layerstyles(path: Path, exist_ok: bool = False):
+    """
+    Create a layer_styles attribute table to store style information in the QGIS way.
+
+    The table is created according to the QGIS Geopackage styling extension:
+    https://github.com/pka/qgpkg/blob/master/qgis_geopackage_extension.md
+
+    Args:
+        path (Path): the file to create the table in.
+        exist_ok (bool, options): If True and the index exists already, don't
+            throw an error.
+    """
+    try:
+        # First check if it exists already
+        if _has_layerstyles_table(path):
+            if exist_ok:
+                return
+            else:
+                raise ValueError(f"layer_styles table exists already in {path}")
+
+        # Doesn't exist yet, so create the table
+        datasource = gdal.OpenEx(str(path), nOpenFlags=gdal.OF_UPDATE)
+        layer = datasource.CreateLayer(
+            "layer_styles", geom_type=ogr.wkbNone, options=["FID=id"]
+        )
+
+        # Add the fields we're interested in
+        field_name = ogr.FieldDefn("f_table_catalog", ogr.OFTString)
+        field_name.SetWidth(256)
+        layer.CreateField(field_name)
+        field_region = ogr.FieldDefn("f_table_schema", ogr.OFTString)
+        field_region.SetWidth(256)
+        layer.CreateField(field_region)
+        field_region = ogr.FieldDefn("f_table_name", ogr.OFTString)
+        field_region.SetWidth(256)
+        layer.CreateField(field_region)
+        field_region = ogr.FieldDefn("f_geometry_column", ogr.OFTString)
+        field_region.SetWidth(256)
+        layer.CreateField(field_region)
+        field_region = ogr.FieldDefn("styleName", ogr.OFTString)
+        field_region.SetWidth(30)
+        layer.CreateField(field_region)
+        layer.CreateField(ogr.FieldDefn("styleQML", ogr.OFTString))
+        layer.CreateField(ogr.FieldDefn("styleSLD", ogr.OFTString))
+        layer.CreateField(ogr.FieldDefn("useAsDefault", ogr.OFSTBoolean))
+        layer.CreateField(ogr.FieldDefn("description", ogr.OFTString))
+        field_region = ogr.FieldDefn("owner", ogr.OFTString)
+        field_region.SetWidth(30)
+        layer.CreateField(field_region)
+        field_region = ogr.FieldDefn("ui", ogr.OFTString)
+        field_region.SetWidth(30)
+        layer.CreateField(field_region)
+        field_region = ogr.FieldDefn("update_time", ogr.OFTDateTime)
+        field_region.SetDefault("CURRENT_TIMESTAMP")
+        layer.CreateField(field_region)
+    finally:
+        datasource = None
+        layer = None
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_general_util.py` & `geofileops-0.8.2/geofileops/util/_general_util.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,183 +1,183 @@
-"""
-Module containing some general utilities.
-"""
-
-import datetime
-import logging
-from typing import Any, Dict, Iterable, List, Optional
-
-logger = logging.getLogger(__name__)
-
-
-class MissingRuntimeDependencyError(Exception):
-    """
-    Exception raised when an unsupported SQL statement is passed.
-
-    Attributes:
-        message (str): Exception message
-    """
-
-    def __init__(self, message):
-        self.message = message
-        super().__init__(self.message)
-
-
-def align_casing(string_to_align: str, strings_to_align_to: Iterable) -> str:
-    """
-    Search a string case-insentive in a list of string to align its casing.
-
-    If the string is not found in strings_to_align_to, a ValueError is thrown.
-
-    Args:
-        string_to_align (str): string to align the casing of to strings_to_align_to.
-        strings_to_align_to (Iterable): strings to align the casing with.
-
-    Raises:
-        ValueError: the string was not found in strings_to_align_to.
-
-    Returns:
-        str: the aligned string.
-    """
-    return align_casing_list([string_to_align], strings_to_align_to)[0]
-
-
-def align_casing_list(
-    strings_to_align: List[str],
-    strings_to_align_to: Iterable,
-    raise_on_missing: bool = True,
-) -> List[str]:
-    """
-    Search the string caseintensitive in a list of strings.
-
-    Args:
-        strings_to_align (List[str]): strings to align the casing of to
-            strings_to_align_to.
-        strings_to_align_to (Iterable): strings to align the casing with.
-        raise_on_missing (bool, optional): if True, a ValueError is raised if a string
-            in ``strings_to_align`` is not found in ``strings_to_align_to``. If False,
-            the casing in ``strings_to_align`` is retained in the output.
-
-    Raises:
-        ValueError: a string in strings_to_align was nog found in strings_to_align_to.
-
-    Returns:
-        List[str]: the aligned list of strings.
-    """
-    strings_to_align_to_upper_dict = {
-        string.upper(): string for string in strings_to_align_to
-    }
-    strings_aligned = []
-    for string in strings_to_align:
-        string_aligned = strings_to_align_to_upper_dict.get(string.upper())
-        if string_aligned is not None:
-            strings_aligned.append(string_aligned)
-        elif raise_on_missing:
-            raise ValueError(f"{string} not available in: {strings_to_align_to}")
-        else:
-            strings_aligned.append(string)
-
-    return strings_aligned
-
-
-def report_progress(
-    start_time: datetime.datetime,
-    nb_done: int,
-    nb_todo: int,
-    operation: Optional[str] = None,
-    nb_parallel: int = 1,
-):
-    # If logging level not enabled for INFO, no progress reporting...
-    if logger.isEnabledFor(logging.INFO) is False:
-        return
-
-    message = format_progress(
-        start_time=start_time,
-        nb_done=nb_done,
-        nb_todo=nb_todo,
-        operation=operation,
-        nb_parallel=nb_parallel,
-    )
-    if message is not None:
-        if nb_done >= nb_todo:
-            message += "\n"
-        print(f"\r{message}", end="", flush=True)
-
-
-def format_progress(
-    start_time: datetime.datetime,
-    nb_done: int,
-    nb_todo: int,
-    operation: Optional[str] = None,
-    nb_parallel: int = 1,
-) -> Optional[str]:
-    # Init
-    time_passed = (datetime.datetime.now() - start_time).total_seconds()
-    pct_progress = 100.0 - (nb_todo - nb_done) * 100 / nb_todo
-    nb_todo_str = f"{nb_todo:n}"
-    nb_decimal = len(nb_todo_str)
-
-    # If we haven't really started yet, don't report time estimate yet
-    if nb_done == 0:
-        return (
-            f" ?: ?: ? left, {operation} done on {nb_done:{nb_decimal}n} of "
-            f"{nb_todo:{nb_decimal}n} ({pct_progress:3.2f}%)    "
-        )
-    else:
-        pct_progress = 100.0 - (nb_todo - nb_done) * 100 / nb_todo
-        if time_passed > 0:
-            # Else, report progress properly...
-            processed_per_hour = (nb_done / time_passed) * 3600
-            # Correct the nb processed per hour if running parallel
-            if nb_done < nb_parallel:
-                processed_per_hour = round(processed_per_hour * nb_parallel / nb_done)
-            hours_to_go = (int)((nb_todo - nb_done) / processed_per_hour)
-            min_to_go = (int)((((nb_todo - nb_done) / processed_per_hour) % 1) * 60)
-            secs_to_go = (int)(
-                ((((nb_todo - nb_done) / processed_per_hour) % 1) * 3600) % 60
-            )
-            time_left_str = f"{hours_to_go:02d}:{min_to_go:02d}:{secs_to_go:02d}"
-            nb_left_str = f"{nb_done:{nb_decimal}n} of {nb_todo:{nb_decimal}n}"
-            pct_str = f"({pct_progress:3.2f}%)    "
-        elif pct_progress >= 100:
-            time_left_str = "00:00:00"
-            nb_left_str = f"{nb_done:{nb_decimal}n} of {nb_todo:{nb_decimal}n}"
-            pct_str = f"({pct_progress:3.2f}%)    "
-        else:
-            return None
-        message = f"{time_left_str} left, {operation} done on {nb_left_str} {pct_str}"
-        return message
-
-
-def formatbytes(bytes: float):
-    """
-    Return the given bytes as a human friendly KB, MB, GB, or TB string.
-    """
-    bytes_float = float(bytes)
-    KB = float(1024)
-    MB = float(KB**2)  # 1,048,576
-    GB = float(KB**3)  # 1,073,741,824
-    TB = float(KB**4)  # 1,099,511,627,776
-
-    if bytes_float < KB:
-        return "{} {}".format(bytes_float, "Bytes" if bytes_float > 1 else "Byte")
-    elif KB <= bytes_float < MB:
-        return f"{bytes_float / KB:.2f} KB"
-    elif MB <= bytes_float < GB:
-        return f"{bytes_float / MB:.2f} MB"
-    elif GB <= bytes_float < TB:
-        return f"{bytes_float / GB:.2f} GB"
-    elif TB <= bytes_float:
-        return f"{bytes_float / TB:.2f} TB"
-
-
-def prepare_for_serialize(data: dict) -> dict:
-    prepared: Dict[str, Any] = {}
-    for key, value in data.items():
-        if isinstance(value, (dict)):
-            prepared[key] = prepare_for_serialize(value)
-        elif isinstance(value, (list, tuple)):
-            prepared[key] = value
-        else:
-            prepared[key] = str(value)
-
-    return prepared
+"""
+Module containing some general utilities.
+"""
+
+import datetime
+import logging
+from typing import Any, Dict, Iterable, List, Optional
+
+logger = logging.getLogger(__name__)
+
+
+class MissingRuntimeDependencyError(Exception):
+    """
+    Exception raised when an unsupported SQL statement is passed.
+
+    Attributes:
+        message (str): Exception message
+    """
+
+    def __init__(self, message):
+        self.message = message
+        super().__init__(self.message)
+
+
+def align_casing(string_to_align: str, strings_to_align_to: Iterable) -> str:
+    """
+    Search a string case-insentive in a list of string to align its casing.
+
+    If the string is not found in strings_to_align_to, a ValueError is thrown.
+
+    Args:
+        string_to_align (str): string to align the casing of to strings_to_align_to.
+        strings_to_align_to (Iterable): strings to align the casing with.
+
+    Raises:
+        ValueError: the string was not found in strings_to_align_to.
+
+    Returns:
+        str: the aligned string.
+    """
+    return align_casing_list([string_to_align], strings_to_align_to)[0]
+
+
+def align_casing_list(
+    strings_to_align: List[str],
+    strings_to_align_to: Iterable,
+    raise_on_missing: bool = True,
+) -> List[str]:
+    """
+    Search the string caseintensitive in a list of strings.
+
+    Args:
+        strings_to_align (List[str]): strings to align the casing of to
+            strings_to_align_to.
+        strings_to_align_to (Iterable): strings to align the casing with.
+        raise_on_missing (bool, optional): if True, a ValueError is raised if a string
+            in ``strings_to_align`` is not found in ``strings_to_align_to``. If False,
+            the casing in ``strings_to_align`` is retained in the output.
+
+    Raises:
+        ValueError: a string in strings_to_align was nog found in strings_to_align_to.
+
+    Returns:
+        List[str]: the aligned list of strings.
+    """
+    strings_to_align_to_upper_dict = {
+        string.upper(): string for string in strings_to_align_to
+    }
+    strings_aligned = []
+    for string in strings_to_align:
+        string_aligned = strings_to_align_to_upper_dict.get(string.upper())
+        if string_aligned is not None:
+            strings_aligned.append(string_aligned)
+        elif raise_on_missing:
+            raise ValueError(f"{string} not available in: {strings_to_align_to}")
+        else:
+            strings_aligned.append(string)
+
+    return strings_aligned
+
+
+def report_progress(
+    start_time: datetime.datetime,
+    nb_done: int,
+    nb_todo: int,
+    operation: Optional[str] = None,
+    nb_parallel: int = 1,
+):
+    # If logging level not enabled for INFO, no progress reporting...
+    if logger.isEnabledFor(logging.INFO) is False:
+        return
+
+    message = format_progress(
+        start_time=start_time,
+        nb_done=nb_done,
+        nb_todo=nb_todo,
+        operation=operation,
+        nb_parallel=nb_parallel,
+    )
+    if message is not None:
+        if nb_done >= nb_todo:
+            message += "\n"
+        print(f"\r{message}", end="", flush=True)
+
+
+def format_progress(
+    start_time: datetime.datetime,
+    nb_done: int,
+    nb_todo: int,
+    operation: Optional[str] = None,
+    nb_parallel: int = 1,
+) -> Optional[str]:
+    # Init
+    time_passed = (datetime.datetime.now() - start_time).total_seconds()
+    pct_progress = 100.0 - (nb_todo - nb_done) * 100 / nb_todo
+    nb_todo_str = f"{nb_todo:n}"
+    nb_decimal = len(nb_todo_str)
+
+    # If we haven't really started yet, don't report time estimate yet
+    if nb_done == 0:
+        return (
+            f" ?: ?: ? left, {operation} done on {nb_done:{nb_decimal}n} of "
+            f"{nb_todo:{nb_decimal}n} ({pct_progress:3.2f}%)    "
+        )
+    else:
+        pct_progress = 100.0 - (nb_todo - nb_done) * 100 / nb_todo
+        if time_passed > 0:
+            # Else, report progress properly...
+            processed_per_hour = (nb_done / time_passed) * 3600
+            # Correct the nb processed per hour if running parallel
+            if nb_done < nb_parallel:
+                processed_per_hour = round(processed_per_hour * nb_parallel / nb_done)
+            hours_to_go = (int)((nb_todo - nb_done) / processed_per_hour)
+            min_to_go = (int)((((nb_todo - nb_done) / processed_per_hour) % 1) * 60)
+            secs_to_go = (int)(
+                ((((nb_todo - nb_done) / processed_per_hour) % 1) * 3600) % 60
+            )
+            time_left_str = f"{hours_to_go:02d}:{min_to_go:02d}:{secs_to_go:02d}"
+            nb_left_str = f"{nb_done:{nb_decimal}n} of {nb_todo:{nb_decimal}n}"
+            pct_str = f"({pct_progress:3.2f}%)    "
+        elif pct_progress >= 100:
+            time_left_str = "00:00:00"
+            nb_left_str = f"{nb_done:{nb_decimal}n} of {nb_todo:{nb_decimal}n}"
+            pct_str = f"({pct_progress:3.2f}%)    "
+        else:
+            return None
+        message = f"{time_left_str} left, {operation} done on {nb_left_str} {pct_str}"
+        return message
+
+
+def formatbytes(bytes: float):
+    """
+    Return the given bytes as a human friendly KB, MB, GB, or TB string.
+    """
+    bytes_float = float(bytes)
+    KB = float(1024)
+    MB = float(KB**2)  # 1,048,576
+    GB = float(KB**3)  # 1,073,741,824
+    TB = float(KB**4)  # 1,099,511,627,776
+
+    if bytes_float < KB:
+        return "{} {}".format(bytes_float, "Bytes" if bytes_float > 1 else "Byte")
+    elif KB <= bytes_float < MB:
+        return f"{bytes_float / KB:.2f} KB"
+    elif MB <= bytes_float < GB:
+        return f"{bytes_float / MB:.2f} MB"
+    elif GB <= bytes_float < TB:
+        return f"{bytes_float / GB:.2f} GB"
+    elif TB <= bytes_float:
+        return f"{bytes_float / TB:.2f} TB"
+
+
+def prepare_for_serialize(data: dict) -> dict:
+    prepared: Dict[str, Any] = {}
+    for key, value in data.items():
+        if isinstance(value, (dict)):
+            prepared[key] = prepare_for_serialize(value)
+        elif isinstance(value, (list, tuple)):
+            prepared[key] = value
+        else:
+            prepared[key] = str(value)
+
+    return prepared
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_geofileinfo.py` & `geofileops-0.8.2/geofileops/util/_geofileinfo.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,289 +1,289 @@
-"""
-Module with information about geofile types.
-"""
-
-import ast
-import csv
-from dataclasses import dataclass
-import enum
-from pathlib import Path
-from typing import Any, Dict, List, Optional, Union, TYPE_CHECKING
-
-from osgeo import gdal
-from osgeo_utils.auxiliary.util import GetOutputDriversFor
-
-if TYPE_CHECKING:
-    import os
-
-# Enable exceptions for GDAL
-gdal.UseExceptions()
-gdal.ogr.UseExceptions()
-
-
-@dataclass
-class GeofileTypeInfo:
-    """
-    Class with properties of a GeofileType.
-    """
-
-    geofiletype: str
-    ogrdriver: str
-    suffixes: Optional[List[str]]
-    is_fid_zerobased: bool
-    is_spatialite_based: bool
-    suffixes_extrafiles: Optional[List[str]]
-
-
-geofiletypes: Dict[str, GeofileTypeInfo] = {}
-
-
-def _init_geofiletypes():
-    geofiletypes_path = Path(__file__).resolve().parent / "geofiletypes.csv"
-    with open(geofiletypes_path) as file:
-        # Set skipinitialspace to True so the csv can be formatted for readability
-        csv.register_dialect("geofiletype_dialect", skipinitialspace=True, strict=True)
-        reader = csv.DictReader(file, dialect="geofiletype_dialect")
-
-        for row in reader:
-            # Prepare optional values that need eval first
-            suffixes = None
-            if row["suffixes"] is not None and row["suffixes"] != "":
-                suffixes = ast.literal_eval(row["suffixes"])
-            suffixes_extrafiles = None
-            if (
-                row["suffixes_extrafiles"] is not None
-                and row["suffixes_extrafiles"] != ""
-            ):
-                suffixes_extrafiles = ast.literal_eval(row["suffixes_extrafiles"])
-
-            # Add geofiletype
-            geofiletypes[row["geofiletype"]] = GeofileTypeInfo(
-                geofiletype=row["geofiletype"],
-                ogrdriver=row["ogrdriver"],
-                suffixes=suffixes,
-                is_fid_zerobased=ast.literal_eval(row["is_fid_zerobased"]),
-                is_spatialite_based=ast.literal_eval(row["is_spatialite_based"]),
-                suffixes_extrafiles=suffixes_extrafiles,
-            )
-
-
-class GeofileType(enum.Enum):
-    """
-    DEPRECATED Enumeration of relevant geo file types and their properties.
-    """
-
-    ESRIShapefile = enum.auto()
-    GeoJSON = enum.auto()
-    GPKG = enum.auto()
-    SQLite = enum.auto()
-    FlatGeobuf = enum.auto()
-
-    @classmethod
-    def _missing_(cls, value):
-        """
-        Expand options in the GeofileType() constructor.
-
-        Args:
-            value (Union[str, int, Driver, Path]):
-                * case insensitive lookup based on suffix
-                * case insensitive lookup based on path
-                * case insensitive lookup based on driver name
-                * GeofileType: create the same GeometryType as the one passed in
-
-        Returns:
-            [GeofileType]: The corresponding GeometryType.
-        """
-
-        def get_geofiletype_for_suffix(suffix: str):
-            suffix_lower = suffix.lower()
-            for geofiletype in geofiletypes:
-                suffixes = geofiletypes[geofiletype].suffixes
-                if suffixes is not None and suffix_lower in suffixes:
-                    return GeofileType[geofiletype]
-            raise ValueError(f"Unknown extension {suffix}")
-
-        def get_geofiletype_for_ogrdriver(ogrdriver: str):
-            for geofiletype in geofiletypes:
-                driver = geofiletypes[geofiletype].ogrdriver
-                if driver is not None and driver == ogrdriver:
-                    return GeofileType[geofiletype]
-            raise ValueError(f"Unknown ogr driver {ogrdriver}")
-
-        if value is None:
-            return None
-        elif isinstance(value, Path):
-            # If it is a Path, return Driver based on the suffix
-            return get_geofiletype_for_suffix(value.suffix)
-        elif isinstance(value, str):
-            if value.startswith("."):
-                # If it start with a point, it is a suffix
-                return get_geofiletype_for_suffix(value)
-            else:
-                # it's probably an ogr driver
-                return get_geofiletype_for_ogrdriver(value)
-        elif isinstance(value, GeofileType):
-            # If a GeofileType is passed in, return same GeofileType.
-            # TODO: why create a new one?
-            return cls(value.value)
-        # Default behaviour (= lookup based on int value)
-        return super()._missing_(value)
-
-    @property
-    def is_fid_zerobased(self) -> bool:
-        """Returns True if the fid is zero based for this GeofileType."""
-        return geofiletypes[self.name].is_fid_zerobased
-
-    @property
-    def is_spatialite_based(self) -> bool:
-        """Returns True if this GeofileType is based on spatialite."""
-        return geofiletypes[self.name].is_spatialite_based
-
-    @property
-    def ogrdriver(self) -> str:
-        """Returns the ogr driver for this GeofileType."""
-        return geofiletypes[self.name].ogrdriver
-
-    @property
-    def suffixes_extrafiles(self) -> List[str]:
-        """Returns a list of suffixes for the extra files for this GeofileType."""
-        suffixes = geofiletypes[self.name].suffixes_extrafiles
-        if suffixes is None:
-            return []
-        return suffixes
-
-    @property
-    def is_singlelayer(self) -> bool:
-        """Returns True if a file of this GeofileType can only have one layer."""
-        if self.is_spatialite_based:
-            return False
-        else:
-            return True
-
-
-# Init!
-_init_geofiletypes()
-
-
-class GeofileInfo:
-    """
-    A data object containing meta-information about a geofile.
-
-    Attributes:
-        driver (str): the relevant gdal driver for the file.
-    """
-
-    def __init__(self, path: Path):
-        """
-        Constructor of Layerinfo.
-
-        Args:
-            path (Path): the path to the file.
-        """
-        self.path = path
-        self.driver = get_driver(path=path)
-        self.geofiletype_info = geofiletypes.get(self.driver.replace(" ", ""))
-
-    def __repr__(self):
-        """Overrides the representation property of GeofileInfo."""
-        return f"{self.__class__}({self.__dict__})"
-
-    @property
-    def is_fid_zerobased(self) -> bool:
-        """Returns True if the fid is zero based."""
-        if self.geofiletype_info is not None:
-            return self.geofiletype_info.is_fid_zerobased
-        else:
-            # Default, not zero-based (at least the case for CSV)
-            return False
-
-    @property
-    def is_spatialite_based(self) -> bool:
-        """Returns True if file driver is based on spatialite."""
-        if self.geofiletype_info is not None:
-            return self.geofiletype_info.is_spatialite_based
-        else:
-            return False
-
-    @property
-    def is_singlelayer(self) -> bool:
-        """Returns True if this geofile can only have one layer."""
-        if (
-            self.geofiletype_info is not None
-            and self.geofiletype_info.is_spatialite_based
-        ):
-            return False
-        else:
-            return True
-
-    @property
-    def suffixes_extrafiles(self) -> List[str]:
-        """Returns a list of suffixes for the extra files for this GeofileType."""
-        if self.geofiletype_info is not None:
-            return self.geofiletype_info.suffixes_extrafiles
-        else:
-            return []
-
-
-def get_driver(path: Union[str, "os.PathLike[Any]"]) -> str:
-    """
-    Get the gdal driver name for the file specified.
-
-    Args:
-        path (PathLike): The file path.
-
-    Returns:
-        str: The OGR driver name.
-    """
-    path = Path(path)
-
-    def get_driver_for_path(input_path) -> str:
-        # If there is no suffix, possibly it is only a suffix, so prefix with filename
-        if input_path.suffix == "":
-            local_path = f"temp{input_path}"
-        else:
-            local_path = input_path
-
-        drivers = GetOutputDriversFor(local_path, is_raster=False)
-        if len(drivers) == 1:
-            return drivers[0]
-        else:
-            raise ValueError(
-                "Could not infer driver from path. Please specify driver explicitly by "
-                "prefixing the file path with '<DRIVER>:', e.g. 'GPKG:path'. "
-                f"Path: {input_path}"
-            )
-
-    # If the file exists, determine the driver based on the file.
-    datasource = None
-    try:
-        datasource = gdal.OpenEx(
-            str(path), nOpenFlags=gdal.OF_VECTOR | gdal.OF_READONLY | gdal.OF_SHARED
-        )
-        driver = datasource.GetDriver()
-        drivername = driver.ShortName
-    except Exception as ex:
-        try:
-            drivername = get_driver_for_path(path)
-        except Exception:
-            ex.args = (f"get_driver error for {path}: {ex}",)
-            raise
-    finally:
-        datasource = None
-
-    return drivername
-
-
-def get_geofileinfo(path: Union[str, "os.PathLike[Any]"]) -> GeofileInfo:
-    """
-    Get information about a geofile.
-
-    Not a public function, as the properties are for internal use and might change in
-    the future.
-
-    Args:
-        path (Union[str, PathLike): the path to the file.
-
-    Returns:
-        GeofileInfo: _description_
-    """
-    return GeofileInfo(path=path)
+"""
+Module with information about geofile types.
+"""
+
+import ast
+import csv
+from dataclasses import dataclass
+import enum
+from pathlib import Path
+from typing import Any, Dict, List, Optional, Union, TYPE_CHECKING
+
+from osgeo import gdal
+from osgeo_utils.auxiliary.util import GetOutputDriversFor
+
+if TYPE_CHECKING:
+    import os
+
+# Enable exceptions for GDAL
+gdal.UseExceptions()
+gdal.ogr.UseExceptions()
+
+
+@dataclass
+class GeofileTypeInfo:
+    """
+    Class with properties of a GeofileType.
+    """
+
+    geofiletype: str
+    ogrdriver: str
+    suffixes: Optional[List[str]]
+    is_fid_zerobased: bool
+    is_spatialite_based: bool
+    suffixes_extrafiles: Optional[List[str]]
+
+
+geofiletypes: Dict[str, GeofileTypeInfo] = {}
+
+
+def _init_geofiletypes():
+    geofiletypes_path = Path(__file__).resolve().parent / "geofiletypes.csv"
+    with open(geofiletypes_path) as file:
+        # Set skipinitialspace to True so the csv can be formatted for readability
+        csv.register_dialect("geofiletype_dialect", skipinitialspace=True, strict=True)
+        reader = csv.DictReader(file, dialect="geofiletype_dialect")
+
+        for row in reader:
+            # Prepare optional values that need eval first
+            suffixes = None
+            if row["suffixes"] is not None and row["suffixes"] != "":
+                suffixes = ast.literal_eval(row["suffixes"])
+            suffixes_extrafiles = None
+            if (
+                row["suffixes_extrafiles"] is not None
+                and row["suffixes_extrafiles"] != ""
+            ):
+                suffixes_extrafiles = ast.literal_eval(row["suffixes_extrafiles"])
+
+            # Add geofiletype
+            geofiletypes[row["geofiletype"]] = GeofileTypeInfo(
+                geofiletype=row["geofiletype"],
+                ogrdriver=row["ogrdriver"],
+                suffixes=suffixes,
+                is_fid_zerobased=ast.literal_eval(row["is_fid_zerobased"]),
+                is_spatialite_based=ast.literal_eval(row["is_spatialite_based"]),
+                suffixes_extrafiles=suffixes_extrafiles,
+            )
+
+
+class GeofileType(enum.Enum):
+    """
+    DEPRECATED Enumeration of relevant geo file types and their properties.
+    """
+
+    ESRIShapefile = enum.auto()
+    GeoJSON = enum.auto()
+    GPKG = enum.auto()
+    SQLite = enum.auto()
+    FlatGeobuf = enum.auto()
+
+    @classmethod
+    def _missing_(cls, value):
+        """
+        Expand options in the GeofileType() constructor.
+
+        Args:
+            value (Union[str, int, Driver, Path]):
+                * case insensitive lookup based on suffix
+                * case insensitive lookup based on path
+                * case insensitive lookup based on driver name
+                * GeofileType: create the same GeometryType as the one passed in
+
+        Returns:
+            [GeofileType]: The corresponding GeometryType.
+        """
+
+        def get_geofiletype_for_suffix(suffix: str):
+            suffix_lower = suffix.lower()
+            for geofiletype in geofiletypes:
+                suffixes = geofiletypes[geofiletype].suffixes
+                if suffixes is not None and suffix_lower in suffixes:
+                    return GeofileType[geofiletype]
+            raise ValueError(f"Unknown extension {suffix}")
+
+        def get_geofiletype_for_ogrdriver(ogrdriver: str):
+            for geofiletype in geofiletypes:
+                driver = geofiletypes[geofiletype].ogrdriver
+                if driver is not None and driver == ogrdriver:
+                    return GeofileType[geofiletype]
+            raise ValueError(f"Unknown ogr driver {ogrdriver}")
+
+        if value is None:
+            return None
+        elif isinstance(value, Path):
+            # If it is a Path, return Driver based on the suffix
+            return get_geofiletype_for_suffix(value.suffix)
+        elif isinstance(value, str):
+            if value.startswith("."):
+                # If it start with a point, it is a suffix
+                return get_geofiletype_for_suffix(value)
+            else:
+                # it's probably an ogr driver
+                return get_geofiletype_for_ogrdriver(value)
+        elif isinstance(value, GeofileType):
+            # If a GeofileType is passed in, return same GeofileType.
+            # TODO: why create a new one?
+            return cls(value.value)
+        # Default behaviour (= lookup based on int value)
+        return super()._missing_(value)
+
+    @property
+    def is_fid_zerobased(self) -> bool:
+        """Returns True if the fid is zero based for this GeofileType."""
+        return geofiletypes[self.name].is_fid_zerobased
+
+    @property
+    def is_spatialite_based(self) -> bool:
+        """Returns True if this GeofileType is based on spatialite."""
+        return geofiletypes[self.name].is_spatialite_based
+
+    @property
+    def ogrdriver(self) -> str:
+        """Returns the ogr driver for this GeofileType."""
+        return geofiletypes[self.name].ogrdriver
+
+    @property
+    def suffixes_extrafiles(self) -> List[str]:
+        """Returns a list of suffixes for the extra files for this GeofileType."""
+        suffixes = geofiletypes[self.name].suffixes_extrafiles
+        if suffixes is None:
+            return []
+        return suffixes
+
+    @property
+    def is_singlelayer(self) -> bool:
+        """Returns True if a file of this GeofileType can only have one layer."""
+        if self.is_spatialite_based:
+            return False
+        else:
+            return True
+
+
+# Init!
+_init_geofiletypes()
+
+
+class GeofileInfo:
+    """
+    A data object containing meta-information about a geofile.
+
+    Attributes:
+        driver (str): the relevant gdal driver for the file.
+    """
+
+    def __init__(self, path: Path):
+        """
+        Constructor of Layerinfo.
+
+        Args:
+            path (Path): the path to the file.
+        """
+        self.path = path
+        self.driver = get_driver(path=path)
+        self.geofiletype_info = geofiletypes.get(self.driver.replace(" ", ""))
+
+    def __repr__(self):
+        """Overrides the representation property of GeofileInfo."""
+        return f"{self.__class__}({self.__dict__})"
+
+    @property
+    def is_fid_zerobased(self) -> bool:
+        """Returns True if the fid is zero based."""
+        if self.geofiletype_info is not None:
+            return self.geofiletype_info.is_fid_zerobased
+        else:
+            # Default, not zero-based (at least the case for CSV)
+            return False
+
+    @property
+    def is_spatialite_based(self) -> bool:
+        """Returns True if file driver is based on spatialite."""
+        if self.geofiletype_info is not None:
+            return self.geofiletype_info.is_spatialite_based
+        else:
+            return False
+
+    @property
+    def is_singlelayer(self) -> bool:
+        """Returns True if this geofile can only have one layer."""
+        if (
+            self.geofiletype_info is not None
+            and self.geofiletype_info.is_spatialite_based
+        ):
+            return False
+        else:
+            return True
+
+    @property
+    def suffixes_extrafiles(self) -> List[str]:
+        """Returns a list of suffixes for the extra files for this GeofileType."""
+        if self.geofiletype_info is not None:
+            return self.geofiletype_info.suffixes_extrafiles
+        else:
+            return []
+
+
+def get_driver(path: Union[str, "os.PathLike[Any]"]) -> str:
+    """
+    Get the gdal driver name for the file specified.
+
+    Args:
+        path (PathLike): The file path.
+
+    Returns:
+        str: The OGR driver name.
+    """
+    path = Path(path)
+
+    def get_driver_for_path(input_path) -> str:
+        # If there is no suffix, possibly it is only a suffix, so prefix with filename
+        if input_path.suffix == "":
+            local_path = f"temp{input_path}"
+        else:
+            local_path = input_path
+
+        drivers = GetOutputDriversFor(local_path, is_raster=False)
+        if len(drivers) == 1:
+            return drivers[0]
+        else:
+            raise ValueError(
+                "Could not infer driver from path. Please specify driver explicitly by "
+                "prefixing the file path with '<DRIVER>:', e.g. 'GPKG:path'. "
+                f"Path: {input_path}"
+            )
+
+    # If the file exists, determine the driver based on the file.
+    datasource = None
+    try:
+        datasource = gdal.OpenEx(
+            str(path), nOpenFlags=gdal.OF_VECTOR | gdal.OF_READONLY | gdal.OF_SHARED
+        )
+        driver = datasource.GetDriver()
+        drivername = driver.ShortName
+    except Exception as ex:
+        try:
+            drivername = get_driver_for_path(path)
+        except Exception:
+            ex.args = (f"get_driver error for {path}: {ex}",)
+            raise
+    finally:
+        datasource = None
+
+    return drivername
+
+
+def get_geofileinfo(path: Union[str, "os.PathLike[Any]"]) -> GeofileInfo:
+    """
+    Get information about a geofile.
+
+    Not a public function, as the properties are for internal use and might change in
+    the future.
+
+    Args:
+        path (Union[str, PathLike): the path to the file.
+
+    Returns:
+        GeofileInfo: _description_
+    """
+    return GeofileInfo(path=path)
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_geoops_gpd.py` & `geofileops-0.8.2/geofileops/util/_geoops_gpd.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,5790 +1,5637 @@
-00000000: 2222 220d 0a4d 6f64 756c 6520 636f 6e74  """..Module cont
-00000010: 6169 6e69 6e67 2074 6865 2069 6d70 6c65  aining the imple
-00000020: 6d65 6e74 6174 696f 6e20 6f66 2047 656f  mentation of Geo
-00000030: 6669 6c65 206f 7065 7261 7469 6f6e 7320  file operations 
-00000040: 7573 696e 6720 4765 6f50 616e 6461 732e  using GeoPandas.
-00000050: 0d0a 2222 220d 0a0d 0a66 726f 6d20 636f  .."""....from co
-00000060: 6e63 7572 7265 6e74 2069 6d70 6f72 7420  ncurrent import 
-00000070: 6675 7475 7265 730d 0a69 6d70 6f72 7420  futures..import 
-00000080: 636f 7079 0d0a 6672 6f6d 2064 6174 6574  copy..from datet
-00000090: 696d 6520 696d 706f 7274 2064 6174 6574  ime import datet
-000000a0: 696d 650d 0a69 6d70 6f72 7420 656e 756d  ime..import enum
-000000b0: 0d0a 696d 706f 7274 206a 736f 6e0d 0a69  ..import json..i
-000000c0: 6d70 6f72 7420 6c6f 6767 696e 670d 0a69  mport logging..i
-000000d0: 6d70 6f72 7420 6c6f 6767 696e 672e 636f  mport logging.co
-000000e0: 6e66 6967 0d0a 696d 706f 7274 206d 6174  nfig..import mat
-000000f0: 680d 0a69 6d70 6f72 7420 6d75 6c74 6970  h..import multip
-00000100: 726f 6365 7373 696e 670d 0a66 726f 6d20  rocessing..from 
-00000110: 7061 7468 6c69 6220 696d 706f 7274 2050  pathlib import P
-00000120: 6174 680d 0a69 6d70 6f72 7420 7069 636b  ath..import pick
-00000130: 6c65 0d0a 696d 706f 7274 2072 650d 0a69  le..import re..i
-00000140: 6d70 6f72 7420 7368 7574 696c 0d0a 696d  mport shutil..im
-00000150: 706f 7274 2074 696d 650d 0a66 726f 6d20  port time..from 
-00000160: 7479 7069 6e67 2069 6d70 6f72 7420 416e  typing import An
-00000170: 792c 2043 616c 6c61 626c 652c 2044 6963  y, Callable, Dic
-00000180: 742c 2049 7465 7261 626c 652c 204c 6973  t, Iterable, Lis
-00000190: 742c 204f 7074 696f 6e61 6c2c 2053 6574  t, Optional, Set
-000001a0: 2c20 5475 706c 652c 2055 6e69 6f6e 0d0a  , Tuple, Union..
-000001b0: 696d 706f 7274 2077 6172 6e69 6e67 730d  import warnings.
-000001c0: 0a0d 0a69 6d70 6f72 7420 636c 6f75 6470  ...import cloudp
-000001d0: 6963 6b6c 650d 0a69 6d70 6f72 7420 6765  ickle..import ge
-000001e0: 6f70 616e 6461 7320 6173 2067 7064 0d0a  opandas as gpd..
-000001f0: 696d 706f 7274 206e 756d 7079 2061 7320  import numpy as 
-00000200: 6e70 0d0a 696d 706f 7274 2070 616e 6461  np..import panda
-00000210: 7320 6173 2070 640d 0a69 6d70 6f72 7420  s as pd..import 
-00000220: 7079 6765 6f6f 7073 0d0a 696d 706f 7274  pygeoops..import
-00000230: 2070 7375 7469 6c0d 0a0d 0a66 726f 6d20   psutil....from 
-00000240: 7079 6765 6f6f 7073 2069 6d70 6f72 7420  pygeoops import 
-00000250: 4765 6f6d 6574 7279 5479 7065 2c20 5072  GeometryType, Pr
-00000260: 696d 6974 6976 6554 7970 650d 0a69 6d70  imitiveType..imp
-00000270: 6f72 7420 7368 6170 656c 790d 0a69 6d70  ort shapely..imp
-00000280: 6f72 7420 7368 6170 656c 792e 6765 6f6d  ort shapely.geom
-00000290: 6574 7279 2061 7320 7368 5f67 656f 6d0d  etry as sh_geom.
-000002a0: 0a0d 0a69 6d70 6f72 7420 6765 6f66 696c  ...import geofil
-000002b0: 656f 7073 2061 7320 6766 6f0d 0a66 726f  eops as gfo..fro
-000002c0: 6d20 6765 6f66 696c 656f 7073 2069 6d70  m geofileops imp
-000002d0: 6f72 7420 6669 6c65 6f70 730d 0a66 726f  ort fileops..fro
-000002e0: 6d20 6765 6f66 696c 656f 7073 2e68 656c  m geofileops.hel
-000002f0: 7065 7273 2069 6d70 6f72 7420 5f70 6172  pers import _par
-00000300: 616d 6574 6572 5f68 656c 7065 720d 0a66  ameter_helper..f
-00000310: 726f 6d20 6765 6f66 696c 656f 7073 2e75  rom geofileops.u
-00000320: 7469 6c20 696d 706f 7274 205f 6765 6e65  til import _gene
-00000330: 7261 6c5f 7574 696c 0d0a 6672 6f6d 2067  ral_util..from g
-00000340: 656f 6669 6c65 6f70 732e 7574 696c 2069  eofileops.util i
-00000350: 6d70 6f72 7420 5f67 656f 6f70 735f 7371  mport _geoops_sq
-00000360: 6c0d 0a66 726f 6d20 6765 6f66 696c 656f  l..from geofileo
-00000370: 7073 2e75 7469 6c20 696d 706f 7274 205f  ps.util import _
-00000380: 6765 6f73 6572 6965 735f 7574 696c 0d0a  geoseries_util..
-00000390: 6672 6f6d 2067 656f 6669 6c65 6f70 732e  from geofileops.
-000003a0: 7574 696c 2069 6d70 6f72 7420 5f69 6f5f  util import _io_
-000003b0: 7574 696c 0d0a 6672 6f6d 2067 656f 6669  util..from geofi
-000003c0: 6c65 6f70 732e 7574 696c 2069 6d70 6f72  leops.util impor
-000003d0: 7420 5f6f 6772 5f75 7469 6c0d 0a66 726f  t _ogr_util..fro
-000003e0: 6d20 6765 6f66 696c 656f 7073 2e75 7469  m geofileops.uti
-000003f0: 6c20 696d 706f 7274 205f 7072 6f63 6573  l import _proces
-00000400: 7369 6e67 5f75 7469 6c0d 0a66 726f 6d20  sing_util..from 
-00000410: 6765 6f66 696c 656f 7073 2e75 7469 6c2e  geofileops.util.
-00000420: 5f67 656f 6d65 7472 795f 7574 696c 2069  _geometry_util i
-00000430: 6d70 6f72 7420 5369 6d70 6c69 6679 416c  mport SimplifyAl
-00000440: 676f 7269 7468 6d0d 0a66 726f 6d20 6765  gorithm..from ge
-00000450: 6f66 696c 656f 7073 2e75 7469 6c2e 5f67  ofileops.util._g
-00000460: 656f 6d65 7472 795f 7574 696c 2069 6d70  eometry_util imp
-00000470: 6f72 7420 4275 6666 6572 456e 6443 6170  ort BufferEndCap
-00000480: 5374 796c 652c 2042 7566 6665 724a 6f69  Style, BufferJoi
-00000490: 6e53 7479 6c65 0d0a 0d0a 2320 446f 6e27  nStyle....# Don'
-000004a0: 7420 7368 6f77 2074 6869 7320 6765 6f70  t show this geop
-000004b0: 616e 6461 7320 7761 726e 696e 672e 2e2e  andas warning...
-000004c0: 0d0a 7761 726e 696e 6773 2e66 696c 7465  ..warnings.filte
-000004d0: 7277 6172 6e69 6e67 7328 2269 676e 6f72  rwarnings("ignor
-000004e0: 6522 2c20 2247 656f 5365 7269 6573 2e69  e", "GeoSeries.i
-000004f0: 736e 6122 2c20 5573 6572 5761 726e 696e  sna", UserWarnin
-00000500: 6729 0d0a 0d0a 6c6f 6767 6572 203d 206c  g)....logger = l
-00000510: 6f67 6769 6e67 2e67 6574 4c6f 6767 6572  ogging.getLogger
-00000520: 285f 5f6e 616d 655f 5f29 0d0a 0d0a 0d0a  (__name__)......
-00000530: 636c 6173 7320 5061 7261 6c6c 656c 697a  class Paralleliz
-00000540: 6174 696f 6e43 6f6e 6669 673a 0d0a 2020  ationConfig:..  
-00000550: 2020 2222 220d 0a20 2020 2048 6575 7269    """..    Heuri
-00000560: 7374 6963 7320 666f 7220 6765 6f70 616e  stics for geopan
-00000570: 6461 7320 6261 7365 6420 6765 6f20 6f70  das based geo op
-00000580: 6572 6174 696f 6e73 2e0d 0a0d 0a20 2020  erations.....   
-00000590: 2048 6575 7269 7374 6963 7320 6d65 616e   Heuristics mean
-000005a0: 7420 746f 2062 6520 6162 6c65 2074 6f20  t to be able to 
-000005b0: 6f70 7469 6d69 7a65 2074 6865 2070 6172  optimize the par
-000005c0: 616c 6c65 6c69 7361 7469 6f6e 2070 6172  allelisation par
-000005d0: 616d 6574 6572 7320 666f 720d 0a20 2020  ameters for..   
-000005e0: 2067 656f 7061 6e64 6173 2062 6173 6564   geopandas based
-000005f0: 2067 656f 206f 7065 7261 7469 6f6e 2e0d   geo operation..
-00000600: 0a20 2020 2022 2222 0d0a 0d0a 2020 2020  .    """....    
-00000610: 6465 6620 5f5f 696e 6974 5f5f 280d 0a20  def __init__(.. 
-00000620: 2020 2020 2020 2073 656c 662c 0d0a 2020         self,..  
-00000630: 2020 2020 2020 6279 7465 735f 6261 7365        bytes_base
-00000640: 666f 6f74 7072 696e 743a 2069 6e74 203d  footprint: int =
-00000650: 2035 3020 2a20 3130 3234 202a 2031 3032   50 * 1024 * 102
-00000660: 342c 0d0a 2020 2020 2020 2020 6279 7465  4,..        byte
-00000670: 735f 7065 725f 726f 773a 2069 6e74 203d  s_per_row: int =
-00000680: 2031 3030 302c 0d0a 2020 2020 2020 2020   1000,..        
-00000690: 6d69 6e5f 726f 7773 5f70 6572 5f62 6174  min_rows_per_bat
-000006a0: 6368 3a20 696e 7420 3d20 3130 3030 2c0d  ch: int = 1000,.
-000006b0: 0a20 2020 2020 2020 206d 6178 5f72 6f77  .        max_row
-000006c0: 735f 7065 725f 6261 7463 683a 2069 6e74  s_per_batch: int
-000006d0: 203d 2031 3030 3030 302c 0d0a 2020 2020   = 100000,..    
-000006e0: 2020 2020 6279 7465 735f 6d69 6e5f 7065      bytes_min_pe
-000006f0: 725f 7072 6f63 6573 733a 204f 7074 696f  r_process: Optio
-00000700: 6e61 6c5b 696e 745d 203d 204e 6f6e 652c  nal[int] = None,
-00000710: 0d0a 2020 2020 2020 2020 6279 7465 735f  ..        bytes_
-00000720: 7573 6162 6c65 3a20 4f70 7469 6f6e 616c  usable: Optional
-00000730: 5b69 6e74 5d20 3d20 4e6f 6e65 2c0d 0a20  [int] = None,.. 
-00000740: 2020 2020 2020 2063 7075 5f63 6f75 6e74         cpu_count
-00000750: 3a20 696e 7420 3d20 2d31 2c0d 0a20 2020  : int = -1,..   
-00000760: 2029 3a0d 0a20 2020 2020 2020 2022 2222   ):..        """
-00000770: 0d0a 2020 2020 2020 2020 4865 7572 6973  ..        Heuris
-00000780: 7469 6373 2066 6f72 2067 656f 7061 6e64  tics for geopand
-00000790: 6173 2062 6173 6564 2067 656f 206f 7065  as based geo ope
-000007a0: 7261 7469 6f6e 732e 0d0a 0d0a 2020 2020  rations.....    
-000007b0: 2020 2020 4865 7572 6973 7469 6373 206d      Heuristics m
-000007c0: 6561 6e74 2074 6f20 6265 2061 626c 6520  eant to be able 
-000007d0: 746f 206f 7074 696d 697a 6520 7468 6520  to optimize the 
-000007e0: 7061 7261 6c6c 656c 6973 6174 696f 6e20  parallelisation 
-000007f0: 7061 7261 6d65 7465 7273 2066 6f72 0d0a  parameters for..
-00000800: 2020 2020 2020 2020 6765 6f70 616e 6461          geopanda
-00000810: 7320 6261 7365 6420 6765 6f20 6f70 6572  s based geo oper
-00000820: 6174 696f 6e2e 0d0a 0d0a 2020 2020 2020  ation.....      
-00000830: 2020 4172 6773 3a0d 0a20 2020 2020 2020    Args:..       
-00000840: 2020 2020 2062 7974 6573 5f62 6173 6566       bytes_basef
-00000850: 6f6f 7470 7269 6e74 2028 696e 742c 206f  ootprint (int, o
-00000860: 7074 696f 6e61 6c29 3a20 5468 6520 6261  ptional): The ba
-00000870: 7365 206d 656d 6f72 7920 7573 6167 6520  se memory usage 
-00000880: 6f66 2061 2067 656f 6669 6c65 6f70 730d  of a geofileops.
-00000890: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000008a0: 2077 6f72 6b65 7220 7072 6f63 6573 732e   worker process.
-000008b0: 2044 6566 6175 6c74 7320 746f 2035 3020   Defaults to 50 
-000008c0: 4d42 2e0d 0a20 2020 2020 2020 2020 2020  MB...           
-000008d0: 2062 7974 6573 5f70 6572 5f72 6f77 2028   bytes_per_row (
-000008e0: 696e 742c 206f 7074 696f 6e61 6c29 3a20  int, optional): 
-000008f0: 5468 6520 6e75 6d62 6572 2069 6620 6279  The number if by
-00000900: 7465 7320 6e65 6564 6564 2074 6f20 7374  tes needed to st
-00000910: 6f72 652f 7072 6f63 6573 730d 0a20 2020  ore/process..   
-00000920: 2020 2020 2020 2020 2020 2020 206f 6e65               one
-00000930: 2072 6f77 206f 6620 6461 7461 2e20 4465   row of data. De
-00000940: 6661 756c 7473 2074 6f20 3130 3030 2e0d  faults to 1000..
-00000950: 0a20 2020 2020 2020 2020 2020 206d 696e  .            min
-00000960: 5f72 6f77 735f 7065 725f 6261 7463 6820  _rows_per_batch 
-00000970: 2869 6e74 2c20 6f70 7469 6f6e 616c 293a  (int, optional):
-00000980: 2054 6865 206d 696e 696d 756d 206e 756d   The minimum num
-00000990: 6265 7220 6f66 2072 6f77 7320 746f 2061  ber of rows to a
-000009a0: 696d 2066 6f72 2069 6e0d 0a20 2020 2020  im for in..     
-000009b0: 2020 2020 2020 2020 2020 206f 6e65 2062             one b
-000009c0: 6174 6368 2e20 4465 6661 756c 7473 2074  atch. Defaults t
-000009d0: 6f20 3130 3030 2e0d 0a20 2020 2020 2020  o 1000...       
-000009e0: 2020 2020 206d 6178 5f72 6f77 735f 7065       max_rows_pe
-000009f0: 725f 6261 7463 6820 2869 6e74 2c20 6f70  r_batch (int, op
-00000a00: 7469 6f6e 616c 293a 2054 6865 206d 6178  tional): The max
-00000a10: 696d 756d 206e 756d 6265 7220 6f66 2072  imum number of r
-00000a20: 6f77 7320 746f 2061 696d 2066 6f72 2069  ows to aim for i
-00000a30: 6e0d 0a20 2020 2020 2020 2020 2020 2020  n..             
-00000a40: 2020 2061 2062 6174 6368 2e20 4465 6661     a batch. Defa
-00000a50: 756c 7473 2074 6f20 3130 3030 3030 2e0d  ults to 100000..
-00000a60: 0a20 2020 2020 2020 2020 2020 2062 7974  .            byt
-00000a70: 6573 5f6d 696e 5f70 6572 5f70 726f 6365  es_min_per_proce
-00000a80: 7373 2028 4f70 7469 6f6e 616c 5b69 6e74  ss (Optional[int
-00000a90: 5d2c 206f 7074 696f 6e61 6c29 3a20 5468  ], optional): Th
-00000aa0: 6520 6d69 6e69 6d75 6d20 6e75 6d62 6572  e minimum number
-00000ab0: 206f 6620 6279 7465 730d 0a20 2020 2020   of bytes..     
-00000ac0: 2020 2020 2020 2020 2020 206e 6565 6465             neede
-00000ad0: 6420 666f 7220 6120 6765 6f66 696c 656f  d for a geofileo
-00000ae0: 7073 2077 6f72 6b65 7220 7072 6f63 6573  ps worker proces
-00000af0: 732e 2044 6566 6175 6c74 7320 746f 204e  s. Defaults to N
-00000b00: 6f6e 652e 0d0a 2020 2020 2020 2020 2020  one...          
-00000b10: 2020 6279 7465 735f 7573 6162 6c65 2028    bytes_usable (
-00000b20: 4f70 7469 6f6e 616c 5b69 6e74 5d2c 206f  Optional[int], o
-00000b30: 7074 696f 6e61 6c29 3a20 7468 6520 6d65  ptional): the me
-00000b40: 6d6f 7279 2061 7661 696c 6162 6c65 2066  mory available f
-00000b50: 6f72 2070 726f 6365 7373 696e 672e 0d0a  or processing...
-00000b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000b70: 4465 6661 756c 7473 2074 6f20 4e6f 6e65  Defaults to None
-00000b80: 2c20 7468 656e 2074 6865 2066 7265 6520  , then the free 
-00000b90: 6d65 6d6f 7279 2069 7320 6175 746f 6d61  memory is automa
-00000ba0: 7469 6361 6c6c 7920 6465 7465 726d 696e  tically determin
-00000bb0: 6564 2e0d 0a20 2020 2020 2020 2020 2020  ed...           
-00000bc0: 2063 7075 5f63 6f75 6e74 2028 696e 742c   cpu_count (int,
-00000bd0: 206f 7074 696f 6e61 6c29 3a20 7468 6520   optional): the 
-00000be0: 6e75 6d62 6572 206f 6620 4350 5527 7320  number of CPU's 
-00000bf0: 6176 6169 6c61 626c 652e 2044 6566 6175  available. Defau
-00000c00: 6c74 7320 746f 202d 312c 0d0a 2020 2020  lts to -1,..    
-00000c10: 2020 2020 2020 2020 2020 2020 7468 656e              then
-00000c20: 2074 6865 2063 7075 5f63 6f75 6e74 2069   the cpu_count i
-00000c30: 7320 6465 7465 726d 696e 6564 2061 7574  s determined aut
-00000c40: 6f6d 6174 6963 616c 6c79 2e0d 0a20 2020  omatically...   
-00000c50: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-00000c60: 2020 7365 6c66 2e62 7974 6573 5f62 6173    self.bytes_bas
-00000c70: 6566 6f6f 7470 7269 6e74 203d 2062 7974  efootprint = byt
-00000c80: 6573 5f62 6173 6566 6f6f 7470 7269 6e74  es_basefootprint
-00000c90: 0d0a 2020 2020 2020 2020 7365 6c66 2e62  ..        self.b
-00000ca0: 7974 6573 5f70 6572 5f72 6f77 203d 2062  ytes_per_row = b
-00000cb0: 7974 6573 5f70 6572 5f72 6f77 0d0a 2020  ytes_per_row..  
-00000cc0: 2020 2020 2020 7365 6c66 2e6d 696e 5f72        self.min_r
-00000cd0: 6f77 735f 7065 725f 6261 7463 6820 3d20  ows_per_batch = 
-00000ce0: 6d69 6e5f 726f 7773 5f70 6572 5f62 6174  min_rows_per_bat
-00000cf0: 6368 0d0a 2020 2020 2020 2020 7365 6c66  ch..        self
-00000d00: 2e6d 6178 5f72 6f77 735f 7065 725f 6261  .max_rows_per_ba
-00000d10: 7463 6820 3d20 6d61 785f 726f 7773 5f70  tch = max_rows_p
-00000d20: 6572 5f62 6174 6368 0d0a 0d0a 2020 2020  er_batch....    
-00000d30: 2020 2020 2320 4e65 6564 7320 736f 6d65      # Needs some
-00000d40: 206c 6f67 6963 2074 6f20 6765 7420 7661   logic to get va
-00000d50: 6c75 6520 6966 206e 6f74 2073 6574 2065  lue if not set e
-00000d60: 7870 6c69 6369 746c 792e 2e2e 0d0a 2020  xplicitly.....  
-00000d70: 2020 2020 2020 7365 6c66 2e5f 6279 7465        self._byte
-00000d80: 735f 6d69 6e5f 7065 725f 7072 6f63 6573  s_min_per_proces
-00000d90: 7320 3d20 6279 7465 735f 6d69 6e5f 7065  s = bytes_min_pe
-00000da0: 725f 7072 6f63 6573 730d 0a20 2020 2020  r_process..     
-00000db0: 2020 2023 2049 6620 6e6f 7420 7370 6563     # If not spec
-00000dc0: 6966 6965 642c 2064 6574 6572 6d69 6e65  ified, determine
-00000dd0: 2079 6f75 7273 656c 660d 0a20 2020 2020   yourself..     
-00000de0: 2020 2073 656c 662e 6279 7465 735f 7573     self.bytes_us
-00000df0: 6162 6c65 203d 2028 0d0a 2020 2020 2020  able = (..      
-00000e00: 2020 2020 2020 6279 7465 735f 7573 6162        bytes_usab
-00000e10: 6c65 0d0a 2020 2020 2020 2020 2020 2020  le..            
-00000e20: 6966 2062 7974 6573 5f75 7361 626c 6520  if bytes_usable 
-00000e30: 6973 206e 6f74 204e 6f6e 650d 0a20 2020  is not None..   
-00000e40: 2020 2020 2020 2020 2065 6c73 6520 696e           else in
-00000e50: 7428 7073 7574 696c 2e76 6972 7475 616c  t(psutil.virtual
-00000e60: 5f6d 656d 6f72 7928 292e 6176 6169 6c61  _memory().availa
-00000e70: 626c 6520 2a20 302e 3929 0d0a 2020 2020  ble * 0.9)..    
-00000e80: 2020 2020 290d 0a20 2020 2020 2020 2023      )..        #
-00000e90: 2049 6620 6e6f 7420 7370 6563 6966 6965   If not specifie
-00000ea0: 642c 2064 6574 6572 6d69 6e65 2079 6f75  d, determine you
-00000eb0: 7273 656c 660d 0a20 2020 2020 2020 2073  rself..        s
-00000ec0: 656c 662e 6370 755f 636f 756e 7420 3d20  elf.cpu_count = 
-00000ed0: 6370 755f 636f 756e 7420 6966 2063 7075  cpu_count if cpu
-00000ee0: 5f63 6f75 6e74 203e 2030 2065 6c73 6520  _count > 0 else 
-00000ef0: 6d75 6c74 6970 726f 6365 7373 696e 672e  multiprocessing.
-00000f00: 6370 755f 636f 756e 7428 290d 0a0d 0a20  cpu_count().... 
-00000f10: 2020 2040 7072 6f70 6572 7479 0d0a 2020     @property..  
-00000f20: 2020 6465 6620 6279 7465 735f 6d69 6e5f    def bytes_min_
-00000f30: 7065 725f 7072 6f63 6573 7328 7365 6c66  per_process(self
-00000f40: 293a 0d0a 2020 2020 2020 2020 6966 2073  ):..        if s
-00000f50: 656c 662e 5f62 7974 6573 5f6d 696e 5f70  elf._bytes_min_p
-00000f60: 6572 5f70 726f 6365 7373 2069 7320 6e6f  er_process is no
-00000f70: 7420 4e6f 6e65 3a0d 0a20 2020 2020 2020  t None:..       
-00000f80: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00000f90: 2e5f 6279 7465 735f 6d69 6e5f 7065 725f  ._bytes_min_per_
-00000fa0: 7072 6f63 6573 730d 0a20 2020 2020 2020  process..       
-00000fb0: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-00000fc0: 2020 2020 7265 7475 726e 2028 0d0a 2020      return (..  
-00000fd0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00000fe0: 6c66 2e62 7974 6573 5f62 6173 6566 6f6f  lf.bytes_basefoo
-00000ff0: 7470 7269 6e74 202b 2073 656c 662e 6279  tprint + self.by
-00001000: 7465 735f 7065 725f 726f 7720 2a20 7365  tes_per_row * se
-00001010: 6c66 2e6d 696e 5f72 6f77 735f 7065 725f  lf.min_rows_per_
-00001020: 6261 7463 680d 0a20 2020 2020 2020 2020  batch..         
-00001030: 2020 2029 0d0a 0d0a 2020 2020 4062 7974     )....    @byt
-00001040: 6573 5f6d 696e 5f70 6572 5f70 726f 6365  es_min_per_proce
-00001050: 7373 2e73 6574 7465 720d 0a20 2020 2064  ss.setter..    d
-00001060: 6566 2062 7974 6573 5f6d 696e 5f70 6572  ef bytes_min_per
-00001070: 5f70 726f 6365 7373 2873 656c 662c 2076  _process(self, v
-00001080: 616c 7565 293a 0d0a 2020 2020 2020 2020  alue):..        
-00001090: 7365 6c66 2e5f 6279 7465 735f 6d69 6e5f  self._bytes_min_
-000010a0: 7065 725f 7072 6f63 6573 7320 3d20 7661  per_process = va
-000010b0: 6c75 650d 0a0d 0a0d 0a64 6566 205f 6465  lue......def _de
-000010c0: 7465 726d 696e 655f 6e62 5f62 6174 6368  termine_nb_batch
-000010d0: 6573 280d 0a20 2020 206e 625f 726f 7773  es(..    nb_rows
-000010e0: 5f74 6f74 616c 3a20 696e 742c 0d0a 2020  _total: int,..  
-000010f0: 2020 6e62 5f70 6172 616c 6c65 6c3a 2069    nb_parallel: i
-00001100: 6e74 203d 202d 312c 0d0a 2020 2020 6261  nt = -1,..    ba
-00001110: 7463 6873 697a 653a 2069 6e74 203d 202d  tchsize: int = -
-00001120: 312c 0d0a 2020 2020 7061 7261 6c6c 656c  1,..    parallel
-00001130: 697a 6174 696f 6e5f 636f 6e66 6967 3a20  ization_config: 
-00001140: 4f70 7469 6f6e 616c 5b50 6172 616c 6c65  Optional[Paralle
-00001150: 6c69 7a61 7469 6f6e 436f 6e66 6967 5d20  lizationConfig] 
-00001160: 3d20 4e6f 6e65 2c0d 0a29 202d 3e20 5475  = None,..) -> Tu
-00001170: 706c 655b 696e 742c 2069 6e74 5d3a 0d0a  ple[int, int]:..
-00001180: 2020 2020 2222 220d 0a20 2020 2044 6574      """..    Det
-00001190: 6572 6d69 6e65 7320 7265 636f 6d6d 656e  ermines recommen
-000011a0: 6465 6420 7061 7261 6c6c 656c 697a 6174  ded parallelizat
-000011b0: 696f 6e20 7061 7261 6d73 2e0d 0a0d 0a20  ion params..... 
-000011c0: 2020 2041 7267 733a 0d0a 2020 2020 2020     Args:..      
-000011d0: 2020 6e62 5f72 6f77 735f 746f 7461 6c20    nb_rows_total 
-000011e0: 2869 6e74 293a 2054 6865 2074 6f74 616c  (int): The total
-000011f0: 206e 756d 6265 7220 6f66 2072 6f77 7320   number of rows 
-00001200: 7468 6174 2077 696c 6c20 6265 2070 726f  that will be pro
-00001210: 6365 7373 6564 0d0a 2020 2020 2020 2020  cessed..        
-00001220: 6e62 5f70 6172 616c 6c65 6c20 2869 6e74  nb_parallel (int
-00001230: 293a 2054 6865 206c 6576 656c 206f 6620  ): The level of 
-00001240: 7061 7261 6c6c 656c 697a 6174 696f 6e20  parallelization 
-00001250: 7265 7175 6573 7465 642e 0d0a 2020 2020  requested...    
-00001260: 2020 2020 2020 2020 4966 202d 312c 2074          If -1, t
-00001270: 7269 6573 2074 6f20 7573 6520 616c 6c20  ries to use all 
-00001280: 7265 736f 7572 6365 7320 6176 6169 6c61  resources availa
-00001290: 626c 652e 0d0a 2020 2020 2020 2020 6261  ble...        ba
-000012a0: 7463 6873 697a 6520 2869 6e74 293a 2069  tchsize (int): i
-000012b0: 6e64 6963 6174 6976 6520 6e75 6d62 6572  ndicative number
-000012c0: 206f 6620 726f 7773 2074 6f20 7072 6f63   of rows to proc
-000012d0: 6573 7320 7065 7220 6261 7463 682e 0d0a  ess per batch...
-000012e0: 2020 2020 2020 2020 2020 2020 4966 202d              If -
-000012f0: 313a 2028 7472 7920 746f 2920 6465 7465  1: (try to) dete
-00001300: 726d 696e 6520 6f70 7469 6d61 6c20 7369  rmine optimal si
-00001310: 7a65 2061 7574 6f6d 6174 6963 616c 6c79  ze automatically
-00001320: 2075 7369 6e67 2074 6865 2068 6575 7269   using the heuri
-00001330: 7374 6963 7320 696e 0d0a 2020 2020 2020  stics in..      
-00001340: 2020 2020 2020 2770 6172 616c 6c65 6c69        'paralleli
-00001350: 7a61 7469 6f6e 5f63 6f6e 6669 6727 2e0d  zation_config'..
-00001360: 0a20 2020 2020 2020 2070 6172 616c 6c65  .        paralle
-00001370: 6c69 7a61 7469 6f6e 5f63 6f6e 6669 6720  lization_config 
-00001380: 2850 6172 616c 6c65 6c69 7a61 7469 6f6e  (Parallelization
-00001390: 436f 6e66 6967 2c20 6f70 7469 6f6e 616c  Config, optional
-000013a0: 293a 2043 6f6e 6669 6775 7261 7469 6f6e  ): Configuration
-000013b0: 0d0a 2020 2020 2020 2020 2020 2020 7061  ..            pa
-000013c0: 7261 6d65 7465 7273 2074 6f20 7573 6520  rameters to use 
-000013d0: 746f 2073 7567 6765 7374 2070 6172 616c  to suggest paral
-000013e0: 6c65 6c69 7361 7469 6f6e 2070 6172 616d  lelisation param
-000013f0: 6574 6572 732e 0d0a 0d0a 2020 2020 5265  eters.....    Re
-00001400: 7475 726e 733a 0d0a 2020 2020 2020 2020  turns:..        
-00001410: 5475 706c 655b 696e 742c 2069 6e74 5d3a  Tuple[int, int]:
-00001420: 2054 7570 6c65 206f 6620 286e 625f 7061   Tuple of (nb_pa
-00001430: 7261 6c6c 656c 2c20 6e62 5f62 6174 6368  rallel, nb_batch
-00001440: 6573 290d 0a20 2020 2022 2222 0d0a 2020  es)..    """..  
-00001450: 2020 2320 4966 2030 206f 7220 3120 726f    # If 0 or 1 ro
-00001460: 7773 2074 6f20 7072 6f63 6573 732c 206f  ws to process, o
-00001470: 6e65 2062 6174 6368 0d0a 2020 2020 6966  ne batch..    if
-00001480: 206e 625f 726f 7773 5f74 6f74 616c 203c   nb_rows_total <
-00001490: 3d20 313a 0d0a 2020 2020 2020 2020 7265  = 1:..        re
-000014a0: 7475 726e 2028 312c 2031 290d 0a0d 0a20  turn (1, 1).... 
-000014b0: 2020 2023 2049 6620 636f 6e66 6967 2069     # If config i
-000014c0: 7320 4e6f 6e65 2c20 7573 6520 6465 6661  s None, use defa
-000014d0: 756c 7420 636f 6e66 6967 0d0a 2020 2020  ult config..    
-000014e0: 6966 2070 6172 616c 6c65 6c69 7a61 7469  if parallelizati
-000014f0: 6f6e 5f63 6f6e 6669 6720 6973 204e 6f6e  on_config is Non
-00001500: 653a 0d0a 2020 2020 2020 2020 636f 6e66  e:..        conf
-00001510: 6967 5f6c 6f63 616c 203d 2050 6172 616c  ig_local = Paral
-00001520: 6c65 6c69 7a61 7469 6f6e 436f 6e66 6967  lelizationConfig
-00001530: 2829 0d0a 2020 2020 656c 7365 3a0d 0a20  ()..    else:.. 
-00001540: 2020 2020 2020 2063 6f6e 6669 675f 6c6f         config_lo
-00001550: 6361 6c20 3d20 636f 7079 2e64 6565 7063  cal = copy.deepc
-00001560: 6f70 7928 7061 7261 6c6c 656c 697a 6174  opy(parallelizat
-00001570: 696f 6e5f 636f 6e66 6967 290d 0a0d 0a20  ion_config).... 
-00001580: 2020 2023 2049 6620 7468 6520 6e75 6d62     # If the numb
-00001590: 6572 206f 6620 726f 7773 2069 7320 7265  er of rows is re
-000015a0: 616c 6c79 206c 6f77 2c20 6a75 7374 2075  ally low, just u
-000015b0: 7365 206f 6e65 2062 6174 6368 0d0a 2020  se one batch..  
-000015c0: 2020 6966 206e 625f 7061 7261 6c6c 656c    if nb_parallel
-000015d0: 203c 2031 2061 6e64 2062 6174 6368 7369   < 1 and batchsi
-000015e0: 7a65 203c 2031 3a0d 0a20 2020 2020 2020  ze < 1:..       
-000015f0: 2069 6620 6e62 5f72 6f77 735f 746f 7461   if nb_rows_tota
-00001600: 6c20 3c3d 2063 6f6e 6669 675f 6c6f 6361  l <= config_loca
-00001610: 6c2e 6d69 6e5f 726f 7773 5f70 6572 5f62  l.min_rows_per_b
-00001620: 6174 6368 3a0d 0a20 2020 2020 2020 2020  atch:..         
-00001630: 2020 2072 6574 7572 6e20 2831 2c20 3129     return (1, 1)
-00001640: 0d0a 0d0a 2020 2020 6966 206e 625f 7061  ....    if nb_pa
-00001650: 7261 6c6c 656c 203c 3d20 303a 0d0a 2020  rallel <= 0:..  
-00001660: 2020 2020 2020 6e62 5f70 6172 616c 6c65        nb_paralle
-00001670: 6c20 3d20 636f 6e66 6967 5f6c 6f63 616c  l = config_local
-00001680: 2e63 7075 5f63 6f75 6e74 0d0a 0d0a 2020  .cpu_count....  
-00001690: 2020 6966 206c 6f67 6765 722e 6973 456e    if logger.isEn
-000016a0: 6162 6c65 6446 6f72 286c 6f67 6769 6e67  abledFor(logging
-000016b0: 2e44 4542 5547 293a 0d0a 2020 2020 2020  .DEBUG):..      
-000016c0: 2020 6d65 6d5f 7573 6162 6c65 203d 205f    mem_usable = _
-000016d0: 6765 6e65 7261 6c5f 7574 696c 2e66 6f72  general_util.for
-000016e0: 6d61 7462 7974 6573 2863 6f6e 6669 675f  matbytes(config_
-000016f0: 6c6f 6361 6c2e 6279 7465 735f 7573 6162  local.bytes_usab
-00001700: 6c65 290d 0a20 2020 2020 2020 206c 6f67  le)..        log
-00001710: 6765 722e 6465 6275 6728 6622 6d65 6d6f  ger.debug(f"memo
-00001720: 7279 5f75 7361 626c 653a 207b 6d65 6d5f  ry_usable: {mem_
-00001730: 7573 6162 6c65 7d2c 2077 6974 683a 2229  usable}, with:")
-00001740: 0d0a 2020 2020 2020 2020 6d65 6d5f 6176  ..        mem_av
-00001750: 6169 6c61 626c 6520 3d20 5f67 656e 6572  ailable = _gener
-00001760: 616c 5f75 7469 6c2e 666f 726d 6174 6279  al_util.formatby
-00001770: 7465 7328 7073 7574 696c 2e76 6972 7475  tes(psutil.virtu
-00001780: 616c 5f6d 656d 6f72 7928 292e 6176 6169  al_memory().avai
-00001790: 6c61 626c 6529 0d0a 2020 2020 2020 2020  lable)..        
-000017a0: 6c6f 6767 6572 2e64 6562 7567 2866 2220  logger.debug(f" 
-000017b0: 202d 3e20 6d65 6d2e 6176 6169 6c61 626c   -> mem.availabl
-000017c0: 653a 207b 6d65 6d5f 6176 6169 6c61 626c  e: {mem_availabl
-000017d0: 657d 2229 0d0a 2020 2020 2020 2020 7377  e}")..        sw
-000017e0: 6170 5f66 7265 6520 3d20 5f67 656e 6572  ap_free = _gener
-000017f0: 616c 5f75 7469 6c2e 666f 726d 6174 6279  al_util.formatby
-00001800: 7465 7328 7073 7574 696c 2e73 7761 705f  tes(psutil.swap_
-00001810: 6d65 6d6f 7279 2829 2e66 7265 6529 0d0a  memory().free)..
-00001820: 2020 2020 2020 2020 6c6f 6767 6572 2e64          logger.d
-00001830: 6562 7567 2866 2220 202d 3e20 7377 6170  ebug(f"  -> swap
-00001840: 2e66 7265 653a 207b 7377 6170 5f66 7265  .free: {swap_fre
-00001850: 657d 2229 0d0a 0d0a 2020 2020 2320 4966  e}")....    # If
-00001860: 206e 6f74 2065 6e6f 7567 6820 6d65 6d6f   not enough memo
-00001870: 7279 2066 6f72 2074 6865 2061 6d6f 756e  ry for the amoun
-00001880: 7420 6f66 2070 6172 616c 6c65 6c6c 6973  t of parallellis
-00001890: 6d20 6173 6b65 642c 2072 6564 7563 650d  m asked, reduce.
-000018a0: 0a20 2020 2069 6620 286e 625f 7061 7261  .    if (nb_para
-000018b0: 6c6c 656c 202a 2063 6f6e 6669 675f 6c6f  llel * config_lo
-000018c0: 6361 6c2e 6279 7465 735f 6d69 6e5f 7065  cal.bytes_min_pe
-000018d0: 725f 7072 6f63 6573 7329 203e 2063 6f6e  r_process) > con
-000018e0: 6669 675f 6c6f 6361 6c2e 6279 7465 735f  fig_local.bytes_
-000018f0: 7573 6162 6c65 3a0d 0a20 2020 2020 2020  usable:..       
-00001900: 206e 625f 7061 7261 6c6c 656c 203d 2069   nb_parallel = i
-00001910: 6e74 280d 0a20 2020 2020 2020 2020 2020  nt(..           
-00001920: 2063 6f6e 6669 675f 6c6f 6361 6c2e 6279   config_local.by
-00001930: 7465 735f 7573 6162 6c65 202f 2063 6f6e  tes_usable / con
-00001940: 6669 675f 6c6f 6361 6c2e 6279 7465 735f  fig_local.bytes_
-00001950: 6d69 6e5f 7065 725f 7072 6f63 6573 730d  min_per_process.
-00001960: 0a20 2020 2020 2020 2029 0d0a 2020 2020  .        )..    
-00001970: 2020 2020 6c6f 6767 6572 2e64 6562 7567      logger.debug
-00001980: 2866 224e 625f 7061 7261 6c6c 656c 2072  (f"Nb_parallel r
-00001990: 6564 7563 6564 2074 6f20 7b6e 625f 7061  educed to {nb_pa
-000019a0: 7261 6c6c 656c 7d20 746f 2072 6564 7563  rallel} to reduc
-000019b0: 6520 6d65 6d6f 7279 2075 7361 6765 2229  e memory usage")
-000019c0: 0d0a 0d0a 2020 2020 2320 4861 7669 6e67  ....    # Having
-000019d0: 206d 6f72 6520 776f 726b 6572 7320 7468   more workers th
-000019e0: 616e 2072 6f77 7320 646f 6573 6e27 7420  an rows doesn't 
-000019f0: 6d61 6b65 2073 656e 7365 0d0a 2020 2020  make sense..    
-00001a00: 6966 206e 625f 7061 7261 6c6c 656c 203e  if nb_parallel >
-00001a10: 206e 625f 726f 7773 5f74 6f74 616c 3a0d   nb_rows_total:.
-00001a20: 0a20 2020 2020 2020 206e 625f 7061 7261  .        nb_para
-00001a30: 6c6c 656c 203d 206e 625f 726f 7773 5f74  llel = nb_rows_t
-00001a40: 6f74 616c 0d0a 0d0a 2020 2020 2320 4966  otal....    # If
-00001a50: 2062 6174 6368 7369 7a65 2069 7320 7370   batchsize is sp
-00001a60: 6563 6966 6965 642c 2075 7365 2069 7420  ecified, use it 
-00001a70: 746f 2064 6574 6572 6d69 6e65 206e 756d  to determine num
-00001a80: 6265 7220 6f66 2062 6174 6368 6573 2e0d  ber of batches..
-00001a90: 0a20 2020 2069 6620 6261 7463 6873 697a  .    if batchsiz
-00001aa0: 6520 3e20 303a 0d0a 2020 2020 2020 2020  e > 0:..        
-00001ab0: 6e62 5f62 6174 6368 6573 203d 206d 6174  nb_batches = mat
-00001ac0: 682e 6365 696c 286e 625f 726f 7773 5f74  h.ceil(nb_rows_t
-00001ad0: 6f74 616c 202f 2062 6174 6368 7369 7a65  otal / batchsize
-00001ae0: 290d 0a0d 0a20 2020 2020 2020 2023 204e  )....        # N
-00001af0: 6f20 7573 6520 746f 2068 6176 6520 6d6f  o use to have mo
-00001b00: 7265 2077 6f72 6b65 7273 2074 6861 6e20  re workers than 
-00001b10: 6e75 6d62 6572 206f 6620 6261 7463 6865  number of batche
-00001b20: 730d 0a20 2020 2020 2020 2069 6620 6e62  s..        if nb
-00001b30: 5f70 6172 616c 6c65 6c20 3e20 6e62 5f62  _parallel > nb_b
-00001b40: 6174 6368 6573 3a0d 0a20 2020 2020 2020  atches:..       
-00001b50: 2020 2020 206e 625f 7061 7261 6c6c 656c       nb_parallel
-00001b60: 203d 206e 625f 6261 7463 6865 730d 0a0d   = nb_batches...
-00001b70: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00001b80: 286e 625f 7061 7261 6c6c 656c 2c20 6e62  (nb_parallel, nb
-00001b90: 5f62 6174 6368 6573 290d 0a0d 0a20 2020  _batches)....   
-00001ba0: 2023 204e 6f20 6261 7463 6873 697a 6520   # No batchsize 
-00001bb0: 7370 6563 6966 6965 642c 2073 6f20 7573  specified, so us
-00001bc0: 6520 6865 7572 6973 7469 6373 2e0d 0a20  e heuristics... 
-00001bd0: 2020 2023 2053 7461 7274 2077 6974 6820     # Start with 
-00001be0: 3120 6261 7463 6820 7065 7220 776f 726b  1 batch per work
-00001bf0: 6572 0d0a 2020 2020 6e62 5f62 6174 6368  er..    nb_batch
-00001c00: 6573 203d 206e 625f 7061 7261 6c6c 656c  es = nb_parallel
-00001c10: 0d0a 0d0a 2020 2020 2320 4966 2074 6865  ....    # If the
-00001c20: 2062 6174 6368 6573 203c 206d 696e 5f72   batches < min_r
-00001c30: 6f77 735f 7065 725f 6261 7463 682c 2064  ows_per_batch, d
-00001c40: 6563 7265 6173 6520 6e75 6d62 6572 2062  ecrease number b
-00001c50: 6174 6368 6573 0d0a 2020 2020 6966 206e  atches..    if n
-00001c60: 625f 726f 7773 5f74 6f74 616c 202f 206e  b_rows_total / n
-00001c70: 625f 6261 7463 6865 7320 3c20 636f 6e66  b_batches < conf
-00001c80: 6967 5f6c 6f63 616c 2e6d 696e 5f72 6f77  ig_local.min_row
-00001c90: 735f 7065 725f 6261 7463 683a 0d0a 2020  s_per_batch:..  
-00001ca0: 2020 2020 2020 6e62 5f62 6174 6368 6573        nb_batches
-00001cb0: 203d 206d 6174 682e 6365 696c 286e 625f   = math.ceil(nb_
-00001cc0: 726f 7773 5f74 6f74 616c 202f 2063 6f6e  rows_total / con
-00001cd0: 6669 675f 6c6f 6361 6c2e 6d69 6e5f 726f  fig_local.min_ro
-00001ce0: 7773 5f70 6572 5f62 6174 6368 290d 0a0d  ws_per_batch)...
-00001cf0: 0a20 2020 2023 2049 6620 7468 6520 6261  .    # If the ba
-00001d00: 7463 6865 7320 3e20 6d61 785f 726f 7773  tches > max_rows
-00001d10: 5f70 6572 5f62 6174 6368 2c20 696e 6372  _per_batch, incr
-00001d20: 6561 7365 206e 756d 6265 7220 6261 7463  ease number batc
-00001d30: 6865 730d 0a20 2020 2069 6620 6e62 5f72  hes..    if nb_r
-00001d40: 6f77 735f 746f 7461 6c20 2f20 6e62 5f62  ows_total / nb_b
-00001d50: 6174 6368 6573 203e 2063 6f6e 6669 675f  atches > config_
-00001d60: 6c6f 6361 6c2e 6d61 785f 726f 7773 5f70  local.max_rows_p
-00001d70: 6572 5f62 6174 6368 3a0d 0a20 2020 2020  er_batch:..     
-00001d80: 2020 206e 625f 6261 7463 6865 7320 3d20     nb_batches = 
-00001d90: 6d61 7468 2e63 6569 6c28 6e62 5f72 6f77  math.ceil(nb_row
-00001da0: 735f 746f 7461 6c20 2f20 636f 6e66 6967  s_total / config
-00001db0: 5f6c 6f63 616c 2e6d 6178 5f72 6f77 735f  _local.max_rows_
-00001dc0: 7065 725f 6261 7463 6829 0d0a 2020 2020  per_batch)..    
-00001dd0: 2020 2020 2320 526f 756e 6420 6e62 5f62      # Round nb_b
-00001de0: 6174 6368 6573 2075 7020 746f 2074 6865  atches up to the
-00001df0: 206e 6561 7265 7374 206d 756c 7469 706c   nearest multipl
-00001e00: 6520 6f66 206e 625f 7061 7261 6c6c 656c  e of nb_parallel
-00001e10: 0d0a 2020 2020 2020 2020 6e62 5f62 6174  ..        nb_bat
-00001e20: 6368 6573 203d 206d 6174 682e 6365 696c  ches = math.ceil
-00001e30: 286e 625f 6261 7463 6865 7320 2f20 6e62  (nb_batches / nb
-00001e40: 5f70 6172 616c 6c65 6c29 202a 206e 625f  _parallel) * nb_
-00001e50: 7061 7261 6c6c 656c 0d0a 0d0a 2020 2020  parallel....    
-00001e60: 2320 4861 7669 6e67 206d 6f72 6520 776f  # Having more wo
-00001e70: 726b 6572 7320 7468 616e 2062 6174 6368  rkers than batch
-00001e80: 6573 2069 736e 2774 206c 6f67 6963 616c  es isn't logical
-00001e90: 2e2e 2e0d 0a20 2020 2069 6620 6e62 5f70  .....    if nb_p
-00001ea0: 6172 616c 6c65 6c20 3e20 6e62 5f62 6174  arallel > nb_bat
-00001eb0: 6368 6573 3a0d 0a20 2020 2020 2020 206e  ches:..        n
-00001ec0: 625f 7061 7261 6c6c 656c 203d 206e 625f  b_parallel = nb_
-00001ed0: 6261 7463 6865 730d 0a0d 0a20 2020 2023  batches....    #
-00001ee0: 2046 696e 616c 6c79 2c20 6d61 6b65 2073   Finally, make s
-00001ef0: 7572 6520 7468 6572 6520 6172 6520 656e  ure there are en
-00001f00: 6f75 6768 2062 6174 6368 6573 2074 6f20  ough batches to 
-00001f10: 6176 6f69 6420 6d65 6d6f 7279 2069 7373  avoid memory iss
-00001f20: 7565 733a 0d0a 2020 2020 2320 2020 3d20  ues:..    #   = 
-00001f30: 746f 7461 6c20 6d65 6d6f 7279 2075 7361  total memory usa
-00001f40: 6765 2066 6f72 2061 6c6c 2072 6f77 7320  ge for all rows 
-00001f50: 2f0d 0a20 2020 2023 2020 2020 2028 6672  /..    #     (fr
-00001f60: 6565 206d 656d 6f72 7920 2d20 6261 7365  ee memory - base
-00001f70: 206d 656d 6f72 7920 7573 6564 2062 7920   memory used by 
-00001f80: 616c 6c20 7061 7261 6c6c 656c 2070 726f  all parallel pro
-00001f90: 6365 7373 6573 290d 0a20 2020 206e 625f  cesses)..    nb_
-00001fa0: 6261 7463 6865 735f 6d69 6e20 3d20 6d61  batches_min = ma
-00001fb0: 7468 2e63 6569 6c28 0d0a 2020 2020 2020  th.ceil(..      
-00001fc0: 2020 286e 625f 726f 7773 5f74 6f74 616c    (nb_rows_total
-00001fd0: 202a 2063 6f6e 6669 675f 6c6f 6361 6c2e   * config_local.
-00001fe0: 6279 7465 735f 7065 725f 726f 7729 0d0a  bytes_per_row)..
-00001ff0: 2020 2020 2020 2020 2f20 2863 6f6e 6669          / (confi
-00002000: 675f 6c6f 6361 6c2e 6279 7465 735f 7573  g_local.bytes_us
-00002010: 6162 6c65 202d 2063 6f6e 6669 675f 6c6f  able - config_lo
-00002020: 6361 6c2e 6279 7465 735f 6261 7365 666f  cal.bytes_basefo
-00002030: 6f74 7072 696e 7420 2a20 6e62 5f70 6172  otprint * nb_par
-00002040: 616c 6c65 6c29 0d0a 2020 2020 290d 0a20  allel)..    ).. 
-00002050: 2020 2069 6620 6e62 5f62 6174 6368 6573     if nb_batches
-00002060: 203c 206e 625f 6261 7463 6865 735f 6d69   < nb_batches_mi
-00002070: 6e3a 0d0a 2020 2020 2020 2020 2320 526f  n:..        # Ro
-00002080: 756e 6420 6e62 5f62 6174 6368 6573 2075  und nb_batches u
-00002090: 7020 746f 2074 6865 206e 6561 7265 7374  p to the nearest
-000020a0: 206d 756c 7469 706c 6520 6f66 206e 625f   multiple of nb_
-000020b0: 7061 7261 6c6c 656c 0d0a 2020 2020 2020  parallel..      
-000020c0: 2020 6e62 5f62 6174 6368 6573 203d 206d    nb_batches = m
-000020d0: 6174 682e 6365 696c 286e 625f 6261 7463  ath.ceil(nb_batc
-000020e0: 6865 735f 6d69 6e20 2f20 6e62 5f70 6172  hes_min / nb_par
-000020f0: 616c 6c65 6c29 202a 206e 625f 7061 7261  allel) * nb_para
-00002100: 6c6c 656c 0d0a 0d0a 2020 2020 2320 4c6f  llel....    # Lo
-00002110: 6720 7265 7375 6c74 0d0a 2020 2020 6966  g result..    if
-00002120: 206c 6f67 6765 722e 6973 456e 6162 6c65   logger.isEnable
-00002130: 6446 6f72 286c 6f67 6769 6e67 2e44 4542  dFor(logging.DEB
-00002140: 5547 293a 0d0a 2020 2020 2020 2020 6261  UG):..        ba
-00002150: 7463 6873 697a 6520 3d20 6d61 7468 2e63  tchsize = math.c
-00002160: 6569 6c28 6e62 5f72 6f77 735f 746f 7461  eil(nb_rows_tota
-00002170: 6c20 2f20 6e62 5f62 6174 6368 6573 290d  l / nb_batches).
-00002180: 0a20 2020 2020 2020 206d 656d 5f70 7265  .        mem_pre
-00002190: 6469 6374 6564 203d 2028 0d0a 2020 2020  dicted = (..    
-000021a0: 2020 2020 2020 2020 636f 6e66 6967 5f6c          config_l
-000021b0: 6f63 616c 2e62 7974 6573 5f62 6173 6566  ocal.bytes_basef
-000021c0: 6f6f 7470 7269 6e74 202b 2062 6174 6368  ootprint + batch
-000021d0: 7369 7a65 202a 2063 6f6e 6669 675f 6c6f  size * config_lo
-000021e0: 6361 6c2e 6279 7465 735f 7065 725f 726f  cal.bytes_per_ro
-000021f0: 770d 0a20 2020 2020 2020 2029 202a 206e  w..        ) * n
-00002200: 625f 6261 7463 6865 730d 0a0d 0a20 2020  b_batches....   
-00002210: 2020 2020 206c 6f67 6765 722e 6465 6275       logger.debu
-00002220: 6728 0d0a 2020 2020 2020 2020 2020 2020  g(..            
-00002230: 6622 6e62 5f62 6174 6368 6573 5f72 6563  f"nb_batches_rec
-00002240: 6f6d 6d65 6e64 6564 3a20 7b6e 625f 6261  ommended: {nb_ba
-00002250: 7463 6865 737d 2c20 726f 7773 5f70 6572  tches}, rows_per
-00002260: 5f62 6174 6368 3a20 7b62 6174 6368 7369  _batch: {batchsi
-00002270: 7a65 7d22 0d0a 2020 2020 2020 2020 290d  ze}"..        ).
-00002280: 0a20 2020 2020 2020 206c 6f67 6765 722e  .        logger.
-00002290: 6465 6275 6728 6622 202d 3e20 6e62 5f72  debug(f" -> nb_r
-000022a0: 6f77 735f 696e 7075 745f 6c61 7965 723a  ows_input_layer:
-000022b0: 207b 6e62 5f72 6f77 735f 746f 7461 6c7d   {nb_rows_total}
-000022c0: 2229 0d0a 2020 2020 2020 2020 6c6f 6767  ")..        logg
-000022d0: 6572 2e64 6562 7567 2866 2220 2d3e 206d  er.debug(f" -> m
-000022e0: 656d 5f70 7265 6469 6374 6564 3a20 7b5f  em_predicted: {_
-000022f0: 6765 6e65 7261 6c5f 7574 696c 2e66 6f72  general_util.for
-00002300: 6d61 7462 7974 6573 286d 656d 5f70 7265  matbytes(mem_pre
-00002310: 6469 6374 6564 297d 2229 0d0a 0d0a 2020  dicted)}")....  
-00002320: 2020 7265 7475 726e 2028 6e62 5f70 6172    return (nb_par
-00002330: 616c 6c65 6c2c 206e 625f 6261 7463 6865  allel, nb_batche
-00002340: 7329 0d0a 0d0a 0d0a 636c 6173 7320 5072  s)......class Pr
-00002350: 6f63 6573 7369 6e67 5061 7261 6d73 3a0d  ocessingParams:.
-00002360: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
-00002370: 5f28 0d0a 2020 2020 2020 2020 7365 6c66  _(..        self
-00002380: 2c0d 0a20 2020 2020 2020 206e 625f 726f  ,..        nb_ro
-00002390: 7773 5f74 6f5f 7072 6f63 6573 733a 2069  ws_to_process: i
-000023a0: 6e74 2c0d 0a20 2020 2020 2020 206e 625f  nt,..        nb_
-000023b0: 7061 7261 6c6c 656c 3a20 696e 742c 0d0a  parallel: int,..
-000023c0: 2020 2020 2020 2020 6261 7463 6865 733a          batches:
-000023d0: 204c 6973 745b 7374 725d 2c0d 0a20 2020   List[str],..   
-000023e0: 2020 2020 2062 6174 6368 7369 7a65 3a20       batchsize: 
-000023f0: 696e 742c 0d0a 2020 2020 293a 0d0a 2020  int,..    ):..  
-00002400: 2020 2020 2020 7365 6c66 2e6e 625f 726f        self.nb_ro
-00002410: 7773 5f74 6f5f 7072 6f63 6573 7320 3d20  ws_to_process = 
-00002420: 6e62 5f72 6f77 735f 746f 5f70 726f 6365  nb_rows_to_proce
-00002430: 7373 0d0a 2020 2020 2020 2020 7365 6c66  ss..        self
-00002440: 2e6e 625f 7061 7261 6c6c 656c 203d 206e  .nb_parallel = n
-00002450: 625f 7061 7261 6c6c 656c 0d0a 2020 2020  b_parallel..    
-00002460: 2020 2020 7365 6c66 2e62 6174 6368 6573      self.batches
-00002470: 203d 2062 6174 6368 6573 0d0a 2020 2020   = batches..    
-00002480: 2020 2020 7365 6c66 2e62 6174 6368 7369      self.batchsi
-00002490: 7a65 203d 2062 6174 6368 7369 7a65 0d0a  ze = batchsize..
-000024a0: 0d0a 2020 2020 6465 6620 746f 5f6a 736f  ..    def to_jso
-000024b0: 6e28 7365 6c66 2c20 7061 7468 3a20 5061  n(self, path: Pa
-000024c0: 7468 293a 0d0a 2020 2020 2020 2020 7072  th):..        pr
-000024d0: 6570 6172 6564 203d 205f 6765 6e65 7261  epared = _genera
-000024e0: 6c5f 7574 696c 2e70 7265 7061 7265 5f66  l_util.prepare_f
-000024f0: 6f72 5f73 6572 6961 6c69 7a65 2876 6172  or_serialize(var
-00002500: 7328 7365 6c66 2929 0d0a 2020 2020 2020  s(self))..      
-00002510: 2020 7769 7468 206f 7065 6e28 7061 7468    with open(path
-00002520: 2c20 2277 2229 2061 7320 6669 6c65 3a0d  , "w") as file:.
-00002530: 0a20 2020 2020 2020 2020 2020 2066 696c  .            fil
-00002540: 652e 7772 6974 6528 6a73 6f6e 2e64 756d  e.write(json.dum
-00002550: 7073 2870 7265 7061 7265 642c 2069 6e64  ps(prepared, ind
-00002560: 656e 743d 342c 2073 6f72 745f 6b65 7973  ent=4, sort_keys
-00002570: 3d54 7275 6529 290d 0a0d 0a0d 0a64 6566  =True))......def
-00002580: 205f 7072 6570 6172 655f 7072 6f63 6573   _prepare_proces
-00002590: 7369 6e67 5f70 6172 616d 7328 0d0a 2020  sing_params(..  
-000025a0: 2020 696e 7075 745f 7061 7468 3a20 5061    input_path: Pa
-000025b0: 7468 2c0d 0a20 2020 2069 6e70 7574 5f6c  th,..    input_l
-000025c0: 6179 6572 3a20 7374 722c 0d0a 2020 2020  ayer: str,..    
-000025d0: 6e62 5f70 6172 616c 6c65 6c3a 2069 6e74  nb_parallel: int
-000025e0: 2c0d 0a20 2020 2062 6174 6368 7369 7a65  ,..    batchsize
-000025f0: 3a20 696e 742c 0d0a 2020 2020 7061 7261  : int,..    para
-00002600: 6c6c 656c 697a 6174 696f 6e5f 636f 6e66  llelization_conf
-00002610: 6967 3a20 4f70 7469 6f6e 616c 5b50 6172  ig: Optional[Par
-00002620: 616c 6c65 6c69 7a61 7469 6f6e 436f 6e66  allelizationConf
-00002630: 6967 5d20 3d20 4e6f 6e65 2c0d 0a20 2020  ig] = None,..   
-00002640: 2074 6d70 5f64 6972 3a20 4f70 7469 6f6e   tmp_dir: Option
-00002650: 616c 5b50 6174 685d 203d 204e 6f6e 652c  al[Path] = None,
-00002660: 0d0a 2920 2d3e 2050 726f 6365 7373 696e  ..) -> Processin
-00002670: 6750 6172 616d 733a 0d0a 2020 2020 696e  gParams:..    in
-00002680: 7075 745f 696e 666f 203d 2067 666f 2e67  put_info = gfo.g
-00002690: 6574 5f6c 6179 6572 696e 666f 2869 6e70  et_layerinfo(inp
-000026a0: 7574 5f70 6174 682c 2069 6e70 7574 5f6c  ut_path, input_l
-000026b0: 6179 6572 290d 0a20 2020 2066 6964 5f63  ayer)..    fid_c
-000026c0: 6f6c 756d 6e20 3d20 696e 7075 745f 696e  olumn = input_in
-000026d0: 666f 2e66 6964 5f63 6f6c 756d 6e20 6966  fo.fid_column if
-000026e0: 2069 6e70 7574 5f69 6e66 6f2e 6669 645f   input_info.fid_
-000026f0: 636f 6c75 6d6e 2021 3d20 2222 2065 6c73  column != "" els
-00002700: 6520 2266 6964 220d 0a20 2020 206e 625f  e "fid"..    nb_
-00002710: 7061 7261 6c6c 656c 2c20 6e62 5f62 6174  parallel, nb_bat
-00002720: 6368 6573 203d 205f 6465 7465 726d 696e  ches = _determin
-00002730: 655f 6e62 5f62 6174 6368 6573 280d 0a20  e_nb_batches(.. 
-00002740: 2020 2020 2020 206e 625f 726f 7773 5f74         nb_rows_t
-00002750: 6f74 616c 3d69 6e70 7574 5f69 6e66 6f2e  otal=input_info.
-00002760: 6665 6174 7572 6563 6f75 6e74 2c0d 0a20  featurecount,.. 
-00002770: 2020 2020 2020 206e 625f 7061 7261 6c6c         nb_parall
-00002780: 656c 3d6e 625f 7061 7261 6c6c 656c 2c0d  el=nb_parallel,.
-00002790: 0a20 2020 2020 2020 2062 6174 6368 7369  .        batchsi
-000027a0: 7a65 3d62 6174 6368 7369 7a65 2c0d 0a20  ze=batchsize,.. 
-000027b0: 2020 2020 2020 2070 6172 616c 6c65 6c69         paralleli
-000027c0: 7a61 7469 6f6e 5f63 6f6e 6669 673d 7061  zation_config=pa
-000027d0: 7261 6c6c 656c 697a 6174 696f 6e5f 636f  rallelization_co
-000027e0: 6e66 6967 2c0d 0a20 2020 2029 0d0a 0d0a  nfig,..    )....
-000027f0: 2020 2020 2320 5072 6570 6172 6520 6261      # Prepare ba
-00002800: 7463 6865 7320 746f 2070 726f 6365 7373  tches to process
-00002810: 0d0a 2020 2020 6261 7463 6865 733a 204c  ..    batches: L
-00002820: 6973 745b 7374 725d 203d 205b 5d0d 0a20  ist[str] = [].. 
-00002830: 2020 2069 6620 6e62 5f62 6174 6368 6573     if nb_batches
-00002840: 203d 3d20 313a 0d0a 2020 2020 2020 2020   == 1:..        
-00002850: 2320 4966 206f 6e6c 7920 6f6e 6520 6261  # If only one ba
-00002860: 7463 682c 206e 6f20 6669 6c74 6572 696e  tch, no filterin
-00002870: 6720 6973 206e 6565 6465 640d 0a20 2020  g is needed..   
-00002880: 2020 2020 2062 6174 6368 6573 2e61 7070       batches.app
-00002890: 656e 6428 2222 290d 0a20 2020 2065 6c73  end("")..    els
-000028a0: 653a 0d0a 2020 2020 2020 2020 2320 4465  e:..        # De
-000028b0: 7465 726d 696e 6520 7468 6520 6d69 6e5f  termine the min_
-000028c0: 6669 6420 616e 6420 6d61 785f 6669 640d  fid and max_fid.
-000028d0: 0a20 2020 2020 2020 2023 2052 656d 6172  .        # Remar
-000028e0: 6b3a 2053 454c 4543 5420 4d49 4e28 6669  k: SELECT MIN(fi
-000028f0: 6429 2c20 4d41 5828 6669 6429 2046 524f  d), MAX(fid) FRO
-00002900: 4d20 2e2e 2e20 6973 2061 206c 6f74 2073  M ... is a lot s
-00002910: 6c6f 7765 7220 7468 616e 2055 4e49 4f4e  lower than UNION
-00002920: 2041 4c4c 210d 0a20 2020 2020 2020 2073   ALL!..        s
-00002930: 716c 5f73 746d 7420 3d20 6622 2222 0d0a  ql_stmt = f"""..
-00002940: 2020 2020 2020 2020 2020 2020 5345 4c45              SELE
-00002950: 4354 204d 494e 287b 6669 645f 636f 6c75  CT MIN({fid_colu
-00002960: 6d6e 7d29 206d 696e 6d61 785f 6669 6420  mn}) minmax_fid 
-00002970: 4652 4f4d 2022 7b69 6e70 7574 5f69 6e66  FROM "{input_inf
-00002980: 6f2e 6e61 6d65 7d22 0d0a 2020 2020 2020  o.name}"..      
-00002990: 2020 2020 2020 554e 494f 4e20 414c 4c0d        UNION ALL.
-000029a0: 0a20 2020 2020 2020 2020 2020 2053 454c  .            SEL
-000029b0: 4543 5420 4d41 5828 7b66 6964 5f63 6f6c  ECT MAX({fid_col
-000029c0: 756d 6e7d 2920 6d69 6e6d 6178 5f66 6964  umn}) minmax_fid
-000029d0: 2046 524f 4d20 227b 696e 7075 745f 696e   FROM "{input_in
-000029e0: 666f 2e6e 616d 657d 220d 0a20 2020 2020  fo.name}"..     
-000029f0: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-00002a00: 6261 7463 685f 696e 666f 5f64 6620 3d20  batch_info_df = 
-00002a10: 6766 6f2e 7265 6164 5f66 696c 6528 7061  gfo.read_file(pa
-00002a20: 7468 3d69 6e70 7574 5f70 6174 682c 2073  th=input_path, s
-00002a30: 716c 5f73 746d 743d 7371 6c5f 7374 6d74  ql_stmt=sql_stmt
-00002a40: 290d 0a20 2020 2020 2020 206d 696e 5f66  )..        min_f
-00002a50: 6964 203d 2070 642e 746f 5f6e 756d 6572  id = pd.to_numer
-00002a60: 6963 2862 6174 6368 5f69 6e66 6f5f 6466  ic(batch_info_df
-00002a70: 5b22 6d69 6e6d 6178 5f66 6964 225d 5b30  ["minmax_fid"][0
-00002a80: 5d29 2e69 7465 6d28 290d 0a20 2020 2020  ]).item()..     
-00002a90: 2020 206d 6178 5f66 6964 203d 2070 642e     max_fid = pd.
-00002aa0: 746f 5f6e 756d 6572 6963 2862 6174 6368  to_numeric(batch
-00002ab0: 5f69 6e66 6f5f 6466 5b22 6d69 6e6d 6178  _info_df["minmax
-00002ac0: 5f66 6964 225d 5b31 5d29 2e69 7465 6d28  _fid"][1]).item(
-00002ad0: 290d 0a0d 0a20 2020 2020 2020 2023 2044  )....        # D
-00002ae0: 6574 6572 6d69 6e65 2074 6865 2065 7861  etermine the exa
-00002af0: 6374 2062 6174 6368 6573 2074 6f20 7573  ct batches to us
-00002b00: 650d 0a20 2020 2020 2020 2069 6620 2828  e..        if ((
-00002b10: 6d61 785f 6669 6420 2d20 6d69 6e5f 6669  max_fid - min_fi
-00002b20: 6429 202f 2069 6e70 7574 5f69 6e66 6f2e  d) / input_info.
-00002b30: 6665 6174 7572 6563 6f75 6e74 2920 3c20  featurecount) < 
-00002b40: 312e 313a 0d0a 2020 2020 2020 2020 2020  1.1:..          
-00002b50: 2020 2320 4966 2074 6865 2066 6964 2773    # If the fid's
-00002b60: 2061 7265 2071 7569 7465 2063 6f6e 7365   are quite conse
-00002b70: 6375 7469 7665 2c20 7573 6520 616e 2069  cutive, use an i
-00002b80: 6d70 6572 6665 6374 2c20 6275 740d 0a20  mperfect, but.. 
-00002b90: 2020 2020 2020 2020 2020 2023 2066 6173             # fas
-00002ba0: 7420 6469 7374 7269 6275 7469 6f6e 2069  t distribution i
-00002bb0: 6e20 6261 7463 6865 730d 0a20 2020 2020  n batches..     
-00002bc0: 2020 2020 2020 2062 6174 6368 5f69 6e66         batch_inf
-00002bd0: 6f5f 6c69 7374 203d 205b 5d0d 0a20 2020  o_list = []..   
-00002be0: 2020 2020 2020 2020 206e 625f 726f 7773           nb_rows
-00002bf0: 5f70 6572 5f62 6174 6368 203d 2072 6f75  _per_batch = rou
-00002c00: 6e64 2869 6e70 7574 5f69 6e66 6f2e 6665  nd(input_info.fe
-00002c10: 6174 7572 6563 6f75 6e74 202f 206e 625f  aturecount / nb_
-00002c20: 6261 7463 6865 7329 0d0a 2020 2020 2020  batches)..      
-00002c30: 2020 2020 2020 6f66 6673 6574 203d 2030        offset = 0
-00002c40: 0d0a 2020 2020 2020 2020 2020 2020 6f66  ..            of
-00002c50: 6673 6574 5f70 6572 5f62 6174 6368 203d  fset_per_batch =
-00002c60: 2072 6f75 6e64 2828 6d61 785f 6669 6420   round((max_fid 
-00002c70: 2d20 6d69 6e5f 6669 6429 202f 206e 625f  - min_fid) / nb_
-00002c80: 6261 7463 6865 7329 0d0a 2020 2020 2020  batches)..      
-00002c90: 2020 2020 2020 666f 7220 6261 7463 685f        for batch_
-00002ca0: 6964 2069 6e20 7261 6e67 6528 6e62 5f62  id in range(nb_b
-00002cb0: 6174 6368 6573 293a 0d0a 2020 2020 2020  atches):..      
-00002cc0: 2020 2020 2020 2020 2020 7374 6172 745f            start_
-00002cd0: 6669 6420 3d20 6f66 6673 6574 0d0a 2020  fid = offset..  
-00002ce0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00002cf0: 2062 6174 6368 5f69 6420 3c20 286e 625f   batch_id < (nb_
-00002d00: 6261 7463 6865 7320 2d20 3129 3a0d 0a20  batches - 1):.. 
-00002d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d20: 2020 2023 2045 6e64 2066 6964 2066 6f72     # End fid for
-00002d30: 2074 6869 7320 6261 7463 6820 6973 2074   this batch is t
-00002d40: 6865 206e 6578 7420 7374 6172 745f 6669  he next start_fi
-00002d50: 6420 2d20 310d 0a20 2020 2020 2020 2020  d - 1..         
-00002d60: 2020 2020 2020 2020 2020 2065 6e64 5f66             end_f
-00002d70: 6964 203d 206f 6666 7365 7420 2b20 6f66  id = offset + of
-00002d80: 6673 6574 5f70 6572 5f62 6174 6368 202d  fset_per_batch -
-00002d90: 2031 0d0a 2020 2020 2020 2020 2020 2020   1..            
-00002da0: 2020 2020 656c 7365 3a0d 0a20 2020 2020      else:..     
-00002db0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00002dc0: 2046 6f72 2074 6865 206c 6173 7420 6261   For the last ba
-00002dd0: 7463 682c 2074 616b 6520 7468 6520 6d61  tch, take the ma
-00002de0: 785f 6669 6420 736f 206e 6f20 6669 6427  x_fid so no fid'
-00002df0: 7320 6172 650d 0a20 2020 2020 2020 2020  s are..         
-00002e00: 2020 2020 2020 2020 2020 2023 2027 6c6f             # 'lo
-00002e10: 7374 2720 6475 6520 746f 2072 6f75 6e64  st' due to round
-00002e20: 696e 6720 6572 726f 7273 0d0a 2020 2020  ing errors..    
-00002e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e40: 656e 645f 6669 6420 3d20 6d61 785f 6669  end_fid = max_fi
-00002e50: 640d 0a20 2020 2020 2020 2020 2020 2020  d..             
-00002e60: 2020 2062 6174 6368 5f69 6e66 6f5f 6c69     batch_info_li
-00002e70: 7374 2e61 7070 656e 6428 0d0a 2020 2020  st.append(..    
-00002e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e90: 2862 6174 6368 5f69 642c 206e 625f 726f  (batch_id, nb_ro
-00002ea0: 7773 5f70 6572 5f62 6174 6368 2c20 7374  ws_per_batch, st
-00002eb0: 6172 745f 6669 642c 2065 6e64 5f66 6964  art_fid, end_fid
-00002ec0: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-00002ed0: 2020 2029 0d0a 2020 2020 2020 2020 2020     )..          
-00002ee0: 2020 2020 2020 6f66 6673 6574 202b 3d20        offset += 
-00002ef0: 6f66 6673 6574 5f70 6572 5f62 6174 6368  offset_per_batch
-00002f00: 0d0a 2020 2020 2020 2020 2020 2020 6261  ..            ba
-00002f10: 7463 685f 696e 666f 5f64 6620 3d20 7064  tch_info_df = pd
-00002f20: 2e44 6174 6146 7261 6d65 280d 0a20 2020  .DataFrame(..   
-00002f30: 2020 2020 2020 2020 2020 2020 2062 6174               bat
-00002f40: 6368 5f69 6e66 6f5f 6c69 7374 2c20 636f  ch_info_list, co
-00002f50: 6c75 6d6e 733d 5b22 6261 7463 685f 6964  lumns=["batch_id
-00002f60: 222c 2022 6e62 5f72 6f77 7322 2c20 2273  ", "nb_rows", "s
-00002f70: 7461 7274 5f66 6964 222c 2022 656e 645f  tart_fid", "end_
-00002f80: 6669 6422 5d0d 0a20 2020 2020 2020 2020  fid"]..         
-00002f90: 2020 2029 0d0a 2020 2020 2020 2020 656c     )..        el
-00002fa0: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-00002fb0: 2023 2054 6865 2066 6964 7320 6172 6520   # The fids are 
-00002fc0: 6e6f 7420 636f 6e73 6563 7574 6976 652c  not consecutive,
-00002fd0: 2073 6f20 6465 7465 726d 696e 6520 7468   so determine th
-00002fe0: 6520 6f70 7469 6d61 6c20 6669 640d 0a20  e optimal fid.. 
-00002ff0: 2020 2020 2020 2020 2020 2023 2072 616e             # ran
-00003000: 6765 7320 666f 7220 6561 6368 2062 6174  ges for each bat
-00003010: 6368 2073 6f20 6561 6368 2062 6174 6368  ch so each batch
-00003020: 2068 6173 2073 616d 6520 6e75 6d62 6572   has same number
-00003030: 206f 6620 656c 656d 656e 7473 0d0a 2020   of elements..  
-00003040: 2020 2020 2020 2020 2020 2320 5265 6d61            # Rema
-00003050: 726b 3a20 2d20 7468 6973 206d 6967 6874  rk: - this might
-00003060: 2074 616b 6520 736f 6d65 2073 6563 6f6e   take some secon
-00003070: 6473 2066 6f72 206c 6172 6765 7220 6461  ds for larger da
-00003080: 7461 7365 7473 210d 0a20 2020 2020 2020  tasets!..       
-00003090: 2020 2020 2023 2020 2020 2020 2020 202d       #         -
-000030a0: 2028 6261 7463 685f 6964 202d 2031 2920   (batch_id - 1) 
-000030b0: 4153 2069 6420 746f 206d 616b 6520 7468  AS id to make th
-000030c0: 6520 6964 207a 6572 6f2d 6261 7365 640d  e id zero-based.
-000030d0: 0a20 2020 2020 2020 2020 2020 2073 716c  .            sql
-000030e0: 5f73 746d 7420 3d20 6622 2222 0d0a 2020  _stmt = f"""..  
-000030f0: 2020 2020 2020 2020 2020 2020 2020 5345                SE
-00003100: 4c45 4354 2028 6261 7463 685f 6964 5f31  LECT (batch_id_1
-00003110: 202d 2031 2920 4153 2062 6174 6368 5f69   - 1) AS batch_i
-00003120: 640d 0a20 2020 2020 2020 2020 2020 2020  d..             
-00003130: 2020 2020 2020 2020 202c 434f 554e 5428           ,COUNT(
-00003140: 2a29 2041 5320 6e62 5f72 6f77 730d 0a20  *) AS nb_rows.. 
-00003150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003160: 2020 2020 202c 4d49 4e28 7b66 6964 5f63       ,MIN({fid_c
-00003170: 6f6c 756d 6e7d 2920 4153 2073 7461 7274  olumn}) AS start
-00003180: 5f66 6964 0d0a 2020 2020 2020 2020 2020  _fid..          
-00003190: 2020 2020 2020 2020 2020 2020 2c4d 4158              ,MAX
-000031a0: 287b 6669 645f 636f 6c75 6d6e 7d29 2041  ({fid_column}) A
-000031b0: 5320 656e 645f 6669 640d 0a20 2020 2020  S end_fid..     
-000031c0: 2020 2020 2020 2020 2020 2020 2046 524f               FRO
-000031d0: 4d0d 0a20 2020 2020 2020 2020 2020 2020  M..             
-000031e0: 2020 2020 2020 2028 2053 454c 4543 5420         ( SELECT 
-000031f0: 7b66 6964 5f63 6f6c 756d 6e7d 0d0a 2020  {fid_column}..  
-00003200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003210: 2020 2020 2020 2020 2020 2c4e 5449 4c45            ,NTILE
-00003220: 287b 6e62 5f62 6174 6368 6573 7d29 204f  ({nb_batches}) O
-00003230: 5645 5220 284f 5244 4552 2042 5920 7b66  VER (ORDER BY {f
-00003240: 6964 5f63 6f6c 756d 6e7d 2920 6261 7463  id_column}) batc
-00003250: 685f 6964 5f31 0d0a 2020 2020 2020 2020  h_id_1..        
-00003260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003270: 4652 4f4d 2022 7b69 6e70 7574 5f69 6e66  FROM "{input_inf
-00003280: 6f2e 6e61 6d65 7d22 0d0a 2020 2020 2020  o.name}"..      
-00003290: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-000032a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000032b0: 2020 4752 4f55 5020 4259 2062 6174 6368    GROUP BY batch
-000032c0: 5f69 645f 313b 0d0a 2020 2020 2020 2020  _id_1;..        
-000032d0: 2020 2020 2222 220d 0a20 2020 2020 2020      """..       
-000032e0: 2020 2020 2062 6174 6368 5f69 6e66 6f5f       batch_info_
-000032f0: 6466 203d 2067 666f 2e72 6561 645f 6669  df = gfo.read_fi
-00003300: 6c65 2870 6174 683d 696e 7075 745f 7061  le(path=input_pa
-00003310: 7468 2c20 7371 6c5f 7374 6d74 3d73 716c  th, sql_stmt=sql
-00003320: 5f73 746d 7429 0d0a 0d0a 2020 2020 2020  _stmt)....      
-00003330: 2020 2320 4e6f 7720 6c6f 6f70 206f 7665    # Now loop ove
-00003340: 7220 616c 6c20 6261 7463 6820 7261 6e67  r all batch rang
-00003350: 6573 2074 6f20 6275 696c 6420 7570 2074  es to build up t
-00003360: 6865 206e 6563 6573 7361 7279 2066 696c  he necessary fil
-00003370: 7465 7273 0d0a 2020 2020 2020 2020 666f  ters..        fo
-00003380: 7220 6261 7463 685f 696e 666f 2069 6e20  r batch_info in 
-00003390: 6261 7463 685f 696e 666f 5f64 662e 6974  batch_info_df.it
-000033a0: 6572 7475 706c 6573 2829 3a0d 0a20 2020  ertuples():..   
-000033b0: 2020 2020 2020 2020 2023 2054 6865 2062           # The b
-000033c0: 6174 6368 2066 696c 7465 720d 0a20 2020  atch filter..   
-000033d0: 2020 2020 2020 2020 2069 6620 6261 7463           if batc
-000033e0: 685f 696e 666f 2e62 6174 6368 5f69 6420  h_info.batch_id 
-000033f0: 3c20 6e62 5f62 6174 6368 6573 202d 2031  < nb_batches - 1
-00003400: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00003410: 2020 2062 6174 6368 6573 2e61 7070 656e     batches.appen
-00003420: 6428 0d0a 2020 2020 2020 2020 2020 2020  d(..            
-00003430: 2020 2020 2020 2020 6622 287b 6669 645f          f"({fid_
-00003440: 636f 6c75 6d6e 7d20 3e3d 207b 6261 7463  column} >= {batc
-00003450: 685f 696e 666f 2e73 7461 7274 5f66 6964  h_info.start_fid
-00003460: 7d20 220d 0a20 2020 2020 2020 2020 2020  } "..           
-00003470: 2020 2020 2020 2020 2066 2241 4e44 207b           f"AND {
-00003480: 6669 645f 636f 6c75 6d6e 7d20 3c3d 207b  fid_column} <= {
-00003490: 6261 7463 685f 696e 666f 2e65 6e64 5f66  batch_info.end_f
-000034a0: 6964 7d29 2022 0d0a 2020 2020 2020 2020  id}) "..        
-000034b0: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-000034c0: 2020 2020 2020 2065 6c73 653a 0d0a 2020         else:..  
-000034d0: 2020 2020 2020 2020 2020 2020 2020 6261                ba
-000034e0: 7463 6865 732e 6170 7065 6e64 2866 227b  tches.append(f"{
-000034f0: 6669 645f 636f 6c75 6d6e 7d20 3e3d 207b  fid_column} >= {
-00003500: 6261 7463 685f 696e 666f 2e73 7461 7274  batch_info.start
-00003510: 5f66 6964 7d20 2229 0d0a 0d0a 2020 2020  _fid} ")....    
-00003520: 2320 4e6f 2075 7365 2073 7461 7274 696e  # No use startin
-00003530: 6720 6d6f 7265 2070 726f 6365 7373 6573  g more processes
-00003540: 2074 6861 6e20 7468 6520 6e75 6d62 6572   than the number
-00003550: 206f 6620 6261 7463 6865 732e 2e2e 0d0a   of batches.....
-00003560: 2020 2020 6966 206c 656e 2862 6174 6368      if len(batch
-00003570: 6573 2920 3c20 6e62 5f70 6172 616c 6c65  es) < nb_paralle
-00003580: 6c3a 0d0a 2020 2020 2020 2020 6e62 5f70  l:..        nb_p
-00003590: 6172 616c 6c65 6c20 3d20 6c65 6e28 6261  arallel = len(ba
-000035a0: 7463 6865 7329 0d0a 0d0a 2020 2020 7265  tches)....    re
-000035b0: 7475 726e 7661 6c75 6520 3d20 5072 6f63  turnvalue = Proc
-000035c0: 6573 7369 6e67 5061 7261 6d73 280d 0a20  essingParams(.. 
-000035d0: 2020 2020 2020 206e 625f 726f 7773 5f74         nb_rows_t
-000035e0: 6f5f 7072 6f63 6573 733d 696e 7075 745f  o_process=input_
-000035f0: 696e 666f 2e66 6561 7475 7265 636f 756e  info.featurecoun
-00003600: 742c 0d0a 2020 2020 2020 2020 6e62 5f70  t,..        nb_p
-00003610: 6172 616c 6c65 6c3d 6e62 5f70 6172 616c  arallel=nb_paral
-00003620: 6c65 6c2c 0d0a 2020 2020 2020 2020 6261  lel,..        ba
-00003630: 7463 6865 733d 6261 7463 6865 732c 0d0a  tches=batches,..
-00003640: 2020 2020 2020 2020 6261 7463 6873 697a          batchsiz
-00003650: 653d 696e 7428 696e 7075 745f 696e 666f  e=int(input_info
-00003660: 2e66 6561 7475 7265 636f 756e 7420 2f20  .featurecount / 
-00003670: 6c65 6e28 6261 7463 6865 7329 292c 0d0a  len(batches)),..
-00003680: 2020 2020 290d 0a0d 0a20 2020 2069 6620      )....    if 
-00003690: 746d 705f 6469 7220 6973 206e 6f74 204e  tmp_dir is not N
-000036a0: 6f6e 653a 0d0a 2020 2020 2020 2020 7265  one:..        re
-000036b0: 7475 726e 7661 6c75 652e 746f 5f6a 736f  turnvalue.to_jso
-000036c0: 6e28 746d 705f 6469 7220 2f20 2270 726f  n(tmp_dir / "pro
-000036d0: 6365 7373 696e 675f 7061 7261 6d73 2e6a  cessing_params.j
-000036e0: 736f 6e22 290d 0a20 2020 2072 6574 7572  son")..    retur
-000036f0: 6e20 7265 7475 726e 7661 6c75 650d 0a0d  n returnvalue...
-00003700: 0a0d 0a63 6c61 7373 2047 656f 4f70 6572  ...class GeoOper
-00003710: 6174 696f 6e28 656e 756d 2e45 6e75 6d29  ation(enum.Enum)
-00003720: 3a0d 0a20 2020 2053 494d 504c 4946 5920  :..    SIMPLIFY 
-00003730: 3d20 2273 696d 706c 6966 7922 0d0a 2020  = "simplify"..  
-00003740: 2020 4255 4646 4552 203d 2022 6275 6666    BUFFER = "buff
-00003750: 6572 220d 0a20 2020 2043 4f4e 5645 5848  er"..    CONVEXH
-00003760: 554c 4c20 3d20 2263 6f6e 7665 7868 756c  ULL = "convexhul
-00003770: 6c22 0d0a 2020 2020 4150 504c 5920 3d20  l"..    APPLY = 
-00003780: 2261 7070 6c79 220d 0a0d 0a0d 0a64 6566  "apply"......def
-00003790: 2061 7070 6c79 280d 0a20 2020 2069 6e70   apply(..    inp
-000037a0: 7574 5f70 6174 683a 2050 6174 682c 0d0a  ut_path: Path,..
-000037b0: 2020 2020 6f75 7470 7574 5f70 6174 683a      output_path:
-000037c0: 2050 6174 682c 0d0a 2020 2020 6675 6e63   Path,..    func
-000037d0: 3a20 4361 6c6c 6162 6c65 5b5b 416e 795d  : Callable[[Any]
-000037e0: 2c20 416e 795d 2c0d 0a20 2020 206f 7065  , Any],..    ope
-000037f0: 7261 7469 6f6e 5f6e 616d 653a 204f 7074  ration_name: Opt
-00003800: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
-00003810: 652c 0d0a 2020 2020 6f6e 6c79 5f67 656f  e,..    only_geo
-00003820: 6d5f 696e 7075 743a 2062 6f6f 6c20 3d20  m_input: bool = 
-00003830: 5472 7565 2c0d 0a20 2020 2069 6e70 7574  True,..    input
-00003840: 5f6c 6179 6572 3a20 4f70 7469 6f6e 616c  _layer: Optional
-00003850: 5b73 7472 5d20 3d20 4e6f 6e65 2c0d 0a20  [str] = None,.. 
-00003860: 2020 206f 7574 7075 745f 6c61 7965 723a     output_layer:
-00003870: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
-00003880: 204e 6f6e 652c 0d0a 2020 2020 636f 6c75   None,..    colu
-00003890: 6d6e 733a 204f 7074 696f 6e61 6c5b 4c69  mns: Optional[Li
-000038a0: 7374 5b73 7472 5d5d 203d 204e 6f6e 652c  st[str]] = None,
-000038b0: 0d0a 2020 2020 6578 706c 6f64 6563 6f6c  ..    explodecol
-000038c0: 6c65 6374 696f 6e73 3a20 626f 6f6c 203d  lections: bool =
-000038d0: 2046 616c 7365 2c0d 0a20 2020 2066 6f72   False,..    for
-000038e0: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-000038f0: 7279 7479 7065 3a20 556e 696f 6e5b 4765  rytype: Union[Ge
-00003900: 6f6d 6574 7279 5479 7065 2c20 7374 722c  ometryType, str,
-00003910: 204e 6f6e 655d 203d 204e 6f6e 652c 0d0a   None] = None,..
-00003920: 2020 2020 6772 6964 7369 7a65 3a20 666c      gridsize: fl
-00003930: 6f61 7420 3d20 302e 302c 0d0a 2020 2020  oat = 0.0,..    
-00003940: 6b65 6570 5f65 6d70 7479 5f67 656f 6d73  keep_empty_geoms
-00003950: 3a20 626f 6f6c 203d 2054 7275 652c 0d0a  : bool = True,..
-00003960: 2020 2020 7768 6572 655f 706f 7374 3a20      where_post: 
-00003970: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
-00003980: 4e6f 6e65 2c0d 0a20 2020 206e 625f 7061  None,..    nb_pa
-00003990: 7261 6c6c 656c 3a20 696e 7420 3d20 2d31  rallel: int = -1
-000039a0: 2c0d 0a20 2020 2062 6174 6368 7369 7a65  ,..    batchsize
-000039b0: 3a20 696e 7420 3d20 2d31 2c0d 0a20 2020  : int = -1,..   
-000039c0: 2066 6f72 6365 3a20 626f 6f6c 203d 2046   force: bool = F
-000039d0: 616c 7365 2c0d 0a20 2020 2070 6172 616c  alse,..    paral
-000039e0: 6c65 6c69 7a61 7469 6f6e 5f63 6f6e 6669  lelization_confi
-000039f0: 673a 2050 6172 616c 6c65 6c69 7a61 7469  g: Parallelizati
-00003a00: 6f6e 436f 6e66 6967 203d 204e 6f6e 652c  onConfig = None,
-00003a10: 0d0a 293a 0d0a 2020 2020 2320 496e 6974  ..):..    # Init
-00003a20: 0d0a 2020 2020 6f70 6572 6174 696f 6e5f  ..    operation_
-00003a30: 7061 7261 6d73 203d 207b 0d0a 2020 2020  params = {..    
-00003a40: 2020 2020 226f 6e6c 795f 6765 6f6d 5f69      "only_geom_i
-00003a50: 6e70 7574 223a 206f 6e6c 795f 6765 6f6d  nput": only_geom
-00003a60: 5f69 6e70 7574 2c0d 0a20 2020 2020 2020  _input,..       
-00003a70: 2022 7069 636b 6c65 645f 6675 6e63 223a   "pickled_func":
-00003a80: 2063 6c6f 7564 7069 636b 6c65 2e64 756d   cloudpickle.dum
-00003a90: 7073 2866 756e 6329 2c0d 0a20 2020 207d  ps(func),..    }
-00003aa0: 0d0a 2020 2020 6966 206f 7065 7261 7469  ..    if operati
-00003ab0: 6f6e 5f6e 616d 6520 6973 206e 6f74 204e  on_name is not N
-00003ac0: 6f6e 653a 0d0a 2020 2020 2020 2020 6f70  one:..        op
-00003ad0: 6572 6174 696f 6e5f 7061 7261 6d73 5b22  eration_params["
-00003ae0: 6f70 6572 6174 696f 6e5f 6e61 6d65 225d  operation_name"]
-00003af0: 203d 206f 7065 7261 7469 6f6e 5f6e 616d   = operation_nam
-00003b00: 650d 0a0d 0a20 2020 2023 2047 6f21 0d0a  e....    # Go!..
-00003b10: 2020 2020 7265 7475 726e 205f 6170 706c      return _appl
-00003b20: 795f 6765 6f6f 7065 7261 7469 6f6e 5f74  y_geooperation_t
-00003b30: 6f5f 6c61 7965 7228 0d0a 2020 2020 2020  o_layer(..      
-00003b40: 2020 696e 7075 745f 7061 7468 3d69 6e70    input_path=inp
-00003b50: 7574 5f70 6174 682c 0d0a 2020 2020 2020  ut_path,..      
-00003b60: 2020 6f75 7470 7574 5f70 6174 683d 6f75    output_path=ou
-00003b70: 7470 7574 5f70 6174 682c 0d0a 2020 2020  tput_path,..    
-00003b80: 2020 2020 6f70 6572 6174 696f 6e3d 4765      operation=Ge
-00003b90: 6f4f 7065 7261 7469 6f6e 2e41 5050 4c59  oOperation.APPLY
-00003ba0: 2c0d 0a20 2020 2020 2020 206f 7065 7261  ,..        opera
-00003bb0: 7469 6f6e 5f70 6172 616d 733d 6f70 6572  tion_params=oper
-00003bc0: 6174 696f 6e5f 7061 7261 6d73 2c0d 0a20  ation_params,.. 
-00003bd0: 2020 2020 2020 2069 6e70 7574 5f6c 6179         input_lay
-00003be0: 6572 3d69 6e70 7574 5f6c 6179 6572 2c0d  er=input_layer,.
-00003bf0: 0a20 2020 2020 2020 206f 7574 7075 745f  .        output_
-00003c00: 6c61 7965 723d 6f75 7470 7574 5f6c 6179  layer=output_lay
-00003c10: 6572 2c0d 0a20 2020 2020 2020 2063 6f6c  er,..        col
-00003c20: 756d 6e73 3d63 6f6c 756d 6e73 2c0d 0a20  umns=columns,.. 
-00003c30: 2020 2020 2020 2065 7870 6c6f 6465 636f         explodeco
-00003c40: 6c6c 6563 7469 6f6e 733d 6578 706c 6f64  llections=explod
-00003c50: 6563 6f6c 6c65 6374 696f 6e73 2c0d 0a20  ecollections,.. 
-00003c60: 2020 2020 2020 2066 6f72 6365 5f6f 7574         force_out
-00003c70: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-00003c80: 3d66 6f72 6365 5f6f 7574 7075 745f 6765  =force_output_ge
-00003c90: 6f6d 6574 7279 7479 7065 2c0d 0a20 2020  ometrytype,..   
-00003ca0: 2020 2020 2067 7269 6473 697a 653d 6772       gridsize=gr
-00003cb0: 6964 7369 7a65 2c0d 0a20 2020 2020 2020  idsize,..       
-00003cc0: 206b 6565 705f 656d 7074 795f 6765 6f6d   keep_empty_geom
-00003cd0: 733d 6b65 6570 5f65 6d70 7479 5f67 656f  s=keep_empty_geo
-00003ce0: 6d73 2c0d 0a20 2020 2020 2020 2077 6865  ms,..        whe
-00003cf0: 7265 5f70 6f73 743d 7768 6572 655f 706f  re_post=where_po
-00003d00: 7374 2c0d 0a20 2020 2020 2020 206e 625f  st,..        nb_
-00003d10: 7061 7261 6c6c 656c 3d6e 625f 7061 7261  parallel=nb_para
-00003d20: 6c6c 656c 2c0d 0a20 2020 2020 2020 2062  llel,..        b
-00003d30: 6174 6368 7369 7a65 3d62 6174 6368 7369  atchsize=batchsi
-00003d40: 7a65 2c0d 0a20 2020 2020 2020 2066 6f72  ze,..        for
-00003d50: 6365 3d66 6f72 6365 2c0d 0a20 2020 2020  ce=force,..     
-00003d60: 2020 2070 6172 616c 6c65 6c69 7a61 7469     parallelizati
-00003d70: 6f6e 5f63 6f6e 6669 673d 7061 7261 6c6c  on_config=parall
-00003d80: 656c 697a 6174 696f 6e5f 636f 6e66 6967  elization_config
-00003d90: 2c0d 0a20 2020 2029 0d0a 0d0a 0d0a 6465  ,..    )......de
-00003da0: 6620 6275 6666 6572 280d 0a20 2020 2069  f buffer(..    i
-00003db0: 6e70 7574 5f70 6174 683a 2050 6174 682c  nput_path: Path,
-00003dc0: 0d0a 2020 2020 6f75 7470 7574 5f70 6174  ..    output_pat
-00003dd0: 683a 2050 6174 682c 0d0a 2020 2020 6469  h: Path,..    di
-00003de0: 7374 616e 6365 3a20 666c 6f61 742c 0d0a  stance: float,..
-00003df0: 2020 2020 7175 6164 7261 6e74 7365 676d      quadrantsegm
-00003e00: 656e 7473 3a20 696e 7420 3d20 352c 0d0a  ents: int = 5,..
-00003e10: 2020 2020 656e 6463 6170 5f73 7479 6c65      endcap_style
-00003e20: 3a20 4275 6666 6572 456e 6443 6170 5374  : BufferEndCapSt
-00003e30: 796c 6520 3d20 4275 6666 6572 456e 6443  yle = BufferEndC
-00003e40: 6170 5374 796c 652e 524f 554e 442c 0d0a  apStyle.ROUND,..
-00003e50: 2020 2020 6a6f 696e 5f73 7479 6c65 3a20      join_style: 
-00003e60: 4275 6666 6572 4a6f 696e 5374 796c 6520  BufferJoinStyle 
-00003e70: 3d20 4275 6666 6572 4a6f 696e 5374 796c  = BufferJoinStyl
-00003e80: 652e 524f 554e 442c 0d0a 2020 2020 6d69  e.ROUND,..    mi
-00003e90: 7472 655f 6c69 6d69 743a 2066 6c6f 6174  tre_limit: float
-00003ea0: 203d 2035 2e30 2c0d 0a20 2020 2073 696e   = 5.0,..    sin
-00003eb0: 676c 655f 7369 6465 643a 2062 6f6f 6c20  gle_sided: bool 
-00003ec0: 3d20 4661 6c73 652c 0d0a 2020 2020 696e  = False,..    in
-00003ed0: 7075 745f 6c61 7965 723a 204f 7074 696f  put_layer: Optio
-00003ee0: 6e61 6c5b 7374 725d 203d 204e 6f6e 652c  nal[str] = None,
-00003ef0: 0d0a 2020 2020 6f75 7470 7574 5f6c 6179  ..    output_lay
-00003f00: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
-00003f10: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2063  ] = None,..    c
-00003f20: 6f6c 756d 6e73 3a20 4f70 7469 6f6e 616c  olumns: Optional
-00003f30: 5b4c 6973 745b 7374 725d 5d20 3d20 4e6f  [List[str]] = No
-00003f40: 6e65 2c0d 0a20 2020 2065 7870 6c6f 6465  ne,..    explode
-00003f50: 636f 6c6c 6563 7469 6f6e 733a 2062 6f6f  collections: boo
-00003f60: 6c20 3d20 4661 6c73 652c 0d0a 2020 2020  l = False,..    
-00003f70: 6772 6964 7369 7a65 3a20 666c 6f61 7420  gridsize: float 
-00003f80: 3d20 302e 302c 0d0a 2020 2020 6b65 6570  = 0.0,..    keep
-00003f90: 5f65 6d70 7479 5f67 656f 6d73 3a20 626f  _empty_geoms: bo
-00003fa0: 6f6c 203d 2054 7275 652c 0d0a 2020 2020  ol = True,..    
-00003fb0: 7768 6572 655f 706f 7374 3a20 4f70 7469  where_post: Opti
-00003fc0: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
-00003fd0: 2c0d 0a20 2020 206e 625f 7061 7261 6c6c  ,..    nb_parall
-00003fe0: 656c 3a20 696e 7420 3d20 2d31 2c0d 0a20  el: int = -1,.. 
-00003ff0: 2020 2062 6174 6368 7369 7a65 3a20 696e     batchsize: in
-00004000: 7420 3d20 2d31 2c0d 0a20 2020 2066 6f72  t = -1,..    for
-00004010: 6365 3a20 626f 6f6c 203d 2046 616c 7365  ce: bool = False
-00004020: 2c0d 0a20 2020 206f 7065 7261 7469 6f6e  ,..    operation
-00004030: 5f70 7265 6669 783a 2073 7472 203d 2022  _prefix: str = "
-00004040: 222c 0d0a 293a 0d0a 2020 2020 2320 496e  ",..):..    # In
-00004050: 6974 0d0a 2020 2020 6f70 6572 6174 696f  it..    operatio
-00004060: 6e5f 7061 7261 6d73 203d 207b 0d0a 2020  n_params = {..  
-00004070: 2020 2020 2020 226f 7065 7261 7469 6f6e        "operation
-00004080: 5f6e 616d 6522 3a20 6622 7b6f 7065 7261  _name": f"{opera
-00004090: 7469 6f6e 5f70 7265 6669 787d 6275 6666  tion_prefix}buff
-000040a0: 6572 222c 0d0a 2020 2020 2020 2020 2264  er",..        "d
-000040b0: 6973 7461 6e63 6522 3a20 6469 7374 616e  istance": distan
-000040c0: 6365 2c0d 0a20 2020 2020 2020 2022 7175  ce,..        "qu
-000040d0: 6164 7261 6e74 7365 676d 656e 7473 223a  adrantsegments":
-000040e0: 2071 7561 6472 616e 7473 6567 6d65 6e74   quadrantsegment
-000040f0: 732c 0d0a 2020 2020 2020 2020 2265 6e64  s,..        "end
-00004100: 6361 705f 7374 796c 6522 3a20 656e 6463  cap_style": endc
-00004110: 6170 5f73 7479 6c65 2c0d 0a20 2020 2020  ap_style,..     
-00004120: 2020 2022 6a6f 696e 5f73 7479 6c65 223a     "join_style":
-00004130: 206a 6f69 6e5f 7374 796c 652c 0d0a 2020   join_style,..  
-00004140: 2020 2020 2020 226d 6974 7265 5f6c 696d        "mitre_lim
-00004150: 6974 223a 206d 6974 7265 5f6c 696d 6974  it": mitre_limit
-00004160: 2c0d 0a20 2020 2020 2020 2022 7369 6e67  ,..        "sing
-00004170: 6c65 5f73 6964 6564 223a 2073 696e 676c  le_sided": singl
-00004180: 655f 7369 6465 642c 0d0a 2020 2020 7d0d  e_sided,..    }.
-00004190: 0a0d 0a20 2020 2023 2042 7566 6665 7220  ...    # Buffer 
-000041a0: 6f70 6572 6174 696f 6e20 616c 7761 7973  operation always
-000041b0: 2072 6573 756c 7473 2069 6e20 706f 6c79   results in poly
-000041c0: 676f 6e73 2e2e 2e0d 0a20 2020 2069 6620  gons.....    if 
-000041d0: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
-000041e0: 6e73 3a0d 0a20 2020 2020 2020 2066 6f72  ns:..        for
-000041f0: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
-00004200: 7279 7479 7065 203d 2047 656f 6d65 7472  rytype = Geometr
-00004210: 7954 7970 652e 504f 4c59 474f 4e2e 6e61  yType.POLYGON.na
-00004220: 6d65 0d0a 2020 2020 656c 7365 3a0d 0a20  me..    else:.. 
-00004230: 2020 2020 2020 2066 6f72 6365 5f6f 7574         force_out
-00004240: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-00004250: 203d 2047 656f 6d65 7472 7954 7970 652e   = GeometryType.
-00004260: 4d55 4c54 4950 4f4c 5947 4f4e 2e6e 616d  MULTIPOLYGON.nam
-00004270: 650d 0a0d 0a20 2020 2023 2047 6f21 0d0a  e....    # Go!..
-00004280: 2020 2020 7265 7475 726e 205f 6170 706c      return _appl
-00004290: 795f 6765 6f6f 7065 7261 7469 6f6e 5f74  y_geooperation_t
-000042a0: 6f5f 6c61 7965 7228 0d0a 2020 2020 2020  o_layer(..      
-000042b0: 2020 696e 7075 745f 7061 7468 3d69 6e70    input_path=inp
-000042c0: 7574 5f70 6174 682c 0d0a 2020 2020 2020  ut_path,..      
-000042d0: 2020 6f75 7470 7574 5f70 6174 683d 6f75    output_path=ou
-000042e0: 7470 7574 5f70 6174 682c 0d0a 2020 2020  tput_path,..    
-000042f0: 2020 2020 6f70 6572 6174 696f 6e3d 4765      operation=Ge
-00004300: 6f4f 7065 7261 7469 6f6e 2e42 5546 4645  oOperation.BUFFE
-00004310: 522c 0d0a 2020 2020 2020 2020 6f70 6572  R,..        oper
-00004320: 6174 696f 6e5f 7061 7261 6d73 3d6f 7065  ation_params=ope
-00004330: 7261 7469 6f6e 5f70 6172 616d 732c 0d0a  ration_params,..
-00004340: 2020 2020 2020 2020 696e 7075 745f 6c61          input_la
-00004350: 7965 723d 696e 7075 745f 6c61 7965 722c  yer=input_layer,
-00004360: 0d0a 2020 2020 2020 2020 6f75 7470 7574  ..        output
-00004370: 5f6c 6179 6572 3d6f 7574 7075 745f 6c61  _layer=output_la
-00004380: 7965 722c 0d0a 2020 2020 2020 2020 636f  yer,..        co
-00004390: 6c75 6d6e 733d 636f 6c75 6d6e 732c 0d0a  lumns=columns,..
-000043a0: 2020 2020 2020 2020 6578 706c 6f64 6563          explodec
-000043b0: 6f6c 6c65 6374 696f 6e73 3d65 7870 6c6f  ollections=explo
-000043c0: 6465 636f 6c6c 6563 7469 6f6e 732c 0d0a  decollections,..
-000043d0: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
-000043e0: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
-000043f0: 653d 666f 7263 655f 6f75 7470 7574 5f67  e=force_output_g
-00004400: 656f 6d65 7472 7974 7970 652c 0d0a 2020  eometrytype,..  
-00004410: 2020 2020 2020 6772 6964 7369 7a65 3d67        gridsize=g
-00004420: 7269 6473 697a 652c 0d0a 2020 2020 2020  ridsize,..      
-00004430: 2020 6b65 6570 5f65 6d70 7479 5f67 656f    keep_empty_geo
-00004440: 6d73 3d6b 6565 705f 656d 7074 795f 6765  ms=keep_empty_ge
-00004450: 6f6d 732c 0d0a 2020 2020 2020 2020 7768  oms,..        wh
-00004460: 6572 655f 706f 7374 3d77 6865 7265 5f70  ere_post=where_p
-00004470: 6f73 742c 0d0a 2020 2020 2020 2020 6e62  ost,..        nb
-00004480: 5f70 6172 616c 6c65 6c3d 6e62 5f70 6172  _parallel=nb_par
-00004490: 616c 6c65 6c2c 0d0a 2020 2020 2020 2020  allel,..        
-000044a0: 6261 7463 6873 697a 653d 6261 7463 6873  batchsize=batchs
-000044b0: 697a 652c 0d0a 2020 2020 2020 2020 666f  ize,..        fo
-000044c0: 7263 653d 666f 7263 652c 0d0a 2020 2020  rce=force,..    
-000044d0: 290d 0a0d 0a0d 0a64 6566 2063 6f6e 7665  )......def conve
-000044e0: 7868 756c 6c28 0d0a 2020 2020 696e 7075  xhull(..    inpu
-000044f0: 745f 7061 7468 3a20 5061 7468 2c0d 0a20  t_path: Path,.. 
-00004500: 2020 206f 7574 7075 745f 7061 7468 3a20     output_path: 
-00004510: 5061 7468 2c0d 0a20 2020 2069 6e70 7574  Path,..    input
-00004520: 5f6c 6179 6572 3a20 4f70 7469 6f6e 616c  _layer: Optional
-00004530: 5b73 7472 5d20 3d20 4e6f 6e65 2c0d 0a20  [str] = None,.. 
-00004540: 2020 206f 7574 7075 745f 6c61 7965 723a     output_layer:
-00004550: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
-00004560: 204e 6f6e 652c 0d0a 2020 2020 636f 6c75   None,..    colu
-00004570: 6d6e 733a 204f 7074 696f 6e61 6c5b 4c69  mns: Optional[Li
-00004580: 7374 5b73 7472 5d5d 203d 204e 6f6e 652c  st[str]] = None,
-00004590: 0d0a 2020 2020 6578 706c 6f64 6563 6f6c  ..    explodecol
-000045a0: 6c65 6374 696f 6e73 3a20 626f 6f6c 203d  lections: bool =
-000045b0: 2046 616c 7365 2c0d 0a20 2020 2067 7269   False,..    gri
-000045c0: 6473 697a 653a 2066 6c6f 6174 203d 2030  dsize: float = 0
-000045d0: 2e30 2c0d 0a20 2020 206b 6565 705f 656d  .0,..    keep_em
-000045e0: 7074 795f 6765 6f6d 733a 2062 6f6f 6c20  pty_geoms: bool 
-000045f0: 3d20 5472 7565 2c0d 0a20 2020 2077 6865  = True,..    whe
-00004600: 7265 5f70 6f73 743a 204f 7074 696f 6e61  re_post: Optiona
-00004610: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
-00004620: 2020 2020 6e62 5f70 6172 616c 6c65 6c3a      nb_parallel:
-00004630: 2069 6e74 203d 202d 312c 0d0a 2020 2020   int = -1,..    
-00004640: 6261 7463 6873 697a 653a 2069 6e74 203d  batchsize: int =
-00004650: 202d 312c 0d0a 2020 2020 666f 7263 653a   -1,..    force:
-00004660: 2062 6f6f 6c20 3d20 4661 6c73 652c 0d0a   bool = False,..
-00004670: 293a 0d0a 2020 2020 2320 496e 6974 0d0a  ):..    # Init..
-00004680: 2020 2020 6f70 6572 6174 696f 6e5f 7061      operation_pa
-00004690: 7261 6d73 3a20 4469 6374 5b73 7472 2c20  rams: Dict[str, 
-000046a0: 416e 795d 203d 207b 7d0d 0a0d 0a20 2020  Any] = {}....   
-000046b0: 2023 2047 6f21 0d0a 2020 2020 7265 7475   # Go!..    retu
-000046c0: 726e 205f 6170 706c 795f 6765 6f6f 7065  rn _apply_geoope
-000046d0: 7261 7469 6f6e 5f74 6f5f 6c61 7965 7228  ration_to_layer(
-000046e0: 0d0a 2020 2020 2020 2020 696e 7075 745f  ..        input_
-000046f0: 7061 7468 3d69 6e70 7574 5f70 6174 682c  path=input_path,
-00004700: 0d0a 2020 2020 2020 2020 6f75 7470 7574  ..        output
-00004710: 5f70 6174 683d 6f75 7470 7574 5f70 6174  _path=output_pat
-00004720: 682c 0d0a 2020 2020 2020 2020 6f70 6572  h,..        oper
-00004730: 6174 696f 6e3d 4765 6f4f 7065 7261 7469  ation=GeoOperati
-00004740: 6f6e 2e43 4f4e 5645 5848 554c 4c2c 0d0a  on.CONVEXHULL,..
-00004750: 2020 2020 2020 2020 6f70 6572 6174 696f          operatio
-00004760: 6e5f 7061 7261 6d73 3d6f 7065 7261 7469  n_params=operati
-00004770: 6f6e 5f70 6172 616d 732c 0d0a 2020 2020  on_params,..    
-00004780: 2020 2020 696e 7075 745f 6c61 7965 723d      input_layer=
-00004790: 696e 7075 745f 6c61 7965 722c 0d0a 2020  input_layer,..  
-000047a0: 2020 2020 2020 6f75 7470 7574 5f6c 6179        output_lay
-000047b0: 6572 3d6f 7574 7075 745f 6c61 7965 722c  er=output_layer,
-000047c0: 0d0a 2020 2020 2020 2020 636f 6c75 6d6e  ..        column
-000047d0: 733d 636f 6c75 6d6e 732c 0d0a 2020 2020  s=columns,..    
-000047e0: 2020 2020 6578 706c 6f64 6563 6f6c 6c65      explodecolle
-000047f0: 6374 696f 6e73 3d65 7870 6c6f 6465 636f  ctions=explodeco
-00004800: 6c6c 6563 7469 6f6e 732c 0d0a 2020 2020  llections,..    
-00004810: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
-00004820: 5f67 656f 6d65 7472 7974 7970 653d 4e6f  _geometrytype=No
-00004830: 6e65 2c0d 0a20 2020 2020 2020 2067 7269  ne,..        gri
-00004840: 6473 697a 653d 6772 6964 7369 7a65 2c0d  dsize=gridsize,.
-00004850: 0a20 2020 2020 2020 206b 6565 705f 656d  .        keep_em
-00004860: 7074 795f 6765 6f6d 733d 6b65 6570 5f65  pty_geoms=keep_e
-00004870: 6d70 7479 5f67 656f 6d73 2c0d 0a20 2020  mpty_geoms,..   
-00004880: 2020 2020 2077 6865 7265 5f70 6f73 743d       where_post=
-00004890: 7768 6572 655f 706f 7374 2c0d 0a20 2020  where_post,..   
-000048a0: 2020 2020 206e 625f 7061 7261 6c6c 656c       nb_parallel
-000048b0: 3d6e 625f 7061 7261 6c6c 656c 2c0d 0a20  =nb_parallel,.. 
-000048c0: 2020 2020 2020 2062 6174 6368 7369 7a65         batchsize
-000048d0: 3d62 6174 6368 7369 7a65 2c0d 0a20 2020  =batchsize,..   
-000048e0: 2020 2020 2066 6f72 6365 3d66 6f72 6365       force=force
-000048f0: 2c0d 0a20 2020 2029 0d0a 0d0a 0d0a 6465  ,..    )......de
-00004900: 6620 6d61 6b65 7661 6c69 6428 0d0a 2020  f makevalid(..  
-00004910: 2020 696e 7075 745f 7061 7468 3a20 5061    input_path: Pa
-00004920: 7468 2c0d 0a20 2020 206f 7574 7075 745f  th,..    output_
-00004930: 7061 7468 3a20 5061 7468 2c0d 0a20 2020  path: Path,..   
-00004940: 2069 6e70 7574 5f6c 6179 6572 3a20 4f70   input_layer: Op
-00004950: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
-00004960: 6e65 2c0d 0a20 2020 206f 7574 7075 745f  ne,..    output_
-00004970: 6c61 7965 723a 204f 7074 696f 6e61 6c5b  layer: Optional[
-00004980: 7374 725d 203d 204e 6f6e 652c 0d0a 2020  str] = None,..  
-00004990: 2020 636f 6c75 6d6e 733a 204f 7074 696f    columns: Optio
-000049a0: 6e61 6c5b 4c69 7374 5b73 7472 5d5d 203d  nal[List[str]] =
-000049b0: 204e 6f6e 652c 0d0a 2020 2020 6578 706c   None,..    expl
-000049c0: 6f64 6563 6f6c 6c65 6374 696f 6e73 3a20  odecollections: 
-000049d0: 626f 6f6c 203d 2046 616c 7365 2c0d 0a20  bool = False,.. 
-000049e0: 2020 2066 6f72 6365 5f6f 7574 7075 745f     force_output_
-000049f0: 6765 6f6d 6574 7279 7479 7065 3a20 4f70  geometrytype: Op
-00004a00: 7469 6f6e 616c 5b47 656f 6d65 7472 7954  tional[GeometryT
-00004a10: 7970 655d 203d 204e 6f6e 652c 0d0a 2020  ype] = None,..  
-00004a20: 2020 6772 6964 7369 7a65 3a20 666c 6f61    gridsize: floa
-00004a30: 7420 3d20 302e 302c 0d0a 2020 2020 6b65  t = 0.0,..    ke
-00004a40: 6570 5f65 6d70 7479 5f67 656f 6d73 3a20  ep_empty_geoms: 
-00004a50: 626f 6f6c 203d 2054 7275 652c 0d0a 2020  bool = True,..  
-00004a60: 2020 7768 6572 655f 706f 7374 3a20 4f70    where_post: Op
-00004a70: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
-00004a80: 6e65 2c0d 0a20 2020 2076 616c 6964 6174  ne,..    validat
-00004a90: 655f 6174 7472 6962 7574 655f 6461 7461  e_attribute_data
-00004aa0: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-00004ab0: 0a20 2020 206e 625f 7061 7261 6c6c 656c  .    nb_parallel
-00004ac0: 3a20 696e 7420 3d20 2d31 2c0d 0a20 2020  : int = -1,..   
-00004ad0: 2062 6174 6368 7369 7a65 3a20 696e 7420   batchsize: int 
-00004ae0: 3d20 2d31 2c0d 0a20 2020 2066 6f72 6365  = -1,..    force
-00004af0: 3a20 626f 6f6c 203d 2046 616c 7365 2c0d  : bool = False,.
-00004b00: 0a29 3a0d 0a20 2020 2023 2044 6574 6572  .):..    # Deter
-00004b10: 6d69 6e65 2069 6620 636f 6c6c 6170 7365  mine if collapse
-00004b20: 6420 7061 7274 7320 6e65 6564 2074 6f20  d parts need to 
-00004b30: 6265 206b 6570 7420 6166 7465 7220 6d61  be kept after ma
-00004b40: 6b65 7661 6c69 6420 6f72 206e 6f74 0d0a  kevalid or not..
-00004b50: 2020 2020 6b65 6570 5f63 6f6c 6c61 7073      keep_collaps
-00004b60: 6564 203d 2054 7275 650d 0a20 2020 2069  ed = True..    i
-00004b70: 6620 666f 7263 655f 6f75 7470 7574 5f67  f force_output_g
-00004b80: 656f 6d65 7472 7974 7970 6520 6973 204e  eometrytype is N
-00004b90: 6f6e 653a 0d0a 2020 2020 2020 2020 6b65  one:..        ke
-00004ba0: 6570 5f63 6f6c 6c61 7073 6564 203d 2046  ep_collapsed = F
-00004bb0: 616c 7365 0d0a 2020 2020 656c 7365 3a0d  alse..    else:.
-00004bc0: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
-00004bd0: 7374 616e 6365 2866 6f72 6365 5f6f 7574  stance(force_out
-00004be0: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-00004bf0: 2c20 4765 6f6d 6574 7279 5479 7065 293a  , GeometryType):
-00004c00: 0d0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
-00004c10: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-00004c20: 7472 7974 7970 6520 3d20 666f 7263 655f  trytype = force_
-00004c30: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-00004c40: 7970 652e 6e61 6d65 0d0a 2020 2020 2020  ype.name..      
-00004c50: 2020 696e 666f 203d 2066 696c 656f 7073    info = fileops
-00004c60: 2e67 6574 5f6c 6179 6572 696e 666f 2869  .get_layerinfo(i
-00004c70: 6e70 7574 5f70 6174 6829 0d0a 2020 2020  nput_path)..    
-00004c80: 2020 2020 6966 2066 6f72 6365 5f6f 7574      if force_out
-00004c90: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
-00004ca0: 2e73 7461 7274 7377 6974 6828 0d0a 2020  .startswith(..  
-00004cb0: 2020 2020 2020 2020 2020 696e 666f 2e67            info.g
-00004cc0: 656f 6d65 7472 7974 7970 656e 616d 650d  eometrytypename.
-00004cd0: 0a20 2020 2020 2020 2029 206f 7220 696e  .        ) or in
-00004ce0: 666f 2e67 656f 6d65 7472 7974 7970 656e  fo.geometrytypen
-00004cf0: 616d 652e 7374 6172 7473 7769 7468 2866  ame.startswith(f
-00004d00: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-00004d10: 6574 7279 7479 7065 293a 0d0a 2020 2020  etrytype):..    
-00004d20: 2020 2020 2020 2020 6b65 6570 5f63 6f6c          keep_col
-00004d30: 6c61 7073 6564 203d 2046 616c 7365 0d0a  lapsed = False..
-00004d40: 0d0a 2020 2020 6170 706c 7928 0d0a 2020  ..    apply(..  
-00004d50: 2020 2020 2020 696e 7075 745f 7061 7468        input_path
-00004d60: 3d50 6174 6828 696e 7075 745f 7061 7468  =Path(input_path
-00004d70: 292c 0d0a 2020 2020 2020 2020 6f75 7470  ),..        outp
-00004d80: 7574 5f70 6174 683d 5061 7468 286f 7574  ut_path=Path(out
-00004d90: 7075 745f 7061 7468 292c 0d0a 2020 2020  put_path),..    
-00004da0: 2020 2020 6675 6e63 3d6c 616d 6264 6120      func=lambda 
-00004db0: 6765 6f6d 3a20 7079 6765 6f6f 7073 2e6d  geom: pygeoops.m
-00004dc0: 616b 655f 7661 6c69 6428 0d0a 2020 2020  ake_valid(..    
-00004dd0: 2020 2020 2020 2020 6765 6f6d 2c20 6b65          geom, ke
-00004de0: 6570 5f63 6f6c 6c61 7073 6564 3d6b 6565  ep_collapsed=kee
-00004df0: 705f 636f 6c6c 6170 7365 642c 206f 6e6c  p_collapsed, onl
-00004e00: 795f 6966 5f69 6e76 616c 6964 3d54 7275  y_if_invalid=Tru
-00004e10: 650d 0a20 2020 2020 2020 2029 2c0d 0a20  e..        ),.. 
-00004e20: 2020 2020 2020 206f 7065 7261 7469 6f6e         operation
-00004e30: 5f6e 616d 653d 226d 616b 6576 616c 6964  _name="makevalid
-00004e40: 222c 0d0a 2020 2020 2020 2020 696e 7075  ",..        inpu
-00004e50: 745f 6c61 7965 723d 696e 7075 745f 6c61  t_layer=input_la
-00004e60: 7965 722c 0d0a 2020 2020 2020 2020 6f75  yer,..        ou
-00004e70: 7470 7574 5f6c 6179 6572 3d6f 7574 7075  tput_layer=outpu
-00004e80: 745f 6c61 7965 722c 0d0a 2020 2020 2020  t_layer,..      
-00004e90: 2020 636f 6c75 6d6e 733d 636f 6c75 6d6e    columns=column
-00004ea0: 732c 0d0a 2020 2020 2020 2020 6578 706c  s,..        expl
-00004eb0: 6f64 6563 6f6c 6c65 6374 696f 6e73 3d65  odecollections=e
-00004ec0: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
-00004ed0: 732c 0d0a 2020 2020 2020 2020 666f 7263  s,..        forc
-00004ee0: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-00004ef0: 7974 7970 653d 666f 7263 655f 6f75 7470  ytype=force_outp
-00004f00: 7574 5f67 656f 6d65 7472 7974 7970 652c  ut_geometrytype,
-00004f10: 0d0a 2020 2020 2020 2020 6772 6964 7369  ..        gridsi
-00004f20: 7a65 3d67 7269 6473 697a 652c 0d0a 2020  ze=gridsize,..  
-00004f30: 2020 2020 2020 6b65 6570 5f65 6d70 7479        keep_empty
-00004f40: 5f67 656f 6d73 3d6b 6565 705f 656d 7074  _geoms=keep_empt
-00004f50: 795f 6765 6f6d 732c 0d0a 2020 2020 2020  y_geoms,..      
-00004f60: 2020 7768 6572 655f 706f 7374 3d77 6865    where_post=whe
-00004f70: 7265 5f70 6f73 742c 0d0a 2020 2020 2020  re_post,..      
-00004f80: 2020 6e62 5f70 6172 616c 6c65 6c3d 6e62    nb_parallel=nb
-00004f90: 5f70 6172 616c 6c65 6c2c 0d0a 2020 2020  _parallel,..    
-00004fa0: 2020 2020 6261 7463 6873 697a 653d 6261      batchsize=ba
-00004fb0: 7463 6873 697a 652c 0d0a 2020 2020 2020  tchsize,..      
-00004fc0: 2020 666f 7263 653d 666f 7263 652c 0d0a    force=force,..
-00004fd0: 2020 2020 290d 0a0d 0a0d 0a64 6566 2073      )......def s
-00004fe0: 696d 706c 6966 7928 0d0a 2020 2020 696e  implify(..    in
-00004ff0: 7075 745f 7061 7468 3a20 5061 7468 2c0d  put_path: Path,.
-00005000: 0a20 2020 206f 7574 7075 745f 7061 7468  .    output_path
-00005010: 3a20 5061 7468 2c0d 0a20 2020 2074 6f6c  : Path,..    tol
-00005020: 6572 616e 6365 3a20 666c 6f61 742c 0d0a  erance: float,..
-00005030: 2020 2020 616c 676f 7269 7468 6d3a 2053      algorithm: S
-00005040: 696d 706c 6966 7941 6c67 6f72 6974 686d  implifyAlgorithm
-00005050: 203d 2053 696d 706c 6966 7941 6c67 6f72   = SimplifyAlgor
-00005060: 6974 686d 2e52 414d 4552 5f44 4f55 474c  ithm.RAMER_DOUGL
-00005070: 4153 5f50 4555 434b 4552 2c0d 0a20 2020  AS_PEUCKER,..   
-00005080: 206c 6f6f 6b61 6865 6164 3a20 696e 7420   lookahead: int 
-00005090: 3d20 382c 0d0a 2020 2020 696e 7075 745f  = 8,..    input_
-000050a0: 6c61 7965 723a 204f 7074 696f 6e61 6c5b  layer: Optional[
-000050b0: 7374 725d 203d 204e 6f6e 652c 0d0a 2020  str] = None,..  
-000050c0: 2020 6f75 7470 7574 5f6c 6179 6572 3a20    output_layer: 
-000050d0: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
-000050e0: 4e6f 6e65 2c0d 0a20 2020 2063 6f6c 756d  None,..    colum
-000050f0: 6e73 3a20 4f70 7469 6f6e 616c 5b4c 6973  ns: Optional[Lis
-00005100: 745b 7374 725d 5d20 3d20 4e6f 6e65 2c0d  t[str]] = None,.
-00005110: 0a20 2020 2065 7870 6c6f 6465 636f 6c6c  .    explodecoll
-00005120: 6563 7469 6f6e 733a 2062 6f6f 6c20 3d20  ections: bool = 
-00005130: 4661 6c73 652c 0d0a 2020 2020 6772 6964  False,..    grid
-00005140: 7369 7a65 3a20 666c 6f61 7420 3d20 302e  size: float = 0.
-00005150: 302c 0d0a 2020 2020 6b65 6570 5f65 6d70  0,..    keep_emp
-00005160: 7479 5f67 656f 6d73 3a20 626f 6f6c 203d  ty_geoms: bool =
-00005170: 2054 7275 652c 0d0a 2020 2020 7768 6572   True,..    wher
-00005180: 655f 706f 7374 3a20 4f70 7469 6f6e 616c  e_post: Optional
-00005190: 5b73 7472 5d20 3d20 4e6f 6e65 2c0d 0a20  [str] = None,.. 
-000051a0: 2020 206e 625f 7061 7261 6c6c 656c 3a20     nb_parallel: 
-000051b0: 696e 7420 3d20 2d31 2c0d 0a20 2020 2062  int = -1,..    b
-000051c0: 6174 6368 7369 7a65 3a20 696e 7420 3d20  atchsize: int = 
-000051d0: 2d31 2c0d 0a20 2020 2066 6f72 6365 3a20  -1,..    force: 
-000051e0: 626f 6f6c 203d 2046 616c 7365 2c0d 0a29  bool = False,..)
-000051f0: 3a0d 0a20 2020 2023 2049 6e69 740d 0a20  :..    # Init.. 
-00005200: 2020 206f 7065 7261 7469 6f6e 5f70 6172     operation_par
-00005210: 616d 7320 3d20 7b0d 0a20 2020 2020 2020  ams = {..       
-00005220: 2022 746f 6c65 7261 6e63 6522 3a20 746f   "tolerance": to
-00005230: 6c65 7261 6e63 652c 0d0a 2020 2020 2020  lerance,..      
-00005240: 2020 2261 6c67 6f72 6974 686d 223a 2061    "algorithm": a
-00005250: 6c67 6f72 6974 686d 2c0d 0a20 2020 2020  lgorithm,..     
-00005260: 2020 2022 7374 6570 223a 206c 6f6f 6b61     "step": looka
-00005270: 6865 6164 2c0d 0a20 2020 207d 0d0a 0d0a  head,..    }....
-00005280: 2020 2020 2320 476f 210d 0a20 2020 2072      # Go!..    r
-00005290: 6574 7572 6e20 5f61 7070 6c79 5f67 656f  eturn _apply_geo
-000052a0: 6f70 6572 6174 696f 6e5f 746f 5f6c 6179  operation_to_lay
-000052b0: 6572 280d 0a20 2020 2020 2020 2069 6e70  er(..        inp
-000052c0: 7574 5f70 6174 683d 696e 7075 745f 7061  ut_path=input_pa
-000052d0: 7468 2c0d 0a20 2020 2020 2020 206f 7574  th,..        out
-000052e0: 7075 745f 7061 7468 3d6f 7574 7075 745f  put_path=output_
-000052f0: 7061 7468 2c0d 0a20 2020 2020 2020 206f  path,..        o
-00005300: 7065 7261 7469 6f6e 3d47 656f 4f70 6572  peration=GeoOper
-00005310: 6174 696f 6e2e 5349 4d50 4c49 4659 2c0d  ation.SIMPLIFY,.
-00005320: 0a20 2020 2020 2020 206f 7065 7261 7469  .        operati
-00005330: 6f6e 5f70 6172 616d 733d 6f70 6572 6174  on_params=operat
-00005340: 696f 6e5f 7061 7261 6d73 2c0d 0a20 2020  ion_params,..   
-00005350: 2020 2020 2069 6e70 7574 5f6c 6179 6572       input_layer
-00005360: 3d69 6e70 7574 5f6c 6179 6572 2c0d 0a20  =input_layer,.. 
-00005370: 2020 2020 2020 206f 7574 7075 745f 6c61         output_la
-00005380: 7965 723d 6f75 7470 7574 5f6c 6179 6572  yer=output_layer
-00005390: 2c0d 0a20 2020 2020 2020 2063 6f6c 756d  ,..        colum
-000053a0: 6e73 3d63 6f6c 756d 6e73 2c0d 0a20 2020  ns=columns,..   
-000053b0: 2020 2020 2065 7870 6c6f 6465 636f 6c6c       explodecoll
-000053c0: 6563 7469 6f6e 733d 6578 706c 6f64 6563  ections=explodec
-000053d0: 6f6c 6c65 6374 696f 6e73 2c0d 0a20 2020  ollections,..   
-000053e0: 2020 2020 2066 6f72 6365 5f6f 7574 7075       force_outpu
-000053f0: 745f 6765 6f6d 6574 7279 7479 7065 3d4e  t_geometrytype=N
-00005400: 6f6e 652c 0d0a 2020 2020 2020 2020 6772  one,..        gr
-00005410: 6964 7369 7a65 3d67 7269 6473 697a 652c  idsize=gridsize,
-00005420: 0d0a 2020 2020 2020 2020 6b65 6570 5f65  ..        keep_e
-00005430: 6d70 7479 5f67 656f 6d73 3d6b 6565 705f  mpty_geoms=keep_
-00005440: 656d 7074 795f 6765 6f6d 732c 0d0a 2020  empty_geoms,..  
-00005450: 2020 2020 2020 7768 6572 655f 706f 7374        where_post
-00005460: 3d77 6865 7265 5f70 6f73 742c 0d0a 2020  =where_post,..  
-00005470: 2020 2020 2020 6e62 5f70 6172 616c 6c65        nb_paralle
-00005480: 6c3d 6e62 5f70 6172 616c 6c65 6c2c 0d0a  l=nb_parallel,..
-00005490: 2020 2020 2020 2020 6261 7463 6873 697a          batchsiz
-000054a0: 653d 6261 7463 6873 697a 652c 0d0a 2020  e=batchsize,..  
-000054b0: 2020 2020 2020 666f 7263 653d 666f 7263        force=forc
-000054c0: 652c 0d0a 2020 2020 290d 0a0d 0a0d 0a64  e,..    )......d
-000054d0: 6566 205f 6170 706c 795f 6765 6f6f 7065  ef _apply_geoope
-000054e0: 7261 7469 6f6e 5f74 6f5f 6c61 7965 7228  ration_to_layer(
-000054f0: 0d0a 2020 2020 696e 7075 745f 7061 7468  ..    input_path
-00005500: 3a20 5061 7468 2c0d 0a20 2020 206f 7574  : Path,..    out
-00005510: 7075 745f 7061 7468 3a20 5061 7468 2c0d  put_path: Path,.
-00005520: 0a20 2020 206f 7065 7261 7469 6f6e 3a20  .    operation: 
-00005530: 4765 6f4f 7065 7261 7469 6f6e 2c0d 0a20  GeoOperation,.. 
-00005540: 2020 206f 7065 7261 7469 6f6e 5f70 6172     operation_par
-00005550: 616d 733a 2064 6963 742c 0d0a 2020 2020  ams: dict,..    
-00005560: 696e 7075 745f 6c61 7965 723a 204f 7074  input_layer: Opt
-00005570: 696f 6e61 6c5b 7374 725d 2c20 2023 203d  ional[str],  # =
-00005580: 204e 6f6e 650d 0a20 2020 2063 6f6c 756d   None..    colum
-00005590: 6e73 3a20 4f70 7469 6f6e 616c 5b4c 6973  ns: Optional[Lis
-000055a0: 745b 7374 725d 5d2c 2020 2320 3d20 4e6f  t[str]],  # = No
-000055b0: 6e65 0d0a 2020 2020 6f75 7470 7574 5f6c  ne..    output_l
-000055c0: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
-000055d0: 7472 5d2c 2020 2320 3d20 4e6f 6e65 0d0a  tr],  # = None..
-000055e0: 2020 2020 6578 706c 6f64 6563 6f6c 6c65      explodecolle
-000055f0: 6374 696f 6e73 3a20 626f 6f6c 2c20 2023  ctions: bool,  #
-00005600: 203d 2046 616c 7365 0d0a 2020 2020 666f   = False..    fo
-00005610: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-00005620: 7472 7974 7970 653a 2055 6e69 6f6e 5b47  trytype: Union[G
-00005630: 656f 6d65 7472 7954 7970 652c 2073 7472  eometryType, str
-00005640: 2c20 4e6f 6e65 5d2c 2020 2320 3d20 4e6f  , None],  # = No
-00005650: 6e65 0d0a 2020 2020 6772 6964 7369 7a65  ne..    gridsize
-00005660: 3a20 666c 6f61 742c 2020 2320 3d20 302e  : float,  # = 0.
-00005670: 300d 0a20 2020 206b 6565 705f 656d 7074  0..    keep_empt
-00005680: 795f 6765 6f6d 733a 2062 6f6f 6c2c 2020  y_geoms: bool,  
-00005690: 2320 3d20 5472 7565 0d0a 2020 2020 7768  # = True..    wh
-000056a0: 6572 655f 706f 7374 3a20 4f70 7469 6f6e  ere_post: Option
-000056b0: 616c 5b73 7472 5d2c 2020 2320 3d20 4e6f  al[str],  # = No
-000056c0: 6e65 0d0a 2020 2020 6e62 5f70 6172 616c  ne..    nb_paral
-000056d0: 6c65 6c3a 2069 6e74 2c20 2023 203d 202d  lel: int,  # = -
-000056e0: 310d 0a20 2020 2062 6174 6368 7369 7a65  1..    batchsize
-000056f0: 3a20 696e 742c 2020 2320 3d20 2d31 0d0a  : int,  # = -1..
-00005700: 2020 2020 666f 7263 653a 2062 6f6f 6c2c      force: bool,
-00005710: 2020 2320 3d20 4661 6c73 650d 0a20 2020    # = False..   
-00005720: 2070 6172 616c 6c65 6c69 7a61 7469 6f6e   parallelization
-00005730: 5f63 6f6e 6669 673a 2050 6172 616c 6c65  _config: Paralle
-00005740: 6c69 7a61 7469 6f6e 436f 6e66 6967 203d  lizationConfig =
-00005750: 204e 6f6e 652c 0d0a 293a 0d0a 2020 2020   None,..):..    
-00005760: 2222 220d 0a20 2020 2041 7070 6c69 6573  """..    Applies
-00005770: 2061 2067 656f 206f 7065 7261 7469 6f6e   a geo operation
-00005780: 206f 6e20 6120 6c61 7965 722e 0d0a 0d0a   on a layer.....
-00005790: 2020 2020 5468 6520 6f70 6572 6174 696f      The operatio
-000057a0: 6e20 746f 2061 7070 6c79 2063 616e 2062  n to apply can b
-000057b0: 6520 6f6e 6520 6f66 2074 6865 2074 6865  e one of the the
-000057c0: 2066 6f6c 6c6f 7769 6e67 3a0d 0a20 2020   following:..   
-000057d0: 2020 202d 2042 5546 4645 523a 2061 7070     - BUFFER: app
-000057e0: 6c79 2061 2062 7566 6665 722e 204f 7065  ly a buffer. Ope
-000057f0: 7261 7469 6f6e 2070 6172 616d 6574 6572  ration parameter
-00005800: 733a 0d0a 2020 2020 2020 2020 2020 2d20  s:..          - 
-00005810: 6469 7374 616e 6365 3a20 6469 7374 616e  distance: distan
-00005820: 6365 2074 6f20 6275 6666 6572 0d0a 2020  ce to buffer..  
-00005830: 2020 2020 2020 2020 2d20 7175 6164 7261          - quadra
-00005840: 6e74 7365 676d 656e 7473 3a20 6e75 6d62  ntsegments: numb
-00005850: 6572 206f 6620 706f 696e 7473 2075 7365  er of points use
-00005860: 6420 746f 2072 6570 7265 7365 6e74 2031  d to represent 1
-00005870: 2f34 206f 6620 6120 6369 7263 6c65 0d0a  /4 of a circle..
-00005880: 2020 2020 2020 2020 2020 2d20 656e 6463            - endc
-00005890: 6170 5f73 7479 6c65 3a20 6275 6666 6572  ap_style: buffer
-000058a0: 2073 7479 6c65 2074 6f20 7573 6520 666f   style to use fo
-000058b0: 7220 6120 706f 696e 7420 6f72 2074 6865  r a point or the
-000058c0: 2065 6e64 2070 6f69 6e74 7320 6f66 0d0a   end points of..
-000058d0: 2020 2020 2020 2020 2020 2020 6120 6c69              a li
-000058e0: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-000058f0: 202d 2052 4f55 4e44 3a20 666f 7220 706f   - ROUND: for po
-00005900: 696e 7473 2061 6e64 206c 696e 6573 2074  ints and lines t
-00005910: 6865 2065 6e64 7320 6172 6520 6275 6666  he ends are buff
-00005920: 6572 6564 2072 6f75 6e64 6564 2e0d 0a20  ered rounded... 
-00005930: 2020 2020 2020 2020 2020 202d 2046 4c41             - FLA
-00005940: 543a 2061 2070 6f69 6e74 2073 7461 7973  T: a point stays
-00005950: 2061 2070 6f69 6e74 2c20 6120 6275 6666   a point, a buff
-00005960: 6572 6564 206c 696e 6520 7769 6c6c 2065  ered line will e
-00005970: 6e64 2066 6c61 740d 0a20 2020 2020 2020  nd flat..       
-00005980: 2020 2020 2020 2061 7420 7468 6520 656e         at the en
-00005990: 6420 706f 696e 7473 0d0a 2020 2020 2020  d points..      
-000059a0: 2020 2020 2020 2d20 5351 5541 5245 3a20        - SQUARE: 
-000059b0: 6120 706f 696e 7420 6265 636f 6d65 7320  a point becomes 
-000059c0: 6120 7371 7561 7265 2c20 6120 6275 6666  a square, a buff
-000059d0: 6572 6564 206c 696e 6520 7769 6c6c 2065  ered line will e
-000059e0: 6e64 0d0a 2020 2020 2020 2020 2020 2020  nd..            
-000059f0: 2020 666c 6174 2061 7420 7468 6520 656e    flat at the en
-00005a00: 6420 706f 696e 7473 2c20 6275 7420 656c  d points, but el
-00005a10: 6f6e 6761 7465 6420 6279 2022 6469 7374  ongated by "dist
-00005a20: 616e 6365 220d 0a20 2020 2020 2020 202d  ance"..        -
-00005a30: 206a 6f69 6e5f 7374 796c 653a 2062 7566   join_style: buf
-00005a40: 6665 7220 7374 796c 6520 746f 2075 7365  fer style to use
-00005a50: 2066 6f72 2063 6f72 6e65 7273 2069 6e20   for corners in 
-00005a60: 6120 6c69 6e65 206f 7220 6120 706f 6c79  a line or a poly
-00005a70: 676f 6e0d 0a20 2020 2020 2020 2020 2062  gon..          b
-00005a80: 6f75 6e64 6172 793a 0d0a 2020 2020 2020  oundary:..      
-00005a90: 2020 2020 2020 2d20 524f 554e 443a 2063        - ROUND: c
-00005aa0: 6f72 6e65 7273 2069 6e20 7468 6520 7265  orners in the re
-00005ab0: 7375 6c74 2061 7265 2072 6f75 6e64 6564  sult are rounded
-00005ac0: 0d0a 2020 2020 2020 2020 2020 2020 2d20  ..            - 
-00005ad0: 4d49 5452 453a 2063 6f72 6e65 7273 2069  MITRE: corners i
-00005ae0: 6e20 7468 6520 7265 7375 6c74 2061 7265  n the result are
-00005af0: 2073 6861 7270 0d0a 2020 2020 2020 2020   sharp..        
-00005b00: 2020 2020 2d20 4245 5645 4c3a 2061 7265      - BEVEL: are
-00005b10: 2066 6c61 7474 656e 6564 0d0a 2020 2020   flattened..    
-00005b20: 2020 2020 2d20 6d69 7472 655f 6c69 6d69      - mitre_limi
-00005b30: 743a 2069 6e20 6361 7365 206f 6620 6a6f  t: in case of jo
-00005b40: 696e 5f73 7479 6c65 204d 4954 5245 2c20  in_style MITRE, 
-00005b50: 6966 2074 6865 0d0a 2020 2020 2020 2020  if the..        
-00005b60: 2020 2020 7370 696b 7920 7265 7375 6c74      spiky result
-00005b70: 2066 6f72 2061 2073 6861 7270 2061 6e67   for a sharp ang
-00005b80: 6c65 2062 6563 6f6d 6573 206c 6f6e 6765  le becomes longe
-00005b90: 7220 7468 616e 2074 6869 7320 6c69 6d69  r than this limi
-00005ba0: 742c 2069 740d 0a20 2020 2020 2020 2020  t, it..         
-00005bb0: 2020 2069 7320 2262 6576 656c 6564 2220     is "beveled" 
-00005bc0: 6174 2074 6869 7320 6469 7374 616e 6365  at this distance
-00005bd0: 2e20 4465 6661 756c 7473 2074 6f20 352e  . Defaults to 5.
-00005be0: 302e 0d0a 2020 2020 2020 2020 2d20 7369  0...        - si
-00005bf0: 6e67 6c65 5f73 6964 6564 3a20 6f6e 6c79  ngle_sided: only
-00005c00: 206f 6e65 2073 6964 6520 6f66 2074 6865   one side of the
-00005c10: 206c 696e 6520 6973 2062 7566 6665 7265   line is buffere
-00005c20: 642c 0d0a 2020 2020 2020 2020 2020 2020  d,..            
-00005c30: 6966 2064 6973 7461 6e63 6520 6973 206e  if distance is n
-00005c40: 6567 6174 6976 652c 2074 6865 206c 6566  egative, the lef
-00005c50: 7420 7369 6465 2c20 6966 2064 6973 7461  t side, if dista
-00005c60: 6e63 6520 6973 2070 6f73 6974 6976 652c  nce is positive,
-00005c70: 0d0a 2020 2020 2020 2020 2020 2020 7468  ..            th
-00005c80: 6520 7269 6768 7420 6861 6e64 2073 6964  e right hand sid
-00005c90: 652e 204f 6e6c 7920 7265 6c65 7661 6e74  e. Only relevant
-00005ca0: 2066 6f72 206c 696e 6520 6765 6f6d 6574   for line geomet
-00005cb0: 7269 6573 2e0d 0a20 2020 2020 202d 2043  ries...      - C
-00005cc0: 4f4e 5645 5848 554c 4c3a 2061 7070 7920  ONVEXHULL: appy 
-00005cd0: 6120 636f 6e76 6578 2068 756c 6c2e 0d0a  a convex hull...
-00005ce0: 2020 2020 2020 2d20 5349 4d50 4c49 4659        - SIMPLIFY
-00005cf0: 3a20 7369 6d70 6c69 6679 2074 6865 2067  : simplify the g
-00005d00: 656f 6d65 7472 792e 204f 7065 7261 7469  eometry. Operati
-00005d10: 6f6e 2070 6172 616d 6574 6572 733a 0d0a  on parameters:..
-00005d20: 2020 2020 2020 2020 2020 2d20 616c 676f            - algo
-00005d30: 7269 7468 6d3a 2076 6563 746f 725f 7574  rithm: vector_ut
-00005d40: 696c 2e53 696d 706c 6966 7941 6c67 6f72  il.SimplifyAlgor
-00005d50: 6974 686d 0d0a 2020 2020 2020 2020 2020  ithm..          
-00005d60: 2d20 746f 6c65 7261 6e63 653a 206d 6178  - tolerance: max
-00005d70: 696d 756d 2064 6973 7461 6e63 6520 746f  imum distance to
-00005d80: 2073 696d 706c 6966 792e 0d0a 2020 2020   simplify...    
-00005d90: 2020 2020 2020 2d20 6c6f 6f6b 6168 6561        - lookahea
-00005da0: 643a 2066 6f72 204c 414e 472c 2074 6865  d: for LANG, the
-00005db0: 206e 756d 6265 7220 6f66 2070 6f69 6e74   number of point
-00005dc0: 7320 746f 2066 6f72 7761 7264 2d6c 6f6f  s to forward-loo
-00005dd0: 6b0d 0a20 2020 2020 202d 2041 5050 4c59  k..      - APPLY
-00005de0: 3a20 6170 706c 7920 6120 6c61 6d62 6461  : apply a lambda
-00005df0: 2066 756e 6374 696f 6e2e 204f 7065 7261   function. Opera
-00005e00: 7469 6f6e 2070 6172 616d 6574 6572 3a0d  tion parameter:.
-00005e10: 0a20 2020 2020 2020 2020 202d 2070 6963  .          - pic
-00005e20: 6b6c 6564 5f66 756e 633a 206c 616d 6264  kled_func: lambd
-00005e30: 6120 6675 6e63 7469 6f6e 2074 6f20 6170  a function to ap
-00005e40: 706c 792c 2070 6963 6b6c 6564 2074 6f20  ply, pickled to 
-00005e50: 6279 7465 732e 0d0a 2020 2020 2020 2020  bytes...        
-00005e60: 2020 2d20 6f6e 6c79 5f67 656f 6d5f 696e    - only_geom_in
-00005e70: 7075 743a 2069 6620 5472 7565 2c20 6f6e  put: if True, on
-00005e80: 6c79 2074 6865 2067 656f 6d65 7472 7920  ly the geometry 
-00005e90: 6973 2061 7661 696c 6162 6c65 2061 730d  is available as.
-00005ea0: 0a20 2020 2020 2020 2020 2020 2069 6e70  .            inp
-00005eb0: 7574 2066 6f72 2074 6865 206c 616d 6264  ut for the lambd
-00005ec0: 6120 6675 6e63 7469 6f6e 2e20 4966 2066  a function. If f
-00005ed0: 616c 7365 2c20 7468 6520 726f 7720 6973  alse, the row is
-00005ee0: 2074 6865 2069 6e70 7574 2e0d 0a0d 0a20   the input..... 
-00005ef0: 2020 2041 7267 733a 0d0a 2020 2020 2020     Args:..      
-00005f00: 2020 696e 7075 745f 7061 7468 2028 5061    input_path (Pa
-00005f10: 7468 293a 205b 6465 7363 7269 7074 696f  th): [descriptio
-00005f20: 6e5d 0d0a 2020 2020 2020 2020 6f75 7470  n]..        outp
-00005f30: 7574 5f70 6174 6820 2850 6174 6829 3a20  ut_path (Path): 
-00005f40: 5b64 6573 6372 6970 7469 6f6e 5d0d 0a20  [description].. 
-00005f50: 2020 2020 2020 206f 7065 7261 7469 6f6e         operation
-00005f60: 2028 4765 6f4f 7065 7261 7469 6f6e 293a   (GeoOperation):
-00005f70: 2074 6865 2067 656f 206f 7065 7261 7469   the geo operati
-00005f80: 6f6e 2074 6f20 6170 706c 792e 0d0a 2020  on to apply...  
-00005f90: 2020 2020 2020 6f70 6572 6174 696f 6e5f        operation_
-00005fa0: 7061 7261 6d73 2028 6469 6374 2c20 6f70  params (dict, op
-00005fb0: 7469 6f6e 616c 293a 2074 6865 2070 6172  tional): the par
-00005fc0: 616d 6574 6572 7320 666f 7220 7468 6520  ameters for the 
-00005fd0: 6765 6f20 6f70 6572 6174 696f 6e2e 0d0a  geo operation...
-00005fe0: 2020 2020 2020 2020 2020 2020 4465 6661              Defa
-00005ff0: 756c 7473 2074 6f20 4e6f 6e65 2e0d 0a20  ults to None... 
-00006000: 2020 2020 2020 2069 6e70 7574 5f6c 6179         input_lay
-00006010: 6572 2028 7374 722c 206f 7074 696f 6e61  er (str, optiona
-00006020: 6c29 3a20 5b64 6573 6372 6970 7469 6f6e  l): [description
-00006030: 5d2e 2044 6566 6175 6c74 7320 746f 204e  ]. Defaults to N
-00006040: 6f6e 652e 0d0a 2020 2020 2020 2020 6f75  one...        ou
-00006050: 7470 7574 5f6c 6179 6572 2028 7374 722c  tput_layer (str,
-00006060: 206f 7074 696f 6e61 6c29 3a20 5b64 6573   optional): [des
-00006070: 6372 6970 7469 6f6e 5d2e 2044 6566 6175  cription]. Defau
-00006080: 6c74 7320 746f 204e 6f6e 652e 0d0a 2020  lts to None...  
-00006090: 2020 2020 2020 636f 6c75 6d6e 7320 284c        columns (L
-000060a0: 6973 745b 7374 725d 2c20 6f70 7469 6f6e  ist[str], option
-000060b0: 616c 293a 2049 6620 6e6f 7420 4e6f 6e65  al): If not None
-000060c0: 2c20 6f6e 6c79 206f 7574 7075 7420 7468  , only output th
-000060d0: 6520 636f 6c75 6d6e 730d 0a20 2020 2020  e columns..     
-000060e0: 2020 2020 2020 2073 7065 6369 6669 6564         specified
-000060f0: 2e20 4465 6661 756c 7473 2074 6f20 4e6f  . Defaults to No
-00006100: 6e65 2e0d 0a20 2020 2020 2020 2065 7870  ne...        exp
-00006110: 6c6f 6465 636f 6c6c 6563 7469 6f6e 7320  lodecollections 
-00006120: 2862 6f6f 6c2c 206f 7074 696f 6e61 6c29  (bool, optional)
-00006130: 3a20 5472 7565 2074 6f20 636f 6e76 6572  : True to conver
-00006140: 7420 616c 6c20 6d75 6c74 692d 6765 6f6d  t all multi-geom
-00006150: 6574 7269 6573 2074 6f0d 0a20 2020 2020  etries to..     
-00006160: 2020 2020 2020 2073 696e 6775 6c61 7220         singular 
-00006170: 6f6e 6573 2064 7572 696e 6720 7468 6520  ones during the 
-00006180: 6765 6f6f 7065 7261 7469 6f6e 2e20 4465  geooperation. De
-00006190: 6661 756c 7473 2074 6f20 4661 6c73 652e  faults to False.
-000061a0: 0d0a 2020 2020 2020 2020 666f 7263 655f  ..        force_
-000061b0: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
-000061c0: 7970 6520 2847 656f 6d65 7472 7954 7970  ype (GeometryTyp
-000061d0: 652c 206f 7074 696f 6e61 6c29 3a20 5468  e, optional): Th
-000061e0: 6520 6f75 7470 7574 2067 656f 6d65 7472  e output geometr
-000061f0: 7920 7479 7065 2074 6f0d 0a20 2020 2020  y type to..     
-00006200: 2020 2020 2020 2066 6f72 6365 2e20 4966         force. If
-00006210: 204e 6f6e 652c 2061 2062 6573 742d 6566   None, a best-ef
-00006220: 666f 7274 2067 7565 7373 2069 7320 6d61  fort guess is ma
-00006230: 6465 2e20 4465 6661 756c 7473 2074 6f20  de. Defaults to 
-00006240: 4e6f 6e65 2e0d 0a20 2020 2020 2020 2067  None...        g
-00006250: 7269 6473 697a 6520 2866 6c6f 6174 2c20  ridsize (float, 
-00006260: 6f70 7469 6f6e 616c 293a 2074 6865 2073  optional): the s
-00006270: 697a 6520 6f66 2074 6865 2067 7269 6420  ize of the grid 
-00006280: 7468 6520 636f 6f72 6469 6e61 7465 7320  the coordinates 
-00006290: 6f66 2074 6865 206f 7570 7574 0d0a 2020  of the ouput..  
-000062a0: 2020 2020 2020 2020 2020 7769 6c6c 2062            will b
-000062b0: 6520 726f 756e 6465 6420 746f 2e20 4567  e rounded to. Eg
-000062c0: 2e20 302e 3030 3120 746f 206b 6565 7020  . 0.001 to keep 
-000062d0: 3320 6465 6369 6d61 6c73 2e20 5661 6c75  3 decimals. Valu
-000062e0: 6520 302e 3020 646f 6573 6e27 7420 6368  e 0.0 doesn't ch
-000062f0: 616e 6765 0d0a 2020 2020 2020 2020 2020  ange..          
-00006300: 2020 7468 6520 7072 6563 6973 696f 6e2e    the precision.
-00006310: 2044 6566 6175 6c74 7320 746f 2030 2e30   Defaults to 0.0
-00006320: 2e0d 0a20 2020 2020 2020 206b 6565 705f  ...        keep_
-00006330: 656d 7074 795f 6765 6f6d 7320 2862 6f6f  empty_geoms (boo
-00006340: 6c2c 206f 7074 696f 6e61 6c29 3a20 5472  l, optional): Tr
-00006350: 7565 2074 6f20 6b65 6570 2072 6f77 7320  ue to keep rows 
-00006360: 7769 7468 2065 6d70 7479 2f6e 756c 6c20  with empty/null 
-00006370: 6765 6f6d 6574 7269 6573 0d0a 2020 2020  geometries..    
-00006380: 2020 2020 2020 2020 696e 2074 6865 206f          in the o
-00006390: 7574 7075 742e 2044 6566 6175 6c74 7320  utput. Defaults 
-000063a0: 746f 2054 7275 652e 0d0a 2020 2020 2020  to True...      
-000063b0: 2020 7768 6572 655f 706f 7374 2028 7374    where_post (st
-000063c0: 722c 206f 7074 696f 6e61 6c29 3a20 7371  r, optional): sq
-000063d0: 6c20 6669 6c74 6572 2074 6f20 6170 706c  l filter to appl
-000063e0: 7920 6166 7465 7220 616c 6c20 6f74 6865  y after all othe
-000063f0: 7220 7072 6f63 6573 7369 6e67 2c0d 0a20  r processing,.. 
-00006400: 2020 2020 2020 2020 2020 2069 6e63 6c75             inclu
-00006410: 6469 6e67 2065 2e67 2e20 6578 706c 6f64  ding e.g. explod
-00006420: 6563 6f6c 6c65 6374 696f 6e73 2e20 4974  ecollections. It
-00006430: 2073 686f 756c 6420 6265 2069 6e20 7371   should be in sq
-00006440: 6c69 7465 2073 796e 7461 7820 616e 640d  lite syntax and.
-00006450: 0a20 2020 2020 2020 2020 2020 207c 7370  .            |sp
-00006460: 6174 6961 6c69 7465 5f72 6566 6572 656e  atialite_referen
-00006470: 6365 5f6c 696e 6b7c 2066 756e 6374 696f  ce_link| functio
-00006480: 6e73 2063 616e 2062 6520 7573 6564 2e20  ns can be used. 
-00006490: 4465 6661 756c 7473 2074 6f20 4e6f 6e65  Defaults to None
-000064a0: 2e0d 0a20 2020 2020 2020 206e 625f 7061  ...        nb_pa
-000064b0: 7261 6c6c 656c 2028 696e 742c 206f 7074  rallel (int, opt
-000064c0: 696f 6e61 6c29 3a20 5b64 6573 6372 6970  ional): [descrip
-000064d0: 7469 6f6e 5d2e 2044 6566 6175 6c74 7320  tion]. Defaults 
-000064e0: 746f 202d 312e 0d0a 2020 2020 2020 2020  to -1...        
-000064f0: 6261 7463 6873 697a 6520 2869 6e74 2c20  batchsize (int, 
-00006500: 6f70 7469 6f6e 616c 293a 2069 6e64 6963  optional): indic
-00006510: 6174 6976 6520 6e75 6d62 6572 206f 6620  ative number of 
-00006520: 726f 7773 2074 6f20 7072 6f63 6573 7320  rows to process 
-00006530: 7065 720d 0a20 2020 2020 2020 2020 2020  per..           
-00006540: 2062 6174 6368 2e20 4120 736d 616c 6c65   batch. A smalle
-00006550: 7220 6261 7463 6820 7369 7a65 2c20 706f  r batch size, po
-00006560: 7373 6962 6c79 2069 6e20 636f 6d62 696e  ssibly in combin
-00006570: 6174 696f 6e20 7769 7468 2061 0d0a 2020  ation with a..  
-00006580: 2020 2020 2020 2020 2020 736d 616c 6c65            smalle
-00006590: 7220 6e62 5f70 6172 616c 6c65 6c2c 2077  r nb_parallel, w
-000065a0: 696c 6c20 7265 6475 6365 2074 6865 206d  ill reduce the m
-000065b0: 656d 6f72 7920 7573 6167 652e 0d0a 2020  emory usage...  
-000065c0: 2020 2020 2020 2020 2020 4465 6661 756c            Defaul
-000065d0: 7473 2074 6f20 2d31 3a20 2874 7279 2074  ts to -1: (try t
-000065e0: 6f29 2064 6574 6572 6d69 6e65 206f 7074  o) determine opt
-000065f0: 696d 616c 2073 697a 6520 6175 746f 6d61  imal size automa
-00006600: 7469 6361 6c6c 792e 0d0a 2020 2020 2020  tically...      
-00006610: 2020 666f 7263 6520 2862 6f6f 6c2c 206f    force (bool, o
-00006620: 7074 696f 6e61 6c29 3a20 5b64 6573 6372  ptional): [descr
-00006630: 6970 7469 6f6e 5d2e 2044 6566 6175 6c74  iption]. Default
-00006640: 7320 746f 2046 616c 7365 2e0d 0a20 2020  s to False...   
-00006650: 2020 2020 2070 6172 616c 6c65 6c69 7a61       paralleliza
-00006660: 7469 6f6e 5f63 6f6e 6669 6720 2850 6172  tion_config (Par
-00006670: 616c 6c65 6c69 7a61 7469 6f6e 436f 6e66  allelizationConf
-00006680: 6967 2c20 6f70 7469 6f6e 616c 293a 2044  ig, optional): D
-00006690: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
-000066a0: 0d0a 0d0a 2020 2020 5465 6368 6e69 6361  ....    Technica
-000066b0: 6c20 7265 6d61 726b 733a 0d0a 2020 2020  l remarks:..    
-000066c0: 2020 2020 2d20 5265 7461 696e 696e 6720      - Retaining 
-000066d0: 4e6f 6e65 2067 656f 6d65 7472 7920 7661  None geometry va
-000066e0: 6c75 6573 2069 6e20 7468 6520 6f75 7470  lues in the outp
-000066f0: 7574 2066 696c 6573 2069 7320 6861 7264  ut files is hard
-00006700: 2c20 6265 6361 7573 6520 7768 656e 0d0a  , because when..
-00006710: 2020 2020 2020 2020 2020 6361 6c63 756c            calcul
-00006720: 6174 696e 6720 7061 7274 6961 6c20 6669  ating partial fi
-00006730: 6c65 732c 2061 2070 6172 7469 616c 2066  les, a partial f
-00006740: 696c 6520 6361 6e20 6861 7665 206f 6e6c  ile can have onl
-00006750: 7920 4e6f 6e65 2067 656f 6d65 7472 6965  y None geometrie
-00006760: 7320 7768 6963 680d 0a20 2020 2020 2020  s which..       
-00006770: 2020 206d 616b 6573 2069 7420 696d 706f     makes it impo
-00006780: 7373 6962 6c65 2074 6f20 6b6e 6f77 2074  ssible to know t
-00006790: 6865 2067 656f 6d65 7472 7920 7479 7065  he geometry type
-000067a0: 2e20 4f6e 6365 2061 6e20 6f75 7470 7574  . Once an output
-000067b0: 2066 696c 6520 6973 2063 7265 6174 6564   file is created
-000067c0: 2c0d 0a20 2020 2020 2020 2020 2069 7420  ,..          it 
-000067d0: 6973 2061 6c73 6f20 696d 706f 7373 6962  is also impossib
-000067e0: 6c65 2074 6f20 6368 616e 6765 2074 6865  le to change the
-000067f0: 2074 7970 6520 6166 7465 7277 6172 6473   type afterwards
-00006800: 2028 7769 7468 6f75 7420 6d61 6b69 6e67   (without making
-00006810: 2061 2063 6f70 7929 2e0d 0a20 2020 2020   a copy)...     
-00006820: 2020 2020 2049 6620 666f 7263 655f 6f75       If force_ou
-00006830: 7470 7574 5f74 7970 6520 6973 2073 7065  tput_type is spe
-00006840: 6369 6669 6564 2c20 7468 6520 7072 6f62  cified, the prob
-00006850: 6c65 6d20 6973 2067 6f6e 652e 0d0a 0d0a  lem is gone.....
-00006860: 2020 2020 2e2e 207c 7370 6174 6961 6c69      .. |spatiali
-00006870: 7465 5f72 6566 6572 656e 6365 5f6c 696e  te_reference_lin
-00006880: 6b7c 2072 6177 3a3a 2068 746d 6c0d 0a0d  k| raw:: html...
-00006890: 0a20 2020 2020 2020 203c 6120 6872 6566  .        <a href
-000068a0: 3d22 6874 7470 733a 2f2f 7777 772e 6761  ="https://www.ga
-000068b0: 6961 2d67 6973 2e69 742f 6761 6961 2d73  ia-gis.it/gaia-s
-000068c0: 696e 732f 7370 6174 6961 6c69 7465 2d73  ins/spatialite-s
-000068d0: 716c 2d6c 6174 6573 742e 6874 6d6c 2220  ql-latest.html" 
-000068e0: 7461 7267 6574 3d22 5f62 6c61 6e6b 223e  target="_blank">
-000068f0: 7370 6174 6961 6c69 7465 2072 6566 6572  spatialite refer
-00006900: 656e 6365 3c2f 613e 0d0a 0d0a 2020 2020  ence</a>....    
-00006910: 2222 2220 2023 206e 6f71 613a 2045 3530  """  # noqa: E50
-00006920: 310d 0a20 2020 2023 2049 6e69 740d 0a20  1..    # Init.. 
-00006930: 2020 2073 7461 7274 5f74 696d 655f 676c     start_time_gl
-00006940: 6f62 616c 203d 2064 6174 6574 696d 652e  obal = datetime.
-00006950: 6e6f 7728 290d 0a20 2020 206f 7065 7261  now()..    opera
-00006960: 7469 6f6e 5f6e 616d 6520 3d20 6f70 6572  tion_name = oper
-00006970: 6174 696f 6e5f 7061 7261 6d73 2e67 6574  ation_params.get
-00006980: 2822 6f70 6572 6174 696f 6e5f 6e61 6d65  ("operation_name
-00006990: 2229 0d0a 2020 2020 6966 206f 7065 7261  ")..    if opera
-000069a0: 7469 6f6e 5f6e 616d 6520 6973 204e 6f6e  tion_name is Non
-000069b0: 653a 0d0a 2020 2020 2020 2020 6f70 6572  e:..        oper
-000069c0: 6174 696f 6e5f 6e61 6d65 203d 206f 7065  ation_name = ope
-000069d0: 7261 7469 6f6e 2e76 616c 7565 0d0a 2020  ration.value..  
-000069e0: 2020 6c6f 6767 6572 203d 206c 6f67 6769    logger = loggi
-000069f0: 6e67 2e67 6574 4c6f 6767 6572 2866 2267  ng.getLogger(f"g
-00006a00: 656f 6669 6c65 6f70 732e 7b6f 7065 7261  eofileops.{opera
-00006a10: 7469 6f6e 5f6e 616d 657d 2229 0d0a 0d0a  tion_name}")....
-00006a20: 2020 2020 2320 4368 6563 6b20 696e 7075      # Check inpu
-00006a30: 7420 7061 7261 6d65 7465 7273 2e2e 2e0d  t parameters....
-00006a40: 0a20 2020 2069 6620 6e6f 7420 696e 7075  .    if not inpu
-00006a50: 745f 7061 7468 2e65 7869 7374 7328 293a  t_path.exists():
-00006a60: 0d0a 2020 2020 2020 2020 7261 6973 6520  ..        raise 
-00006a70: 5661 6c75 6545 7272 6f72 2866 227b 6f70  ValueError(f"{op
-00006a80: 6572 6174 696f 6e5f 6e61 6d65 7d3a 2069  eration_name}: i
-00006a90: 6e70 7574 5f70 6174 6820 646f 6573 6e27  nput_path doesn'
-00006aa0: 7420 6578 6973 743a 207b 696e 7075 745f  t exist: {input_
-00006ab0: 7061 7468 7d22 290d 0a20 2020 2069 6620  path}")..    if 
-00006ac0: 696e 7075 745f 7061 7468 203d 3d20 6f75  input_path == ou
-00006ad0: 7470 7574 5f70 6174 683a 0d0a 2020 2020  tput_path:..    
-00006ae0: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-00006af0: 7272 6f72 2866 227b 6f70 6572 6174 696f  rror(f"{operatio
-00006b00: 6e5f 6e61 6d65 7d3a 206f 7574 7075 745f  n_name}: output_
-00006b10: 7061 7468 206d 7573 7420 6e6f 7420 6571  path must not eq
-00006b20: 7561 6c20 696e 7075 745f 7061 7468 2229  ual input_path")
-00006b30: 0d0a 2020 2020 6966 2069 6e70 7574 5f6c  ..    if input_l
-00006b40: 6179 6572 2069 7320 4e6f 6e65 3a0d 0a20  ayer is None:.. 
-00006b50: 2020 2020 2020 2069 6e70 7574 5f6c 6179         input_lay
-00006b60: 6572 203d 2067 666f 2e67 6574 5f6f 6e6c  er = gfo.get_onl
-00006b70: 795f 6c61 7965 7228 696e 7075 745f 7061  y_layer(input_pa
-00006b80: 7468 290d 0a20 2020 2069 6620 6f75 7470  th)..    if outp
-00006b90: 7574 5f70 6174 682e 6578 6973 7473 2829  ut_path.exists()
-00006ba0: 3a0d 0a20 2020 2020 2020 2069 6620 666f  :..        if fo
-00006bb0: 7263 6520 6973 2046 616c 7365 3a0d 0a20  rce is False:.. 
-00006bc0: 2020 2020 2020 2020 2020 206c 6f67 6765             logge
-00006bd0: 722e 696e 666f 2866 2253 746f 702c 206f  r.info(f"Stop, o
-00006be0: 7574 7075 7420 6578 6973 7473 2061 6c72  utput exists alr
-00006bf0: 6561 6479 207b 6f75 7470 7574 5f70 6174  eady {output_pat
-00006c00: 687d 2229 0d0a 2020 2020 2020 2020 2020  h}")..          
-00006c10: 2020 7265 7475 726e 0d0a 2020 2020 2020    return..      
-00006c20: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-00006c30: 2020 2020 2067 666f 2e72 656d 6f76 6528       gfo.remove(
-00006c40: 6f75 7470 7574 5f70 6174 6829 0d0a 2020  output_path)..  
-00006c50: 2020 6966 2069 6e70 7574 5f6c 6179 6572    if input_layer
-00006c60: 2069 7320 4e6f 6e65 3a0d 0a20 2020 2020   is None:..     
-00006c70: 2020 2069 6e70 7574 5f6c 6179 6572 203d     input_layer =
-00006c80: 2067 666f 2e67 6574 5f6f 6e6c 795f 6c61   gfo.get_only_la
-00006c90: 7965 7228 696e 7075 745f 7061 7468 290d  yer(input_path).
-00006ca0: 0a20 2020 2069 6620 6f75 7470 7574 5f6c  .    if output_l
-00006cb0: 6179 6572 2069 7320 4e6f 6e65 3a0d 0a20  ayer is None:.. 
-00006cc0: 2020 2020 2020 206f 7574 7075 745f 6c61         output_la
-00006cd0: 7965 7220 3d20 6766 6f2e 6765 745f 6465  yer = gfo.get_de
-00006ce0: 6661 756c 745f 6c61 7965 7228 6f75 7470  fault_layer(outp
-00006cf0: 7574 5f70 6174 6829 0d0a 2020 2020 6966  ut_path)..    if
-00006d00: 2069 7369 6e73 7461 6e63 6528 666f 7263   isinstance(forc
-00006d10: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-00006d20: 7974 7970 652c 2047 656f 6d65 7472 7954  ytype, GeometryT
-00006d30: 7970 6529 3a0d 0a20 2020 2020 2020 2066  ype):..        f
-00006d40: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
-00006d50: 6574 7279 7479 7065 203d 2066 6f72 6365  etrytype = force
-00006d60: 5f6f 7574 7075 745f 6765 6f6d 6574 7279  _output_geometry
-00006d70: 7479 7065 2e6e 616d 650d 0a0d 0a20 2020  type.name....   
-00006d80: 2023 2043 6865 636b 2069 6620 7765 2077   # Check if we w
-00006d90: 616e 7420 746f 2070 7265 7365 7276 6520  ant to preserve 
-00006da0: 7468 6520 6669 6420 696e 2074 6865 206f  the fid in the o
-00006db0: 7574 7075 740d 0a20 2020 2070 7265 7365  utput..    prese
-00006dc0: 7276 655f 6669 6420 3d20 4661 6c73 650d  rve_fid = False.
-00006dd0: 0a20 2020 2069 6620 6e6f 7420 6578 706c  .    if not expl
-00006de0: 6f64 6563 6f6c 6c65 6374 696f 6e73 2061  odecollections a
-00006df0: 6e64 2067 666f 2e67 6574 5f64 7269 7665  nd gfo.get_drive
-00006e00: 7228 6f75 7470 7574 5f70 6174 6829 203d  r(output_path) =
-00006e10: 3d20 2247 504b 4722 3a0d 0a20 2020 2020  = "GPKG":..     
-00006e20: 2020 2070 7265 7365 7276 655f 6669 6420     preserve_fid 
-00006e30: 3d20 5472 7565 0d0a 0d0a 2020 2020 2320  = True....    # 
-00006e40: 5072 6570 6172 6520 7768 6572 655f 746f  Prepare where_to
-00006e50: 5f61 7070 6c79 2061 6e64 2066 696c 7465  _apply and filte
-00006e60: 725f 6e75 6c6c 5f67 656f 6d73 0d0a 2020  r_null_geoms..  
-00006e70: 2020 6966 2077 6865 7265 5f70 6f73 7420    if where_post 
-00006e80: 6973 206e 6f74 204e 6f6e 653a 0d0a 2020  is not None:..  
-00006e90: 2020 2020 2020 6966 2077 6865 7265 5f70        if where_p
-00006ea0: 6f73 7420 3d3d 2022 223a 0d0a 2020 2020  ost == "":..    
-00006eb0: 2020 2020 2020 2020 7768 6572 655f 706f          where_po
-00006ec0: 7374 203d 204e 6f6e 650d 0a20 2020 2020  st = None..     
-00006ed0: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-00006ee0: 2020 2020 2020 2320 416c 7761 7973 2073        # Always s
-00006ef0: 6574 2067 656f 6d65 7472 7963 6f6c 756d  et geometrycolum
-00006f00: 6e20 746f 2022 6765 6f6d 222c 2062 6563  n to "geom", bec
-00006f10: 6175 7365 2077 6865 7265 5f70 6f73 7420  ause where_post 
-00006f20: 7061 7261 6d65 7465 7220 666f 7220 7368  parameter for sh
-00006f30: 700d 0a20 2020 2020 2020 2020 2020 2023  p..            #
-00006f40: 2064 6f65 736e 2774 2073 6565 6d20 746f   doesn't seem to
-00006f50: 2077 6f72 6b2e 2e2e 2073 6f20 6372 6561   work... so crea
-00006f60: 7465 2074 656d 7020 7061 7274 6961 6c20  te temp partial 
-00006f70: 6669 6c65 7320 616c 7761 7973 2061 7320  files always as 
-00006f80: 6770 6b67 2e0d 0a20 2020 2020 2020 2020  gpkg...         
-00006f90: 2020 2077 6865 7265 5f70 6f73 7420 3d20     where_post = 
-00006fa0: 7768 6572 655f 706f 7374 2e66 6f72 6d61  where_post.forma
-00006fb0: 7428 6765 6f6d 6574 7279 636f 6c75 6d6e  t(geometrycolumn
-00006fc0: 3d22 6765 6f6d 2229 0d0a 0d0a 2020 2020  ="geom")....    
-00006fd0: 2320 5072 6570 6172 6520 746d 7020 6669  # Prepare tmp fi
-00006fe0: 6c65 730d 0a20 2020 2074 6d70 5f64 6972  les..    tmp_dir
-00006ff0: 203d 205f 696f 5f75 7469 6c2e 6372 6561   = _io_util.crea
-00007000: 7465 5f74 656d 7064 6972 2866 2267 656f  te_tempdir(f"geo
-00007010: 6669 6c65 6f70 732f 7b6f 7065 7261 7469  fileops/{operati
-00007020: 6f6e 2e76 616c 7565 7d22 290d 0a20 2020  on.value}")..   
-00007030: 206c 6f67 6765 722e 6465 6275 6728 6622   logger.debug(f"
-00007040: 5374 6172 7420 6361 6c63 756c 6174 696f  Start calculatio
-00007050: 6e20 746f 2074 656d 7020 6669 6c65 7320  n to temp files 
-00007060: 696e 207b 746d 705f 6469 727d 2229 0d0a  in {tmp_dir}")..
-00007070: 0d0a 2020 2020 7472 793a 0d0a 2020 2020  ..    try:..    
-00007080: 2020 2020 2320 4361 6c63 756c 6174 6520      # Calculate 
-00007090: 7468 6520 6265 7374 206e 756d 6265 7220  the best number 
-000070a0: 6f66 2070 6172 616c 6c65 6c20 7072 6f63  of parallel proc
-000070b0: 6573 7365 7320 616e 6420 6261 7463 6865  esses and batche
-000070c0: 7320 666f 720d 0a20 2020 2020 2020 2023  s for..        #
-000070d0: 2074 6865 2061 7661 696c 6162 6c65 2072   the available r
-000070e0: 6573 6f75 7263 6573 0d0a 2020 2020 2020  esources..      
-000070f0: 2020 7072 6f63 6573 7369 6e67 5f70 6172    processing_par
-00007100: 616d 7320 3d20 5f70 7265 7061 7265 5f70  ams = _prepare_p
-00007110: 726f 6365 7373 696e 675f 7061 7261 6d73  rocessing_params
-00007120: 280d 0a20 2020 2020 2020 2020 2020 2069  (..            i
-00007130: 6e70 7574 5f70 6174 683d 696e 7075 745f  nput_path=input_
-00007140: 7061 7468 2c0d 0a20 2020 2020 2020 2020  path,..         
-00007150: 2020 2069 6e70 7574 5f6c 6179 6572 3d69     input_layer=i
-00007160: 6e70 7574 5f6c 6179 6572 2c0d 0a20 2020  nput_layer,..   
-00007170: 2020 2020 2020 2020 206e 625f 7061 7261           nb_para
-00007180: 6c6c 656c 3d6e 625f 7061 7261 6c6c 656c  llel=nb_parallel
-00007190: 2c0d 0a20 2020 2020 2020 2020 2020 2062  ,..            b
-000071a0: 6174 6368 7369 7a65 3d62 6174 6368 7369  atchsize=batchsi
-000071b0: 7a65 2c0d 0a20 2020 2020 2020 2020 2020  ze,..           
-000071c0: 2070 6172 616c 6c65 6c69 7a61 7469 6f6e   parallelization
-000071d0: 5f63 6f6e 6669 673d 7061 7261 6c6c 656c  _config=parallel
-000071e0: 697a 6174 696f 6e5f 636f 6e66 6967 2c0d  ization_config,.
-000071f0: 0a20 2020 2020 2020 2020 2020 2074 6d70  .            tmp
-00007200: 5f64 6972 3d74 6d70 5f64 6972 2c0d 0a20  _dir=tmp_dir,.. 
-00007210: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-00007220: 2020 6173 7365 7274 2070 726f 6365 7373    assert process
-00007230: 696e 675f 7061 7261 6d73 2e62 6174 6368  ing_params.batch
-00007240: 6573 2069 7320 6e6f 7420 4e6f 6e65 0d0a  es is not None..
-00007250: 0d0a 2020 2020 2020 2020 6c6f 6767 6572  ..        logger
-00007260: 2e69 6e66 6f28 0d0a 2020 2020 2020 2020  .info(..        
-00007270: 2020 2020 6622 5374 6172 7420 7072 6f63      f"Start proc
-00007280: 6573 7369 6e67 2028 7b70 726f 6365 7373  essing ({process
-00007290: 696e 675f 7061 7261 6d73 2e6e 625f 7061  ing_params.nb_pa
-000072a0: 7261 6c6c 656c 7d20 220d 0a20 2020 2020  rallel} "..     
-000072b0: 2020 2020 2020 2066 2270 6172 616c 6c65         f"paralle
-000072c0: 6c20 776f 726b 6572 732c 2062 6174 6368  l workers, batch
-000072d0: 2073 697a 653a 207b 7072 6f63 6573 7369   size: {processi
-000072e0: 6e67 5f70 6172 616d 732e 6261 7463 6873  ng_params.batchs
-000072f0: 697a 657d 2922 0d0a 2020 2020 2020 2020  ize})"..        
-00007300: 290d 0a20 2020 2020 2020 2023 2050 726f  )..        # Pro
-00007310: 6365 7373 696e 6720 696e 2074 6872 6561  cessing in threa
-00007320: 6473 2069 7320 3278 2066 6173 7465 7220  ds is 2x faster 
-00007330: 666f 7220 736d 616c 6c20 6461 7461 7365  for small datase
-00007340: 7473 2028 6f6e 2057 696e 646f 7773 290d  ts (on Windows).
-00007350: 0a20 2020 2020 2020 2063 616c 6375 6c61  .        calcula
-00007360: 7465 5f69 6e5f 7468 7265 6164 7320 3d20  te_in_threads = 
-00007370: 280d 0a20 2020 2020 2020 2020 2020 2054  (..            T
-00007380: 7275 6520 6966 2070 726f 6365 7373 696e  rue if processin
-00007390: 675f 7061 7261 6d73 2e6e 625f 726f 7773  g_params.nb_rows
-000073a0: 5f74 6f5f 7072 6f63 6573 7320 3c3d 2031  _to_process <= 1
-000073b0: 3030 2065 6c73 6520 4661 6c73 650d 0a20  00 else False.. 
-000073c0: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-000073d0: 2020 7769 7468 205f 7072 6f63 6573 7369    with _processi
-000073e0: 6e67 5f75 7469 6c2e 506f 6f6c 6564 4578  ng_util.PooledEx
-000073f0: 6563 7574 6f72 4661 6374 6f72 7928 0d0a  ecutorFactory(..
-00007400: 2020 2020 2020 2020 2020 2020 7468 7265              thre
-00007410: 6164 706f 6f6c 3d63 616c 6375 6c61 7465  adpool=calculate
-00007420: 5f69 6e5f 7468 7265 6164 732c 0d0a 2020  _in_threads,..  
-00007430: 2020 2020 2020 2020 2020 6d61 785f 776f            max_wo
-00007440: 726b 6572 733d 7072 6f63 6573 7369 6e67  rkers=processing
-00007450: 5f70 6172 616d 732e 6e62 5f70 6172 616c  _params.nb_paral
-00007460: 6c65 6c2c 0d0a 2020 2020 2020 2020 2020  lel,..          
-00007470: 2020 696e 6974 6961 6c69 7a65 723d 5f70    initializer=_p
-00007480: 726f 6365 7373 696e 675f 7574 696c 2e69  rocessing_util.i
-00007490: 6e69 7469 616c 697a 655f 776f 726b 6572  nitialize_worker
-000074a0: 2829 2c0d 0a20 2020 2020 2020 2029 2061  (),..        ) a
-000074b0: 7320 6361 6c63 756c 6174 655f 706f 6f6c  s calculate_pool
-000074c0: 3a0d 0a20 2020 2020 2020 2020 2020 2023  :..            #
-000074d0: 2050 7265 7061 7265 206f 7574 7075 7420   Prepare output 
-000074e0: 6669 6c65 6e61 6d65 0d0a 2020 2020 2020  filename..      
-000074f0: 2020 2020 2020 746d 705f 6f75 7470 7574        tmp_output
-00007500: 5f70 6174 6820 3d20 746d 705f 6469 7220  _path = tmp_dir 
-00007510: 2f20 6f75 7470 7574 5f70 6174 682e 6e61  / output_path.na
-00007520: 6d65 0d0a 0d0a 2020 2020 2020 2020 2020  me....          
-00007530: 2020 6261 7463 6865 733a 2044 6963 745b    batches: Dict[
-00007540: 696e 742c 2064 6963 745d 203d 207b 7d0d  int, dict] = {}.
-00007550: 0a20 2020 2020 2020 2020 2020 2066 7574  .            fut
-00007560: 7572 655f 746f 5f62 6174 6368 5f69 6420  ure_to_batch_id 
-00007570: 3d20 7b7d 0d0a 0d0a 2020 2020 2020 2020  = {}....        
-00007580: 2020 2020 666f 7220 6261 7463 685f 6964      for batch_id
-00007590: 2c20 6261 7463 685f 6669 6c74 6572 2069  , batch_filter i
-000075a0: 6e20 656e 756d 6572 6174 6528 7072 6f63  n enumerate(proc
-000075b0: 6573 7369 6e67 5f70 6172 616d 732e 6261  essing_params.ba
-000075c0: 7463 6865 7329 3a0d 0a20 2020 2020 2020  tches):..       
-000075d0: 2020 2020 2020 2020 2062 6174 6368 6573           batches
-000075e0: 5b62 6174 6368 5f69 645d 203d 207b 7d0d  [batch_id] = {}.
-000075f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007600: 2062 6174 6368 6573 5b62 6174 6368 5f69   batches[batch_i
-00007610: 645d 5b22 6c61 7965 7222 5d20 3d20 6f75  d]["layer"] = ou
-00007620: 7470 7574 5f6c 6179 6572 0d0a 0d0a 2020  tput_layer....  
-00007630: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00007640: 4f75 7470 7574 2065 6163 6820 6261 7463  Output each batc
-00007650: 6820 746f 2061 2073 6570 6572 6174 6520  h to a seperate 
-00007660: 7465 6d70 6f72 6172 7920 6669 6c65 2c20  temporary file, 
-00007670: 6f74 6865 7277 6973 6520 7468 6572 650d  otherwise there.
-00007680: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007690: 2023 2061 7265 2074 696d 656f 7574 2069   # are timeout i
-000076a0: 7373 7565 7320 7768 656e 2070 726f 6365  ssues when proce
-000076b0: 7373 696e 6720 6c61 7267 6520 6669 6c65  ssing large file
-000076c0: 730d 0a20 2020 2020 2020 2020 2020 2020  s..             
-000076d0: 2020 206f 7574 7075 745f 746d 705f 7061     output_tmp_pa
-000076e0: 7274 6961 6c5f 7061 7468 203d 2028 0d0a  rtial_path = (..
+00000000: 2222 220a 4d6f 6475 6c65 2063 6f6e 7461  """.Module conta
+00000010: 696e 696e 6720 7468 6520 696d 706c 656d  ining the implem
+00000020: 656e 7461 7469 6f6e 206f 6620 4765 6f66  entation of Geof
+00000030: 696c 6520 6f70 6572 6174 696f 6e73 2075  ile operations u
+00000040: 7369 6e67 2047 656f 5061 6e64 6173 2e0a  sing GeoPandas..
+00000050: 2222 220a 0a66 726f 6d20 636f 6e63 7572  """..from concur
+00000060: 7265 6e74 2069 6d70 6f72 7420 6675 7475  rent import futu
+00000070: 7265 730a 696d 706f 7274 2063 6f70 790a  res.import copy.
+00000080: 6672 6f6d 2064 6174 6574 696d 6520 696d  from datetime im
+00000090: 706f 7274 2064 6174 6574 696d 650a 696d  port datetime.im
+000000a0: 706f 7274 2065 6e75 6d0a 696d 706f 7274  port enum.import
+000000b0: 206a 736f 6e0a 696d 706f 7274 206c 6f67   json.import log
+000000c0: 6769 6e67 0a69 6d70 6f72 7420 6c6f 6767  ging.import logg
+000000d0: 696e 672e 636f 6e66 6967 0a69 6d70 6f72  ing.config.impor
+000000e0: 7420 6d61 7468 0a69 6d70 6f72 7420 6d75  t math.import mu
+000000f0: 6c74 6970 726f 6365 7373 696e 670a 6672  ltiprocessing.fr
+00000100: 6f6d 2070 6174 686c 6962 2069 6d70 6f72  om pathlib impor
+00000110: 7420 5061 7468 0a69 6d70 6f72 7420 7069  t Path.import pi
+00000120: 636b 6c65 0a69 6d70 6f72 7420 7265 0a69  ckle.import re.i
+00000130: 6d70 6f72 7420 7368 7574 696c 0a69 6d70  mport shutil.imp
+00000140: 6f72 7420 7469 6d65 0a66 726f 6d20 7479  ort time.from ty
+00000150: 7069 6e67 2069 6d70 6f72 7420 416e 792c  ping import Any,
+00000160: 2043 616c 6c61 626c 652c 2044 6963 742c   Callable, Dict,
+00000170: 2049 7465 7261 626c 652c 204c 6973 742c   Iterable, List,
+00000180: 204f 7074 696f 6e61 6c2c 2053 6574 2c20   Optional, Set, 
+00000190: 5475 706c 652c 2055 6e69 6f6e 0a69 6d70  Tuple, Union.imp
+000001a0: 6f72 7420 7761 726e 696e 6773 0a0a 696d  ort warnings..im
+000001b0: 706f 7274 2063 6c6f 7564 7069 636b 6c65  port cloudpickle
+000001c0: 0a69 6d70 6f72 7420 6765 6f70 616e 6461  .import geopanda
+000001d0: 7320 6173 2067 7064 0a69 6d70 6f72 7420  s as gpd.import 
+000001e0: 6e75 6d70 7920 6173 206e 700a 696d 706f  numpy as np.impo
+000001f0: 7274 2070 616e 6461 7320 6173 2070 640a  rt pandas as pd.
+00000200: 696d 706f 7274 2070 7967 656f 6f70 730a  import pygeoops.
+00000210: 696d 706f 7274 2070 7375 7469 6c0a 0a66  import psutil..f
+00000220: 726f 6d20 7079 6765 6f6f 7073 2069 6d70  rom pygeoops imp
+00000230: 6f72 7420 4765 6f6d 6574 7279 5479 7065  ort GeometryType
+00000240: 2c20 5072 696d 6974 6976 6554 7970 650a  , PrimitiveType.
+00000250: 696d 706f 7274 2073 6861 7065 6c79 0a69  import shapely.i
+00000260: 6d70 6f72 7420 7368 6170 656c 792e 6765  mport shapely.ge
+00000270: 6f6d 6574 7279 2061 7320 7368 5f67 656f  ometry as sh_geo
+00000280: 6d0a 0a69 6d70 6f72 7420 6765 6f66 696c  m..import geofil
+00000290: 656f 7073 2061 7320 6766 6f0a 6672 6f6d  eops as gfo.from
+000002a0: 2067 656f 6669 6c65 6f70 7320 696d 706f   geofileops impo
+000002b0: 7274 2066 696c 656f 7073 0a66 726f 6d20  rt fileops.from 
+000002c0: 6765 6f66 696c 656f 7073 2e68 656c 7065  geofileops.helpe
+000002d0: 7273 2069 6d70 6f72 7420 5f70 6172 616d  rs import _param
+000002e0: 6574 6572 5f68 656c 7065 720a 6672 6f6d  eter_helper.from
+000002f0: 2067 656f 6669 6c65 6f70 732e 7574 696c   geofileops.util
+00000300: 2069 6d70 6f72 7420 5f67 656e 6572 616c   import _general
+00000310: 5f75 7469 6c0a 6672 6f6d 2067 656f 6669  _util.from geofi
+00000320: 6c65 6f70 732e 7574 696c 2069 6d70 6f72  leops.util impor
+00000330: 7420 5f67 656f 6f70 735f 7371 6c0a 6672  t _geoops_sql.fr
+00000340: 6f6d 2067 656f 6669 6c65 6f70 732e 7574  om geofileops.ut
+00000350: 696c 2069 6d70 6f72 7420 5f67 656f 7365  il import _geose
+00000360: 7269 6573 5f75 7469 6c0a 6672 6f6d 2067  ries_util.from g
+00000370: 656f 6669 6c65 6f70 732e 7574 696c 2069  eofileops.util i
+00000380: 6d70 6f72 7420 5f69 6f5f 7574 696c 0a66  mport _io_util.f
+00000390: 726f 6d20 6765 6f66 696c 656f 7073 2e75  rom geofileops.u
+000003a0: 7469 6c20 696d 706f 7274 205f 6f67 725f  til import _ogr_
+000003b0: 7574 696c 0a66 726f 6d20 6765 6f66 696c  util.from geofil
+000003c0: 656f 7073 2e75 7469 6c20 696d 706f 7274  eops.util import
+000003d0: 205f 7072 6f63 6573 7369 6e67 5f75 7469   _processing_uti
+000003e0: 6c0a 6672 6f6d 2067 656f 6669 6c65 6f70  l.from geofileop
+000003f0: 732e 7574 696c 2e5f 6765 6f6d 6574 7279  s.util._geometry
+00000400: 5f75 7469 6c20 696d 706f 7274 2053 696d  _util import Sim
+00000410: 706c 6966 7941 6c67 6f72 6974 686d 0a66  plifyAlgorithm.f
+00000420: 726f 6d20 6765 6f66 696c 656f 7073 2e75  rom geofileops.u
+00000430: 7469 6c2e 5f67 656f 6d65 7472 795f 7574  til._geometry_ut
+00000440: 696c 2069 6d70 6f72 7420 4275 6666 6572  il import Buffer
+00000450: 456e 6443 6170 5374 796c 652c 2042 7566  EndCapStyle, Buf
+00000460: 6665 724a 6f69 6e53 7479 6c65 0a0a 2320  ferJoinStyle..# 
+00000470: 446f 6e27 7420 7368 6f77 2074 6869 7320  Don't show this 
+00000480: 6765 6f70 616e 6461 7320 7761 726e 696e  geopandas warnin
+00000490: 672e 2e2e 0a77 6172 6e69 6e67 732e 6669  g....warnings.fi
+000004a0: 6c74 6572 7761 726e 696e 6773 2822 6967  lterwarnings("ig
+000004b0: 6e6f 7265 222c 2022 4765 6f53 6572 6965  nore", "GeoSerie
+000004c0: 732e 6973 6e61 222c 2055 7365 7257 6172  s.isna", UserWar
+000004d0: 6e69 6e67 290a 0a6c 6f67 6765 7220 3d20  ning)..logger = 
+000004e0: 6c6f 6767 696e 672e 6765 744c 6f67 6765  logging.getLogge
+000004f0: 7228 5f5f 6e61 6d65 5f5f 290a 0a0a 636c  r(__name__)...cl
+00000500: 6173 7320 5061 7261 6c6c 656c 697a 6174  ass Parallelizat
+00000510: 696f 6e43 6f6e 6669 673a 0a20 2020 2022  ionConfig:.    "
+00000520: 2222 0a20 2020 2048 6575 7269 7374 6963  "".    Heuristic
+00000530: 7320 666f 7220 6765 6f70 616e 6461 7320  s for geopandas 
+00000540: 6261 7365 6420 6765 6f20 6f70 6572 6174  based geo operat
+00000550: 696f 6e73 2e0a 0a20 2020 2048 6575 7269  ions...    Heuri
+00000560: 7374 6963 7320 6d65 616e 7420 746f 2062  stics meant to b
+00000570: 6520 6162 6c65 2074 6f20 6f70 7469 6d69  e able to optimi
+00000580: 7a65 2074 6865 2070 6172 616c 6c65 6c69  ze the paralleli
+00000590: 7361 7469 6f6e 2070 6172 616d 6574 6572  sation parameter
+000005a0: 7320 666f 720a 2020 2020 6765 6f70 616e  s for.    geopan
+000005b0: 6461 7320 6261 7365 6420 6765 6f20 6f70  das based geo op
+000005c0: 6572 6174 696f 6e2e 0a20 2020 2022 2222  eration..    """
+000005d0: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
+000005e0: 5f5f 280a 2020 2020 2020 2020 7365 6c66  __(.        self
+000005f0: 2c0a 2020 2020 2020 2020 6279 7465 735f  ,.        bytes_
+00000600: 6261 7365 666f 6f74 7072 696e 743a 2069  basefootprint: i
+00000610: 6e74 203d 2035 3020 2a20 3130 3234 202a  nt = 50 * 1024 *
+00000620: 2031 3032 342c 0a20 2020 2020 2020 2062   1024,.        b
+00000630: 7974 6573 5f70 6572 5f72 6f77 3a20 696e  ytes_per_row: in
+00000640: 7420 3d20 3130 3030 2c0a 2020 2020 2020  t = 1000,.      
+00000650: 2020 6d69 6e5f 726f 7773 5f70 6572 5f62    min_rows_per_b
+00000660: 6174 6368 3a20 696e 7420 3d20 3130 3030  atch: int = 1000
+00000670: 2c0a 2020 2020 2020 2020 6d61 785f 726f  ,.        max_ro
+00000680: 7773 5f70 6572 5f62 6174 6368 3a20 696e  ws_per_batch: in
+00000690: 7420 3d20 3130 3030 3030 2c0a 2020 2020  t = 100000,.    
+000006a0: 2020 2020 6279 7465 735f 6d69 6e5f 7065      bytes_min_pe
+000006b0: 725f 7072 6f63 6573 733a 204f 7074 696f  r_process: Optio
+000006c0: 6e61 6c5b 696e 745d 203d 204e 6f6e 652c  nal[int] = None,
+000006d0: 0a20 2020 2020 2020 2062 7974 6573 5f75  .        bytes_u
+000006e0: 7361 626c 653a 204f 7074 696f 6e61 6c5b  sable: Optional[
+000006f0: 696e 745d 203d 204e 6f6e 652c 0a20 2020  int] = None,.   
+00000700: 2020 2020 2063 7075 5f63 6f75 6e74 3a20       cpu_count: 
+00000710: 696e 7420 3d20 2d31 2c0a 2020 2020 293a  int = -1,.    ):
+00000720: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00000730: 2020 2020 2048 6575 7269 7374 6963 7320       Heuristics 
+00000740: 666f 7220 6765 6f70 616e 6461 7320 6261  for geopandas ba
+00000750: 7365 6420 6765 6f20 6f70 6572 6174 696f  sed geo operatio
+00000760: 6e73 2e0a 0a20 2020 2020 2020 2048 6575  ns...        Heu
+00000770: 7269 7374 6963 7320 6d65 616e 7420 746f  ristics meant to
+00000780: 2062 6520 6162 6c65 2074 6f20 6f70 7469   be able to opti
+00000790: 6d69 7a65 2074 6865 2070 6172 616c 6c65  mize the paralle
+000007a0: 6c69 7361 7469 6f6e 2070 6172 616d 6574  lisation paramet
+000007b0: 6572 7320 666f 720a 2020 2020 2020 2020  ers for.        
+000007c0: 6765 6f70 616e 6461 7320 6261 7365 6420  geopandas based 
+000007d0: 6765 6f20 6f70 6572 6174 696f 6e2e 0a0a  geo operation...
+000007e0: 2020 2020 2020 2020 4172 6773 3a0a 2020          Args:.  
+000007f0: 2020 2020 2020 2020 2020 6279 7465 735f            bytes_
+00000800: 6261 7365 666f 6f74 7072 696e 7420 2869  basefootprint (i
+00000810: 6e74 2c20 6f70 7469 6f6e 616c 293a 2054  nt, optional): T
+00000820: 6865 2062 6173 6520 6d65 6d6f 7279 2075  he base memory u
+00000830: 7361 6765 206f 6620 6120 6765 6f66 696c  sage of a geofil
+00000840: 656f 7073 0a20 2020 2020 2020 2020 2020  eops.           
+00000850: 2020 2020 2077 6f72 6b65 7220 7072 6f63       worker proc
+00000860: 6573 732e 2044 6566 6175 6c74 7320 746f  ess. Defaults to
+00000870: 2035 3020 4d42 2e0a 2020 2020 2020 2020   50 MB..        
+00000880: 2020 2020 6279 7465 735f 7065 725f 726f      bytes_per_ro
+00000890: 7720 2869 6e74 2c20 6f70 7469 6f6e 616c  w (int, optional
+000008a0: 293a 2054 6865 206e 756d 6265 7220 6966  ): The number if
+000008b0: 2062 7974 6573 206e 6565 6465 6420 746f   bytes needed to
+000008c0: 2073 746f 7265 2f70 726f 6365 7373 0a20   store/process. 
+000008d0: 2020 2020 2020 2020 2020 2020 2020 206f                 o
+000008e0: 6e65 2072 6f77 206f 6620 6461 7461 2e20  ne row of data. 
+000008f0: 4465 6661 756c 7473 2074 6f20 3130 3030  Defaults to 1000
+00000900: 2e0a 2020 2020 2020 2020 2020 2020 6d69  ..            mi
+00000910: 6e5f 726f 7773 5f70 6572 5f62 6174 6368  n_rows_per_batch
+00000920: 2028 696e 742c 206f 7074 696f 6e61 6c29   (int, optional)
+00000930: 3a20 5468 6520 6d69 6e69 6d75 6d20 6e75  : The minimum nu
+00000940: 6d62 6572 206f 6620 726f 7773 2074 6f20  mber of rows to 
+00000950: 6169 6d20 666f 7220 696e 0a20 2020 2020  aim for in.     
+00000960: 2020 2020 2020 2020 2020 206f 6e65 2062             one b
+00000970: 6174 6368 2e20 4465 6661 756c 7473 2074  atch. Defaults t
+00000980: 6f20 3130 3030 2e0a 2020 2020 2020 2020  o 1000..        
+00000990: 2020 2020 6d61 785f 726f 7773 5f70 6572      max_rows_per
+000009a0: 5f62 6174 6368 2028 696e 742c 206f 7074  _batch (int, opt
+000009b0: 696f 6e61 6c29 3a20 5468 6520 6d61 7869  ional): The maxi
+000009c0: 6d75 6d20 6e75 6d62 6572 206f 6620 726f  mum number of ro
+000009d0: 7773 2074 6f20 6169 6d20 666f 7220 696e  ws to aim for in
+000009e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000009f0: 2061 2062 6174 6368 2e20 4465 6661 756c   a batch. Defaul
+00000a00: 7473 2074 6f20 3130 3030 3030 2e0a 2020  ts to 100000..  
+00000a10: 2020 2020 2020 2020 2020 6279 7465 735f            bytes_
+00000a20: 6d69 6e5f 7065 725f 7072 6f63 6573 7320  min_per_process 
+00000a30: 284f 7074 696f 6e61 6c5b 696e 745d 2c20  (Optional[int], 
+00000a40: 6f70 7469 6f6e 616c 293a 2054 6865 206d  optional): The m
+00000a50: 696e 696d 756d 206e 756d 6265 7220 6f66  inimum number of
+00000a60: 2062 7974 6573 0a20 2020 2020 2020 2020   bytes.         
+00000a70: 2020 2020 2020 206e 6565 6465 6420 666f         needed fo
+00000a80: 7220 6120 6765 6f66 696c 656f 7073 2077  r a geofileops w
+00000a90: 6f72 6b65 7220 7072 6f63 6573 732e 2044  orker process. D
+00000aa0: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
+00000ab0: 0a20 2020 2020 2020 2020 2020 2062 7974  .            byt
+00000ac0: 6573 5f75 7361 626c 6520 284f 7074 696f  es_usable (Optio
+00000ad0: 6e61 6c5b 696e 745d 2c20 6f70 7469 6f6e  nal[int], option
+00000ae0: 616c 293a 2074 6865 206d 656d 6f72 7920  al): the memory 
+00000af0: 6176 6169 6c61 626c 6520 666f 7220 7072  available for pr
+00000b00: 6f63 6573 7369 6e67 2e0a 2020 2020 2020  ocessing..      
+00000b10: 2020 2020 2020 2020 2020 4465 6661 756c            Defaul
+00000b20: 7473 2074 6f20 4e6f 6e65 2c20 7468 656e  ts to None, then
+00000b30: 2074 6865 2066 7265 6520 6d65 6d6f 7279   the free memory
+00000b40: 2069 7320 6175 746f 6d61 7469 6361 6c6c   is automaticall
+00000b50: 7920 6465 7465 726d 696e 6564 2e0a 2020  y determined..  
+00000b60: 2020 2020 2020 2020 2020 6370 755f 636f            cpu_co
+00000b70: 756e 7420 2869 6e74 2c20 6f70 7469 6f6e  unt (int, option
+00000b80: 616c 293a 2074 6865 206e 756d 6265 7220  al): the number 
+00000b90: 6f66 2043 5055 2773 2061 7661 696c 6162  of CPU's availab
+00000ba0: 6c65 2e20 4465 6661 756c 7473 2074 6f20  le. Defaults to 
+00000bb0: 2d31 2c0a 2020 2020 2020 2020 2020 2020  -1,.            
+00000bc0: 2020 2020 7468 656e 2074 6865 2063 7075      then the cpu
+00000bd0: 5f63 6f75 6e74 2069 7320 6465 7465 726d  _count is determ
+00000be0: 696e 6564 2061 7574 6f6d 6174 6963 616c  ined automatical
+00000bf0: 6c79 2e0a 2020 2020 2020 2020 2222 220a  ly..        """.
+00000c00: 2020 2020 2020 2020 7365 6c66 2e62 7974          self.byt
+00000c10: 6573 5f62 6173 6566 6f6f 7470 7269 6e74  es_basefootprint
+00000c20: 203d 2062 7974 6573 5f62 6173 6566 6f6f   = bytes_basefoo
+00000c30: 7470 7269 6e74 0a20 2020 2020 2020 2073  tprint.        s
+00000c40: 656c 662e 6279 7465 735f 7065 725f 726f  elf.bytes_per_ro
+00000c50: 7720 3d20 6279 7465 735f 7065 725f 726f  w = bytes_per_ro
+00000c60: 770a 2020 2020 2020 2020 7365 6c66 2e6d  w.        self.m
+00000c70: 696e 5f72 6f77 735f 7065 725f 6261 7463  in_rows_per_batc
+00000c80: 6820 3d20 6d69 6e5f 726f 7773 5f70 6572  h = min_rows_per
+00000c90: 5f62 6174 6368 0a20 2020 2020 2020 2073  _batch.        s
+00000ca0: 656c 662e 6d61 785f 726f 7773 5f70 6572  elf.max_rows_per
+00000cb0: 5f62 6174 6368 203d 206d 6178 5f72 6f77  _batch = max_row
+00000cc0: 735f 7065 725f 6261 7463 680a 0a20 2020  s_per_batch..   
+00000cd0: 2020 2020 2023 204e 6565 6473 2073 6f6d       # Needs som
+00000ce0: 6520 6c6f 6769 6320 746f 2067 6574 2076  e logic to get v
+00000cf0: 616c 7565 2069 6620 6e6f 7420 7365 7420  alue if not set 
+00000d00: 6578 706c 6963 6974 6c79 2e2e 2e0a 2020  explicitly....  
+00000d10: 2020 2020 2020 7365 6c66 2e5f 6279 7465        self._byte
+00000d20: 735f 6d69 6e5f 7065 725f 7072 6f63 6573  s_min_per_proces
+00000d30: 7320 3d20 6279 7465 735f 6d69 6e5f 7065  s = bytes_min_pe
+00000d40: 725f 7072 6f63 6573 730a 2020 2020 2020  r_process.      
+00000d50: 2020 2320 4966 206e 6f74 2073 7065 6369    # If not speci
+00000d60: 6669 6564 2c20 6465 7465 726d 696e 6520  fied, determine 
+00000d70: 796f 7572 7365 6c66 0a20 2020 2020 2020  yourself.       
+00000d80: 2073 656c 662e 6279 7465 735f 7573 6162   self.bytes_usab
+00000d90: 6c65 203d 2028 0a20 2020 2020 2020 2020  le = (.         
+00000da0: 2020 2062 7974 6573 5f75 7361 626c 650a     bytes_usable.
+00000db0: 2020 2020 2020 2020 2020 2020 6966 2062              if b
+00000dc0: 7974 6573 5f75 7361 626c 6520 6973 206e  ytes_usable is n
+00000dd0: 6f74 204e 6f6e 650a 2020 2020 2020 2020  ot None.        
+00000de0: 2020 2020 656c 7365 2069 6e74 2870 7375      else int(psu
+00000df0: 7469 6c2e 7669 7274 7561 6c5f 6d65 6d6f  til.virtual_memo
+00000e00: 7279 2829 2e61 7661 696c 6162 6c65 202a  ry().available *
+00000e10: 2030 2e39 290a 2020 2020 2020 2020 290a   0.9).        ).
+00000e20: 2020 2020 2020 2020 2320 4966 206e 6f74          # If not
+00000e30: 2073 7065 6369 6669 6564 2c20 6465 7465   specified, dete
+00000e40: 726d 696e 6520 796f 7572 7365 6c66 0a20  rmine yourself. 
+00000e50: 2020 2020 2020 2073 656c 662e 6370 755f         self.cpu_
+00000e60: 636f 756e 7420 3d20 6370 755f 636f 756e  count = cpu_coun
+00000e70: 7420 6966 2063 7075 5f63 6f75 6e74 203e  t if cpu_count >
+00000e80: 2030 2065 6c73 6520 6d75 6c74 6970 726f   0 else multipro
+00000e90: 6365 7373 696e 672e 6370 755f 636f 756e  cessing.cpu_coun
+00000ea0: 7428 290a 0a20 2020 2040 7072 6f70 6572  t()..    @proper
+00000eb0: 7479 0a20 2020 2064 6566 2062 7974 6573  ty.    def bytes
+00000ec0: 5f6d 696e 5f70 6572 5f70 726f 6365 7373  _min_per_process
+00000ed0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00000ee0: 6966 2073 656c 662e 5f62 7974 6573 5f6d  if self._bytes_m
+00000ef0: 696e 5f70 6572 5f70 726f 6365 7373 2069  in_per_process i
+00000f00: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00000f10: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00000f20: 656c 662e 5f62 7974 6573 5f6d 696e 5f70  elf._bytes_min_p
+00000f30: 6572 5f70 726f 6365 7373 0a20 2020 2020  er_process.     
+00000f40: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00000f50: 2020 2020 2072 6574 7572 6e20 280a 2020       return (.  
+00000f60: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00000f70: 6c66 2e62 7974 6573 5f62 6173 6566 6f6f  lf.bytes_basefoo
+00000f80: 7470 7269 6e74 202b 2073 656c 662e 6279  tprint + self.by
+00000f90: 7465 735f 7065 725f 726f 7720 2a20 7365  tes_per_row * se
+00000fa0: 6c66 2e6d 696e 5f72 6f77 735f 7065 725f  lf.min_rows_per_
+00000fb0: 6261 7463 680a 2020 2020 2020 2020 2020  batch.          
+00000fc0: 2020 290a 0a20 2020 2040 6279 7465 735f    )..    @bytes_
+00000fd0: 6d69 6e5f 7065 725f 7072 6f63 6573 732e  min_per_process.
+00000fe0: 7365 7474 6572 0a20 2020 2064 6566 2062  setter.    def b
+00000ff0: 7974 6573 5f6d 696e 5f70 6572 5f70 726f  ytes_min_per_pro
+00001000: 6365 7373 2873 656c 662c 2076 616c 7565  cess(self, value
+00001010: 293a 0a20 2020 2020 2020 2073 656c 662e  ):.        self.
+00001020: 5f62 7974 6573 5f6d 696e 5f70 6572 5f70  _bytes_min_per_p
+00001030: 726f 6365 7373 203d 2076 616c 7565 0a0a  rocess = value..
+00001040: 0a64 6566 205f 6465 7465 726d 696e 655f  .def _determine_
+00001050: 6e62 5f62 6174 6368 6573 280a 2020 2020  nb_batches(.    
+00001060: 6e62 5f72 6f77 735f 746f 7461 6c3a 2069  nb_rows_total: i
+00001070: 6e74 2c0a 2020 2020 6e62 5f70 6172 616c  nt,.    nb_paral
+00001080: 6c65 6c3a 2069 6e74 203d 202d 312c 0a20  lel: int = -1,. 
+00001090: 2020 2062 6174 6368 7369 7a65 3a20 696e     batchsize: in
+000010a0: 7420 3d20 2d31 2c0a 2020 2020 7061 7261  t = -1,.    para
+000010b0: 6c6c 656c 697a 6174 696f 6e5f 636f 6e66  llelization_conf
+000010c0: 6967 3a20 4f70 7469 6f6e 616c 5b50 6172  ig: Optional[Par
+000010d0: 616c 6c65 6c69 7a61 7469 6f6e 436f 6e66  allelizationConf
+000010e0: 6967 5d20 3d20 4e6f 6e65 2c0a 2920 2d3e  ig] = None,.) ->
+000010f0: 2054 7570 6c65 5b69 6e74 2c20 696e 745d   Tuple[int, int]
+00001100: 3a0a 2020 2020 2222 220a 2020 2020 4465  :.    """.    De
+00001110: 7465 726d 696e 6573 2072 6563 6f6d 6d65  termines recomme
+00001120: 6e64 6564 2070 6172 616c 6c65 6c69 7a61  nded paralleliza
+00001130: 7469 6f6e 2070 6172 616d 732e 0a0a 2020  tion params...  
+00001140: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
+00001150: 6e62 5f72 6f77 735f 746f 7461 6c20 2869  nb_rows_total (i
+00001160: 6e74 293a 2054 6865 2074 6f74 616c 206e  nt): The total n
+00001170: 756d 6265 7220 6f66 2072 6f77 7320 7468  umber of rows th
+00001180: 6174 2077 696c 6c20 6265 2070 726f 6365  at will be proce
+00001190: 7373 6564 0a20 2020 2020 2020 206e 625f  ssed.        nb_
+000011a0: 7061 7261 6c6c 656c 2028 696e 7429 3a20  parallel (int): 
+000011b0: 5468 6520 6c65 7665 6c20 6f66 2070 6172  The level of par
+000011c0: 616c 6c65 6c69 7a61 7469 6f6e 2072 6571  allelization req
+000011d0: 7565 7374 6564 2e0a 2020 2020 2020 2020  uested..        
+000011e0: 2020 2020 4966 202d 312c 2074 7269 6573      If -1, tries
+000011f0: 2074 6f20 7573 6520 616c 6c20 7265 736f   to use all reso
+00001200: 7572 6365 7320 6176 6169 6c61 626c 652e  urces available.
+00001210: 0a20 2020 2020 2020 2062 6174 6368 7369  .        batchsi
+00001220: 7a65 2028 696e 7429 3a20 696e 6469 6361  ze (int): indica
+00001230: 7469 7665 206e 756d 6265 7220 6f66 2072  tive number of r
+00001240: 6f77 7320 746f 2070 726f 6365 7373 2070  ows to process p
+00001250: 6572 2062 6174 6368 2e0a 2020 2020 2020  er batch..      
+00001260: 2020 2020 2020 4966 202d 313a 2028 7472        If -1: (tr
+00001270: 7920 746f 2920 6465 7465 726d 696e 6520  y to) determine 
+00001280: 6f70 7469 6d61 6c20 7369 7a65 2061 7574  optimal size aut
+00001290: 6f6d 6174 6963 616c 6c79 2075 7369 6e67  omatically using
+000012a0: 2074 6865 2068 6575 7269 7374 6963 7320   the heuristics 
+000012b0: 696e 0a20 2020 2020 2020 2020 2020 2027  in.            '
+000012c0: 7061 7261 6c6c 656c 697a 6174 696f 6e5f  parallelization_
+000012d0: 636f 6e66 6967 272e 0a20 2020 2020 2020  config'..       
+000012e0: 2070 6172 616c 6c65 6c69 7a61 7469 6f6e   parallelization
+000012f0: 5f63 6f6e 6669 6720 2850 6172 616c 6c65  _config (Paralle
+00001300: 6c69 7a61 7469 6f6e 436f 6e66 6967 2c20  lizationConfig, 
+00001310: 6f70 7469 6f6e 616c 293a 2043 6f6e 6669  optional): Confi
+00001320: 6775 7261 7469 6f6e 0a20 2020 2020 2020  guration.       
+00001330: 2020 2020 2070 6172 616d 6574 6572 7320       parameters 
+00001340: 746f 2075 7365 2074 6f20 7375 6767 6573  to use to sugges
+00001350: 7420 7061 7261 6c6c 656c 6973 6174 696f  t parallelisatio
+00001360: 6e20 7061 7261 6d65 7465 7273 2e0a 0a20  n parameters... 
+00001370: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
+00001380: 2020 2020 5475 706c 655b 696e 742c 2069      Tuple[int, i
+00001390: 6e74 5d3a 2054 7570 6c65 206f 6620 286e  nt]: Tuple of (n
+000013a0: 625f 7061 7261 6c6c 656c 2c20 6e62 5f62  b_parallel, nb_b
+000013b0: 6174 6368 6573 290a 2020 2020 2222 220a  atches).    """.
+000013c0: 2020 2020 2320 4966 2030 206f 7220 3120      # If 0 or 1 
+000013d0: 726f 7773 2074 6f20 7072 6f63 6573 732c  rows to process,
+000013e0: 206f 6e65 2062 6174 6368 0a20 2020 2069   one batch.    i
+000013f0: 6620 6e62 5f72 6f77 735f 746f 7461 6c20  f nb_rows_total 
+00001400: 3c3d 2031 3a0a 2020 2020 2020 2020 7265  <= 1:.        re
+00001410: 7475 726e 2028 312c 2031 290a 0a20 2020  turn (1, 1)..   
+00001420: 2023 2049 6620 636f 6e66 6967 2069 7320   # If config is 
+00001430: 4e6f 6e65 2c20 7573 6520 6465 6661 756c  None, use defaul
+00001440: 7420 636f 6e66 6967 0a20 2020 2069 6620  t config.    if 
+00001450: 7061 7261 6c6c 656c 697a 6174 696f 6e5f  parallelization_
+00001460: 636f 6e66 6967 2069 7320 4e6f 6e65 3a0a  config is None:.
+00001470: 2020 2020 2020 2020 636f 6e66 6967 5f6c          config_l
+00001480: 6f63 616c 203d 2050 6172 616c 6c65 6c69  ocal = Paralleli
+00001490: 7a61 7469 6f6e 436f 6e66 6967 2829 0a20  zationConfig(). 
+000014a0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000014b0: 2063 6f6e 6669 675f 6c6f 6361 6c20 3d20   config_local = 
+000014c0: 636f 7079 2e64 6565 7063 6f70 7928 7061  copy.deepcopy(pa
+000014d0: 7261 6c6c 656c 697a 6174 696f 6e5f 636f  rallelization_co
+000014e0: 6e66 6967 290a 0a20 2020 2023 2049 6620  nfig)..    # If 
+000014f0: 7468 6520 6e75 6d62 6572 206f 6620 726f  the number of ro
+00001500: 7773 2069 7320 7265 616c 6c79 206c 6f77  ws is really low
+00001510: 2c20 6a75 7374 2075 7365 206f 6e65 2062  , just use one b
+00001520: 6174 6368 0a20 2020 2069 6620 6e62 5f70  atch.    if nb_p
+00001530: 6172 616c 6c65 6c20 3c20 3120 616e 6420  arallel < 1 and 
+00001540: 6261 7463 6873 697a 6520 3c20 313a 0a20  batchsize < 1:. 
+00001550: 2020 2020 2020 2069 6620 6e62 5f72 6f77         if nb_row
+00001560: 735f 746f 7461 6c20 3c3d 2063 6f6e 6669  s_total <= confi
+00001570: 675f 6c6f 6361 6c2e 6d69 6e5f 726f 7773  g_local.min_rows
+00001580: 5f70 6572 5f62 6174 6368 3a0a 2020 2020  _per_batch:.    
+00001590: 2020 2020 2020 2020 7265 7475 726e 2028          return (
+000015a0: 312c 2031 290a 0a20 2020 2069 6620 6e62  1, 1)..    if nb
+000015b0: 5f70 6172 616c 6c65 6c20 3c3d 2030 3a0a  _parallel <= 0:.
+000015c0: 2020 2020 2020 2020 6e62 5f70 6172 616c          nb_paral
+000015d0: 6c65 6c20 3d20 636f 6e66 6967 5f6c 6f63  lel = config_loc
+000015e0: 616c 2e63 7075 5f63 6f75 6e74 0a0a 2020  al.cpu_count..  
+000015f0: 2020 6966 206c 6f67 6765 722e 6973 456e    if logger.isEn
+00001600: 6162 6c65 6446 6f72 286c 6f67 6769 6e67  abledFor(logging
+00001610: 2e44 4542 5547 293a 0a20 2020 2020 2020  .DEBUG):.       
+00001620: 206d 656d 5f75 7361 626c 6520 3d20 5f67   mem_usable = _g
+00001630: 656e 6572 616c 5f75 7469 6c2e 666f 726d  eneral_util.form
+00001640: 6174 6279 7465 7328 636f 6e66 6967 5f6c  atbytes(config_l
+00001650: 6f63 616c 2e62 7974 6573 5f75 7361 626c  ocal.bytes_usabl
+00001660: 6529 0a20 2020 2020 2020 206c 6f67 6765  e).        logge
+00001670: 722e 6465 6275 6728 6622 6d65 6d6f 7279  r.debug(f"memory
+00001680: 5f75 7361 626c 653a 207b 6d65 6d5f 7573  _usable: {mem_us
+00001690: 6162 6c65 7d2c 2077 6974 683a 2229 0a20  able}, with:"). 
+000016a0: 2020 2020 2020 206d 656d 5f61 7661 696c         mem_avail
+000016b0: 6162 6c65 203d 205f 6765 6e65 7261 6c5f  able = _general_
+000016c0: 7574 696c 2e66 6f72 6d61 7462 7974 6573  util.formatbytes
+000016d0: 2870 7375 7469 6c2e 7669 7274 7561 6c5f  (psutil.virtual_
+000016e0: 6d65 6d6f 7279 2829 2e61 7661 696c 6162  memory().availab
+000016f0: 6c65 290a 2020 2020 2020 2020 6c6f 6767  le).        logg
+00001700: 6572 2e64 6562 7567 2866 2220 202d 3e20  er.debug(f"  -> 
+00001710: 6d65 6d2e 6176 6169 6c61 626c 653a 207b  mem.available: {
+00001720: 6d65 6d5f 6176 6169 6c61 626c 657d 2229  mem_available}")
+00001730: 0a20 2020 2020 2020 2073 7761 705f 6672  .        swap_fr
+00001740: 6565 203d 205f 6765 6e65 7261 6c5f 7574  ee = _general_ut
+00001750: 696c 2e66 6f72 6d61 7462 7974 6573 2870  il.formatbytes(p
+00001760: 7375 7469 6c2e 7377 6170 5f6d 656d 6f72  sutil.swap_memor
+00001770: 7928 292e 6672 6565 290a 2020 2020 2020  y().free).      
+00001780: 2020 6c6f 6767 6572 2e64 6562 7567 2866    logger.debug(f
+00001790: 2220 202d 3e20 7377 6170 2e66 7265 653a  "  -> swap.free:
+000017a0: 207b 7377 6170 5f66 7265 657d 2229 0a0a   {swap_free}")..
+000017b0: 2020 2020 2320 4966 206e 6f74 2065 6e6f      # If not eno
+000017c0: 7567 6820 6d65 6d6f 7279 2066 6f72 2074  ugh memory for t
+000017d0: 6865 2061 6d6f 756e 7420 6f66 2070 6172  he amount of par
+000017e0: 616c 6c65 6c6c 6973 6d20 6173 6b65 642c  allellism asked,
+000017f0: 2072 6564 7563 650a 2020 2020 6966 2028   reduce.    if (
+00001800: 6e62 5f70 6172 616c 6c65 6c20 2a20 636f  nb_parallel * co
+00001810: 6e66 6967 5f6c 6f63 616c 2e62 7974 6573  nfig_local.bytes
+00001820: 5f6d 696e 5f70 6572 5f70 726f 6365 7373  _min_per_process
+00001830: 2920 3e20 636f 6e66 6967 5f6c 6f63 616c  ) > config_local
+00001840: 2e62 7974 6573 5f75 7361 626c 653a 0a20  .bytes_usable:. 
+00001850: 2020 2020 2020 206e 625f 7061 7261 6c6c         nb_parall
+00001860: 656c 203d 2069 6e74 280a 2020 2020 2020  el = int(.      
+00001870: 2020 2020 2020 636f 6e66 6967 5f6c 6f63        config_loc
+00001880: 616c 2e62 7974 6573 5f75 7361 626c 6520  al.bytes_usable 
+00001890: 2f20 636f 6e66 6967 5f6c 6f63 616c 2e62  / config_local.b
+000018a0: 7974 6573 5f6d 696e 5f70 6572 5f70 726f  ytes_min_per_pro
+000018b0: 6365 7373 0a20 2020 2020 2020 2029 0a20  cess.        ). 
+000018c0: 2020 2020 2020 206c 6f67 6765 722e 6465         logger.de
+000018d0: 6275 6728 6622 4e62 5f70 6172 616c 6c65  bug(f"Nb_paralle
+000018e0: 6c20 7265 6475 6365 6420 746f 207b 6e62  l reduced to {nb
+000018f0: 5f70 6172 616c 6c65 6c7d 2074 6f20 7265  _parallel} to re
+00001900: 6475 6365 206d 656d 6f72 7920 7573 6167  duce memory usag
+00001910: 6522 290a 0a20 2020 2023 2048 6176 696e  e")..    # Havin
+00001920: 6720 6d6f 7265 2077 6f72 6b65 7273 2074  g more workers t
+00001930: 6861 6e20 726f 7773 2064 6f65 736e 2774  han rows doesn't
+00001940: 206d 616b 6520 7365 6e73 650a 2020 2020   make sense.    
+00001950: 6966 206e 625f 7061 7261 6c6c 656c 203e  if nb_parallel >
+00001960: 206e 625f 726f 7773 5f74 6f74 616c 3a0a   nb_rows_total:.
+00001970: 2020 2020 2020 2020 6e62 5f70 6172 616c          nb_paral
+00001980: 6c65 6c20 3d20 6e62 5f72 6f77 735f 746f  lel = nb_rows_to
+00001990: 7461 6c0a 0a20 2020 2023 2049 6620 6261  tal..    # If ba
+000019a0: 7463 6873 697a 6520 6973 2073 7065 6369  tchsize is speci
+000019b0: 6669 6564 2c20 7573 6520 6974 2074 6f20  fied, use it to 
+000019c0: 6465 7465 726d 696e 6520 6e75 6d62 6572  determine number
+000019d0: 206f 6620 6261 7463 6865 732e 0a20 2020   of batches..   
+000019e0: 2069 6620 6261 7463 6873 697a 6520 3e20   if batchsize > 
+000019f0: 303a 0a20 2020 2020 2020 206e 625f 6261  0:.        nb_ba
+00001a00: 7463 6865 7320 3d20 6d61 7468 2e63 6569  tches = math.cei
+00001a10: 6c28 6e62 5f72 6f77 735f 746f 7461 6c20  l(nb_rows_total 
+00001a20: 2f20 6261 7463 6873 697a 6529 0a0a 2020  / batchsize)..  
+00001a30: 2020 2020 2020 2320 4e6f 2075 7365 2074        # No use t
+00001a40: 6f20 6861 7665 206d 6f72 6520 776f 726b  o have more work
+00001a50: 6572 7320 7468 616e 206e 756d 6265 7220  ers than number 
+00001a60: 6f66 2062 6174 6368 6573 0a20 2020 2020  of batches.     
+00001a70: 2020 2069 6620 6e62 5f70 6172 616c 6c65     if nb_paralle
+00001a80: 6c20 3e20 6e62 5f62 6174 6368 6573 3a0a  l > nb_batches:.
+00001a90: 2020 2020 2020 2020 2020 2020 6e62 5f70              nb_p
+00001aa0: 6172 616c 6c65 6c20 3d20 6e62 5f62 6174  arallel = nb_bat
+00001ab0: 6368 6573 0a0a 2020 2020 2020 2020 7265  ches..        re
+00001ac0: 7475 726e 2028 6e62 5f70 6172 616c 6c65  turn (nb_paralle
+00001ad0: 6c2c 206e 625f 6261 7463 6865 7329 0a0a  l, nb_batches)..
+00001ae0: 2020 2020 2320 4e6f 2062 6174 6368 7369      # No batchsi
+00001af0: 7a65 2073 7065 6369 6669 6564 2c20 736f  ze specified, so
+00001b00: 2075 7365 2068 6575 7269 7374 6963 732e   use heuristics.
+00001b10: 0a20 2020 2023 2053 7461 7274 2077 6974  .    # Start wit
+00001b20: 6820 3120 6261 7463 6820 7065 7220 776f  h 1 batch per wo
+00001b30: 726b 6572 0a20 2020 206e 625f 6261 7463  rker.    nb_batc
+00001b40: 6865 7320 3d20 6e62 5f70 6172 616c 6c65  hes = nb_paralle
+00001b50: 6c0a 0a20 2020 2023 2049 6620 7468 6520  l..    # If the 
+00001b60: 6261 7463 6865 7320 3c20 6d69 6e5f 726f  batches < min_ro
+00001b70: 7773 5f70 6572 5f62 6174 6368 2c20 6465  ws_per_batch, de
+00001b80: 6372 6561 7365 206e 756d 6265 7220 6261  crease number ba
+00001b90: 7463 6865 730a 2020 2020 6966 206e 625f  tches.    if nb_
+00001ba0: 726f 7773 5f74 6f74 616c 202f 206e 625f  rows_total / nb_
+00001bb0: 6261 7463 6865 7320 3c20 636f 6e66 6967  batches < config
+00001bc0: 5f6c 6f63 616c 2e6d 696e 5f72 6f77 735f  _local.min_rows_
+00001bd0: 7065 725f 6261 7463 683a 0a20 2020 2020  per_batch:.     
+00001be0: 2020 206e 625f 6261 7463 6865 7320 3d20     nb_batches = 
+00001bf0: 6d61 7468 2e63 6569 6c28 6e62 5f72 6f77  math.ceil(nb_row
+00001c00: 735f 746f 7461 6c20 2f20 636f 6e66 6967  s_total / config
+00001c10: 5f6c 6f63 616c 2e6d 696e 5f72 6f77 735f  _local.min_rows_
+00001c20: 7065 725f 6261 7463 6829 0a0a 2020 2020  per_batch)..    
+00001c30: 2320 4966 2074 6865 2062 6174 6368 6573  # If the batches
+00001c40: 203e 206d 6178 5f72 6f77 735f 7065 725f   > max_rows_per_
+00001c50: 6261 7463 682c 2069 6e63 7265 6173 6520  batch, increase 
+00001c60: 6e75 6d62 6572 2062 6174 6368 6573 0a20  number batches. 
+00001c70: 2020 2069 6620 6e62 5f72 6f77 735f 746f     if nb_rows_to
+00001c80: 7461 6c20 2f20 6e62 5f62 6174 6368 6573  tal / nb_batches
+00001c90: 203e 2063 6f6e 6669 675f 6c6f 6361 6c2e   > config_local.
+00001ca0: 6d61 785f 726f 7773 5f70 6572 5f62 6174  max_rows_per_bat
+00001cb0: 6368 3a0a 2020 2020 2020 2020 6e62 5f62  ch:.        nb_b
+00001cc0: 6174 6368 6573 203d 206d 6174 682e 6365  atches = math.ce
+00001cd0: 696c 286e 625f 726f 7773 5f74 6f74 616c  il(nb_rows_total
+00001ce0: 202f 2063 6f6e 6669 675f 6c6f 6361 6c2e   / config_local.
+00001cf0: 6d61 785f 726f 7773 5f70 6572 5f62 6174  max_rows_per_bat
+00001d00: 6368 290a 2020 2020 2020 2020 2320 526f  ch).        # Ro
+00001d10: 756e 6420 6e62 5f62 6174 6368 6573 2075  und nb_batches u
+00001d20: 7020 746f 2074 6865 206e 6561 7265 7374  p to the nearest
+00001d30: 206d 756c 7469 706c 6520 6f66 206e 625f   multiple of nb_
+00001d40: 7061 7261 6c6c 656c 0a20 2020 2020 2020  parallel.       
+00001d50: 206e 625f 6261 7463 6865 7320 3d20 6d61   nb_batches = ma
+00001d60: 7468 2e63 6569 6c28 6e62 5f62 6174 6368  th.ceil(nb_batch
+00001d70: 6573 202f 206e 625f 7061 7261 6c6c 656c  es / nb_parallel
+00001d80: 2920 2a20 6e62 5f70 6172 616c 6c65 6c0a  ) * nb_parallel.
+00001d90: 0a20 2020 2023 2048 6176 696e 6720 6d6f  .    # Having mo
+00001da0: 7265 2077 6f72 6b65 7273 2074 6861 6e20  re workers than 
+00001db0: 6261 7463 6865 7320 6973 6e27 7420 6c6f  batches isn't lo
+00001dc0: 6769 6361 6c2e 2e2e 0a20 2020 2069 6620  gical....    if 
+00001dd0: 6e62 5f70 6172 616c 6c65 6c20 3e20 6e62  nb_parallel > nb
+00001de0: 5f62 6174 6368 6573 3a0a 2020 2020 2020  _batches:.      
+00001df0: 2020 6e62 5f70 6172 616c 6c65 6c20 3d20    nb_parallel = 
+00001e00: 6e62 5f62 6174 6368 6573 0a0a 2020 2020  nb_batches..    
+00001e10: 2320 4669 6e61 6c6c 792c 206d 616b 6520  # Finally, make 
+00001e20: 7375 7265 2074 6865 7265 2061 7265 2065  sure there are e
+00001e30: 6e6f 7567 6820 6261 7463 6865 7320 746f  nough batches to
+00001e40: 2061 766f 6964 206d 656d 6f72 7920 6973   avoid memory is
+00001e50: 7375 6573 3a0a 2020 2020 2320 2020 3d20  sues:.    #   = 
+00001e60: 746f 7461 6c20 6d65 6d6f 7279 2075 7361  total memory usa
+00001e70: 6765 2066 6f72 2061 6c6c 2072 6f77 7320  ge for all rows 
+00001e80: 2f0a 2020 2020 2320 2020 2020 2866 7265  /.    #     (fre
+00001e90: 6520 6d65 6d6f 7279 202d 2062 6173 6520  e memory - base 
+00001ea0: 6d65 6d6f 7279 2075 7365 6420 6279 2061  memory used by a
+00001eb0: 6c6c 2070 6172 616c 6c65 6c20 7072 6f63  ll parallel proc
+00001ec0: 6573 7365 7329 0a20 2020 206e 625f 6261  esses).    nb_ba
+00001ed0: 7463 6865 735f 6d69 6e20 3d20 6d61 7468  tches_min = math
+00001ee0: 2e63 6569 6c28 0a20 2020 2020 2020 2028  .ceil(.        (
+00001ef0: 6e62 5f72 6f77 735f 746f 7461 6c20 2a20  nb_rows_total * 
+00001f00: 636f 6e66 6967 5f6c 6f63 616c 2e62 7974  config_local.byt
+00001f10: 6573 5f70 6572 5f72 6f77 290a 2020 2020  es_per_row).    
+00001f20: 2020 2020 2f20 2863 6f6e 6669 675f 6c6f      / (config_lo
+00001f30: 6361 6c2e 6279 7465 735f 7573 6162 6c65  cal.bytes_usable
+00001f40: 202d 2063 6f6e 6669 675f 6c6f 6361 6c2e   - config_local.
+00001f50: 6279 7465 735f 6261 7365 666f 6f74 7072  bytes_basefootpr
+00001f60: 696e 7420 2a20 6e62 5f70 6172 616c 6c65  int * nb_paralle
+00001f70: 6c29 0a20 2020 2029 0a20 2020 2069 6620  l).    ).    if 
+00001f80: 6e62 5f62 6174 6368 6573 203c 206e 625f  nb_batches < nb_
+00001f90: 6261 7463 6865 735f 6d69 6e3a 0a20 2020  batches_min:.   
+00001fa0: 2020 2020 2023 2052 6f75 6e64 206e 625f       # Round nb_
+00001fb0: 6261 7463 6865 7320 7570 2074 6f20 7468  batches up to th
+00001fc0: 6520 6e65 6172 6573 7420 6d75 6c74 6970  e nearest multip
+00001fd0: 6c65 206f 6620 6e62 5f70 6172 616c 6c65  le of nb_paralle
+00001fe0: 6c0a 2020 2020 2020 2020 6e62 5f62 6174  l.        nb_bat
+00001ff0: 6368 6573 203d 206d 6174 682e 6365 696c  ches = math.ceil
+00002000: 286e 625f 6261 7463 6865 735f 6d69 6e20  (nb_batches_min 
+00002010: 2f20 6e62 5f70 6172 616c 6c65 6c29 202a  / nb_parallel) *
+00002020: 206e 625f 7061 7261 6c6c 656c 0a0a 2020   nb_parallel..  
+00002030: 2020 2320 4c6f 6720 7265 7375 6c74 0a20    # Log result. 
+00002040: 2020 2069 6620 6c6f 6767 6572 2e69 7345     if logger.isE
+00002050: 6e61 626c 6564 466f 7228 6c6f 6767 696e  nabledFor(loggin
+00002060: 672e 4445 4255 4729 3a0a 2020 2020 2020  g.DEBUG):.      
+00002070: 2020 6261 7463 6873 697a 6520 3d20 6d61    batchsize = ma
+00002080: 7468 2e63 6569 6c28 6e62 5f72 6f77 735f  th.ceil(nb_rows_
+00002090: 746f 7461 6c20 2f20 6e62 5f62 6174 6368  total / nb_batch
+000020a0: 6573 290a 2020 2020 2020 2020 6d65 6d5f  es).        mem_
+000020b0: 7072 6564 6963 7465 6420 3d20 280a 2020  predicted = (.  
+000020c0: 2020 2020 2020 2020 2020 636f 6e66 6967            config
+000020d0: 5f6c 6f63 616c 2e62 7974 6573 5f62 6173  _local.bytes_bas
+000020e0: 6566 6f6f 7470 7269 6e74 202b 2062 6174  efootprint + bat
+000020f0: 6368 7369 7a65 202a 2063 6f6e 6669 675f  chsize * config_
+00002100: 6c6f 6361 6c2e 6279 7465 735f 7065 725f  local.bytes_per_
+00002110: 726f 770a 2020 2020 2020 2020 2920 2a20  row.        ) * 
+00002120: 6e62 5f62 6174 6368 6573 0a0a 2020 2020  nb_batches..    
+00002130: 2020 2020 6c6f 6767 6572 2e64 6562 7567      logger.debug
+00002140: 280a 2020 2020 2020 2020 2020 2020 6622  (.            f"
+00002150: 6e62 5f62 6174 6368 6573 5f72 6563 6f6d  nb_batches_recom
+00002160: 6d65 6e64 6564 3a20 7b6e 625f 6261 7463  mended: {nb_batc
+00002170: 6865 737d 2c20 726f 7773 5f70 6572 5f62  hes}, rows_per_b
+00002180: 6174 6368 3a20 7b62 6174 6368 7369 7a65  atch: {batchsize
+00002190: 7d22 0a20 2020 2020 2020 2029 0a20 2020  }".        ).   
+000021a0: 2020 2020 206c 6f67 6765 722e 6465 6275       logger.debu
+000021b0: 6728 6622 202d 3e20 6e62 5f72 6f77 735f  g(f" -> nb_rows_
+000021c0: 696e 7075 745f 6c61 7965 723a 207b 6e62  input_layer: {nb
+000021d0: 5f72 6f77 735f 746f 7461 6c7d 2229 0a20  _rows_total}"). 
+000021e0: 2020 2020 2020 206c 6f67 6765 722e 6465         logger.de
+000021f0: 6275 6728 6622 202d 3e20 6d65 6d5f 7072  bug(f" -> mem_pr
+00002200: 6564 6963 7465 643a 207b 5f67 656e 6572  edicted: {_gener
+00002210: 616c 5f75 7469 6c2e 666f 726d 6174 6279  al_util.formatby
+00002220: 7465 7328 6d65 6d5f 7072 6564 6963 7465  tes(mem_predicte
+00002230: 6429 7d22 290a 0a20 2020 2072 6574 7572  d)}")..    retur
+00002240: 6e20 286e 625f 7061 7261 6c6c 656c 2c20  n (nb_parallel, 
+00002250: 6e62 5f62 6174 6368 6573 290a 0a0a 636c  nb_batches)...cl
+00002260: 6173 7320 5072 6f63 6573 7369 6e67 5061  ass ProcessingPa
+00002270: 7261 6d73 3a0a 2020 2020 6465 6620 5f5f  rams:.    def __
+00002280: 696e 6974 5f5f 280a 2020 2020 2020 2020  init__(.        
+00002290: 7365 6c66 2c0a 2020 2020 2020 2020 6e62  self,.        nb
+000022a0: 5f72 6f77 735f 746f 5f70 726f 6365 7373  _rows_to_process
+000022b0: 3a20 696e 742c 0a20 2020 2020 2020 206e  : int,.        n
+000022c0: 625f 7061 7261 6c6c 656c 3a20 696e 742c  b_parallel: int,
+000022d0: 0a20 2020 2020 2020 2062 6174 6368 6573  .        batches
+000022e0: 3a20 4c69 7374 5b73 7472 5d2c 0a20 2020  : List[str],.   
+000022f0: 2020 2020 2062 6174 6368 7369 7a65 3a20       batchsize: 
+00002300: 696e 742c 0a20 2020 2029 3a0a 2020 2020  int,.    ):.    
+00002310: 2020 2020 7365 6c66 2e6e 625f 726f 7773      self.nb_rows
+00002320: 5f74 6f5f 7072 6f63 6573 7320 3d20 6e62  _to_process = nb
+00002330: 5f72 6f77 735f 746f 5f70 726f 6365 7373  _rows_to_process
+00002340: 0a20 2020 2020 2020 2073 656c 662e 6e62  .        self.nb
+00002350: 5f70 6172 616c 6c65 6c20 3d20 6e62 5f70  _parallel = nb_p
+00002360: 6172 616c 6c65 6c0a 2020 2020 2020 2020  arallel.        
+00002370: 7365 6c66 2e62 6174 6368 6573 203d 2062  self.batches = b
+00002380: 6174 6368 6573 0a20 2020 2020 2020 2073  atches.        s
+00002390: 656c 662e 6261 7463 6873 697a 6520 3d20  elf.batchsize = 
+000023a0: 6261 7463 6873 697a 650a 0a20 2020 2064  batchsize..    d
+000023b0: 6566 2074 6f5f 6a73 6f6e 2873 656c 662c  ef to_json(self,
+000023c0: 2070 6174 683a 2050 6174 6829 3a0a 2020   path: Path):.  
+000023d0: 2020 2020 2020 7072 6570 6172 6564 203d        prepared =
+000023e0: 205f 6765 6e65 7261 6c5f 7574 696c 2e70   _general_util.p
+000023f0: 7265 7061 7265 5f66 6f72 5f73 6572 6961  repare_for_seria
+00002400: 6c69 7a65 2876 6172 7328 7365 6c66 2929  lize(vars(self))
+00002410: 0a20 2020 2020 2020 2077 6974 6820 6f70  .        with op
+00002420: 656e 2870 6174 682c 2022 7722 2920 6173  en(path, "w") as
+00002430: 2066 696c 653a 0a20 2020 2020 2020 2020   file:.         
+00002440: 2020 2066 696c 652e 7772 6974 6528 6a73     file.write(js
+00002450: 6f6e 2e64 756d 7073 2870 7265 7061 7265  on.dumps(prepare
+00002460: 642c 2069 6e64 656e 743d 342c 2073 6f72  d, indent=4, sor
+00002470: 745f 6b65 7973 3d54 7275 6529 290a 0a0a  t_keys=True))...
+00002480: 6465 6620 5f70 7265 7061 7265 5f70 726f  def _prepare_pro
+00002490: 6365 7373 696e 675f 7061 7261 6d73 280a  cessing_params(.
+000024a0: 2020 2020 696e 7075 745f 7061 7468 3a20      input_path: 
+000024b0: 5061 7468 2c0a 2020 2020 696e 7075 745f  Path,.    input_
+000024c0: 6c61 7965 723a 2073 7472 2c0a 2020 2020  layer: str,.    
+000024d0: 6e62 5f70 6172 616c 6c65 6c3a 2069 6e74  nb_parallel: int
+000024e0: 2c0a 2020 2020 6261 7463 6873 697a 653a  ,.    batchsize:
+000024f0: 2069 6e74 2c0a 2020 2020 7061 7261 6c6c   int,.    parall
+00002500: 656c 697a 6174 696f 6e5f 636f 6e66 6967  elization_config
+00002510: 3a20 4f70 7469 6f6e 616c 5b50 6172 616c  : Optional[Paral
+00002520: 6c65 6c69 7a61 7469 6f6e 436f 6e66 6967  lelizationConfig
+00002530: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 746d  ] = None,.    tm
+00002540: 705f 6469 723a 204f 7074 696f 6e61 6c5b  p_dir: Optional[
+00002550: 5061 7468 5d20 3d20 4e6f 6e65 2c0a 2920  Path] = None,.) 
+00002560: 2d3e 2050 726f 6365 7373 696e 6750 6172  -> ProcessingPar
+00002570: 616d 733a 0a20 2020 2069 6e70 7574 5f69  ams:.    input_i
+00002580: 6e66 6f20 3d20 6766 6f2e 6765 745f 6c61  nfo = gfo.get_la
+00002590: 7965 7269 6e66 6f28 696e 7075 745f 7061  yerinfo(input_pa
+000025a0: 7468 2c20 696e 7075 745f 6c61 7965 7229  th, input_layer)
+000025b0: 0a20 2020 2066 6964 5f63 6f6c 756d 6e20  .    fid_column 
+000025c0: 3d20 696e 7075 745f 696e 666f 2e66 6964  = input_info.fid
+000025d0: 5f63 6f6c 756d 6e20 6966 2069 6e70 7574  _column if input
+000025e0: 5f69 6e66 6f2e 6669 645f 636f 6c75 6d6e  _info.fid_column
+000025f0: 2021 3d20 2222 2065 6c73 6520 2266 6964   != "" else "fid
+00002600: 220a 2020 2020 6e62 5f70 6172 616c 6c65  ".    nb_paralle
+00002610: 6c2c 206e 625f 6261 7463 6865 7320 3d20  l, nb_batches = 
+00002620: 5f64 6574 6572 6d69 6e65 5f6e 625f 6261  _determine_nb_ba
+00002630: 7463 6865 7328 0a20 2020 2020 2020 206e  tches(.        n
+00002640: 625f 726f 7773 5f74 6f74 616c 3d69 6e70  b_rows_total=inp
+00002650: 7574 5f69 6e66 6f2e 6665 6174 7572 6563  ut_info.featurec
+00002660: 6f75 6e74 2c0a 2020 2020 2020 2020 6e62  ount,.        nb
+00002670: 5f70 6172 616c 6c65 6c3d 6e62 5f70 6172  _parallel=nb_par
+00002680: 616c 6c65 6c2c 0a20 2020 2020 2020 2062  allel,.        b
+00002690: 6174 6368 7369 7a65 3d62 6174 6368 7369  atchsize=batchsi
+000026a0: 7a65 2c0a 2020 2020 2020 2020 7061 7261  ze,.        para
+000026b0: 6c6c 656c 697a 6174 696f 6e5f 636f 6e66  llelization_conf
+000026c0: 6967 3d70 6172 616c 6c65 6c69 7a61 7469  ig=parallelizati
+000026d0: 6f6e 5f63 6f6e 6669 672c 0a20 2020 2029  on_config,.    )
+000026e0: 0a0a 2020 2020 2320 5072 6570 6172 6520  ..    # Prepare 
+000026f0: 6261 7463 6865 7320 746f 2070 726f 6365  batches to proce
+00002700: 7373 0a20 2020 2062 6174 6368 6573 3a20  ss.    batches: 
+00002710: 4c69 7374 5b73 7472 5d20 3d20 5b5d 0a20  List[str] = []. 
+00002720: 2020 2069 6620 6e62 5f62 6174 6368 6573     if nb_batches
+00002730: 203d 3d20 313a 0a20 2020 2020 2020 2023   == 1:.        #
+00002740: 2049 6620 6f6e 6c79 206f 6e65 2062 6174   If only one bat
+00002750: 6368 2c20 6e6f 2066 696c 7465 7269 6e67  ch, no filtering
+00002760: 2069 7320 6e65 6564 6564 0a20 2020 2020   is needed.     
+00002770: 2020 2062 6174 6368 6573 2e61 7070 656e     batches.appen
+00002780: 6428 2222 290a 2020 2020 656c 7365 3a0a  d("").    else:.
+00002790: 2020 2020 2020 2020 2320 4465 7465 726d          # Determ
+000027a0: 696e 6520 7468 6520 6d69 6e5f 6669 6420  ine the min_fid 
+000027b0: 616e 6420 6d61 785f 6669 640a 2020 2020  and max_fid.    
+000027c0: 2020 2020 2320 5265 6d61 726b 3a20 5345      # Remark: SE
+000027d0: 4c45 4354 204d 494e 2866 6964 292c 204d  LECT MIN(fid), M
+000027e0: 4158 2866 6964 2920 4652 4f4d 202e 2e2e  AX(fid) FROM ...
+000027f0: 2069 7320 6120 6c6f 7420 736c 6f77 6572   is a lot slower
+00002800: 2074 6861 6e20 554e 494f 4e20 414c 4c21   than UNION ALL!
+00002810: 0a20 2020 2020 2020 2073 716c 5f73 746d  .        sql_stm
+00002820: 7420 3d20 6622 2222 0a20 2020 2020 2020  t = f""".       
+00002830: 2020 2020 2053 454c 4543 5420 4d49 4e28       SELECT MIN(
+00002840: 7b66 6964 5f63 6f6c 756d 6e7d 2920 6d69  {fid_column}) mi
+00002850: 6e6d 6178 5f66 6964 2046 524f 4d20 227b  nmax_fid FROM "{
+00002860: 696e 7075 745f 696e 666f 2e6e 616d 657d  input_info.name}
+00002870: 220a 2020 2020 2020 2020 2020 2020 554e  ".            UN
+00002880: 494f 4e20 414c 4c0a 2020 2020 2020 2020  ION ALL.        
+00002890: 2020 2020 5345 4c45 4354 204d 4158 287b      SELECT MAX({
+000028a0: 6669 645f 636f 6c75 6d6e 7d29 206d 696e  fid_column}) min
+000028b0: 6d61 785f 6669 6420 4652 4f4d 2022 7b69  max_fid FROM "{i
+000028c0: 6e70 7574 5f69 6e66 6f2e 6e61 6d65 7d22  nput_info.name}"
+000028d0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+000028e0: 2020 2020 2062 6174 6368 5f69 6e66 6f5f       batch_info_
+000028f0: 6466 203d 2067 666f 2e72 6561 645f 6669  df = gfo.read_fi
+00002900: 6c65 2870 6174 683d 696e 7075 745f 7061  le(path=input_pa
+00002910: 7468 2c20 7371 6c5f 7374 6d74 3d73 716c  th, sql_stmt=sql
+00002920: 5f73 746d 7429 0a20 2020 2020 2020 206d  _stmt).        m
+00002930: 696e 5f66 6964 203d 2070 642e 746f 5f6e  in_fid = pd.to_n
+00002940: 756d 6572 6963 2862 6174 6368 5f69 6e66  umeric(batch_inf
+00002950: 6f5f 6466 5b22 6d69 6e6d 6178 5f66 6964  o_df["minmax_fid
+00002960: 225d 5b30 5d29 2e69 7465 6d28 290a 2020  "][0]).item().  
+00002970: 2020 2020 2020 6d61 785f 6669 6420 3d20        max_fid = 
+00002980: 7064 2e74 6f5f 6e75 6d65 7269 6328 6261  pd.to_numeric(ba
+00002990: 7463 685f 696e 666f 5f64 665b 226d 696e  tch_info_df["min
+000029a0: 6d61 785f 6669 6422 5d5b 315d 292e 6974  max_fid"][1]).it
+000029b0: 656d 2829 0a0a 2020 2020 2020 2020 2320  em()..        # 
+000029c0: 4465 7465 726d 696e 6520 7468 6520 6578  Determine the ex
+000029d0: 6163 7420 6261 7463 6865 7320 746f 2075  act batches to u
+000029e0: 7365 0a20 2020 2020 2020 2069 6620 2828  se.        if ((
+000029f0: 6d61 785f 6669 6420 2d20 6d69 6e5f 6669  max_fid - min_fi
+00002a00: 6429 202f 2069 6e70 7574 5f69 6e66 6f2e  d) / input_info.
+00002a10: 6665 6174 7572 6563 6f75 6e74 2920 3c20  featurecount) < 
+00002a20: 312e 313a 0a20 2020 2020 2020 2020 2020  1.1:.           
+00002a30: 2023 2049 6620 7468 6520 6669 6427 7320   # If the fid's 
+00002a40: 6172 6520 7175 6974 6520 636f 6e73 6563  are quite consec
+00002a50: 7574 6976 652c 2075 7365 2061 6e20 696d  utive, use an im
+00002a60: 7065 7266 6563 742c 2062 7574 0a20 2020  perfect, but.   
+00002a70: 2020 2020 2020 2020 2023 2066 6173 7420           # fast 
+00002a80: 6469 7374 7269 6275 7469 6f6e 2069 6e20  distribution in 
+00002a90: 6261 7463 6865 730a 2020 2020 2020 2020  batches.        
+00002aa0: 2020 2020 6261 7463 685f 696e 666f 5f6c      batch_info_l
+00002ab0: 6973 7420 3d20 5b5d 0a20 2020 2020 2020  ist = [].       
+00002ac0: 2020 2020 206e 625f 726f 7773 5f70 6572       nb_rows_per
+00002ad0: 5f62 6174 6368 203d 2072 6f75 6e64 2869  _batch = round(i
+00002ae0: 6e70 7574 5f69 6e66 6f2e 6665 6174 7572  nput_info.featur
+00002af0: 6563 6f75 6e74 202f 206e 625f 6261 7463  ecount / nb_batc
+00002b00: 6865 7329 0a20 2020 2020 2020 2020 2020  hes).           
+00002b10: 206f 6666 7365 7420 3d20 300a 2020 2020   offset = 0.    
+00002b20: 2020 2020 2020 2020 6f66 6673 6574 5f70          offset_p
+00002b30: 6572 5f62 6174 6368 203d 2072 6f75 6e64  er_batch = round
+00002b40: 2828 6d61 785f 6669 6420 2d20 6d69 6e5f  ((max_fid - min_
+00002b50: 6669 6429 202f 206e 625f 6261 7463 6865  fid) / nb_batche
+00002b60: 7329 0a20 2020 2020 2020 2020 2020 2066  s).            f
+00002b70: 6f72 2062 6174 6368 5f69 6420 696e 2072  or batch_id in r
+00002b80: 616e 6765 286e 625f 6261 7463 6865 7329  ange(nb_batches)
+00002b90: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00002ba0: 2020 7374 6172 745f 6669 6420 3d20 6f66    start_fid = of
+00002bb0: 6673 6574 0a20 2020 2020 2020 2020 2020  fset.           
+00002bc0: 2020 2020 2069 6620 6261 7463 685f 6964       if batch_id
+00002bd0: 203c 2028 6e62 5f62 6174 6368 6573 202d   < (nb_batches -
+00002be0: 2031 293a 0a20 2020 2020 2020 2020 2020   1):.           
+00002bf0: 2020 2020 2020 2020 2023 2045 6e64 2066           # End f
+00002c00: 6964 2066 6f72 2074 6869 7320 6261 7463  id for this batc
+00002c10: 6820 6973 2074 6865 206e 6578 7420 7374  h is the next st
+00002c20: 6172 745f 6669 6420 2d20 310a 2020 2020  art_fid - 1.    
+00002c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002c40: 656e 645f 6669 6420 3d20 6f66 6673 6574  end_fid = offset
+00002c50: 202b 206f 6666 7365 745f 7065 725f 6261   + offset_per_ba
+00002c60: 7463 6820 2d20 310a 2020 2020 2020 2020  tch - 1.        
+00002c70: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00002c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002c90: 2020 2320 466f 7220 7468 6520 6c61 7374    # For the last
+00002ca0: 2062 6174 6368 2c20 7461 6b65 2074 6865   batch, take the
+00002cb0: 206d 6178 5f66 6964 2073 6f20 6e6f 2066   max_fid so no f
+00002cc0: 6964 2773 2061 7265 0a20 2020 2020 2020  id's are.       
+00002cd0: 2020 2020 2020 2020 2020 2020 2023 2027               # '
+00002ce0: 6c6f 7374 2720 6475 6520 746f 2072 6f75  lost' due to rou
+00002cf0: 6e64 696e 6720 6572 726f 7273 0a20 2020  nding errors.   
+00002d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002d10: 2065 6e64 5f66 6964 203d 206d 6178 5f66   end_fid = max_f
+00002d20: 6964 0a20 2020 2020 2020 2020 2020 2020  id.             
+00002d30: 2020 2062 6174 6368 5f69 6e66 6f5f 6c69     batch_info_li
+00002d40: 7374 2e61 7070 656e 6428 0a20 2020 2020  st.append(.     
+00002d50: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+00002d60: 6261 7463 685f 6964 2c20 6e62 5f72 6f77  batch_id, nb_row
+00002d70: 735f 7065 725f 6261 7463 682c 2073 7461  s_per_batch, sta
+00002d80: 7274 5f66 6964 2c20 656e 645f 6669 6429  rt_fid, end_fid)
+00002d90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002da0: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+00002db0: 2020 206f 6666 7365 7420 2b3d 206f 6666     offset += off
+00002dc0: 7365 745f 7065 725f 6261 7463 680a 2020  set_per_batch.  
+00002dd0: 2020 2020 2020 2020 2020 6261 7463 685f            batch_
+00002de0: 696e 666f 5f64 6620 3d20 7064 2e44 6174  info_df = pd.Dat
+00002df0: 6146 7261 6d65 280a 2020 2020 2020 2020  aFrame(.        
+00002e00: 2020 2020 2020 2020 6261 7463 685f 696e          batch_in
+00002e10: 666f 5f6c 6973 742c 2063 6f6c 756d 6e73  fo_list, columns
+00002e20: 3d5b 2262 6174 6368 5f69 6422 2c20 226e  =["batch_id", "n
+00002e30: 625f 726f 7773 222c 2022 7374 6172 745f  b_rows", "start_
+00002e40: 6669 6422 2c20 2265 6e64 5f66 6964 225d  fid", "end_fid"]
+00002e50: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+00002e60: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00002e70: 2020 2020 2020 2020 2023 2054 6865 2066           # The f
+00002e80: 6964 7320 6172 6520 6e6f 7420 636f 6e73  ids are not cons
+00002e90: 6563 7574 6976 652c 2073 6f20 6465 7465  ecutive, so dete
+00002ea0: 726d 696e 6520 7468 6520 6f70 7469 6d61  rmine the optima
+00002eb0: 6c20 6669 640a 2020 2020 2020 2020 2020  l fid.          
+00002ec0: 2020 2320 7261 6e67 6573 2066 6f72 2065    # ranges for e
+00002ed0: 6163 6820 6261 7463 6820 736f 2065 6163  ach batch so eac
+00002ee0: 6820 6261 7463 6820 6861 7320 7361 6d65  h batch has same
+00002ef0: 206e 756d 6265 7220 6f66 2065 6c65 6d65   number of eleme
+00002f00: 6e74 730a 2020 2020 2020 2020 2020 2020  nts.            
+00002f10: 2320 5265 6d61 726b 3a20 2d20 7468 6973  # Remark: - this
+00002f20: 206d 6967 6874 2074 616b 6520 736f 6d65   might take some
+00002f30: 2073 6563 6f6e 6473 2066 6f72 206c 6172   seconds for lar
+00002f40: 6765 7220 6461 7461 7365 7473 210a 2020  ger datasets!.  
+00002f50: 2020 2020 2020 2020 2020 2320 2020 2020            #     
+00002f60: 2020 2020 2d20 2862 6174 6368 5f69 6420      - (batch_id 
+00002f70: 2d20 3129 2041 5320 6964 2074 6f20 6d61  - 1) AS id to ma
+00002f80: 6b65 2074 6865 2069 6420 7a65 726f 2d62  ke the id zero-b
+00002f90: 6173 6564 0a20 2020 2020 2020 2020 2020  ased.           
+00002fa0: 2073 716c 5f73 746d 7420 3d20 6622 2222   sql_stmt = f"""
+00002fb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002fc0: 2053 454c 4543 5420 2862 6174 6368 5f69   SELECT (batch_i
+00002fd0: 645f 3120 2d20 3129 2041 5320 6261 7463  d_1 - 1) AS batc
+00002fe0: 685f 6964 0a20 2020 2020 2020 2020 2020  h_id.           
+00002ff0: 2020 2020 2020 2020 2020 202c 434f 554e             ,COUN
+00003000: 5428 2a29 2041 5320 6e62 5f72 6f77 730a  T(*) AS nb_rows.
+00003010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003020: 2020 2020 2020 2c4d 494e 287b 6669 645f        ,MIN({fid_
+00003030: 636f 6c75 6d6e 7d29 2041 5320 7374 6172  column}) AS star
+00003040: 745f 6669 640a 2020 2020 2020 2020 2020  t_fid.          
+00003050: 2020 2020 2020 2020 2020 2020 2c4d 4158              ,MAX
+00003060: 287b 6669 645f 636f 6c75 6d6e 7d29 2041  ({fid_column}) A
+00003070: 5320 656e 645f 6669 640a 2020 2020 2020  S end_fid.      
+00003080: 2020 2020 2020 2020 2020 2020 4652 4f4d              FROM
+00003090: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000030a0: 2020 2020 2028 2053 454c 4543 5420 7b66       ( SELECT {f
+000030b0: 6964 5f63 6f6c 756d 6e7d 0a20 2020 2020  id_column}.     
+000030c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000030d0: 2020 2020 2020 202c 4e54 494c 4528 7b6e         ,NTILE({n
+000030e0: 625f 6261 7463 6865 737d 2920 4f56 4552  b_batches}) OVER
+000030f0: 2028 4f52 4445 5220 4259 207b 6669 645f   (ORDER BY {fid_
+00003100: 636f 6c75 6d6e 7d29 2062 6174 6368 5f69  column}) batch_i
+00003110: 645f 310a 2020 2020 2020 2020 2020 2020  d_1.            
+00003120: 2020 2020 2020 2020 2020 2020 4652 4f4d              FROM
+00003130: 2022 7b69 6e70 7574 5f69 6e66 6f2e 6e61   "{input_info.na
+00003140: 6d65 7d22 0a20 2020 2020 2020 2020 2020  me}".           
+00003150: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00003160: 2020 2020 2020 2020 2020 2020 4752 4f55              GROU
+00003170: 5020 4259 2062 6174 6368 5f69 645f 313b  P BY batch_id_1;
+00003180: 0a20 2020 2020 2020 2020 2020 2022 2222  .            """
+00003190: 0a20 2020 2020 2020 2020 2020 2062 6174  .            bat
+000031a0: 6368 5f69 6e66 6f5f 6466 203d 2067 666f  ch_info_df = gfo
+000031b0: 2e72 6561 645f 6669 6c65 2870 6174 683d  .read_file(path=
+000031c0: 696e 7075 745f 7061 7468 2c20 7371 6c5f  input_path, sql_
+000031d0: 7374 6d74 3d73 716c 5f73 746d 7429 0a0a  stmt=sql_stmt)..
+000031e0: 2020 2020 2020 2020 2320 4e6f 7720 6c6f          # Now lo
+000031f0: 6f70 206f 7665 7220 616c 6c20 6261 7463  op over all batc
+00003200: 6820 7261 6e67 6573 2074 6f20 6275 696c  h ranges to buil
+00003210: 6420 7570 2074 6865 206e 6563 6573 7361  d up the necessa
+00003220: 7279 2066 696c 7465 7273 0a20 2020 2020  ry filters.     
+00003230: 2020 2066 6f72 2062 6174 6368 5f69 6e66     for batch_inf
+00003240: 6f20 696e 2062 6174 6368 5f69 6e66 6f5f  o in batch_info_
+00003250: 6466 2e69 7465 7274 7570 6c65 7328 293a  df.itertuples():
+00003260: 0a20 2020 2020 2020 2020 2020 2023 2054  .            # T
+00003270: 6865 2062 6174 6368 2066 696c 7465 720a  he batch filter.
+00003280: 2020 2020 2020 2020 2020 2020 6966 2062              if b
+00003290: 6174 6368 5f69 6e66 6f2e 6261 7463 685f  atch_info.batch_
+000032a0: 6964 203c 206e 625f 6261 7463 6865 7320  id < nb_batches 
+000032b0: 2d20 313a 0a20 2020 2020 2020 2020 2020  - 1:.           
+000032c0: 2020 2020 2062 6174 6368 6573 2e61 7070       batches.app
+000032d0: 656e 6428 0a20 2020 2020 2020 2020 2020  end(.           
+000032e0: 2020 2020 2020 2020 2066 2228 7b66 6964           f"({fid
+000032f0: 5f63 6f6c 756d 6e7d 203e 3d20 7b62 6174  _column} >= {bat
+00003300: 6368 5f69 6e66 6f2e 7374 6172 745f 6669  ch_info.start_fi
+00003310: 647d 2022 0a20 2020 2020 2020 2020 2020  d} ".           
+00003320: 2020 2020 2020 2020 2066 2241 4e44 207b           f"AND {
+00003330: 6669 645f 636f 6c75 6d6e 7d20 3c3d 207b  fid_column} <= {
+00003340: 6261 7463 685f 696e 666f 2e65 6e64 5f66  batch_info.end_f
+00003350: 6964 7d29 2022 0a20 2020 2020 2020 2020  id}) ".         
+00003360: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00003370: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00003380: 2020 2020 2020 2020 2020 2062 6174 6368             batch
+00003390: 6573 2e61 7070 656e 6428 6622 7b66 6964  es.append(f"{fid
+000033a0: 5f63 6f6c 756d 6e7d 203e 3d20 7b62 6174  _column} >= {bat
+000033b0: 6368 5f69 6e66 6f2e 7374 6172 745f 6669  ch_info.start_fi
+000033c0: 647d 2022 290a 0a20 2020 2023 204e 6f20  d} ")..    # No 
+000033d0: 7573 6520 7374 6172 7469 6e67 206d 6f72  use starting mor
+000033e0: 6520 7072 6f63 6573 7365 7320 7468 616e  e processes than
+000033f0: 2074 6865 206e 756d 6265 7220 6f66 2062   the number of b
+00003400: 6174 6368 6573 2e2e 2e0a 2020 2020 6966  atches....    if
+00003410: 206c 656e 2862 6174 6368 6573 2920 3c20   len(batches) < 
+00003420: 6e62 5f70 6172 616c 6c65 6c3a 0a20 2020  nb_parallel:.   
+00003430: 2020 2020 206e 625f 7061 7261 6c6c 656c       nb_parallel
+00003440: 203d 206c 656e 2862 6174 6368 6573 290a   = len(batches).
+00003450: 0a20 2020 2072 6574 7572 6e76 616c 7565  .    returnvalue
+00003460: 203d 2050 726f 6365 7373 696e 6750 6172   = ProcessingPar
+00003470: 616d 7328 0a20 2020 2020 2020 206e 625f  ams(.        nb_
+00003480: 726f 7773 5f74 6f5f 7072 6f63 6573 733d  rows_to_process=
+00003490: 696e 7075 745f 696e 666f 2e66 6561 7475  input_info.featu
+000034a0: 7265 636f 756e 742c 0a20 2020 2020 2020  recount,.       
+000034b0: 206e 625f 7061 7261 6c6c 656c 3d6e 625f   nb_parallel=nb_
+000034c0: 7061 7261 6c6c 656c 2c0a 2020 2020 2020  parallel,.      
+000034d0: 2020 6261 7463 6865 733d 6261 7463 6865    batches=batche
+000034e0: 732c 0a20 2020 2020 2020 2062 6174 6368  s,.        batch
+000034f0: 7369 7a65 3d69 6e74 2869 6e70 7574 5f69  size=int(input_i
+00003500: 6e66 6f2e 6665 6174 7572 6563 6f75 6e74  nfo.featurecount
+00003510: 202f 206c 656e 2862 6174 6368 6573 2929   / len(batches))
+00003520: 2c0a 2020 2020 290a 0a20 2020 2069 6620  ,.    )..    if 
+00003530: 746d 705f 6469 7220 6973 206e 6f74 204e  tmp_dir is not N
+00003540: 6f6e 653a 0a20 2020 2020 2020 2072 6574  one:.        ret
+00003550: 7572 6e76 616c 7565 2e74 6f5f 6a73 6f6e  urnvalue.to_json
+00003560: 2874 6d70 5f64 6972 202f 2022 7072 6f63  (tmp_dir / "proc
+00003570: 6573 7369 6e67 5f70 6172 616d 732e 6a73  essing_params.js
+00003580: 6f6e 2229 0a20 2020 2072 6574 7572 6e20  on").    return 
+00003590: 7265 7475 726e 7661 6c75 650a 0a0a 636c  returnvalue...cl
+000035a0: 6173 7320 4765 6f4f 7065 7261 7469 6f6e  ass GeoOperation
+000035b0: 2865 6e75 6d2e 456e 756d 293a 0a20 2020  (enum.Enum):.   
+000035c0: 2053 494d 504c 4946 5920 3d20 2273 696d   SIMPLIFY = "sim
+000035d0: 706c 6966 7922 0a20 2020 2042 5546 4645  plify".    BUFFE
+000035e0: 5220 3d20 2262 7566 6665 7222 0a20 2020  R = "buffer".   
+000035f0: 2043 4f4e 5645 5848 554c 4c20 3d20 2263   CONVEXHULL = "c
+00003600: 6f6e 7665 7868 756c 6c22 0a20 2020 2041  onvexhull".    A
+00003610: 5050 4c59 203d 2022 6170 706c 7922 0a0a  PPLY = "apply"..
+00003620: 0a64 6566 2061 7070 6c79 280a 2020 2020  .def apply(.    
+00003630: 696e 7075 745f 7061 7468 3a20 5061 7468  input_path: Path
+00003640: 2c0a 2020 2020 6f75 7470 7574 5f70 6174  ,.    output_pat
+00003650: 683a 2050 6174 682c 0a20 2020 2066 756e  h: Path,.    fun
+00003660: 633a 2043 616c 6c61 626c 655b 5b41 6e79  c: Callable[[Any
+00003670: 5d2c 2041 6e79 5d2c 0a20 2020 206f 7065  ], Any],.    ope
+00003680: 7261 7469 6f6e 5f6e 616d 653a 204f 7074  ration_name: Opt
+00003690: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
+000036a0: 652c 0a20 2020 206f 6e6c 795f 6765 6f6d  e,.    only_geom
+000036b0: 5f69 6e70 7574 3a20 626f 6f6c 203d 2054  _input: bool = T
+000036c0: 7275 652c 0a20 2020 2069 6e70 7574 5f6c  rue,.    input_l
+000036d0: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
+000036e0: 7472 5d20 3d20 4e6f 6e65 2c0a 2020 2020  tr] = None,.    
+000036f0: 6f75 7470 7574 5f6c 6179 6572 3a20 4f70  output_layer: Op
+00003700: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
+00003710: 6e65 2c0a 2020 2020 636f 6c75 6d6e 733a  ne,.    columns:
+00003720: 204f 7074 696f 6e61 6c5b 4c69 7374 5b73   Optional[List[s
+00003730: 7472 5d5d 203d 204e 6f6e 652c 0a20 2020  tr]] = None,.   
+00003740: 2065 7870 6c6f 6465 636f 6c6c 6563 7469   explodecollecti
+00003750: 6f6e 733a 2062 6f6f 6c20 3d20 4661 6c73  ons: bool = Fals
+00003760: 652c 0a20 2020 2066 6f72 6365 5f6f 7574  e,.    force_out
+00003770: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
+00003780: 3a20 556e 696f 6e5b 4765 6f6d 6574 7279  : Union[Geometry
+00003790: 5479 7065 2c20 7374 722c 204e 6f6e 655d  Type, str, None]
+000037a0: 203d 204e 6f6e 652c 0a20 2020 2067 7269   = None,.    gri
+000037b0: 6473 697a 653a 2066 6c6f 6174 203d 2030  dsize: float = 0
+000037c0: 2e30 2c0a 2020 2020 6b65 6570 5f65 6d70  .0,.    keep_emp
+000037d0: 7479 5f67 656f 6d73 3a20 626f 6f6c 203d  ty_geoms: bool =
+000037e0: 2054 7275 652c 0a20 2020 2077 6865 7265   True,.    where
+000037f0: 5f70 6f73 743a 204f 7074 696f 6e61 6c5b  _post: Optional[
+00003800: 7374 725d 203d 204e 6f6e 652c 0a20 2020  str] = None,.   
+00003810: 206e 625f 7061 7261 6c6c 656c 3a20 696e   nb_parallel: in
+00003820: 7420 3d20 2d31 2c0a 2020 2020 6261 7463  t = -1,.    batc
+00003830: 6873 697a 653a 2069 6e74 203d 202d 312c  hsize: int = -1,
+00003840: 0a20 2020 2066 6f72 6365 3a20 626f 6f6c  .    force: bool
+00003850: 203d 2046 616c 7365 2c0a 2020 2020 7061   = False,.    pa
+00003860: 7261 6c6c 656c 697a 6174 696f 6e5f 636f  rallelization_co
+00003870: 6e66 6967 3a20 5061 7261 6c6c 656c 697a  nfig: Paralleliz
+00003880: 6174 696f 6e43 6f6e 6669 6720 3d20 4e6f  ationConfig = No
+00003890: 6e65 2c0a 293a 0a20 2020 2023 2049 6e69  ne,.):.    # Ini
+000038a0: 740a 2020 2020 6f70 6572 6174 696f 6e5f  t.    operation_
+000038b0: 7061 7261 6d73 203d 207b 0a20 2020 2020  params = {.     
+000038c0: 2020 2022 6f6e 6c79 5f67 656f 6d5f 696e     "only_geom_in
+000038d0: 7075 7422 3a20 6f6e 6c79 5f67 656f 6d5f  put": only_geom_
+000038e0: 696e 7075 742c 0a20 2020 2020 2020 2022  input,.        "
+000038f0: 7069 636b 6c65 645f 6675 6e63 223a 2063  pickled_func": c
+00003900: 6c6f 7564 7069 636b 6c65 2e64 756d 7073  loudpickle.dumps
+00003910: 2866 756e 6329 2c0a 2020 2020 7d0a 2020  (func),.    }.  
+00003920: 2020 6966 206f 7065 7261 7469 6f6e 5f6e    if operation_n
+00003930: 616d 6520 6973 206e 6f74 204e 6f6e 653a  ame is not None:
+00003940: 0a20 2020 2020 2020 206f 7065 7261 7469  .        operati
+00003950: 6f6e 5f70 6172 616d 735b 226f 7065 7261  on_params["opera
+00003960: 7469 6f6e 5f6e 616d 6522 5d20 3d20 6f70  tion_name"] = op
+00003970: 6572 6174 696f 6e5f 6e61 6d65 0a0a 2020  eration_name..  
+00003980: 2020 2320 476f 210a 2020 2020 7265 7475    # Go!.    retu
+00003990: 726e 205f 6170 706c 795f 6765 6f6f 7065  rn _apply_geoope
+000039a0: 7261 7469 6f6e 5f74 6f5f 6c61 7965 7228  ration_to_layer(
+000039b0: 0a20 2020 2020 2020 2069 6e70 7574 5f70  .        input_p
+000039c0: 6174 683d 696e 7075 745f 7061 7468 2c0a  ath=input_path,.
+000039d0: 2020 2020 2020 2020 6f75 7470 7574 5f70          output_p
+000039e0: 6174 683d 6f75 7470 7574 5f70 6174 682c  ath=output_path,
+000039f0: 0a20 2020 2020 2020 206f 7065 7261 7469  .        operati
+00003a00: 6f6e 3d47 656f 4f70 6572 6174 696f 6e2e  on=GeoOperation.
+00003a10: 4150 504c 592c 0a20 2020 2020 2020 206f  APPLY,.        o
+00003a20: 7065 7261 7469 6f6e 5f70 6172 616d 733d  peration_params=
+00003a30: 6f70 6572 6174 696f 6e5f 7061 7261 6d73  operation_params
+00003a40: 2c0a 2020 2020 2020 2020 696e 7075 745f  ,.        input_
+00003a50: 6c61 7965 723d 696e 7075 745f 6c61 7965  layer=input_laye
+00003a60: 722c 0a20 2020 2020 2020 206f 7574 7075  r,.        outpu
+00003a70: 745f 6c61 7965 723d 6f75 7470 7574 5f6c  t_layer=output_l
+00003a80: 6179 6572 2c0a 2020 2020 2020 2020 636f  ayer,.        co
+00003a90: 6c75 6d6e 733d 636f 6c75 6d6e 732c 0a20  lumns=columns,. 
+00003aa0: 2020 2020 2020 2065 7870 6c6f 6465 636f         explodeco
+00003ab0: 6c6c 6563 7469 6f6e 733d 6578 706c 6f64  llections=explod
+00003ac0: 6563 6f6c 6c65 6374 696f 6e73 2c0a 2020  ecollections,.  
+00003ad0: 2020 2020 2020 666f 7263 655f 6f75 7470        force_outp
+00003ae0: 7574 5f67 656f 6d65 7472 7974 7970 653d  ut_geometrytype=
+00003af0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
+00003b00: 6d65 7472 7974 7970 652c 0a20 2020 2020  metrytype,.     
+00003b10: 2020 2067 7269 6473 697a 653d 6772 6964     gridsize=grid
+00003b20: 7369 7a65 2c0a 2020 2020 2020 2020 6b65  size,.        ke
+00003b30: 6570 5f65 6d70 7479 5f67 656f 6d73 3d6b  ep_empty_geoms=k
+00003b40: 6565 705f 656d 7074 795f 6765 6f6d 732c  eep_empty_geoms,
+00003b50: 0a20 2020 2020 2020 2077 6865 7265 5f70  .        where_p
+00003b60: 6f73 743d 7768 6572 655f 706f 7374 2c0a  ost=where_post,.
+00003b70: 2020 2020 2020 2020 6e62 5f70 6172 616c          nb_paral
+00003b80: 6c65 6c3d 6e62 5f70 6172 616c 6c65 6c2c  lel=nb_parallel,
+00003b90: 0a20 2020 2020 2020 2062 6174 6368 7369  .        batchsi
+00003ba0: 7a65 3d62 6174 6368 7369 7a65 2c0a 2020  ze=batchsize,.  
+00003bb0: 2020 2020 2020 666f 7263 653d 666f 7263        force=forc
+00003bc0: 652c 0a20 2020 2020 2020 2070 6172 616c  e,.        paral
+00003bd0: 6c65 6c69 7a61 7469 6f6e 5f63 6f6e 6669  lelization_confi
+00003be0: 673d 7061 7261 6c6c 656c 697a 6174 696f  g=parallelizatio
+00003bf0: 6e5f 636f 6e66 6967 2c0a 2020 2020 290a  n_config,.    ).
+00003c00: 0a0a 6465 6620 6275 6666 6572 280a 2020  ..def buffer(.  
+00003c10: 2020 696e 7075 745f 7061 7468 3a20 5061    input_path: Pa
+00003c20: 7468 2c0a 2020 2020 6f75 7470 7574 5f70  th,.    output_p
+00003c30: 6174 683a 2050 6174 682c 0a20 2020 2064  ath: Path,.    d
+00003c40: 6973 7461 6e63 653a 2066 6c6f 6174 2c0a  istance: float,.
+00003c50: 2020 2020 7175 6164 7261 6e74 7365 676d      quadrantsegm
+00003c60: 656e 7473 3a20 696e 7420 3d20 352c 0a20  ents: int = 5,. 
+00003c70: 2020 2065 6e64 6361 705f 7374 796c 653a     endcap_style:
+00003c80: 2042 7566 6665 7245 6e64 4361 7053 7479   BufferEndCapSty
+00003c90: 6c65 203d 2042 7566 6665 7245 6e64 4361  le = BufferEndCa
+00003ca0: 7053 7479 6c65 2e52 4f55 4e44 2c0a 2020  pStyle.ROUND,.  
+00003cb0: 2020 6a6f 696e 5f73 7479 6c65 3a20 4275    join_style: Bu
+00003cc0: 6666 6572 4a6f 696e 5374 796c 6520 3d20  fferJoinStyle = 
+00003cd0: 4275 6666 6572 4a6f 696e 5374 796c 652e  BufferJoinStyle.
+00003ce0: 524f 554e 442c 0a20 2020 206d 6974 7265  ROUND,.    mitre
+00003cf0: 5f6c 696d 6974 3a20 666c 6f61 7420 3d20  _limit: float = 
+00003d00: 352e 302c 0a20 2020 2073 696e 676c 655f  5.0,.    single_
+00003d10: 7369 6465 643a 2062 6f6f 6c20 3d20 4661  sided: bool = Fa
+00003d20: 6c73 652c 0a20 2020 2069 6e70 7574 5f6c  lse,.    input_l
+00003d30: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
+00003d40: 7472 5d20 3d20 4e6f 6e65 2c0a 2020 2020  tr] = None,.    
+00003d50: 6f75 7470 7574 5f6c 6179 6572 3a20 4f70  output_layer: Op
+00003d60: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
+00003d70: 6e65 2c0a 2020 2020 636f 6c75 6d6e 733a  ne,.    columns:
+00003d80: 204f 7074 696f 6e61 6c5b 4c69 7374 5b73   Optional[List[s
+00003d90: 7472 5d5d 203d 204e 6f6e 652c 0a20 2020  tr]] = None,.   
+00003da0: 2065 7870 6c6f 6465 636f 6c6c 6563 7469   explodecollecti
+00003db0: 6f6e 733a 2062 6f6f 6c20 3d20 4661 6c73  ons: bool = Fals
+00003dc0: 652c 0a20 2020 2067 7269 6473 697a 653a  e,.    gridsize:
+00003dd0: 2066 6c6f 6174 203d 2030 2e30 2c0a 2020   float = 0.0,.  
+00003de0: 2020 6b65 6570 5f65 6d70 7479 5f67 656f    keep_empty_geo
+00003df0: 6d73 3a20 626f 6f6c 203d 2054 7275 652c  ms: bool = True,
+00003e00: 0a20 2020 2077 6865 7265 5f70 6f73 743a  .    where_post:
+00003e10: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
+00003e20: 204e 6f6e 652c 0a20 2020 206e 625f 7061   None,.    nb_pa
+00003e30: 7261 6c6c 656c 3a20 696e 7420 3d20 2d31  rallel: int = -1
+00003e40: 2c0a 2020 2020 6261 7463 6873 697a 653a  ,.    batchsize:
+00003e50: 2069 6e74 203d 202d 312c 0a20 2020 2066   int = -1,.    f
+00003e60: 6f72 6365 3a20 626f 6f6c 203d 2046 616c  orce: bool = Fal
+00003e70: 7365 2c0a 2020 2020 6f70 6572 6174 696f  se,.    operatio
+00003e80: 6e5f 7072 6566 6978 3a20 7374 7220 3d20  n_prefix: str = 
+00003e90: 2222 2c0a 293a 0a20 2020 2023 2049 6e69  "",.):.    # Ini
+00003ea0: 740a 2020 2020 6f70 6572 6174 696f 6e5f  t.    operation_
+00003eb0: 7061 7261 6d73 203d 207b 0a20 2020 2020  params = {.     
+00003ec0: 2020 2022 6f70 6572 6174 696f 6e5f 6e61     "operation_na
+00003ed0: 6d65 223a 2066 227b 6f70 6572 6174 696f  me": f"{operatio
+00003ee0: 6e5f 7072 6566 6978 7d62 7566 6665 7222  n_prefix}buffer"
+00003ef0: 2c0a 2020 2020 2020 2020 2264 6973 7461  ,.        "dista
+00003f00: 6e63 6522 3a20 6469 7374 616e 6365 2c0a  nce": distance,.
+00003f10: 2020 2020 2020 2020 2271 7561 6472 616e          "quadran
+00003f20: 7473 6567 6d65 6e74 7322 3a20 7175 6164  tsegments": quad
+00003f30: 7261 6e74 7365 676d 656e 7473 2c0a 2020  rantsegments,.  
+00003f40: 2020 2020 2020 2265 6e64 6361 705f 7374        "endcap_st
+00003f50: 796c 6522 3a20 656e 6463 6170 5f73 7479  yle": endcap_sty
+00003f60: 6c65 2c0a 2020 2020 2020 2020 226a 6f69  le,.        "joi
+00003f70: 6e5f 7374 796c 6522 3a20 6a6f 696e 5f73  n_style": join_s
+00003f80: 7479 6c65 2c0a 2020 2020 2020 2020 226d  tyle,.        "m
+00003f90: 6974 7265 5f6c 696d 6974 223a 206d 6974  itre_limit": mit
+00003fa0: 7265 5f6c 696d 6974 2c0a 2020 2020 2020  re_limit,.      
+00003fb0: 2020 2273 696e 676c 655f 7369 6465 6422    "single_sided"
+00003fc0: 3a20 7369 6e67 6c65 5f73 6964 6564 2c0a  : single_sided,.
+00003fd0: 2020 2020 7d0a 0a20 2020 2023 2042 7566      }..    # Buf
+00003fe0: 6665 7220 6f70 6572 6174 696f 6e20 616c  fer operation al
+00003ff0: 7761 7973 2072 6573 756c 7473 2069 6e20  ways results in 
+00004000: 706f 6c79 676f 6e73 2e2e 2e0a 2020 2020  polygons....    
+00004010: 6966 2065 7870 6c6f 6465 636f 6c6c 6563  if explodecollec
+00004020: 7469 6f6e 733a 0a20 2020 2020 2020 2066  tions:.        f
+00004030: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+00004040: 6574 7279 7479 7065 203d 2047 656f 6d65  etrytype = Geome
+00004050: 7472 7954 7970 652e 504f 4c59 474f 4e2e  tryType.POLYGON.
+00004060: 6e61 6d65 0a20 2020 2065 6c73 653a 0a20  name.    else:. 
+00004070: 2020 2020 2020 2066 6f72 6365 5f6f 7574         force_out
+00004080: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
+00004090: 203d 2047 656f 6d65 7472 7954 7970 652e   = GeometryType.
+000040a0: 4d55 4c54 4950 4f4c 5947 4f4e 2e6e 616d  MULTIPOLYGON.nam
+000040b0: 650a 0a20 2020 2023 2047 6f21 0a20 2020  e..    # Go!.   
+000040c0: 2072 6574 7572 6e20 5f61 7070 6c79 5f67   return _apply_g
+000040d0: 656f 6f70 6572 6174 696f 6e5f 746f 5f6c  eooperation_to_l
+000040e0: 6179 6572 280a 2020 2020 2020 2020 696e  ayer(.        in
+000040f0: 7075 745f 7061 7468 3d69 6e70 7574 5f70  put_path=input_p
+00004100: 6174 682c 0a20 2020 2020 2020 206f 7574  ath,.        out
+00004110: 7075 745f 7061 7468 3d6f 7574 7075 745f  put_path=output_
+00004120: 7061 7468 2c0a 2020 2020 2020 2020 6f70  path,.        op
+00004130: 6572 6174 696f 6e3d 4765 6f4f 7065 7261  eration=GeoOpera
+00004140: 7469 6f6e 2e42 5546 4645 522c 0a20 2020  tion.BUFFER,.   
+00004150: 2020 2020 206f 7065 7261 7469 6f6e 5f70       operation_p
+00004160: 6172 616d 733d 6f70 6572 6174 696f 6e5f  arams=operation_
+00004170: 7061 7261 6d73 2c0a 2020 2020 2020 2020  params,.        
+00004180: 696e 7075 745f 6c61 7965 723d 696e 7075  input_layer=inpu
+00004190: 745f 6c61 7965 722c 0a20 2020 2020 2020  t_layer,.       
+000041a0: 206f 7574 7075 745f 6c61 7965 723d 6f75   output_layer=ou
+000041b0: 7470 7574 5f6c 6179 6572 2c0a 2020 2020  tput_layer,.    
+000041c0: 2020 2020 636f 6c75 6d6e 733d 636f 6c75      columns=colu
+000041d0: 6d6e 732c 0a20 2020 2020 2020 2065 7870  mns,.        exp
+000041e0: 6c6f 6465 636f 6c6c 6563 7469 6f6e 733d  lodecollections=
+000041f0: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
+00004200: 6e73 2c0a 2020 2020 2020 2020 666f 7263  ns,.        forc
+00004210: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+00004220: 7974 7970 653d 666f 7263 655f 6f75 7470  ytype=force_outp
+00004230: 7574 5f67 656f 6d65 7472 7974 7970 652c  ut_geometrytype,
+00004240: 0a20 2020 2020 2020 2067 7269 6473 697a  .        gridsiz
+00004250: 653d 6772 6964 7369 7a65 2c0a 2020 2020  e=gridsize,.    
+00004260: 2020 2020 6b65 6570 5f65 6d70 7479 5f67      keep_empty_g
+00004270: 656f 6d73 3d6b 6565 705f 656d 7074 795f  eoms=keep_empty_
+00004280: 6765 6f6d 732c 0a20 2020 2020 2020 2077  geoms,.        w
+00004290: 6865 7265 5f70 6f73 743d 7768 6572 655f  here_post=where_
+000042a0: 706f 7374 2c0a 2020 2020 2020 2020 6e62  post,.        nb
+000042b0: 5f70 6172 616c 6c65 6c3d 6e62 5f70 6172  _parallel=nb_par
+000042c0: 616c 6c65 6c2c 0a20 2020 2020 2020 2062  allel,.        b
+000042d0: 6174 6368 7369 7a65 3d62 6174 6368 7369  atchsize=batchsi
+000042e0: 7a65 2c0a 2020 2020 2020 2020 666f 7263  ze,.        forc
+000042f0: 653d 666f 7263 652c 0a20 2020 2029 0a0a  e=force,.    )..
+00004300: 0a64 6566 2063 6f6e 7665 7868 756c 6c28  .def convexhull(
+00004310: 0a20 2020 2069 6e70 7574 5f70 6174 683a  .    input_path:
+00004320: 2050 6174 682c 0a20 2020 206f 7574 7075   Path,.    outpu
+00004330: 745f 7061 7468 3a20 5061 7468 2c0a 2020  t_path: Path,.  
+00004340: 2020 696e 7075 745f 6c61 7965 723a 204f    input_layer: O
+00004350: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
+00004360: 6f6e 652c 0a20 2020 206f 7574 7075 745f  one,.    output_
+00004370: 6c61 7965 723a 204f 7074 696f 6e61 6c5b  layer: Optional[
+00004380: 7374 725d 203d 204e 6f6e 652c 0a20 2020  str] = None,.   
+00004390: 2063 6f6c 756d 6e73 3a20 4f70 7469 6f6e   columns: Option
+000043a0: 616c 5b4c 6973 745b 7374 725d 5d20 3d20  al[List[str]] = 
+000043b0: 4e6f 6e65 2c0a 2020 2020 6578 706c 6f64  None,.    explod
+000043c0: 6563 6f6c 6c65 6374 696f 6e73 3a20 626f  ecollections: bo
+000043d0: 6f6c 203d 2046 616c 7365 2c0a 2020 2020  ol = False,.    
+000043e0: 6772 6964 7369 7a65 3a20 666c 6f61 7420  gridsize: float 
+000043f0: 3d20 302e 302c 0a20 2020 206b 6565 705f  = 0.0,.    keep_
+00004400: 656d 7074 795f 6765 6f6d 733a 2062 6f6f  empty_geoms: boo
+00004410: 6c20 3d20 5472 7565 2c0a 2020 2020 7768  l = True,.    wh
+00004420: 6572 655f 706f 7374 3a20 4f70 7469 6f6e  ere_post: Option
+00004430: 616c 5b73 7472 5d20 3d20 4e6f 6e65 2c0a  al[str] = None,.
+00004440: 2020 2020 6e62 5f70 6172 616c 6c65 6c3a      nb_parallel:
+00004450: 2069 6e74 203d 202d 312c 0a20 2020 2062   int = -1,.    b
+00004460: 6174 6368 7369 7a65 3a20 696e 7420 3d20  atchsize: int = 
+00004470: 2d31 2c0a 2020 2020 666f 7263 653a 2062  -1,.    force: b
+00004480: 6f6f 6c20 3d20 4661 6c73 652c 0a29 3a0a  ool = False,.):.
+00004490: 2020 2020 2320 496e 6974 0a20 2020 206f      # Init.    o
+000044a0: 7065 7261 7469 6f6e 5f70 6172 616d 733a  peration_params:
+000044b0: 2044 6963 745b 7374 722c 2041 6e79 5d20   Dict[str, Any] 
+000044c0: 3d20 7b7d 0a0a 2020 2020 2320 476f 210a  = {}..    # Go!.
+000044d0: 2020 2020 7265 7475 726e 205f 6170 706c      return _appl
+000044e0: 795f 6765 6f6f 7065 7261 7469 6f6e 5f74  y_geooperation_t
+000044f0: 6f5f 6c61 7965 7228 0a20 2020 2020 2020  o_layer(.       
+00004500: 2069 6e70 7574 5f70 6174 683d 696e 7075   input_path=inpu
+00004510: 745f 7061 7468 2c0a 2020 2020 2020 2020  t_path,.        
+00004520: 6f75 7470 7574 5f70 6174 683d 6f75 7470  output_path=outp
+00004530: 7574 5f70 6174 682c 0a20 2020 2020 2020  ut_path,.       
+00004540: 206f 7065 7261 7469 6f6e 3d47 656f 4f70   operation=GeoOp
+00004550: 6572 6174 696f 6e2e 434f 4e56 4558 4855  eration.CONVEXHU
+00004560: 4c4c 2c0a 2020 2020 2020 2020 6f70 6572  LL,.        oper
+00004570: 6174 696f 6e5f 7061 7261 6d73 3d6f 7065  ation_params=ope
+00004580: 7261 7469 6f6e 5f70 6172 616d 732c 0a20  ration_params,. 
+00004590: 2020 2020 2020 2069 6e70 7574 5f6c 6179         input_lay
+000045a0: 6572 3d69 6e70 7574 5f6c 6179 6572 2c0a  er=input_layer,.
+000045b0: 2020 2020 2020 2020 6f75 7470 7574 5f6c          output_l
+000045c0: 6179 6572 3d6f 7574 7075 745f 6c61 7965  ayer=output_laye
+000045d0: 722c 0a20 2020 2020 2020 2063 6f6c 756d  r,.        colum
+000045e0: 6e73 3d63 6f6c 756d 6e73 2c0a 2020 2020  ns=columns,.    
+000045f0: 2020 2020 6578 706c 6f64 6563 6f6c 6c65      explodecolle
+00004600: 6374 696f 6e73 3d65 7870 6c6f 6465 636f  ctions=explodeco
+00004610: 6c6c 6563 7469 6f6e 732c 0a20 2020 2020  llections,.     
+00004620: 2020 2066 6f72 6365 5f6f 7574 7075 745f     force_output_
+00004630: 6765 6f6d 6574 7279 7479 7065 3d4e 6f6e  geometrytype=Non
+00004640: 652c 0a20 2020 2020 2020 2067 7269 6473  e,.        grids
+00004650: 697a 653d 6772 6964 7369 7a65 2c0a 2020  ize=gridsize,.  
+00004660: 2020 2020 2020 6b65 6570 5f65 6d70 7479        keep_empty
+00004670: 5f67 656f 6d73 3d6b 6565 705f 656d 7074  _geoms=keep_empt
+00004680: 795f 6765 6f6d 732c 0a20 2020 2020 2020  y_geoms,.       
+00004690: 2077 6865 7265 5f70 6f73 743d 7768 6572   where_post=wher
+000046a0: 655f 706f 7374 2c0a 2020 2020 2020 2020  e_post,.        
+000046b0: 6e62 5f70 6172 616c 6c65 6c3d 6e62 5f70  nb_parallel=nb_p
+000046c0: 6172 616c 6c65 6c2c 0a20 2020 2020 2020  arallel,.       
+000046d0: 2062 6174 6368 7369 7a65 3d62 6174 6368   batchsize=batch
+000046e0: 7369 7a65 2c0a 2020 2020 2020 2020 666f  size,.        fo
+000046f0: 7263 653d 666f 7263 652c 0a20 2020 2029  rce=force,.    )
+00004700: 0a0a 0a64 6566 206d 616b 6576 616c 6964  ...def makevalid
+00004710: 280a 2020 2020 696e 7075 745f 7061 7468  (.    input_path
+00004720: 3a20 5061 7468 2c0a 2020 2020 6f75 7470  : Path,.    outp
+00004730: 7574 5f70 6174 683a 2050 6174 682c 0a20  ut_path: Path,. 
+00004740: 2020 2069 6e70 7574 5f6c 6179 6572 3a20     input_layer: 
+00004750: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
+00004760: 4e6f 6e65 2c0a 2020 2020 6f75 7470 7574  None,.    output
+00004770: 5f6c 6179 6572 3a20 4f70 7469 6f6e 616c  _layer: Optional
+00004780: 5b73 7472 5d20 3d20 4e6f 6e65 2c0a 2020  [str] = None,.  
+00004790: 2020 636f 6c75 6d6e 733a 204f 7074 696f    columns: Optio
+000047a0: 6e61 6c5b 4c69 7374 5b73 7472 5d5d 203d  nal[List[str]] =
+000047b0: 204e 6f6e 652c 0a20 2020 2065 7870 6c6f   None,.    explo
+000047c0: 6465 636f 6c6c 6563 7469 6f6e 733a 2062  decollections: b
+000047d0: 6f6f 6c20 3d20 4661 6c73 652c 0a20 2020  ool = False,.   
+000047e0: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
+000047f0: 6f6d 6574 7279 7479 7065 3a20 4f70 7469  ometrytype: Opti
+00004800: 6f6e 616c 5b47 656f 6d65 7472 7954 7970  onal[GeometryTyp
+00004810: 655d 203d 204e 6f6e 652c 0a20 2020 2067  e] = None,.    g
+00004820: 7269 6473 697a 653a 2066 6c6f 6174 203d  ridsize: float =
+00004830: 2030 2e30 2c0a 2020 2020 6b65 6570 5f65   0.0,.    keep_e
+00004840: 6d70 7479 5f67 656f 6d73 3a20 626f 6f6c  mpty_geoms: bool
+00004850: 203d 2054 7275 652c 0a20 2020 2077 6865   = True,.    whe
+00004860: 7265 5f70 6f73 743a 204f 7074 696f 6e61  re_post: Optiona
+00004870: 6c5b 7374 725d 203d 204e 6f6e 652c 0a20  l[str] = None,. 
+00004880: 2020 2076 616c 6964 6174 655f 6174 7472     validate_attr
+00004890: 6962 7574 655f 6461 7461 3a20 626f 6f6c  ibute_data: bool
+000048a0: 203d 2046 616c 7365 2c0a 2020 2020 6e62   = False,.    nb
+000048b0: 5f70 6172 616c 6c65 6c3a 2069 6e74 203d  _parallel: int =
+000048c0: 202d 312c 0a20 2020 2062 6174 6368 7369   -1,.    batchsi
+000048d0: 7a65 3a20 696e 7420 3d20 2d31 2c0a 2020  ze: int = -1,.  
+000048e0: 2020 666f 7263 653a 2062 6f6f 6c20 3d20    force: bool = 
+000048f0: 4661 6c73 652c 0a29 3a0a 2020 2020 2320  False,.):.    # 
+00004900: 4465 7465 726d 696e 6520 6966 2063 6f6c  Determine if col
+00004910: 6c61 7073 6564 2070 6172 7473 206e 6565  lapsed parts nee
+00004920: 6420 746f 2062 6520 6b65 7074 2061 6674  d to be kept aft
+00004930: 6572 206d 616b 6576 616c 6964 206f 7220  er makevalid or 
+00004940: 6e6f 740a 2020 2020 6b65 6570 5f63 6f6c  not.    keep_col
+00004950: 6c61 7073 6564 203d 2054 7275 650a 2020  lapsed = True.  
+00004960: 2020 6966 2066 6f72 6365 5f6f 7574 7075    if force_outpu
+00004970: 745f 6765 6f6d 6574 7279 7479 7065 2069  t_geometrytype i
+00004980: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+00004990: 6b65 6570 5f63 6f6c 6c61 7073 6564 203d  keep_collapsed =
+000049a0: 2046 616c 7365 0a20 2020 2065 6c73 653a   False.    else:
+000049b0: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
+000049c0: 7374 616e 6365 2866 6f72 6365 5f6f 7574  stance(force_out
+000049d0: 7075 745f 6765 6f6d 6574 7279 7479 7065  put_geometrytype
+000049e0: 2c20 4765 6f6d 6574 7279 5479 7065 293a  , GeometryType):
+000049f0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+00004a00: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
+00004a10: 7279 7479 7065 203d 2066 6f72 6365 5f6f  rytype = force_o
+00004a20: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
+00004a30: 7065 2e6e 616d 650a 2020 2020 2020 2020  pe.name.        
+00004a40: 696e 666f 203d 2066 696c 656f 7073 2e67  info = fileops.g
+00004a50: 6574 5f6c 6179 6572 696e 666f 2869 6e70  et_layerinfo(inp
+00004a60: 7574 5f70 6174 6829 0a20 2020 2020 2020  ut_path).       
+00004a70: 2069 6620 666f 7263 655f 6f75 7470 7574   if force_output
+00004a80: 5f67 656f 6d65 7472 7974 7970 652e 7374  _geometrytype.st
+00004a90: 6172 7473 7769 7468 280a 2020 2020 2020  artswith(.      
+00004aa0: 2020 2020 2020 696e 666f 2e67 656f 6d65        info.geome
+00004ab0: 7472 7974 7970 656e 616d 650a 2020 2020  trytypename.    
+00004ac0: 2020 2020 2920 6f72 2069 6e66 6f2e 6765      ) or info.ge
+00004ad0: 6f6d 6574 7279 7479 7065 6e61 6d65 2e73  ometrytypename.s
+00004ae0: 7461 7274 7377 6974 6828 666f 7263 655f  tartswith(force_
+00004af0: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
+00004b00: 7970 6529 3a0a 2020 2020 2020 2020 2020  ype):.          
+00004b10: 2020 6b65 6570 5f63 6f6c 6c61 7073 6564    keep_collapsed
+00004b20: 203d 2046 616c 7365 0a0a 2020 2020 6170   = False..    ap
+00004b30: 706c 7928 0a20 2020 2020 2020 2069 6e70  ply(.        inp
+00004b40: 7574 5f70 6174 683d 5061 7468 2869 6e70  ut_path=Path(inp
+00004b50: 7574 5f70 6174 6829 2c0a 2020 2020 2020  ut_path),.      
+00004b60: 2020 6f75 7470 7574 5f70 6174 683d 5061    output_path=Pa
+00004b70: 7468 286f 7574 7075 745f 7061 7468 292c  th(output_path),
+00004b80: 0a20 2020 2020 2020 2066 756e 633d 6c61  .        func=la
+00004b90: 6d62 6461 2067 656f 6d3a 2070 7967 656f  mbda geom: pygeo
+00004ba0: 6f70 732e 6d61 6b65 5f76 616c 6964 280a  ops.make_valid(.
+00004bb0: 2020 2020 2020 2020 2020 2020 6765 6f6d              geom
+00004bc0: 2c20 6b65 6570 5f63 6f6c 6c61 7073 6564  , keep_collapsed
+00004bd0: 3d6b 6565 705f 636f 6c6c 6170 7365 642c  =keep_collapsed,
+00004be0: 206f 6e6c 795f 6966 5f69 6e76 616c 6964   only_if_invalid
+00004bf0: 3d54 7275 650a 2020 2020 2020 2020 292c  =True.        ),
+00004c00: 0a20 2020 2020 2020 206f 7065 7261 7469  .        operati
+00004c10: 6f6e 5f6e 616d 653d 226d 616b 6576 616c  on_name="makeval
+00004c20: 6964 222c 0a20 2020 2020 2020 2069 6e70  id",.        inp
+00004c30: 7574 5f6c 6179 6572 3d69 6e70 7574 5f6c  ut_layer=input_l
+00004c40: 6179 6572 2c0a 2020 2020 2020 2020 6f75  ayer,.        ou
+00004c50: 7470 7574 5f6c 6179 6572 3d6f 7574 7075  tput_layer=outpu
+00004c60: 745f 6c61 7965 722c 0a20 2020 2020 2020  t_layer,.       
+00004c70: 2063 6f6c 756d 6e73 3d63 6f6c 756d 6e73   columns=columns
+00004c80: 2c0a 2020 2020 2020 2020 6578 706c 6f64  ,.        explod
+00004c90: 6563 6f6c 6c65 6374 696f 6e73 3d65 7870  ecollections=exp
+00004ca0: 6c6f 6465 636f 6c6c 6563 7469 6f6e 732c  lodecollections,
+00004cb0: 0a20 2020 2020 2020 2066 6f72 6365 5f6f  .        force_o
+00004cc0: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
+00004cd0: 7065 3d66 6f72 6365 5f6f 7574 7075 745f  pe=force_output_
+00004ce0: 6765 6f6d 6574 7279 7479 7065 2c0a 2020  geometrytype,.  
+00004cf0: 2020 2020 2020 6772 6964 7369 7a65 3d67        gridsize=g
+00004d00: 7269 6473 697a 652c 0a20 2020 2020 2020  ridsize,.       
+00004d10: 206b 6565 705f 656d 7074 795f 6765 6f6d   keep_empty_geom
+00004d20: 733d 6b65 6570 5f65 6d70 7479 5f67 656f  s=keep_empty_geo
+00004d30: 6d73 2c0a 2020 2020 2020 2020 7768 6572  ms,.        wher
+00004d40: 655f 706f 7374 3d77 6865 7265 5f70 6f73  e_post=where_pos
+00004d50: 742c 0a20 2020 2020 2020 206e 625f 7061  t,.        nb_pa
+00004d60: 7261 6c6c 656c 3d6e 625f 7061 7261 6c6c  rallel=nb_parall
+00004d70: 656c 2c0a 2020 2020 2020 2020 6261 7463  el,.        batc
+00004d80: 6873 697a 653d 6261 7463 6873 697a 652c  hsize=batchsize,
+00004d90: 0a20 2020 2020 2020 2066 6f72 6365 3d66  .        force=f
+00004da0: 6f72 6365 2c0a 2020 2020 290a 0a0a 6465  orce,.    )...de
+00004db0: 6620 7369 6d70 6c69 6679 280a 2020 2020  f simplify(.    
+00004dc0: 696e 7075 745f 7061 7468 3a20 5061 7468  input_path: Path
+00004dd0: 2c0a 2020 2020 6f75 7470 7574 5f70 6174  ,.    output_pat
+00004de0: 683a 2050 6174 682c 0a20 2020 2074 6f6c  h: Path,.    tol
+00004df0: 6572 616e 6365 3a20 666c 6f61 742c 0a20  erance: float,. 
+00004e00: 2020 2061 6c67 6f72 6974 686d 3a20 5369     algorithm: Si
+00004e10: 6d70 6c69 6679 416c 676f 7269 7468 6d20  mplifyAlgorithm 
+00004e20: 3d20 5369 6d70 6c69 6679 416c 676f 7269  = SimplifyAlgori
+00004e30: 7468 6d2e 5241 4d45 525f 444f 5547 4c41  thm.RAMER_DOUGLA
+00004e40: 535f 5045 5543 4b45 522c 0a20 2020 206c  S_PEUCKER,.    l
+00004e50: 6f6f 6b61 6865 6164 3a20 696e 7420 3d20  ookahead: int = 
+00004e60: 382c 0a20 2020 2069 6e70 7574 5f6c 6179  8,.    input_lay
+00004e70: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
+00004e80: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 6f75  ] = None,.    ou
+00004e90: 7470 7574 5f6c 6179 6572 3a20 4f70 7469  tput_layer: Opti
+00004ea0: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+00004eb0: 2c0a 2020 2020 636f 6c75 6d6e 733a 204f  ,.    columns: O
+00004ec0: 7074 696f 6e61 6c5b 4c69 7374 5b73 7472  ptional[List[str
+00004ed0: 5d5d 203d 204e 6f6e 652c 0a20 2020 2065  ]] = None,.    e
+00004ee0: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
+00004ef0: 733a 2062 6f6f 6c20 3d20 4661 6c73 652c  s: bool = False,
+00004f00: 0a20 2020 2067 7269 6473 697a 653a 2066  .    gridsize: f
+00004f10: 6c6f 6174 203d 2030 2e30 2c0a 2020 2020  loat = 0.0,.    
+00004f20: 6b65 6570 5f65 6d70 7479 5f67 656f 6d73  keep_empty_geoms
+00004f30: 3a20 626f 6f6c 203d 2054 7275 652c 0a20  : bool = True,. 
+00004f40: 2020 2077 6865 7265 5f70 6f73 743a 204f     where_post: O
+00004f50: 7074 696f 6e61 6c5b 7374 725d 203d 204e  ptional[str] = N
+00004f60: 6f6e 652c 0a20 2020 206e 625f 7061 7261  one,.    nb_para
+00004f70: 6c6c 656c 3a20 696e 7420 3d20 2d31 2c0a  llel: int = -1,.
+00004f80: 2020 2020 6261 7463 6873 697a 653a 2069      batchsize: i
+00004f90: 6e74 203d 202d 312c 0a20 2020 2066 6f72  nt = -1,.    for
+00004fa0: 6365 3a20 626f 6f6c 203d 2046 616c 7365  ce: bool = False
+00004fb0: 2c0a 293a 0a20 2020 2023 2049 6e69 740a  ,.):.    # Init.
+00004fc0: 2020 2020 6f70 6572 6174 696f 6e5f 7061      operation_pa
+00004fd0: 7261 6d73 203d 207b 0a20 2020 2020 2020  rams = {.       
+00004fe0: 2022 746f 6c65 7261 6e63 6522 3a20 746f   "tolerance": to
+00004ff0: 6c65 7261 6e63 652c 0a20 2020 2020 2020  lerance,.       
+00005000: 2022 616c 676f 7269 7468 6d22 3a20 616c   "algorithm": al
+00005010: 676f 7269 7468 6d2c 0a20 2020 2020 2020  gorithm,.       
+00005020: 2022 7374 6570 223a 206c 6f6f 6b61 6865   "step": lookahe
+00005030: 6164 2c0a 2020 2020 7d0a 0a20 2020 2023  ad,.    }..    #
+00005040: 2047 6f21 0a20 2020 2072 6574 7572 6e20   Go!.    return 
+00005050: 5f61 7070 6c79 5f67 656f 6f70 6572 6174  _apply_geooperat
+00005060: 696f 6e5f 746f 5f6c 6179 6572 280a 2020  ion_to_layer(.  
+00005070: 2020 2020 2020 696e 7075 745f 7061 7468        input_path
+00005080: 3d69 6e70 7574 5f70 6174 682c 0a20 2020  =input_path,.   
+00005090: 2020 2020 206f 7574 7075 745f 7061 7468       output_path
+000050a0: 3d6f 7574 7075 745f 7061 7468 2c0a 2020  =output_path,.  
+000050b0: 2020 2020 2020 6f70 6572 6174 696f 6e3d        operation=
+000050c0: 4765 6f4f 7065 7261 7469 6f6e 2e53 494d  GeoOperation.SIM
+000050d0: 504c 4946 592c 0a20 2020 2020 2020 206f  PLIFY,.        o
+000050e0: 7065 7261 7469 6f6e 5f70 6172 616d 733d  peration_params=
+000050f0: 6f70 6572 6174 696f 6e5f 7061 7261 6d73  operation_params
+00005100: 2c0a 2020 2020 2020 2020 696e 7075 745f  ,.        input_
+00005110: 6c61 7965 723d 696e 7075 745f 6c61 7965  layer=input_laye
+00005120: 722c 0a20 2020 2020 2020 206f 7574 7075  r,.        outpu
+00005130: 745f 6c61 7965 723d 6f75 7470 7574 5f6c  t_layer=output_l
+00005140: 6179 6572 2c0a 2020 2020 2020 2020 636f  ayer,.        co
+00005150: 6c75 6d6e 733d 636f 6c75 6d6e 732c 0a20  lumns=columns,. 
+00005160: 2020 2020 2020 2065 7870 6c6f 6465 636f         explodeco
+00005170: 6c6c 6563 7469 6f6e 733d 6578 706c 6f64  llections=explod
+00005180: 6563 6f6c 6c65 6374 696f 6e73 2c0a 2020  ecollections,.  
+00005190: 2020 2020 2020 666f 7263 655f 6f75 7470        force_outp
+000051a0: 7574 5f67 656f 6d65 7472 7974 7970 653d  ut_geometrytype=
+000051b0: 4e6f 6e65 2c0a 2020 2020 2020 2020 6772  None,.        gr
+000051c0: 6964 7369 7a65 3d67 7269 6473 697a 652c  idsize=gridsize,
+000051d0: 0a20 2020 2020 2020 206b 6565 705f 656d  .        keep_em
+000051e0: 7074 795f 6765 6f6d 733d 6b65 6570 5f65  pty_geoms=keep_e
+000051f0: 6d70 7479 5f67 656f 6d73 2c0a 2020 2020  mpty_geoms,.    
+00005200: 2020 2020 7768 6572 655f 706f 7374 3d77      where_post=w
+00005210: 6865 7265 5f70 6f73 742c 0a20 2020 2020  here_post,.     
+00005220: 2020 206e 625f 7061 7261 6c6c 656c 3d6e     nb_parallel=n
+00005230: 625f 7061 7261 6c6c 656c 2c0a 2020 2020  b_parallel,.    
+00005240: 2020 2020 6261 7463 6873 697a 653d 6261      batchsize=ba
+00005250: 7463 6873 697a 652c 0a20 2020 2020 2020  tchsize,.       
+00005260: 2066 6f72 6365 3d66 6f72 6365 2c0a 2020   force=force,.  
+00005270: 2020 290a 0a0a 6465 6620 5f61 7070 6c79    )...def _apply
+00005280: 5f67 656f 6f70 6572 6174 696f 6e5f 746f  _geooperation_to
+00005290: 5f6c 6179 6572 280a 2020 2020 696e 7075  _layer(.    inpu
+000052a0: 745f 7061 7468 3a20 5061 7468 2c0a 2020  t_path: Path,.  
+000052b0: 2020 6f75 7470 7574 5f70 6174 683a 2050    output_path: P
+000052c0: 6174 682c 0a20 2020 206f 7065 7261 7469  ath,.    operati
+000052d0: 6f6e 3a20 4765 6f4f 7065 7261 7469 6f6e  on: GeoOperation
+000052e0: 2c0a 2020 2020 6f70 6572 6174 696f 6e5f  ,.    operation_
+000052f0: 7061 7261 6d73 3a20 6469 6374 2c0a 2020  params: dict,.  
+00005300: 2020 696e 7075 745f 6c61 7965 723a 204f    input_layer: O
+00005310: 7074 696f 6e61 6c5b 7374 725d 2c20 2023  ptional[str],  #
+00005320: 203d 204e 6f6e 650a 2020 2020 636f 6c75   = None.    colu
+00005330: 6d6e 733a 204f 7074 696f 6e61 6c5b 4c69  mns: Optional[Li
+00005340: 7374 5b73 7472 5d5d 2c20 2023 203d 204e  st[str]],  # = N
+00005350: 6f6e 650a 2020 2020 6f75 7470 7574 5f6c  one.    output_l
+00005360: 6179 6572 3a20 4f70 7469 6f6e 616c 5b73  ayer: Optional[s
+00005370: 7472 5d2c 2020 2320 3d20 4e6f 6e65 0a20  tr],  # = None. 
+00005380: 2020 2065 7870 6c6f 6465 636f 6c6c 6563     explodecollec
+00005390: 7469 6f6e 733a 2062 6f6f 6c2c 2020 2320  tions: bool,  # 
+000053a0: 3d20 4661 6c73 650a 2020 2020 666f 7263  = False.    forc
+000053b0: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+000053c0: 7974 7970 653a 2055 6e69 6f6e 5b47 656f  ytype: Union[Geo
+000053d0: 6d65 7472 7954 7970 652c 2073 7472 2c20  metryType, str, 
+000053e0: 4e6f 6e65 5d2c 2020 2320 3d20 4e6f 6e65  None],  # = None
+000053f0: 0a20 2020 2067 7269 6473 697a 653a 2066  .    gridsize: f
+00005400: 6c6f 6174 2c20 2023 203d 2030 2e30 0a20  loat,  # = 0.0. 
+00005410: 2020 206b 6565 705f 656d 7074 795f 6765     keep_empty_ge
+00005420: 6f6d 733a 2062 6f6f 6c2c 2020 2320 3d20  oms: bool,  # = 
+00005430: 5472 7565 0a20 2020 2077 6865 7265 5f70  True.    where_p
+00005440: 6f73 743a 204f 7074 696f 6e61 6c5b 7374  ost: Optional[st
+00005450: 725d 2c20 2023 203d 204e 6f6e 650a 2020  r],  # = None.  
+00005460: 2020 6e62 5f70 6172 616c 6c65 6c3a 2069    nb_parallel: i
+00005470: 6e74 2c20 2023 203d 202d 310a 2020 2020  nt,  # = -1.    
+00005480: 6261 7463 6873 697a 653a 2069 6e74 2c20  batchsize: int, 
+00005490: 2023 203d 202d 310a 2020 2020 666f 7263   # = -1.    forc
+000054a0: 653a 2062 6f6f 6c2c 2020 2320 3d20 4661  e: bool,  # = Fa
+000054b0: 6c73 650a 2020 2020 7061 7261 6c6c 656c  lse.    parallel
+000054c0: 697a 6174 696f 6e5f 636f 6e66 6967 3a20  ization_config: 
+000054d0: 5061 7261 6c6c 656c 697a 6174 696f 6e43  ParallelizationC
+000054e0: 6f6e 6669 6720 3d20 4e6f 6e65 2c0a 293a  onfig = None,.):
+000054f0: 0a20 2020 2022 2222 0a20 2020 2041 7070  .    """.    App
+00005500: 6c69 6573 2061 2067 656f 206f 7065 7261  lies a geo opera
+00005510: 7469 6f6e 206f 6e20 6120 6c61 7965 722e  tion on a layer.
+00005520: 0a0a 2020 2020 5468 6520 6f70 6572 6174  ..    The operat
+00005530: 696f 6e20 746f 2061 7070 6c79 2063 616e  ion to apply can
+00005540: 2062 6520 6f6e 6520 6f66 2074 6865 2074   be one of the t
+00005550: 6865 2066 6f6c 6c6f 7769 6e67 3a0a 2020  he following:.  
+00005560: 2020 2020 2d20 4255 4646 4552 3a20 6170      - BUFFER: ap
+00005570: 706c 7920 6120 6275 6666 6572 2e20 4f70  ply a buffer. Op
+00005580: 6572 6174 696f 6e20 7061 7261 6d65 7465  eration paramete
+00005590: 7273 3a0a 2020 2020 2020 2020 2020 2d20  rs:.          - 
+000055a0: 6469 7374 616e 6365 3a20 6469 7374 616e  distance: distan
+000055b0: 6365 2074 6f20 6275 6666 6572 0a20 2020  ce to buffer.   
+000055c0: 2020 2020 2020 202d 2071 7561 6472 616e         - quadran
+000055d0: 7473 6567 6d65 6e74 733a 206e 756d 6265  tsegments: numbe
+000055e0: 7220 6f66 2070 6f69 6e74 7320 7573 6564  r of points used
+000055f0: 2074 6f20 7265 7072 6573 656e 7420 312f   to represent 1/
+00005600: 3420 6f66 2061 2063 6972 636c 650a 2020  4 of a circle.  
+00005610: 2020 2020 2020 2020 2d20 656e 6463 6170          - endcap
+00005620: 5f73 7479 6c65 3a20 6275 6666 6572 2073  _style: buffer s
+00005630: 7479 6c65 2074 6f20 7573 6520 666f 7220  tyle to use for 
+00005640: 6120 706f 696e 7420 6f72 2074 6865 2065  a point or the e
+00005650: 6e64 2070 6f69 6e74 7320 6f66 0a20 2020  nd points of.   
+00005660: 2020 2020 2020 2020 2061 206c 696e 653a           a line:
+00005670: 0a20 2020 2020 2020 2020 2020 202d 2052  .            - R
+00005680: 4f55 4e44 3a20 666f 7220 706f 696e 7473  OUND: for points
+00005690: 2061 6e64 206c 696e 6573 2074 6865 2065   and lines the e
+000056a0: 6e64 7320 6172 6520 6275 6666 6572 6564  nds are buffered
+000056b0: 2072 6f75 6e64 6564 2e0a 2020 2020 2020   rounded..      
+000056c0: 2020 2020 2020 2d20 464c 4154 3a20 6120        - FLAT: a 
+000056d0: 706f 696e 7420 7374 6179 7320 6120 706f  point stays a po
+000056e0: 696e 742c 2061 2062 7566 6665 7265 6420  int, a buffered 
+000056f0: 6c69 6e65 2077 696c 6c20 656e 6420 666c  line will end fl
+00005700: 6174 0a20 2020 2020 2020 2020 2020 2020  at.             
+00005710: 2061 7420 7468 6520 656e 6420 706f 696e   at the end poin
+00005720: 7473 0a20 2020 2020 2020 2020 2020 202d  ts.            -
+00005730: 2053 5155 4152 453a 2061 2070 6f69 6e74   SQUARE: a point
+00005740: 2062 6563 6f6d 6573 2061 2073 7175 6172   becomes a squar
+00005750: 652c 2061 2062 7566 6665 7265 6420 6c69  e, a buffered li
+00005760: 6e65 2077 696c 6c20 656e 640a 2020 2020  ne will end.    
+00005770: 2020 2020 2020 2020 2020 666c 6174 2061            flat a
+00005780: 7420 7468 6520 656e 6420 706f 696e 7473  t the end points
+00005790: 2c20 6275 7420 656c 6f6e 6761 7465 6420  , but elongated 
+000057a0: 6279 2022 6469 7374 616e 6365 220a 2020  by "distance".  
+000057b0: 2020 2020 2020 2d20 6a6f 696e 5f73 7479        - join_sty
+000057c0: 6c65 3a20 6275 6666 6572 2073 7479 6c65  le: buffer style
+000057d0: 2074 6f20 7573 6520 666f 7220 636f 726e   to use for corn
+000057e0: 6572 7320 696e 2061 206c 696e 6520 6f72  ers in a line or
+000057f0: 2061 2070 6f6c 7967 6f6e 0a20 2020 2020   a polygon.     
+00005800: 2020 2020 2062 6f75 6e64 6172 793a 0a20       boundary:. 
+00005810: 2020 2020 2020 2020 2020 202d 2052 4f55             - ROU
+00005820: 4e44 3a20 636f 726e 6572 7320 696e 2074  ND: corners in t
+00005830: 6865 2072 6573 756c 7420 6172 6520 726f  he result are ro
+00005840: 756e 6465 640a 2020 2020 2020 2020 2020  unded.          
+00005850: 2020 2d20 4d49 5452 453a 2063 6f72 6e65    - MITRE: corne
+00005860: 7273 2069 6e20 7468 6520 7265 7375 6c74  rs in the result
+00005870: 2061 7265 2073 6861 7270 0a20 2020 2020   are sharp.     
+00005880: 2020 2020 2020 202d 2042 4556 454c 3a20         - BEVEL: 
+00005890: 6172 6520 666c 6174 7465 6e65 640a 2020  are flattened.  
+000058a0: 2020 2020 2020 2d20 6d69 7472 655f 6c69        - mitre_li
+000058b0: 6d69 743a 2069 6e20 6361 7365 206f 6620  mit: in case of 
+000058c0: 6a6f 696e 5f73 7479 6c65 204d 4954 5245  join_style MITRE
+000058d0: 2c20 6966 2074 6865 0a20 2020 2020 2020  , if the.       
+000058e0: 2020 2020 2073 7069 6b79 2072 6573 756c       spiky resul
+000058f0: 7420 666f 7220 6120 7368 6172 7020 616e  t for a sharp an
+00005900: 676c 6520 6265 636f 6d65 7320 6c6f 6e67  gle becomes long
+00005910: 6572 2074 6861 6e20 7468 6973 206c 696d  er than this lim
+00005920: 6974 2c20 6974 0a20 2020 2020 2020 2020  it, it.         
+00005930: 2020 2069 7320 2262 6576 656c 6564 2220     is "beveled" 
+00005940: 6174 2074 6869 7320 6469 7374 616e 6365  at this distance
+00005950: 2e20 4465 6661 756c 7473 2074 6f20 352e  . Defaults to 5.
+00005960: 302e 0a20 2020 2020 2020 202d 2073 696e  0..        - sin
+00005970: 676c 655f 7369 6465 643a 206f 6e6c 7920  gle_sided: only 
+00005980: 6f6e 6520 7369 6465 206f 6620 7468 6520  one side of the 
+00005990: 6c69 6e65 2069 7320 6275 6666 6572 6564  line is buffered
+000059a0: 2c0a 2020 2020 2020 2020 2020 2020 6966  ,.            if
+000059b0: 2064 6973 7461 6e63 6520 6973 206e 6567   distance is neg
+000059c0: 6174 6976 652c 2074 6865 206c 6566 7420  ative, the left 
+000059d0: 7369 6465 2c20 6966 2064 6973 7461 6e63  side, if distanc
+000059e0: 6520 6973 2070 6f73 6974 6976 652c 0a20  e is positive,. 
+000059f0: 2020 2020 2020 2020 2020 2074 6865 2072             the r
+00005a00: 6967 6874 2068 616e 6420 7369 6465 2e20  ight hand side. 
+00005a10: 4f6e 6c79 2072 656c 6576 616e 7420 666f  Only relevant fo
+00005a20: 7220 6c69 6e65 2067 656f 6d65 7472 6965  r line geometrie
+00005a30: 732e 0a20 2020 2020 202d 2043 4f4e 5645  s..      - CONVE
+00005a40: 5848 554c 4c3a 2061 7070 7920 6120 636f  XHULL: appy a co
+00005a50: 6e76 6578 2068 756c 6c2e 0a20 2020 2020  nvex hull..     
+00005a60: 202d 2053 494d 504c 4946 593a 2073 696d   - SIMPLIFY: sim
+00005a70: 706c 6966 7920 7468 6520 6765 6f6d 6574  plify the geomet
+00005a80: 7279 2e20 4f70 6572 6174 696f 6e20 7061  ry. Operation pa
+00005a90: 7261 6d65 7465 7273 3a0a 2020 2020 2020  rameters:.      
+00005aa0: 2020 2020 2d20 616c 676f 7269 7468 6d3a      - algorithm:
+00005ab0: 2076 6563 746f 725f 7574 696c 2e53 696d   vector_util.Sim
+00005ac0: 706c 6966 7941 6c67 6f72 6974 686d 0a20  plifyAlgorithm. 
+00005ad0: 2020 2020 2020 2020 202d 2074 6f6c 6572           - toler
+00005ae0: 616e 6365 3a20 6d61 7869 6d75 6d20 6469  ance: maximum di
+00005af0: 7374 616e 6365 2074 6f20 7369 6d70 6c69  stance to simpli
+00005b00: 6679 2e0a 2020 2020 2020 2020 2020 2d20  fy..          - 
+00005b10: 6c6f 6f6b 6168 6561 643a 2066 6f72 204c  lookahead: for L
+00005b20: 414e 472c 2074 6865 206e 756d 6265 7220  ANG, the number 
+00005b30: 6f66 2070 6f69 6e74 7320 746f 2066 6f72  of points to for
+00005b40: 7761 7264 2d6c 6f6f 6b0a 2020 2020 2020  ward-look.      
+00005b50: 2d20 4150 504c 593a 2061 7070 6c79 2061  - APPLY: apply a
+00005b60: 206c 616d 6264 6120 6675 6e63 7469 6f6e   lambda function
+00005b70: 2e20 4f70 6572 6174 696f 6e20 7061 7261  . Operation para
+00005b80: 6d65 7465 723a 0a20 2020 2020 2020 2020  meter:.         
+00005b90: 202d 2070 6963 6b6c 6564 5f66 756e 633a   - pickled_func:
+00005ba0: 206c 616d 6264 6120 6675 6e63 7469 6f6e   lambda function
+00005bb0: 2074 6f20 6170 706c 792c 2070 6963 6b6c   to apply, pickl
+00005bc0: 6564 2074 6f20 6279 7465 732e 0a20 2020  ed to bytes..   
+00005bd0: 2020 2020 2020 202d 206f 6e6c 795f 6765         - only_ge
+00005be0: 6f6d 5f69 6e70 7574 3a20 6966 2054 7275  om_input: if Tru
+00005bf0: 652c 206f 6e6c 7920 7468 6520 6765 6f6d  e, only the geom
+00005c00: 6574 7279 2069 7320 6176 6169 6c61 626c  etry is availabl
+00005c10: 6520 6173 0a20 2020 2020 2020 2020 2020  e as.           
+00005c20: 2069 6e70 7574 2066 6f72 2074 6865 206c   input for the l
+00005c30: 616d 6264 6120 6675 6e63 7469 6f6e 2e20  ambda function. 
+00005c40: 4966 2066 616c 7365 2c20 7468 6520 726f  If false, the ro
+00005c50: 7720 6973 2074 6865 2069 6e70 7574 2e0a  w is the input..
+00005c60: 0a20 2020 2041 7267 733a 0a20 2020 2020  .    Args:.     
+00005c70: 2020 2069 6e70 7574 5f70 6174 6820 2850     input_path (P
+00005c80: 6174 6829 3a20 5b64 6573 6372 6970 7469  ath): [descripti
+00005c90: 6f6e 5d0a 2020 2020 2020 2020 6f75 7470  on].        outp
+00005ca0: 7574 5f70 6174 6820 2850 6174 6829 3a20  ut_path (Path): 
+00005cb0: 5b64 6573 6372 6970 7469 6f6e 5d0a 2020  [description].  
+00005cc0: 2020 2020 2020 6f70 6572 6174 696f 6e20        operation 
+00005cd0: 2847 656f 4f70 6572 6174 696f 6e29 3a20  (GeoOperation): 
+00005ce0: 7468 6520 6765 6f20 6f70 6572 6174 696f  the geo operatio
+00005cf0: 6e20 746f 2061 7070 6c79 2e0a 2020 2020  n to apply..    
+00005d00: 2020 2020 6f70 6572 6174 696f 6e5f 7061      operation_pa
+00005d10: 7261 6d73 2028 6469 6374 2c20 6f70 7469  rams (dict, opti
+00005d20: 6f6e 616c 293a 2074 6865 2070 6172 616d  onal): the param
+00005d30: 6574 6572 7320 666f 7220 7468 6520 6765  eters for the ge
+00005d40: 6f20 6f70 6572 6174 696f 6e2e 0a20 2020  o operation..   
+00005d50: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
+00005d60: 7320 746f 204e 6f6e 652e 0a20 2020 2020  s to None..     
+00005d70: 2020 2069 6e70 7574 5f6c 6179 6572 2028     input_layer (
+00005d80: 7374 722c 206f 7074 696f 6e61 6c29 3a20  str, optional): 
+00005d90: 5b64 6573 6372 6970 7469 6f6e 5d2e 2044  [description]. D
+00005da0: 6566 6175 6c74 7320 746f 204e 6f6e 652e  efaults to None.
+00005db0: 0a20 2020 2020 2020 206f 7574 7075 745f  .        output_
+00005dc0: 6c61 7965 7220 2873 7472 2c20 6f70 7469  layer (str, opti
+00005dd0: 6f6e 616c 293a 205b 6465 7363 7269 7074  onal): [descript
+00005de0: 696f 6e5d 2e20 4465 6661 756c 7473 2074  ion]. Defaults t
+00005df0: 6f20 4e6f 6e65 2e0a 2020 2020 2020 2020  o None..        
+00005e00: 636f 6c75 6d6e 7320 284c 6973 745b 7374  columns (List[st
+00005e10: 725d 2c20 6f70 7469 6f6e 616c 293a 2049  r], optional): I
+00005e20: 6620 6e6f 7420 4e6f 6e65 2c20 6f6e 6c79  f not None, only
+00005e30: 206f 7574 7075 7420 7468 6520 636f 6c75   output the colu
+00005e40: 6d6e 730a 2020 2020 2020 2020 2020 2020  mns.            
+00005e50: 7370 6563 6966 6965 642e 2044 6566 6175  specified. Defau
+00005e60: 6c74 7320 746f 204e 6f6e 652e 0a20 2020  lts to None..   
+00005e70: 2020 2020 2065 7870 6c6f 6465 636f 6c6c       explodecoll
+00005e80: 6563 7469 6f6e 7320 2862 6f6f 6c2c 206f  ections (bool, o
+00005e90: 7074 696f 6e61 6c29 3a20 5472 7565 2074  ptional): True t
+00005ea0: 6f20 636f 6e76 6572 7420 616c 6c20 6d75  o convert all mu
+00005eb0: 6c74 692d 6765 6f6d 6574 7269 6573 2074  lti-geometries t
+00005ec0: 6f0a 2020 2020 2020 2020 2020 2020 7369  o.            si
+00005ed0: 6e67 756c 6172 206f 6e65 7320 6475 7269  ngular ones duri
+00005ee0: 6e67 2074 6865 2067 656f 6f70 6572 6174  ng the geooperat
+00005ef0: 696f 6e2e 2044 6566 6175 6c74 7320 746f  ion. Defaults to
+00005f00: 2046 616c 7365 2e0a 2020 2020 2020 2020   False..        
+00005f10: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
+00005f20: 6d65 7472 7974 7970 6520 2847 656f 6d65  metrytype (Geome
+00005f30: 7472 7954 7970 652c 206f 7074 696f 6e61  tryType, optiona
+00005f40: 6c29 3a20 5468 6520 6f75 7470 7574 2067  l): The output g
+00005f50: 656f 6d65 7472 7920 7479 7065 2074 6f0a  eometry type to.
+00005f60: 2020 2020 2020 2020 2020 2020 666f 7263              forc
+00005f70: 652e 2049 6620 4e6f 6e65 2c20 6120 6265  e. If None, a be
+00005f80: 7374 2d65 6666 6f72 7420 6775 6573 7320  st-effort guess 
+00005f90: 6973 206d 6164 652e 2044 6566 6175 6c74  is made. Default
+00005fa0: 7320 746f 204e 6f6e 652e 0a20 2020 2020  s to None..     
+00005fb0: 2020 2067 7269 6473 697a 6520 2866 6c6f     gridsize (flo
+00005fc0: 6174 2c20 6f70 7469 6f6e 616c 293a 2074  at, optional): t
+00005fd0: 6865 2073 697a 6520 6f66 2074 6865 2067  he size of the g
+00005fe0: 7269 6420 7468 6520 636f 6f72 6469 6e61  rid the coordina
+00005ff0: 7465 7320 6f66 2074 6865 206f 7570 7574  tes of the ouput
+00006000: 0a20 2020 2020 2020 2020 2020 2077 696c  .            wil
+00006010: 6c20 6265 2072 6f75 6e64 6564 2074 6f2e  l be rounded to.
+00006020: 2045 672e 2030 2e30 3031 2074 6f20 6b65   Eg. 0.001 to ke
+00006030: 6570 2033 2064 6563 696d 616c 732e 2056  ep 3 decimals. V
+00006040: 616c 7565 2030 2e30 2064 6f65 736e 2774  alue 0.0 doesn't
+00006050: 2063 6861 6e67 650a 2020 2020 2020 2020   change.        
+00006060: 2020 2020 7468 6520 7072 6563 6973 696f      the precisio
+00006070: 6e2e 2044 6566 6175 6c74 7320 746f 2030  n. Defaults to 0
+00006080: 2e30 2e0a 2020 2020 2020 2020 6b65 6570  .0..        keep
+00006090: 5f65 6d70 7479 5f67 656f 6d73 2028 626f  _empty_geoms (bo
+000060a0: 6f6c 2c20 6f70 7469 6f6e 616c 293a 2054  ol, optional): T
+000060b0: 7275 6520 746f 206b 6565 7020 726f 7773  rue to keep rows
+000060c0: 2077 6974 6820 656d 7074 792f 6e75 6c6c   with empty/null
+000060d0: 2067 656f 6d65 7472 6965 730a 2020 2020   geometries.    
+000060e0: 2020 2020 2020 2020 696e 2074 6865 206f          in the o
+000060f0: 7574 7075 742e 2044 6566 6175 6c74 7320  utput. Defaults 
+00006100: 746f 2054 7275 652e 0a20 2020 2020 2020  to True..       
+00006110: 2077 6865 7265 5f70 6f73 7420 2873 7472   where_post (str
+00006120: 2c20 6f70 7469 6f6e 616c 293a 2073 716c  , optional): sql
+00006130: 2066 696c 7465 7220 746f 2061 7070 6c79   filter to apply
+00006140: 2061 6674 6572 2061 6c6c 206f 7468 6572   after all other
+00006150: 2070 726f 6365 7373 696e 672c 0a20 2020   processing,.   
+00006160: 2020 2020 2020 2020 2069 6e63 6c75 6469           includi
+00006170: 6e67 2065 2e67 2e20 6578 706c 6f64 6563  ng e.g. explodec
+00006180: 6f6c 6c65 6374 696f 6e73 2e20 4974 2073  ollections. It s
+00006190: 686f 756c 6420 6265 2069 6e20 7371 6c69  hould be in sqli
+000061a0: 7465 2073 796e 7461 7820 616e 640a 2020  te syntax and.  
+000061b0: 2020 2020 2020 2020 2020 7c73 7061 7469            |spati
+000061c0: 616c 6974 655f 7265 6665 7265 6e63 655f  alite_reference_
+000061d0: 6c69 6e6b 7c20 6675 6e63 7469 6f6e 7320  link| functions 
+000061e0: 6361 6e20 6265 2075 7365 642e 2044 6566  can be used. Def
+000061f0: 6175 6c74 7320 746f 204e 6f6e 652e 0a20  aults to None.. 
+00006200: 2020 2020 2020 206e 625f 7061 7261 6c6c         nb_parall
+00006210: 656c 2028 696e 742c 206f 7074 696f 6e61  el (int, optiona
+00006220: 6c29 3a20 5b64 6573 6372 6970 7469 6f6e  l): [description
+00006230: 5d2e 2044 6566 6175 6c74 7320 746f 202d  ]. Defaults to -
+00006240: 312e 0a20 2020 2020 2020 2062 6174 6368  1..        batch
+00006250: 7369 7a65 2028 696e 742c 206f 7074 696f  size (int, optio
+00006260: 6e61 6c29 3a20 696e 6469 6361 7469 7665  nal): indicative
+00006270: 206e 756d 6265 7220 6f66 2072 6f77 7320   number of rows 
+00006280: 746f 2070 726f 6365 7373 2070 6572 0a20  to process per. 
+00006290: 2020 2020 2020 2020 2020 2062 6174 6368             batch
+000062a0: 2e20 4120 736d 616c 6c65 7220 6261 7463  . A smaller batc
+000062b0: 6820 7369 7a65 2c20 706f 7373 6962 6c79  h size, possibly
+000062c0: 2069 6e20 636f 6d62 696e 6174 696f 6e20   in combination 
+000062d0: 7769 7468 2061 0a20 2020 2020 2020 2020  with a.         
+000062e0: 2020 2073 6d61 6c6c 6572 206e 625f 7061     smaller nb_pa
+000062f0: 7261 6c6c 656c 2c20 7769 6c6c 2072 6564  rallel, will red
+00006300: 7563 6520 7468 6520 6d65 6d6f 7279 2075  uce the memory u
+00006310: 7361 6765 2e0a 2020 2020 2020 2020 2020  sage..          
+00006320: 2020 4465 6661 756c 7473 2074 6f20 2d31    Defaults to -1
+00006330: 3a20 2874 7279 2074 6f29 2064 6574 6572  : (try to) deter
+00006340: 6d69 6e65 206f 7074 696d 616c 2073 697a  mine optimal siz
+00006350: 6520 6175 746f 6d61 7469 6361 6c6c 792e  e automatically.
+00006360: 0a20 2020 2020 2020 2066 6f72 6365 2028  .        force (
+00006370: 626f 6f6c 2c20 6f70 7469 6f6e 616c 293a  bool, optional):
+00006380: 205b 6465 7363 7269 7074 696f 6e5d 2e20   [description]. 
+00006390: 4465 6661 756c 7473 2074 6f20 4661 6c73  Defaults to Fals
+000063a0: 652e 0a20 2020 2020 2020 2070 6172 616c  e..        paral
+000063b0: 6c65 6c69 7a61 7469 6f6e 5f63 6f6e 6669  lelization_confi
+000063c0: 6720 2850 6172 616c 6c65 6c69 7a61 7469  g (Parallelizati
+000063d0: 6f6e 436f 6e66 6967 2c20 6f70 7469 6f6e  onConfig, option
+000063e0: 616c 293a 2044 6566 6175 6c74 7320 746f  al): Defaults to
+000063f0: 204e 6f6e 652e 0a0a 2020 2020 5465 6368   None...    Tech
+00006400: 6e69 6361 6c20 7265 6d61 726b 733a 0a20  nical remarks:. 
+00006410: 2020 2020 2020 202d 2052 6574 6169 6e69         - Retaini
+00006420: 6e67 204e 6f6e 6520 6765 6f6d 6574 7279  ng None geometry
+00006430: 2076 616c 7565 7320 696e 2074 6865 206f   values in the o
+00006440: 7574 7075 7420 6669 6c65 7320 6973 2068  utput files is h
+00006450: 6172 642c 2062 6563 6175 7365 2077 6865  ard, because whe
+00006460: 6e0a 2020 2020 2020 2020 2020 6361 6c63  n.          calc
+00006470: 756c 6174 696e 6720 7061 7274 6961 6c20  ulating partial 
+00006480: 6669 6c65 732c 2061 2070 6172 7469 616c  files, a partial
+00006490: 2066 696c 6520 6361 6e20 6861 7665 206f   file can have o
+000064a0: 6e6c 7920 4e6f 6e65 2067 656f 6d65 7472  nly None geometr
+000064b0: 6965 7320 7768 6963 680a 2020 2020 2020  ies which.      
+000064c0: 2020 2020 6d61 6b65 7320 6974 2069 6d70      makes it imp
+000064d0: 6f73 7369 626c 6520 746f 206b 6e6f 7720  ossible to know 
+000064e0: 7468 6520 6765 6f6d 6574 7279 2074 7970  the geometry typ
+000064f0: 652e 204f 6e63 6520 616e 206f 7574 7075  e. Once an outpu
+00006500: 7420 6669 6c65 2069 7320 6372 6561 7465  t file is create
+00006510: 642c 0a20 2020 2020 2020 2020 2069 7420  d,.          it 
+00006520: 6973 2061 6c73 6f20 696d 706f 7373 6962  is also impossib
+00006530: 6c65 2074 6f20 6368 616e 6765 2074 6865  le to change the
+00006540: 2074 7970 6520 6166 7465 7277 6172 6473   type afterwards
+00006550: 2028 7769 7468 6f75 7420 6d61 6b69 6e67   (without making
+00006560: 2061 2063 6f70 7929 2e0a 2020 2020 2020   a copy)..      
+00006570: 2020 2020 4966 2066 6f72 6365 5f6f 7574      If force_out
+00006580: 7075 745f 7479 7065 2069 7320 7370 6563  put_type is spec
+00006590: 6966 6965 642c 2074 6865 2070 726f 626c  ified, the probl
+000065a0: 656d 2069 7320 676f 6e65 2e0a 0a20 2020  em is gone...   
+000065b0: 202e 2e20 7c73 7061 7469 616c 6974 655f   .. |spatialite_
+000065c0: 7265 6665 7265 6e63 655f 6c69 6e6b 7c20  reference_link| 
+000065d0: 7261 773a 3a20 6874 6d6c 0a0a 2020 2020  raw:: html..    
+000065e0: 2020 2020 3c61 2068 7265 663d 2268 7474      <a href="htt
+000065f0: 7073 3a2f 2f77 7777 2e67 6169 612d 6769  ps://www.gaia-gi
+00006600: 732e 6974 2f67 6169 612d 7369 6e73 2f73  s.it/gaia-sins/s
+00006610: 7061 7469 616c 6974 652d 7371 6c2d 6c61  patialite-sql-la
+00006620: 7465 7374 2e68 746d 6c22 2074 6172 6765  test.html" targe
+00006630: 743d 225f 626c 616e 6b22 3e73 7061 7469  t="_blank">spati
+00006640: 616c 6974 6520 7265 6665 7265 6e63 653c  alite reference<
+00006650: 2f61 3e0a 0a20 2020 2022 2222 2020 2320  /a>..    """  # 
+00006660: 6e6f 7161 3a20 4535 3031 0a20 2020 2023  noqa: E501.    #
+00006670: 2049 6e69 740a 2020 2020 7374 6172 745f   Init.    start_
+00006680: 7469 6d65 5f67 6c6f 6261 6c20 3d20 6461  time_global = da
+00006690: 7465 7469 6d65 2e6e 6f77 2829 0a20 2020  tetime.now().   
+000066a0: 206f 7065 7261 7469 6f6e 5f6e 616d 6520   operation_name 
+000066b0: 3d20 6f70 6572 6174 696f 6e5f 7061 7261  = operation_para
+000066c0: 6d73 2e67 6574 2822 6f70 6572 6174 696f  ms.get("operatio
+000066d0: 6e5f 6e61 6d65 2229 0a20 2020 2069 6620  n_name").    if 
+000066e0: 6f70 6572 6174 696f 6e5f 6e61 6d65 2069  operation_name i
+000066f0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+00006700: 6f70 6572 6174 696f 6e5f 6e61 6d65 203d  operation_name =
+00006710: 206f 7065 7261 7469 6f6e 2e76 616c 7565   operation.value
+00006720: 0a20 2020 206c 6f67 6765 7220 3d20 6c6f  .    logger = lo
+00006730: 6767 696e 672e 6765 744c 6f67 6765 7228  gging.getLogger(
+00006740: 6622 6765 6f66 696c 656f 7073 2e7b 6f70  f"geofileops.{op
+00006750: 6572 6174 696f 6e5f 6e61 6d65 7d22 290a  eration_name}").
+00006760: 0a20 2020 2023 2043 6865 636b 2069 6e70  .    # Check inp
+00006770: 7574 2070 6172 616d 6574 6572 732e 2e2e  ut parameters...
+00006780: 0a20 2020 2069 6620 6e6f 7420 696e 7075  .    if not inpu
+00006790: 745f 7061 7468 2e65 7869 7374 7328 293a  t_path.exists():
+000067a0: 0a20 2020 2020 2020 2072 6169 7365 2056  .        raise V
+000067b0: 616c 7565 4572 726f 7228 6622 7b6f 7065  alueError(f"{ope
+000067c0: 7261 7469 6f6e 5f6e 616d 657d 3a20 696e  ration_name}: in
+000067d0: 7075 745f 7061 7468 2064 6f65 736e 2774  put_path doesn't
+000067e0: 2065 7869 7374 3a20 7b69 6e70 7574 5f70   exist: {input_p
+000067f0: 6174 687d 2229 0a20 2020 2069 6620 696e  ath}").    if in
+00006800: 7075 745f 7061 7468 203d 3d20 6f75 7470  put_path == outp
+00006810: 7574 5f70 6174 683a 0a20 2020 2020 2020  ut_path:.       
+00006820: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
+00006830: 7228 6622 7b6f 7065 7261 7469 6f6e 5f6e  r(f"{operation_n
+00006840: 616d 657d 3a20 6f75 7470 7574 5f70 6174  ame}: output_pat
+00006850: 6820 6d75 7374 206e 6f74 2065 7175 616c  h must not equal
+00006860: 2069 6e70 7574 5f70 6174 6822 290a 2020   input_path").  
+00006870: 2020 6966 2069 6e70 7574 5f6c 6179 6572    if input_layer
+00006880: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00006890: 2020 696e 7075 745f 6c61 7965 7220 3d20    input_layer = 
+000068a0: 6766 6f2e 6765 745f 6f6e 6c79 5f6c 6179  gfo.get_only_lay
+000068b0: 6572 2869 6e70 7574 5f70 6174 6829 0a20  er(input_path). 
+000068c0: 2020 2069 6620 6f75 7470 7574 5f70 6174     if output_pat
+000068d0: 682e 6578 6973 7473 2829 3a0a 2020 2020  h.exists():.    
+000068e0: 2020 2020 6966 2066 6f72 6365 2069 7320      if force is 
+000068f0: 4661 6c73 653a 0a20 2020 2020 2020 2020  False:.         
+00006900: 2020 206c 6f67 6765 722e 696e 666f 2866     logger.info(f
+00006910: 2253 746f 702c 206f 7574 7075 7420 6578  "Stop, output ex
+00006920: 6973 7473 2061 6c72 6561 6479 207b 6f75  ists already {ou
+00006930: 7470 7574 5f70 6174 687d 2229 0a20 2020  tput_path}").   
+00006940: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
+00006950: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00006960: 2020 2020 2020 2020 2020 6766 6f2e 7265            gfo.re
+00006970: 6d6f 7665 286f 7574 7075 745f 7061 7468  move(output_path
+00006980: 290a 2020 2020 6966 2069 6e70 7574 5f6c  ).    if input_l
+00006990: 6179 6572 2069 7320 4e6f 6e65 3a0a 2020  ayer is None:.  
+000069a0: 2020 2020 2020 696e 7075 745f 6c61 7965        input_laye
+000069b0: 7220 3d20 6766 6f2e 6765 745f 6f6e 6c79  r = gfo.get_only
+000069c0: 5f6c 6179 6572 2869 6e70 7574 5f70 6174  _layer(input_pat
+000069d0: 6829 0a20 2020 2069 6620 6f75 7470 7574  h).    if output
+000069e0: 5f6c 6179 6572 2069 7320 4e6f 6e65 3a0a  _layer is None:.
+000069f0: 2020 2020 2020 2020 6f75 7470 7574 5f6c          output_l
+00006a00: 6179 6572 203d 2067 666f 2e67 6574 5f64  ayer = gfo.get_d
+00006a10: 6566 6175 6c74 5f6c 6179 6572 286f 7574  efault_layer(out
+00006a20: 7075 745f 7061 7468 290a 2020 2020 6966  put_path).    if
+00006a30: 2069 7369 6e73 7461 6e63 6528 666f 7263   isinstance(forc
+00006a40: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+00006a50: 7974 7970 652c 2047 656f 6d65 7472 7954  ytype, GeometryT
+00006a60: 7970 6529 3a0a 2020 2020 2020 2020 666f  ype):.        fo
+00006a70: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
+00006a80: 7472 7974 7970 6520 3d20 666f 7263 655f  trytype = force_
+00006a90: 6f75 7470 7574 5f67 656f 6d65 7472 7974  output_geometryt
+00006aa0: 7970 652e 6e61 6d65 0a0a 2020 2020 2320  ype.name..    # 
+00006ab0: 4368 6563 6b20 6966 2077 6520 7761 6e74  Check if we want
+00006ac0: 2074 6f20 7072 6573 6572 7665 2074 6865   to preserve the
+00006ad0: 2066 6964 2069 6e20 7468 6520 6f75 7470   fid in the outp
+00006ae0: 7574 0a20 2020 2070 7265 7365 7276 655f  ut.    preserve_
+00006af0: 6669 6420 3d20 4661 6c73 650a 2020 2020  fid = False.    
+00006b00: 6966 206e 6f74 2065 7870 6c6f 6465 636f  if not explodeco
+00006b10: 6c6c 6563 7469 6f6e 7320 616e 6420 6766  llections and gf
+00006b20: 6f2e 6765 745f 6472 6976 6572 286f 7574  o.get_driver(out
+00006b30: 7075 745f 7061 7468 2920 3d3d 2022 4750  put_path) == "GP
+00006b40: 4b47 223a 0a20 2020 2020 2020 2070 7265  KG":.        pre
+00006b50: 7365 7276 655f 6669 6420 3d20 5472 7565  serve_fid = True
+00006b60: 0a0a 2020 2020 2320 5072 6570 6172 6520  ..    # Prepare 
+00006b70: 7768 6572 655f 746f 5f61 7070 6c79 2061  where_to_apply a
+00006b80: 6e64 2066 696c 7465 725f 6e75 6c6c 5f67  nd filter_null_g
+00006b90: 656f 6d73 0a20 2020 2069 6620 7768 6572  eoms.    if wher
+00006ba0: 655f 706f 7374 2069 7320 6e6f 7420 4e6f  e_post is not No
+00006bb0: 6e65 3a0a 2020 2020 2020 2020 6966 2077  ne:.        if w
+00006bc0: 6865 7265 5f70 6f73 7420 3d3d 2022 223a  here_post == "":
+00006bd0: 0a20 2020 2020 2020 2020 2020 2077 6865  .            whe
+00006be0: 7265 5f70 6f73 7420 3d20 4e6f 6e65 0a20  re_post = None. 
+00006bf0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00006c00: 2020 2020 2020 2020 2023 2041 6c77 6179           # Alway
+00006c10: 7320 7365 7420 6765 6f6d 6574 7279 636f  s set geometryco
+00006c20: 6c75 6d6e 2074 6f20 2267 656f 6d22 2c20  lumn to "geom", 
+00006c30: 6265 6361 7573 6520 7768 6572 655f 706f  because where_po
+00006c40: 7374 2070 6172 616d 6574 6572 2066 6f72  st parameter for
+00006c50: 2073 6870 0a20 2020 2020 2020 2020 2020   shp.           
+00006c60: 2023 2064 6f65 736e 2774 2073 6565 6d20   # doesn't seem 
+00006c70: 746f 2077 6f72 6b2e 2e2e 2073 6f20 6372  to work... so cr
+00006c80: 6561 7465 2074 656d 7020 7061 7274 6961  eate temp partia
+00006c90: 6c20 6669 6c65 7320 616c 7761 7973 2061  l files always a
+00006ca0: 7320 6770 6b67 2e0a 2020 2020 2020 2020  s gpkg..        
+00006cb0: 2020 2020 7768 6572 655f 706f 7374 203d      where_post =
+00006cc0: 2077 6865 7265 5f70 6f73 742e 666f 726d   where_post.form
+00006cd0: 6174 2867 656f 6d65 7472 7963 6f6c 756d  at(geometrycolum
+00006ce0: 6e3d 2267 656f 6d22 290a 0a20 2020 2023  n="geom")..    #
+00006cf0: 2050 7265 7061 7265 2074 6d70 2066 696c   Prepare tmp fil
+00006d00: 6573 0a20 2020 2074 6d70 5f64 6972 203d  es.    tmp_dir =
+00006d10: 205f 696f 5f75 7469 6c2e 6372 6561 7465   _io_util.create
+00006d20: 5f74 656d 7064 6972 2866 2267 656f 6669  _tempdir(f"geofi
+00006d30: 6c65 6f70 732f 7b6f 7065 7261 7469 6f6e  leops/{operation
+00006d40: 2e76 616c 7565 7d22 290a 2020 2020 6c6f  .value}").    lo
+00006d50: 6767 6572 2e64 6562 7567 2866 2253 7461  gger.debug(f"Sta
+00006d60: 7274 2063 616c 6375 6c61 7469 6f6e 2074  rt calculation t
+00006d70: 6f20 7465 6d70 2066 696c 6573 2069 6e20  o temp files in 
+00006d80: 7b74 6d70 5f64 6972 7d22 290a 0a20 2020  {tmp_dir}")..   
+00006d90: 2074 7279 3a0a 2020 2020 2020 2020 2320   try:.        # 
+00006da0: 4361 6c63 756c 6174 6520 7468 6520 6265  Calculate the be
+00006db0: 7374 206e 756d 6265 7220 6f66 2070 6172  st number of par
+00006dc0: 616c 6c65 6c20 7072 6f63 6573 7365 7320  allel processes 
+00006dd0: 616e 6420 6261 7463 6865 7320 666f 720a  and batches for.
+00006de0: 2020 2020 2020 2020 2320 7468 6520 6176          # the av
+00006df0: 6169 6c61 626c 6520 7265 736f 7572 6365  ailable resource
+00006e00: 730a 2020 2020 2020 2020 7072 6f63 6573  s.        proces
+00006e10: 7369 6e67 5f70 6172 616d 7320 3d20 5f70  sing_params = _p
+00006e20: 7265 7061 7265 5f70 726f 6365 7373 696e  repare_processin
+00006e30: 675f 7061 7261 6d73 280a 2020 2020 2020  g_params(.      
+00006e40: 2020 2020 2020 696e 7075 745f 7061 7468        input_path
+00006e50: 3d69 6e70 7574 5f70 6174 682c 0a20 2020  =input_path,.   
+00006e60: 2020 2020 2020 2020 2069 6e70 7574 5f6c           input_l
+00006e70: 6179 6572 3d69 6e70 7574 5f6c 6179 6572  ayer=input_layer
+00006e80: 2c0a 2020 2020 2020 2020 2020 2020 6e62  ,.            nb
+00006e90: 5f70 6172 616c 6c65 6c3d 6e62 5f70 6172  _parallel=nb_par
+00006ea0: 616c 6c65 6c2c 0a20 2020 2020 2020 2020  allel,.         
+00006eb0: 2020 2062 6174 6368 7369 7a65 3d62 6174     batchsize=bat
+00006ec0: 6368 7369 7a65 2c0a 2020 2020 2020 2020  chsize,.        
+00006ed0: 2020 2020 7061 7261 6c6c 656c 697a 6174      parallelizat
+00006ee0: 696f 6e5f 636f 6e66 6967 3d70 6172 616c  ion_config=paral
+00006ef0: 6c65 6c69 7a61 7469 6f6e 5f63 6f6e 6669  lelization_confi
+00006f00: 672c 0a20 2020 2020 2020 2020 2020 2074  g,.            t
+00006f10: 6d70 5f64 6972 3d74 6d70 5f64 6972 2c0a  mp_dir=tmp_dir,.
+00006f20: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00006f30: 2020 6173 7365 7274 2070 726f 6365 7373    assert process
+00006f40: 696e 675f 7061 7261 6d73 2e62 6174 6368  ing_params.batch
+00006f50: 6573 2069 7320 6e6f 7420 4e6f 6e65 0a0a  es is not None..
+00006f60: 2020 2020 2020 2020 6c6f 6767 6572 2e69          logger.i
+00006f70: 6e66 6f28 0a20 2020 2020 2020 2020 2020  nfo(.           
+00006f80: 2066 2253 7461 7274 2070 726f 6365 7373   f"Start process
+00006f90: 696e 6720 287b 7072 6f63 6573 7369 6e67  ing ({processing
+00006fa0: 5f70 6172 616d 732e 6e62 5f70 6172 616c  _params.nb_paral
+00006fb0: 6c65 6c7d 2022 0a20 2020 2020 2020 2020  lel} ".         
+00006fc0: 2020 2066 2270 6172 616c 6c65 6c20 776f     f"parallel wo
+00006fd0: 726b 6572 732c 2062 6174 6368 2073 697a  rkers, batch siz
+00006fe0: 653a 207b 7072 6f63 6573 7369 6e67 5f70  e: {processing_p
+00006ff0: 6172 616d 732e 6261 7463 6873 697a 657d  arams.batchsize}
+00007000: 2922 0a20 2020 2020 2020 2029 0a20 2020  )".        ).   
+00007010: 2020 2020 2023 2050 726f 6365 7373 696e       # Processin
+00007020: 6720 696e 2074 6872 6561 6473 2069 7320  g in threads is 
+00007030: 3278 2066 6173 7465 7220 666f 7220 736d  2x faster for sm
+00007040: 616c 6c20 6461 7461 7365 7473 2028 6f6e  all datasets (on
+00007050: 2057 696e 646f 7773 290a 2020 2020 2020   Windows).      
+00007060: 2020 6361 6c63 756c 6174 655f 696e 5f74    calculate_in_t
+00007070: 6872 6561 6473 203d 2028 0a20 2020 2020  hreads = (.     
+00007080: 2020 2020 2020 2054 7275 6520 6966 2070         True if p
+00007090: 726f 6365 7373 696e 675f 7061 7261 6d73  rocessing_params
+000070a0: 2e6e 625f 726f 7773 5f74 6f5f 7072 6f63  .nb_rows_to_proc
+000070b0: 6573 7320 3c3d 2031 3030 2065 6c73 6520  ess <= 100 else 
+000070c0: 4661 6c73 650a 2020 2020 2020 2020 290a  False.        ).
+000070d0: 2020 2020 2020 2020 7769 7468 205f 7072          with _pr
+000070e0: 6f63 6573 7369 6e67 5f75 7469 6c2e 506f  ocessing_util.Po
+000070f0: 6f6c 6564 4578 6563 7574 6f72 4661 6374  oledExecutorFact
+00007100: 6f72 7928 0a20 2020 2020 2020 2020 2020  ory(.           
+00007110: 2074 6872 6561 6470 6f6f 6c3d 6361 6c63   threadpool=calc
+00007120: 756c 6174 655f 696e 5f74 6872 6561 6473  ulate_in_threads
+00007130: 2c0a 2020 2020 2020 2020 2020 2020 6d61  ,.            ma
+00007140: 785f 776f 726b 6572 733d 7072 6f63 6573  x_workers=proces
+00007150: 7369 6e67 5f70 6172 616d 732e 6e62 5f70  sing_params.nb_p
+00007160: 6172 616c 6c65 6c2c 0a20 2020 2020 2020  arallel,.       
+00007170: 2020 2020 2069 6e69 7469 616c 697a 6572       initializer
+00007180: 3d5f 7072 6f63 6573 7369 6e67 5f75 7469  =_processing_uti
+00007190: 6c2e 696e 6974 6961 6c69 7a65 5f77 6f72  l.initialize_wor
+000071a0: 6b65 7228 292c 0a20 2020 2020 2020 2029  ker(),.        )
+000071b0: 2061 7320 6361 6c63 756c 6174 655f 706f   as calculate_po
+000071c0: 6f6c 3a0a 2020 2020 2020 2020 2020 2020  ol:.            
+000071d0: 2320 5072 6570 6172 6520 6f75 7470 7574  # Prepare output
+000071e0: 2066 696c 656e 616d 650a 2020 2020 2020   filename.      
+000071f0: 2020 2020 2020 746d 705f 6f75 7470 7574        tmp_output
+00007200: 5f70 6174 6820 3d20 746d 705f 6469 7220  _path = tmp_dir 
+00007210: 2f20 6f75 7470 7574 5f70 6174 682e 6e61  / output_path.na
+00007220: 6d65 0a0a 2020 2020 2020 2020 2020 2020  me..            
+00007230: 6261 7463 6865 733a 2044 6963 745b 696e  batches: Dict[in
+00007240: 742c 2064 6963 745d 203d 207b 7d0a 2020  t, dict] = {}.  
+00007250: 2020 2020 2020 2020 2020 6675 7475 7265            future
+00007260: 5f74 6f5f 6261 7463 685f 6964 203d 207b  _to_batch_id = {
+00007270: 7d0a 0a20 2020 2020 2020 2020 2020 2066  }..            f
+00007280: 6f72 2062 6174 6368 5f69 642c 2062 6174  or batch_id, bat
+00007290: 6368 5f66 696c 7465 7220 696e 2065 6e75  ch_filter in enu
+000072a0: 6d65 7261 7465 2870 726f 6365 7373 696e  merate(processin
+000072b0: 675f 7061 7261 6d73 2e62 6174 6368 6573  g_params.batches
+000072c0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+000072d0: 2020 2062 6174 6368 6573 5b62 6174 6368     batches[batch
+000072e0: 5f69 645d 203d 207b 7d0a 2020 2020 2020  _id] = {}.      
+000072f0: 2020 2020 2020 2020 2020 6261 7463 6865            batche
+00007300: 735b 6261 7463 685f 6964 5d5b 226c 6179  s[batch_id]["lay
+00007310: 6572 225d 203d 206f 7574 7075 745f 6c61  er"] = output_la
+00007320: 7965 720a 0a20 2020 2020 2020 2020 2020  yer..           
+00007330: 2020 2020 2023 204f 7574 7075 7420 6561       # Output ea
+00007340: 6368 2062 6174 6368 2074 6f20 6120 7365  ch batch to a se
+00007350: 7065 7261 7465 2074 656d 706f 7261 7279  perate temporary
+00007360: 2066 696c 652c 206f 7468 6572 7769 7365   file, otherwise
+00007370: 2074 6865 7265 0a20 2020 2020 2020 2020   there.         
+00007380: 2020 2020 2020 2023 2061 7265 2074 696d         # are tim
+00007390: 656f 7574 2069 7373 7565 7320 7768 656e  eout issues when
+000073a0: 2070 726f 6365 7373 696e 6720 6c61 7267   processing larg
+000073b0: 6520 6669 6c65 730a 2020 2020 2020 2020  e files.        
+000073c0: 2020 2020 2020 2020 6f75 7470 7574 5f74          output_t
+000073d0: 6d70 5f70 6172 7469 616c 5f70 6174 6820  mp_partial_path 
+000073e0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+000073f0: 2020 2020 2020 2020 746d 705f 6469 7220          tmp_dir 
+00007400: 2f20 6622 7b6f 7574 7075 745f 7061 7468  / f"{output_path
+00007410: 2e73 7465 6d7d 5f7b 6261 7463 685f 6964  .stem}_{batch_id
+00007420: 7d2e 6770 6b67 220a 2020 2020 2020 2020  }.gpkg".        
+00007430: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00007440: 2020 2020 2020 2020 2020 6261 7463 6865            batche
+00007450: 735b 6261 7463 685f 6964 5d5b 2274 6d70  s[batch_id]["tmp
+00007460: 5f70 6172 7469 616c 5f6f 7574 7075 745f  _partial_output_
+00007470: 7061 7468 225d 203d 206f 7574 7075 745f  path"] = output_
+00007480: 746d 705f 7061 7274 6961 6c5f 7061 7468  tmp_partial_path
+00007490: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000074a0: 2062 6174 6368 6573 5b62 6174 6368 5f69   batches[batch_i
+000074b0: 645d 5b22 6669 6c74 6572 225d 203d 2062  d]["filter"] = b
+000074c0: 6174 6368 5f66 696c 7465 720a 0a20 2020  atch_filter..   
+000074d0: 2020 2020 2020 2020 2020 2020 2023 2052               # R
+000074e0: 656d 6172 6b3a 2074 6869 7320 7465 6d70  emark: this temp
+000074f0: 2066 696c 6520 646f 6573 6e27 7420 6e65   file doesn't ne
+00007500: 6564 2073 7061 7469 616c 2069 6e64 6578  ed spatial index
+00007510: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007520: 2023 2052 656d 6172 6b3a 2062 6563 6175   # Remark: becau
+00007530: 7365 2066 6f72 6365 5f6f 7574 7075 745f  se force_output_
+00007540: 6765 6f6d 6574 7279 7479 7065 2066 6f72  geometrytype for
+00007550: 2047 656f 4461 7461 4672 616d 650a 2020   GeoDataFrame.  
+00007560: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00007570: 6f70 6572 6174 696f 6e73 2069 7320 2861  operations is (a
+00007580: 206c 6f74 2920 6d6f 7265 206c 696d 6974   lot) more limit
+00007590: 6564 2074 6861 6e20 6764 616c 2d62 6173  ed than gdal-bas
+000075a0: 6564 2c20 7468 6520 6764 616c 2076 6572  ed, the gdal ver
+000075b0: 7369 6f6e 0a20 2020 2020 2020 2020 2020  sion.           
+000075c0: 2020 2020 2023 2069 7320 7573 6564 206c       # is used l
+000075d0: 6174 6572 206f 6e20 7768 656e 2074 6865  ater on when the
+000075e0: 2072 6573 756c 7473 2061 7265 206d 6572   results are mer
+000075f0: 6765 6420 746f 2074 6865 2072 6573 756c  ged to the resul
+00007600: 7420 6669 6c65 2e0a 2020 2020 2020 2020  t file..        
+00007610: 2020 2020 2020 2020 6675 7475 7265 203d          future =
+00007620: 2063 616c 6375 6c61 7465 5f70 6f6f 6c2e   calculate_pool.
+00007630: 7375 626d 6974 280a 2020 2020 2020 2020  submit(.        
+00007640: 2020 2020 2020 2020 2020 2020 5f61 7070              _app
+00007650: 6c79 5f67 656f 6f70 6572 6174 696f 6e2c  ly_geooperation,
+00007660: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007670: 2020 2020 2069 6e70 7574 5f70 6174 683d       input_path=
+00007680: 696e 7075 745f 7061 7468 2c0a 2020 2020  input_path,.    
+00007690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000076a0: 6f75 7470 7574 5f70 6174 683d 6f75 7470  output_path=outp
+000076b0: 7574 5f74 6d70 5f70 6172 7469 616c 5f70  ut_tmp_partial_p
+000076c0: 6174 682c 0a20 2020 2020 2020 2020 2020  ath,.           
+000076d0: 2020 2020 2020 2020 206f 7065 7261 7469           operati
+000076e0: 6f6e 3d6f 7065 7261 7469 6f6e 2c0a 2020  on=operation,.  
 000076f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007700: 2020 2020 746d 705f 6469 7220 2f20 6622      tmp_dir / f"
-00007710: 7b6f 7574 7075 745f 7061 7468 2e73 7465  {output_path.ste
-00007720: 6d7d 5f7b 6261 7463 685f 6964 7d2e 6770  m}_{batch_id}.gp
-00007730: 6b67 220d 0a20 2020 2020 2020 2020 2020  kg"..           
-00007740: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-00007750: 2020 2020 2020 2020 6261 7463 6865 735b          batches[
-00007760: 6261 7463 685f 6964 5d5b 2274 6d70 5f70  batch_id]["tmp_p
-00007770: 6172 7469 616c 5f6f 7574 7075 745f 7061  artial_output_pa
-00007780: 7468 225d 203d 206f 7574 7075 745f 746d  th"] = output_tm
-00007790: 705f 7061 7274 6961 6c5f 7061 7468 0d0a  p_partial_path..
-000077a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000077b0: 6261 7463 6865 735b 6261 7463 685f 6964  batches[batch_id
-000077c0: 5d5b 2266 696c 7465 7222 5d20 3d20 6261  ]["filter"] = ba
-000077d0: 7463 685f 6669 6c74 6572 0d0a 0d0a 2020  tch_filter....  
-000077e0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-000077f0: 5265 6d61 726b 3a20 7468 6973 2074 656d  Remark: this tem
-00007800: 7020 6669 6c65 2064 6f65 736e 2774 206e  p file doesn't n
-00007810: 6565 6420 7370 6174 6961 6c20 696e 6465  eed spatial inde
-00007820: 780d 0a20 2020 2020 2020 2020 2020 2020  x..             
-00007830: 2020 2023 2052 656d 6172 6b3a 2062 6563     # Remark: bec
-00007840: 6175 7365 2066 6f72 6365 5f6f 7574 7075  ause force_outpu
-00007850: 745f 6765 6f6d 6574 7279 7479 7065 2066  t_geometrytype f
-00007860: 6f72 2047 656f 4461 7461 4672 616d 650d  or GeoDataFrame.
-00007870: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007880: 2023 206f 7065 7261 7469 6f6e 7320 6973   # operations is
-00007890: 2028 6120 6c6f 7429 206d 6f72 6520 6c69   (a lot) more li
-000078a0: 6d69 7465 6420 7468 616e 2067 6461 6c2d  mited than gdal-
-000078b0: 6261 7365 642c 2074 6865 2067 6461 6c20  based, the gdal 
-000078c0: 7665 7273 696f 6e0d 0a20 2020 2020 2020  version..       
-000078d0: 2020 2020 2020 2020 2023 2069 7320 7573           # is us
-000078e0: 6564 206c 6174 6572 206f 6e20 7768 656e  ed later on when
-000078f0: 2074 6865 2072 6573 756c 7473 2061 7265   the results are
-00007900: 206d 6572 6765 6420 746f 2074 6865 2072   merged to the r
-00007910: 6573 756c 7420 6669 6c65 2e0d 0a20 2020  esult file...   
-00007920: 2020 2020 2020 2020 2020 2020 2066 7574               fut
-00007930: 7572 6520 3d20 6361 6c63 756c 6174 655f  ure = calculate_
-00007940: 706f 6f6c 2e73 7562 6d69 7428 0d0a 2020  pool.submit(..  
-00007950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007960: 2020 5f61 7070 6c79 5f67 656f 6f70 6572    _apply_geooper
-00007970: 6174 696f 6e2c 0d0a 2020 2020 2020 2020  ation,..        
-00007980: 2020 2020 2020 2020 2020 2020 696e 7075              inpu
-00007990: 745f 7061 7468 3d69 6e70 7574 5f70 6174  t_path=input_pat
-000079a0: 682c 0d0a 2020 2020 2020 2020 2020 2020  h,..            
-000079b0: 2020 2020 2020 2020 6f75 7470 7574 5f70          output_p
-000079c0: 6174 683d 6f75 7470 7574 5f74 6d70 5f70  ath=output_tmp_p
-000079d0: 6172 7469 616c 5f70 6174 682c 0d0a 2020  artial_path,..  
-000079e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000079f0: 2020 6f70 6572 6174 696f 6e3d 6f70 6572    operation=oper
-00007a00: 6174 696f 6e2c 0d0a 2020 2020 2020 2020  ation,..        
-00007a10: 2020 2020 2020 2020 2020 2020 6f70 6572              oper
-00007a20: 6174 696f 6e5f 7061 7261 6d73 3d6f 7065  ation_params=ope
-00007a30: 7261 7469 6f6e 5f70 6172 616d 732c 0d0a  ration_params,..
-00007a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007a50: 2020 2020 696e 7075 745f 6c61 7965 723d      input_layer=
-00007a60: 696e 7075 745f 6c61 7965 722c 0d0a 2020  input_layer,..  
-00007a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007a80: 2020 636f 6c75 6d6e 733d 636f 6c75 6d6e    columns=column
-00007a90: 732c 0d0a 2020 2020 2020 2020 2020 2020  s,..            
-00007aa0: 2020 2020 2020 2020 6f75 7470 7574 5f6c          output_l
-00007ab0: 6179 6572 3d6f 7574 7075 745f 6c61 7965  ayer=output_laye
-00007ac0: 722c 0d0a 2020 2020 2020 2020 2020 2020  r,..            
-00007ad0: 2020 2020 2020 2020 7768 6572 653d 6261          where=ba
-00007ae0: 7463 685f 6669 6c74 6572 2c0d 0a20 2020  tch_filter,..   
-00007af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007b00: 2065 7870 6c6f 6465 636f 6c6c 6563 7469   explodecollecti
-00007b10: 6f6e 733d 6578 706c 6f64 6563 6f6c 6c65  ons=explodecolle
-00007b20: 6374 696f 6e73 2c0d 0a20 2020 2020 2020  ctions,..       
-00007b30: 2020 2020 2020 2020 2020 2020 2067 7269               gri
-00007b40: 6473 697a 653d 6772 6964 7369 7a65 2c0d  dsize=gridsize,.
-00007b50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007b60: 2020 2020 206b 6565 705f 656d 7074 795f       keep_empty_
-00007b70: 6765 6f6d 733d 6b65 6570 5f65 6d70 7479  geoms=keep_empty
-00007b80: 5f67 656f 6d73 2c0d 0a20 2020 2020 2020  _geoms,..       
-00007b90: 2020 2020 2020 2020 2020 2020 2070 7265               pre
-00007ba0: 7365 7276 655f 6669 643d 7072 6573 6572  serve_fid=preser
-00007bb0: 7665 5f66 6964 2c0d 0a20 2020 2020 2020  ve_fid,..       
-00007bc0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00007bd0: 6365 3d66 6f72 6365 2c0d 0a20 2020 2020  ce=force,..     
-00007be0: 2020 2020 2020 2020 2020 2029 0d0a 2020             )..  
-00007bf0: 2020 2020 2020 2020 2020 2020 2020 6675                fu
-00007c00: 7475 7265 5f74 6f5f 6261 7463 685f 6964  ture_to_batch_id
-00007c10: 5b66 7574 7572 655d 203d 2062 6174 6368  [future] = batch
-00007c20: 5f69 640d 0a0d 0a20 2020 2020 2020 2020  _id....         
-00007c30: 2020 2023 204c 6f6f 7020 7469 6c6c 2061     # Loop till a
-00007c40: 6c6c 2070 6172 616c 6c65 6c20 7072 6f63  ll parallel proc
-00007c50: 6573 7365 7320 6172 6520 7265 6164 792c  esses are ready,
-00007c60: 2062 7574 2070 726f 6365 7373 2065 6163   but process eac
-00007c70: 6820 6f6e 650d 0a20 2020 2020 2020 2020  h one..         
-00007c80: 2020 2023 2074 6861 7420 6973 2072 6561     # that is rea
-00007c90: 6479 2061 6c72 6561 6479 0d0a 2020 2020  dy already..    
-00007ca0: 2020 2020 2020 2020 2320 5265 6d61 726b          # Remark
-00007cb0: 3a20 6361 6c63 756c 6174 696e 6720 6361  : calculating ca
-00007cc0: 6e20 6265 2064 6f6e 6520 696e 2070 6172  n be done in par
-00007cd0: 616c 6c65 6c2c 2062 7574 206f 6e6c 7920  allel, but only 
-00007ce0: 6f6e 6520 7072 6f63 6573 730d 0a20 2020  one process..   
-00007cf0: 2020 2020 2020 2020 2023 2063 616e 2077           # can w
-00007d00: 7269 7465 2074 6f20 7468 6520 7361 6d65  rite to the same
-00007d10: 206f 7574 7075 7420 6669 6c65 2061 7420   output file at 
-00007d20: 7468 6520 7469 6d65 2e2e 2e0d 0a20 2020  the time.....   
-00007d30: 2020 2020 2020 2020 2073 7461 7274 5f74           start_t
-00007d40: 696d 6520 3d20 6461 7465 7469 6d65 2e6e  ime = datetime.n
-00007d50: 6f77 2829 0d0a 2020 2020 2020 2020 2020  ow()..          
-00007d60: 2020 6e62 5f64 6f6e 6520 3d20 300d 0a20    nb_done = 0.. 
-00007d70: 2020 2020 2020 2020 2020 206e 625f 6261             nb_ba
-00007d80: 7463 6865 7320 3d20 6c65 6e28 7072 6f63  tches = len(proc
-00007d90: 6573 7369 6e67 5f70 6172 616d 732e 6261  essing_params.ba
-00007da0: 7463 6865 7329 0d0a 2020 2020 2020 2020  tches)..        
-00007db0: 2020 2020 5f67 656e 6572 616c 5f75 7469      _general_uti
-00007dc0: 6c2e 7265 706f 7274 5f70 726f 6772 6573  l.report_progres
-00007dd0: 7328 0d0a 2020 2020 2020 2020 2020 2020  s(..            
-00007de0: 2020 2020 7374 6172 745f 7469 6d65 2c0d      start_time,.
-00007df0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007e00: 206e 625f 646f 6e65 2c0d 0a20 2020 2020   nb_done,..     
-00007e10: 2020 2020 2020 2020 2020 206e 625f 746f             nb_to
-00007e20: 646f 3d6e 625f 6261 7463 6865 732c 0d0a  do=nb_batches,..
+00007700: 2020 6f70 6572 6174 696f 6e5f 7061 7261    operation_para
+00007710: 6d73 3d6f 7065 7261 7469 6f6e 5f70 6172  ms=operation_par
+00007720: 616d 732c 0a20 2020 2020 2020 2020 2020  ams,.           
+00007730: 2020 2020 2020 2020 2069 6e70 7574 5f6c           input_l
+00007740: 6179 6572 3d69 6e70 7574 5f6c 6179 6572  ayer=input_layer
+00007750: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00007760: 2020 2020 2020 636f 6c75 6d6e 733d 636f        columns=co
+00007770: 6c75 6d6e 732c 0a20 2020 2020 2020 2020  lumns,.         
+00007780: 2020 2020 2020 2020 2020 206f 7574 7075             outpu
+00007790: 745f 6c61 7965 723d 6f75 7470 7574 5f6c  t_layer=output_l
+000077a0: 6179 6572 2c0a 2020 2020 2020 2020 2020  ayer,.          
+000077b0: 2020 2020 2020 2020 2020 7768 6572 653d            where=
+000077c0: 6261 7463 685f 6669 6c74 6572 2c0a 2020  batch_filter,.  
+000077d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000077e0: 2020 6578 706c 6f64 6563 6f6c 6c65 6374    explodecollect
+000077f0: 696f 6e73 3d65 7870 6c6f 6465 636f 6c6c  ions=explodecoll
+00007800: 6563 7469 6f6e 732c 0a20 2020 2020 2020  ections,.       
+00007810: 2020 2020 2020 2020 2020 2020 2067 7269               gri
+00007820: 6473 697a 653d 6772 6964 7369 7a65 2c0a  dsize=gridsize,.
+00007830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007840: 2020 2020 6b65 6570 5f65 6d70 7479 5f67      keep_empty_g
+00007850: 656f 6d73 3d6b 6565 705f 656d 7074 795f  eoms=keep_empty_
+00007860: 6765 6f6d 732c 0a20 2020 2020 2020 2020  geoms,.         
+00007870: 2020 2020 2020 2020 2020 2070 7265 7365             prese
+00007880: 7276 655f 6669 643d 7072 6573 6572 7665  rve_fid=preserve
+00007890: 5f66 6964 2c0a 2020 2020 2020 2020 2020  _fid,.          
+000078a0: 2020 2020 2020 2020 2020 666f 7263 653d            force=
+000078b0: 666f 7263 652c 0a20 2020 2020 2020 2020  force,.         
+000078c0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+000078d0: 2020 2020 2020 2020 2066 7574 7572 655f           future_
+000078e0: 746f 5f62 6174 6368 5f69 645b 6675 7475  to_batch_id[futu
+000078f0: 7265 5d20 3d20 6261 7463 685f 6964 0a0a  re] = batch_id..
+00007900: 2020 2020 2020 2020 2020 2020 2320 4c6f              # Lo
+00007910: 6f70 2074 696c 6c20 616c 6c20 7061 7261  op till all para
+00007920: 6c6c 656c 2070 726f 6365 7373 6573 2061  llel processes a
+00007930: 7265 2072 6561 6479 2c20 6275 7420 7072  re ready, but pr
+00007940: 6f63 6573 7320 6561 6368 206f 6e65 0a20  ocess each one. 
+00007950: 2020 2020 2020 2020 2020 2023 2074 6861             # tha
+00007960: 7420 6973 2072 6561 6479 2061 6c72 6561  t is ready alrea
+00007970: 6479 0a20 2020 2020 2020 2020 2020 2023  dy.            #
+00007980: 2052 656d 6172 6b3a 2063 616c 6375 6c61   Remark: calcula
+00007990: 7469 6e67 2063 616e 2062 6520 646f 6e65  ting can be done
+000079a0: 2069 6e20 7061 7261 6c6c 656c 2c20 6275   in parallel, bu
+000079b0: 7420 6f6e 6c79 206f 6e65 2070 726f 6365  t only one proce
+000079c0: 7373 0a20 2020 2020 2020 2020 2020 2023  ss.            #
+000079d0: 2063 616e 2077 7269 7465 2074 6f20 7468   can write to th
+000079e0: 6520 7361 6d65 206f 7574 7075 7420 6669  e same output fi
+000079f0: 6c65 2061 7420 7468 6520 7469 6d65 2e2e  le at the time..
+00007a00: 2e0a 2020 2020 2020 2020 2020 2020 7374  ..            st
+00007a10: 6172 745f 7469 6d65 203d 2064 6174 6574  art_time = datet
+00007a20: 696d 652e 6e6f 7728 290a 2020 2020 2020  ime.now().      
+00007a30: 2020 2020 2020 6e62 5f64 6f6e 6520 3d20        nb_done = 
+00007a40: 300a 2020 2020 2020 2020 2020 2020 6e62  0.            nb
+00007a50: 5f62 6174 6368 6573 203d 206c 656e 2870  _batches = len(p
+00007a60: 726f 6365 7373 696e 675f 7061 7261 6d73  rocessing_params
+00007a70: 2e62 6174 6368 6573 290a 2020 2020 2020  .batches).      
+00007a80: 2020 2020 2020 5f67 656e 6572 616c 5f75        _general_u
+00007a90: 7469 6c2e 7265 706f 7274 5f70 726f 6772  til.report_progr
+00007aa0: 6573 7328 0a20 2020 2020 2020 2020 2020  ess(.           
+00007ab0: 2020 2020 2073 7461 7274 5f74 696d 652c       start_time,
+00007ac0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007ad0: 206e 625f 646f 6e65 2c0a 2020 2020 2020   nb_done,.      
+00007ae0: 2020 2020 2020 2020 2020 6e62 5f74 6f64            nb_tod
+00007af0: 6f3d 6e62 5f62 6174 6368 6573 2c0a 2020  o=nb_batches,.  
+00007b00: 2020 2020 2020 2020 2020 2020 2020 6f70                op
+00007b10: 6572 6174 696f 6e3d 6f70 6572 6174 696f  eration=operatio
+00007b20: 6e2e 7661 6c75 652c 0a20 2020 2020 2020  n.value,.       
+00007b30: 2020 2020 2020 2020 206e 625f 7061 7261           nb_para
+00007b40: 6c6c 656c 3d70 726f 6365 7373 696e 675f  llel=processing_
+00007b50: 7061 7261 6d73 2e6e 625f 7061 7261 6c6c  params.nb_parall
+00007b60: 656c 2c0a 2020 2020 2020 2020 2020 2020  el,.            
+00007b70: 290a 2020 2020 2020 2020 2020 2020 666f  ).            fo
+00007b80: 7220 6675 7475 7265 2069 6e20 6675 7475  r future in futu
+00007b90: 7265 732e 6173 5f63 6f6d 706c 6574 6564  res.as_completed
+00007ba0: 2866 7574 7572 655f 746f 5f62 6174 6368  (future_to_batch
+00007bb0: 5f69 6429 3a0a 2020 2020 2020 2020 2020  _id):.          
+00007bc0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+00007bd0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00007be0: 6573 7361 6765 203d 2066 7574 7572 652e  essage = future.
+00007bf0: 7265 7375 6c74 2829 0a20 2020 2020 2020  result().       
+00007c00: 2020 2020 2020 2020 2020 2020 206c 6f67               log
+00007c10: 6765 722e 6465 6275 6728 6d65 7373 6167  ger.debug(messag
+00007c20: 6529 0a0a 2020 2020 2020 2020 2020 2020  e)..            
+00007c30: 2020 2020 2020 2020 2320 4966 2074 6865          # If the
+00007c40: 2063 616c 6375 6c61 7465 2067 6176 6520   calculate gave 
+00007c50: 7265 7375 6c74 732c 2063 6f70 7920 746f  results, copy to
+00007c60: 206f 7574 7075 740a 2020 2020 2020 2020   output.        
+00007c70: 2020 2020 2020 2020 2020 2020 6261 7463              batc
+00007c80: 685f 6964 203d 2066 7574 7572 655f 746f  h_id = future_to
+00007c90: 5f62 6174 6368 5f69 645b 6675 7475 7265  _batch_id[future
+00007ca0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00007cb0: 2020 2020 2020 746d 705f 7061 7274 6961        tmp_partia
+00007cc0: 6c5f 6f75 7470 7574 5f70 6174 6820 3d20  l_output_path = 
+00007cd0: 6261 7463 6865 735b 6261 7463 685f 6964  batches[batch_id
+00007ce0: 5d5b 0a20 2020 2020 2020 2020 2020 2020  ][.             
+00007cf0: 2020 2020 2020 2020 2020 2022 746d 705f             "tmp_
+00007d00: 7061 7274 6961 6c5f 6f75 7470 7574 5f70  partial_output_p
+00007d10: 6174 6822 0a20 2020 2020 2020 2020 2020  ath".           
+00007d20: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
+00007d30: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00007d40: 6620 280a 2020 2020 2020 2020 2020 2020  f (.            
+00007d50: 2020 2020 2020 2020 2020 2020 746d 705f              tmp_
+00007d60: 7061 7274 6961 6c5f 6f75 7470 7574 5f70  partial_output_p
+00007d70: 6174 682e 6578 6973 7473 2829 0a20 2020  ath.exists().   
+00007d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007d90: 2020 2020 2061 6e64 2074 6d70 5f70 6172       and tmp_par
+00007da0: 7469 616c 5f6f 7574 7075 745f 7061 7468  tial_output_path
+00007db0: 2e73 7461 7428 292e 7374 5f73 697a 6520  .stat().st_size 
+00007dc0: 3e20 300a 2020 2020 2020 2020 2020 2020  > 0.            
+00007dd0: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
+00007de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007df0: 2020 2023 2052 656d 6172 6b3a 2062 6563     # Remark: bec
+00007e00: 6175 7365 2066 6f72 6365 5f6f 7574 7075  ause force_outpu
+00007e10: 745f 6765 6f6d 6574 7279 7479 7065 2066  t_geometrytype f
+00007e20: 6f72 2047 656f 4461 7461 4672 616d 650a  or GeoDataFrame.
 00007e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007e40: 6f70 6572 6174 696f 6e3d 6f70 6572 6174  operation=operat
-00007e50: 696f 6e2e 7661 6c75 652c 0d0a 2020 2020  ion.value,..    
-00007e60: 2020 2020 2020 2020 2020 2020 6e62 5f70              nb_p
-00007e70: 6172 616c 6c65 6c3d 7072 6f63 6573 7369  arallel=processi
-00007e80: 6e67 5f70 6172 616d 732e 6e62 5f70 6172  ng_params.nb_par
-00007e90: 616c 6c65 6c2c 0d0a 2020 2020 2020 2020  allel,..        
-00007ea0: 2020 2020 290d 0a20 2020 2020 2020 2020      )..         
-00007eb0: 2020 2066 6f72 2066 7574 7572 6520 696e     for future in
-00007ec0: 2066 7574 7572 6573 2e61 735f 636f 6d70   futures.as_comp
-00007ed0: 6c65 7465 6428 6675 7475 7265 5f74 6f5f  leted(future_to_
-00007ee0: 6261 7463 685f 6964 293a 0d0a 2020 2020  batch_id):..    
-00007ef0: 2020 2020 2020 2020 2020 2020 7472 793a              try:
-00007f00: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00007f10: 2020 2020 2020 6d65 7373 6167 6520 3d20        message = 
-00007f20: 6675 7475 7265 2e72 6573 756c 7428 290d  future.result().
-00007f30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007f40: 2020 2020 206c 6f67 6765 722e 6465 6275       logger.debu
-00007f50: 6728 6d65 7373 6167 6529 0d0a 0d0a 2020  g(message)....  
-00007f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f70: 2020 2320 4966 2074 6865 2063 616c 6375    # If the calcu
-00007f80: 6c61 7465 2067 6176 6520 7265 7375 6c74  late gave result
-00007f90: 732c 2063 6f70 7920 746f 206f 7574 7075  s, copy to outpu
-00007fa0: 740d 0a20 2020 2020 2020 2020 2020 2020  t..             
-00007fb0: 2020 2020 2020 2062 6174 6368 5f69 6420         batch_id 
-00007fc0: 3d20 6675 7475 7265 5f74 6f5f 6261 7463  = future_to_batc
-00007fd0: 685f 6964 5b66 7574 7572 655d 0d0a 2020  h_id[future]..  
+00007e40: 2020 2020 2020 2020 2320 6f70 6572 6174          # operat
+00007e50: 696f 6e73 2069 7320 2861 206c 6f74 2920  ions is (a lot) 
+00007e60: 6d6f 7265 206c 696d 6974 6564 2074 6861  more limited tha
+00007e70: 6e20 6764 616c 2d62 6173 6564 2c20 7573  n gdal-based, us
+00007e80: 6520 7468 650a 2020 2020 2020 2020 2020  e the.          
+00007e90: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00007ea0: 6764 616c 2076 6572 7369 6f6e 2076 6961  gdal version via
+00007eb0: 205f 6170 7065 6e64 5f74 6f5f 6e6f 6c6f   _append_to_nolo
+00007ec0: 636b 2e0a 2020 2020 2020 2020 2020 2020  ck..            
+00007ed0: 2020 2020 2020 2020 2020 2020 6966 2028              if (
+00007ee0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007ef0: 2020 2020 2020 2020 2020 2020 206e 625f               nb_
+00007f00: 6261 7463 6865 7320 3d3d 2031 0a20 2020  batches == 1.   
+00007f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007f20: 2020 2020 2020 2020 2061 6e64 2066 6f72           and for
+00007f30: 6365 5f6f 7574 7075 745f 6765 6f6d 6574  ce_output_geomet
+00007f40: 7279 7479 7065 2069 7320 4e6f 6e65 0a20  rytype is None. 
+00007f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007f60: 2020 2020 2020 2020 2020 2061 6e64 2074             and t
+00007f70: 6d70 5f70 6172 7469 616c 5f6f 7574 7075  mp_partial_outpu
+00007f80: 745f 7061 7468 2e73 7566 6669 7820 3d3d  t_path.suffix ==
+00007f90: 2074 6d70 5f6f 7574 7075 745f 7061 7468   tmp_output_path
+00007fa0: 2e73 7566 6669 780a 2020 2020 2020 2020  .suffix.        
+00007fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007fc0: 2020 2020 616e 6420 7768 6572 655f 706f      and where_po
+00007fd0: 7374 2069 7320 4e6f 6e65 0a20 2020 2020  st is None.     
 00007fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007ff0: 2020 746d 705f 7061 7274 6961 6c5f 6f75    tmp_partial_ou
-00008000: 7470 7574 5f70 6174 6820 3d20 6261 7463  tput_path = batc
-00008010: 6865 735b 6261 7463 685f 6964 5d5b 0d0a  hes[batch_id][..
-00008020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008030: 2020 2020 2020 2020 2274 6d70 5f70 6172          "tmp_par
-00008040: 7469 616c 5f6f 7574 7075 745f 7061 7468  tial_output_path
-00008050: 220d 0a20 2020 2020 2020 2020 2020 2020  "..             
-00008060: 2020 2020 2020 205d 0d0a 2020 2020 2020         ]..      
-00008070: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00008080: 2028 0d0a 2020 2020 2020 2020 2020 2020   (..            
-00008090: 2020 2020 2020 2020 2020 2020 746d 705f              tmp_
-000080a0: 7061 7274 6961 6c5f 6f75 7470 7574 5f70  partial_output_p
-000080b0: 6174 682e 6578 6973 7473 2829 0d0a 2020  ath.exists()..  
-000080c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000080d0: 2020 2020 2020 616e 6420 746d 705f 7061        and tmp_pa
-000080e0: 7274 6961 6c5f 6f75 7470 7574 5f70 6174  rtial_output_pat
-000080f0: 682e 7374 6174 2829 2e73 745f 7369 7a65  h.stat().st_size
-00008100: 203e 2030 0d0a 2020 2020 2020 2020 2020   > 0..          
-00008110: 2020 2020 2020 2020 2020 293a 0d0a 2020            ):..  
-00008120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008130: 2020 2020 2020 2320 5265 6d61 726b 3a20        # Remark: 
-00008140: 6265 6361 7573 6520 666f 7263 655f 6f75  because force_ou
-00008150: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
-00008160: 6520 666f 7220 4765 6f44 6174 6146 7261  e for GeoDataFra
-00008170: 6d65 0d0a 2020 2020 2020 2020 2020 2020  me..            
-00008180: 2020 2020 2020 2020 2020 2020 2320 6f70              # op
-00008190: 6572 6174 696f 6e73 2069 7320 2861 206c  erations is (a l
-000081a0: 6f74 2920 6d6f 7265 206c 696d 6974 6564  ot) more limited
-000081b0: 2074 6861 6e20 6764 616c 2d62 6173 6564   than gdal-based
-000081c0: 2c20 7573 6520 7468 650d 0a20 2020 2020  , use the..     
-000081d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000081e0: 2020 2023 2067 6461 6c20 7665 7273 696f     # gdal versio
-000081f0: 6e20 7669 6120 5f61 7070 656e 645f 746f  n via _append_to
-00008200: 5f6e 6f6c 6f63 6b2e 0d0a 2020 2020 2020  _nolock...      
-00008210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008220: 2020 6966 2028 0d0a 2020 2020 2020 2020    if (..        
-00008230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008240: 2020 2020 6e62 5f62 6174 6368 6573 203d      nb_batches =
-00008250: 3d20 310d 0a20 2020 2020 2020 2020 2020  = 1..           
-00008260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008270: 2061 6e64 2066 6f72 6365 5f6f 7574 7075   and force_outpu
-00008280: 745f 6765 6f6d 6574 7279 7479 7065 2069  t_geometrytype i
-00008290: 7320 4e6f 6e65 0d0a 2020 2020 2020 2020  s None..        
-000082a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000082b0: 2020 2020 616e 6420 746d 705f 7061 7274      and tmp_part
-000082c0: 6961 6c5f 6f75 7470 7574 5f70 6174 682e  ial_output_path.
-000082d0: 7375 6666 6978 203d 3d20 746d 705f 6f75  suffix == tmp_ou
-000082e0: 7470 7574 5f70 6174 682e 7375 6666 6978  tput_path.suffix
-000082f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00008300: 2020 2020 2020 2020 2020 2020 2020 616e                an
-00008310: 6420 7768 6572 655f 706f 7374 2069 7320  d where_post is 
-00008320: 4e6f 6e65 0d0a 2020 2020 2020 2020 2020  None..          
-00008330: 2020 2020 2020 2020 2020 2020 2020 293a                ):
-00008340: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00008350: 2020 2020 2020 2020 2020 2020 2020 6766                gf
-00008360: 6f2e 6d6f 7665 2874 6d70 5f70 6172 7469  o.move(tmp_parti
-00008370: 616c 5f6f 7574 7075 745f 7061 7468 2c20  al_output_path, 
-00008380: 746d 705f 6f75 7470 7574 5f70 6174 6829  tmp_output_path)
-00008390: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000083a0: 2020 2020 2020 2020 2020 656c 7365 3a0d            else:.
-000083b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000083c0: 2020 2020 2020 2020 2020 2020 2066 696c               fil
-000083d0: 656f 7073 2e5f 6170 7065 6e64 5f74 6f5f  eops._append_to_
-000083e0: 6e6f 6c6f 636b 280d 0a20 2020 2020 2020  nolock(..       
-000083f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008400: 2020 2020 2020 2020 2073 7263 3d74 6d70           src=tmp
-00008410: 5f70 6172 7469 616c 5f6f 7574 7075 745f  _partial_output_
-00008420: 7061 7468 2c0d 0a20 2020 2020 2020 2020  path,..         
-00008430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008440: 2020 2020 2020 2064 7374 3d74 6d70 5f6f         dst=tmp_o
-00008450: 7574 7075 745f 7061 7468 2c0d 0a20 2020  utput_path,..   
-00008460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008470: 2020 2020 2020 2020 2020 2020 2065 7870               exp
-00008480: 6c6f 6465 636f 6c6c 6563 7469 6f6e 733d  lodecollections=
-00008490: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
-000084a0: 6e73 2c0d 0a20 2020 2020 2020 2020 2020  ns,..           
+00007ff0: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
+00008000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008010: 2020 6766 6f2e 6d6f 7665 2874 6d70 5f70    gfo.move(tmp_p
+00008020: 6172 7469 616c 5f6f 7574 7075 745f 7061  artial_output_pa
+00008030: 7468 2c20 746d 705f 6f75 7470 7574 5f70  th, tmp_output_p
+00008040: 6174 6829 0a20 2020 2020 2020 2020 2020  ath).           
+00008050: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00008060: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00008070: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00008080: 696c 656f 7073 2e5f 6170 7065 6e64 5f74  ileops._append_t
+00008090: 6f5f 6e6f 6c6f 636b 280a 2020 2020 2020  o_nolock(.      
+000080a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000080b0: 2020 2020 2020 2020 2020 7372 633d 746d            src=tm
+000080c0: 705f 7061 7274 6961 6c5f 6f75 7470 7574  p_partial_output
+000080d0: 5f70 6174 682c 0a20 2020 2020 2020 2020  _path,.         
+000080e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000080f0: 2020 2020 2020 2064 7374 3d74 6d70 5f6f         dst=tmp_o
+00008100: 7574 7075 745f 7061 7468 2c0a 2020 2020  utput_path,.    
+00008110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008120: 2020 2020 2020 2020 2020 2020 6578 706c              expl
+00008130: 6f64 6563 6f6c 6c65 6374 696f 6e73 3d65  odecollections=e
+00008140: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
+00008150: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+00008160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008170: 2020 2063 7265 6174 655f 7370 6174 6961     create_spatia
+00008180: 6c5f 696e 6465 783d 4661 6c73 652c 0a20  l_index=False,. 
+00008190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000081a0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+000081b0: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+000081c0: 6574 7279 7479 7065 3d66 6f72 6365 5f6f  etrytype=force_o
+000081d0: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
+000081e0: 7065 2c0a 2020 2020 2020 2020 2020 2020  pe,.            
+000081f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008200: 2020 2020 7768 6572 653d 7768 6572 655f      where=where_
+00008210: 706f 7374 2c0a 2020 2020 2020 2020 2020  post,.          
+00008220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008230: 2020 2020 2020 7072 6573 6572 7665 5f66        preserve_f
+00008240: 6964 3d70 7265 7365 7276 655f 6669 642c  id=preserve_fid,
+00008250: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008260: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+00008270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008280: 2020 2020 2020 2020 2020 2067 666f 2e72             gfo.r
+00008290: 656d 6f76 6528 746d 705f 7061 7274 6961  emove(tmp_partia
+000082a0: 6c5f 6f75 7470 7574 5f70 6174 6829 0a0a  l_output_path)..
+000082b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000082c0: 6578 6365 7074 2045 7863 6570 7469 6f6e  except Exception
+000082d0: 2061 7320 6578 3a0a 2020 2020 2020 2020   as ex:.        
+000082e0: 2020 2020 2020 2020 2020 2020 6261 7463              batc
+000082f0: 685f 6964 203d 2066 7574 7572 655f 746f  h_id = future_to
+00008300: 5f62 6174 6368 5f69 645b 6675 7475 7265  _batch_id[future
+00008310: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00008320: 2020 2020 2020 6d65 7373 6167 6520 3d20        message = 
+00008330: 6622 4572 726f 7220 7b65 787d 2065 7865  f"Error {ex} exe
+00008340: 6375 7469 6e67 207b 6261 7463 6865 735b  cuting {batches[
+00008350: 6261 7463 685f 6964 5d7d 220a 2020 2020  batch_id]}".    
+00008360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008370: 6c6f 6767 6572 2e65 7863 6570 7469 6f6e  logger.exception
+00008380: 286d 6573 7361 6765 290a 2020 2020 2020  (message).      
+00008390: 2020 2020 2020 2020 2020 2020 2020 7261                ra
+000083a0: 6973 6520 5275 6e74 696d 6545 7272 6f72  ise RuntimeError
+000083b0: 286d 6573 7361 6765 2920 6672 6f6d 2065  (message) from e
+000083c0: 780a 0a20 2020 2020 2020 2020 2020 2020  x..             
+000083d0: 2020 2023 204c 6f67 2074 6865 2070 726f     # Log the pro
+000083e0: 6772 6573 7320 616e 6420 7072 6564 6963  gress and predic
+000083f0: 7469 6f6e 2073 7065 6564 0a20 2020 2020  tion speed.     
+00008400: 2020 2020 2020 2020 2020 206e 625f 646f             nb_do
+00008410: 6e65 202b 3d20 310a 2020 2020 2020 2020  ne += 1.        
+00008420: 2020 2020 2020 2020 5f67 656e 6572 616c          _general
+00008430: 5f75 7469 6c2e 7265 706f 7274 5f70 726f  _util.report_pro
+00008440: 6772 6573 7328 0a20 2020 2020 2020 2020  gress(.         
+00008450: 2020 2020 2020 2020 2020 2073 7461 7274             start
+00008460: 5f74 696d 652c 0a20 2020 2020 2020 2020  _time,.         
+00008470: 2020 2020 2020 2020 2020 206e 625f 646f             nb_do
+00008480: 6e65 2c0a 2020 2020 2020 2020 2020 2020  ne,.            
+00008490: 2020 2020 2020 2020 6e62 5f74 6f64 6f3d          nb_todo=
+000084a0: 6e62 5f62 6174 6368 6573 2c0a 2020 2020  nb_batches,.    
 000084b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000084c0: 2020 2020 2063 7265 6174 655f 7370 6174       create_spat
-000084d0: 6961 6c5f 696e 6465 783d 4661 6c73 652c  ial_index=False,
-000084e0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000084f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008500: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
-00008510: 656f 6d65 7472 7974 7970 653d 666f 7263  eometrytype=forc
-00008520: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-00008530: 7974 7970 652c 0d0a 2020 2020 2020 2020  ytype,..        
-00008540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008550: 2020 2020 2020 2020 7768 6572 653d 7768          where=wh
-00008560: 6572 655f 706f 7374 2c0d 0a20 2020 2020  ere_post,..     
-00008570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008580: 2020 2020 2020 2020 2020 2070 7265 7365             prese
-00008590: 7276 655f 6669 643d 7072 6573 6572 7665  rve_fid=preserve
-000085a0: 5f66 6964 2c0d 0a20 2020 2020 2020 2020  _fid,..         
-000085b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000085c0: 2020 2029 0d0a 2020 2020 2020 2020 2020     )..          
-000085d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000085e0: 2020 6766 6f2e 7265 6d6f 7665 2874 6d70    gfo.remove(tmp
-000085f0: 5f70 6172 7469 616c 5f6f 7574 7075 745f  _partial_output_
-00008600: 7061 7468 290d 0a0d 0a20 2020 2020 2020  path)....       
-00008610: 2020 2020 2020 2020 2065 7863 6570 7420           except 
-00008620: 4578 6365 7074 696f 6e20 6173 2065 783a  Exception as ex:
-00008630: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00008640: 2020 2020 2020 6261 7463 685f 6964 203d        batch_id =
-00008650: 2066 7574 7572 655f 746f 5f62 6174 6368   future_to_batch
-00008660: 5f69 645b 6675 7475 7265 5d0d 0a20 2020  _id[future]..   
-00008670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008680: 206d 6573 7361 6765 203d 2066 2245 7272   message = f"Err
-00008690: 6f72 207b 6578 7d20 6578 6563 7574 696e  or {ex} executin
-000086a0: 6720 7b62 6174 6368 6573 5b62 6174 6368  g {batches[batch
-000086b0: 5f69 645d 7d22 0d0a 2020 2020 2020 2020  _id]}"..        
-000086c0: 2020 2020 2020 2020 2020 2020 6c6f 6767              logg
-000086d0: 6572 2e65 7863 6570 7469 6f6e 286d 6573  er.exception(mes
-000086e0: 7361 6765 290d 0a20 2020 2020 2020 2020  sage)..         
-000086f0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-00008700: 2052 756e 7469 6d65 4572 726f 7228 6d65   RuntimeError(me
-00008710: 7373 6167 6529 2066 726f 6d20 6578 0d0a  ssage) from ex..
-00008720: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00008730: 2020 2320 4c6f 6720 7468 6520 7072 6f67    # Log the prog
-00008740: 7265 7373 2061 6e64 2070 7265 6469 6374  ress and predict
-00008750: 696f 6e20 7370 6565 640d 0a20 2020 2020  ion speed..     
-00008760: 2020 2020 2020 2020 2020 206e 625f 646f             nb_do
-00008770: 6e65 202b 3d20 310d 0a20 2020 2020 2020  ne += 1..       
-00008780: 2020 2020 2020 2020 205f 6765 6e65 7261           _genera
-00008790: 6c5f 7574 696c 2e72 6570 6f72 745f 7072  l_util.report_pr
-000087a0: 6f67 7265 7373 280d 0a20 2020 2020 2020  ogress(..       
-000087b0: 2020 2020 2020 2020 2020 2020 2073 7461               sta
-000087c0: 7274 5f74 696d 652c 0d0a 2020 2020 2020  rt_time,..      
-000087d0: 2020 2020 2020 2020 2020 2020 2020 6e62                nb
-000087e0: 5f64 6f6e 652c 0d0a 2020 2020 2020 2020  _done,..        
-000087f0: 2020 2020 2020 2020 2020 2020 6e62 5f74              nb_t
-00008800: 6f64 6f3d 6e62 5f62 6174 6368 6573 2c0d  odo=nb_batches,.
-00008810: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008820: 2020 2020 206f 7065 7261 7469 6f6e 3d6f       operation=o
-00008830: 7065 7261 7469 6f6e 2e76 616c 7565 2c0d  peration.value,.
-00008840: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008850: 2020 2020 206e 625f 7061 7261 6c6c 656c       nb_parallel
-00008860: 3d70 726f 6365 7373 696e 675f 7061 7261  =processing_para
-00008870: 6d73 2e6e 625f 7061 7261 6c6c 656c 2c0d  ms.nb_parallel,.
-00008880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008890: 2029 0d0a 0d0a 2020 2020 2020 2020 2320   )....        # 
-000088a0: 526f 756e 6420 7570 2061 6e64 2063 6c65  Round up and cle
-000088b0: 616e 2075 700d 0a20 2020 2020 2020 2023  an up..        #
-000088c0: 204e 6f77 2063 7265 6174 6520 7370 6174   Now create spat
-000088d0: 6961 6c20 696e 6465 7820 616e 6420 6d6f  ial index and mo
-000088e0: 7665 2074 6f20 6f75 7470 7574 206c 6f63  ve to output loc
-000088f0: 6174 696f 6e0d 0a20 2020 2020 2020 2069  ation..        i
-00008900: 6620 746d 705f 6f75 7470 7574 5f70 6174  f tmp_output_pat
-00008910: 682e 6578 6973 7473 2829 3a0d 0a20 2020  h.exists():..   
-00008920: 2020 2020 2020 2020 2067 666f 2e63 7265           gfo.cre
-00008930: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
-00008940: 7828 7061 7468 3d74 6d70 5f6f 7574 7075  x(path=tmp_outpu
-00008950: 745f 7061 7468 2c20 6c61 7965 723d 6f75  t_path, layer=ou
-00008960: 7470 7574 5f6c 6179 6572 290d 0a20 2020  tput_layer)..   
-00008970: 2020 2020 2020 2020 2067 666f 2e6d 6f76           gfo.mov
-00008980: 6528 746d 705f 6f75 7470 7574 5f70 6174  e(tmp_output_pat
-00008990: 682c 206f 7574 7075 745f 7061 7468 290d  h, output_path).
-000089a0: 0a20 2020 2020 2020 2065 6c73 653a 0d0a  .        else:..
-000089b0: 2020 2020 2020 2020 2020 2020 6c6f 6767              logg
-000089c0: 6572 2e64 6562 7567 2822 5265 7375 6c74  er.debug("Result
-000089d0: 2077 6173 2065 6d70 7479 2229 0d0a 0d0a   was empty")....
-000089e0: 2020 2020 6669 6e61 6c6c 793a 0d0a 2020      finally:..  
-000089f0: 2020 2020 2020 7368 7574 696c 2e72 6d74        shutil.rmt
-00008a00: 7265 6528 746d 705f 6469 722c 2069 676e  ree(tmp_dir, ign
-00008a10: 6f72 655f 6572 726f 7273 3d54 7275 6529  ore_errors=True)
-00008a20: 0d0a 0d0a 2020 2020 6c6f 6767 6572 2e69  ....    logger.i
-00008a30: 6e66 6f28 6622 5265 6164 792c 2074 6f6f  nfo(f"Ready, too
-00008a40: 6b20 7b64 6174 6574 696d 652e 6e6f 7728  k {datetime.now(
-00008a50: 292d 7374 6172 745f 7469 6d65 5f67 6c6f  )-start_time_glo
-00008a60: 6261 6c7d 2229 0d0a 0d0a 0d0a 6465 6620  bal}")......def 
-00008a70: 5f61 7070 6c79 5f67 656f 6f70 6572 6174  _apply_geooperat
-00008a80: 696f 6e28 0d0a 2020 2020 696e 7075 745f  ion(..    input_
-00008a90: 7061 7468 3a20 5061 7468 2c0d 0a20 2020  path: Path,..   
-00008aa0: 206f 7574 7075 745f 7061 7468 3a20 5061   output_path: Pa
-00008ab0: 7468 2c0d 0a20 2020 206f 7065 7261 7469  th,..    operati
-00008ac0: 6f6e 3a20 4765 6f4f 7065 7261 7469 6f6e  on: GeoOperation
-00008ad0: 2c0d 0a20 2020 206f 7065 7261 7469 6f6e  ,..    operation
-00008ae0: 5f70 6172 616d 733a 2064 6963 742c 0d0a  _params: dict,..
-00008af0: 2020 2020 696e 7075 745f 6c61 7965 723a      input_layer:
-00008b00: 204f 7074 696f 6e61 6c5b 7374 725d 203d   Optional[str] =
-00008b10: 204e 6f6e 652c 0d0a 2020 2020 6f75 7470   None,..    outp
-00008b20: 7574 5f6c 6179 6572 3a20 4f70 7469 6f6e  ut_layer: Option
-00008b30: 616c 5b73 7472 5d20 3d20 4e6f 6e65 2c0d  al[str] = None,.
-00008b40: 0a20 2020 2063 6f6c 756d 6e73 3a20 4f70  .    columns: Op
-00008b50: 7469 6f6e 616c 5b4c 6973 745b 7374 725d  tional[List[str]
-00008b60: 5d20 3d20 4e6f 6e65 2c0d 0a20 2020 2077  ] = None,..    w
-00008b70: 6865 7265 3d4e 6f6e 652c 0d0a 2020 2020  here=None,..    
-00008b80: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
-00008b90: 6e73 3a20 626f 6f6c 203d 2046 616c 7365  ns: bool = False
-00008ba0: 2c0d 0a20 2020 2067 7269 6473 697a 653a  ,..    gridsize:
-00008bb0: 2066 6c6f 6174 203d 2030 2e30 2c0d 0a20   float = 0.0,.. 
-00008bc0: 2020 206b 6565 705f 656d 7074 795f 6765     keep_empty_ge
-00008bd0: 6f6d 733a 2062 6f6f 6c20 3d20 5472 7565  oms: bool = True
-00008be0: 2c0d 0a20 2020 2070 7265 7365 7276 655f  ,..    preserve_
-00008bf0: 6669 643a 2062 6f6f 6c20 3d20 4661 6c73  fid: bool = Fals
-00008c00: 652c 0d0a 2020 2020 666f 7263 653a 2062  e,..    force: b
-00008c10: 6f6f 6c20 3d20 4661 6c73 652c 0d0a 2920  ool = False,..) 
-00008c20: 2d3e 2073 7472 3a0d 0a20 2020 2023 2049  -> str:..    # I
-00008c30: 6e69 740d 0a20 2020 2069 6620 6f75 7470  nit..    if outp
-00008c40: 7574 5f70 6174 682e 6578 6973 7473 2829  ut_path.exists()
-00008c50: 3a0d 0a20 2020 2020 2020 2069 6620 666f  :..        if fo
-00008c60: 7263 6520 6973 2046 616c 7365 3a0d 0a20  rce is False:.. 
-00008c70: 2020 2020 2020 2020 2020 206d 6573 7361             messa
-00008c80: 6765 203d 2066 2253 746f 702c 206f 7574  ge = f"Stop, out
-00008c90: 7075 7420 6578 6973 7473 2061 6c72 6561  put exists alrea
-00008ca0: 6479 207b 6f75 7470 7574 5f70 6174 687d  dy {output_path}
-00008cb0: 220d 0a20 2020 2020 2020 2020 2020 2072  "..            r
-00008cc0: 6574 7572 6e20 6d65 7373 6167 650d 0a20  eturn message.. 
-00008cd0: 2020 2020 2020 2065 6c73 653a 0d0a 2020         else:..  
-00008ce0: 2020 2020 2020 2020 2020 6766 6f2e 7265            gfo.re
-00008cf0: 6d6f 7665 286f 7574 7075 745f 7061 7468  move(output_path
-00008d00: 290d 0a0d 0a20 2020 2023 204e 6f77 2067  )....    # Now g
-00008d10: 6f21 0d0a 2020 2020 7374 6172 745f 7469  o!..    start_ti
-00008d20: 6d65 203d 2064 6174 6574 696d 652e 6e6f  me = datetime.no
-00008d30: 7728 290d 0a20 2020 2064 6174 615f 6764  w()..    data_gd
-00008d40: 6620 3d20 6766 6f2e 7265 6164 5f66 696c  f = gfo.read_fil
-00008d50: 6528 0d0a 2020 2020 2020 2020 7061 7468  e(..        path
-00008d60: 3d69 6e70 7574 5f70 6174 682c 0d0a 2020  =input_path,..  
-00008d70: 2020 2020 2020 6c61 7965 723d 696e 7075        layer=inpu
-00008d80: 745f 6c61 7965 722c 0d0a 2020 2020 2020  t_layer,..      
-00008d90: 2020 636f 6c75 6d6e 733d 636f 6c75 6d6e    columns=column
-00008da0: 732c 0d0a 2020 2020 2020 2020 7768 6572  s,..        wher
-00008db0: 653d 7768 6572 652c 0d0a 2020 2020 2020  e=where,..      
-00008dc0: 2020 6669 645f 6173 5f69 6e64 6578 3d70    fid_as_index=p
-00008dd0: 7265 7365 7276 655f 6669 642c 0d0a 2020  reserve_fid,..  
-00008de0: 2020 290d 0a0d 0a20 2020 2023 2052 756e    )....    # Run
-00008df0: 206f 7065 7261 7469 6f6e 2069 6620 6461   operation if da
-00008e00: 7461 2072 6561 640d 0a20 2020 2069 6620  ta read..    if 
-00008e10: 6c65 6e28 6461 7461 5f67 6466 2920 3e20  len(data_gdf) > 
-00008e20: 303a 0d0a 2020 2020 2020 2020 6966 206f  0:..        if o
-00008e30: 7065 7261 7469 6f6e 2069 7320 4765 6f4f  peration is GeoO
-00008e40: 7065 7261 7469 6f6e 2e42 5546 4645 523a  peration.BUFFER:
-00008e50: 0d0a 2020 2020 2020 2020 2020 2020 6461  ..            da
-00008e60: 7461 5f67 6466 2e67 656f 6d65 7472 7920  ta_gdf.geometry 
-00008e70: 3d20 6461 7461 5f67 6466 2e67 656f 6d65  = data_gdf.geome
-00008e80: 7472 792e 6275 6666 6572 280d 0a20 2020  try.buffer(..   
-00008e90: 2020 2020 2020 2020 2020 2020 2064 6973               dis
-00008ea0: 7461 6e63 653d 6f70 6572 6174 696f 6e5f  tance=operation_
-00008eb0: 7061 7261 6d73 5b22 6469 7374 616e 6365  params["distance
-00008ec0: 225d 2c0d 0a20 2020 2020 2020 2020 2020  "],..           
-00008ed0: 2020 2020 2072 6573 6f6c 7574 696f 6e3d       resolution=
-00008ee0: 6f70 6572 6174 696f 6e5f 7061 7261 6d73  operation_params
-00008ef0: 5b22 7175 6164 7261 6e74 7365 676d 656e  ["quadrantsegmen
-00008f00: 7473 225d 2c0d 0a20 2020 2020 2020 2020  ts"],..         
-00008f10: 2020 2020 2020 2063 6170 5f73 7479 6c65         cap_style
-00008f20: 3d6f 7065 7261 7469 6f6e 5f70 6172 616d  =operation_param
-00008f30: 735b 2265 6e64 6361 705f 7374 796c 6522  s["endcap_style"
-00008f40: 5d2e 7661 6c75 652c 0d0a 2020 2020 2020  ].value,..      
-00008f50: 2020 2020 2020 2020 2020 6a6f 696e 5f73            join_s
-00008f60: 7479 6c65 3d6f 7065 7261 7469 6f6e 5f70  tyle=operation_p
-00008f70: 6172 616d 735b 226a 6f69 6e5f 7374 796c  arams["join_styl
-00008f80: 6522 5d2e 7661 6c75 652c 0d0a 2020 2020  e"].value,..    
-00008f90: 2020 2020 2020 2020 2020 2020 6d69 7472              mitr
-00008fa0: 655f 6c69 6d69 743d 6f70 6572 6174 696f  e_limit=operatio
-00008fb0: 6e5f 7061 7261 6d73 5b22 6d69 7472 655f  n_params["mitre_
-00008fc0: 6c69 6d69 7422 5d2c 0d0a 2020 2020 2020  limit"],..      
-00008fd0: 2020 2020 2020 2020 2020 7369 6e67 6c65            single
-00008fe0: 5f73 6964 6564 3d6f 7065 7261 7469 6f6e  _sided=operation
-00008ff0: 5f70 6172 616d 735b 2273 696e 676c 655f  _params["single_
-00009000: 7369 6465 6422 5d2c 0d0a 2020 2020 2020  sided"],..      
-00009010: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-00009020: 2065 6c69 6620 6f70 6572 6174 696f 6e20   elif operation 
-00009030: 6973 2047 656f 4f70 6572 6174 696f 6e2e  is GeoOperation.
-00009040: 434f 4e56 4558 4855 4c4c 3a0d 0a20 2020  CONVEXHULL:..   
-00009050: 2020 2020 2020 2020 2064 6174 615f 6764           data_gd
-00009060: 662e 6765 6f6d 6574 7279 203d 2064 6174  f.geometry = dat
-00009070: 615f 6764 662e 6765 6f6d 6574 7279 2e63  a_gdf.geometry.c
-00009080: 6f6e 7665 785f 6875 6c6c 0d0a 2020 2020  onvex_hull..    
-00009090: 2020 2020 656c 6966 206f 7065 7261 7469      elif operati
-000090a0: 6f6e 2069 7320 4765 6f4f 7065 7261 7469  on is GeoOperati
-000090b0: 6f6e 2e53 494d 504c 4946 593a 0d0a 2020  on.SIMPLIFY:..  
-000090c0: 2020 2020 2020 2020 2020 6461 7461 5f67            data_g
-000090d0: 6466 2e67 656f 6d65 7472 7920 3d20 7079  df.geometry = py
-000090e0: 6765 6f6f 7073 2e73 696d 706c 6966 7928  geoops.simplify(
-000090f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00009100: 2020 6461 7461 5f67 6466 2e67 656f 6d65    data_gdf.geome
-00009110: 7472 792c 0d0a 2020 2020 2020 2020 2020  try,..          
-00009120: 2020 2020 2020 616c 676f 7269 7468 6d3d        algorithm=
-00009130: 6f70 6572 6174 696f 6e5f 7061 7261 6d73  operation_params
-00009140: 5b22 616c 676f 7269 7468 6d22 5d2e 7661  ["algorithm"].va
-00009150: 6c75 652c 0d0a 2020 2020 2020 2020 2020  lue,..          
-00009160: 2020 2020 2020 746f 6c65 7261 6e63 653d        tolerance=
-00009170: 6f70 6572 6174 696f 6e5f 7061 7261 6d73  operation_params
-00009180: 5b22 746f 6c65 7261 6e63 6522 5d2c 0d0a  ["tolerance"],..
-00009190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000091a0: 6c6f 6f6b 6168 6561 643d 6f70 6572 6174  lookahead=operat
-000091b0: 696f 6e5f 7061 7261 6d73 5b22 7374 6570  ion_params["step
-000091c0: 225d 2c0d 0a20 2020 2020 2020 2020 2020  "],..           
-000091d0: 2029 0d0a 2020 2020 2020 2020 656c 6966   )..        elif
-000091e0: 206f 7065 7261 7469 6f6e 2069 7320 4765   operation is Ge
-000091f0: 6f4f 7065 7261 7469 6f6e 2e41 5050 4c59  oOperation.APPLY
-00009200: 3a0d 0a20 2020 2020 2020 2020 2020 2066  :..            f
-00009210: 756e 6320 3d20 7069 636b 6c65 2e6c 6f61  unc = pickle.loa
-00009220: 6473 286f 7065 7261 7469 6f6e 5f70 6172  ds(operation_par
-00009230: 616d 735b 2270 6963 6b6c 6564 5f66 756e  ams["pickled_fun
-00009240: 6322 5d29 0d0a 2020 2020 2020 2020 2020  c"])..          
-00009250: 2020 6966 206f 7065 7261 7469 6f6e 5f70    if operation_p
-00009260: 6172 616d 735b 226f 6e6c 795f 6765 6f6d  arams["only_geom
-00009270: 5f69 6e70 7574 225d 2069 7320 5472 7565  _input"] is True
-00009280: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00009290: 2020 2064 6174 615f 6764 662e 6765 6f6d     data_gdf.geom
-000092a0: 6574 7279 203d 2064 6174 615f 6764 662e  etry = data_gdf.
-000092b0: 6765 6f6d 6574 7279 2e61 7070 6c79 2866  geometry.apply(f
-000092c0: 756e 6329 0d0a 2020 2020 2020 2020 2020  unc)..          
-000092d0: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-000092e0: 2020 2020 2020 2020 2064 6174 615f 6764           data_gd
-000092f0: 662e 6765 6f6d 6574 7279 203d 2064 6174  f.geometry = dat
-00009300: 615f 6764 662e 6170 706c 7928 6675 6e63  a_gdf.apply(func
-00009310: 2c20 6178 6973 3d31 290d 0a20 2020 2020  , axis=1)..     
-00009320: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-00009330: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00009340: 6545 7272 6f72 2866 226f 7065 7261 7469  eError(f"operati
-00009350: 6f6e 206e 6f74 2073 7570 706f 7274 6564  on not supported
-00009360: 3a20 7b6f 7065 7261 7469 6f6e 7d22 290d  : {operation}").
-00009370: 0a0d 0a20 2020 2023 2053 6574 2065 6d70  ...    # Set emp
-00009380: 7479 2067 656f 6d65 7472 6965 7320 746f  ty geometries to
-00009390: 206e 756c 6c2f 4e6f 6e65 0d0a 2020 2020   null/None..    
-000093a0: 6173 7365 7274 2064 6174 615f 6764 662e  assert data_gdf.
-000093b0: 6765 6f6d 6574 7279 2069 7320 6e6f 7420  geometry is not 
-000093c0: 4e6f 6e65 0d0a 2020 2020 6461 7461 5f67  None..    data_g
-000093d0: 6466 2e6c 6f63 5b64 6174 615f 6764 662e  df.loc[data_gdf.
-000093e0: 6765 6f6d 6574 7279 2e69 735f 656d 7074  geometry.is_empt
-000093f0: 792c 205b 2267 656f 6d65 7472 7922 5d5d  y, ["geometry"]]
-00009400: 203d 204e 6f6e 650d 0a0d 0a20 2020 2023   = None....    #
-00009410: 2049 6620 7468 6572 6520 6973 2061 6e20   If there is an 
-00009420: 6669 6420 636f 6c75 6d6e 2069 6e20 7468  fid column in th
-00009430: 6520 6461 7461 7365 742c 2072 656e 616d  e dataset, renam
-00009440: 6520 6974 2c20 6265 6361 7573 6520 7468  e it, because th
-00009450: 6520 6669 6420 636f 6c75 6d6e 2069 7320  e fid column is 
-00009460: 610d 0a20 2020 2023 2022 7370 6563 6961  a..    # "specia
-00009470: 6c20 6361 7365 2220 696e 2067 6461 6c20  l case" in gdal 
-00009480: 7468 6174 2073 686f 756c 6420 6e6f 7420  that should not 
-00009490: 6265 2077 7269 7474 656e 2e0d 0a20 2020  be written...   
-000094a0: 2061 7373 6572 7420 6973 696e 7374 616e   assert isinstan
-000094b0: 6365 2864 6174 615f 6764 662c 2067 7064  ce(data_gdf, gpd
-000094c0: 2e47 656f 4461 7461 4672 616d 6529 0d0a  .GeoDataFrame)..
-000094d0: 2020 2020 636f 6c75 6d6e 735f 6c6f 7765      columns_lowe
-000094e0: 725f 6c6f 6f6b 7570 203d 207b 636f 6c75  r_lookup = {colu
-000094f0: 6d6e 2e6c 6f77 6572 2829 3a20 636f 6c75  mn.lower(): colu
-00009500: 6d6e 2066 6f72 2063 6f6c 756d 6e20 696e  mn for column in
-00009510: 2064 6174 615f 6764 662e 636f 6c75 6d6e   data_gdf.column
-00009520: 737d 0d0a 2020 2020 6966 2022 6669 6422  s}..    if "fid"
-00009530: 2069 6e20 636f 6c75 6d6e 735f 6c6f 7765   in columns_lowe
-00009540: 725f 6c6f 6f6b 7570 3a0d 0a20 2020 2020  r_lookup:..     
-00009550: 2020 2066 6964 5f63 6f6c 756d 6e20 3d20     fid_column = 
-00009560: 636f 6c75 6d6e 735f 6c6f 7765 725f 6c6f  columns_lower_lo
-00009570: 6f6b 7570 5b22 6669 6422 5d0d 0a20 2020  okup["fid"]..   
-00009580: 2020 2020 2066 6f72 2066 6964 5f6e 756d       for fid_num
-00009590: 6265 7220 696e 2072 616e 6765 2831 2c20  ber in range(1, 
-000095a0: 3130 3029 3a0d 0a20 2020 2020 2020 2020  100):..         
-000095b0: 2020 206e 6577 5f6e 616d 6520 3d20 6622     new_name = f"
-000095c0: 7b66 6964 5f63 6f6c 756d 6e7d 5f7b 6669  {fid_column}_{fi
-000095d0: 645f 6e75 6d62 6572 7d22 0d0a 2020 2020  d_number}"..    
-000095e0: 2020 2020 2020 2020 6966 206e 6577 5f6e          if new_n
-000095f0: 616d 6520 6e6f 7420 696e 2063 6f6c 756d  ame not in colum
-00009600: 6e73 5f6c 6f77 6572 5f6c 6f6f 6b75 703a  ns_lower_lookup:
-00009610: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00009620: 2020 6461 7461 5f67 6466 203d 2064 6174    data_gdf = dat
-00009630: 615f 6764 662e 7265 6e61 6d65 2863 6f6c  a_gdf.rename(col
-00009640: 756d 6e73 3d7b 6669 645f 636f 6c75 6d6e  umns={fid_column
-00009650: 3a20 6e65 775f 6e61 6d65 7d2c 2063 6f70  : new_name}, cop
-00009660: 793d 4661 6c73 6529 0d0a 0d0a 2020 2020  y=False)....    
-00009670: 6966 2067 7269 6473 697a 6520 213d 2030  if gridsize != 0
-00009680: 2e30 3a0d 0a20 2020 2020 2020 2064 6174  .0:..        dat
-00009690: 615f 6764 662e 6765 6f6d 6574 7279 203d  a_gdf.geometry =
-000096a0: 205f 6765 6f73 6572 6965 735f 7574 696c   _geoseries_util
-000096b0: 2e73 6574 5f70 7265 6369 7369 6f6e 280d  .set_precision(.
-000096c0: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
-000096d0: 615f 6764 662e 6765 6f6d 6574 7279 2c20  a_gdf.geometry, 
-000096e0: 6772 6964 5f73 697a 653d 6772 6964 7369  grid_size=gridsi
-000096f0: 7a65 2c20 7261 6973 655f 6f6e 5f74 6f70  ze, raise_on_top
-00009700: 6f65 7272 6f72 3d46 616c 7365 0d0a 2020  oerror=False..  
-00009710: 2020 2020 2020 290d 0a0d 0a20 2020 2069        )....    i
-00009720: 6620 6578 706c 6f64 6563 6f6c 6c65 6374  f explodecollect
-00009730: 696f 6e73 3a0d 0a20 2020 2020 2020 2064  ions:..        d
-00009740: 6174 615f 6764 6620 3d20 6461 7461 5f67  ata_gdf = data_g
-00009750: 6466 2e65 7870 6c6f 6465 2869 676e 6f72  df.explode(ignor
-00009760: 655f 696e 6465 783d 5472 7565 290d 0a0d  e_index=True)...
-00009770: 0a20 2020 2023 2052 656d 6f76 6520 726f  .    # Remove ro
-00009780: 7773 2077 6865 7265 2067 656f 6d20 6973  ws where geom is
-00009790: 204e 6f6e 652f 6e75 6c6c 2f65 6d70 7479   None/null/empty
-000097a0: 0d0a 2020 2020 6966 206e 6f74 206b 6565  ..    if not kee
-000097b0: 705f 656d 7074 795f 6765 6f6d 733a 0d0a  p_empty_geoms:..
-000097c0: 2020 2020 2020 2020 6173 7365 7274 2069          assert i
-000097d0: 7369 6e73 7461 6e63 6528 6461 7461 5f67  sinstance(data_g
-000097e0: 6466 2c20 6770 642e 4765 6f44 6174 6146  df, gpd.GeoDataF
-000097f0: 7261 6d65 290d 0a20 2020 2020 2020 2064  rame)..        d
-00009800: 6174 615f 6764 6620 3d20 6461 7461 5f67  ata_gdf = data_g
-00009810: 6466 5b7e 6461 7461 5f67 6466 2e67 656f  df[~data_gdf.geo
-00009820: 6d65 7472 792e 6973 6e61 2829 5d0d 0a20  metry.isna()].. 
-00009830: 2020 2020 2020 2064 6174 615f 6764 6620         data_gdf 
-00009840: 3d20 6461 7461 5f67 6466 5b7e 6461 7461  = data_gdf[~data
-00009850: 5f67 6466 2e67 656f 6d65 7472 792e 6973  _gdf.geometry.is
-00009860: 5f65 6d70 7479 5d0d 0a0d 0a20 2020 2023  _empty]....    #
-00009870: 2049 6620 7468 6520 7265 7375 6c74 2069   If the result i
-00009880: 7320 656d 7074 792c 2061 6e64 206e 6f20  s empty, and no 
-00009890: 6f75 7470 7574 2067 656f 6d65 7472 7974  output geometryt
-000098a0: 7970 6520 7370 6563 6966 6965 642c 2075  ype specified, u
-000098b0: 7365 2069 6e70 7574 0d0a 2020 2020 2320  se input..    # 
-000098c0: 6765 6f6d 6574 7279 7479 7065 0d0a 2020  geometrytype..  
-000098d0: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
-000098e0: 656f 6d65 7472 7974 7970 6520 3d20 4e6f  eometrytype = No
-000098f0: 6e65 0d0a 2020 2020 6966 206c 656e 2864  ne..    if len(d
-00009900: 6174 615f 6764 6629 203d 3d20 303a 0d0a  ata_gdf) == 0:..
-00009910: 2020 2020 2020 2020 696e 7075 745f 6c61          input_la
-00009920: 7965 7269 6e66 6f20 3d20 6766 6f2e 6765  yerinfo = gfo.ge
-00009930: 745f 6c61 7965 7269 6e66 6f28 696e 7075  t_layerinfo(inpu
-00009940: 745f 7061 7468 2c20 696e 7075 745f 6c61  t_path, input_la
-00009950: 7965 7229 0d0a 2020 2020 2020 2020 666f  yer)..        fo
-00009960: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-00009970: 7472 7974 7970 6520 3d20 696e 7075 745f  trytype = input_
-00009980: 6c61 7965 7269 6e66 6f2e 6765 6f6d 6574  layerinfo.geomet
-00009990: 7279 7479 7065 0d0a 2020 2020 2020 2020  rytype..        
-000099a0: 6966 206e 6f74 2065 7870 6c6f 6465 636f  if not explodeco
-000099b0: 6c6c 6563 7469 6f6e 733a 0d0a 2020 2020  llections:..    
-000099c0: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
-000099d0: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
-000099e0: 6520 3d20 666f 7263 655f 6f75 7470 7574  e = force_output
-000099f0: 5f67 656f 6d65 7472 7974 7970 652e 746f  _geometrytype.to
-00009a00: 5f6d 756c 7469 7479 7065 0d0a 2020 2020  _multitype..    
-00009a10: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
-00009a20: 5f67 656f 6d65 7472 7974 7970 6520 3d20  _geometrytype = 
-00009a30: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
-00009a40: 6d65 7472 7974 7970 652e 6e61 6d65 0d0a  metrytype.name..
-00009a50: 0d0a 2020 2020 2320 4966 2074 6865 2069  ..    # If the i
-00009a60: 6e64 6578 2069 7320 7374 696c 6c20 756e  ndex is still un
-00009a70: 6971 7565 2c20 7361 7665 2069 7420 746f  ique, save it to
-00009a80: 2066 6964 2063 6f6c 756d 6e20 736f 2074   fid column so t
-00009a90: 6f5f 6669 6c65 2063 616e 2073 6176 6520  o_file can save 
-00009aa0: 6974 0d0a 2020 2020 6966 2070 7265 7365  it..    if prese
-00009ab0: 7276 655f 6669 643a 0d0a 2020 2020 2020  rve_fid:..      
-00009ac0: 2020 6461 7461 5f67 6466 203d 2064 6174    data_gdf = dat
-00009ad0: 615f 6764 662e 7265 7365 745f 696e 6465  a_gdf.reset_inde
-00009ae0: 7828 6472 6f70 3d46 616c 7365 290d 0a0d  x(drop=False)...
-00009af0: 0a20 2020 2023 2055 7365 2066 6f72 6365  .    # Use force
-00009b00: 5f6d 756c 7469 7479 7065 2069 6620 6578  _multitype if ex
-00009b10: 706c 6f64 6563 6f6c 6c65 6374 696f 6e73  plodecollections
-00009b20: 3d46 616c 7365 2074 6f20 6176 6f69 6420  =False to avoid 
-00009b30: 7761 726e 696e 6773 2f69 7373 7565 7320  warnings/issues 
-00009b40: 7768 656e 2073 6f6d 650d 0a20 2020 2023  when some..    #
-00009b50: 2062 6174 6368 6573 2063 6f6e 7461 696e   batches contain
-00009b60: 2073 696e 676c 6574 7970 6520 616e 6420   singletype and 
-00009b70: 736f 6d65 2063 6f6e 7461 696e 206d 756c  some contain mul
-00009b80: 7469 7479 7065 2067 656f 6d65 7472 6965  titype geometrie
-00009b90: 730d 0a20 2020 2067 666f 2e74 6f5f 6669  s..    gfo.to_fi
-00009ba0: 6c65 280d 0a20 2020 2020 2020 2067 6466  le(..        gdf
-00009bb0: 3d64 6174 615f 6764 662c 0d0a 2020 2020  =data_gdf,..    
-00009bc0: 2020 2020 7061 7468 3d6f 7574 7075 745f      path=output_
-00009bd0: 7061 7468 2c0d 0a20 2020 2020 2020 206c  path,..        l
-00009be0: 6179 6572 3d6f 7574 7075 745f 6c61 7965  ayer=output_laye
-00009bf0: 722c 0d0a 2020 2020 2020 2020 696e 6465  r,..        inde
-00009c00: 783d 4661 6c73 652c 0d0a 2020 2020 2020  x=False,..      
-00009c10: 2020 666f 7263 655f 6f75 7470 7574 5f67    force_output_g
-00009c20: 656f 6d65 7472 7974 7970 653d 666f 7263  eometrytype=forc
-00009c30: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
-00009c40: 7974 7970 652c 0d0a 2020 2020 2020 2020  ytype,..        
-00009c50: 666f 7263 655f 6d75 6c74 6974 7970 653d  force_multitype=
-00009c60: 6e6f 7420 6578 706c 6f64 6563 6f6c 6c65  not explodecolle
-00009c70: 6374 696f 6e73 2c0d 0a20 2020 2020 2020  ctions,..       
-00009c80: 2063 7265 6174 655f 7370 6174 6961 6c5f   create_spatial_
-00009c90: 696e 6465 783d 4661 6c73 652c 0d0a 2020  index=False,..  
-00009ca0: 2020 290d 0a0d 0a20 2020 206d 6573 7361    )....    messa
-00009cb0: 6765 203d 2066 2254 6f6f 6b20 7b64 6174  ge = f"Took {dat
-00009cc0: 6574 696d 652e 6e6f 7728 292d 7374 6172  etime.now()-star
-00009cd0: 745f 7469 6d65 7d20 666f 7220 7b6c 656e  t_time} for {len
-00009ce0: 2864 6174 615f 6764 6629 7d20 726f 7773  (data_gdf)} rows
-00009cf0: 2028 7b77 6865 7265 7d29 220d 0a20 2020   ({where})"..   
-00009d00: 2072 6574 7572 6e20 6d65 7373 6167 650d   return message.
-00009d10: 0a0d 0a0d 0a64 6566 2064 6973 736f 6c76  .....def dissolv
-00009d20: 6528 0d0a 2020 2020 696e 7075 745f 7061  e(..    input_pa
-00009d30: 7468 3a20 5061 7468 2c0d 0a20 2020 206f  th: Path,..    o
-00009d40: 7574 7075 745f 7061 7468 3a20 5061 7468  utput_path: Path
-00009d50: 2c0d 0a20 2020 2067 726f 7570 6279 5f63  ,..    groupby_c
-00009d60: 6f6c 756d 6e73 3a20 4f70 7469 6f6e 616c  olumns: Optional
-00009d70: 5b49 7465 7261 626c 655b 7374 725d 5d20  [Iterable[str]] 
-00009d80: 3d20 4e6f 6e65 2c0d 0a20 2020 2061 6767  = None,..    agg
-00009d90: 5f63 6f6c 756d 6e73 3a20 4f70 7469 6f6e  _columns: Option
-00009da0: 616c 5b64 6963 745d 203d 204e 6f6e 652c  al[dict] = None,
-00009db0: 0d0a 2020 2020 6578 706c 6f64 6563 6f6c  ..    explodecol
-00009dc0: 6c65 6374 696f 6e73 3a20 626f 6f6c 203d  lections: bool =
-00009dd0: 2054 7275 652c 0d0a 2020 2020 7469 6c65   True,..    tile
-00009de0: 735f 7061 7468 3a20 4f70 7469 6f6e 616c  s_path: Optional
-00009df0: 5b50 6174 685d 203d 204e 6f6e 652c 0d0a  [Path] = None,..
-00009e00: 2020 2020 6e62 5f73 7175 6172 6973 685f      nb_squarish_
-00009e10: 7469 6c65 733a 2069 6e74 203d 2031 2c0d  tiles: int = 1,.
-00009e20: 0a20 2020 2069 6e70 7574 5f6c 6179 6572  .    input_layer
-00009e30: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d20  : Optional[str] 
-00009e40: 3d20 4e6f 6e65 2c0d 0a20 2020 206f 7574  = None,..    out
-00009e50: 7075 745f 6c61 7965 723a 204f 7074 696f  put_layer: Optio
-00009e60: 6e61 6c5b 7374 725d 203d 204e 6f6e 652c  nal[str] = None,
-00009e70: 0d0a 2020 2020 6772 6964 7369 7a65 3a20  ..    gridsize: 
-00009e80: 666c 6f61 7420 3d20 302e 302c 0d0a 2020  float = 0.0,..  
-00009e90: 2020 7768 6572 655f 706f 7374 3a20 4f70    where_post: Op
-00009ea0: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
-00009eb0: 6e65 2c0d 0a20 2020 206e 625f 7061 7261  ne,..    nb_para
-00009ec0: 6c6c 656c 3a20 696e 7420 3d20 2d31 2c0d  llel: int = -1,.
-00009ed0: 0a20 2020 2062 6174 6368 7369 7a65 3a20  .    batchsize: 
-00009ee0: 696e 7420 3d20 2d31 2c0d 0a20 2020 2066  int = -1,..    f
-00009ef0: 6f72 6365 3a20 626f 6f6c 203d 2046 616c  orce: bool = Fal
-00009f00: 7365 2c0d 0a20 2020 206f 7065 7261 7469  se,..    operati
-00009f10: 6f6e 5f70 7265 6669 783a 2073 7472 203d  on_prefix: str =
-00009f20: 2022 222c 0d0a 2920 2d3e 2064 6963 743a   "",..) -> dict:
-00009f30: 0d0a 2020 2020 2222 220d 0a20 2020 2046  ..    """..    F
-00009f40: 756e 6374 696f 6e20 7468 6174 2061 7070  unction that app
-00009f50: 6c69 6573 2061 2064 6973 736f 6c76 652e  lies a dissolve.
-00009f60: 0d0a 0d0a 2020 2020 4d6f 7265 2064 6574  ....    More det
-00009f70: 6169 6c65 6420 646f 6375 6d65 6e74 6174  ailed documentat
-00009f80: 696f 6e20 696e 206d 6f64 756c 6520 6765  ion in module ge
-00009f90: 6f6f 7073 210d 0a0d 0a20 2020 2052 656d  oops!....    Rem
-00009fa0: 6172 6b3a 206b 6565 705f 656d 7074 795f  ark: keep_empty_
-00009fb0: 6765 6f6d 7320 6973 206e 6f74 2069 6d70  geoms is not imp
-00009fc0: 6c65 6d65 6e74 6564 2062 6563 6175 7365  lemented because
-00009fd0: 2074 6869 7320 6973 206e 6f74 2073 6f20   this is not so 
-00009fe0: 6561 7379 2062 6563 6175 7365 0d0a 2020  easy because..  
-00009ff0: 2020 2866 6f72 2070 6f6c 7967 6f6e 2064    (for polygon d
-0000a000: 6973 736f 6c76 6529 2074 6865 2062 6174  issolve) the bat
-0000a010: 6368 6573 2061 7265 206c 6f63 6174 696f  ches are locatio
-0000a020: 6e20 6261 7365 642c 2061 6e64 206e 756c  n based, and nul
-0000a030: 6c2f 656d 7074 7920 6765 6f6d 6574 7269  l/empty geometri
-0000a040: 6573 0d0a 2020 2020 646f 6e27 7420 6861  es..    don't ha
-0000a050: 7665 2061 206c 6f63 6174 696f 6e2e 2049  ve a location. I
-0000a060: 7420 636f 756c 6420 6265 2069 6d70 6c65  t could be imple
-0000a070: 6d65 6e74 6564 2c20 6275 7420 6173 206c  mented, but as l
-0000a080: 6f6e 6720 6173 206e 6f62 6f64 7920 6e65  ong as nobody ne
-0000a090: 6564 7320 6974 2e2e 2e0d 0a20 2020 2022  eds it.....    "
-0000a0a0: 2222 0d0a 2020 2020 2320 496e 6974 2061  ""..    # Init a
-0000a0b0: 6e64 2076 616c 6964 6174 6520 696e 7075  nd validate inpu
-0000a0c0: 7420 7061 7261 6d65 7465 7273 0d0a 2020  t parameters..  
-0000a0d0: 2020 2320 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d    # ------------
-0000a0e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-0000a0f0: 2d2d 2d2d 2d2d 0d0a 2020 2020 7374 6172  ------..    star
-0000a100: 745f 7469 6d65 203d 2064 6174 6574 696d  t_time = datetim
-0000a110: 652e 6e6f 7728 290d 0a20 2020 206f 7065  e.now()..    ope
-0000a120: 7261 7469 6f6e 5f6e 616d 6520 3d20 6622  ration_name = f"
-0000a130: 7b6f 7065 7261 7469 6f6e 5f70 7265 6669  {operation_prefi
-0000a140: 787d 6469 7373 6f6c 7665 220d 0a20 2020  x}dissolve"..   
-0000a150: 206c 6f67 6765 7220 3d20 6c6f 6767 696e   logger = loggin
-0000a160: 672e 6765 744c 6f67 6765 7228 6622 6765  g.getLogger(f"ge
-0000a170: 6f66 696c 656f 7073 2e7b 6f70 6572 6174  ofileops.{operat
-0000a180: 696f 6e5f 6e61 6d65 7d22 290d 0a20 2020  ion_name}")..   
-0000a190: 2072 6573 756c 745f 696e 666f 203d 207b   result_info = {
-0000a1a0: 7d0d 0a0d 0a20 2020 2023 2043 6865 636b  }....    # Check
-0000a1b0: 2069 6e70 7574 2070 6172 616d 6574 6572   input parameter
-0000a1c0: 730d 0a20 2020 2069 6620 6772 6f75 7062  s..    if groupb
-0000a1d0: 795f 636f 6c75 6d6e 7320 6973 206e 6f74  y_columns is not
-0000a1e0: 204e 6f6e 6520 616e 6420 6c65 6e28 6c69   None and len(li
-0000a1f0: 7374 2867 726f 7570 6279 5f63 6f6c 756d  st(groupby_colum
-0000a200: 6e73 2929 203d 3d20 303a 0d0a 2020 2020  ns)) == 0:..    
-0000a210: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-0000a220: 7272 6f72 2822 6772 6f75 7062 795f 636f  rror("groupby_co
-0000a230: 6c75 6d6e 733d 5b5d 2069 7320 6e6f 7420  lumns=[] is not 
-0000a240: 7375 7070 6f72 7465 642e 2055 7365 204e  supported. Use N
-0000a250: 6f6e 652e 2229 0d0a 2020 2020 6966 206e  one.")..    if n
-0000a260: 6f74 2069 6e70 7574 5f70 6174 682e 6578  ot input_path.ex
-0000a270: 6973 7473 2829 3a0d 0a20 2020 2020 2020  ists():..       
-0000a280: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0000a290: 7228 6622 696e 7075 745f 7061 7468 2064  r(f"input_path d
-0000a2a0: 6f65 736e 2774 2065 7869 7374 3a20 7b69  oesn't exist: {i
-0000a2b0: 6e70 7574 5f70 6174 687d 2229 0d0a 2020  nput_path}")..  
-0000a2c0: 2020 6966 2069 6e70 7574 5f70 6174 6820    if input_path 
-0000a2d0: 3d3d 206f 7574 7075 745f 7061 7468 3a0d  == output_path:.
-0000a2e0: 0a20 2020 2020 2020 2072 6169 7365 2056  .        raise V
-0000a2f0: 616c 7565 4572 726f 7228 226f 7574 7075  alueError("outpu
-0000a300: 745f 7061 7468 206d 7573 7420 6e6f 7420  t_path must not 
-0000a310: 6571 7561 6c20 696e 7075 745f 7061 7468  equal input_path
-0000a320: 2229 0d0a 0d0a 2020 2020 696e 7075 745f  ")....    input_
-0000a330: 6c61 7965 7269 6e66 6f20 3d20 6766 6f2e  layerinfo = gfo.
-0000a340: 6765 745f 6c61 7965 7269 6e66 6f28 696e  get_layerinfo(in
-0000a350: 7075 745f 7061 7468 2c20 696e 7075 745f  put_path, input_
-0000a360: 6c61 7965 7229 0d0a 2020 2020 6966 2069  layer)..    if i
-0000a370: 6e70 7574 5f6c 6179 6572 696e 666f 2e67  nput_layerinfo.g
-0000a380: 656f 6d65 7472 7974 7970 652e 746f 5f70  eometrytype.to_p
-0000a390: 7269 6d69 7469 7665 7479 7065 2069 6e20  rimitivetype in 
-0000a3a0: 5b0d 0a20 2020 2020 2020 2050 7269 6d69  [..        Primi
-0000a3b0: 7469 7665 5479 7065 2e50 4f49 4e54 2c0d  tiveType.POINT,.
-0000a3c0: 0a20 2020 2020 2020 2050 7269 6d69 7469  .        Primiti
-0000a3d0: 7665 5479 7065 2e4c 494e 4553 5452 494e  veType.LINESTRIN
-0000a3e0: 472c 0d0a 2020 2020 5d3a 0d0a 2020 2020  G,..    ]:..    
-0000a3f0: 2020 2020 6966 2074 696c 6573 5f70 6174      if tiles_pat
-0000a400: 6820 6973 206e 6f74 204e 6f6e 6520 6f72  h is not None or
-0000a410: 206e 625f 7371 7561 7269 7368 5f74 696c   nb_squarish_til
-0000a420: 6573 203e 2031 3a0d 0a20 2020 2020 2020  es > 1:..       
-0000a430: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-0000a440: 4572 726f 7228 0d0a 2020 2020 2020 2020  Error(..        
-0000a450: 2020 2020 2020 2020 6622 4469 7373 6f6c          f"Dissol
-0000a460: 7665 2074 6f20 7469 6c65 7320 6973 206e  ve to tiles is n
-0000a470: 6f74 2073 7570 706f 7274 6564 2066 6f72  ot supported for
-0000a480: 207b 696e 7075 745f 6c61 7965 7269 6e66   {input_layerinf
-0000a490: 6f2e 6765 6f6d 6574 7279 7479 7065 7d22  o.geometrytype}"
-0000a4a0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000a4b0: 2020 222c 2073 6f20 7469 6c65 735f 7061    ", so tiles_pa
-0000a4c0: 7468 2073 686f 756c 6420 6265 204e 6f6e  th should be Non
-0000a4d0: 6520 616e 6420 6e62 5f73 7175 6172 6973  e and nb_squaris
-0000a4e0: 685f 7469 6c65 7320 7368 6f75 6c64 2062  h_tiles should b
-0000a4f0: 6520 3129 220d 0a20 2020 2020 2020 2020  e 1)"..         
-0000a500: 2020 2029 0d0a 0d0a 2020 2020 6966 2069     )....    if i
-0000a510: 6e70 7574 5f6c 6179 6572 2069 7320 4e6f  nput_layer is No
-0000a520: 6e65 3a0d 0a20 2020 2020 2020 2069 6e70  ne:..        inp
-0000a530: 7574 5f6c 6179 6572 203d 2067 666f 2e67  ut_layer = gfo.g
-0000a540: 6574 5f6f 6e6c 795f 6c61 7965 7228 696e  et_only_layer(in
-0000a550: 7075 745f 7061 7468 290d 0a20 2020 2069  put_path)..    i
-0000a560: 6620 6f75 7470 7574 5f6c 6179 6572 2069  f output_layer i
-0000a570: 7320 4e6f 6e65 3a0d 0a20 2020 2020 2020  s None:..       
-0000a580: 206f 7574 7075 745f 6c61 7965 7220 3d20   output_layer = 
-0000a590: 6766 6f2e 6765 745f 6465 6661 756c 745f  gfo.get_default_
-0000a5a0: 6c61 7965 7228 6f75 7470 7574 5f70 6174  layer(output_pat
-0000a5b0: 6829 0d0a 0d0a 2020 2020 2320 4368 6563  h)....    # Chec
-0000a5c0: 6b20 636f 6c75 6d6e 7320 696e 2067 726f  k columns in gro
-0000a5d0: 7570 6279 5f63 6f6c 756d 6e73 0d0a 2020  upby_columns..  
-0000a5e0: 2020 636f 6c75 6d6e 735f 6176 6169 6c61    columns_availa
-0000a5f0: 626c 6520 3d20 6c69 7374 2869 6e70 7574  ble = list(input
-0000a600: 5f6c 6179 6572 696e 666f 2e63 6f6c 756d  _layerinfo.colum
-0000a610: 6e73 2920 2b20 5b22 6669 6422 5d0d 0a20  ns) + ["fid"].. 
-0000a620: 2020 2069 6620 6772 6f75 7062 795f 636f     if groupby_co
-0000a630: 6c75 6d6e 7320 6973 206e 6f74 204e 6f6e  lumns is not Non
-0000a640: 653a 0d0a 2020 2020 2020 2020 636f 6c75  e:..        colu
-0000a650: 6d6e 735f 696e 5f6c 6179 6572 5f75 7070  mns_in_layer_upp
-0000a660: 6572 203d 205b 636f 6c75 6d6e 2e75 7070  er = [column.upp
-0000a670: 6572 2829 2066 6f72 2063 6f6c 756d 6e20  er() for column 
-0000a680: 696e 2063 6f6c 756d 6e73 5f61 7661 696c  in columns_avail
-0000a690: 6162 6c65 5d0d 0a20 2020 2020 2020 2066  able]..        f
-0000a6a0: 6f72 2063 6f6c 756d 6e20 696e 2067 726f  or column in gro
-0000a6b0: 7570 6279 5f63 6f6c 756d 6e73 3a0d 0a20  upby_columns:.. 
-0000a6c0: 2020 2020 2020 2020 2020 2069 6620 636f             if co
-0000a6d0: 6c75 6d6e 2e75 7070 6572 2829 206e 6f74  lumn.upper() not
-0000a6e0: 2069 6e20 636f 6c75 6d6e 735f 696e 5f6c   in columns_in_l
-0000a6f0: 6179 6572 5f75 7070 6572 3a0d 0a20 2020  ayer_upper:..   
-0000a700: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-0000a710: 7365 2056 616c 7565 4572 726f 7228 0d0a  se ValueError(..
-0000a720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a730: 2020 2020 6622 636f 6c75 6d6e 2069 6e20      f"column in 
-0000a740: 6772 6f75 7062 795f 636f 6c75 6d6e 7320  groupby_columns 
-0000a750: 6e6f 7420 6176 6169 6c61 626c 6520 696e  not available in
-0000a760: 206c 6179 6572 3a20 7b63 6f6c 756d 6e7d   layer: {column}
-0000a770: 220d 0a20 2020 2020 2020 2020 2020 2020  "..             
-0000a780: 2020 2029 0d0a 2020 2020 2020 2020 636f     )..        co
-0000a790: 6c75 6d6e 735f 6176 6169 6c61 626c 6520  lumns_available 
-0000a7a0: 3d20 5f67 656e 6572 616c 5f75 7469 6c2e  = _general_util.
-0000a7b0: 616c 6967 6e5f 6361 7369 6e67 5f6c 6973  align_casing_lis
-0000a7c0: 7428 0d0a 2020 2020 2020 2020 2020 2020  t(..            
-0000a7d0: 636f 6c75 6d6e 735f 6176 6169 6c61 626c  columns_availabl
-0000a7e0: 652c 2067 726f 7570 6279 5f63 6f6c 756d  e, groupby_colum
-0000a7f0: 6e73 2c20 7261 6973 655f 6f6e 5f6d 6973  ns, raise_on_mis
-0000a800: 7369 6e67 3d46 616c 7365 0d0a 2020 2020  sing=False..    
-0000a810: 2020 2020 290d 0a0d 0a20 2020 2023 2043      )....    # C
-0000a820: 6865 636b 2061 6767 5f63 6f6c 756d 6e73  heck agg_columns
-0000a830: 2070 6172 616d 0d0a 2020 2020 6966 2061   param..    if a
-0000a840: 6767 5f63 6f6c 756d 6e73 2069 7320 6e6f  gg_columns is no
-0000a850: 7420 4e6f 6e65 3a0d 0a20 2020 2020 2020  t None:..       
-0000a860: 2023 2056 616c 6964 6174 6520 7468 6520   # Validate the 
-0000a870: 6469 6374 2073 7472 7563 7475 7265 2c20  dict structure, 
-0000a880: 736f 2077 6520 6361 6e20 6173 7375 6d65  so we can assume
-0000a890: 2065 7665 7279 7468 696e 6720 6973 204f   everything is O
-0000a8a0: 4b20 6675 7274 6865 7220 6f6e 0d0a 2020  K further on..  
-0000a8b0: 2020 2020 2020 5f70 6172 616d 6574 6572        _parameter
-0000a8c0: 5f68 656c 7065 722e 7661 6c69 6461 7465  _helper.validate
-0000a8d0: 5f61 6767 5f63 6f6c 756d 6e73 2861 6767  _agg_columns(agg
-0000a8e0: 5f63 6f6c 756d 6e73 290d 0a0d 0a20 2020  _columns)....   
-0000a8f0: 2020 2020 2023 2046 6972 7374 2074 616b       # First tak
-0000a900: 6520 6120 6465 6570 2063 6f70 792c 2061  e a deep copy, a
-0000a910: 7320 7661 6c75 6573 2063 616e 2062 6520  s values can be 
-0000a920: 6368 616e 6765 6420 6675 7274 6865 7220  changed further 
-0000a930: 6f6e 2074 6f20 7472 6561 7420 636f 6c75  on to treat colu
-0000a940: 6d6e 730d 0a20 2020 2020 2020 2023 2063  mns..        # c
-0000a950: 6173 6520 696e 7365 6e73 6974 6976 650d  ase insensitive.
-0000a960: 0a20 2020 2020 2020 2061 6767 5f63 6f6c  .        agg_col
-0000a970: 756d 6e73 203d 206a 736f 6e2e 6c6f 6164  umns = json.load
-0000a980: 7328 6a73 6f6e 2e64 756d 7073 2861 6767  s(json.dumps(agg
-0000a990: 5f63 6f6c 756d 6e73 2929 0d0a 2020 2020  _columns))..    
-0000a9a0: 2020 2020 6173 7365 7274 2061 6767 5f63      assert agg_c
-0000a9b0: 6f6c 756d 6e73 2069 7320 6e6f 7420 4e6f  olumns is not No
-0000a9c0: 6e65 0d0a 2020 2020 2020 2020 6966 2022  ne..        if "
-0000a9d0: 6a73 6f6e 2220 696e 2061 6767 5f63 6f6c  json" in agg_col
-0000a9e0: 756d 6e73 3a0d 0a20 2020 2020 2020 2020  umns:..         
-0000a9f0: 2020 2069 6620 6167 675f 636f 6c75 6d6e     if agg_column
-0000aa00: 735b 226a 736f 6e22 5d20 6973 204e 6f6e  s["json"] is Non
-0000aa10: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-0000aa20: 2020 2020 6167 675f 636f 6c75 6d6e 735b      agg_columns[
-0000aa30: 226a 736f 6e22 5d20 3d20 5b0d 0a20 2020  "json"] = [..   
-0000aa40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa50: 2063 2066 6f72 2063 2069 6e20 636f 6c75   c for c in colu
-0000aa60: 6d6e 735f 6176 6169 6c61 626c 6520 6966  mns_available if
-0000aa70: 2063 2e6c 6f77 6572 2829 206e 6f74 2069   c.lower() not i
-0000aa80: 6e20 2822 696e 6465 7822 2c20 2266 6964  n ("index", "fid
-0000aa90: 2229 0d0a 2020 2020 2020 2020 2020 2020  ")..            
-0000aaa0: 2020 2020 5d0d 0a20 2020 2020 2020 2020      ]..         
-0000aab0: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-0000aac0: 2020 2020 2020 2020 2020 2320 416c 6967            # Alig
-0000aad0: 6e20 6361 7369 6e67 206f 6620 636f 6c75  n casing of colu
-0000aae0: 6d6e 206e 616d 6573 2074 6f20 6461 7461  mn names to data
-0000aaf0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000ab00: 2020 6167 675f 636f 6c75 6d6e 735b 226a    agg_columns["j
-0000ab10: 736f 6e22 5d20 3d20 5f67 656e 6572 616c  son"] = _general
-0000ab20: 5f75 7469 6c2e 616c 6967 6e5f 6361 7369  _util.align_casi
-0000ab30: 6e67 5f6c 6973 7428 0d0a 2020 2020 2020  ng_list(..      
-0000ab40: 2020 2020 2020 2020 2020 2020 2020 6167                ag
-0000ab50: 675f 636f 6c75 6d6e 735b 226a 736f 6e22  g_columns["json"
-0000ab60: 5d2c 2063 6f6c 756d 6e73 5f61 7661 696c  ], columns_avail
-0000ab70: 6162 6c65 0d0a 2020 2020 2020 2020 2020  able..          
-0000ab80: 2020 2020 2020 290d 0a20 2020 2020 2020        )..       
-0000ab90: 2065 6c69 6620 2263 6f6c 756d 6e73 2220   elif "columns" 
-0000aba0: 696e 2061 6767 5f63 6f6c 756d 6e73 3a0d  in agg_columns:.
-0000abb0: 0a20 2020 2020 2020 2020 2020 2023 204c  .            # L
-0000abc0: 6f6f 7020 7468 726f 7567 6820 616c 6c20  oop through all 
-0000abd0: 726f 7773 0d0a 2020 2020 2020 2020 2020  rows..          
-0000abe0: 2020 666f 7220 6167 675f 636f 6c75 6d6e    for agg_column
-0000abf0: 2069 6e20 6167 675f 636f 6c75 6d6e 735b   in agg_columns[
-0000ac00: 2263 6f6c 756d 6e73 225d 3a0d 0a20 2020  "columns"]:..   
-0000ac10: 2020 2020 2020 2020 2020 2020 2023 2043               # C
-0000ac20: 6865 636b 2069 6620 636f 6c75 6d6e 2065  heck if column e
-0000ac30: 7869 7374 7320 2b20 7365 7420 6361 7369  xists + set casi
-0000ac40: 6e67 2073 616d 6520 6173 2069 6e20 6461  ng same as in da
-0000ac50: 7461 0d0a 2020 2020 2020 2020 2020 2020  ta..            
-0000ac60: 2020 2020 6167 675f 636f 6c75 6d6e 5b22      agg_column["
-0000ac70: 636f 6c75 6d6e 225d 203d 205f 6765 6e65  column"] = _gene
-0000ac80: 7261 6c5f 7574 696c 2e61 6c69 676e 5f63  ral_util.align_c
-0000ac90: 6173 696e 6728 0d0a 2020 2020 2020 2020  asing(..        
-0000aca0: 2020 2020 2020 2020 2020 2020 6167 675f              agg_
-0000acb0: 636f 6c75 6d6e 5b22 636f 6c75 6d6e 225d  column["column"]
-0000acc0: 2c20 636f 6c75 6d6e 735f 6176 6169 6c61  , columns_availa
-0000acd0: 626c 650d 0a20 2020 2020 2020 2020 2020  ble..           
-0000ace0: 2020 2020 2029 0d0a 0d0a 2020 2020 2320       )....    # 
-0000acf0: 4e6f 7720 696e 7075 7420 7061 7261 6d65  Now input parame
-0000ad00: 7465 7273 2061 7265 2063 6865 636b 6564  ters are checked
-0000ad10: 2c20 6368 6563 6b20 6966 2077 6520 6e65  , check if we ne
-0000ad20: 6564 2074 6f20 6361 6c63 756c 6174 6520  ed to calculate 
-0000ad30: 616e 7977 6179 0d0a 2020 2020 6966 206f  anyway..    if o
-0000ad40: 7574 7075 745f 7061 7468 2e65 7869 7374  utput_path.exist
-0000ad50: 7328 293a 0d0a 2020 2020 2020 2020 6966  s():..        if
-0000ad60: 2066 6f72 6365 2069 7320 4661 6c73 653a   force is False:
-0000ad70: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-0000ad80: 7375 6c74 5f69 6e66 6f5b 0d0a 2020 2020  sult_info[..    
-0000ad90: 2020 2020 2020 2020 2020 2020 226d 6573              "mes
-0000ada0: 7361 6765 220d 0a20 2020 2020 2020 2020  sage"..         
-0000adb0: 2020 205d 203d 2066 2253 746f 702c 206f     ] = f"Stop, o
-0000adc0: 7574 7075 7420 6578 6973 7473 2061 6c72  utput exists alr
-0000add0: 6561 6479 207b 6f75 7470 7574 5f70 6174  eady {output_pat
-0000ade0: 687d 2061 6e64 2066 6f72 6365 2069 7320  h} and force is 
-0000adf0: 6661 6c73 6522 0d0a 2020 2020 2020 2020  false"..        
-0000ae00: 2020 2020 6c6f 6767 6572 2e69 6e66 6f28      logger.info(
-0000ae10: 7265 7375 6c74 5f69 6e66 6f5b 226d 6573  result_info["mes
-0000ae20: 7361 6765 225d 290d 0a20 2020 2020 2020  sage"])..       
-0000ae30: 2020 2020 2072 6574 7572 6e20 7265 7375       return resu
-0000ae40: 6c74 5f69 6e66 6f0d 0a20 2020 2020 2020  lt_info..       
-0000ae50: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-0000ae60: 2020 2020 6766 6f2e 7265 6d6f 7665 286f      gfo.remove(o
-0000ae70: 7574 7075 745f 7061 7468 290d 0a0d 0a20  utput_path).... 
-0000ae80: 2020 2023 204e 6f77 2073 7461 7274 2064     # Now start d
-0000ae90: 6973 736f 6c76 696e 670d 0a20 2020 2023  issolving..    #
-0000aea0: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   ---------------
-0000aeb0: 2d2d 2d2d 2d0d 0a20 2020 2023 2045 6d70  -----..    # Emp
-0000aec0: 7479 206f 7220 4c69 6e65 2061 6e64 2070  ty or Line and p
-0000aed0: 6f69 6e74 206c 6179 6572 7320 6172 653a  oint layers are:
-0000aee0: 0d0a 2020 2020 2320 2020 2a20 6e6f 7420  ..    #   * not 
-0000aef0: 736f 206c 6172 6765 2028 6d65 6d6f 7279  so large (memory
-0000af00: 2d77 6973 6529 0d0a 2020 2020 2320 2020  -wise)..    #   
-0000af10: 2a20 6172 656e 2774 2063 6f6d 7075 7461  * aren't computa
-0000af20: 7469 6f6e 616c 6c79 2068 6561 7679 0d0a  tionally heavy..
-0000af30: 2020 2020 2320 4164 6469 7469 6f6e 616c      # Additional
-0000af40: 6c79 206c 696e 6520 6c61 7965 7273 2061  ly line layers a
-0000af50: 7265 2061 2070 6169 6e20 746f 2068 616e  re a pain to han
-0000af60: 646c 6520 636f 7272 6563 746c 7920 6265  dle correctly be
-0000af70: 6361 7573 6520 6f66 0d0a 2020 2020 2320  cause of..    # 
-0000af80: 726f 756e 6469 6e67 2069 7373 7565 7320  rounding issues 
-0000af90: 6174 2074 6865 2062 6f72 6465 7273 206f  at the borders o
-0000afa0: 6620 7469 6c65 732e 2e2e 2073 6f20 6a75  f tiles... so ju
-0000afb0: 7374 2064 6973 736f 6c76 6520 7468 656d  st dissolve them
-0000afc0: 2069 6e20 6f6e 6520 676f 2e0d 0a20 2020   in one go...   
-0000afd0: 2069 6620 280d 0a20 2020 2020 2020 2069   if (..        i
-0000afe0: 6e70 7574 5f6c 6179 6572 696e 666f 2e66  nput_layerinfo.f
-0000aff0: 6561 7475 7265 636f 756e 7420 3d3d 2030  eaturecount == 0
-0000b000: 0d0a 2020 2020 2020 2020 6f72 2069 6e70  ..        or inp
-0000b010: 7574 5f6c 6179 6572 696e 666f 2e67 656f  ut_layerinfo.geo
-0000b020: 6d65 7472 7974 7970 652e 746f 5f70 7269  metrytype.to_pri
-0000b030: 6d69 7469 7665 7479 7065 0d0a 2020 2020  mitivetype..    
-0000b040: 2020 2020 696e 205b 0d0a 2020 2020 2020      in [..      
-0000b050: 2020 2020 2020 5072 696d 6974 6976 6554        PrimitiveT
-0000b060: 7970 652e 504f 494e 542c 0d0a 2020 2020  ype.POINT,..    
-0000b070: 2020 2020 2020 2020 5072 696d 6974 6976          Primitiv
-0000b080: 6554 7970 652e 4c49 4e45 5354 5249 4e47  eType.LINESTRING
-0000b090: 2c0d 0a20 2020 2020 2020 205d 0d0a 2020  ,..        ]..  
-0000b0a0: 2020 293a 0d0a 2020 2020 2020 2020 5f67    ):..        _g
-0000b0b0: 656f 6f70 735f 7371 6c2e 6469 7373 6f6c  eoops_sql.dissol
-0000b0c0: 7665 5f73 696e 676c 6574 6872 6561 6428  ve_singlethread(
-0000b0d0: 0d0a 2020 2020 2020 2020 2020 2020 696e  ..            in
-0000b0e0: 7075 745f 7061 7468 3d69 6e70 7574 5f70  put_path=input_p
-0000b0f0: 6174 682c 0d0a 2020 2020 2020 2020 2020  ath,..          
-0000b100: 2020 6f75 7470 7574 5f70 6174 683d 6f75    output_path=ou
-0000b110: 7470 7574 5f70 6174 682c 0d0a 2020 2020  tput_path,..    
-0000b120: 2020 2020 2020 2020 6578 706c 6f64 6563          explodec
-0000b130: 6f6c 6c65 6374 696f 6e73 3d65 7870 6c6f  ollections=explo
-0000b140: 6465 636f 6c6c 6563 7469 6f6e 732c 0d0a  decollections,..
-0000b150: 2020 2020 2020 2020 2020 2020 6772 6f75              grou
-0000b160: 7062 795f 636f 6c75 6d6e 733d 6772 6f75  pby_columns=grou
-0000b170: 7062 795f 636f 6c75 6d6e 732c 0d0a 2020  pby_columns,..  
-0000b180: 2020 2020 2020 2020 2020 6167 675f 636f            agg_co
-0000b190: 6c75 6d6e 733d 6167 675f 636f 6c75 6d6e  lumns=agg_column
-0000b1a0: 732c 0d0a 2020 2020 2020 2020 2020 2020  s,..            
-0000b1b0: 696e 7075 745f 6c61 7965 723d 696e 7075  input_layer=inpu
-0000b1c0: 745f 6c61 7965 722c 0d0a 2020 2020 2020  t_layer,..      
-0000b1d0: 2020 2020 2020 6f75 7470 7574 5f6c 6179        output_lay
-0000b1e0: 6572 3d6f 7574 7075 745f 6c61 7965 722c  er=output_layer,
-0000b1f0: 0d0a 2020 2020 2020 2020 2020 2020 6772  ..            gr
-0000b200: 6964 7369 7a65 3d67 7269 6473 697a 652c  idsize=gridsize,
-0000b210: 0d0a 2020 2020 2020 2020 2020 2020 6b65  ..            ke
-0000b220: 6570 5f65 6d70 7479 5f67 656f 6d73 3d46  ep_empty_geoms=F
-0000b230: 616c 7365 2c0d 0a20 2020 2020 2020 2020  alse,..         
-0000b240: 2020 2077 6865 7265 5f70 6f73 743d 7768     where_post=wh
-0000b250: 6572 655f 706f 7374 2c0d 0a20 2020 2020  ere_post,..     
-0000b260: 2020 2020 2020 2066 6f72 6365 3d66 6f72         force=for
-0000b270: 6365 2c0d 0a20 2020 2020 2020 2029 0d0a  ce,..        )..
-0000b280: 0d0a 2020 2020 656c 6966 2069 6e70 7574  ..    elif input
-0000b290: 5f6c 6179 6572 696e 666f 2e67 656f 6d65  _layerinfo.geome
-0000b2a0: 7472 7974 7970 652e 746f 5f70 7269 6d69  trytype.to_primi
-0000b2b0: 7469 7665 7479 7065 2069 7320 5072 696d  tivetype is Prim
-0000b2c0: 6974 6976 6554 7970 652e 504f 4c59 474f  itiveType.POLYGO
-0000b2d0: 4e3a 0d0a 2020 2020 2020 2020 2320 5072  N:..        # Pr
-0000b2e0: 6570 6172 6520 7768 6572 655f 706f 7374  epare where_post
-0000b2f0: 0d0a 2020 2020 2020 2020 6966 2077 6865  ..        if whe
-0000b300: 7265 5f70 6f73 7420 6973 206e 6f74 204e  re_post is not N
-0000b310: 6f6e 653a 0d0a 2020 2020 2020 2020 2020  one:..          
-0000b320: 2020 6966 2077 6865 7265 5f70 6f73 7420    if where_post 
-0000b330: 3d3d 2022 223a 0d0a 2020 2020 2020 2020  == "":..        
-0000b340: 2020 2020 2020 2020 7768 6572 655f 706f          where_po
-0000b350: 7374 203d 204e 6f6e 650d 0a20 2020 2020  st = None..     
-0000b360: 2020 2020 2020 2065 6c73 653a 0d0a 2020         else:..  
-0000b370: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000b380: 5365 7420 6765 6f6d 6574 7279 636f 6c75  Set geometrycolu
-0000b390: 6d6e 2074 6f20 2267 656f 6d22 2c20 6265  mn to "geom", be
-0000b3a0: 6361 7573 6520 7465 6d70 2066 696c 6573  cause temp files
-0000b3b0: 2061 7265 2073 6176 6564 2061 7320 6770   are saved as gp
-0000b3c0: 6b67 2e0d 0a20 2020 2020 2020 2020 2020  kg...           
-0000b3d0: 2020 2020 2077 6865 7265 5f70 6f73 7420       where_post 
-0000b3e0: 3d20 7768 6572 655f 706f 7374 2e66 6f72  = where_post.for
-0000b3f0: 6d61 7428 6765 6f6d 6574 7279 636f 6c75  mat(geometrycolu
-0000b400: 6d6e 3d22 6765 6f6d 2229 0d0a 0d0a 2020  mn="geom")....  
-0000b410: 2020 2020 2020 2320 4966 2061 2074 696c        # If a til
-0000b420: 6573 5f70 6174 6820 6973 2073 7065 6369  es_path is speci
-0000b430: 6669 6564 2c20 7265 6164 2074 686f 7365  fied, read those
-0000b440: 2074 696c 6573 2e2e 2e0d 0a20 2020 2020   tiles.....     
-0000b450: 2020 2072 6573 756c 745f 7469 6c65 735f     result_tiles_
-0000b460: 6764 6620 3d20 4e6f 6e65 0d0a 2020 2020  gdf = None..    
-0000b470: 2020 2020 6966 2074 696c 6573 5f70 6174      if tiles_pat
-0000b480: 6820 6973 206e 6f74 204e 6f6e 653a 0d0a  h is not None:..
-0000b490: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-0000b4a0: 6c74 5f74 696c 6573 5f67 6466 203d 2067  lt_tiles_gdf = g
-0000b4b0: 666f 2e72 6561 645f 6669 6c65 2874 696c  fo.read_file(til
-0000b4c0: 6573 5f70 6174 6829 0d0a 2020 2020 2020  es_path)..      
-0000b4d0: 2020 2020 2020 6966 206e 625f 7061 7261        if nb_para
-0000b4e0: 6c6c 656c 203d 3d20 2d31 3a0d 0a20 2020  llel == -1:..   
-0000b4f0: 2020 2020 2020 2020 2020 2020 206e 625f               nb_
-0000b500: 6370 7520 3d20 6d75 6c74 6970 726f 6365  cpu = multiproce
-0000b510: 7373 696e 672e 6370 755f 636f 756e 7428  ssing.cpu_count(
-0000b520: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-0000b530: 2020 206e 625f 7061 7261 6c6c 656c 203d     nb_parallel =
-0000b540: 206e 625f 6370 7520 2023 2069 6e74 2831   nb_cpu  # int(1
-0000b550: 2e32 3520 2a20 6e62 5f63 7075 290d 0a20  .25 * nb_cpu).. 
-0000b560: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000b570: 6f67 6765 722e 6465 6275 6728 6622 4e62  ogger.debug(f"Nb
-0000b580: 2063 7075 7320 666f 756e 643a 207b 6e62   cpus found: {nb
-0000b590: 5f63 7075 7d2c 206e 625f 7061 7261 6c6c  _cpu}, nb_parall
-0000b5a0: 656c 3a20 7b6e 625f 7061 7261 6c6c 656c  el: {nb_parallel
-0000b5b0: 7d22 290d 0a20 2020 2020 2020 2065 6c73  }")..        els
-0000b5c0: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-0000b5d0: 2320 456c 7365 2c20 6372 6561 7465 2061  # Else, create a
-0000b5e0: 2067 7269 6420 6261 7365 6420 6f6e 2074   grid based on t
-0000b5f0: 6865 206e 756d 6265 7220 6f66 2074 696c  he number of til
-0000b600: 6573 2077 616e 7465 6420 6173 2072 6573  es wanted as res
-0000b610: 756c 740d 0a20 2020 2020 2020 2020 2020  ult..           
-0000b620: 2023 2055 7365 2061 206d 6172 6769 6e20   # Use a margin 
-0000b630: 6f66 2031 206d 6574 6572 2061 726f 756e  of 1 meter aroun
-0000b640: 6420 7468 6520 626f 756e 6473 0d0a 2020  d the bounds..  
-0000b650: 2020 2020 2020 2020 2020 6d61 7267 696e            margin
-0000b660: 203d 2031 2e30 0d0a 2020 2020 2020 2020   = 1.0..        
-0000b670: 2020 2020 6966 2069 6e70 7574 5f6c 6179      if input_lay
-0000b680: 6572 696e 666f 2e63 7273 2069 7320 6e6f  erinfo.crs is no
-0000b690: 7420 4e6f 6e65 2061 6e64 206e 6f74 2069  t None and not i
-0000b6a0: 6e70 7574 5f6c 6179 6572 696e 666f 2e63  nput_layerinfo.c
-0000b6b0: 7273 2e69 735f 7072 6f6a 6563 7465 643a  rs.is_projected:
-0000b6c0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000b6d0: 2020 2320 4966 2067 656f 6772 6170 6869    # If geographi
-0000b6e0: 6320 6372 732c 2031 2064 6567 7265 6520  c crs, 1 degree 
-0000b6f0: 3d20 3131 3120 6b6d 206f 7220 3131 3130  = 111 km or 1110
-0000b700: 3030 206d 0d0a 2020 2020 2020 2020 2020  00 m..          
-0000b710: 2020 2020 2020 6d61 7267 696e 202f 3d20        margin /= 
-0000b720: 3131 3130 3030 0d0a 2020 2020 2020 2020  111000..        
-0000b730: 2020 2020 626f 756e 6473 203d 2069 6e70      bounds = inp
-0000b740: 7574 5f6c 6179 6572 696e 666f 2e74 6f74  ut_layerinfo.tot
-0000b750: 616c 5f62 6f75 6e64 730d 0a20 2020 2020  al_bounds..     
-0000b760: 2020 2020 2020 2062 6f75 6e64 7320 3d20         bounds = 
-0000b770: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-0000b780: 2020 2062 6f75 6e64 735b 305d 202d 206d     bounds[0] - m
-0000b790: 6172 6769 6e2c 0d0a 2020 2020 2020 2020  argin,..        
-0000b7a0: 2020 2020 2020 2020 626f 756e 6473 5b31          bounds[1
-0000b7b0: 5d20 2d20 6d61 7267 696e 2c0d 0a20 2020  ] - margin,..   
-0000b7c0: 2020 2020 2020 2020 2020 2020 2062 6f75               bou
-0000b7d0: 6e64 735b 325d 202b 206d 6172 6769 6e2c  nds[2] + margin,
-0000b7e0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000b7f0: 2020 626f 756e 6473 5b33 5d20 2b20 6d61    bounds[3] + ma
-0000b800: 7267 696e 2c0d 0a20 2020 2020 2020 2020  rgin,..         
-0000b810: 2020 2029 0d0a 2020 2020 2020 2020 2020     )..          
-0000b820: 2020 7265 7375 6c74 5f74 696c 6573 5f67    result_tiles_g
-0000b830: 6466 203d 2067 7064 2e47 656f 4461 7461  df = gpd.GeoData
-0000b840: 4672 616d 6528 0d0a 2020 2020 2020 2020  Frame(..        
-0000b850: 2020 2020 2020 2020 6765 6f6d 6574 7279          geometry
-0000b860: 3d70 7967 656f 6f70 732e 6372 6561 7465  =pygeoops.create
-0000b870: 5f67 7269 6432 2862 6f75 6e64 732c 206e  _grid2(bounds, n
-0000b880: 625f 7371 7561 7269 7368 5f74 696c 6573  b_squarish_tiles
-0000b890: 292c 0d0a 2020 2020 2020 2020 2020 2020  ),..            
-0000b8a0: 2020 2020 6372 733d 696e 7075 745f 6c61      crs=input_la
-0000b8b0: 7965 7269 6e66 6f2e 6372 732c 0d0a 2020  yerinfo.crs,..  
-0000b8c0: 2020 2020 2020 2020 2020 290d 0a0d 0a20            ).... 
-0000b8d0: 2020 2020 2020 2023 2041 7070 6c79 2067         # Apply g
-0000b8e0: 7269 6473 697a 6520 746f 6c65 7261 6e63  ridsize toleranc
-0000b8f0: 6520 6f6e 2074 696c 6573 2c20 6f74 6865  e on tiles, othe
-0000b900: 7277 6973 6520 7468 6520 626f 7264 6572  rwise the border
-0000b910: 2070 6f6c 7967 6f6e 7320 6361 6e27 7420   polygons can't 
-0000b920: 6265 0d0a 2020 2020 2020 2020 2320 756e  be..        # un
-0000b930: 696f 6e65 6420 7072 6f70 6572 6c79 2062  ioned properly b
-0000b940: 6563 6175 7365 2067 6170 7320 6170 7065  ecause gaps appe
-0000b950: 6172 2061 6674 6572 2072 6f75 6e64 696e  ar after roundin
-0000b960: 6720 636f 6f72 6469 6e61 7465 732e 0d0a  g coordinates...
-0000b970: 2020 2020 2020 2020 6966 2067 7269 6473          if grids
-0000b980: 697a 6520 213d 2030 2e30 3a0d 0a20 2020  ize != 0.0:..   
-0000b990: 2020 2020 2020 2020 2072 6573 756c 745f           result_
-0000b9a0: 7469 6c65 735f 6764 662e 6765 6f6d 6574  tiles_gdf.geomet
-0000b9b0: 7279 203d 2073 6861 7065 6c79 2e73 6574  ry = shapely.set
-0000b9c0: 5f70 7265 6369 7369 6f6e 280d 0a20 2020  _precision(..   
-0000b9d0: 2020 2020 2020 2020 2020 2020 2072 6573               res
-0000b9e0: 756c 745f 7469 6c65 735f 6764 662e 6765  ult_tiles_gdf.ge
-0000b9f0: 6f6d 6574 7279 2c20 6772 6964 5f73 697a  ometry, grid_siz
-0000ba00: 653d 6772 6964 7369 7a65 0d0a 2020 2020  e=gridsize..    
-0000ba10: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-0000ba20: 2020 2069 6620 6c65 6e28 7265 7375 6c74     if len(result
-0000ba30: 5f74 696c 6573 5f67 6466 2920 3e20 313a  _tiles_gdf) > 1:
-0000ba40: 0d0a 2020 2020 2020 2020 2020 2020 6766  ..            gf
-0000ba50: 6f2e 746f 5f66 696c 6528 0d0a 2020 2020  o.to_file(..    
-0000ba60: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-0000ba70: 6c74 5f74 696c 6573 5f67 6466 2c0d 0a20  lt_tiles_gdf,.. 
-0000ba80: 2020 2020 2020 2020 2020 2020 2020 206f                 o
-0000ba90: 7574 7075 745f 7061 7468 2e70 6172 656e  utput_path.paren
-0000baa0: 7420 2f20 6622 7b6f 7574 7075 745f 7061  t / f"{output_pa
-0000bab0: 7468 2e73 7465 6d7d 5f74 696c 6573 2e67  th.stem}_tiles.g
-0000bac0: 706b 6722 2c0d 0a20 2020 2020 2020 2020  pkg",..         
-0000bad0: 2020 2029 0d0a 0d0a 2020 2020 2020 2020     )....        
-0000bae0: 2320 4966 2061 2074 696c 6564 2072 6573  # If a tiled res
-0000baf0: 756c 7420 6973 2061 736b 6564 2c20 6164  ult is asked, ad
-0000bb00: 6420 7469 6c65 5f69 6420 746f 2067 726f  d tile_id to gro
-0000bb10: 7570 206f 6e20 666f 7220 7468 6520 7265  up on for the re
-0000bb20: 7375 6c74 0d0a 2020 2020 2020 2020 6966  sult..        if
-0000bb30: 206c 656e 2872 6573 756c 745f 7469 6c65   len(result_tile
-0000bb40: 735f 6764 6629 203e 2031 3a0d 0a20 2020  s_gdf) > 1:..   
-0000bb50: 2020 2020 2020 2020 2072 6573 756c 745f           result_
-0000bb60: 7469 6c65 735f 6764 665b 2274 696c 655f  tiles_gdf["tile_
-0000bb70: 6964 225d 203d 2072 6573 756c 745f 7469  id"] = result_ti
-0000bb80: 6c65 735f 6764 662e 7265 7365 745f 696e  les_gdf.reset_in
-0000bb90: 6465 7828 292e 696e 6465 780d 0a0d 0a20  dex().index.... 
-0000bba0: 2020 2020 2020 2023 2054 6865 2064 6973         # The dis
-0000bbb0: 736f 6c76 6520 666f 7220 706f 6c79 676f  solve for polygo
-0000bbc0: 6e73 2069 7320 646f 6e65 2069 6e20 7365  ns is done in se
-0000bbd0: 7665 7261 6c20 7061 7373 6573 2c20 616e  veral passes, an
-0000bbe0: 6420 6166 7465 7220 7468 6520 6669 7273  d after the firs
-0000bbf0: 740d 0a20 2020 2020 2020 2023 2070 6173  t..        # pas
-0000bc00: 732c 206f 6e6c 7920 7468 6520 276f 6e62  s, only the 'onb
-0000bc10: 6f72 6465 7227 2066 6561 7475 7265 7320  order' features 
-0000bc20: 6172 6520 6675 7274 6865 7220 6469 7373  are further diss
-0000bc30: 6f6c 7665 642c 2061 7320 7468 650d 0a20  olved, as the.. 
-0000bc40: 2020 2020 2020 2023 2027 6e6f 746f 6e62         # 'notonb
-0000bc50: 6f72 6465 7227 2066 6561 7475 7265 7320  order' features 
-0000bc60: 6172 6520 616c 7265 6164 7920 4f4b 2e0d  are already OK..
-0000bc70: 0a20 2020 2020 2020 2074 656d 7064 6972  .        tempdir
-0000bc80: 203d 205f 696f 5f75 7469 6c2e 6372 6561   = _io_util.crea
-0000bc90: 7465 5f74 656d 7064 6972 2866 2267 656f  te_tempdir(f"geo
-0000bca0: 6669 6c65 6f70 732f 7b6f 7065 7261 7469  fileops/{operati
-0000bcb0: 6f6e 5f6e 616d 657d 2229 0d0a 2020 2020  on_name}")..    
-0000bcc0: 2020 2020 7472 793a 0d0a 2020 2020 2020      try:..      
-0000bcd0: 2020 2020 2020 6966 206f 7574 7075 745f        if output_
-0000bce0: 6c61 7965 7220 6973 204e 6f6e 653a 0d0a  layer is None:..
-0000bcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bd00: 6f75 7470 7574 5f6c 6179 6572 203d 2067  output_layer = g
-0000bd10: 666f 2e67 6574 5f64 6566 6175 6c74 5f6c  fo.get_default_l
-0000bd20: 6179 6572 286f 7574 7075 745f 7061 7468  ayer(output_path
-0000bd30: 290d 0a20 2020 2020 2020 2020 2020 206f  )..            o
-0000bd40: 7574 7075 745f 746d 705f 7061 7468 203d  utput_tmp_path =
-0000bd50: 2074 656d 7064 6972 202f 2022 6f75 7470   tempdir / "outp
-0000bd60: 7574 5f74 6d70 2e67 706b 6722 0d0a 2020  ut_tmp.gpkg"..  
-0000bd70: 2020 2020 2020 2020 2020 7072 6576 5f6e            prev_n
-0000bd80: 625f 6261 7463 6865 7320 3d20 4e6f 6e65  b_batches = None
-0000bd90: 0d0a 2020 2020 2020 2020 2020 2020 6c61  ..            la
-0000bda0: 7374 5f70 6173 7320 3d20 4661 6c73 650d  st_pass = False.
-0000bdb0: 0a20 2020 2020 2020 2020 2020 2070 6173  .            pas
-0000bdc0: 735f 6964 203d 2030 0d0a 2020 2020 2020  s_id = 0..      
-0000bdd0: 2020 2020 2020 6c6f 6767 6572 2e69 6e66        logger.inf
-0000bde0: 6f28 6622 5374 6172 742c 2077 6974 6820  o(f"Start, with 
-0000bdf0: 696e 7075 7420 7b69 6e70 7574 5f70 6174  input {input_pat
-0000be00: 687d 2229 0d0a 2020 2020 2020 2020 2020  h}")..          
-0000be10: 2020 696e 7075 745f 7061 7373 5f6c 6179    input_pass_lay
-0000be20: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
-0000be30: 5d20 3d20 696e 7075 745f 6c61 7965 720d  ] = input_layer.
-0000be40: 0a20 2020 2020 2020 2020 2020 2077 6869  .            whi
-0000be50: 6c65 2054 7275 653a 0d0a 2020 2020 2020  le True:..      
-0000be60: 2020 2020 2020 2020 2020 2320 4966 2069            # If i
-0000be70: 6e70 7574 5f70 6174 6820 646f 6573 206e  nput_path does n
-0000be80: 6f74 2065 7869 7374 2c20 7468 6520 6c61  ot exist, the la
-0000be90: 7374 2070 6173 7320 6469 646e 2774 2068  st pass didn't h
-0000bea0: 6176 6520 616e 7920 6f6e 626f 7264 6572  ave any onborder
-0000beb0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000bec0: 2020 2320 706f 6c79 676f 6e73 2061 7320    # polygons as 
-0000bed0: 7265 7375 6c74 2c20 736f 2077 6520 6172  result, so we ar
-0000bee0: 6520 7265 6164 7920 6469 7373 6f6c 7669  e ready dissolvi
-0000bef0: 6e67 2e2e 2e0d 0a20 2020 2020 2020 2020  ng.....         
-0000bf00: 2020 2020 2020 2069 6620 6e6f 7420 696e         if not in
-0000bf10: 7075 745f 7061 7468 2e65 7869 7374 7328  put_path.exists(
-0000bf20: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-0000bf30: 2020 2020 2020 2020 6272 6561 6b0d 0a0d          break...
-0000bf40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000bf50: 2023 2047 6574 2069 6e66 6f20 6f66 2074   # Get info of t
-0000bf60: 6865 2063 7572 7265 6e74 2066 696c 6520  he current file 
-0000bf70: 7468 6174 206e 6565 6473 2074 6f20 6265  that needs to be
-0000bf80: 2064 6973 736f 6c76 6564 0d0a 2020 2020   dissolved..    
-0000bf90: 2020 2020 2020 2020 2020 2020 696e 7075              inpu
-0000bfa0: 745f 7061 7373 5f6c 6179 6572 696e 666f  t_pass_layerinfo
-0000bfb0: 203d 2067 666f 2e67 6574 5f6c 6179 6572   = gfo.get_layer
-0000bfc0: 696e 666f 2869 6e70 7574 5f70 6174 682c  info(input_path,
-0000bfd0: 2069 6e70 7574 5f70 6173 735f 6c61 7965   input_pass_laye
-0000bfe0: 7229 0d0a 2020 2020 2020 2020 2020 2020  r)..            
-0000bff0: 2020 2020 6e62 5f72 6f77 735f 746f 7461      nb_rows_tota
-0000c000: 6c20 3d20 696e 7075 745f 7061 7373 5f6c  l = input_pass_l
-0000c010: 6179 6572 696e 666f 2e66 6561 7475 7265  ayerinfo.feature
-0000c020: 636f 756e 740d 0a0d 0a20 2020 2020 2020  count....       
-0000c030: 2020 2020 2020 2020 2023 2043 616c 6375           # Calcu
-0000c040: 6c61 7465 2074 6865 2062 6573 7420 6e75  late the best nu
-0000c050: 6d62 6572 206f 6620 7061 7261 6c6c 656c  mber of parallel
-0000c060: 2070 726f 6365 7373 6573 2061 6e64 2062   processes and b
-0000c070: 6174 6368 6573 2066 6f72 0d0a 2020 2020  atches for..    
-0000c080: 2020 2020 2020 2020 2020 2020 2320 7468              # th
-0000c090: 6520 6176 6169 6c61 626c 6520 7265 736f  e available reso
-0000c0a0: 7572 6365 7320 666f 7220 7468 6520 6375  urces for the cu
-0000c0b0: 7272 656e 7420 7061 7373 0d0a 2020 2020  rrent pass..    
-0000c0c0: 2020 2020 2020 2020 2020 2020 2320 4c69              # Li
-0000c0d0: 6d69 7420 7468 6520 6e62 206f 6620 726f  mit the nb of ro
-0000c0e0: 7773 2070 6572 2062 6174 6368 2c20 6173  ws per batch, as
-0000c0f0: 2064 6973 736f 6c76 6520 736c 6f77 7320   dissolve slows 
-0000c100: 646f 776e 2077 6974 6820 6d6f 7265 2072  down with more r
-0000c110: 6f77 732e 0d0a 2020 2020 2020 2020 2020  ows...          
-0000c120: 2020 2020 2020 6e62 5f70 6172 616c 6c65        nb_paralle
-0000c130: 6c2c 206e 625f 6261 7463 6865 7320 3d20  l, nb_batches = 
-0000c140: 5f64 6574 6572 6d69 6e65 5f6e 625f 6261  _determine_nb_ba
-0000c150: 7463 6865 7328 0d0a 2020 2020 2020 2020  tches(..        
-0000c160: 2020 2020 2020 2020 2020 2020 6e62 5f72              nb_r
-0000c170: 6f77 735f 746f 7461 6c3d 6e62 5f72 6f77  ows_total=nb_row
-0000c180: 735f 746f 7461 6c2c 0d0a 2020 2020 2020  s_total,..      
-0000c190: 2020 2020 2020 2020 2020 2020 2020 6e62                nb
-0000c1a0: 5f70 6172 616c 6c65 6c3d 6e62 5f70 6172  _parallel=nb_par
-0000c1b0: 616c 6c65 6c2c 0d0a 2020 2020 2020 2020  allel,..        
-0000c1c0: 2020 2020 2020 2020 2020 2020 6261 7463              batc
-0000c1d0: 6873 697a 653d 6261 7463 6873 697a 652c  hsize=batchsize,
-0000c1e0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000c1f0: 2020 2020 2020 7061 7261 6c6c 656c 697a        paralleliz
-0000c200: 6174 696f 6e5f 636f 6e66 6967 3d50 6172  ation_config=Par
-0000c210: 616c 6c65 6c69 7a61 7469 6f6e 436f 6e66  allelizationConf
-0000c220: 6967 280d 0a20 2020 2020 2020 2020 2020  ig(..           
-0000c230: 2020 2020 2020 2020 2020 2020 206d 6178               max
-0000c240: 5f72 6f77 735f 7065 725f 6261 7463 683d  _rows_per_batch=
-0000c250: 3130 3030 300d 0a20 2020 2020 2020 2020  10000..         
-0000c260: 2020 2020 2020 2020 2020 2029 2c0d 0a20             ),.. 
-0000c270: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-0000c280: 0d0a 0d0a 2020 2020 2020 2020 2020 2020  ....            
-0000c290: 2020 2020 2320 4966 2074 6865 2069 6465      # If the ide
-0000c2a0: 616c 206e 756d 6265 7220 6f66 2062 6174  al number of bat
-0000c2b0: 6368 6573 2069 7320 636c 6f73 6520 746f  ches is close to
-0000c2c0: 2074 6865 206e 622e 2072 6573 756c 7420   the nb. result 
-0000c2d0: 7469 6c65 7320 6173 6b65 642c 0d0a 2020  tiles asked,..  
-0000c2e0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000c2f0: 6469 7373 6f6c 7665 2074 6f77 6172 6473  dissolve towards
-0000c300: 2074 6865 2061 736b 6564 2072 6573 756c   the asked resul
-0000c310: 7421 0d0a 2020 2020 2020 2020 2020 2020  t!..            
-0000c320: 2020 2020 2320 4966 206e 6f74 2c20 6120      # If not, a 
-0000c330: 7465 6d70 6f72 6172 7920 7265 7375 6c74  temporary result
-0000c340: 2069 7320 6372 6561 7465 6420 7573 696e   is created usin
-0000c350: 6720 736d 616c 6c65 7220 7469 6c65 730d  g smaller tiles.
-0000c360: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c370: 2069 6620 6e62 5f62 6174 6368 6573 203c   if nb_batches <
-0000c380: 3d20 6c65 6e28 7265 7375 6c74 5f74 696c  = len(result_til
-0000c390: 6573 5f67 6466 2920 2a20 312e 313a 0d0a  es_gdf) * 1.1:..
-0000c3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c3b0: 2020 2020 7469 6c65 735f 6764 6620 3d20      tiles_gdf = 
-0000c3c0: 7265 7375 6c74 5f74 696c 6573 5f67 6466  result_tiles_gdf
-0000c3d0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000c3e0: 2020 2020 2020 6c61 7374 5f70 6173 7320        last_pass 
-0000c3f0: 3d20 5472 7565 0d0a 2020 2020 2020 2020  = True..        
-0000c400: 2020 2020 2020 2020 2020 2020 6e62 5f70              nb_p
-0000c410: 6172 616c 6c65 6c20 3d20 6d69 6e28 6c65  arallel = min(le
-0000c420: 6e28 7265 7375 6c74 5f74 696c 6573 5f67  n(result_tiles_g
-0000c430: 6466 292c 206e 625f 7061 7261 6c6c 656c  df), nb_parallel
-0000c440: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-0000c450: 2020 2065 6c69 6620 6c65 6e28 7265 7375     elif len(resu
-0000c460: 6c74 5f74 696c 6573 5f67 6466 2920 3d3d  lt_tiles_gdf) ==
-0000c470: 2031 3a0d 0a20 2020 2020 2020 2020 2020   1:..           
-0000c480: 2020 2020 2020 2020 2023 2043 7265 6174           # Creat
-0000c490: 6520 6120 6772 6964 2062 6173 6564 206f  e a grid based o
-0000c4a0: 6e20 7468 6520 6964 6561 6c20 6e75 6d62  n the ideal numb
-0000c4b0: 6572 206f 6620 6261 7463 6865 732c 2062  er of batches, b
-0000c4c0: 7574 206d 616b 650d 0a20 2020 2020 2020  ut make..       
-0000c4d0: 2020 2020 2020 2020 2020 2020 2023 2073               # s
-0000c4e0: 7572 6520 7468 6520 6e75 6d62 6572 2069  ure the number i
-0000c4f0: 7320 736d 616c 6c65 7220 7468 616e 2074  s smaller than t
-0000c500: 6865 206d 6178 696d 756d 2e2e 2e0d 0a20  he maximum..... 
-0000c510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c520: 2020 206e 625f 7371 7561 7269 7368 5f74     nb_squarish_t
-0000c530: 696c 6573 5f6d 6178 203d 204e 6f6e 650d  iles_max = None.
-0000c540: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c550: 2020 2020 2069 6620 7072 6576 5f6e 625f       if prev_nb_
-0000c560: 6261 7463 6865 7320 6973 206e 6f74 204e  batches is not N
-0000c570: 6f6e 653a 0d0a 2020 2020 2020 2020 2020  one:..          
-0000c580: 2020 2020 2020 2020 2020 2020 2020 6e62                nb
-0000c590: 5f73 7175 6172 6973 685f 7469 6c65 735f  _squarish_tiles_
-0000c5a0: 6d61 7820 3d20 6d61 7828 7072 6576 5f6e  max = max(prev_n
-0000c5b0: 625f 6261 7463 6865 7320 2d20 312c 2031  b_batches - 1, 1
-0000c5c0: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-0000c5d0: 2020 2020 2020 2020 2020 206e 625f 6261             nb_ba
-0000c5e0: 7463 6865 7320 3d20 6d69 6e28 6e62 5f62  tches = min(nb_b
-0000c5f0: 6174 6368 6573 2c20 6e62 5f73 7175 6172  atches, nb_squar
-0000c600: 6973 685f 7469 6c65 735f 6d61 7829 0d0a  ish_tiles_max)..
-0000c610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c620: 2020 2020 6772 6964 5f74 6f74 616c 5f62      grid_total_b
-0000c630: 6f75 6e64 7320 3d20 280d 0a20 2020 2020  ounds = (..     
-0000c640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c650: 2020 2069 6e70 7574 5f70 6173 735f 6c61     input_pass_la
-0000c660: 7965 7269 6e66 6f2e 746f 7461 6c5f 626f  yerinfo.total_bo
-0000c670: 756e 6473 5b30 5d20 2d20 302e 3030 3030  unds[0] - 0.0000
-0000c680: 3031 2c0d 0a20 2020 2020 2020 2020 2020  01,..           
-0000c690: 2020 2020 2020 2020 2020 2020 2069 6e70               inp
-0000c6a0: 7574 5f70 6173 735f 6c61 7965 7269 6e66  ut_pass_layerinf
-0000c6b0: 6f2e 746f 7461 6c5f 626f 756e 6473 5b31  o.total_bounds[1
-0000c6c0: 5d20 2d20 302e 3030 3030 3031 2c0d 0a20  ] - 0.000001,.. 
-0000c6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c6e0: 2020 2020 2020 2069 6e70 7574 5f70 6173         input_pas
-0000c6f0: 735f 6c61 7965 7269 6e66 6f2e 746f 7461  s_layerinfo.tota
-0000c700: 6c5f 626f 756e 6473 5b32 5d20 2b20 302e  l_bounds[2] + 0.
-0000c710: 3030 3030 3031 2c0d 0a20 2020 2020 2020  000001,..       
-0000c720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c730: 2069 6e70 7574 5f70 6173 735f 6c61 7965   input_pass_laye
-0000c740: 7269 6e66 6f2e 746f 7461 6c5f 626f 756e  rinfo.total_boun
-0000c750: 6473 5b33 5d20 2b20 302e 3030 3030 3031  ds[3] + 0.000001
-0000c760: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000c770: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-0000c780: 2020 2020 2020 2020 2020 2020 2020 7469                ti
-0000c790: 6c65 735f 6764 6620 3d20 6770 642e 4765  les_gdf = gpd.Ge
-0000c7a0: 6f44 6174 6146 7261 6d65 280d 0a20 2020  oDataFrame(..   
-0000c7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c7c0: 2020 2020 2067 656f 6d65 7472 793d 7079       geometry=py
-0000c7d0: 6765 6f6f 7073 2e63 7265 6174 655f 6772  geoops.create_gr
-0000c7e0: 6964 3228 0d0a 2020 2020 2020 2020 2020  id2(..          
-0000c7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c800: 2020 746f 7461 6c5f 626f 756e 6473 3d67    total_bounds=g
-0000c810: 7269 645f 746f 7461 6c5f 626f 756e 6473  rid_total_bounds
-0000c820: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000c830: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0000c840: 625f 7371 7561 7269 7368 5f74 696c 6573  b_squarish_tiles
-0000c850: 3d6e 625f 6261 7463 6865 732c 0d0a 2020  =nb_batches,..  
+000084c0: 6f70 6572 6174 696f 6e3d 6f70 6572 6174  operation=operat
+000084d0: 696f 6e2e 7661 6c75 652c 0a20 2020 2020  ion.value,.     
+000084e0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+000084f0: 625f 7061 7261 6c6c 656c 3d70 726f 6365  b_parallel=proce
+00008500: 7373 696e 675f 7061 7261 6d73 2e6e 625f  ssing_params.nb_
+00008510: 7061 7261 6c6c 656c 2c0a 2020 2020 2020  parallel,.      
+00008520: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+00008530: 2020 2020 2023 2052 6f75 6e64 2075 7020       # Round up 
+00008540: 616e 6420 636c 6561 6e20 7570 0a20 2020  and clean up.   
+00008550: 2020 2020 2023 204e 6f77 2063 7265 6174       # Now creat
+00008560: 6520 7370 6174 6961 6c20 696e 6465 7820  e spatial index 
+00008570: 616e 6420 6d6f 7665 2074 6f20 6f75 7470  and move to outp
+00008580: 7574 206c 6f63 6174 696f 6e0a 2020 2020  ut location.    
+00008590: 2020 2020 6966 2074 6d70 5f6f 7574 7075      if tmp_outpu
+000085a0: 745f 7061 7468 2e65 7869 7374 7328 293a  t_path.exists():
+000085b0: 0a20 2020 2020 2020 2020 2020 2067 666f  .            gfo
+000085c0: 2e63 7265 6174 655f 7370 6174 6961 6c5f  .create_spatial_
+000085d0: 696e 6465 7828 7061 7468 3d74 6d70 5f6f  index(path=tmp_o
+000085e0: 7574 7075 745f 7061 7468 2c20 6c61 7965  utput_path, laye
+000085f0: 723d 6f75 7470 7574 5f6c 6179 6572 290a  r=output_layer).
+00008600: 2020 2020 2020 2020 2020 2020 6766 6f2e              gfo.
+00008610: 6d6f 7665 2874 6d70 5f6f 7574 7075 745f  move(tmp_output_
+00008620: 7061 7468 2c20 6f75 7470 7574 5f70 6174  path, output_pat
+00008630: 6829 0a20 2020 2020 2020 2065 6c73 653a  h).        else:
+00008640: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
+00008650: 6765 722e 6465 6275 6728 2252 6573 756c  ger.debug("Resul
+00008660: 7420 7761 7320 656d 7074 7922 290a 0a20  t was empty").. 
+00008670: 2020 2066 696e 616c 6c79 3a0a 2020 2020     finally:.    
+00008680: 2020 2020 7368 7574 696c 2e72 6d74 7265      shutil.rmtre
+00008690: 6528 746d 705f 6469 722c 2069 676e 6f72  e(tmp_dir, ignor
+000086a0: 655f 6572 726f 7273 3d54 7275 6529 0a0a  e_errors=True)..
+000086b0: 2020 2020 6c6f 6767 6572 2e69 6e66 6f28      logger.info(
+000086c0: 6622 5265 6164 792c 2074 6f6f 6b20 7b64  f"Ready, took {d
+000086d0: 6174 6574 696d 652e 6e6f 7728 292d 7374  atetime.now()-st
+000086e0: 6172 745f 7469 6d65 5f67 6c6f 6261 6c7d  art_time_global}
+000086f0: 2229 0a0a 0a64 6566 205f 6170 706c 795f  ")...def _apply_
+00008700: 6765 6f6f 7065 7261 7469 6f6e 280a 2020  geooperation(.  
+00008710: 2020 696e 7075 745f 7061 7468 3a20 5061    input_path: Pa
+00008720: 7468 2c0a 2020 2020 6f75 7470 7574 5f70  th,.    output_p
+00008730: 6174 683a 2050 6174 682c 0a20 2020 206f  ath: Path,.    o
+00008740: 7065 7261 7469 6f6e 3a20 4765 6f4f 7065  peration: GeoOpe
+00008750: 7261 7469 6f6e 2c0a 2020 2020 6f70 6572  ration,.    oper
+00008760: 6174 696f 6e5f 7061 7261 6d73 3a20 6469  ation_params: di
+00008770: 6374 2c0a 2020 2020 696e 7075 745f 6c61  ct,.    input_la
+00008780: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
+00008790: 725d 203d 204e 6f6e 652c 0a20 2020 206f  r] = None,.    o
+000087a0: 7574 7075 745f 6c61 7965 723a 204f 7074  utput_layer: Opt
+000087b0: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
+000087c0: 652c 0a20 2020 2063 6f6c 756d 6e73 3a20  e,.    columns: 
+000087d0: 4f70 7469 6f6e 616c 5b4c 6973 745b 7374  Optional[List[st
+000087e0: 725d 5d20 3d20 4e6f 6e65 2c0a 2020 2020  r]] = None,.    
+000087f0: 7768 6572 653d 4e6f 6e65 2c0a 2020 2020  where=None,.    
+00008800: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
+00008810: 6e73 3a20 626f 6f6c 203d 2046 616c 7365  ns: bool = False
+00008820: 2c0a 2020 2020 6772 6964 7369 7a65 3a20  ,.    gridsize: 
+00008830: 666c 6f61 7420 3d20 302e 302c 0a20 2020  float = 0.0,.   
+00008840: 206b 6565 705f 656d 7074 795f 6765 6f6d   keep_empty_geom
+00008850: 733a 2062 6f6f 6c20 3d20 5472 7565 2c0a  s: bool = True,.
+00008860: 2020 2020 7072 6573 6572 7665 5f66 6964      preserve_fid
+00008870: 3a20 626f 6f6c 203d 2046 616c 7365 2c0a  : bool = False,.
+00008880: 2020 2020 666f 7263 653a 2062 6f6f 6c20      force: bool 
+00008890: 3d20 4661 6c73 652c 0a29 202d 3e20 7374  = False,.) -> st
+000088a0: 723a 0a20 2020 2023 2049 6e69 740a 2020  r:.    # Init.  
+000088b0: 2020 6966 206f 7574 7075 745f 7061 7468    if output_path
+000088c0: 2e65 7869 7374 7328 293a 0a20 2020 2020  .exists():.     
+000088d0: 2020 2069 6620 666f 7263 6520 6973 2046     if force is F
+000088e0: 616c 7365 3a0a 2020 2020 2020 2020 2020  alse:.          
+000088f0: 2020 6d65 7373 6167 6520 3d20 6622 5374    message = f"St
+00008900: 6f70 2c20 6f75 7470 7574 2065 7869 7374  op, output exist
+00008910: 7320 616c 7265 6164 7920 7b6f 7574 7075  s already {outpu
+00008920: 745f 7061 7468 7d22 0a20 2020 2020 2020  t_path}".       
+00008930: 2020 2020 2072 6574 7572 6e20 6d65 7373       return mess
+00008940: 6167 650a 2020 2020 2020 2020 656c 7365  age.        else
+00008950: 3a0a 2020 2020 2020 2020 2020 2020 6766  :.            gf
+00008960: 6f2e 7265 6d6f 7665 286f 7574 7075 745f  o.remove(output_
+00008970: 7061 7468 290a 0a20 2020 2023 204e 6f77  path)..    # Now
+00008980: 2067 6f21 0a20 2020 2073 7461 7274 5f74   go!.    start_t
+00008990: 696d 6520 3d20 6461 7465 7469 6d65 2e6e  ime = datetime.n
+000089a0: 6f77 2829 0a20 2020 2064 6174 615f 6764  ow().    data_gd
+000089b0: 6620 3d20 6766 6f2e 7265 6164 5f66 696c  f = gfo.read_fil
+000089c0: 6528 0a20 2020 2020 2020 2070 6174 683d  e(.        path=
+000089d0: 696e 7075 745f 7061 7468 2c0a 2020 2020  input_path,.    
+000089e0: 2020 2020 6c61 7965 723d 696e 7075 745f      layer=input_
+000089f0: 6c61 7965 722c 0a20 2020 2020 2020 2063  layer,.        c
+00008a00: 6f6c 756d 6e73 3d63 6f6c 756d 6e73 2c0a  olumns=columns,.
+00008a10: 2020 2020 2020 2020 7768 6572 653d 7768          where=wh
+00008a20: 6572 652c 0a20 2020 2020 2020 2066 6964  ere,.        fid
+00008a30: 5f61 735f 696e 6465 783d 7072 6573 6572  _as_index=preser
+00008a40: 7665 5f66 6964 2c0a 2020 2020 290a 0a20  ve_fid,.    ).. 
+00008a50: 2020 2023 2052 756e 206f 7065 7261 7469     # Run operati
+00008a60: 6f6e 2069 6620 6461 7461 2072 6561 640a  on if data read.
+00008a70: 2020 2020 6966 206c 656e 2864 6174 615f      if len(data_
+00008a80: 6764 6629 203e 2030 3a0a 2020 2020 2020  gdf) > 0:.      
+00008a90: 2020 6966 206f 7065 7261 7469 6f6e 2069    if operation i
+00008aa0: 7320 4765 6f4f 7065 7261 7469 6f6e 2e42  s GeoOperation.B
+00008ab0: 5546 4645 523a 0a20 2020 2020 2020 2020  UFFER:.         
+00008ac0: 2020 2064 6174 615f 6764 662e 6765 6f6d     data_gdf.geom
+00008ad0: 6574 7279 203d 2064 6174 615f 6764 662e  etry = data_gdf.
+00008ae0: 6765 6f6d 6574 7279 2e62 7566 6665 7228  geometry.buffer(
+00008af0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008b00: 2064 6973 7461 6e63 653d 6f70 6572 6174   distance=operat
+00008b10: 696f 6e5f 7061 7261 6d73 5b22 6469 7374  ion_params["dist
+00008b20: 616e 6365 225d 2c0a 2020 2020 2020 2020  ance"],.        
+00008b30: 2020 2020 2020 2020 7265 736f 6c75 7469          resoluti
+00008b40: 6f6e 3d6f 7065 7261 7469 6f6e 5f70 6172  on=operation_par
+00008b50: 616d 735b 2271 7561 6472 616e 7473 6567  ams["quadrantseg
+00008b60: 6d65 6e74 7322 5d2c 0a20 2020 2020 2020  ments"],.       
+00008b70: 2020 2020 2020 2020 2063 6170 5f73 7479           cap_sty
+00008b80: 6c65 3d6f 7065 7261 7469 6f6e 5f70 6172  le=operation_par
+00008b90: 616d 735b 2265 6e64 6361 705f 7374 796c  ams["endcap_styl
+00008ba0: 6522 5d2e 7661 6c75 652c 0a20 2020 2020  e"].value,.     
+00008bb0: 2020 2020 2020 2020 2020 206a 6f69 6e5f             join_
+00008bc0: 7374 796c 653d 6f70 6572 6174 696f 6e5f  style=operation_
+00008bd0: 7061 7261 6d73 5b22 6a6f 696e 5f73 7479  params["join_sty
+00008be0: 6c65 225d 2e76 616c 7565 2c0a 2020 2020  le"].value,.    
+00008bf0: 2020 2020 2020 2020 2020 2020 6d69 7472              mitr
+00008c00: 655f 6c69 6d69 743d 6f70 6572 6174 696f  e_limit=operatio
+00008c10: 6e5f 7061 7261 6d73 5b22 6d69 7472 655f  n_params["mitre_
+00008c20: 6c69 6d69 7422 5d2c 0a20 2020 2020 2020  limit"],.       
+00008c30: 2020 2020 2020 2020 2073 696e 676c 655f           single_
+00008c40: 7369 6465 643d 6f70 6572 6174 696f 6e5f  sided=operation_
+00008c50: 7061 7261 6d73 5b22 7369 6e67 6c65 5f73  params["single_s
+00008c60: 6964 6564 225d 2c0a 2020 2020 2020 2020  ided"],.        
+00008c70: 2020 2020 290a 2020 2020 2020 2020 656c      ).        el
+00008c80: 6966 206f 7065 7261 7469 6f6e 2069 7320  if operation is 
+00008c90: 4765 6f4f 7065 7261 7469 6f6e 2e43 4f4e  GeoOperation.CON
+00008ca0: 5645 5848 554c 4c3a 0a20 2020 2020 2020  VEXHULL:.       
+00008cb0: 2020 2020 2064 6174 615f 6764 662e 6765       data_gdf.ge
+00008cc0: 6f6d 6574 7279 203d 2064 6174 615f 6764  ometry = data_gd
+00008cd0: 662e 6765 6f6d 6574 7279 2e63 6f6e 7665  f.geometry.conve
+00008ce0: 785f 6875 6c6c 0a20 2020 2020 2020 2065  x_hull.        e
+00008cf0: 6c69 6620 6f70 6572 6174 696f 6e20 6973  lif operation is
+00008d00: 2047 656f 4f70 6572 6174 696f 6e2e 5349   GeoOperation.SI
+00008d10: 4d50 4c49 4659 3a0a 2020 2020 2020 2020  MPLIFY:.        
+00008d20: 2020 2020 6461 7461 5f67 6466 2e67 656f      data_gdf.geo
+00008d30: 6d65 7472 7920 3d20 7079 6765 6f6f 7073  metry = pygeoops
+00008d40: 2e73 696d 706c 6966 7928 0a20 2020 2020  .simplify(.     
+00008d50: 2020 2020 2020 2020 2020 2064 6174 615f             data_
+00008d60: 6764 662e 6765 6f6d 6574 7279 2c0a 2020  gdf.geometry,.  
+00008d70: 2020 2020 2020 2020 2020 2020 2020 616c                al
+00008d80: 676f 7269 7468 6d3d 6f70 6572 6174 696f  gorithm=operatio
+00008d90: 6e5f 7061 7261 6d73 5b22 616c 676f 7269  n_params["algori
+00008da0: 7468 6d22 5d2e 7661 6c75 652c 0a20 2020  thm"].value,.   
+00008db0: 2020 2020 2020 2020 2020 2020 2074 6f6c               tol
+00008dc0: 6572 616e 6365 3d6f 7065 7261 7469 6f6e  erance=operation
+00008dd0: 5f70 6172 616d 735b 2274 6f6c 6572 616e  _params["toleran
+00008de0: 6365 225d 2c0a 2020 2020 2020 2020 2020  ce"],.          
+00008df0: 2020 2020 2020 6c6f 6f6b 6168 6561 643d        lookahead=
+00008e00: 6f70 6572 6174 696f 6e5f 7061 7261 6d73  operation_params
+00008e10: 5b22 7374 6570 225d 2c0a 2020 2020 2020  ["step"],.      
+00008e20: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00008e30: 656c 6966 206f 7065 7261 7469 6f6e 2069  elif operation i
+00008e40: 7320 4765 6f4f 7065 7261 7469 6f6e 2e41  s GeoOperation.A
+00008e50: 5050 4c59 3a0a 2020 2020 2020 2020 2020  PPLY:.          
+00008e60: 2020 6675 6e63 203d 2070 6963 6b6c 652e    func = pickle.
+00008e70: 6c6f 6164 7328 6f70 6572 6174 696f 6e5f  loads(operation_
+00008e80: 7061 7261 6d73 5b22 7069 636b 6c65 645f  params["pickled_
+00008e90: 6675 6e63 225d 290a 2020 2020 2020 2020  func"]).        
+00008ea0: 2020 2020 6966 206f 7065 7261 7469 6f6e      if operation
+00008eb0: 5f70 6172 616d 735b 226f 6e6c 795f 6765  _params["only_ge
+00008ec0: 6f6d 5f69 6e70 7574 225d 2069 7320 5472  om_input"] is Tr
+00008ed0: 7565 3a0a 2020 2020 2020 2020 2020 2020  ue:.            
+00008ee0: 2020 2020 6461 7461 5f67 6466 2e67 656f      data_gdf.geo
+00008ef0: 6d65 7472 7920 3d20 6461 7461 5f67 6466  metry = data_gdf
+00008f00: 2e67 656f 6d65 7472 792e 6170 706c 7928  .geometry.apply(
+00008f10: 6675 6e63 290a 2020 2020 2020 2020 2020  func).          
+00008f20: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00008f30: 2020 2020 2020 2020 6461 7461 5f67 6466          data_gdf
+00008f40: 2e67 656f 6d65 7472 7920 3d20 6461 7461  .geometry = data
+00008f50: 5f67 6466 2e61 7070 6c79 2866 756e 632c  _gdf.apply(func,
+00008f60: 2061 7869 733d 3129 0a20 2020 2020 2020   axis=1).       
+00008f70: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00008f80: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00008f90: 726f 7228 6622 6f70 6572 6174 696f 6e20  ror(f"operation 
+00008fa0: 6e6f 7420 7375 7070 6f72 7465 643a 207b  not supported: {
+00008fb0: 6f70 6572 6174 696f 6e7d 2229 0a0a 2020  operation}")..  
+00008fc0: 2020 2320 4966 2074 6865 7265 2069 7320    # If there is 
+00008fd0: 616e 2066 6964 2063 6f6c 756d 6e20 696e  an fid column in
+00008fe0: 2074 6865 2064 6174 6173 6574 2c20 7265   the dataset, re
+00008ff0: 6e61 6d65 2069 742c 2062 6563 6175 7365  name it, because
+00009000: 2074 6865 2066 6964 2063 6f6c 756d 6e20   the fid column 
+00009010: 6973 2061 0a20 2020 2023 2022 7370 6563  is a.    # "spec
+00009020: 6961 6c20 6361 7365 2220 696e 2067 6461  ial case" in gda
+00009030: 6c20 7468 6174 2073 686f 756c 6420 6e6f  l that should no
+00009040: 7420 6265 2077 7269 7474 656e 2e0a 2020  t be written..  
+00009050: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+00009060: 6e63 6528 6461 7461 5f67 6466 2c20 6770  nce(data_gdf, gp
+00009070: 642e 4765 6f44 6174 6146 7261 6d65 290a  d.GeoDataFrame).
+00009080: 2020 2020 636f 6c75 6d6e 735f 6c6f 7765      columns_lowe
+00009090: 725f 6c6f 6f6b 7570 203d 207b 636f 6c75  r_lookup = {colu
+000090a0: 6d6e 2e6c 6f77 6572 2829 3a20 636f 6c75  mn.lower(): colu
+000090b0: 6d6e 2066 6f72 2063 6f6c 756d 6e20 696e  mn for column in
+000090c0: 2064 6174 615f 6764 662e 636f 6c75 6d6e   data_gdf.column
+000090d0: 737d 0a20 2020 2069 6620 2266 6964 2220  s}.    if "fid" 
+000090e0: 696e 2063 6f6c 756d 6e73 5f6c 6f77 6572  in columns_lower
+000090f0: 5f6c 6f6f 6b75 703a 0a20 2020 2020 2020  _lookup:.       
+00009100: 2066 6964 5f63 6f6c 756d 6e20 3d20 636f   fid_column = co
+00009110: 6c75 6d6e 735f 6c6f 7765 725f 6c6f 6f6b  lumns_lower_look
+00009120: 7570 5b22 6669 6422 5d0a 2020 2020 2020  up["fid"].      
+00009130: 2020 666f 7220 6669 645f 6e75 6d62 6572    for fid_number
+00009140: 2069 6e20 7261 6e67 6528 312c 2031 3030   in range(1, 100
+00009150: 293a 0a20 2020 2020 2020 2020 2020 206e  ):.            n
+00009160: 6577 5f6e 616d 6520 3d20 6622 7b66 6964  ew_name = f"{fid
+00009170: 5f63 6f6c 756d 6e7d 5f7b 6669 645f 6e75  _column}_{fid_nu
+00009180: 6d62 6572 7d22 0a20 2020 2020 2020 2020  mber}".         
+00009190: 2020 2069 6620 6e65 775f 6e61 6d65 206e     if new_name n
+000091a0: 6f74 2069 6e20 636f 6c75 6d6e 735f 6c6f  ot in columns_lo
+000091b0: 7765 725f 6c6f 6f6b 7570 3a0a 2020 2020  wer_lookup:.    
+000091c0: 2020 2020 2020 2020 2020 2020 6461 7461              data
+000091d0: 5f67 6466 203d 2064 6174 615f 6764 662e  _gdf = data_gdf.
+000091e0: 7265 6e61 6d65 2863 6f6c 756d 6e73 3d7b  rename(columns={
+000091f0: 6669 645f 636f 6c75 6d6e 3a20 6e65 775f  fid_column: new_
+00009200: 6e61 6d65 7d2c 2063 6f70 793d 4661 6c73  name}, copy=Fals
+00009210: 6529 0a0a 2020 2020 6966 2067 7269 6473  e)..    if grids
+00009220: 697a 6520 213d 2030 2e30 3a0a 2020 2020  ize != 0.0:.    
+00009230: 2020 2020 6461 7461 5f67 6466 2e67 656f      data_gdf.geo
+00009240: 6d65 7472 7920 3d20 5f67 656f 7365 7269  metry = _geoseri
+00009250: 6573 5f75 7469 6c2e 7365 745f 7072 6563  es_util.set_prec
+00009260: 6973 696f 6e28 0a20 2020 2020 2020 2020  ision(.         
+00009270: 2020 2064 6174 615f 6764 662e 6765 6f6d     data_gdf.geom
+00009280: 6574 7279 2c20 6772 6964 5f73 697a 653d  etry, grid_size=
+00009290: 6772 6964 7369 7a65 2c20 7261 6973 655f  gridsize, raise_
+000092a0: 6f6e 5f74 6f70 6f65 7272 6f72 3d46 616c  on_topoerror=Fal
+000092b0: 7365 0a20 2020 2020 2020 2029 0a0a 2020  se.        )..  
+000092c0: 2020 6966 2065 7870 6c6f 6465 636f 6c6c    if explodecoll
+000092d0: 6563 7469 6f6e 733a 0a20 2020 2020 2020  ections:.       
+000092e0: 2064 6174 615f 6764 6620 3d20 6461 7461   data_gdf = data
+000092f0: 5f67 6466 2e65 7870 6c6f 6465 2869 676e  _gdf.explode(ign
+00009300: 6f72 655f 696e 6465 783d 5472 7565 290a  ore_index=True).
+00009310: 0a20 2020 2023 2053 6574 2065 6d70 7479  .    # Set empty
+00009320: 2067 656f 6d65 7472 6965 7320 746f 204e   geometries to N
+00009330: 6f6e 650a 2020 2020 6461 7461 5f67 6466  one.    data_gdf
+00009340: 2e6c 6f63 5b64 6174 615f 6764 662e 6765  .loc[data_gdf.ge
+00009350: 6f6d 6574 7279 2e69 735f 656d 7074 792c  ometry.is_empty,
+00009360: 2064 6174 615f 6764 662e 6765 6f6d 6574   data_gdf.geomet
+00009370: 7279 2e6e 616d 655d 203d 204e 6f6e 650a  ry.name] = None.
+00009380: 0a20 2020 2069 6620 6e6f 7420 6b65 6570  .    if not keep
+00009390: 5f65 6d70 7479 5f67 656f 6d73 3a0a 2020  _empty_geoms:.  
+000093a0: 2020 2020 2020 2320 5265 6d6f 7665 2072        # Remove r
+000093b0: 6f77 7320 7768 6572 6520 6765 6f6d 6574  ows where geomet
+000093c0: 7279 2069 7320 4e6f 6e65 0a20 2020 2020  ry is None.     
+000093d0: 2020 2064 6174 615f 6764 6620 3d20 6461     data_gdf = da
+000093e0: 7461 5f67 6466 5b7e 6461 7461 5f67 6466  ta_gdf[~data_gdf
+000093f0: 2e67 656f 6d65 7472 792e 6973 6e61 2829  .geometry.isna()
+00009400: 5d0a 0a20 2020 2023 2049 6620 7468 6520  ]..    # If the 
+00009410: 7265 7375 6c74 2069 7320 656d 7074 792c  result is empty,
+00009420: 2061 6e64 206e 6f20 6f75 7470 7574 2067   and no output g
+00009430: 656f 6d65 7472 7974 7970 6520 7370 6563  eometrytype spec
+00009440: 6966 6965 642c 2075 7365 2069 6e70 7574  ified, use input
+00009450: 0a20 2020 2023 2067 656f 6d65 7472 7974  .    # geometryt
+00009460: 7970 650a 2020 2020 666f 7263 655f 6f75  ype.    force_ou
+00009470: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+00009480: 6520 3d20 4e6f 6e65 0a20 2020 2069 6620  e = None.    if 
+00009490: 6c65 6e28 6461 7461 5f67 6466 2920 3d3d  len(data_gdf) ==
+000094a0: 2030 3a0a 2020 2020 2020 2020 696e 7075   0:.        inpu
+000094b0: 745f 6c61 7965 7269 6e66 6f20 3d20 6766  t_layerinfo = gf
+000094c0: 6f2e 6765 745f 6c61 7965 7269 6e66 6f28  o.get_layerinfo(
+000094d0: 696e 7075 745f 7061 7468 2c20 696e 7075  input_path, inpu
+000094e0: 745f 6c61 7965 7229 0a20 2020 2020 2020  t_layer).       
+000094f0: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
+00009500: 6f6d 6574 7279 7479 7065 203d 2069 6e70  ometrytype = inp
+00009510: 7574 5f6c 6179 6572 696e 666f 2e67 656f  ut_layerinfo.geo
+00009520: 6d65 7472 7974 7970 650a 2020 2020 2020  metrytype.      
+00009530: 2020 6966 206e 6f74 2065 7870 6c6f 6465    if not explode
+00009540: 636f 6c6c 6563 7469 6f6e 733a 0a20 2020  collections:.   
+00009550: 2020 2020 2020 2020 2066 6f72 6365 5f6f           force_o
+00009560: 7574 7075 745f 6765 6f6d 6574 7279 7479  utput_geometryty
+00009570: 7065 203d 2066 6f72 6365 5f6f 7574 7075  pe = force_outpu
+00009580: 745f 6765 6f6d 6574 7279 7479 7065 2e74  t_geometrytype.t
+00009590: 6f5f 6d75 6c74 6974 7970 650a 2020 2020  o_multitype.    
+000095a0: 2020 2020 666f 7263 655f 6f75 7470 7574      force_output
+000095b0: 5f67 656f 6d65 7472 7974 7970 6520 3d20  _geometrytype = 
+000095c0: 666f 7263 655f 6f75 7470 7574 5f67 656f  force_output_geo
+000095d0: 6d65 7472 7974 7970 652e 6e61 6d65 0a0a  metrytype.name..
+000095e0: 2020 2020 2320 4966 2074 6865 2069 6e64      # If the ind
+000095f0: 6578 2069 7320 7374 696c 6c20 756e 6971  ex is still uniq
+00009600: 7565 2c20 7361 7665 2069 7420 746f 2066  ue, save it to f
+00009610: 6964 2063 6f6c 756d 6e20 736f 2074 6f5f  id column so to_
+00009620: 6669 6c65 2063 616e 2073 6176 6520 6974  file can save it
+00009630: 0a20 2020 2069 6620 7072 6573 6572 7665  .    if preserve
+00009640: 5f66 6964 3a0a 2020 2020 2020 2020 6461  _fid:.        da
+00009650: 7461 5f67 6466 203d 2064 6174 615f 6764  ta_gdf = data_gd
+00009660: 662e 7265 7365 745f 696e 6465 7828 6472  f.reset_index(dr
+00009670: 6f70 3d46 616c 7365 290a 0a20 2020 2023  op=False)..    #
+00009680: 2055 7365 2066 6f72 6365 5f6d 756c 7469   Use force_multi
+00009690: 7479 7065 2069 6620 6578 706c 6f64 6563  type if explodec
+000096a0: 6f6c 6c65 6374 696f 6e73 3d46 616c 7365  ollections=False
+000096b0: 2074 6f20 6176 6f69 6420 7761 726e 696e   to avoid warnin
+000096c0: 6773 2f69 7373 7565 7320 7768 656e 2073  gs/issues when s
+000096d0: 6f6d 650a 2020 2020 2320 6261 7463 6865  ome.    # batche
+000096e0: 7320 636f 6e74 6169 6e20 7369 6e67 6c65  s contain single
+000096f0: 7479 7065 2061 6e64 2073 6f6d 6520 636f  type and some co
+00009700: 6e74 6169 6e20 6d75 6c74 6974 7970 6520  ntain multitype 
+00009710: 6765 6f6d 6574 7269 6573 0a20 2020 2067  geometries.    g
+00009720: 666f 2e74 6f5f 6669 6c65 280a 2020 2020  fo.to_file(.    
+00009730: 2020 2020 6764 663d 6461 7461 5f67 6466      gdf=data_gdf
+00009740: 2c0a 2020 2020 2020 2020 7061 7468 3d6f  ,.        path=o
+00009750: 7574 7075 745f 7061 7468 2c0a 2020 2020  utput_path,.    
+00009760: 2020 2020 6c61 7965 723d 6f75 7470 7574      layer=output
+00009770: 5f6c 6179 6572 2c0a 2020 2020 2020 2020  _layer,.        
+00009780: 696e 6465 783d 4661 6c73 652c 0a20 2020  index=False,.   
+00009790: 2020 2020 2066 6f72 6365 5f6f 7574 7075       force_outpu
+000097a0: 745f 6765 6f6d 6574 7279 7479 7065 3d66  t_geometrytype=f
+000097b0: 6f72 6365 5f6f 7574 7075 745f 6765 6f6d  orce_output_geom
+000097c0: 6574 7279 7479 7065 2c0a 2020 2020 2020  etrytype,.      
+000097d0: 2020 666f 7263 655f 6d75 6c74 6974 7970    force_multityp
+000097e0: 653d 6e6f 7420 6578 706c 6f64 6563 6f6c  e=not explodecol
+000097f0: 6c65 6374 696f 6e73 2c0a 2020 2020 2020  lections,.      
+00009800: 2020 6372 6561 7465 5f73 7061 7469 616c    create_spatial
+00009810: 5f69 6e64 6578 3d46 616c 7365 2c0a 2020  _index=False,.  
+00009820: 2020 290a 0a20 2020 206d 6573 7361 6765    )..    message
+00009830: 203d 2066 2254 6f6f 6b20 7b64 6174 6574   = f"Took {datet
+00009840: 696d 652e 6e6f 7728 292d 7374 6172 745f  ime.now()-start_
+00009850: 7469 6d65 7d20 666f 7220 7b6c 656e 2864  time} for {len(d
+00009860: 6174 615f 6764 6629 7d20 726f 7773 2028  ata_gdf)} rows (
+00009870: 7b77 6865 7265 7d29 220a 2020 2020 7265  {where})".    re
+00009880: 7475 726e 206d 6573 7361 6765 0a0a 0a64  turn message...d
+00009890: 6566 2064 6973 736f 6c76 6528 0a20 2020  ef dissolve(.   
+000098a0: 2069 6e70 7574 5f70 6174 683a 2050 6174   input_path: Pat
+000098b0: 682c 0a20 2020 206f 7574 7075 745f 7061  h,.    output_pa
+000098c0: 7468 3a20 5061 7468 2c0a 2020 2020 6772  th: Path,.    gr
+000098d0: 6f75 7062 795f 636f 6c75 6d6e 733a 204f  oupby_columns: O
+000098e0: 7074 696f 6e61 6c5b 4974 6572 6162 6c65  ptional[Iterable
+000098f0: 5b73 7472 5d5d 203d 204e 6f6e 652c 0a20  [str]] = None,. 
+00009900: 2020 2061 6767 5f63 6f6c 756d 6e73 3a20     agg_columns: 
+00009910: 4f70 7469 6f6e 616c 5b64 6963 745d 203d  Optional[dict] =
+00009920: 204e 6f6e 652c 0a20 2020 2065 7870 6c6f   None,.    explo
+00009930: 6465 636f 6c6c 6563 7469 6f6e 733a 2062  decollections: b
+00009940: 6f6f 6c20 3d20 5472 7565 2c0a 2020 2020  ool = True,.    
+00009950: 7469 6c65 735f 7061 7468 3a20 4f70 7469  tiles_path: Opti
+00009960: 6f6e 616c 5b50 6174 685d 203d 204e 6f6e  onal[Path] = Non
+00009970: 652c 0a20 2020 206e 625f 7371 7561 7269  e,.    nb_squari
+00009980: 7368 5f74 696c 6573 3a20 696e 7420 3d20  sh_tiles: int = 
+00009990: 312c 0a20 2020 2069 6e70 7574 5f6c 6179  1,.    input_lay
+000099a0: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
+000099b0: 5d20 3d20 4e6f 6e65 2c0a 2020 2020 6f75  ] = None,.    ou
+000099c0: 7470 7574 5f6c 6179 6572 3a20 4f70 7469  tput_layer: Opti
+000099d0: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+000099e0: 2c0a 2020 2020 6772 6964 7369 7a65 3a20  ,.    gridsize: 
+000099f0: 666c 6f61 7420 3d20 302e 302c 0a20 2020  float = 0.0,.   
+00009a00: 2077 6865 7265 5f70 6f73 743a 204f 7074   where_post: Opt
+00009a10: 696f 6e61 6c5b 7374 725d 203d 204e 6f6e  ional[str] = Non
+00009a20: 652c 0a20 2020 206e 625f 7061 7261 6c6c  e,.    nb_parall
+00009a30: 656c 3a20 696e 7420 3d20 2d31 2c0a 2020  el: int = -1,.  
+00009a40: 2020 6261 7463 6873 697a 653a 2069 6e74    batchsize: int
+00009a50: 203d 202d 312c 0a20 2020 2066 6f72 6365   = -1,.    force
+00009a60: 3a20 626f 6f6c 203d 2046 616c 7365 2c0a  : bool = False,.
+00009a70: 2020 2020 6f70 6572 6174 696f 6e5f 7072      operation_pr
+00009a80: 6566 6978 3a20 7374 7220 3d20 2222 2c0a  efix: str = "",.
+00009a90: 2920 2d3e 2064 6963 743a 0a20 2020 2022  ) -> dict:.    "
+00009aa0: 2222 0a20 2020 2046 756e 6374 696f 6e20  "".    Function 
+00009ab0: 7468 6174 2061 7070 6c69 6573 2061 2064  that applies a d
+00009ac0: 6973 736f 6c76 652e 0a0a 2020 2020 4d6f  issolve...    Mo
+00009ad0: 7265 2064 6574 6169 6c65 6420 646f 6375  re detailed docu
+00009ae0: 6d65 6e74 6174 696f 6e20 696e 206d 6f64  mentation in mod
+00009af0: 756c 6520 6765 6f6f 7073 210a 0a20 2020  ule geoops!..   
+00009b00: 2052 656d 6172 6b3a 206b 6565 705f 656d   Remark: keep_em
+00009b10: 7074 795f 6765 6f6d 7320 6973 206e 6f74  pty_geoms is not
+00009b20: 2069 6d70 6c65 6d65 6e74 6564 2062 6563   implemented bec
+00009b30: 6175 7365 2074 6869 7320 6973 206e 6f74  ause this is not
+00009b40: 2073 6f20 6561 7379 2062 6563 6175 7365   so easy because
+00009b50: 0a20 2020 2028 666f 7220 706f 6c79 676f  .    (for polygo
+00009b60: 6e20 6469 7373 6f6c 7665 2920 7468 6520  n dissolve) the 
+00009b70: 6261 7463 6865 7320 6172 6520 6c6f 6361  batches are loca
+00009b80: 7469 6f6e 2062 6173 6564 2c20 616e 6420  tion based, and 
+00009b90: 6e75 6c6c 2f65 6d70 7479 2067 656f 6d65  null/empty geome
+00009ba0: 7472 6965 730a 2020 2020 646f 6e27 7420  tries.    don't 
+00009bb0: 6861 7665 2061 206c 6f63 6174 696f 6e2e  have a location.
+00009bc0: 2049 7420 636f 756c 6420 6265 2069 6d70   It could be imp
+00009bd0: 6c65 6d65 6e74 6564 2c20 6275 7420 6173  lemented, but as
+00009be0: 206c 6f6e 6720 6173 206e 6f62 6f64 7920   long as nobody 
+00009bf0: 6e65 6564 7320 6974 2e2e 2e0a 2020 2020  needs it....    
+00009c00: 2222 220a 2020 2020 2320 496e 6974 2061  """.    # Init a
+00009c10: 6e64 2076 616c 6964 6174 6520 696e 7075  nd validate inpu
+00009c20: 7420 7061 7261 6d65 7465 7273 0a20 2020  t parameters.   
+00009c30: 2023 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d   # -------------
+00009c40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00009c50: 2d2d 2d2d 2d0a 2020 2020 7374 6172 745f  -----.    start_
+00009c60: 7469 6d65 203d 2064 6174 6574 696d 652e  time = datetime.
+00009c70: 6e6f 7728 290a 2020 2020 6f70 6572 6174  now().    operat
+00009c80: 696f 6e5f 6e61 6d65 203d 2066 227b 6f70  ion_name = f"{op
+00009c90: 6572 6174 696f 6e5f 7072 6566 6978 7d64  eration_prefix}d
+00009ca0: 6973 736f 6c76 6522 0a20 2020 206c 6f67  issolve".    log
+00009cb0: 6765 7220 3d20 6c6f 6767 696e 672e 6765  ger = logging.ge
+00009cc0: 744c 6f67 6765 7228 6622 6765 6f66 696c  tLogger(f"geofil
+00009cd0: 656f 7073 2e7b 6f70 6572 6174 696f 6e5f  eops.{operation_
+00009ce0: 6e61 6d65 7d22 290a 2020 2020 7265 7375  name}").    resu
+00009cf0: 6c74 5f69 6e66 6f20 3d20 7b7d 0a0a 2020  lt_info = {}..  
+00009d00: 2020 2320 4368 6563 6b20 696e 7075 7420    # Check input 
+00009d10: 7061 7261 6d65 7465 7273 0a20 2020 2069  parameters.    i
+00009d20: 6620 6772 6f75 7062 795f 636f 6c75 6d6e  f groupby_column
+00009d30: 7320 6973 206e 6f74 204e 6f6e 6520 616e  s is not None an
+00009d40: 6420 6c65 6e28 6c69 7374 2867 726f 7570  d len(list(group
+00009d50: 6279 5f63 6f6c 756d 6e73 2929 203d 3d20  by_columns)) == 
+00009d60: 303a 0a20 2020 2020 2020 2072 6169 7365  0:.        raise
+00009d70: 2056 616c 7565 4572 726f 7228 2267 726f   ValueError("gro
+00009d80: 7570 6279 5f63 6f6c 756d 6e73 3d5b 5d20  upby_columns=[] 
+00009d90: 6973 206e 6f74 2073 7570 706f 7274 6564  is not supported
+00009da0: 2e20 5573 6520 4e6f 6e65 2e22 290a 2020  . Use None.").  
+00009db0: 2020 6966 206e 6f74 2069 6e70 7574 5f70    if not input_p
+00009dc0: 6174 682e 6578 6973 7473 2829 3a0a 2020  ath.exists():.  
+00009dd0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00009de0: 6545 7272 6f72 2866 2269 6e70 7574 5f70  eError(f"input_p
+00009df0: 6174 6820 646f 6573 6e27 7420 6578 6973  ath doesn't exis
+00009e00: 743a 207b 696e 7075 745f 7061 7468 7d22  t: {input_path}"
+00009e10: 290a 2020 2020 6966 2069 6e70 7574 5f70  ).    if input_p
+00009e20: 6174 6820 3d3d 206f 7574 7075 745f 7061  ath == output_pa
+00009e30: 7468 3a0a 2020 2020 2020 2020 7261 6973  th:.        rais
+00009e40: 6520 5661 6c75 6545 7272 6f72 2822 6f75  e ValueError("ou
+00009e50: 7470 7574 5f70 6174 6820 6d75 7374 206e  tput_path must n
+00009e60: 6f74 2065 7175 616c 2069 6e70 7574 5f70  ot equal input_p
+00009e70: 6174 6822 290a 0a20 2020 2069 6e70 7574  ath")..    input
+00009e80: 5f6c 6179 6572 696e 666f 203d 2067 666f  _layerinfo = gfo
+00009e90: 2e67 6574 5f6c 6179 6572 696e 666f 2869  .get_layerinfo(i
+00009ea0: 6e70 7574 5f70 6174 682c 2069 6e70 7574  nput_path, input
+00009eb0: 5f6c 6179 6572 290a 2020 2020 6966 2069  _layer).    if i
+00009ec0: 6e70 7574 5f6c 6179 6572 696e 666f 2e67  nput_layerinfo.g
+00009ed0: 656f 6d65 7472 7974 7970 652e 746f 5f70  eometrytype.to_p
+00009ee0: 7269 6d69 7469 7665 7479 7065 2069 6e20  rimitivetype in 
+00009ef0: 5b0a 2020 2020 2020 2020 5072 696d 6974  [.        Primit
+00009f00: 6976 6554 7970 652e 504f 494e 542c 0a20  iveType.POINT,. 
+00009f10: 2020 2020 2020 2050 7269 6d69 7469 7665         Primitive
+00009f20: 5479 7065 2e4c 494e 4553 5452 494e 472c  Type.LINESTRING,
+00009f30: 0a20 2020 205d 3a0a 2020 2020 2020 2020  .    ]:.        
+00009f40: 6966 2074 696c 6573 5f70 6174 6820 6973  if tiles_path is
+00009f50: 206e 6f74 204e 6f6e 6520 6f72 206e 625f   not None or nb_
+00009f60: 7371 7561 7269 7368 5f74 696c 6573 203e  squarish_tiles >
+00009f70: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+00009f80: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+00009f90: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00009fa0: 2020 6622 4469 7373 6f6c 7665 2074 6f20    f"Dissolve to 
+00009fb0: 7469 6c65 7320 6973 206e 6f74 2073 7570  tiles is not sup
+00009fc0: 706f 7274 6564 2066 6f72 207b 696e 7075  ported for {inpu
+00009fd0: 745f 6c61 7965 7269 6e66 6f2e 6765 6f6d  t_layerinfo.geom
+00009fe0: 6574 7279 7479 7065 7d22 0a20 2020 2020  etrytype}".     
+00009ff0: 2020 2020 2020 2020 2020 2022 2c20 736f             ", so
+0000a000: 2074 696c 6573 5f70 6174 6820 7368 6f75   tiles_path shou
+0000a010: 6c64 2062 6520 4e6f 6e65 2061 6e64 206e  ld be None and n
+0000a020: 625f 7371 7561 7269 7368 5f74 696c 6573  b_squarish_tiles
+0000a030: 2073 686f 756c 6420 6265 2031 2922 0a20   should be 1)". 
+0000a040: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+0000a050: 2020 6966 2069 6e70 7574 5f6c 6179 6572    if input_layer
+0000a060: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+0000a070: 2020 696e 7075 745f 6c61 7965 7220 3d20    input_layer = 
+0000a080: 6766 6f2e 6765 745f 6f6e 6c79 5f6c 6179  gfo.get_only_lay
+0000a090: 6572 2869 6e70 7574 5f70 6174 6829 0a20  er(input_path). 
+0000a0a0: 2020 2069 6620 6f75 7470 7574 5f6c 6179     if output_lay
+0000a0b0: 6572 2069 7320 4e6f 6e65 3a0a 2020 2020  er is None:.    
+0000a0c0: 2020 2020 6f75 7470 7574 5f6c 6179 6572      output_layer
+0000a0d0: 203d 2067 666f 2e67 6574 5f64 6566 6175   = gfo.get_defau
+0000a0e0: 6c74 5f6c 6179 6572 286f 7574 7075 745f  lt_layer(output_
+0000a0f0: 7061 7468 290a 0a20 2020 2023 2043 6865  path)..    # Che
+0000a100: 636b 2063 6f6c 756d 6e73 2069 6e20 6772  ck columns in gr
+0000a110: 6f75 7062 795f 636f 6c75 6d6e 730a 2020  oupby_columns.  
+0000a120: 2020 636f 6c75 6d6e 735f 6176 6169 6c61    columns_availa
+0000a130: 626c 6520 3d20 6c69 7374 2869 6e70 7574  ble = list(input
+0000a140: 5f6c 6179 6572 696e 666f 2e63 6f6c 756d  _layerinfo.colum
+0000a150: 6e73 2920 2b20 5b22 6669 6422 5d0a 2020  ns) + ["fid"].  
+0000a160: 2020 6966 2067 726f 7570 6279 5f63 6f6c    if groupby_col
+0000a170: 756d 6e73 2069 7320 6e6f 7420 4e6f 6e65  umns is not None
+0000a180: 3a0a 2020 2020 2020 2020 636f 6c75 6d6e  :.        column
+0000a190: 735f 696e 5f6c 6179 6572 5f75 7070 6572  s_in_layer_upper
+0000a1a0: 203d 205b 636f 6c75 6d6e 2e75 7070 6572   = [column.upper
+0000a1b0: 2829 2066 6f72 2063 6f6c 756d 6e20 696e  () for column in
+0000a1c0: 2063 6f6c 756d 6e73 5f61 7661 696c 6162   columns_availab
+0000a1d0: 6c65 5d0a 2020 2020 2020 2020 666f 7220  le].        for 
+0000a1e0: 636f 6c75 6d6e 2069 6e20 6772 6f75 7062  column in groupb
+0000a1f0: 795f 636f 6c75 6d6e 733a 0a20 2020 2020  y_columns:.     
+0000a200: 2020 2020 2020 2069 6620 636f 6c75 6d6e         if column
+0000a210: 2e75 7070 6572 2829 206e 6f74 2069 6e20  .upper() not in 
+0000a220: 636f 6c75 6d6e 735f 696e 5f6c 6179 6572  columns_in_layer
+0000a230: 5f75 7070 6572 3a0a 2020 2020 2020 2020  _upper:.        
+0000a240: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+0000a250: 6c75 6545 7272 6f72 280a 2020 2020 2020  lueError(.      
+0000a260: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+0000a270: 636f 6c75 6d6e 2069 6e20 6772 6f75 7062  column in groupb
+0000a280: 795f 636f 6c75 6d6e 7320 6e6f 7420 6176  y_columns not av
+0000a290: 6169 6c61 626c 6520 696e 206c 6179 6572  ailable in layer
+0000a2a0: 3a20 7b63 6f6c 756d 6e7d 220a 2020 2020  : {column}".    
+0000a2b0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0000a2c0: 2020 2020 2020 636f 6c75 6d6e 735f 6176        columns_av
+0000a2d0: 6169 6c61 626c 6520 3d20 5f67 656e 6572  ailable = _gener
+0000a2e0: 616c 5f75 7469 6c2e 616c 6967 6e5f 6361  al_util.align_ca
+0000a2f0: 7369 6e67 5f6c 6973 7428 0a20 2020 2020  sing_list(.     
+0000a300: 2020 2020 2020 2063 6f6c 756d 6e73 5f61         columns_a
+0000a310: 7661 696c 6162 6c65 2c20 6772 6f75 7062  vailable, groupb
+0000a320: 795f 636f 6c75 6d6e 732c 2072 6169 7365  y_columns, raise
+0000a330: 5f6f 6e5f 6d69 7373 696e 673d 4661 6c73  _on_missing=Fals
+0000a340: 650a 2020 2020 2020 2020 290a 0a20 2020  e.        )..   
+0000a350: 2023 2043 6865 636b 2061 6767 5f63 6f6c   # Check agg_col
+0000a360: 756d 6e73 2070 6172 616d 0a20 2020 2069  umns param.    i
+0000a370: 6620 6167 675f 636f 6c75 6d6e 7320 6973  f agg_columns is
+0000a380: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+0000a390: 2020 2023 2056 616c 6964 6174 6520 7468     # Validate th
+0000a3a0: 6520 6469 6374 2073 7472 7563 7475 7265  e dict structure
+0000a3b0: 2c20 736f 2077 6520 6361 6e20 6173 7375  , so we can assu
+0000a3c0: 6d65 2065 7665 7279 7468 696e 6720 6973  me everything is
+0000a3d0: 204f 4b20 6675 7274 6865 7220 6f6e 0a20   OK further on. 
+0000a3e0: 2020 2020 2020 205f 7061 7261 6d65 7465         _paramete
+0000a3f0: 725f 6865 6c70 6572 2e76 616c 6964 6174  r_helper.validat
+0000a400: 655f 6167 675f 636f 6c75 6d6e 7328 6167  e_agg_columns(ag
+0000a410: 675f 636f 6c75 6d6e 7329 0a0a 2020 2020  g_columns)..    
+0000a420: 2020 2020 2320 4669 7273 7420 7461 6b65      # First take
+0000a430: 2061 2064 6565 7020 636f 7079 2c20 6173   a deep copy, as
+0000a440: 2076 616c 7565 7320 6361 6e20 6265 2063   values can be c
+0000a450: 6861 6e67 6564 2066 7572 7468 6572 206f  hanged further o
+0000a460: 6e20 746f 2074 7265 6174 2063 6f6c 756d  n to treat colum
+0000a470: 6e73 0a20 2020 2020 2020 2023 2063 6173  ns.        # cas
+0000a480: 6520 696e 7365 6e73 6974 6976 650a 2020  e insensitive.  
+0000a490: 2020 2020 2020 6167 675f 636f 6c75 6d6e        agg_column
+0000a4a0: 7320 3d20 6a73 6f6e 2e6c 6f61 6473 286a  s = json.loads(j
+0000a4b0: 736f 6e2e 6475 6d70 7328 6167 675f 636f  son.dumps(agg_co
+0000a4c0: 6c75 6d6e 7329 290a 2020 2020 2020 2020  lumns)).        
+0000a4d0: 6173 7365 7274 2061 6767 5f63 6f6c 756d  assert agg_colum
+0000a4e0: 6e73 2069 7320 6e6f 7420 4e6f 6e65 0a20  ns is not None. 
+0000a4f0: 2020 2020 2020 2069 6620 226a 736f 6e22         if "json"
+0000a500: 2069 6e20 6167 675f 636f 6c75 6d6e 733a   in agg_columns:
+0000a510: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000a520: 6167 675f 636f 6c75 6d6e 735b 226a 736f  agg_columns["jso
+0000a530: 6e22 5d20 6973 204e 6f6e 653a 0a20 2020  n"] is None:.   
+0000a540: 2020 2020 2020 2020 2020 2020 2061 6767               agg
+0000a550: 5f63 6f6c 756d 6e73 5b22 6a73 6f6e 225d  _columns["json"]
+0000a560: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
+0000a570: 2020 2020 2020 2020 2063 2066 6f72 2063           c for c
+0000a580: 2069 6e20 636f 6c75 6d6e 735f 6176 6169   in columns_avai
+0000a590: 6c61 626c 6520 6966 2063 2e6c 6f77 6572  lable if c.lower
+0000a5a0: 2829 206e 6f74 2069 6e20 2822 696e 6465  () not in ("inde
+0000a5b0: 7822 2c20 2266 6964 2229 0a20 2020 2020  x", "fid").     
+0000a5c0: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+0000a5d0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000a5e0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000a5f0: 2041 6c69 676e 2063 6173 696e 6720 6f66   Align casing of
+0000a600: 2063 6f6c 756d 6e20 6e61 6d65 7320 746f   column names to
+0000a610: 2064 6174 610a 2020 2020 2020 2020 2020   data.          
+0000a620: 2020 2020 2020 6167 675f 636f 6c75 6d6e        agg_column
+0000a630: 735b 226a 736f 6e22 5d20 3d20 5f67 656e  s["json"] = _gen
+0000a640: 6572 616c 5f75 7469 6c2e 616c 6967 6e5f  eral_util.align_
+0000a650: 6361 7369 6e67 5f6c 6973 7428 0a20 2020  casing_list(.   
+0000a660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a670: 2061 6767 5f63 6f6c 756d 6e73 5b22 6a73   agg_columns["js
+0000a680: 6f6e 225d 2c20 636f 6c75 6d6e 735f 6176  on"], columns_av
+0000a690: 6169 6c61 626c 650a 2020 2020 2020 2020  ailable.        
+0000a6a0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000a6b0: 2020 656c 6966 2022 636f 6c75 6d6e 7322    elif "columns"
+0000a6c0: 2069 6e20 6167 675f 636f 6c75 6d6e 733a   in agg_columns:
+0000a6d0: 0a20 2020 2020 2020 2020 2020 2023 204c  .            # L
+0000a6e0: 6f6f 7020 7468 726f 7567 6820 616c 6c20  oop through all 
+0000a6f0: 726f 7773 0a20 2020 2020 2020 2020 2020  rows.           
+0000a700: 2066 6f72 2061 6767 5f63 6f6c 756d 6e20   for agg_column 
+0000a710: 696e 2061 6767 5f63 6f6c 756d 6e73 5b22  in agg_columns["
+0000a720: 636f 6c75 6d6e 7322 5d3a 0a20 2020 2020  columns"]:.     
+0000a730: 2020 2020 2020 2020 2020 2023 2043 6865             # Che
+0000a740: 636b 2069 6620 636f 6c75 6d6e 2065 7869  ck if column exi
+0000a750: 7374 7320 2b20 7365 7420 6361 7369 6e67  sts + set casing
+0000a760: 2073 616d 6520 6173 2069 6e20 6461 7461   same as in data
+0000a770: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a780: 2061 6767 5f63 6f6c 756d 6e5b 2263 6f6c   agg_column["col
+0000a790: 756d 6e22 5d20 3d20 5f67 656e 6572 616c  umn"] = _general
+0000a7a0: 5f75 7469 6c2e 616c 6967 6e5f 6361 7369  _util.align_casi
+0000a7b0: 6e67 280a 2020 2020 2020 2020 2020 2020  ng(.            
+0000a7c0: 2020 2020 2020 2020 6167 675f 636f 6c75          agg_colu
+0000a7d0: 6d6e 5b22 636f 6c75 6d6e 225d 2c20 636f  mn["column"], co
+0000a7e0: 6c75 6d6e 735f 6176 6169 6c61 626c 650a  lumns_available.
+0000a7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a800: 290a 0a20 2020 2023 204e 6f77 2069 6e70  )..    # Now inp
+0000a810: 7574 2070 6172 616d 6574 6572 7320 6172  ut parameters ar
+0000a820: 6520 6368 6563 6b65 642c 2063 6865 636b  e checked, check
+0000a830: 2069 6620 7765 206e 6565 6420 746f 2063   if we need to c
+0000a840: 616c 6375 6c61 7465 2061 6e79 7761 790a  alculate anyway.
+0000a850: 2020 2020 6966 206f 7574 7075 745f 7061      if output_pa
+0000a860: 7468 2e65 7869 7374 7328 293a 0a20 2020  th.exists():.   
+0000a870: 2020 2020 2069 6620 666f 7263 6520 6973       if force is
+0000a880: 2046 616c 7365 3a0a 2020 2020 2020 2020   False:.        
+0000a890: 2020 2020 7265 7375 6c74 5f69 6e66 6f5b      result_info[
+0000a8a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a8b0: 2022 6d65 7373 6167 6522 0a20 2020 2020   "message".     
+0000a8c0: 2020 2020 2020 205d 203d 2066 2253 746f         ] = f"Sto
+0000a8d0: 702c 206f 7574 7075 7420 6578 6973 7473  p, output exists
+0000a8e0: 2061 6c72 6561 6479 207b 6f75 7470 7574   already {output
+0000a8f0: 5f70 6174 687d 2061 6e64 2066 6f72 6365  _path} and force
+0000a900: 2069 7320 6661 6c73 6522 0a20 2020 2020   is false".     
+0000a910: 2020 2020 2020 206c 6f67 6765 722e 696e         logger.in
+0000a920: 666f 2872 6573 756c 745f 696e 666f 5b22  fo(result_info["
+0000a930: 6d65 7373 6167 6522 5d29 0a20 2020 2020  message"]).     
+0000a940: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
+0000a950: 7375 6c74 5f69 6e66 6f0a 2020 2020 2020  sult_info.      
+0000a960: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000a970: 2020 2020 6766 6f2e 7265 6d6f 7665 286f      gfo.remove(o
+0000a980: 7574 7075 745f 7061 7468 290a 0a20 2020  utput_path)..   
+0000a990: 2023 204e 6f77 2073 7461 7274 2064 6973   # Now start dis
+0000a9a0: 736f 6c76 696e 670a 2020 2020 2320 2d2d  solving.    # --
+0000a9b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000a9c0: 2d2d 0a20 2020 2023 2045 6d70 7479 206f  --.    # Empty o
+0000a9d0: 7220 4c69 6e65 2061 6e64 2070 6f69 6e74  r Line and point
+0000a9e0: 206c 6179 6572 7320 6172 653a 0a20 2020   layers are:.   
+0000a9f0: 2023 2020 202a 206e 6f74 2073 6f20 6c61   #   * not so la
+0000aa00: 7267 6520 286d 656d 6f72 792d 7769 7365  rge (memory-wise
+0000aa10: 290a 2020 2020 2320 2020 2a20 6172 656e  ).    #   * aren
+0000aa20: 2774 2063 6f6d 7075 7461 7469 6f6e 616c  't computational
+0000aa30: 6c79 2068 6561 7679 0a20 2020 2023 2041  ly heavy.    # A
+0000aa40: 6464 6974 696f 6e61 6c6c 7920 6c69 6e65  dditionally line
+0000aa50: 206c 6179 6572 7320 6172 6520 6120 7061   layers are a pa
+0000aa60: 696e 2074 6f20 6861 6e64 6c65 2063 6f72  in to handle cor
+0000aa70: 7265 6374 6c79 2062 6563 6175 7365 206f  rectly because o
+0000aa80: 660a 2020 2020 2320 726f 756e 6469 6e67  f.    # rounding
+0000aa90: 2069 7373 7565 7320 6174 2074 6865 2062   issues at the b
+0000aaa0: 6f72 6465 7273 206f 6620 7469 6c65 732e  orders of tiles.
+0000aab0: 2e2e 2073 6f20 6a75 7374 2064 6973 736f  .. so just disso
+0000aac0: 6c76 6520 7468 656d 2069 6e20 6f6e 6520  lve them in one 
+0000aad0: 676f 2e0a 2020 2020 6966 2028 0a20 2020  go..    if (.   
+0000aae0: 2020 2020 2069 6e70 7574 5f6c 6179 6572       input_layer
+0000aaf0: 696e 666f 2e66 6561 7475 7265 636f 756e  info.featurecoun
+0000ab00: 7420 3d3d 2030 0a20 2020 2020 2020 206f  t == 0.        o
+0000ab10: 7220 696e 7075 745f 6c61 7965 7269 6e66  r input_layerinf
+0000ab20: 6f2e 6765 6f6d 6574 7279 7479 7065 2e74  o.geometrytype.t
+0000ab30: 6f5f 7072 696d 6974 6976 6574 7970 650a  o_primitivetype.
+0000ab40: 2020 2020 2020 2020 696e 205b 0a20 2020          in [.   
+0000ab50: 2020 2020 2020 2020 2050 7269 6d69 7469           Primiti
+0000ab60: 7665 5479 7065 2e50 4f49 4e54 2c0a 2020  veType.POINT,.  
+0000ab70: 2020 2020 2020 2020 2020 5072 696d 6974            Primit
+0000ab80: 6976 6554 7970 652e 4c49 4e45 5354 5249  iveType.LINESTRI
+0000ab90: 4e47 2c0a 2020 2020 2020 2020 5d0a 2020  NG,.        ].  
+0000aba0: 2020 293a 0a20 2020 2020 2020 205f 6765    ):.        _ge
+0000abb0: 6f6f 7073 5f73 716c 2e64 6973 736f 6c76  oops_sql.dissolv
+0000abc0: 655f 7369 6e67 6c65 7468 7265 6164 280a  e_singlethread(.
+0000abd0: 2020 2020 2020 2020 2020 2020 696e 7075              inpu
+0000abe0: 745f 7061 7468 3d69 6e70 7574 5f70 6174  t_path=input_pat
+0000abf0: 682c 0a20 2020 2020 2020 2020 2020 206f  h,.            o
+0000ac00: 7574 7075 745f 7061 7468 3d6f 7574 7075  utput_path=outpu
+0000ac10: 745f 7061 7468 2c0a 2020 2020 2020 2020  t_path,.        
+0000ac20: 2020 2020 6578 706c 6f64 6563 6f6c 6c65      explodecolle
+0000ac30: 6374 696f 6e73 3d65 7870 6c6f 6465 636f  ctions=explodeco
+0000ac40: 6c6c 6563 7469 6f6e 732c 0a20 2020 2020  llections,.     
+0000ac50: 2020 2020 2020 2067 726f 7570 6279 5f63         groupby_c
+0000ac60: 6f6c 756d 6e73 3d67 726f 7570 6279 5f63  olumns=groupby_c
+0000ac70: 6f6c 756d 6e73 2c0a 2020 2020 2020 2020  olumns,.        
+0000ac80: 2020 2020 6167 675f 636f 6c75 6d6e 733d      agg_columns=
+0000ac90: 6167 675f 636f 6c75 6d6e 732c 0a20 2020  agg_columns,.   
+0000aca0: 2020 2020 2020 2020 2069 6e70 7574 5f6c           input_l
+0000acb0: 6179 6572 3d69 6e70 7574 5f6c 6179 6572  ayer=input_layer
+0000acc0: 2c0a 2020 2020 2020 2020 2020 2020 6f75  ,.            ou
+0000acd0: 7470 7574 5f6c 6179 6572 3d6f 7574 7075  tput_layer=outpu
+0000ace0: 745f 6c61 7965 722c 0a20 2020 2020 2020  t_layer,.       
+0000acf0: 2020 2020 2067 7269 6473 697a 653d 6772       gridsize=gr
+0000ad00: 6964 7369 7a65 2c0a 2020 2020 2020 2020  idsize,.        
+0000ad10: 2020 2020 6b65 6570 5f65 6d70 7479 5f67      keep_empty_g
+0000ad20: 656f 6d73 3d46 616c 7365 2c0a 2020 2020  eoms=False,.    
+0000ad30: 2020 2020 2020 2020 7768 6572 655f 706f          where_po
+0000ad40: 7374 3d77 6865 7265 5f70 6f73 742c 0a20  st=where_post,. 
+0000ad50: 2020 2020 2020 2020 2020 2066 6f72 6365             force
+0000ad60: 3d66 6f72 6365 2c0a 2020 2020 2020 2020  =force,.        
+0000ad70: 290a 0a20 2020 2065 6c69 6620 696e 7075  )..    elif inpu
+0000ad80: 745f 6c61 7965 7269 6e66 6f2e 6765 6f6d  t_layerinfo.geom
+0000ad90: 6574 7279 7479 7065 2e74 6f5f 7072 696d  etrytype.to_prim
+0000ada0: 6974 6976 6574 7970 6520 6973 2050 7269  itivetype is Pri
+0000adb0: 6d69 7469 7665 5479 7065 2e50 4f4c 5947  mitiveType.POLYG
+0000adc0: 4f4e 3a0a 2020 2020 2020 2020 2320 5072  ON:.        # Pr
+0000add0: 6570 6172 6520 7768 6572 655f 706f 7374  epare where_post
+0000ade0: 0a20 2020 2020 2020 2069 6620 7768 6572  .        if wher
+0000adf0: 655f 706f 7374 2069 7320 6e6f 7420 4e6f  e_post is not No
+0000ae00: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+0000ae10: 6966 2077 6865 7265 5f70 6f73 7420 3d3d  if where_post ==
+0000ae20: 2022 223a 0a20 2020 2020 2020 2020 2020   "":.           
+0000ae30: 2020 2020 2077 6865 7265 5f70 6f73 7420       where_post 
+0000ae40: 3d20 4e6f 6e65 0a20 2020 2020 2020 2020  = None.         
+0000ae50: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000ae60: 2020 2020 2020 2020 2023 2053 6574 2067           # Set g
+0000ae70: 656f 6d65 7472 7963 6f6c 756d 6e20 746f  eometrycolumn to
+0000ae80: 2022 6765 6f6d 222c 2062 6563 6175 7365   "geom", because
+0000ae90: 2074 656d 7020 6669 6c65 7320 6172 6520   temp files are 
+0000aea0: 7361 7665 6420 6173 2067 706b 672e 0a20  saved as gpkg.. 
+0000aeb0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
+0000aec0: 6865 7265 5f70 6f73 7420 3d20 7768 6572  here_post = wher
+0000aed0: 655f 706f 7374 2e66 6f72 6d61 7428 6765  e_post.format(ge
+0000aee0: 6f6d 6574 7279 636f 6c75 6d6e 3d22 6765  ometrycolumn="ge
+0000aef0: 6f6d 2229 0a0a 2020 2020 2020 2020 2320  om")..        # 
+0000af00: 4966 2061 2074 696c 6573 5f70 6174 6820  If a tiles_path 
+0000af10: 6973 2073 7065 6369 6669 6564 2c20 7265  is specified, re
+0000af20: 6164 2074 686f 7365 2074 696c 6573 2e2e  ad those tiles..
+0000af30: 2e0a 2020 2020 2020 2020 7265 7375 6c74  ..        result
+0000af40: 5f74 696c 6573 5f67 6466 203d 204e 6f6e  _tiles_gdf = Non
+0000af50: 650a 2020 2020 2020 2020 6966 2074 696c  e.        if til
+0000af60: 6573 5f70 6174 6820 6973 206e 6f74 204e  es_path is not N
+0000af70: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+0000af80: 2072 6573 756c 745f 7469 6c65 735f 6764   result_tiles_gd
+0000af90: 6620 3d20 6766 6f2e 7265 6164 5f66 696c  f = gfo.read_fil
+0000afa0: 6528 7469 6c65 735f 7061 7468 290a 2020  e(tiles_path).  
+0000afb0: 2020 2020 2020 2020 2020 6966 206e 625f            if nb_
+0000afc0: 7061 7261 6c6c 656c 203d 3d20 2d31 3a0a  parallel == -1:.
+0000afd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000afe0: 6e62 5f63 7075 203d 206d 756c 7469 7072  nb_cpu = multipr
+0000aff0: 6f63 6573 7369 6e67 2e63 7075 5f63 6f75  ocessing.cpu_cou
+0000b000: 6e74 2829 0a20 2020 2020 2020 2020 2020  nt().           
+0000b010: 2020 2020 206e 625f 7061 7261 6c6c 656c       nb_parallel
+0000b020: 203d 206e 625f 6370 7520 2023 2069 6e74   = nb_cpu  # int
+0000b030: 2831 2e32 3520 2a20 6e62 5f63 7075 290a  (1.25 * nb_cpu).
+0000b040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b050: 6c6f 6767 6572 2e64 6562 7567 2866 224e  logger.debug(f"N
+0000b060: 6220 6370 7573 2066 6f75 6e64 3a20 7b6e  b cpus found: {n
+0000b070: 625f 6370 757d 2c20 6e62 5f70 6172 616c  b_cpu}, nb_paral
+0000b080: 6c65 6c3a 207b 6e62 5f70 6172 616c 6c65  lel: {nb_paralle
+0000b090: 6c7d 2229 0a20 2020 2020 2020 2065 6c73  l}").        els
+0000b0a0: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
+0000b0b0: 2045 6c73 652c 2063 7265 6174 6520 6120   Else, create a 
+0000b0c0: 6772 6964 2062 6173 6564 206f 6e20 7468  grid based on th
+0000b0d0: 6520 6e75 6d62 6572 206f 6620 7469 6c65  e number of tile
+0000b0e0: 7320 7761 6e74 6564 2061 7320 7265 7375  s wanted as resu
+0000b0f0: 6c74 0a20 2020 2020 2020 2020 2020 2023  lt.            #
+0000b100: 2055 7365 2061 206d 6172 6769 6e20 6f66   Use a margin of
+0000b110: 2031 206d 6574 6572 2061 726f 756e 6420   1 meter around 
+0000b120: 7468 6520 626f 756e 6473 0a20 2020 2020  the bounds.     
+0000b130: 2020 2020 2020 206d 6172 6769 6e20 3d20         margin = 
+0000b140: 312e 300a 2020 2020 2020 2020 2020 2020  1.0.            
+0000b150: 6966 2069 6e70 7574 5f6c 6179 6572 696e  if input_layerin
+0000b160: 666f 2e63 7273 2069 7320 6e6f 7420 4e6f  fo.crs is not No
+0000b170: 6e65 2061 6e64 206e 6f74 2069 6e70 7574  ne and not input
+0000b180: 5f6c 6179 6572 696e 666f 2e63 7273 2e69  _layerinfo.crs.i
+0000b190: 735f 7072 6f6a 6563 7465 643a 0a20 2020  s_projected:.   
+0000b1a0: 2020 2020 2020 2020 2020 2020 2023 2049               # I
+0000b1b0: 6620 6765 6f67 7261 7068 6963 2063 7273  f geographic crs
+0000b1c0: 2c20 3120 6465 6772 6565 203d 2031 3131  , 1 degree = 111
+0000b1d0: 206b 6d20 6f72 2031 3131 3030 3020 6d0a   km or 111000 m.
+0000b1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b1f0: 6d61 7267 696e 202f 3d20 3131 3130 3030  margin /= 111000
+0000b200: 0a20 2020 2020 2020 2020 2020 2062 6f75  .            bou
+0000b210: 6e64 7320 3d20 696e 7075 745f 6c61 7965  nds = input_laye
+0000b220: 7269 6e66 6f2e 746f 7461 6c5f 626f 756e  rinfo.total_boun
+0000b230: 6473 0a20 2020 2020 2020 2020 2020 2062  ds.            b
+0000b240: 6f75 6e64 7320 3d20 280a 2020 2020 2020  ounds = (.      
+0000b250: 2020 2020 2020 2020 2020 626f 756e 6473            bounds
+0000b260: 5b30 5d20 2d20 6d61 7267 696e 2c0a 2020  [0] - margin,.  
+0000b270: 2020 2020 2020 2020 2020 2020 2020 626f                bo
+0000b280: 756e 6473 5b31 5d20 2d20 6d61 7267 696e  unds[1] - margin
+0000b290: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000b2a0: 2020 626f 756e 6473 5b32 5d20 2b20 6d61    bounds[2] + ma
+0000b2b0: 7267 696e 2c0a 2020 2020 2020 2020 2020  rgin,.          
+0000b2c0: 2020 2020 2020 626f 756e 6473 5b33 5d20        bounds[3] 
+0000b2d0: 2b20 6d61 7267 696e 2c0a 2020 2020 2020  + margin,.      
+0000b2e0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0000b2f0: 2020 2020 7265 7375 6c74 5f74 696c 6573      result_tiles
+0000b300: 5f67 6466 203d 2067 7064 2e47 656f 4461  _gdf = gpd.GeoDa
+0000b310: 7461 4672 616d 6528 0a20 2020 2020 2020  taFrame(.       
+0000b320: 2020 2020 2020 2020 2067 656f 6d65 7472           geometr
+0000b330: 793d 7079 6765 6f6f 7073 2e63 7265 6174  y=pygeoops.creat
+0000b340: 655f 6772 6964 3228 626f 756e 6473 2c20  e_grid2(bounds, 
+0000b350: 6e62 5f73 7175 6172 6973 685f 7469 6c65  nb_squarish_tile
+0000b360: 7329 2c0a 2020 2020 2020 2020 2020 2020  s),.            
+0000b370: 2020 2020 6372 733d 696e 7075 745f 6c61      crs=input_la
+0000b380: 7965 7269 6e66 6f2e 6372 732c 0a20 2020  yerinfo.crs,.   
+0000b390: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+0000b3a0: 2020 2020 2320 4170 706c 7920 6772 6964      # Apply grid
+0000b3b0: 7369 7a65 2074 6f6c 6572 616e 6365 206f  size tolerance o
+0000b3c0: 6e20 7469 6c65 732c 206f 7468 6572 7769  n tiles, otherwi
+0000b3d0: 7365 2074 6865 2062 6f72 6465 7220 706f  se the border po
+0000b3e0: 6c79 676f 6e73 2063 616e 2774 2062 650a  lygons can't be.
+0000b3f0: 2020 2020 2020 2020 2320 756e 696f 6e65          # unione
+0000b400: 6420 7072 6f70 6572 6c79 2062 6563 6175  d properly becau
+0000b410: 7365 2067 6170 7320 6170 7065 6172 2061  se gaps appear a
+0000b420: 6674 6572 2072 6f75 6e64 696e 6720 636f  fter rounding co
+0000b430: 6f72 6469 6e61 7465 732e 0a20 2020 2020  ordinates..     
+0000b440: 2020 2069 6620 6772 6964 7369 7a65 2021     if gridsize !
+0000b450: 3d20 302e 303a 0a20 2020 2020 2020 2020  = 0.0:.         
+0000b460: 2020 2072 6573 756c 745f 7469 6c65 735f     result_tiles_
+0000b470: 6764 662e 6765 6f6d 6574 7279 203d 2073  gdf.geometry = s
+0000b480: 6861 7065 6c79 2e73 6574 5f70 7265 6369  hapely.set_preci
+0000b490: 7369 6f6e 280a 2020 2020 2020 2020 2020  sion(.          
+0000b4a0: 2020 2020 2020 7265 7375 6c74 5f74 696c        result_til
+0000b4b0: 6573 5f67 6466 2e67 656f 6d65 7472 792c  es_gdf.geometry,
+0000b4c0: 2067 7269 645f 7369 7a65 3d67 7269 6473   grid_size=grids
+0000b4d0: 697a 650a 2020 2020 2020 2020 2020 2020  ize.            
+0000b4e0: 290a 2020 2020 2020 2020 6966 206c 656e  ).        if len
+0000b4f0: 2872 6573 756c 745f 7469 6c65 735f 6764  (result_tiles_gd
+0000b500: 6629 203e 2031 3a0a 2020 2020 2020 2020  f) > 1:.        
+0000b510: 2020 2020 6766 6f2e 746f 5f66 696c 6528      gfo.to_file(
+0000b520: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b530: 2072 6573 756c 745f 7469 6c65 735f 6764   result_tiles_gd
+0000b540: 662c 0a20 2020 2020 2020 2020 2020 2020  f,.             
+0000b550: 2020 206f 7574 7075 745f 7061 7468 2e70     output_path.p
+0000b560: 6172 656e 7420 2f20 6622 7b6f 7574 7075  arent / f"{outpu
+0000b570: 745f 7061 7468 2e73 7465 6d7d 5f74 696c  t_path.stem}_til
+0000b580: 6573 2e67 706b 6722 2c0a 2020 2020 2020  es.gpkg",.      
+0000b590: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+0000b5a0: 2023 2049 6620 6120 7469 6c65 6420 7265   # If a tiled re
+0000b5b0: 7375 6c74 2069 7320 6173 6b65 642c 2061  sult is asked, a
+0000b5c0: 6464 2074 696c 655f 6964 2074 6f20 6772  dd tile_id to gr
+0000b5d0: 6f75 7020 6f6e 2066 6f72 2074 6865 2072  oup on for the r
+0000b5e0: 6573 756c 740a 2020 2020 2020 2020 6966  esult.        if
+0000b5f0: 206c 656e 2872 6573 756c 745f 7469 6c65   len(result_tile
+0000b600: 735f 6764 6629 203e 2031 3a0a 2020 2020  s_gdf) > 1:.    
+0000b610: 2020 2020 2020 2020 7265 7375 6c74 5f74          result_t
+0000b620: 696c 6573 5f67 6466 5b22 7469 6c65 5f69  iles_gdf["tile_i
+0000b630: 6422 5d20 3d20 7265 7375 6c74 5f74 696c  d"] = result_til
+0000b640: 6573 5f67 6466 2e72 6573 6574 5f69 6e64  es_gdf.reset_ind
+0000b650: 6578 2829 2e69 6e64 6578 0a0a 2020 2020  ex().index..    
+0000b660: 2020 2020 2320 5468 6520 6469 7373 6f6c      # The dissol
+0000b670: 7665 2066 6f72 2070 6f6c 7967 6f6e 7320  ve for polygons 
+0000b680: 6973 2064 6f6e 6520 696e 2073 6576 6572  is done in sever
+0000b690: 616c 2070 6173 7365 732c 2061 6e64 2061  al passes, and a
+0000b6a0: 6674 6572 2074 6865 2066 6972 7374 0a20  fter the first. 
+0000b6b0: 2020 2020 2020 2023 2070 6173 732c 206f         # pass, o
+0000b6c0: 6e6c 7920 7468 6520 276f 6e62 6f72 6465  nly the 'onborde
+0000b6d0: 7227 2066 6561 7475 7265 7320 6172 6520  r' features are 
+0000b6e0: 6675 7274 6865 7220 6469 7373 6f6c 7665  further dissolve
+0000b6f0: 642c 2061 7320 7468 650a 2020 2020 2020  d, as the.      
+0000b700: 2020 2320 276e 6f74 6f6e 626f 7264 6572    # 'notonborder
+0000b710: 2720 6665 6174 7572 6573 2061 7265 2061  ' features are a
+0000b720: 6c72 6561 6479 204f 4b2e 0a20 2020 2020  lready OK..     
+0000b730: 2020 2074 656d 7064 6972 203d 205f 696f     tempdir = _io
+0000b740: 5f75 7469 6c2e 6372 6561 7465 5f74 656d  _util.create_tem
+0000b750: 7064 6972 2866 2267 656f 6669 6c65 6f70  pdir(f"geofileop
+0000b760: 732f 7b6f 7065 7261 7469 6f6e 5f6e 616d  s/{operation_nam
+0000b770: 657d 2229 0a20 2020 2020 2020 2074 7279  e}").        try
+0000b780: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+0000b790: 206f 7574 7075 745f 6c61 7965 7220 6973   output_layer is
+0000b7a0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0000b7b0: 2020 2020 2020 206f 7574 7075 745f 6c61         output_la
+0000b7c0: 7965 7220 3d20 6766 6f2e 6765 745f 6465  yer = gfo.get_de
+0000b7d0: 6661 756c 745f 6c61 7965 7228 6f75 7470  fault_layer(outp
+0000b7e0: 7574 5f70 6174 6829 0a20 2020 2020 2020  ut_path).       
+0000b7f0: 2020 2020 206f 7574 7075 745f 746d 705f       output_tmp_
+0000b800: 7061 7468 203d 2074 656d 7064 6972 202f  path = tempdir /
+0000b810: 2022 6f75 7470 7574 5f74 6d70 2e67 706b   "output_tmp.gpk
+0000b820: 6722 0a20 2020 2020 2020 2020 2020 2070  g".            p
+0000b830: 7265 765f 6e62 5f62 6174 6368 6573 203d  rev_nb_batches =
+0000b840: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
+0000b850: 2020 6c61 7374 5f70 6173 7320 3d20 4661    last_pass = Fa
+0000b860: 6c73 650a 2020 2020 2020 2020 2020 2020  lse.            
+0000b870: 7061 7373 5f69 6420 3d20 300a 2020 2020  pass_id = 0.    
+0000b880: 2020 2020 2020 2020 6c6f 6767 6572 2e69          logger.i
+0000b890: 6e66 6f28 6622 5374 6172 742c 2077 6974  nfo(f"Start, wit
+0000b8a0: 6820 696e 7075 7420 7b69 6e70 7574 5f70  h input {input_p
+0000b8b0: 6174 687d 2229 0a20 2020 2020 2020 2020  ath}").         
+0000b8c0: 2020 2069 6e70 7574 5f70 6173 735f 6c61     input_pass_la
+0000b8d0: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
+0000b8e0: 725d 203d 2069 6e70 7574 5f6c 6179 6572  r] = input_layer
+0000b8f0: 0a20 2020 2020 2020 2020 2020 2077 6869  .            whi
+0000b900: 6c65 2054 7275 653a 0a20 2020 2020 2020  le True:.       
+0000b910: 2020 2020 2020 2020 2023 2049 6620 696e           # If in
+0000b920: 7075 745f 7061 7468 2064 6f65 7320 6e6f  put_path does no
+0000b930: 7420 6578 6973 742c 2074 6865 206c 6173  t exist, the las
+0000b940: 7420 7061 7373 2064 6964 6e27 7420 6861  t pass didn't ha
+0000b950: 7665 2061 6e79 206f 6e62 6f72 6465 720a  ve any onborder.
+0000b960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b970: 2320 706f 6c79 676f 6e73 2061 7320 7265  # polygons as re
+0000b980: 7375 6c74 2c20 736f 2077 6520 6172 6520  sult, so we are 
+0000b990: 7265 6164 7920 6469 7373 6f6c 7669 6e67  ready dissolving
+0000b9a0: 2e2e 2e0a 2020 2020 2020 2020 2020 2020  ....            
+0000b9b0: 2020 2020 6966 206e 6f74 2069 6e70 7574      if not input
+0000b9c0: 5f70 6174 682e 6578 6973 7473 2829 3a0a  _path.exists():.
+0000b9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b9e0: 2020 2020 6272 6561 6b0a 0a20 2020 2020      break..     
+0000b9f0: 2020 2020 2020 2020 2020 2023 2047 6574             # Get
+0000ba00: 2069 6e66 6f20 6f66 2074 6865 2063 7572   info of the cur
+0000ba10: 7265 6e74 2066 696c 6520 7468 6174 206e  rent file that n
+0000ba20: 6565 6473 2074 6f20 6265 2064 6973 736f  eeds to be disso
+0000ba30: 6c76 6564 0a20 2020 2020 2020 2020 2020  lved.           
+0000ba40: 2020 2020 2069 6e70 7574 5f70 6173 735f       input_pass_
+0000ba50: 6c61 7965 7269 6e66 6f20 3d20 6766 6f2e  layerinfo = gfo.
+0000ba60: 6765 745f 6c61 7965 7269 6e66 6f28 696e  get_layerinfo(in
+0000ba70: 7075 745f 7061 7468 2c20 696e 7075 745f  put_path, input_
+0000ba80: 7061 7373 5f6c 6179 6572 290a 2020 2020  pass_layer).    
+0000ba90: 2020 2020 2020 2020 2020 2020 6e62 5f72              nb_r
+0000baa0: 6f77 735f 746f 7461 6c20 3d20 696e 7075  ows_total = inpu
+0000bab0: 745f 7061 7373 5f6c 6179 6572 696e 666f  t_pass_layerinfo
+0000bac0: 2e66 6561 7475 7265 636f 756e 740a 0a20  .featurecount.. 
+0000bad0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000bae0: 2043 616c 6375 6c61 7465 2074 6865 2062   Calculate the b
+0000baf0: 6573 7420 6e75 6d62 6572 206f 6620 7061  est number of pa
+0000bb00: 7261 6c6c 656c 2070 726f 6365 7373 6573  rallel processes
+0000bb10: 2061 6e64 2062 6174 6368 6573 2066 6f72   and batches for
+0000bb20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000bb30: 2023 2074 6865 2061 7661 696c 6162 6c65   # the available
+0000bb40: 2072 6573 6f75 7263 6573 2066 6f72 2074   resources for t
+0000bb50: 6865 2063 7572 7265 6e74 2070 6173 730a  he current pass.
+0000bb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bb70: 2320 4c69 6d69 7420 7468 6520 6e62 206f  # Limit the nb o
+0000bb80: 6620 726f 7773 2070 6572 2062 6174 6368  f rows per batch
+0000bb90: 2c20 6173 2064 6973 736f 6c76 6520 736c  , as dissolve sl
+0000bba0: 6f77 7320 646f 776e 2077 6974 6820 6d6f  ows down with mo
+0000bbb0: 7265 2072 6f77 732e 0a20 2020 2020 2020  re rows..       
+0000bbc0: 2020 2020 2020 2020 206e 625f 7061 7261           nb_para
+0000bbd0: 6c6c 656c 2c20 6e62 5f62 6174 6368 6573  llel, nb_batches
+0000bbe0: 203d 205f 6465 7465 726d 696e 655f 6e62   = _determine_nb
+0000bbf0: 5f62 6174 6368 6573 280a 2020 2020 2020  _batches(.      
+0000bc00: 2020 2020 2020 2020 2020 2020 2020 6e62                nb
+0000bc10: 5f72 6f77 735f 746f 7461 6c3d 6e62 5f72  _rows_total=nb_r
+0000bc20: 6f77 735f 746f 7461 6c2c 0a20 2020 2020  ows_total,.     
+0000bc30: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+0000bc40: 625f 7061 7261 6c6c 656c 3d6e 625f 7061  b_parallel=nb_pa
+0000bc50: 7261 6c6c 656c 2c0a 2020 2020 2020 2020  rallel,.        
+0000bc60: 2020 2020 2020 2020 2020 2020 6261 7463              batc
+0000bc70: 6873 697a 653d 6261 7463 6873 697a 652c  hsize=batchsize,
+0000bc80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000bc90: 2020 2020 2070 6172 616c 6c65 6c69 7a61       paralleliza
+0000bca0: 7469 6f6e 5f63 6f6e 6669 673d 5061 7261  tion_config=Para
+0000bcb0: 6c6c 656c 697a 6174 696f 6e43 6f6e 6669  llelizationConfi
+0000bcc0: 6728 0a20 2020 2020 2020 2020 2020 2020  g(.             
+0000bcd0: 2020 2020 2020 2020 2020 206d 6178 5f72             max_r
+0000bce0: 6f77 735f 7065 725f 6261 7463 683d 3130  ows_per_batch=10
+0000bcf0: 3030 300a 2020 2020 2020 2020 2020 2020  000.            
+0000bd00: 2020 2020 2020 2020 292c 0a20 2020 2020          ),.     
+0000bd10: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+0000bd20: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000bd30: 4966 2074 6865 2069 6465 616c 206e 756d  If the ideal num
+0000bd40: 6265 7220 6f66 2062 6174 6368 6573 2069  ber of batches i
+0000bd50: 7320 636c 6f73 6520 746f 2074 6865 206e  s close to the n
+0000bd60: 622e 2072 6573 756c 7420 7469 6c65 7320  b. result tiles 
+0000bd70: 6173 6b65 642c 0a20 2020 2020 2020 2020  asked,.         
+0000bd80: 2020 2020 2020 2023 2064 6973 736f 6c76         # dissolv
+0000bd90: 6520 746f 7761 7264 7320 7468 6520 6173  e towards the as
+0000bda0: 6b65 6420 7265 7375 6c74 210a 2020 2020  ked result!.    
+0000bdb0: 2020 2020 2020 2020 2020 2020 2320 4966              # If
+0000bdc0: 206e 6f74 2c20 6120 7465 6d70 6f72 6172   not, a temporar
+0000bdd0: 7920 7265 7375 6c74 2069 7320 6372 6561  y result is crea
+0000bde0: 7465 6420 7573 696e 6720 736d 616c 6c65  ted using smalle
+0000bdf0: 7220 7469 6c65 730a 2020 2020 2020 2020  r tiles.        
+0000be00: 2020 2020 2020 2020 6966 206e 625f 6261          if nb_ba
+0000be10: 7463 6865 7320 3c3d 206c 656e 2872 6573  tches <= len(res
+0000be20: 756c 745f 7469 6c65 735f 6764 6629 202a  ult_tiles_gdf) *
+0000be30: 2031 2e31 3a0a 2020 2020 2020 2020 2020   1.1:.          
+0000be40: 2020 2020 2020 2020 2020 7469 6c65 735f            tiles_
+0000be50: 6764 6620 3d20 7265 7375 6c74 5f74 696c  gdf = result_til
+0000be60: 6573 5f67 6466 0a20 2020 2020 2020 2020  es_gdf.         
+0000be70: 2020 2020 2020 2020 2020 206c 6173 745f             last_
+0000be80: 7061 7373 203d 2054 7275 650a 2020 2020  pass = True.    
+0000be90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bea0: 6e62 5f70 6172 616c 6c65 6c20 3d20 6d69  nb_parallel = mi
+0000beb0: 6e28 6c65 6e28 7265 7375 6c74 5f74 696c  n(len(result_til
+0000bec0: 6573 5f67 6466 292c 206e 625f 7061 7261  es_gdf), nb_para
+0000bed0: 6c6c 656c 290a 2020 2020 2020 2020 2020  llel).          
+0000bee0: 2020 2020 2020 656c 6966 206c 656e 2872        elif len(r
+0000bef0: 6573 756c 745f 7469 6c65 735f 6764 6629  esult_tiles_gdf)
+0000bf00: 203d 3d20 313a 0a20 2020 2020 2020 2020   == 1:.         
+0000bf10: 2020 2020 2020 2020 2020 2023 2043 7265             # Cre
+0000bf20: 6174 6520 6120 6772 6964 2062 6173 6564  ate a grid based
+0000bf30: 206f 6e20 7468 6520 6964 6561 6c20 6e75   on the ideal nu
+0000bf40: 6d62 6572 206f 6620 6261 7463 6865 732c  mber of batches,
+0000bf50: 2062 7574 206d 616b 650a 2020 2020 2020   but make.      
+0000bf60: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000bf70: 7375 7265 2074 6865 206e 756d 6265 7220  sure the number 
+0000bf80: 6973 2073 6d61 6c6c 6572 2074 6861 6e20  is smaller than 
+0000bf90: 7468 6520 6d61 7869 6d75 6d2e 2e2e 0a20  the maximum.... 
+0000bfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bfb0: 2020 206e 625f 7371 7561 7269 7368 5f74     nb_squarish_t
+0000bfc0: 696c 6573 5f6d 6178 203d 204e 6f6e 650a  iles_max = None.
+0000bfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bfe0: 2020 2020 6966 2070 7265 765f 6e62 5f62      if prev_nb_b
+0000bff0: 6174 6368 6573 2069 7320 6e6f 7420 4e6f  atches is not No
+0000c000: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+0000c010: 2020 2020 2020 2020 2020 2020 6e62 5f73              nb_s
+0000c020: 7175 6172 6973 685f 7469 6c65 735f 6d61  quarish_tiles_ma
+0000c030: 7820 3d20 6d61 7828 7072 6576 5f6e 625f  x = max(prev_nb_
+0000c040: 6261 7463 6865 7320 2d20 312c 2031 290a  batches - 1, 1).
+0000c050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c060: 2020 2020 2020 2020 6e62 5f62 6174 6368          nb_batch
+0000c070: 6573 203d 206d 696e 286e 625f 6261 7463  es = min(nb_batc
+0000c080: 6865 732c 206e 625f 7371 7561 7269 7368  hes, nb_squarish
+0000c090: 5f74 696c 6573 5f6d 6178 290a 2020 2020  _tiles_max).    
+0000c0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c0b0: 6772 6964 5f74 6f74 616c 5f62 6f75 6e64  grid_total_bound
+0000c0c0: 7320 3d20 280a 2020 2020 2020 2020 2020  s = (.          
+0000c0d0: 2020 2020 2020 2020 2020 2020 2020 696e                in
+0000c0e0: 7075 745f 7061 7373 5f6c 6179 6572 696e  put_pass_layerin
+0000c0f0: 666f 2e74 6f74 616c 5f62 6f75 6e64 735b  fo.total_bounds[
+0000c100: 305d 202d 2030 2e30 3030 3030 312c 0a20  0] - 0.000001,. 
+0000c110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c120: 2020 2020 2020 2069 6e70 7574 5f70 6173         input_pas
+0000c130: 735f 6c61 7965 7269 6e66 6f2e 746f 7461  s_layerinfo.tota
+0000c140: 6c5f 626f 756e 6473 5b31 5d20 2d20 302e  l_bounds[1] - 0.
+0000c150: 3030 3030 3031 2c0a 2020 2020 2020 2020  000001,.        
+0000c160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c170: 696e 7075 745f 7061 7373 5f6c 6179 6572  input_pass_layer
+0000c180: 696e 666f 2e74 6f74 616c 5f62 6f75 6e64  info.total_bound
+0000c190: 735b 325d 202b 2030 2e30 3030 3030 312c  s[2] + 0.000001,
+0000c1a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c1b0: 2020 2020 2020 2020 2069 6e70 7574 5f70           input_p
+0000c1c0: 6173 735f 6c61 7965 7269 6e66 6f2e 746f  ass_layerinfo.to
+0000c1d0: 7461 6c5f 626f 756e 6473 5b33 5d20 2b20  tal_bounds[3] + 
+0000c1e0: 302e 3030 3030 3031 2c0a 2020 2020 2020  0.000001,.      
+0000c1f0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000c200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c210: 2020 2020 7469 6c65 735f 6764 6620 3d20      tiles_gdf = 
+0000c220: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
+0000c230: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000c240: 2020 2020 2020 2020 2020 6765 6f6d 6574            geomet
+0000c250: 7279 3d70 7967 656f 6f70 732e 6372 6561  ry=pygeoops.crea
+0000c260: 7465 5f67 7269 6432 280a 2020 2020 2020  te_grid2(.      
+0000c270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c280: 2020 2020 2020 746f 7461 6c5f 626f 756e        total_boun
+0000c290: 6473 3d67 7269 645f 746f 7461 6c5f 626f  ds=grid_total_bo
+0000c2a0: 756e 6473 2c0a 2020 2020 2020 2020 2020  unds,.          
+0000c2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c2c0: 2020 6e62 5f73 7175 6172 6973 685f 7469    nb_squarish_ti
+0000c2d0: 6c65 733d 6e62 5f62 6174 6368 6573 2c0a  les=nb_batches,.
+0000c2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c2f0: 2020 2020 2020 2020 2020 2020 6e62 5f73              nb_s
+0000c300: 7175 6172 6973 685f 7469 6c65 735f 6d61  quarish_tiles_ma
+0000c310: 783d 6e62 5f73 7175 6172 6973 685f 7469  x=nb_squarish_ti
+0000c320: 6c65 735f 6d61 782c 0a20 2020 2020 2020  les_max,.       
+0000c330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c340: 2029 2c0a 2020 2020 2020 2020 2020 2020   ),.            
+0000c350: 2020 2020 2020 2020 2020 2020 6372 733d              crs=
+0000c360: 696e 7075 745f 7061 7373 5f6c 6179 6572  input_pass_layer
+0000c370: 696e 666f 2e63 7273 2c0a 2020 2020 2020  info.crs,.      
+0000c380: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000c390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c3a0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0000c3b0: 2020 2020 2020 2020 2020 2320 4966 2061            # If a
+0000c3c0: 2067 7269 6420 6973 2073 7065 6369 6669   grid is specifi
+0000c3d0: 6564 2061 6c72 6561 6479 2c20 6164 6420  ed already, add 
+0000c3e0: 6578 7472 6120 636f 6c75 6d6e 732f 726f  extra columns/ro
+0000c3f0: 7773 2069 6e73 7465 6164 206f 660a 2020  ws instead of.  
+0000c400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c410: 2020 2320 6372 6561 7469 6e67 206e 6577    # creating new
+0000c420: 206f 6e65 2e2e 2e0a 2020 2020 2020 2020   one....        
+0000c430: 2020 2020 2020 2020 2020 2020 7469 6c65              tile
+0000c440: 735f 6764 6620 3d20 7079 6765 6f6f 7073  s_gdf = pygeoops
+0000c450: 2e73 706c 6974 5f74 696c 6573 2872 6573  .split_tiles(res
+0000c460: 756c 745f 7469 6c65 735f 6764 662c 206e  ult_tiles_gdf, n
+0000c470: 625f 6261 7463 6865 7329 0a0a 2020 2020  b_batches)..    
+0000c480: 2020 2020 2020 2020 2020 2020 2320 4170              # Ap
+0000c490: 706c 7920 6772 6964 7369 7a65 2074 6f6c  ply gridsize tol
+0000c4a0: 6572 616e 6365 206f 6e20 7469 6c65 732c  erance on tiles,
+0000c4b0: 206f 7468 6572 7769 7365 2074 6865 2062   otherwise the b
+0000c4c0: 6f72 6465 7220 706f 6c79 676f 6e73 2063  order polygons c
+0000c4d0: 616e 2774 0a20 2020 2020 2020 2020 2020  an't.           
+0000c4e0: 2020 2020 2023 2062 6520 756e 696f 6e65       # be unione
+0000c4f0: 6420 7072 6f70 6572 6c79 2062 6563 6175  d properly becau
+0000c500: 7365 2067 6170 7320 6170 7065 6172 2061  se gaps appear a
+0000c510: 6674 6572 2072 6f75 6e64 696e 6720 636f  fter rounding co
+0000c520: 6f72 6469 6e61 7465 732e 0a20 2020 2020  ordinates..     
+0000c530: 2020 2020 2020 2020 2020 2069 6620 6772             if gr
+0000c540: 6964 7369 7a65 2021 3d20 302e 303a 0a20  idsize != 0.0:. 
+0000c550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c560: 2020 2074 696c 6573 5f67 6466 2e67 656f     tiles_gdf.geo
+0000c570: 6d65 7472 7920 3d20 7368 6170 656c 792e  metry = shapely.
+0000c580: 7365 745f 7072 6563 6973 696f 6e28 0a20  set_precision(. 
+0000c590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c5a0: 2020 2020 2020 2074 696c 6573 5f67 6466         tiles_gdf
+0000c5b0: 2e67 656f 6d65 7472 792c 2067 7269 645f  .geometry, grid_
+0000c5c0: 7369 7a65 3d67 7269 6473 697a 650a 2020  size=gridsize.  
+0000c5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c5e0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+0000c5f0: 2020 2020 6766 6f2e 746f 5f66 696c 6528      gfo.to_file(
+0000c600: 7469 6c65 735f 6764 662c 2074 656d 7064  tiles_gdf, tempd
+0000c610: 6972 202f 2066 226f 7574 7075 745f 7b70  ir / f"output_{p
+0000c620: 6173 735f 6964 7d5f 7469 6c65 732e 6770  ass_id}_tiles.gp
+0000c630: 6b67 2229 0a0a 2020 2020 2020 2020 2020  kg")..          
+0000c640: 2020 2020 2020 2320 4966 2074 6865 206e        # If the n
+0000c650: 756d 6265 7220 6f66 2074 696c 6573 2065  umber of tiles e
+0000c660: 6e64 7320 7570 2061 7320 312c 2069 7420  nds up as 1, it 
+0000c670: 6973 2074 6865 206c 6173 7420 7061 7373  is the last pass
+0000c680: 2061 6e79 7761 792e 2e2e 0a20 2020 2020   anyway....     
+0000c690: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
+0000c6a0: 6e28 7469 6c65 735f 6764 6629 203d 3d20  n(tiles_gdf) == 
+0000c6b0: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
+0000c6c0: 2020 2020 2020 206c 6173 745f 7061 7373         last_pass
+0000c6d0: 203d 2054 7275 650a 0a20 2020 2020 2020   = True..       
+0000c6e0: 2020 2020 2020 2020 2023 2049 6620 7765           # If we
+0000c6f0: 2061 7265 206e 6f74 2069 6e20 7468 6520   are not in the 
+0000c700: 6c61 7374 2070 6173 732c 206f 6e62 6f72  last pass, onbor
+0000c710: 6465 7220 7061 7263 656c 7320 7769 6c6c  der parcels will
+0000c720: 206e 6565 6420 6578 7472 610a 2020 2020   need extra.    
+0000c730: 2020 2020 2020 2020 2020 2020 2320 7072              # pr
+0000c740: 6f63 6573 7369 6e67 2073 7469 6c6c 2069  ocessing still i
+0000c750: 6e20 6675 7274 6865 7220 7061 7373 6573  n further passes
+0000c760: 2c20 736f 2061 7265 2073 6176 6564 2069  , so are saved i
+0000c770: 6e20 6120 7365 7065 7261 7465 0a20 2020  n a seperate.   
+0000c780: 2020 2020 2020 2020 2020 2020 2023 2067               # g
+0000c790: 666f 2e20 5468 6520 6e6f 746f 6e62 6f72  fo. The notonbor
+0000c7a0: 6465 7220 726f 7773 2061 7265 2066 696e  der rows are fin
+0000c7b0: 616c 2069 6d6d 6564 6961 7465 6c79 0a20  al immediately. 
+0000c7c0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000c7d0: 6620 6c61 7374 5f70 6173 7320 6973 206e  f last_pass is n
+0000c7e0: 6f74 2054 7275 653a 0a20 2020 2020 2020  ot True:.       
+0000c7f0: 2020 2020 2020 2020 2020 2020 206f 7574               out
+0000c800: 7075 745f 746d 705f 6f6e 626f 7264 6572  put_tmp_onborder
+0000c810: 5f70 6174 6820 3d20 280a 2020 2020 2020  _path = (.      
+0000c820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c830: 2020 7465 6d70 6469 7220 2f20 6622 6f75    tempdir / f"ou
+0000c840: 7470 7574 5f7b 7061 7373 5f69 647d 5f6f  tput_{pass_id}_o
+0000c850: 6e62 6f72 6465 722e 6770 6b67 220a 2020  nborder.gpkg".  
 0000c860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c870: 2020 2020 2020 2020 2020 6e62 5f73 7175            nb_squ
-0000c880: 6172 6973 685f 7469 6c65 735f 6d61 783d  arish_tiles_max=
-0000c890: 6e62 5f73 7175 6172 6973 685f 7469 6c65  nb_squarish_tile
-0000c8a0: 735f 6d61 782c 0d0a 2020 2020 2020 2020  s_max,..        
-0000c8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c8c0: 292c 0d0a 2020 2020 2020 2020 2020 2020  ),..            
-0000c8d0: 2020 2020 2020 2020 2020 2020 6372 733d              crs=
-0000c8e0: 696e 7075 745f 7061 7373 5f6c 6179 6572  input_pass_layer
-0000c8f0: 696e 666f 2e63 7273 2c0d 0a20 2020 2020  info.crs,..     
-0000c900: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-0000c910: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000c920: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-0000c930: 2020 2020 2020 2020 2020 2020 2023 2049               # I
-0000c940: 6620 6120 6772 6964 2069 7320 7370 6563  f a grid is spec
-0000c950: 6966 6965 6420 616c 7265 6164 792c 2061  ified already, a
-0000c960: 6464 2065 7874 7261 2063 6f6c 756d 6e73  dd extra columns
-0000c970: 2f72 6f77 7320 696e 7374 6561 6420 6f66  /rows instead of
-0000c980: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000c990: 2020 2020 2020 2320 6372 6561 7469 6e67        # creating
-0000c9a0: 206e 6577 206f 6e65 2e2e 2e0d 0a20 2020   new one.....   
-0000c9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c9c0: 2074 696c 6573 5f67 6466 203d 2070 7967   tiles_gdf = pyg
-0000c9d0: 656f 6f70 732e 7370 6c69 745f 7469 6c65  eoops.split_tile
-0000c9e0: 7328 7265 7375 6c74 5f74 696c 6573 5f67  s(result_tiles_g
-0000c9f0: 6466 2c20 6e62 5f62 6174 6368 6573 290d  df, nb_batches).
-0000ca00: 0a0d 0a20 2020 2020 2020 2020 2020 2020  ...             
-0000ca10: 2020 2023 2041 7070 6c79 2067 7269 6473     # Apply grids
-0000ca20: 697a 6520 746f 6c65 7261 6e63 6520 6f6e  ize tolerance on
-0000ca30: 2074 696c 6573 2c20 6f74 6865 7277 6973   tiles, otherwis
-0000ca40: 6520 7468 6520 626f 7264 6572 2070 6f6c  e the border pol
-0000ca50: 7967 6f6e 7320 6361 6e27 740d 0a20 2020  ygons can't..   
-0000ca60: 2020 2020 2020 2020 2020 2020 2023 2062               # b
-0000ca70: 6520 756e 696f 6e65 6420 7072 6f70 6572  e unioned proper
-0000ca80: 6c79 2062 6563 6175 7365 2067 6170 7320  ly because gaps 
-0000ca90: 6170 7065 6172 2061 6674 6572 2072 6f75  appear after rou
-0000caa0: 6e64 696e 6720 636f 6f72 6469 6e61 7465  nding coordinate
-0000cab0: 732e 0d0a 2020 2020 2020 2020 2020 2020  s...            
-0000cac0: 2020 2020 6966 2067 7269 6473 697a 6520      if gridsize 
-0000cad0: 213d 2030 2e30 3a0d 0a20 2020 2020 2020  != 0.0:..       
-0000cae0: 2020 2020 2020 2020 2020 2020 2074 696c               til
-0000caf0: 6573 5f67 6466 2e67 656f 6d65 7472 7920  es_gdf.geometry 
-0000cb00: 3d20 7368 6170 656c 792e 7365 745f 7072  = shapely.set_pr
-0000cb10: 6563 6973 696f 6e28 0d0a 2020 2020 2020  ecision(..      
-0000cb20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb30: 2020 7469 6c65 735f 6764 662e 6765 6f6d    tiles_gdf.geom
-0000cb40: 6574 7279 2c20 6772 6964 5f73 697a 653d  etry, grid_size=
-0000cb50: 6772 6964 7369 7a65 0d0a 2020 2020 2020  gridsize..      
-0000cb60: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-0000cb70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000cb80: 2067 666f 2e74 6f5f 6669 6c65 2874 696c   gfo.to_file(til
-0000cb90: 6573 5f67 6466 2c20 7465 6d70 6469 7220  es_gdf, tempdir 
-0000cba0: 2f20 6622 6f75 7470 7574 5f7b 7061 7373  / f"output_{pass
-0000cbb0: 5f69 647d 5f74 696c 6573 2e67 706b 6722  _id}_tiles.gpkg"
-0000cbc0: 290d 0a0d 0a20 2020 2020 2020 2020 2020  )....           
-0000cbd0: 2020 2020 2023 2049 6620 7468 6520 6e75       # If the nu
-0000cbe0: 6d62 6572 206f 6620 7469 6c65 7320 656e  mber of tiles en
-0000cbf0: 6473 2075 7020 6173 2031 2c20 6974 2069  ds up as 1, it i
-0000cc00: 7320 7468 6520 6c61 7374 2070 6173 7320  s the last pass 
-0000cc10: 616e 7977 6179 2e2e 2e0d 0a20 2020 2020  anyway.....     
-0000cc20: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-0000cc30: 6e28 7469 6c65 735f 6764 6629 203d 3d20  n(tiles_gdf) == 
-0000cc40: 313a 0d0a 2020 2020 2020 2020 2020 2020  1:..            
-0000cc50: 2020 2020 2020 2020 6c61 7374 5f70 6173          last_pas
-0000cc60: 7320 3d20 5472 7565 0d0a 0d0a 2020 2020  s = True....    
-0000cc70: 2020 2020 2020 2020 2020 2020 2320 4966              # If
-0000cc80: 2077 6520 6172 6520 6e6f 7420 696e 2074   we are not in t
-0000cc90: 6865 206c 6173 7420 7061 7373 2c20 6f6e  he last pass, on
-0000cca0: 626f 7264 6572 2070 6172 6365 6c73 2077  border parcels w
-0000ccb0: 696c 6c20 6e65 6564 2065 7874 7261 0d0a  ill need extra..
-0000ccc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ccd0: 2320 7072 6f63 6573 7369 6e67 2073 7469  # processing sti
-0000cce0: 6c6c 2069 6e20 6675 7274 6865 7220 7061  ll in further pa
-0000ccf0: 7373 6573 2c20 736f 2061 7265 2073 6176  sses, so are sav
-0000cd00: 6564 2069 6e20 6120 7365 7065 7261 7465  ed in a seperate
-0000cd10: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000cd20: 2020 2320 6766 6f2e 2054 6865 206e 6f74    # gfo. The not
-0000cd30: 6f6e 626f 7264 6572 2072 6f77 7320 6172  onborder rows ar
-0000cd40: 6520 6669 6e61 6c20 696d 6d65 6469 6174  e final immediat
-0000cd50: 656c 790d 0a20 2020 2020 2020 2020 2020  ely..           
-0000cd60: 2020 2020 2069 6620 6c61 7374 5f70 6173       if last_pas
-0000cd70: 7320 6973 206e 6f74 2054 7275 653a 0d0a  s is not True:..
-0000cd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cd90: 2020 2020 6f75 7470 7574 5f74 6d70 5f6f      output_tmp_o
-0000cda0: 6e62 6f72 6465 725f 7061 7468 203d 2028  nborder_path = (
-0000cdb0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000cdc0: 2020 2020 2020 2020 2020 7465 6d70 6469            tempdi
-0000cdd0: 7220 2f20 6622 6f75 7470 7574 5f7b 7061  r / f"output_{pa
-0000cde0: 7373 5f69 647d 5f6f 6e62 6f72 6465 722e  ss_id}_onborder.
-0000cdf0: 6770 6b67 220d 0a20 2020 2020 2020 2020  gpkg"..         
-0000ce00: 2020 2020 2020 2020 2020 2029 0d0a 2020             )..  
-0000ce10: 2020 2020 2020 2020 2020 2020 2020 656c                el
-0000ce20: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-0000ce30: 2020 2020 2020 2020 206f 7574 7075 745f           output_
-0000ce40: 746d 705f 6f6e 626f 7264 6572 5f70 6174  tmp_onborder_pat
-0000ce50: 6820 3d20 6f75 7470 7574 5f74 6d70 5f70  h = output_tmp_p
-0000ce60: 6174 680d 0a0d 0a20 2020 2020 2020 2020  ath....         
-0000ce70: 2020 2020 2020 2023 204e 6f77 2067 6f21         # Now go!
-0000ce80: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000ce90: 2020 6c6f 6767 6572 2e69 6e66 6f28 0d0a    logger.info(..
-0000cea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ceb0: 2020 2020 6622 5374 6172 7420 7061 7373      f"Start pass
-0000cec0: 207b 7061 7373 5f69 647d 2074 6f20 7b6c   {pass_id} to {l
-0000ced0: 656e 2874 696c 6573 5f67 6466 297d 2074  en(tiles_gdf)} t
-0000cee0: 696c 6573 2022 0d0a 2020 2020 2020 2020  iles "..        
-0000cef0: 2020 2020 2020 2020 2020 2020 6622 2862              f"(b
-0000cf00: 6174 6368 2073 697a 653a 207b 696e 7428  atch size: {int(
-0000cf10: 6e62 5f72 6f77 735f 746f 7461 6c2f 6c65  nb_rows_total/le
-0000cf20: 6e28 7469 6c65 735f 6764 6629 297d 2922  n(tiles_gdf))})"
-0000cf30: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000cf40: 2020 290d 0a20 2020 2020 2020 2020 2020    )..           
-0000cf50: 2020 2020 2070 6173 735f 7374 6172 7420       pass_start 
-0000cf60: 3d20 6461 7465 7469 6d65 2e6e 6f77 2829  = datetime.now()
-0000cf70: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000cf80: 2020 5f20 3d20 5f64 6973 736f 6c76 655f    _ = _dissolve_
-0000cf90: 706f 6c79 676f 6e73 5f70 6173 7328 0d0a  polygons_pass(..
-0000cfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cfb0: 2020 2020 696e 7075 745f 7061 7468 3d69      input_path=i
-0000cfc0: 6e70 7574 5f70 6174 682c 0d0a 2020 2020  nput_path,..    
-0000cfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cfe0: 6f75 7470 7574 5f6e 6f74 6f6e 626f 7264  output_notonbord
-0000cff0: 6572 5f70 6174 683d 6f75 7470 7574 5f74  er_path=output_t
-0000d000: 6d70 5f70 6174 682c 0d0a 2020 2020 2020  mp_path,..      
-0000d010: 2020 2020 2020 2020 2020 2020 2020 6f75                ou
-0000d020: 7470 7574 5f6f 6e62 6f72 6465 725f 7061  tput_onborder_pa
-0000d030: 7468 3d6f 7574 7075 745f 746d 705f 6f6e  th=output_tmp_on
-0000d040: 626f 7264 6572 5f70 6174 682c 0d0a 2020  border_path,..  
-0000d050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d060: 2020 6578 706c 6f64 6563 6f6c 6c65 6374    explodecollect
-0000d070: 696f 6e73 3d65 7870 6c6f 6465 636f 6c6c  ions=explodecoll
-0000d080: 6563 7469 6f6e 732c 0d0a 2020 2020 2020  ections,..      
-0000d090: 2020 2020 2020 2020 2020 2020 2020 6772                gr
-0000d0a0: 6f75 7062 795f 636f 6c75 6d6e 733d 6772  oupby_columns=gr
-0000d0b0: 6f75 7062 795f 636f 6c75 6d6e 732c 0d0a  oupby_columns,..
-0000d0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d0d0: 2020 2020 6167 675f 636f 6c75 6d6e 733d      agg_columns=
-0000d0e0: 6167 675f 636f 6c75 6d6e 732c 0d0a 2020  agg_columns,..  
+0000c870: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+0000c880: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000c890: 2020 2020 2020 2020 2020 2020 2020 6f75                ou
+0000c8a0: 7470 7574 5f74 6d70 5f6f 6e62 6f72 6465  tput_tmp_onborde
+0000c8b0: 725f 7061 7468 203d 206f 7574 7075 745f  r_path = output_
+0000c8c0: 746d 705f 7061 7468 0a0a 2020 2020 2020  tmp_path..      
+0000c8d0: 2020 2020 2020 2020 2020 2320 4e6f 7720            # Now 
+0000c8e0: 676f 210a 2020 2020 2020 2020 2020 2020  go!.            
+0000c8f0: 2020 2020 6c6f 6767 6572 2e69 6e66 6f28      logger.info(
+0000c900: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c910: 2020 2020 2066 2253 7461 7274 2070 6173       f"Start pas
+0000c920: 7320 7b70 6173 735f 6964 7d20 746f 207b  s {pass_id} to {
+0000c930: 6c65 6e28 7469 6c65 735f 6764 6629 7d20  len(tiles_gdf)} 
+0000c940: 7469 6c65 7320 220a 2020 2020 2020 2020  tiles ".        
+0000c950: 2020 2020 2020 2020 2020 2020 6622 2862              f"(b
+0000c960: 6174 6368 2073 697a 653a 207b 696e 7428  atch size: {int(
+0000c970: 6e62 5f72 6f77 735f 746f 7461 6c2f 6c65  nb_rows_total/le
+0000c980: 6e28 7469 6c65 735f 6764 6629 297d 2922  n(tiles_gdf))})"
+0000c990: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c9a0: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+0000c9b0: 2020 2070 6173 735f 7374 6172 7420 3d20     pass_start = 
+0000c9c0: 6461 7465 7469 6d65 2e6e 6f77 2829 0a20  datetime.now(). 
+0000c9d0: 2020 2020 2020 2020 2020 2020 2020 205f                 _
+0000c9e0: 203d 205f 6469 7373 6f6c 7665 5f70 6f6c   = _dissolve_pol
+0000c9f0: 7967 6f6e 735f 7061 7373 280a 2020 2020  ygons_pass(.    
+0000ca00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ca10: 696e 7075 745f 7061 7468 3d69 6e70 7574  input_path=input
+0000ca20: 5f70 6174 682c 0a20 2020 2020 2020 2020  _path,.         
+0000ca30: 2020 2020 2020 2020 2020 206f 7574 7075             outpu
+0000ca40: 745f 6e6f 746f 6e62 6f72 6465 725f 7061  t_notonborder_pa
+0000ca50: 7468 3d6f 7574 7075 745f 746d 705f 7061  th=output_tmp_pa
+0000ca60: 7468 2c0a 2020 2020 2020 2020 2020 2020  th,.            
+0000ca70: 2020 2020 2020 2020 6f75 7470 7574 5f6f          output_o
+0000ca80: 6e62 6f72 6465 725f 7061 7468 3d6f 7574  nborder_path=out
+0000ca90: 7075 745f 746d 705f 6f6e 626f 7264 6572  put_tmp_onborder
+0000caa0: 5f70 6174 682c 0a20 2020 2020 2020 2020  _path,.         
+0000cab0: 2020 2020 2020 2020 2020 2065 7870 6c6f             explo
+0000cac0: 6465 636f 6c6c 6563 7469 6f6e 733d 6578  decollections=ex
+0000cad0: 706c 6f64 6563 6f6c 6c65 6374 696f 6e73  plodecollections
+0000cae0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000caf0: 2020 2020 2020 6772 6f75 7062 795f 636f        groupby_co
+0000cb00: 6c75 6d6e 733d 6772 6f75 7062 795f 636f  lumns=groupby_co
+0000cb10: 6c75 6d6e 732c 0a20 2020 2020 2020 2020  lumns,.         
+0000cb20: 2020 2020 2020 2020 2020 2061 6767 5f63             agg_c
+0000cb30: 6f6c 756d 6e73 3d61 6767 5f63 6f6c 756d  olumns=agg_colum
+0000cb40: 6e73 2c0a 2020 2020 2020 2020 2020 2020  ns,.            
+0000cb50: 2020 2020 2020 2020 7469 6c65 735f 6764          tiles_gd
+0000cb60: 663d 7469 6c65 735f 6764 662c 0a20 2020  f=tiles_gdf,.   
+0000cb70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cb80: 2069 6e70 7574 5f6c 6179 6572 3d69 6e70   input_layer=inp
+0000cb90: 7574 5f70 6173 735f 6c61 7965 722c 0a20  ut_pass_layer,. 
+0000cba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cbb0: 2020 206f 7574 7075 745f 6c61 7965 723d     output_layer=
+0000cbc0: 6f75 7470 7574 5f6c 6179 6572 2c0a 2020  output_layer,.  
+0000cbd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cbe0: 2020 6772 6964 7369 7a65 3d67 7269 6473    gridsize=grids
+0000cbf0: 697a 652c 0a20 2020 2020 2020 2020 2020  ize,.           
+0000cc00: 2020 2020 2020 2020 206b 6565 705f 656d           keep_em
+0000cc10: 7074 795f 6765 6f6d 733d 4661 6c73 652c  pty_geoms=False,
+0000cc20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000cc30: 2020 2020 206e 625f 7061 7261 6c6c 656c       nb_parallel
+0000cc40: 3d6e 625f 7061 7261 6c6c 656c 2c0a 2020  =nb_parallel,.  
+0000cc50: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000cc60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc70: 6c6f 6767 6572 2e69 6e66 6f28 6622 5061  logger.info(f"Pa
+0000cc80: 7373 207b 7061 7373 5f69 647d 2072 6561  ss {pass_id} rea
+0000cc90: 6479 2c20 746f 6f6b 207b 6461 7465 7469  dy, took {dateti
+0000cca0: 6d65 2e6e 6f77 2829 2d70 6173 735f 7374  me.now()-pass_st
+0000ccb0: 6172 747d 2229 0a0a 2020 2020 2020 2020  art}")..        
+0000ccc0: 2020 2020 2020 2020 2320 5072 6570 6172          # Prepar
+0000ccd0: 6520 7468 6520 6e65 7874 2070 6173 730a  e the next pass.
+0000cce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ccf0: 2320 5468 6520 696e 7075 7420 7061 7468  # The input path
+0000cd00: 2069 7320 7468 6520 6f6e 626f 7264 6572   is the onborder
+0000cd10: 2066 696c 650a 2020 2020 2020 2020 2020   file.          
+0000cd20: 2020 2020 2020 7072 6576 5f6e 625f 6261        prev_nb_ba
+0000cd30: 7463 6865 7320 3d20 6c65 6e28 7469 6c65  tches = len(tile
+0000cd40: 735f 6764 6629 0a20 2020 2020 2020 2020  s_gdf).         
+0000cd50: 2020 2020 2020 2069 6e70 7574 5f70 6174         input_pat
+0000cd60: 6820 3d20 6f75 7470 7574 5f74 6d70 5f6f  h = output_tmp_o
+0000cd70: 6e62 6f72 6465 725f 7061 7468 0a20 2020  nborder_path.   
+0000cd80: 2020 2020 2020 2020 2020 2020 2070 6173               pas
+0000cd90: 735f 6964 202b 3d20 310a 2020 2020 2020  s_id += 1.      
+0000cda0: 2020 2020 2020 2020 2020 696e 7075 745f            input_
+0000cdb0: 7061 7373 5f6c 6179 6572 203d 204e 6f6e  pass_layer = Non
+0000cdc0: 650a 0a20 2020 2020 2020 2020 2020 2020  e..             
+0000cdd0: 2020 2023 2049 6620 7765 2061 7265 2072     # If we are r
+0000cde0: 6561 6479 2e2e 2e0a 2020 2020 2020 2020  eady....        
+0000cdf0: 2020 2020 2020 2020 6966 206c 6173 745f          if last_
+0000ce00: 7061 7373 2069 7320 5472 7565 3a0a 2020  pass is True:.  
+0000ce10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce20: 2020 6272 6561 6b0a 0a20 2020 2020 2020    break..       
+0000ce30: 2020 2020 2023 2043 616c 6375 6c61 7469       # Calculati
+0000ce40: 6f6e 2072 6561 6479 2120 4e6f 7720 6669  on ready! Now fi
+0000ce50: 6e61 6c69 7365 206f 7574 7075 7421 0a20  nalise output!. 
+0000ce60: 2020 2020 2020 2020 2020 206c 6f67 6765             logge
+0000ce70: 722e 696e 666f 2822 4669 6e61 6c69 7a65  r.info("Finalize
+0000ce80: 2072 6573 756c 7422 290a 2020 2020 2020   result").      
+0000ce90: 2020 2020 2020 2320 4966 2074 6865 7265        # If there
+0000cea0: 2069 7320 6120 7265 7375 6c74 206f 6e20   is a result on 
+0000ceb0: 626f 7264 6572 2c20 6170 7065 6e64 2069  border, append i
+0000cec0: 7420 746f 2074 6865 2072 6573 740a 2020  t to the rest.  
+0000ced0: 2020 2020 2020 2020 2020 6966 2028 0a20            if (. 
+0000cee0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000cef0: 7472 286f 7574 7075 745f 746d 705f 6f6e  tr(output_tmp_on
+0000cf00: 626f 7264 6572 5f70 6174 6829 2021 3d20  border_path) != 
+0000cf10: 7374 7228 6f75 7470 7574 5f74 6d70 5f70  str(output_tmp_p
+0000cf20: 6174 6829 0a20 2020 2020 2020 2020 2020  ath).           
+0000cf30: 2020 2020 2061 6e64 206f 7574 7075 745f       and output_
+0000cf40: 746d 705f 6f6e 626f 7264 6572 5f70 6174  tmp_onborder_pat
+0000cf50: 682e 6578 6973 7473 2829 0a20 2020 2020  h.exists().     
+0000cf60: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
+0000cf70: 2020 2020 2020 2020 2020 6766 6f2e 6170            gfo.ap
+0000cf80: 7065 6e64 5f74 6f28 0a20 2020 2020 2020  pend_to(.       
+0000cf90: 2020 2020 2020 2020 2020 2020 206f 7574               out
+0000cfa0: 7075 745f 746d 705f 6f6e 626f 7264 6572  put_tmp_onborder
+0000cfb0: 5f70 6174 682c 206f 7574 7075 745f 746d  _path, output_tm
+0000cfc0: 705f 7061 7468 2c20 6473 745f 6c61 7965  p_path, dst_laye
+0000cfd0: 723d 6f75 7470 7574 5f6c 6179 6572 0a20  r=output_layer. 
+0000cfe0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0000cff0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+0000d000: 4966 2074 6865 7265 2069 7320 6120 7265  If there is a re
+0000d010: 7375 6c74 2e2e 2e0a 2020 2020 2020 2020  sult....        
+0000d020: 2020 2020 6966 206f 7574 7075 745f 746d      if output_tm
+0000d030: 705f 7061 7468 2e65 7869 7374 7328 293a  p_path.exists():
+0000d040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d050: 2023 2049 6620 7469 6c65 6420 6f75 7470   # If tiled outp
+0000d060: 7574 2061 736b 6564 2c20 6164 6420 2274  ut asked, add "t
+0000d070: 696c 655f 6964 2220 746f 2067 726f 7570  ile_id" to group
+0000d080: 6279 5f63 6f6c 756d 6e73 0a20 2020 2020  by_columns.     
+0000d090: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
+0000d0a0: 6e28 7265 7375 6c74 5f74 696c 6573 5f67  n(result_tiles_g
+0000d0b0: 6466 2920 3e20 313a 0a20 2020 2020 2020  df) > 1:.       
+0000d0c0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000d0d0: 6772 6f75 7062 795f 636f 6c75 6d6e 7320  groupby_columns 
+0000d0e0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
 0000d0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d100: 2020 7469 6c65 735f 6764 663d 7469 6c65    tiles_gdf=tile
-0000d110: 735f 6764 662c 0d0a 2020 2020 2020 2020  s_gdf,..        
-0000d120: 2020 2020 2020 2020 2020 2020 696e 7075              inpu
-0000d130: 745f 6c61 7965 723d 696e 7075 745f 7061  t_layer=input_pa
-0000d140: 7373 5f6c 6179 6572 2c0d 0a20 2020 2020  ss_layer,..     
-0000d150: 2020 2020 2020 2020 2020 2020 2020 206f                 o
-0000d160: 7574 7075 745f 6c61 7965 723d 6f75 7470  utput_layer=outp
-0000d170: 7574 5f6c 6179 6572 2c0d 0a20 2020 2020  ut_layer,..     
-0000d180: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-0000d190: 7269 6473 697a 653d 6772 6964 7369 7a65  ridsize=gridsize
-0000d1a0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0000d1b0: 2020 2020 2020 206b 6565 705f 656d 7074         keep_empt
-0000d1c0: 795f 6765 6f6d 733d 4661 6c73 652c 0d0a  y_geoms=False,..
-0000d1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d1e0: 2020 2020 6e62 5f70 6172 616c 6c65 6c3d      nb_parallel=
-0000d1f0: 6e62 5f70 6172 616c 6c65 6c2c 0d0a 2020  nb_parallel,..  
-0000d200: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-0000d210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d220: 206c 6f67 6765 722e 696e 666f 2866 2250   logger.info(f"P
-0000d230: 6173 7320 7b70 6173 735f 6964 7d20 7265  ass {pass_id} re
-0000d240: 6164 792c 2074 6f6f 6b20 7b64 6174 6574  ady, took {datet
-0000d250: 696d 652e 6e6f 7728 292d 7061 7373 5f73  ime.now()-pass_s
-0000d260: 7461 7274 7d22 290d 0a0d 0a20 2020 2020  tart}")....     
-0000d270: 2020 2020 2020 2020 2020 2023 2050 7265             # Pre
-0000d280: 7061 7265 2074 6865 206e 6578 7420 7061  pare the next pa
-0000d290: 7373 0d0a 2020 2020 2020 2020 2020 2020  ss..            
-0000d2a0: 2020 2020 2320 5468 6520 696e 7075 7420      # The input 
-0000d2b0: 7061 7468 2069 7320 7468 6520 6f6e 626f  path is the onbo
-0000d2c0: 7264 6572 2066 696c 650d 0a20 2020 2020  rder file..     
-0000d2d0: 2020 2020 2020 2020 2020 2070 7265 765f             prev_
-0000d2e0: 6e62 5f62 6174 6368 6573 203d 206c 656e  nb_batches = len
-0000d2f0: 2874 696c 6573 5f67 6466 290d 0a20 2020  (tiles_gdf)..   
-0000d300: 2020 2020 2020 2020 2020 2020 2069 6e70               inp
-0000d310: 7574 5f70 6174 6820 3d20 6f75 7470 7574  ut_path = output
-0000d320: 5f74 6d70 5f6f 6e62 6f72 6465 725f 7061  _tmp_onborder_pa
-0000d330: 7468 0d0a 2020 2020 2020 2020 2020 2020  th..            
-0000d340: 2020 2020 7061 7373 5f69 6420 2b3d 2031      pass_id += 1
-0000d350: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000d360: 2020 696e 7075 745f 7061 7373 5f6c 6179    input_pass_lay
-0000d370: 6572 203d 204e 6f6e 650d 0a0d 0a20 2020  er = None....   
-0000d380: 2020 2020 2020 2020 2020 2020 2023 2049               # I
-0000d390: 6620 7765 2061 7265 2072 6561 6479 2e2e  f we are ready..
-0000d3a0: 2e0d 0a20 2020 2020 2020 2020 2020 2020  ...             
-0000d3b0: 2020 2069 6620 6c61 7374 5f70 6173 7320     if last_pass 
-0000d3c0: 6973 2054 7275 653a 0d0a 2020 2020 2020  is True:..      
-0000d3d0: 2020 2020 2020 2020 2020 2020 2020 6272                br
-0000d3e0: 6561 6b0d 0a0d 0a20 2020 2020 2020 2020  eak....         
-0000d3f0: 2020 2023 2043 616c 6375 6c61 7469 6f6e     # Calculation
-0000d400: 2072 6561 6479 2120 4e6f 7720 6669 6e61   ready! Now fina
-0000d410: 6c69 7365 206f 7574 7075 7421 0d0a 2020  lise output!..  
-0000d420: 2020 2020 2020 2020 2020 6c6f 6767 6572            logger
-0000d430: 2e69 6e66 6f28 2246 696e 616c 697a 6520  .info("Finalize 
-0000d440: 7265 7375 6c74 2229 0d0a 2020 2020 2020  result")..      
-0000d450: 2020 2020 2020 2320 4966 2074 6865 7265        # If there
-0000d460: 2069 7320 6120 7265 7375 6c74 206f 6e20   is a result on 
-0000d470: 626f 7264 6572 2c20 6170 7065 6e64 2069  border, append i
-0000d480: 7420 746f 2074 6865 2072 6573 740d 0a20  t to the rest.. 
-0000d490: 2020 2020 2020 2020 2020 2069 6620 280d             if (.
-0000d4a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d4b0: 2073 7472 286f 7574 7075 745f 746d 705f   str(output_tmp_
-0000d4c0: 6f6e 626f 7264 6572 5f70 6174 6829 2021  onborder_path) !
-0000d4d0: 3d20 7374 7228 6f75 7470 7574 5f74 6d70  = str(output_tmp
-0000d4e0: 5f70 6174 6829 0d0a 2020 2020 2020 2020  _path)..        
-0000d4f0: 2020 2020 2020 2020 616e 6420 6f75 7470          and outp
-0000d500: 7574 5f74 6d70 5f6f 6e62 6f72 6465 725f  ut_tmp_onborder_
-0000d510: 7061 7468 2e65 7869 7374 7328 290d 0a20  path.exists().. 
-0000d520: 2020 2020 2020 2020 2020 2029 3a0d 0a20             ):.. 
-0000d530: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-0000d540: 666f 2e61 7070 656e 645f 746f 280d 0a20  fo.append_to(.. 
-0000d550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d560: 2020 206f 7574 7075 745f 746d 705f 6f6e     output_tmp_on
-0000d570: 626f 7264 6572 5f70 6174 682c 206f 7574  border_path, out
-0000d580: 7075 745f 746d 705f 7061 7468 2c20 6473  put_tmp_path, ds
-0000d590: 745f 6c61 7965 723d 6f75 7470 7574 5f6c  t_layer=output_l
-0000d5a0: 6179 6572 0d0a 2020 2020 2020 2020 2020  ayer..          
-0000d5b0: 2020 2020 2020 290d 0a0d 0a20 2020 2020        )....     
-0000d5c0: 2020 2020 2020 2023 2049 6620 7468 6572         # If ther
-0000d5d0: 6520 6973 2061 2072 6573 756c 742e 2e2e  e is a result...
-0000d5e0: 0d0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-0000d5f0: 206f 7574 7075 745f 746d 705f 7061 7468   output_tmp_path
-0000d600: 2e65 7869 7374 7328 293a 0d0a 2020 2020  .exists():..    
-0000d610: 2020 2020 2020 2020 2020 2020 2320 4966              # If
-0000d620: 2074 696c 6564 206f 7574 7075 7420 6173   tiled output as
-0000d630: 6b65 642c 2061 6464 2022 7469 6c65 5f69  ked, add "tile_i
-0000d640: 6422 2074 6f20 6772 6f75 7062 795f 636f  d" to groupby_co
-0000d650: 6c75 6d6e 730d 0a20 2020 2020 2020 2020  lumns..         
-0000d660: 2020 2020 2020 2069 6620 6c65 6e28 7265         if len(re
-0000d670: 7375 6c74 5f74 696c 6573 5f67 6466 2920  sult_tiles_gdf) 
-0000d680: 3e20 313a 0d0a 2020 2020 2020 2020 2020  > 1:..          
-0000d690: 2020 2020 2020 2020 2020 6966 2067 726f            if gro
-0000d6a0: 7570 6279 5f63 6f6c 756d 6e73 2069 7320  upby_columns is 
-0000d6b0: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2020  None:..         
-0000d6c0: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-0000d6d0: 726f 7570 6279 5f63 6f6c 756d 6e73 203d  roupby_columns =
-0000d6e0: 205b 2274 696c 655f 6964 225d 0d0a 2020   ["tile_id"]..  
-0000d6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d700: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-0000d710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d720: 2067 726f 7570 6279 5f63 6f6c 756d 6e73   groupby_columns
-0000d730: 203d 206c 6973 7428 6772 6f75 7062 795f   = list(groupby_
-0000d740: 636f 6c75 6d6e 7329 2e63 6f70 7928 290d  columns).copy().
-0000d750: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d760: 2020 2020 2020 2020 2067 726f 7570 6279           groupby
-0000d770: 5f63 6f6c 756d 6e73 2e61 7070 656e 6428  _columns.append(
-0000d780: 2274 696c 655f 6964 2229 0d0a 0d0a 2020  "tile_id")....  
-0000d790: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000d7a0: 5072 6570 6172 6520 7374 7269 6e67 7320  Prepare strings 
-0000d7b0: 746f 2075 7365 2069 6e20 7365 6c65 6374  to use in select
-0000d7c0: 2062 6173 6564 206f 6e20 6772 6f75 7062   based on groupb
-0000d7d0: 795f 636f 6c75 6d6e 730d 0a20 2020 2020  y_columns..     
-0000d7e0: 2020 2020 2020 2020 2020 2069 6620 6772             if gr
-0000d7f0: 6f75 7062 795f 636f 6c75 6d6e 7320 6973  oupby_columns is
-0000d800: 206e 6f74 204e 6f6e 653a 0d0a 2020 2020   not None:..    
+0000d100: 2067 726f 7570 6279 5f63 6f6c 756d 6e73   groupby_columns
+0000d110: 203d 205b 2274 696c 655f 6964 225d 0a20   = ["tile_id"]. 
+0000d120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d130: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000d140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d150: 2067 726f 7570 6279 5f63 6f6c 756d 6e73   groupby_columns
+0000d160: 203d 206c 6973 7428 6772 6f75 7062 795f   = list(groupby_
+0000d170: 636f 6c75 6d6e 7329 2e63 6f70 7928 290a  columns).copy().
+0000d180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d190: 2020 2020 2020 2020 6772 6f75 7062 795f          groupby_
+0000d1a0: 636f 6c75 6d6e 732e 6170 7065 6e64 2822  columns.append("
+0000d1b0: 7469 6c65 5f69 6422 290a 0a20 2020 2020  tile_id")..     
+0000d1c0: 2020 2020 2020 2020 2020 2023 2050 7265             # Pre
+0000d1d0: 7061 7265 2073 7472 696e 6773 2074 6f20  pare strings to 
+0000d1e0: 7573 6520 696e 2073 656c 6563 7420 6261  use in select ba
+0000d1f0: 7365 6420 6f6e 2067 726f 7570 6279 5f63  sed on groupby_c
+0000d200: 6f6c 756d 6e73 0a20 2020 2020 2020 2020  olumns.         
+0000d210: 2020 2020 2020 2069 6620 6772 6f75 7062         if groupb
+0000d220: 795f 636f 6c75 6d6e 7320 6973 206e 6f74  y_columns is not
+0000d230: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0000d240: 2020 2020 2020 2020 2020 2067 726f 7570             group
+0000d250: 6279 5f70 7265 6669 7865 645f 6c69 7374  by_prefixed_list
+0000d260: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
+0000d270: 2020 2020 2020 2020 2020 2020 2066 277b               f'{
+0000d280: 7b70 7265 6669 787d 7d22 7b63 6f6c 756d  {prefix}}"{colum
+0000d290: 6e7d 2227 2066 6f72 2063 6f6c 756d 6e20  n}"' for column 
+0000d2a0: 696e 2067 726f 7570 6279 5f63 6f6c 756d  in groupby_colum
+0000d2b0: 6e73 0a20 2020 2020 2020 2020 2020 2020  ns.             
+0000d2c0: 2020 2020 2020 205d 0a20 2020 2020 2020         ].       
+0000d2d0: 2020 2020 2020 2020 2020 2020 2067 726f               gro
+0000d2e0: 7570 6279 5f73 656c 6563 745f 7072 6566  upby_select_pref
+0000d2f0: 6978 6564 5f73 7472 203d 2028 0a20 2020  ixed_str = (.   
+0000d300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d310: 2020 2020 2066 222c 207b 272c 2027 2e6a       f", {', '.j
+0000d320: 6f69 6e28 6772 6f75 7062 795f 7072 6566  oin(groupby_pref
+0000d330: 6978 6564 5f6c 6973 7429 7d22 0a20 2020  ixed_list)}".   
+0000d340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d350: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+0000d360: 2020 2020 2020 2067 726f 7570 6279 5f67         groupby_g
+0000d370: 726f 7570 6279 5f70 7265 6669 7865 645f  roupby_prefixed_
+0000d380: 7374 7220 3d20 280a 2020 2020 2020 2020  str = (.        
+0000d390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d3a0: 6622 4752 4f55 5020 4259 207b 272c 2027  f"GROUP BY {', '
+0000d3b0: 2e6a 6f69 6e28 6772 6f75 7062 795f 7072  .join(groupby_pr
+0000d3c0: 6566 6978 6564 5f6c 6973 7429 7d22 0a20  efixed_list)}". 
+0000d3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d3e0: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
+0000d3f0: 2020 2020 2020 2020 2020 6772 6f75 7062            groupb
+0000d400: 795f 6669 6c74 6572 5f6c 6973 7420 3d20  y_filter_list = 
+0000d410: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+0000d420: 2020 2020 2020 2020 2020 6627 2041 4e44            f' AND
+0000d430: 2067 656f 5f64 6174 612e 227b 636f 6c75   geo_data."{colu
+0000d440: 6d6e 7d22 203d 206a 736f 6e5f 6461 7461  mn}" = json_data
+0000d450: 2e22 7b63 6f6c 756d 6e7d 2227 0a20 2020  ."{column}"'.   
+0000d460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d470: 2020 2020 2066 6f72 2063 6f6c 756d 6e20       for column 
+0000d480: 696e 2067 726f 7570 6279 5f63 6f6c 756d  in groupby_colum
+0000d490: 6e73 0a20 2020 2020 2020 2020 2020 2020  ns.             
+0000d4a0: 2020 2020 2020 205d 0a20 2020 2020 2020         ].       
+0000d4b0: 2020 2020 2020 2020 2020 2020 2067 726f               gro
+0000d4c0: 7570 6279 5f66 696c 7465 725f 7374 7220  upby_filter_str 
+0000d4d0: 3d20 2220 222e 6a6f 696e 2867 726f 7570  = " ".join(group
+0000d4e0: 6279 5f66 696c 7465 725f 6c69 7374 290a  by_filter_list).
+0000d4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d500: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0000d510: 2020 2020 2020 2020 2020 6772 6f75 7062            groupb
+0000d520: 795f 7365 6c65 6374 5f70 7265 6669 7865  y_select_prefixe
+0000d530: 645f 7374 7220 3d20 2222 0a20 2020 2020  d_str = "".     
+0000d540: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+0000d550: 726f 7570 6279 5f67 726f 7570 6279 5f70  roupby_groupby_p
+0000d560: 7265 6669 7865 645f 7374 7220 3d20 2222  refixed_str = ""
+0000d570: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d580: 2020 2020 2067 726f 7570 6279 5f66 696c       groupby_fil
+0000d590: 7465 725f 7374 7220 3d20 2222 0a0a 2020  ter_str = ""..  
+0000d5a0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000d5b0: 5072 6570 6172 6520 7374 7269 6e67 7320  Prepare strings 
+0000d5c0: 746f 2075 7365 2069 6e20 7365 6c65 6374  to use in select
+0000d5d0: 2062 6173 6564 206f 6e20 6167 675f 636f   based on agg_co
+0000d5e0: 6c75 6d6e 730a 2020 2020 2020 2020 2020  lumns.          
+0000d5f0: 2020 2020 2020 6167 675f 636f 6c75 6d6e        agg_column
+0000d600: 735f 7374 7220 3d20 2222 0a20 2020 2020  s_str = "".     
+0000d610: 2020 2020 2020 2020 2020 2069 6620 6167             if ag
+0000d620: 675f 636f 6c75 6d6e 7320 6973 206e 6f74  g_columns is not
+0000d630: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0000d640: 2020 2020 2020 2020 2020 2069 6620 226a             if "j
+0000d650: 736f 6e22 2069 6e20 6167 675f 636f 6c75  son" in agg_colu
+0000d660: 6d6e 733a 0a20 2020 2020 2020 2020 2020  mns:.           
+0000d670: 2020 2020 2020 2020 2020 2020 2023 2054               # T
+0000d680: 6865 2061 6767 7265 6761 7469 6f6e 2069  he aggregation i
+0000d690: 7320 746f 2061 206a 736f 6e20 636f 6c75  s to a json colu
+0000d6a0: 6d6e 2c20 736f 2061 6464 0a20 2020 2020  mn, so add.     
+0000d6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6c0: 2020 2061 6767 5f63 6f6c 756d 6e73 5f73     agg_columns_s
+0000d6d0: 7472 202b 3d20 280a 2020 2020 2020 2020  tr += (.        
+0000d6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6f0: 2020 2020 222c 6a73 6f6e 5f67 726f 7570      ",json_group
+0000d700: 5f61 7272 6179 2844 4953 5449 4e43 5420  _array(DISTINCT 
+0000d710: 6a73 6f6e 5f64 6174 612e 6a73 6f6e 5f72  json_data.json_r
+0000d720: 6f77 2920 6173 206a 736f 6e22 0a20 2020  ow) as json".   
+0000d730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d740: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+0000d750: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
+0000d760: 2263 6f6c 756d 6e73 2220 696e 2061 6767  "columns" in agg
+0000d770: 5f63 6f6c 756d 6e73 3a0a 2020 2020 2020  _columns:.      
+0000d780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d790: 2020 666f 7220 6167 675f 636f 6c75 6d6e    for agg_column
+0000d7a0: 2069 6e20 6167 675f 636f 6c75 6d6e 735b   in agg_columns[
+0000d7b0: 2263 6f6c 756d 6e73 225d 3a0a 2020 2020  "columns"]:.    
+0000d7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d7d0: 2020 2020 2020 2020 2320 496e 6974 0a20          # Init. 
+0000d7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d7f0: 2020 2020 2020 2020 2020 2064 6973 7469             disti
+0000d800: 6e63 745f 7374 7220 3d20 2222 0a20 2020  nct_str = "".   
 0000d810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d820: 6772 6f75 7062 795f 7072 6566 6978 6564  groupby_prefixed
-0000d830: 5f6c 6973 7420 3d20 5b0d 0a20 2020 2020  _list = [..     
+0000d820: 2020 2020 2020 2020 2065 7874 7261 5f70           extra_p
+0000d830: 6172 616d 5f73 7472 203d 2022 220a 0a20  aram_str = "".. 
 0000d840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d850: 2020 2066 277b 7b70 7265 6669 787d 7d22     f'{{prefix}}"
-0000d860: 7b63 6f6c 756d 6e7d 2227 2066 6f72 2063  {column}"' for c
-0000d870: 6f6c 756d 6e20 696e 2067 726f 7570 6279  olumn in groupby
-0000d880: 5f63 6f6c 756d 6e73 0d0a 2020 2020 2020  _columns..      
-0000d890: 2020 2020 2020 2020 2020 2020 2020 5d0d                ].
-0000d8a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d8b0: 2020 2020 2067 726f 7570 6279 5f73 656c       groupby_sel
-0000d8c0: 6563 745f 7072 6566 6978 6564 5f73 7472  ect_prefixed_str
-0000d8d0: 203d 2028 0d0a 2020 2020 2020 2020 2020   = (..          
-0000d8e0: 2020 2020 2020 2020 2020 2020 2020 6622                f"
-0000d8f0: 2c20 7b27 2c20 272e 6a6f 696e 2867 726f  , {', '.join(gro
-0000d900: 7570 6279 5f70 7265 6669 7865 645f 6c69  upby_prefixed_li
-0000d910: 7374 297d 220d 0a20 2020 2020 2020 2020  st)}"..         
-0000d920: 2020 2020 2020 2020 2020 2029 0d0a 2020             )..  
+0000d850: 2020 2020 2020 2020 2020 2023 2050 7265             # Pre
+0000d860: 7061 7265 2061 6767 7265 6761 7469 6f6e  pare aggregation
+0000d870: 206b 6579 776f 7264 2e0a 2020 2020 2020   keyword..      
+0000d880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d890: 2020 2020 2020 6966 2061 6767 5f63 6f6c        if agg_col
+0000d8a0: 756d 6e5b 2261 6767 225d 2e6c 6f77 6572  umn["agg"].lower
+0000d8b0: 2829 2069 6e20 5b0a 2020 2020 2020 2020  () in [.        
+0000d8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8d0: 2020 2020 2020 2020 2263 6f75 6e74 222c          "count",
+0000d8e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d900: 2022 7375 6d22 2c0a 2020 2020 2020 2020   "sum",.        
+0000d910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d920: 2020 2020 2020 2020 226d 696e 222c 0a20          "min",. 
 0000d930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d940: 2020 6772 6f75 7062 795f 6772 6f75 7062    groupby_groupb
-0000d950: 795f 7072 6566 6978 6564 5f73 7472 203d  y_prefixed_str =
-0000d960: 2028 0d0a 2020 2020 2020 2020 2020 2020   (..            
-0000d970: 2020 2020 2020 2020 2020 2020 6622 4752              f"GR
-0000d980: 4f55 5020 4259 207b 272c 2027 2e6a 6f69  OUP BY {', '.joi
-0000d990: 6e28 6772 6f75 7062 795f 7072 6566 6978  n(groupby_prefix
-0000d9a0: 6564 5f6c 6973 7429 7d22 0d0a 2020 2020  ed_list)}"..    
-0000d9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d9c0: 290d 0a0d 0a20 2020 2020 2020 2020 2020  )....           
-0000d9d0: 2020 2020 2020 2020 2067 726f 7570 6279           groupby
-0000d9e0: 5f66 696c 7465 725f 6c69 7374 203d 205b  _filter_list = [
-0000d9f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000da00: 2020 2020 2020 2020 2020 6627 2041 4e44            f' AND
-0000da10: 2067 656f 5f64 6174 612e 227b 636f 6c75   geo_data."{colu
-0000da20: 6d6e 7d22 203d 206a 736f 6e5f 6461 7461  mn}" = json_data
-0000da30: 2e22 7b63 6f6c 756d 6e7d 2227 0d0a 2020  ."{column}"'..  
+0000d940: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000d950: 6d61 7822 2c0a 2020 2020 2020 2020 2020  max",.          
+0000d960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d970: 2020 2020 2020 226d 6564 6961 6e22 2c0a        "median",.
+0000d980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d990: 2020 2020 2020 2020 2020 2020 5d3a 0a20              ]:. 
+0000d9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d9b0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+0000d9c0: 6767 7265 6761 7469 6f6e 5f73 7472 203d  ggregation_str =
+0000d9d0: 2061 6767 5f63 6f6c 756d 6e5b 2261 6767   agg_column["agg
+0000d9e0: 225d 0a20 2020 2020 2020 2020 2020 2020  "].             
+0000d9f0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000da00: 6c69 6620 6167 675f 636f 6c75 6d6e 5b22  lif agg_column["
+0000da10: 6167 6722 5d2e 6c6f 7765 7228 2920 696e  agg"].lower() in
+0000da20: 205b 226d 6561 6e22 2c20 2261 7667 225d   ["mean", "avg"]
+0000da30: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
 0000da40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000da50: 2020 2020 2020 666f 7220 636f 6c75 6d6e        for column
-0000da60: 2069 6e20 6772 6f75 7062 795f 636f 6c75   in groupby_colu
-0000da70: 6d6e 730d 0a20 2020 2020 2020 2020 2020  mns..           
-0000da80: 2020 2020 2020 2020 205d 0d0a 2020 2020           ]..    
-0000da90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000daa0: 6772 6f75 7062 795f 6669 6c74 6572 5f73  groupby_filter_s
-0000dab0: 7472 203d 2022 2022 2e6a 6f69 6e28 6772  tr = " ".join(gr
-0000dac0: 6f75 7062 795f 6669 6c74 6572 5f6c 6973  oupby_filter_lis
-0000dad0: 7429 0d0a 2020 2020 2020 2020 2020 2020  t)..            
-0000dae0: 2020 2020 656c 7365 3a0d 0a20 2020 2020      else:..     
-0000daf0: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-0000db00: 726f 7570 6279 5f73 656c 6563 745f 7072  roupby_select_pr
-0000db10: 6566 6978 6564 5f73 7472 203d 2022 220d  efixed_str = "".
-0000db20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000db30: 2020 2020 2067 726f 7570 6279 5f67 726f       groupby_gro
-0000db40: 7570 6279 5f70 7265 6669 7865 645f 7374  upby_prefixed_st
-0000db50: 7220 3d20 2222 0d0a 2020 2020 2020 2020  r = ""..        
-0000db60: 2020 2020 2020 2020 2020 2020 6772 6f75              grou
-0000db70: 7062 795f 6669 6c74 6572 5f73 7472 203d  pby_filter_str =
-0000db80: 2022 220d 0a0d 0a20 2020 2020 2020 2020   ""....         
-0000db90: 2020 2020 2020 2023 2050 7265 7061 7265         # Prepare
-0000dba0: 2073 7472 696e 6773 2074 6f20 7573 6520   strings to use 
-0000dbb0: 696e 2073 656c 6563 7420 6261 7365 6420  in select based 
-0000dbc0: 6f6e 2061 6767 5f63 6f6c 756d 6e73 0d0a  on agg_columns..
+0000da50: 2020 6167 6772 6567 6174 696f 6e5f 7374    aggregation_st
+0000da60: 7220 3d20 2261 7667 220a 2020 2020 2020  r = "avg".      
+0000da70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da80: 2020 2020 2020 656c 6966 2061 6767 5f63        elif agg_c
+0000da90: 6f6c 756d 6e5b 2261 6767 225d 2e6c 6f77  olumn["agg"].low
+0000daa0: 6572 2829 203d 3d20 2263 6f6e 6361 7422  er() == "concat"
+0000dab0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000dac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dad0: 2020 6167 6772 6567 6174 696f 6e5f 7374    aggregation_st
+0000dae0: 7220 3d20 2267 726f 7570 5f63 6f6e 6361  r = "group_conca
+0000daf0: 7422 0a20 2020 2020 2020 2020 2020 2020  t".             
+0000db00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db10: 2020 2069 6620 2273 6570 2220 696e 2061     if "sep" in a
+0000db20: 6767 5f63 6f6c 756d 6e3a 0a20 2020 2020  gg_column:.     
+0000db30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db40: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000db50: 7874 7261 5f70 6172 616d 5f73 7472 203d  xtra_param_str =
+0000db60: 2066 222c 2027 7b61 6767 5f63 6f6c 756d   f", '{agg_colum
+0000db70: 6e5b 2773 6570 275d 7d27 220a 2020 2020  n['sep']}'".    
+0000db80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db90: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000dba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dbb0: 2020 2020 2020 2020 2020 2020 2020 7261                ra
+0000dbc0: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
 0000dbd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dbe0: 6167 675f 636f 6c75 6d6e 735f 7374 7220  agg_columns_str 
-0000dbf0: 3d20 2222 0d0a 2020 2020 2020 2020 2020  = ""..          
-0000dc00: 2020 2020 2020 6966 2061 6767 5f63 6f6c        if agg_col
-0000dc10: 756d 6e73 2069 7320 6e6f 7420 4e6f 6e65  umns is not None
-0000dc20: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000dc30: 2020 2020 2020 2069 6620 226a 736f 6e22         if "json"
-0000dc40: 2069 6e20 6167 675f 636f 6c75 6d6e 733a   in agg_columns:
-0000dc50: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000dc60: 2020 2020 2020 2020 2020 2320 5468 6520            # The 
-0000dc70: 6167 6772 6567 6174 696f 6e20 6973 2074  aggregation is t
-0000dc80: 6f20 6120 6a73 6f6e 2063 6f6c 756d 6e2c  o a json column,
-0000dc90: 2073 6f20 6164 640d 0a20 2020 2020 2020   so add..       
+0000dbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dbf0: 2020 2020 6622 6167 6772 6567 6174 696f      f"aggregatio
+0000dc00: 6e20 7b61 6767 5f63 6f6c 756d 6e5b 2761  n {agg_column['a
+0000dc10: 6767 275d 7d20 6973 206e 6f74 2073 7570  gg']} is not sup
+0000dc20: 706f 7274 6564 220a 2020 2020 2020 2020  ported".        
+0000dc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc40: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
+0000dc50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc60: 2020 2020 2020 2023 2049 6620 6469 7374         # If dist
+0000dc70: 696e 6374 2069 7320 7370 6563 6966 6965  inct is specifie
+0000dc80: 642c 2061 6464 2074 6865 2064 6973 7469  d, add the disti
+0000dc90: 6e63 7420 6b65 7977 6f72 640a 2020 2020  nct keyword.    
 0000dca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dcb0: 2061 6767 5f63 6f6c 756d 6e73 5f73 7472   agg_columns_str
-0000dcc0: 202b 3d20 280d 0a20 2020 2020 2020 2020   += (..         
-0000dcd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dce0: 2020 2022 2c6a 736f 6e5f 6772 6f75 705f     ",json_group_
-0000dcf0: 6172 7261 7928 4449 5354 494e 4354 206a  array(DISTINCT j
-0000dd00: 736f 6e5f 6461 7461 2e6a 736f 6e5f 726f  son_data.json_ro
-0000dd10: 7729 2061 7320 6a73 6f6e 220d 0a20 2020  w) as json"..   
-0000dd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd30: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-0000dd40: 2020 2020 2020 2020 2020 2020 656c 6966              elif
-0000dd50: 2022 636f 6c75 6d6e 7322 2069 6e20 6167   "columns" in ag
-0000dd60: 675f 636f 6c75 6d6e 733a 0d0a 2020 2020  g_columns:..    
-0000dd70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd80: 2020 2020 666f 7220 6167 675f 636f 6c75      for agg_colu
-0000dd90: 6d6e 2069 6e20 6167 675f 636f 6c75 6d6e  mn in agg_column
-0000dda0: 735b 2263 6f6c 756d 6e73 225d 3a0d 0a20  s["columns"]:.. 
-0000ddb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ddc0: 2020 2020 2020 2020 2020 2023 2049 6e69             # Ini
-0000ddd0: 740d 0a20 2020 2020 2020 2020 2020 2020  t..             
-0000dde0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-0000ddf0: 6973 7469 6e63 745f 7374 7220 3d20 2222  istinct_str = ""
-0000de00: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000de10: 2020 2020 2020 2020 2020 2020 2020 6578                ex
-0000de20: 7472 615f 7061 7261 6d5f 7374 7220 3d20  tra_param_str = 
-0000de30: 2222 0d0a 0d0a 2020 2020 2020 2020 2020  ""....          
+0000dcb0: 2020 2020 2020 2020 6966 2028 0a20 2020          if (.   
+0000dcc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dcd0: 2020 2020 2020 2020 2020 2020 2022 6469               "di
+0000dce0: 7374 696e 6374 2220 696e 2061 6767 5f63  stinct" in agg_c
+0000dcf0: 6f6c 756d 6e0a 2020 2020 2020 2020 2020  olumn.          
+0000dd00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd10: 2020 2020 2020 616e 6420 6167 675f 636f        and agg_co
+0000dd20: 6c75 6d6e 5b22 6469 7374 696e 6374 225d  lumn["distinct"]
+0000dd30: 2069 7320 5472 7565 0a20 2020 2020 2020   is True.       
+0000dd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd50: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
+0000dd60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd70: 2020 2020 2020 2020 6469 7374 696e 6374          distinct
+0000dd80: 5f73 7472 203d 2022 4449 5354 494e 4354  _str = "DISTINCT
+0000dd90: 2022 0a0a 2020 2020 2020 2020 2020 2020   "..            
+0000dda0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ddb0: 2320 5072 6570 6172 6520 636f 6c75 6d6e  # Prepare column
+0000ddc0: 206e 616d 6520 7374 7269 6e67 2e0a 2020   name string..  
+0000ddd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dde0: 2020 2020 2020 2020 2020 636f 6c75 6d6e            column
+0000ddf0: 5f73 7472 203d 2028 0a20 2020 2020 2020  _str = (.       
+0000de00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de10: 2020 2020 2020 2020 2022 6a73 6f6e 5f65           "json_e
+0000de20: 7874 7261 6374 286a 736f 6e5f 6461 7461  xtract(json_data
+0000de30: 2e6a 736f 6e5f 726f 772c 2022 0a20 2020  .json_row, ".   
 0000de40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de50: 2020 2320 5072 6570 6172 6520 6167 6772    # Prepare aggr
-0000de60: 6567 6174 696f 6e20 6b65 7977 6f72 642e  egation keyword.
-0000de70: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000de80: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000de90: 2061 6767 5f63 6f6c 756d 6e5b 2261 6767   agg_column["agg
-0000dea0: 225d 2e6c 6f77 6572 2829 2069 6e20 5b0d  "].lower() in [.
-0000deb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000dec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ded0: 2022 636f 756e 7422 2c0d 0a20 2020 2020   "count",..     
+0000de50: 2020 2020 2020 2020 2020 2020 2066 2722               f'"
+0000de60: 242e 7b61 6767 5f63 6f6c 756d 6e5b 2263  $.{agg_column["c
+0000de70: 6f6c 756d 6e22 5d7d 2229 270a 2020 2020  olumn"]}")'.    
+0000de80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de90: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
+0000dea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000deb0: 2020 2020 2020 2023 204e 6f77 2070 7574         # Now put
+0000dec0: 2065 7665 7279 7468 696e 6720 746f 6765   everything toge
+0000ded0: 7468 6572 0a20 2020 2020 2020 2020 2020  ther.           
 0000dee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000def0: 2020 2020 2020 2020 2020 2022 7375 6d22             "sum"
-0000df00: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
+0000def0: 2061 6767 5f63 6f6c 756d 6e73 5f73 7472   agg_columns_str
+0000df00: 202b 3d20 280a 2020 2020 2020 2020 2020   += (.          
 0000df10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df20: 2020 2022 6d69 6e22 2c0d 0a20 2020 2020     "min",..     
-0000df30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df40: 2020 2020 2020 2020 2020 2022 6d61 7822             "max"
-0000df50: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
+0000df20: 2020 2020 2020 6622 2c20 7b61 6767 7265        f", {aggre
+0000df30: 6761 7469 6f6e 5f73 7472 7d28 7b64 6973  gation_str}({dis
+0000df40: 7469 6e63 745f 7374 727d 7b63 6f6c 756d  tinct_str}{colum
+0000df50: 6e5f 7374 727d 220a 2020 2020 2020 2020  n_str}".        
 0000df60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df70: 2020 2022 6d65 6469 616e 222c 0d0a 2020     "median",..  
-0000df80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df90: 2020 2020 2020 2020 2020 5d3a 0d0a 2020            ]:..  
-0000dfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dfb0: 2020 2020 2020 2020 2020 2020 2020 6167                ag
-0000dfc0: 6772 6567 6174 696f 6e5f 7374 7220 3d20  gregation_str = 
-0000dfd0: 6167 675f 636f 6c75 6d6e 5b22 6167 6722  agg_column["agg"
-0000dfe0: 5d0d 0a20 2020 2020 2020 2020 2020 2020  ]..             
-0000dff0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-0000e000: 6c69 6620 6167 675f 636f 6c75 6d6e 5b22  lif agg_column["
-0000e010: 6167 6722 5d2e 6c6f 7765 7228 2920 696e  agg"].lower() in
-0000e020: 205b 226d 6561 6e22 2c20 2261 7667 225d   ["mean", "avg"]
-0000e030: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000e040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e050: 2020 2061 6767 7265 6761 7469 6f6e 5f73     aggregation_s
-0000e060: 7472 203d 2022 6176 6722 0d0a 2020 2020  tr = "avg"..    
-0000e070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e080: 2020 2020 2020 2020 656c 6966 2061 6767          elif agg
-0000e090: 5f63 6f6c 756d 6e5b 2261 6767 225d 2e6c  _column["agg"].l
-0000e0a0: 6f77 6572 2829 203d 3d20 2263 6f6e 6361  ower() == "conca
-0000e0b0: 7422 3a0d 0a20 2020 2020 2020 2020 2020  t":..           
-0000e0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e0d0: 2020 2020 2061 6767 7265 6761 7469 6f6e       aggregation
-0000e0e0: 5f73 7472 203d 2022 6772 6f75 705f 636f  _str = "group_co
-0000e0f0: 6e63 6174 220d 0a20 2020 2020 2020 2020  ncat"..         
-0000e100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e110: 2020 2020 2020 2069 6620 2273 6570 2220         if "sep" 
-0000e120: 696e 2061 6767 5f63 6f6c 756d 6e3a 0d0a  in agg_column:..
-0000e130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e150: 2020 2020 6578 7472 615f 7061 7261 6d5f      extra_param_
-0000e160: 7374 7220 3d20 6622 2c20 277b 6167 675f  str = f", '{agg_
-0000e170: 636f 6c75 6d6e 5b27 7365 7027 5d7d 2722  column['sep']}'"
-0000e180: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000e190: 2020 2020 2020 2020 2020 2020 2020 656c                el
-0000e1a0: 7365 3a0d 0a20 2020 2020 2020 2020 2020  se:..           
-0000e1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e1c0: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-0000e1d0: 4572 726f 7228 0d0a 2020 2020 2020 2020  Error(..        
-0000e1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e1f0: 2020 2020 2020 2020 2020 2020 6622 6167              f"ag
-0000e200: 6772 6567 6174 696f 6e20 7b61 6767 5f63  gregation {agg_c
-0000e210: 6f6c 756d 6e5b 2761 6767 275d 7d20 6973  olumn['agg']} is
-0000e220: 206e 6f74 2073 7570 706f 7274 6564 220d   not supported".
-0000e230: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e250: 2029 0d0a 0d0a 2020 2020 2020 2020 2020   )....          
-0000e260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e270: 2020 2320 4966 2064 6973 7469 6e63 7420    # If distinct 
-0000e280: 6973 2073 7065 6369 6669 6564 2c20 6164  is specified, ad
-0000e290: 6420 7468 6520 6469 7374 696e 6374 206b  d the distinct k
-0000e2a0: 6579 776f 7264 0d0a 2020 2020 2020 2020  eyword..        
-0000e2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e2c0: 2020 2020 6966 2028 0d0a 2020 2020 2020      if (..      
-0000e2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e2e0: 2020 2020 2020 2020 2020 2264 6973 7469            "disti
-0000e2f0: 6e63 7422 2069 6e20 6167 675f 636f 6c75  nct" in agg_colu
-0000e300: 6d6e 0d0a 2020 2020 2020 2020 2020 2020  mn..            
-0000e310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e320: 2020 2020 616e 6420 6167 675f 636f 6c75      and agg_colu
-0000e330: 6d6e 5b22 6469 7374 696e 6374 225d 2069  mn["distinct"] i
-0000e340: 7320 5472 7565 0d0a 2020 2020 2020 2020  s True..        
-0000e350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e360: 2020 2020 293a 0d0a 2020 2020 2020 2020      ):..        
+0000df70: 2020 2020 2020 2020 6627 7b65 7874 7261          f'{extra
+0000df80: 5f70 6172 616d 5f73 7472 7d29 2041 5320  _param_str}) AS 
+0000df90: 227b 6167 675f 636f 6c75 6d6e 5b22 6173  "{agg_column["as
+0000dfa0: 225d 7d22 270a 2020 2020 2020 2020 2020  "]}"'.          
+0000dfb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dfc0: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
+0000dfd0: 2020 2020 2023 2041 6464 2061 2063 6f6c       # Add a col
+0000dfe0: 756d 6e20 746f 206f 7264 6572 2074 6865  umn to order the
+0000dff0: 2072 6573 756c 7420 6279 2074 6f20 6176   result by to av
+0000e000: 6f69 6420 6861 7669 6e67 2061 6c6c 0a20  oid having all. 
+0000e010: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000e020: 2063 6f6d 706c 6578 2067 656f 6d65 7472   complex geometr
+0000e030: 6965 7320 746f 6765 7468 6572 2069 6e20  ies together in 
+0000e040: 7468 6520 6f75 7470 7574 2066 696c 652e  the output file.
+0000e050: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e060: 206f 7264 6572 6279 5f63 6f6c 756d 6e20   orderby_column 
+0000e070: 3d20 2274 656d 705f 6f72 6465 7263 6f6c  = "temp_ordercol
+0000e080: 756d 6e5f 6765 6f68 6173 6822 0a20 2020  umn_geohash".   
+0000e090: 2020 2020 2020 2020 2020 2020 205f 6164               _ad
+0000e0a0: 645f 6f72 6465 7262 795f 636f 6c75 6d6e  d_orderby_column
+0000e0b0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000e0c0: 2020 2020 2020 7061 7468 3d6f 7574 7075        path=outpu
+0000e0d0: 745f 746d 705f 7061 7468 2c20 6c61 7965  t_tmp_path, laye
+0000e0e0: 723d 6f75 7470 7574 5f6c 6179 6572 2c20  r=output_layer, 
+0000e0f0: 6e61 6d65 3d6f 7264 6572 6279 5f63 6f6c  name=orderby_col
+0000e100: 756d 6e0a 2020 2020 2020 2020 2020 2020  umn.            
+0000e110: 2020 2020 290a 0a20 2020 2020 2020 2020      )..         
+0000e120: 2020 2020 2020 2023 2050 7265 7061 7265         # Prepare
+0000e130: 2053 514c 2073 7461 7465 6d65 6e74 2066   SQL statement f
+0000e140: 6f72 2066 696e 616c 206f 7574 7075 7420  or final output 
+0000e150: 6669 6c65 2e0a 2020 2020 2020 2020 2020  file..          
+0000e160: 2020 2020 2020 2320 416c 6c20 7469 6c65        # All tile
+0000e170: 7320 6172 6520 616c 7265 6164 7920 6469  s are already di
+0000e180: 7373 6f6c 7665 6420 746f 2067 726f 7570  ssolved to group
+0000e190: 732c 2062 7574 206e 6f77 2074 6865 0a20  s, but now the. 
+0000e1a0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000e1b0: 2072 6573 756c 7473 2066 726f 6d20 616c   results from al
+0000e1c0: 6c20 7469 6c65 7320 7374 696c 6c20 6e65  l tiles still ne
+0000e1d0: 6564 2074 6f20 6265 0a20 2020 2020 2020  ed to be.       
+0000e1e0: 2020 2020 2020 2020 2023 2067 726f 7570           # group
+0000e1f0: 6564 2f63 6f6c 6c65 6374 6564 2074 6f67  ed/collected tog
+0000e200: 6574 6865 722e 0a20 2020 2020 2020 2020  ether..         
+0000e210: 2020 2020 2020 2069 6620 6167 675f 636f         if agg_co
+0000e220: 6c75 6d6e 7320 6973 204e 6f6e 653a 0a20  lumns is None:. 
+0000e230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e240: 2020 2023 2049 6620 7468 6572 6520 6172     # If there ar
+0000e250: 6520 6e6f 2061 6767 7265 6761 7469 6f6e  e no aggregation
+0000e260: 2063 6f6c 756d 6e73 2c20 7468 696e 6773   columns, things
+0000e270: 2061 7265 206e 6f74 2074 6f6f 0a20 2020   are not too.   
+0000e280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e290: 2023 2063 6f6d 706c 6963 6174 6564 2e0a   # complicated..
+0000e2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e2b0: 2020 2020 6966 2065 7870 6c6f 6465 636f      if explodeco
+0000e2c0: 6c6c 6563 7469 6f6e 7320 6973 2054 7275  llections is Tru
+0000e2d0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000e2e0: 2020 2020 2020 2020 2020 2023 2049 6620             # If 
+0000e2f0: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
+0000e300: 6e73 2069 7320 7472 7565 2c20 6974 2069  ns is true, it i
+0000e310: 7320 7573 656c 6573 7320 746f 0a20 2020  s useless to.   
+0000e320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e330: 2020 2020 2023 2066 6972 7374 2067 726f       # first gro
+0000e340: 7570 2074 6865 6d20 6865 7265 2c20 6173  up them here, as
+0000e350: 2074 6865 7920 7769 6c6c 2062 6520 6578   they will be ex
+0000e360: 706c 6f64 6564 2061 6761 696e 0a20 2020  ploded again.   
 0000e370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e380: 2020 2020 2020 2020 6469 7374 696e 6374          distinct
-0000e390: 5f73 7472 203d 2022 4449 5354 494e 4354  _str = "DISTINCT
-0000e3a0: 2022 0d0a 0d0a 2020 2020 2020 2020 2020   "....          
-0000e3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e3c0: 2020 2320 5072 6570 6172 6520 636f 6c75    # Prepare colu
-0000e3d0: 6d6e 206e 616d 6520 7374 7269 6e67 2e0d  mn name string..
-0000e3e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e3f0: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
-0000e400: 756d 6e5f 7374 7220 3d20 280d 0a20 2020  umn_str = (..   
-0000e410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e420: 2020 2020 2020 2020 2020 2020 2022 6a73               "js
-0000e430: 6f6e 5f65 7874 7261 6374 286a 736f 6e5f  on_extract(json_
-0000e440: 6461 7461 2e6a 736f 6e5f 726f 772c 2022  data.json_row, "
-0000e450: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000e460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e470: 2020 6627 2224 2e7b 6167 675f 636f 6c75    f'"$.{agg_colu
-0000e480: 6d6e 5b22 636f 6c75 6d6e 225d 7d22 2927  mn["column"]}")'
-0000e490: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000e4a0: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-0000e4b0: 0a0d 0a20 2020 2020 2020 2020 2020 2020  ...             
-0000e4c0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000e4d0: 204e 6f77 2070 7574 2065 7665 7279 7468   Now put everyth
-0000e4e0: 696e 6720 746f 6765 7468 6572 0d0a 2020  ing together..  
-0000e4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e500: 2020 2020 2020 2020 2020 6167 675f 636f            agg_co
-0000e510: 6c75 6d6e 735f 7374 7220 2b3d 2028 0d0a  lumns_str += (..
-0000e520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e540: 6622 2c20 7b61 6767 7265 6761 7469 6f6e  f", {aggregation
-0000e550: 5f73 7472 7d28 7b64 6973 7469 6e63 745f  _str}({distinct_
-0000e560: 7374 727d 7b63 6f6c 756d 6e5f 7374 727d  str}{column_str}
-0000e570: 220d 0a20 2020 2020 2020 2020 2020 2020  "..             
-0000e580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e590: 2020 2066 277b 6578 7472 615f 7061 7261     f'{extra_para
-0000e5a0: 6d5f 7374 727d 2920 4153 2022 7b61 6767  m_str}) AS "{agg
-0000e5b0: 5f63 6f6c 756d 6e5b 2261 7322 5d7d 2227  _column["as"]}"'
-0000e5c0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000e5d0: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-0000e5e0: 0a0d 0a20 2020 2020 2020 2020 2020 2020  ...             
-0000e5f0: 2020 2023 2041 6464 2061 2063 6f6c 756d     # Add a colum
-0000e600: 6e20 746f 206f 7264 6572 2074 6865 2072  n to order the r
-0000e610: 6573 756c 7420 6279 2074 6f20 6176 6f69  esult by to avoi
-0000e620: 6420 6861 7669 6e67 2061 6c6c 0d0a 2020  d having all..  
-0000e630: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000e640: 636f 6d70 6c65 7820 6765 6f6d 6574 7269  complex geometri
-0000e650: 6573 2074 6f67 6574 6865 7220 696e 2074  es together in t
-0000e660: 6865 206f 7574 7075 7420 6669 6c65 2e0d  he output file..
-0000e670: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e680: 206f 7264 6572 6279 5f63 6f6c 756d 6e20   orderby_column 
-0000e690: 3d20 2274 656d 705f 6f72 6465 7263 6f6c  = "temp_ordercol
-0000e6a0: 756d 6e5f 6765 6f68 6173 6822 0d0a 2020  umn_geohash"..  
-0000e6b0: 2020 2020 2020 2020 2020 2020 2020 5f61                _a
-0000e6c0: 6464 5f6f 7264 6572 6279 5f63 6f6c 756d  dd_orderby_colum
-0000e6d0: 6e28 0d0a 2020 2020 2020 2020 2020 2020  n(..            
-0000e6e0: 2020 2020 2020 2020 7061 7468 3d6f 7574          path=out
-0000e6f0: 7075 745f 746d 705f 7061 7468 2c20 6c61  put_tmp_path, la
-0000e700: 7965 723d 6f75 7470 7574 5f6c 6179 6572  yer=output_layer
-0000e710: 2c20 6e61 6d65 3d6f 7264 6572 6279 5f63  , name=orderby_c
-0000e720: 6f6c 756d 6e0d 0a20 2020 2020 2020 2020  olumn..         
-0000e730: 2020 2020 2020 2029 0d0a 0d0a 2020 2020         )....    
-0000e740: 2020 2020 2020 2020 2020 2020 2320 5072              # Pr
-0000e750: 6570 6172 6520 5351 4c20 7374 6174 656d  epare SQL statem
-0000e760: 656e 7420 666f 7220 6669 6e61 6c20 6f75  ent for final ou
-0000e770: 7470 7574 2066 696c 652e 0d0a 2020 2020  tput file...    
-0000e780: 2020 2020 2020 2020 2020 2020 2320 416c              # Al
-0000e790: 6c20 7469 6c65 7320 6172 6520 616c 7265  l tiles are alre
-0000e7a0: 6164 7920 6469 7373 6f6c 7665 6420 746f  ady dissolved to
-0000e7b0: 2067 726f 7570 732c 2062 7574 206e 6f77   groups, but now
-0000e7c0: 2074 6865 0d0a 2020 2020 2020 2020 2020   the..          
-0000e7d0: 2020 2020 2020 2320 7265 7375 6c74 7320        # results 
-0000e7e0: 6672 6f6d 2061 6c6c 2074 696c 6573 2073  from all tiles s
-0000e7f0: 7469 6c6c 206e 6565 6420 746f 2062 650d  till need to be.
-0000e800: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e810: 2023 2067 726f 7570 6564 2f63 6f6c 6c65   # grouped/colle
-0000e820: 6374 6564 2074 6f67 6574 6865 722e 0d0a  cted together...
-0000e830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e840: 6966 2061 6767 5f63 6f6c 756d 6e73 2069  if agg_columns i
-0000e850: 7320 4e6f 6e65 3a0d 0a20 2020 2020 2020  s None:..       
-0000e860: 2020 2020 2020 2020 2020 2020 2023 2049               # I
-0000e870: 6620 7468 6572 6520 6172 6520 6e6f 2061  f there are no a
-0000e880: 6767 7265 6761 7469 6f6e 2063 6f6c 756d  ggregation colum
-0000e890: 6e73 2c20 7468 696e 6773 2061 7265 206e  ns, things are n
-0000e8a0: 6f74 2074 6f6f 0d0a 2020 2020 2020 2020  ot too..        
-0000e8b0: 2020 2020 2020 2020 2020 2020 2320 636f              # co
-0000e8c0: 6d70 6c69 6361 7465 642e 0d0a 2020 2020  mplicated...    
-0000e8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e8e0: 6966 2065 7870 6c6f 6465 636f 6c6c 6563  if explodecollec
-0000e8f0: 7469 6f6e 7320 6973 2054 7275 653a 0d0a  tions is True:..
-0000e900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e910: 2020 2020 2020 2020 2320 4966 2065 7870          # If exp
-0000e920: 6c6f 6465 636f 6c6c 6563 7469 6f6e 7320  lodecollections 
-0000e930: 6973 2074 7275 652c 2069 7420 6973 2075  is true, it is u
-0000e940: 7365 6c65 7373 2074 6f0d 0a20 2020 2020  seless to..     
-0000e950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e960: 2020 2023 2066 6972 7374 2067 726f 7570     # first group
-0000e970: 2074 6865 6d20 6865 7265 2c20 6173 2074   them here, as t
-0000e980: 6865 7920 7769 6c6c 2062 6520 6578 706c  hey will be expl
-0000e990: 6f64 6564 2061 6761 696e 0d0a 2020 2020  oded again..    
-0000e9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e9b0: 2020 2020 2320 696e 2074 6865 2073 656c      # in the sel
-0000e9c0: 6563 7428 2920 6361 6c6c 206c 6174 6572  ect() call later
-0000e9d0: 206f 6e2e 2e2e 2073 6f20 6a75 7374 206f   on... so just o
-0000e9e0: 7264 6572 2074 6865 6d2e 0d0a 2020 2020  rder them...    
-0000e9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ea00: 2020 2020 2320 4966 2061 2074 696c 6564      # If a tiled
-0000ea10: 2072 6573 756c 7420 6973 2061 736b 6564   result is asked
-0000ea20: 2c20 616c 736f 2064 6f6e 2774 2063 6f6c  , also don't col
-0000ea30: 6c65 6374 2e0d 0a20 2020 2020 2020 2020  lect...         
-0000ea40: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000ea50: 716c 5f73 746d 7420 3d20 6622 2222 0d0a  ql_stmt = f"""..
-0000ea60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ea70: 2020 2020 2020 2020 2020 2020 5345 4c45              SELE
-0000ea80: 4354 207b 7b67 656f 6d65 7472 7963 6f6c  CT {{geometrycol
-0000ea90: 756d 6e7d 7d0d 0a20 2020 2020 2020 2020  umn}}..         
-0000eaa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eab0: 2020 2020 2020 2020 207b 6772 6f75 7062           {groupb
-0000eac0: 795f 7365 6c65 6374 5f70 7265 6669 7865  y_select_prefixe
-0000ead0: 645f 7374 722e 666f 726d 6174 2870 7265  d_str.format(pre
-0000eae0: 6669 783d 226c 6179 6572 2e22 297d 0d0a  fix="layer.")}..
-0000eaf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eb00: 2020 2020 2020 2020 2020 2020 2020 4652                FR
-0000eb10: 4f4d 2022 7b7b 696e 7075 745f 6c61 7965  OM "{{input_laye
-0000eb20: 727d 7d22 206c 6179 6572 0d0a 2020 2020  r}}" layer..    
-0000eb30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eb40: 2020 2020 2020 2020 204f 5244 4552 2042           ORDER B
-0000eb50: 5920 6c61 7965 722e 7b6f 7264 6572 6279  Y layer.{orderby
-0000eb60: 5f63 6f6c 756d 6e7d 0d0a 2020 2020 2020  _column}..      
-0000eb70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eb80: 2020 2222 220d 0a20 2020 2020 2020 2020    """..         
-0000eb90: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0000eba0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000ebb0: 2020 2020 2020 2020 2020 2320 4e6f 2065            # No e
-0000ebc0: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
-0000ebd0: 732c 2073 6f20 636f 6c6c 6563 7420 746f  s, so collect to
-0000ebe0: 206f 6e65 2067 656f 6d65 7472 790d 0a20   one geometry.. 
-0000ebf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec00: 2020 2020 2020 2023 2028 7065 7220 6772         # (per gr
-0000ec10: 6f75 7062 7920 6966 2061 7070 6c69 6361  oupby if applica
-0000ec20: 626c 6529 2e0d 0a20 2020 2020 2020 2020  ble)...         
-0000ec30: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000ec40: 716c 5f73 746d 7420 3d20 6622 2222 0d0a  ql_stmt = f"""..
+0000e380: 2020 2020 2023 2069 6e20 7468 6520 7365       # in the se
+0000e390: 6c65 6374 2829 2063 616c 6c20 6c61 7465  lect() call late
+0000e3a0: 7220 6f6e 2e2e 2e20 736f 206a 7573 7420  r on... so just 
+0000e3b0: 6f72 6465 7220 7468 656d 2e0a 2020 2020  order them..    
+0000e3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e3d0: 2020 2020 2320 4966 2061 2074 696c 6564      # If a tiled
+0000e3e0: 2072 6573 756c 7420 6973 2061 736b 6564   result is asked
+0000e3f0: 2c20 616c 736f 2064 6f6e 2774 2063 6f6c  , also don't col
+0000e400: 6c65 6374 2e0a 2020 2020 2020 2020 2020  lect..          
+0000e410: 2020 2020 2020 2020 2020 2020 2020 7371                sq
+0000e420: 6c5f 7374 6d74 203d 2066 2222 220a 2020  l_stmt = f""".  
+0000e430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e440: 2020 2020 2020 2020 2020 5345 4c45 4354            SELECT
+0000e450: 207b 7b67 656f 6d65 7472 7963 6f6c 756d   {{geometrycolum
+0000e460: 6e7d 7d0a 2020 2020 2020 2020 2020 2020  n}}.            
+0000e470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e480: 2020 2020 2020 7b67 726f 7570 6279 5f73        {groupby_s
+0000e490: 656c 6563 745f 7072 6566 6978 6564 5f73  elect_prefixed_s
+0000e4a0: 7472 2e66 6f72 6d61 7428 7072 6566 6978  tr.format(prefix
+0000e4b0: 3d22 6c61 7965 722e 2229 7d0a 2020 2020  ="layer.")}.    
+0000e4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e4d0: 2020 2020 2020 2020 2020 4652 4f4d 2022            FROM "
+0000e4e0: 7b7b 696e 7075 745f 6c61 7965 727d 7d22  {{input_layer}}"
+0000e4f0: 206c 6179 6572 0a20 2020 2020 2020 2020   layer.         
+0000e500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e510: 2020 2020 4f52 4445 5220 4259 206c 6179      ORDER BY lay
+0000e520: 6572 2e7b 6f72 6465 7262 795f 636f 6c75  er.{orderby_colu
+0000e530: 6d6e 7d0a 2020 2020 2020 2020 2020 2020  mn}.            
+0000e540: 2020 2020 2020 2020 2020 2020 2222 220a              """.
+0000e550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e560: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000e570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e580: 2020 2320 4e6f 2065 7870 6c6f 6465 636f    # No explodeco
+0000e590: 6c6c 6563 7469 6f6e 732c 2073 6f20 636f  llections, so co
+0000e5a0: 6c6c 6563 7420 746f 206f 6e65 2067 656f  llect to one geo
+0000e5b0: 6d65 7472 790a 2020 2020 2020 2020 2020  metry.          
+0000e5c0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000e5d0: 2870 6572 2067 726f 7570 6279 2069 6620  (per groupby if 
+0000e5e0: 6170 706c 6963 6162 6c65 292e 0a20 2020  applicable)..   
+0000e5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e600: 2020 2020 2073 716c 5f73 746d 7420 3d20       sql_stmt = 
+0000e610: 6622 2222 0a20 2020 2020 2020 2020 2020  f""".           
+0000e620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e630: 2053 454c 4543 5420 5354 5f43 6f6c 6c65   SELECT ST_Colle
+0000e640: 6374 287b 7b67 656f 6d65 7472 7963 6f6c  ct({{geometrycol
+0000e650: 756d 6e7d 7d29 2041 5320 7b7b 6765 6f6d  umn}}) AS {{geom
+0000e660: 6574 7279 636f 6c75 6d6e 7d7d 0a20 2020  etrycolumn}}.   
+0000e670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e680: 2020 2020 2020 2020 2020 2020 2020 207b                 {
+0000e690: 6772 6f75 7062 795f 7365 6c65 6374 5f70  groupby_select_p
+0000e6a0: 7265 6669 7865 645f 7374 722e 666f 726d  refixed_str.form
+0000e6b0: 6174 2870 7265 6669 783d 226c 6179 6572  at(prefix="layer
+0000e6c0: 2e22 297d 0a20 2020 2020 2020 2020 2020  .")}.           
+0000e6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e6e0: 2020 2046 524f 4d20 227b 7b69 6e70 7574     FROM "{{input
+0000e6f0: 5f6c 6179 6572 7d7d 2220 6c61 7965 720a  _layer}}" layer.
+0000e700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e710: 2020 2020 2020 2020 2020 2020 2020 7b67                {g
+0000e720: 726f 7570 6279 5f67 726f 7570 6279 5f70  roupby_groupby_p
+0000e730: 7265 6669 7865 645f 7374 722e 666f 726d  refixed_str.form
+0000e740: 6174 2870 7265 6669 783d 226c 6179 6572  at(prefix="layer
+0000e750: 2e22 297d 0a20 2020 2020 2020 2020 2020  .")}.           
+0000e760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e770: 2020 4f52 4445 5220 4259 204d 494e 286c    ORDER BY MIN(l
+0000e780: 6179 6572 2e7b 6f72 6465 7262 795f 636f  ayer.{orderby_co
+0000e790: 6c75 6d6e 7d29 0a20 2020 2020 2020 2020  lumn}).         
+0000e7a0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000e7b0: 2222 0a20 2020 2020 2020 2020 2020 2020  "".             
+0000e7c0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000e7d0: 2020 2020 2020 2020 2020 2020 2023 2049               # I
+0000e7e0: 6620 6167 675f 636f 6c75 6d6e 7320 7370  f agg_columns sp
+0000e7f0: 6563 6966 6965 642c 2070 6f73 7470 726f  ecified, postpro
+0000e800: 6365 7373 696e 6720 6973 2061 2062 6974  cessing is a bit
+0000e810: 206d 6f72 650a 2020 2020 2020 2020 2020   more.          
+0000e820: 2020 2020 2020 2020 2020 2320 636f 6d70            # comp
+0000e830: 6c69 6361 7465 642e 0a20 2020 2020 2020  licated..       
+0000e840: 2020 2020 2020 2020 2020 2020 2073 716c               sql
+0000e850: 5f73 746d 7420 3d20 6622 2222 0a20 2020  _stmt = f""".   
+0000e860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e870: 2020 2020 2053 454c 4543 5420 6765 6f5f       SELECT geo_
+0000e880: 6461 7461 2e7b 7b67 656f 6d65 7472 7963  data.{{geometryc
+0000e890: 6f6c 756d 6e7d 7d0a 2020 2020 2020 2020  olumn}}.        
+0000e8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e8b0: 2020 2020 2020 7b67 726f 7570 6279 5f73        {groupby_s
+0000e8c0: 656c 6563 745f 7072 6566 6978 6564 5f73  elect_prefixed_s
+0000e8d0: 7472 2e66 6f72 6d61 7428 7072 6566 6978  tr.format(prefix
+0000e8e0: 3d22 6765 6f5f 6461 7461 2e22 297d 0a20  ="geo_data.")}. 
+0000e8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e900: 2020 2020 2020 2020 2020 2020 207b 6167               {ag
+0000e910: 675f 636f 6c75 6d6e 735f 7374 727d 0a20  g_columns_str}. 
+0000e920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e930: 2020 2020 2020 2020 2046 524f 4d20 280a           FROM (.
+0000e940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e950: 2020 2020 2020 2020 2020 2020 5345 4c45              SELE
+0000e960: 4354 2053 545f 436f 6c6c 6563 7428 6c61  CT ST_Collect(la
+0000e970: 7965 725f 6765 6f2e 7b7b 6765 6f6d 6574  yer_geo.{{geomet
+0000e980: 7279 636f 6c75 6d6e 7d7d 0a20 2020 2020  rycolumn}}.     
+0000e990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e9a0: 2020 2020 2020 2020 2020 2020 2020 2920                ) 
+0000e9b0: 4153 207b 7b67 656f 6d65 7472 7963 6f6c  AS {{geometrycol
+0000e9c0: 756d 6e7d 7d0a 2020 2020 2020 2020 2020  umn}}.          
+0000e9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e9e0: 2020 2020 2020 2020 7b67 726f 7570 6279          {groupby
+0000e9f0: 5f73 656c 6563 745f 7072 6566 6978 6564  _select_prefixed
+0000ea00: 5f73 7472 2e66 6f72 6d61 7428 7072 6566  _str.format(pref
+0000ea10: 6978 3d22 6c61 7965 725f 6765 6f2e 2229  ix="layer_geo.")
+0000ea20: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+0000ea30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ea40: 2020 2020 2c4d 494e 286c 6179 6572 5f67      ,MIN(layer_g
+0000ea50: 656f 2e7b 6f72 6465 7262 795f 636f 6c75  eo.{orderby_colu
+0000ea60: 6d6e 7d29 2061 7320 7b6f 7264 6572 6279  mn}) as {orderby
+0000ea70: 5f63 6f6c 756d 6e7d 0a20 2020 2020 2020  _column}.       
+0000ea80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ea90: 2020 2020 2020 2046 524f 4d20 227b 7b69         FROM "{{i
+0000eaa0: 6e70 7574 5f6c 6179 6572 7d7d 2220 6c61  nput_layer}}" la
+0000eab0: 7965 725f 6765 6f0a 2020 2020 2020 2020  yer_geo.        
+0000eac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ead0: 2020 2020 2020 7b67 726f 7570 6279 5f67        {groupby_g
+0000eae0: 726f 7570 6279 5f70 7265 6669 7865 645f  roupby_prefixed_
+0000eaf0: 7374 722e 666f 726d 6174 2870 7265 6669  str.format(prefi
+0000eb00: 783d 226c 6179 6572 5f67 656f 2e22 297d  x="layer_geo.")}
+0000eb10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000eb20: 2020 2020 2020 2020 2020 2020 2029 2067               ) g
+0000eb30: 656f 5f64 6174 610a 2020 2020 2020 2020  eo_data.        
+0000eb40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb50: 2020 4a4f 494e 2028 0a20 2020 2020 2020    JOIN (.       
+0000eb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb70: 2020 2020 2053 454c 4543 5420 4449 5354       SELECT DIST
+0000eb80: 494e 4354 206a 736f 6e5f 726f 7773 5f74  INCT json_rows_t
+0000eb90: 6162 6c65 2e76 616c 7565 2061 7320 6a73  able.value as js
+0000eba0: 6f6e 5f72 6f77 0a20 2020 2020 2020 2020  on_row.         
+0000ebb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ebc0: 2020 2020 2020 207b 6772 6f75 7062 795f         {groupby_
+0000ebd0: 7365 6c65 6374 5f70 7265 6669 7865 645f  select_prefixed_
+0000ebe0: 7374 722e 666f 726d 6174 2870 7265 6669  str.format(prefi
+0000ebf0: 783d 226c 6179 6572 5f66 6f72 5f6a 736f  x="layer_for_jso
+0000ec00: 6e2e 2229 7d0a 2020 2020 2020 2020 2020  n.")}.          
+0000ec10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ec20: 2020 2020 4652 4f4d 2022 7b7b 696e 7075      FROM "{{inpu
+0000ec30: 745f 6c61 7965 727d 7d22 206c 6179 6572  t_layer}}" layer
+0000ec40: 5f66 6f72 5f6a 736f 6e0a 2020 2020 2020  _for_json.      
 0000ec50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec60: 2020 2020 2020 2020 2020 2020 5345 4c45              SELE
-0000ec70: 4354 2053 545f 436f 6c6c 6563 7428 7b7b  CT ST_Collect({{
-0000ec80: 6765 6f6d 6574 7279 636f 6c75 6d6e 7d7d  geometrycolumn}}
-0000ec90: 2920 4153 207b 7b67 656f 6d65 7472 7963  ) AS {{geometryc
-0000eca0: 6f6c 756d 6e7d 7d0d 0a20 2020 2020 2020  olumn}}..       
-0000ecb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ecc0: 2020 2020 2020 2020 2020 207b 6772 6f75             {grou
-0000ecd0: 7062 795f 7365 6c65 6374 5f70 7265 6669  pby_select_prefi
-0000ece0: 7865 645f 7374 722e 666f 726d 6174 2870  xed_str.format(p
-0000ecf0: 7265 6669 783d 226c 6179 6572 2e22 297d  refix="layer.")}
-0000ed00: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000ed10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ed20: 4652 4f4d 2022 7b7b 696e 7075 745f 6c61  FROM "{{input_la
-0000ed30: 7965 727d 7d22 206c 6179 6572 0d0a 2020  yer}}" layer..  
-0000ed40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ed50: 2020 2020 2020 2020 2020 2020 7b67 726f              {gro
-0000ed60: 7570 6279 5f67 726f 7570 6279 5f70 7265  upby_groupby_pre
-0000ed70: 6669 7865 645f 7374 722e 666f 726d 6174  fixed_str.format
-0000ed80: 2870 7265 6669 783d 226c 6179 6572 2e22  (prefix="layer."
-0000ed90: 297d 0d0a 2020 2020 2020 2020 2020 2020  )}..            
-0000eda0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000edb0: 204f 5244 4552 2042 5920 4d49 4e28 6c61   ORDER BY MIN(la
-0000edc0: 7965 722e 7b6f 7264 6572 6279 5f63 6f6c  yer.{orderby_col
-0000edd0: 756d 6e7d 290d 0a20 2020 2020 2020 2020  umn})..         
-0000ede0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-0000edf0: 2222 0d0a 2020 2020 2020 2020 2020 2020  ""..            
-0000ee00: 2020 2020 656c 7365 3a0d 0a20 2020 2020      else:..     
-0000ee10: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000ee20: 2049 6620 6167 675f 636f 6c75 6d6e 7320   If agg_columns 
-0000ee30: 7370 6563 6966 6965 642c 2070 6f73 7470  specified, postp
-0000ee40: 726f 6365 7373 696e 6720 6973 2061 2062  rocessing is a b
-0000ee50: 6974 206d 6f72 650d 0a20 2020 2020 2020  it more..       
-0000ee60: 2020 2020 2020 2020 2020 2020 2023 2063               # c
-0000ee70: 6f6d 706c 6963 6174 6564 2e0d 0a20 2020  omplicated...   
-0000ee80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ee90: 2073 716c 5f73 746d 7420 3d20 6622 2222   sql_stmt = f"""
-0000eea0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000eeb0: 2020 2020 2020 2020 2020 5345 4c45 4354            SELECT
-0000eec0: 2067 656f 5f64 6174 612e 7b7b 6765 6f6d   geo_data.{{geom
-0000eed0: 6574 7279 636f 6c75 6d6e 7d7d 0d0a 2020  etrycolumn}}..  
-0000eee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eef0: 2020 2020 2020 2020 2020 2020 7b67 726f              {gro
-0000ef00: 7570 6279 5f73 656c 6563 745f 7072 6566  upby_select_pref
-0000ef10: 6978 6564 5f73 7472 2e66 6f72 6d61 7428  ixed_str.format(
-0000ef20: 7072 6566 6978 3d22 6765 6f5f 6461 7461  prefix="geo_data
-0000ef30: 2e22 297d 0d0a 2020 2020 2020 2020 2020  .")}..          
-0000ef40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ef50: 2020 2020 7b61 6767 5f63 6f6c 756d 6e73      {agg_columns
-0000ef60: 5f73 7472 7d0d 0a20 2020 2020 2020 2020  _str}..         
-0000ef70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ef80: 2046 524f 4d20 280d 0a20 2020 2020 2020   FROM (..       
-0000ef90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000efa0: 2020 2020 2053 454c 4543 5420 5354 5f43       SELECT ST_C
-0000efb0: 6f6c 6c65 6374 286c 6179 6572 5f67 656f  ollect(layer_geo
-0000efc0: 2e7b 7b67 656f 6d65 7472 7963 6f6c 756d  .{{geometrycolum
-0000efd0: 6e7d 7d0d 0a20 2020 2020 2020 2020 2020  n}}..           
-0000efe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eff0: 2020 2020 2020 2020 2920 4153 207b 7b67          ) AS {{g
-0000f000: 656f 6d65 7472 7963 6f6c 756d 6e7d 7d0d  eometrycolumn}}.
-0000f010: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f030: 2020 207b 6772 6f75 7062 795f 7365 6c65     {groupby_sele
-0000f040: 6374 5f70 7265 6669 7865 645f 7374 722e  ct_prefixed_str.
-0000f050: 666f 726d 6174 2870 7265 6669 783d 226c  format(prefix="l
-0000f060: 6179 6572 5f67 656f 2e22 297d 0d0a 2020  ayer_geo.")}..  
-0000f070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f090: 2c4d 494e 286c 6179 6572 5f67 656f 2e7b  ,MIN(layer_geo.{
-0000f0a0: 6f72 6465 7262 795f 636f 6c75 6d6e 7d29  orderby_column})
-0000f0b0: 2061 7320 7b6f 7264 6572 6279 5f63 6f6c   as {orderby_col
-0000f0c0: 756d 6e7d 0d0a 2020 2020 2020 2020 2020  umn}..          
-0000f0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f0e0: 2020 2020 4652 4f4d 2022 7b7b 696e 7075      FROM "{{inpu
-0000f0f0: 745f 6c61 7965 727d 7d22 206c 6179 6572  t_layer}}" layer
-0000f100: 5f67 656f 0d0a 2020 2020 2020 2020 2020  _geo..          
-0000f110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f120: 2020 2020 7b67 726f 7570 6279 5f67 726f      {groupby_gro
-0000f130: 7570 6279 5f70 7265 6669 7865 645f 7374  upby_prefixed_st
-0000f140: 722e 666f 726d 6174 2870 7265 6669 783d  r.format(prefix=
-0000f150: 226c 6179 6572 5f67 656f 2e22 297d 0d0a  "layer_geo.")}..
-0000f160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f170: 2020 2020 2020 2020 2020 2020 2920 6765              ) ge
-0000f180: 6f5f 6461 7461 0d0a 2020 2020 2020 2020  o_data..        
-0000f190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f1a0: 2020 4a4f 494e 2028 0d0a 2020 2020 2020    JOIN (..      
-0000f1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f1c0: 2020 2020 2020 5345 4c45 4354 2044 4953        SELECT DIS
-0000f1d0: 5449 4e43 5420 6a73 6f6e 5f72 6f77 735f  TINCT json_rows_
-0000f1e0: 7461 626c 652e 7661 6c75 6520 6173 206a  table.value as j
-0000f1f0: 736f 6e5f 726f 770d 0a20 2020 2020 2020  son_row..       
-0000f200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f210: 2020 2020 2020 2020 207b 6772 6f75 7062           {groupb
-0000f220: 795f 7365 6c65 6374 5f70 7265 6669 7865  y_select_prefixe
-0000f230: 645f 7374 722e 666f 726d 6174 2870 7265  d_str.format(pre
-0000f240: 6669 783d 226c 6179 6572 5f66 6f72 5f6a  fix="layer_for_j
-0000f250: 736f 6e2e 2229 7d0d 0a20 2020 2020 2020  son.")}..       
-0000f260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f270: 2020 2020 2020 2046 524f 4d20 227b 7b69         FROM "{{i
-0000f280: 6e70 7574 5f6c 6179 6572 7d7d 2220 6c61  nput_layer}}" la
-0000f290: 7965 725f 666f 725f 6a73 6f6e 0d0a 2020  yer_for_json..  
-0000f2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f2b0: 2020 2020 2020 2020 2020 2020 4352 4f53              CROS
-0000f2c0: 5320 4a4f 494e 206a 736f 6e5f 6561 6368  S JOIN json_each
-0000f2d0: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-0000f2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f2f0: 2020 2020 206c 6179 6572 5f66 6f72 5f6a       layer_for_j
-0000f300: 736f 6e2e 5f5f 4449 5353 4f4c 5645 5f54  son.__DISSOLVE_T
-0000f310: 4f4a 534f 4e2c 2022 2422 2920 6a73 6f6e  OJSON, "$") json
-0000f320: 5f72 6f77 735f 7461 626c 650d 0a20 2020  _rows_table..   
-0000f330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f340: 2020 2020 2020 2020 2029 206a 736f 6e5f           ) json_
-0000f350: 6461 7461 0d0a 2020 2020 2020 2020 2020  data..          
-0000f360: 2020 2020 2020 2020 2020 2020 2020 2057                 W
-0000f370: 4845 5245 2031 3d31 0d0a 2020 2020 2020  HERE 1=1..      
-0000f380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f390: 2020 2020 2020 7b67 726f 7570 6279 5f66        {groupby_f
-0000f3a0: 696c 7465 725f 7374 727d 0d0a 2020 2020  ilter_str}..    
-0000f3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f3c0: 2020 2020 2020 7b67 726f 7570 6279 5f67        {groupby_g
-0000f3d0: 726f 7570 6279 5f70 7265 6669 7865 645f  roupby_prefixed_
-0000f3e0: 7374 722e 666f 726d 6174 2870 7265 6669  str.format(prefi
-0000f3f0: 783d 2267 656f 5f64 6174 612e 2229 7d0d  x="geo_data.")}.
-0000f400: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f410: 2020 2020 2020 2020 2020 204f 5244 4552             ORDER
-0000f420: 2042 5920 6765 6f5f 6461 7461 2e7b 6f72   BY geo_data.{or
-0000f430: 6465 7262 795f 636f 6c75 6d6e 7d0d 0a20  derby_column}.. 
+0000ec60: 2020 2020 2020 2020 4352 4f53 5320 4a4f          CROSS JO
+0000ec70: 494e 206a 736f 6e5f 6561 6368 280a 2020  IN json_each(.  
+0000ec80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ec90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eca0: 6c61 7965 725f 666f 725f 6a73 6f6e 2e5f  layer_for_json._
+0000ecb0: 5f44 4953 534f 4c56 455f 544f 4a53 4f4e  _DISSOLVE_TOJSON
+0000ecc0: 2c20 2224 2229 206a 736f 6e5f 726f 7773  , "$") json_rows
+0000ecd0: 5f74 6162 6c65 0a20 2020 2020 2020 2020  _table.         
+0000ece0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ecf0: 2020 2029 206a 736f 6e5f 6461 7461 0a20     ) json_data. 
+0000ed00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed10: 2020 2020 2020 2020 5748 4552 4520 313d          WHERE 1=
+0000ed20: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
+0000ed30: 2020 2020 2020 2020 2020 2020 2020 7b67                {g
+0000ed40: 726f 7570 6279 5f66 696c 7465 725f 7374  roupby_filter_st
+0000ed50: 727d 0a20 2020 2020 2020 2020 2020 2020  r}.             
+0000ed60: 2020 2020 2020 2020 2020 2020 207b 6772               {gr
+0000ed70: 6f75 7062 795f 6772 6f75 7062 795f 7072  oupby_groupby_pr
+0000ed80: 6566 6978 6564 5f73 7472 2e66 6f72 6d61  efixed_str.forma
+0000ed90: 7428 7072 6566 6978 3d22 6765 6f5f 6461  t(prefix="geo_da
+0000eda0: 7461 2e22 297d 0a20 2020 2020 2020 2020  ta.")}.         
+0000edb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000edc0: 204f 5244 4552 2042 5920 6765 6f5f 6461   ORDER BY geo_da
+0000edd0: 7461 2e7b 6f72 6465 7262 795f 636f 6c75  ta.{orderby_colu
+0000ede0: 6d6e 7d0a 2020 2020 2020 2020 2020 2020  mn}.            
+0000edf0: 2020 2020 2020 2020 2222 220a 0a20 2020          """..   
+0000ee00: 2020 2020 2020 2020 2020 2020 2023 2041               # A
+0000ee10: 7070 6c79 2077 6865 7265 5f70 6f73 7420  pply where_post 
+0000ee20: 7061 7261 6d65 7465 7220 6966 206e 6565  parameter if nee
+0000ee30: 6465 642f 706f 7373 6962 6c65 0a20 2020  ded/possible.   
+0000ee40: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000ee50: 7768 6572 655f 706f 7374 2069 7320 6e6f  where_post is no
+0000ee60: 7420 4e6f 6e65 2061 6e64 206e 6f74 206e  t None and not n
+0000ee70: 6f74 2065 7870 6c6f 6465 636f 6c6c 6563  ot explodecollec
+0000ee80: 7469 6f6e 733a 0a20 2020 2020 2020 2020  tions:.         
+0000ee90: 2020 2020 2020 2020 2020 2023 2065 7870             # exp
+0000eea0: 6c6f 6465 636f 6c6c 6563 7469 6f6e 7320  lodecollections 
+0000eeb0: 6973 206e 6f74 2054 7275 652c 2073 6f20  is not True, so 
+0000eec0: 7765 2063 616e 2061 6464 2069 7420 746f  we can add it to
+0000eed0: 2073 716c 5f73 746d 742e 0a20 2020 2020   sql_stmt..     
+0000eee0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000eef0: 2049 6620 6578 706c 6f64 6563 6f6c 6c65   If explodecolle
+0000ef00: 6374 696f 6e73 2077 6f75 6c64 2062 6520  ctions would be 
+0000ef10: 5472 7565 2c20 7765 206e 6565 6420 746f  True, we need to
+0000ef20: 2077 6169 7420 746f 2061 7070 6c79 2074   wait to apply t
+0000ef30: 6865 0a20 2020 2020 2020 2020 2020 2020  he.             
+0000ef40: 2020 2020 2020 2023 2077 6865 7265 5f70         # where_p
+0000ef50: 6f73 7420 7469 6c6c 2061 6674 6572 2065  ost till after e
+0000ef60: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
+0000ef70: 7320 6973 2061 7070 6c69 6564 2c20 736f  s is applied, so
+0000ef80: 2077 6865 6e0a 2020 2020 2020 2020 2020   when.          
+0000ef90: 2020 2020 2020 2020 2020 2320 6170 7065            # appe
+0000efa0: 6e64 696e 6720 7468 6520 7061 7274 6961  nding the partia
+0000efb0: 6c20 7265 7375 6c74 7320 746f 2074 6865  l results to the
+0000efc0: 206f 7574 7075 7420 6669 6c65 2e0a 2020   output file..  
+0000efd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000efe0: 2020 7768 6572 655f 706f 7374 203d 2077    where_post = w
+0000eff0: 6865 7265 5f70 6f73 742e 666f 726d 6174  here_post.format
+0000f000: 2867 656f 6d65 7472 7963 6f6c 756d 6e3d  (geometrycolumn=
+0000f010: 2267 656f 6d22 290a 2020 2020 2020 2020  "geom").        
+0000f020: 2020 2020 2020 2020 2020 2020 7371 6c5f              sql_
+0000f030: 7374 6d74 203d 2066 2222 220a 2020 2020  stmt = f""".    
+0000f040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f050: 2020 2020 5345 4c45 4354 202a 2046 524f      SELECT * FRO
+0000f060: 4d0a 2020 2020 2020 2020 2020 2020 2020  M.              
+0000f070: 2020 2020 2020 2020 2020 2020 2020 2820                ( 
+0000f080: 7b73 716c 5f73 746d 747d 0a20 2020 2020  {sql_stmt}.     
+0000f090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f0a0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0000f0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f0c0: 2057 4845 5245 207b 7768 6572 655f 706f   WHERE {where_po
+0000f0d0: 7374 7d0a 2020 2020 2020 2020 2020 2020  st}.            
+0000f0e0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0000f0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f100: 2320 7768 6572 655f 706f 7374 2068 6173  # where_post has
+0000f110: 2062 6565 6e20 6170 706c 6965 6420 616c   been applied al
+0000f120: 7265 6164 7920 736f 2073 6574 2074 6f20  ready so set to 
+0000f130: 4e6f 6e65 2e0a 2020 2020 2020 2020 2020  None..          
+0000f140: 2020 2020 2020 2020 2020 7768 6572 655f            where_
+0000f150: 706f 7374 203d 204e 6f6e 650a 0a20 2020  post = None..   
+0000f160: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000f170: 7768 6572 655f 706f 7374 2069 7320 4e6f  where_post is No
+0000f180: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+0000f190: 2020 2020 2020 2020 6e61 6d65 203d 2066          name = f
+0000f1a0: 226f 7574 7075 745f 746d 7032 5f66 696e  "output_tmp2_fin
+0000f1b0: 616c 7b6f 7574 7075 745f 7061 7468 2e73  al{output_path.s
+0000f1c0: 7566 6669 787d 220a 2020 2020 2020 2020  uffix}".        
+0000f1d0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000f1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f1f0: 2020 6e61 6d65 203d 2066 226f 7574 7075    name = f"outpu
+0000f200: 745f 746d 7032 5f66 696e 616c 7b6f 7574  t_tmp2_final{out
+0000f210: 7075 745f 746d 705f 7061 7468 2e73 7566  put_tmp_path.suf
+0000f220: 6669 787d 220a 2020 2020 2020 2020 2020  fix}".          
+0000f230: 2020 2020 2020 6f75 7470 7574 5f74 6d70        output_tmp
+0000f240: 325f 6669 6e61 6c5f 7061 7468 203d 2074  2_final_path = t
+0000f250: 656d 7064 6972 202f 206e 616d 650a 2020  empdir / name.  
+0000f260: 2020 2020 2020 2020 2020 2020 2020 7371                sq
+0000f270: 6c5f 7374 6d74 203d 2073 716c 5f73 746d  l_stmt = sql_stm
+0000f280: 742e 666f 726d 6174 280a 2020 2020 2020  t.format(.      
+0000f290: 2020 2020 2020 2020 2020 2020 2020 6765                ge
+0000f2a0: 6f6d 6574 7279 636f 6c75 6d6e 3d22 6765  ometrycolumn="ge
+0000f2b0: 6f6d 222c 2069 6e70 7574 5f6c 6179 6572  om", input_layer
+0000f2c0: 3d6f 7574 7075 745f 6c61 7965 720a 2020  =output_layer.  
+0000f2d0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000f2e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f2f0: 2063 7265 6174 655f 7370 6174 6961 6c5f   create_spatial_
+0000f300: 696e 6465 7820 3d20 5472 7565 2069 6620  index = True if 
+0000f310: 7768 6572 655f 706f 7374 2069 7320 4e6f  where_post is No
+0000f320: 6e65 2065 6c73 6520 4661 6c73 650a 2020  ne else False.  
+0000f330: 2020 2020 2020 2020 2020 2020 2020 6f75                ou
+0000f340: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000f350: 6520 3d20 280a 2020 2020 2020 2020 2020  e = (.          
+0000f360: 2020 2020 2020 2020 2020 696e 7075 745f            input_
+0000f370: 6c61 7965 7269 6e66 6f2e 6765 6f6d 6574  layerinfo.geomet
+0000f380: 7279 7479 7065 2e74 6f5f 7369 6e67 6c65  rytype.to_single
+0000f390: 7479 7065 0a20 2020 2020 2020 2020 2020  type.           
+0000f3a0: 2020 2020 2020 2020 2069 6620 6578 706c           if expl
+0000f3b0: 6f64 6563 6f6c 6c65 6374 696f 6e73 0a20  odecollections. 
+0000f3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f3d0: 2020 2065 6c73 6520 696e 7075 745f 6c61     else input_la
+0000f3e0: 7965 7269 6e66 6f2e 6765 6f6d 6574 7279  yerinfo.geometry
+0000f3f0: 7479 7065 2e74 6f5f 6d75 6c74 6974 7970  type.to_multityp
+0000f400: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+0000f410: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+0000f420: 2020 2020 5f6f 6772 5f75 7469 6c2e 7665      _ogr_util.ve
+0000f430: 6374 6f72 5f74 7261 6e73 6c61 7465 280a  ctor_translate(.
 0000f440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f450: 2020 2022 2222 0d0a 0d0a 2020 2020 2020     """....      
-0000f460: 2020 2020 2020 2020 2020 2320 4170 706c            # Appl
-0000f470: 7920 7768 6572 655f 706f 7374 2070 6172  y where_post par
-0000f480: 616d 6574 6572 2069 6620 6e65 6564 6564  ameter if needed
-0000f490: 2f70 6f73 7369 626c 650d 0a20 2020 2020  /possible..     
-0000f4a0: 2020 2020 2020 2020 2020 2069 6620 7768             if wh
-0000f4b0: 6572 655f 706f 7374 2069 7320 6e6f 7420  ere_post is not 
-0000f4c0: 4e6f 6e65 2061 6e64 206e 6f74 206e 6f74  None and not not
-0000f4d0: 2065 7870 6c6f 6465 636f 6c6c 6563 7469   explodecollecti
-0000f4e0: 6f6e 733a 0d0a 2020 2020 2020 2020 2020  ons:..          
-0000f4f0: 2020 2020 2020 2020 2020 2320 6578 706c            # expl
-0000f500: 6f64 6563 6f6c 6c65 6374 696f 6e73 2069  odecollections i
-0000f510: 7320 6e6f 7420 5472 7565 2c20 736f 2077  s not True, so w
-0000f520: 6520 6361 6e20 6164 6420 6974 2074 6f20  e can add it to 
-0000f530: 7371 6c5f 7374 6d74 2e0d 0a20 2020 2020  sql_stmt...     
-0000f540: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000f550: 2049 6620 6578 706c 6f64 6563 6f6c 6c65   If explodecolle
-0000f560: 6374 696f 6e73 2077 6f75 6c64 2062 6520  ctions would be 
-0000f570: 5472 7565 2c20 7765 206e 6565 6420 746f  True, we need to
-0000f580: 2077 6169 7420 746f 2061 7070 6c79 2074   wait to apply t
-0000f590: 6865 0d0a 2020 2020 2020 2020 2020 2020  he..            
-0000f5a0: 2020 2020 2020 2020 2320 7768 6572 655f          # where_
-0000f5b0: 706f 7374 2074 696c 6c20 6166 7465 7220  post till after 
-0000f5c0: 6578 706c 6f64 6563 6f6c 6c65 6374 696f  explodecollectio
-0000f5d0: 6e73 2069 7320 6170 706c 6965 642c 2073  ns is applied, s
-0000f5e0: 6f20 7768 656e 0d0a 2020 2020 2020 2020  o when..        
-0000f5f0: 2020 2020 2020 2020 2020 2020 2320 6170              # ap
-0000f600: 7065 6e64 696e 6720 7468 6520 7061 7274  pending the part
-0000f610: 6961 6c20 7265 7375 6c74 7320 746f 2074  ial results to t
-0000f620: 6865 206f 7574 7075 7420 6669 6c65 2e0d  he output file..
-0000f630: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f640: 2020 2020 2077 6865 7265 5f70 6f73 7420       where_post 
-0000f650: 3d20 7768 6572 655f 706f 7374 2e66 6f72  = where_post.for
-0000f660: 6d61 7428 6765 6f6d 6574 7279 636f 6c75  mat(geometrycolu
-0000f670: 6d6e 3d22 6765 6f6d 2229 0d0a 2020 2020  mn="geom")..    
-0000f680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f690: 7371 6c5f 7374 6d74 203d 2066 2222 220d  sql_stmt = f""".
-0000f6a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f6b0: 2020 2020 2020 2020 2053 454c 4543 5420           SELECT 
-0000f6c0: 2a20 4652 4f4d 0d0a 2020 2020 2020 2020  * FROM..        
-0000f6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f6e0: 2020 2020 2820 7b73 716c 5f73 746d 747d      ( {sql_stmt}
-0000f6f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000f700: 2020 2020 2020 2020 2020 2020 2020 290d                ).
-0000f710: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f720: 2020 2020 2020 2020 2057 4845 5245 207b           WHERE {
-0000f730: 7768 6572 655f 706f 7374 7d0d 0a20 2020  where_post}..   
-0000f740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f750: 2022 2222 0d0a 2020 2020 2020 2020 2020   """..          
-0000f760: 2020 2020 2020 2020 2020 2320 7768 6572            # wher
-0000f770: 655f 706f 7374 2068 6173 2062 6565 6e20  e_post has been 
-0000f780: 6170 706c 6965 6420 616c 7265 6164 7920  applied already 
-0000f790: 736f 2073 6574 2074 6f20 4e6f 6e65 2e0d  so set to None..
-0000f7a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f7b0: 2020 2020 2077 6865 7265 5f70 6f73 7420       where_post 
-0000f7c0: 3d20 4e6f 6e65 0d0a 0d0a 2020 2020 2020  = None....      
-0000f7d0: 2020 2020 2020 2020 2020 6966 2077 6865            if whe
-0000f7e0: 7265 5f70 6f73 7420 6973 204e 6f6e 653a  re_post is None:
-0000f7f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000f800: 2020 2020 2020 6e61 6d65 203d 2066 226f        name = f"o
-0000f810: 7574 7075 745f 746d 7032 5f66 696e 616c  utput_tmp2_final
-0000f820: 7b6f 7574 7075 745f 7061 7468 2e73 7566  {output_path.suf
-0000f830: 6669 787d 220d 0a20 2020 2020 2020 2020  fix}"..         
-0000f840: 2020 2020 2020 2065 6c73 653a 0d0a 2020         else:..  
-0000f850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f860: 2020 6e61 6d65 203d 2066 226f 7574 7075    name = f"outpu
-0000f870: 745f 746d 7032 5f66 696e 616c 7b6f 7574  t_tmp2_final{out
-0000f880: 7075 745f 746d 705f 7061 7468 2e73 7566  put_tmp_path.suf
-0000f890: 6669 787d 220d 0a20 2020 2020 2020 2020  fix}"..         
-0000f8a0: 2020 2020 2020 206f 7574 7075 745f 746d         output_tm
-0000f8b0: 7032 5f66 696e 616c 5f70 6174 6820 3d20  p2_final_path = 
-0000f8c0: 7465 6d70 6469 7220 2f20 6e61 6d65 0d0a  tempdir / name..
+0000f450: 2020 2020 696e 7075 745f 7061 7468 3d6f      input_path=o
+0000f460: 7574 7075 745f 746d 705f 7061 7468 2c0a  utput_tmp_path,.
+0000f470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f480: 2020 2020 6f75 7470 7574 5f70 6174 683d      output_path=
+0000f490: 6f75 7470 7574 5f74 6d70 325f 6669 6e61  output_tmp2_fina
+0000f4a0: 6c5f 7061 7468 2c0a 2020 2020 2020 2020  l_path,.        
+0000f4b0: 2020 2020 2020 2020 2020 2020 6f75 7470              outp
+0000f4c0: 7574 5f6c 6179 6572 3d6f 7574 7075 745f  ut_layer=output_
+0000f4d0: 6c61 7965 722c 0a20 2020 2020 2020 2020  layer,.         
+0000f4e0: 2020 2020 2020 2020 2020 2073 716c 5f73             sql_s
+0000f4f0: 746d 743d 7371 6c5f 7374 6d74 2c0a 2020  tmt=sql_stmt,.  
+0000f500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f510: 2020 7371 6c5f 6469 616c 6563 743d 2253    sql_dialect="S
+0000f520: 514c 4954 4522 2c0a 2020 2020 2020 2020  QLITE",.        
+0000f530: 2020 2020 2020 2020 2020 2020 666f 7263              forc
+0000f540: 655f 6f75 7470 7574 5f67 656f 6d65 7472  e_output_geometr
+0000f550: 7974 7970 653d 6f75 7470 7574 5f67 656f  ytype=output_geo
+0000f560: 6d65 7472 7974 7970 652c 0a20 2020 2020  metrytype,.     
+0000f570: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000f580: 7870 6c6f 6465 636f 6c6c 6563 7469 6f6e  xplodecollection
+0000f590: 733d 6578 706c 6f64 6563 6f6c 6c65 6374  s=explodecollect
+0000f5a0: 696f 6e73 2c0a 2020 2020 2020 2020 2020  ions,.          
+0000f5b0: 2020 2020 2020 2020 2020 6f70 7469 6f6e            option
+0000f5c0: 733d 7b22 4c41 5945 525f 4352 4541 5449  s={"LAYER_CREATI
+0000f5d0: 4f4e 2e53 5041 5449 414c 5f49 4e44 4558  ON.SPATIAL_INDEX
+0000f5e0: 223a 2063 7265 6174 655f 7370 6174 6961  ": create_spatia
+0000f5f0: 6c5f 696e 6465 787d 2c0a 2020 2020 2020  l_index},.      
+0000f600: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+0000f610: 2020 2020 2020 2020 2020 2020 2023 2057               # W
+0000f620: 6520 7374 696c 6c20 6e65 6564 2074 6f20  e still need to 
+0000f630: 6170 706c 7920 7468 6520 7768 6572 655f  apply the where_
+0000f640: 706f 7374 2066 696c 7465 720a 2020 2020  post filter.    
+0000f650: 2020 2020 2020 2020 2020 2020 6966 2077              if w
+0000f660: 6865 7265 5f70 6f73 7420 6973 206e 6f74  here_post is not
+0000f670: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0000f680: 2020 2020 2020 2020 2020 206e 616d 6520             name 
+0000f690: 3d20 6622 6f75 7470 7574 5f74 6d70 335f  = f"output_tmp3_
+0000f6a0: 7768 6572 657b 6f75 7470 7574 5f70 6174  where{output_pat
+0000f6b0: 682e 7375 6666 6978 7d22 0a20 2020 2020  h.suffix}".     
+0000f6c0: 2020 2020 2020 2020 2020 2020 2020 206f                 o
+0000f6d0: 7574 7075 745f 746d 7033 5f77 6865 7265  utput_tmp3_where
+0000f6e0: 5f70 6174 6820 3d20 7465 6d70 6469 7220  _path = tempdir 
+0000f6f0: 2f20 6e61 6d65 0a20 2020 2020 2020 2020  / name.         
+0000f700: 2020 2020 2020 2020 2020 206f 7574 7075             outpu
+0000f710: 745f 746d 7032 5f69 6e66 6f20 3d20 6766  t_tmp2_info = gf
+0000f720: 6f2e 6765 745f 6c61 7965 7269 6e66 6f28  o.get_layerinfo(
+0000f730: 6f75 7470 7574 5f74 6d70 325f 6669 6e61  output_tmp2_fina
+0000f740: 6c5f 7061 7468 290a 2020 2020 2020 2020  l_path).        
+0000f750: 2020 2020 2020 2020 2020 2020 7768 6572              wher
+0000f760: 655f 706f 7374 203d 2077 6865 7265 5f70  e_post = where_p
+0000f770: 6f73 742e 666f 726d 6174 280a 2020 2020  ost.format(.    
+0000f780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f790: 2020 2020 6765 6f6d 6574 7279 636f 6c75      geometrycolu
+0000f7a0: 6d6e 3d6f 7574 7075 745f 746d 7032 5f69  mn=output_tmp2_i
+0000f7b0: 6e66 6f2e 6765 6f6d 6574 7279 636f 6c75  nfo.geometrycolu
+0000f7c0: 6d6e 0a20 2020 2020 2020 2020 2020 2020  mn.             
+0000f7d0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0000f7e0: 2020 2020 2020 2020 2020 2020 2073 716c               sql
+0000f7f0: 5f73 746d 7420 3d20 6622 2222 0a20 2020  _stmt = f""".   
+0000f800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f810: 2020 2020 2053 454c 4543 5420 2a20 4652       SELECT * FR
+0000f820: 4f4d 2022 7b6f 7574 7075 745f 6c61 7965  OM "{output_laye
+0000f830: 727d 220a 2020 2020 2020 2020 2020 2020  r}".            
+0000f840: 2020 2020 2020 2020 2020 2020 2057 4845               WHE
+0000f850: 5245 207b 7768 6572 655f 706f 7374 7d0a  RE {where_post}.
+0000f860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f870: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0000f880: 2020 2020 2020 2020 2020 2020 746d 705f              tmp_
+0000f890: 696e 666f 203d 2067 666f 2e67 6574 5f6c  info = gfo.get_l
+0000f8a0: 6179 6572 696e 666f 286f 7574 7075 745f  ayerinfo(output_
+0000f8b0: 746d 7032 5f66 696e 616c 5f70 6174 682c  tmp2_final_path,
+0000f8c0: 206f 7574 7075 745f 6c61 7965 7229 0a20   output_layer). 
 0000f8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f8e0: 7371 6c5f 7374 6d74 203d 2073 716c 5f73  sql_stmt = sql_s
-0000f8f0: 746d 742e 666f 726d 6174 280d 0a20 2020  tmt.format(..   
-0000f900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f910: 2067 656f 6d65 7472 7963 6f6c 756d 6e3d   geometrycolumn=
-0000f920: 2267 656f 6d22 2c20 696e 7075 745f 6c61  "geom", input_la
-0000f930: 7965 723d 6f75 7470 7574 5f6c 6179 6572  yer=output_layer
-0000f940: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000f950: 2020 290d 0a0d 0a20 2020 2020 2020 2020    )....         
-0000f960: 2020 2020 2020 2063 7265 6174 655f 7370         create_sp
-0000f970: 6174 6961 6c5f 696e 6465 7820 3d20 5472  atial_index = Tr
-0000f980: 7565 2069 6620 7768 6572 655f 706f 7374  ue if where_post
-0000f990: 2069 7320 4e6f 6e65 2065 6c73 6520 4661   is None else Fa
-0000f9a0: 6c73 650d 0a20 2020 2020 2020 2020 2020  lse..           
-0000f9b0: 2020 2020 206f 7574 7075 745f 6765 6f6d       output_geom
-0000f9c0: 6574 7279 7479 7065 203d 2028 0d0a 2020  etrytype = (..  
+0000f8e0: 2020 2073 716c 5f73 746d 7420 3d20 7371     sql_stmt = sq
+0000f8f0: 6c5f 7374 6d74 2e66 6f72 6d61 7428 6765  l_stmt.format(ge
+0000f900: 6f6d 6574 7279 636f 6c75 6d6e 3d74 6d70  ometrycolumn=tmp
+0000f910: 5f69 6e66 6f2e 6765 6f6d 6574 7279 636f  _info.geometryco
+0000f920: 6c75 6d6e 290a 2020 2020 2020 2020 2020  lumn).          
+0000f930: 2020 2020 2020 2020 2020 5f6f 6772 5f75            _ogr_u
+0000f940: 7469 6c2e 7665 6374 6f72 5f74 7261 6e73  til.vector_trans
+0000f950: 6c61 7465 280a 2020 2020 2020 2020 2020  late(.          
+0000f960: 2020 2020 2020 2020 2020 2020 2020 696e                in
+0000f970: 7075 745f 7061 7468 3d6f 7574 7075 745f  put_path=output_
+0000f980: 746d 7032 5f66 696e 616c 5f70 6174 682c  tmp2_final_path,
+0000f990: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f9a0: 2020 2020 2020 2020 206f 7574 7075 745f           output_
+0000f9b0: 7061 7468 3d6f 7574 7075 745f 746d 7033  path=output_tmp3
+0000f9c0: 5f77 6865 7265 5f70 6174 682c 0a20 2020  _where_path,.   
 0000f9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f9e0: 2020 696e 7075 745f 6c61 7965 7269 6e66    input_layerinf
-0000f9f0: 6f2e 6765 6f6d 6574 7279 7479 7065 2e74  o.geometrytype.t
-0000fa00: 6f5f 7369 6e67 6c65 7479 7065 0d0a 2020  o_singletype..  
-0000fa10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fa20: 2020 6966 2065 7870 6c6f 6465 636f 6c6c    if explodecoll
-0000fa30: 6563 7469 6f6e 730d 0a20 2020 2020 2020  ections..       
-0000fa40: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000fa50: 6520 696e 7075 745f 6c61 7965 7269 6e66  e input_layerinf
-0000fa60: 6f2e 6765 6f6d 6574 7279 7479 7065 2e74  o.geometrytype.t
-0000fa70: 6f5f 6d75 6c74 6974 7970 650d 0a20 2020  o_multitype..   
-0000fa80: 2020 2020 2020 2020 2020 2020 2029 0d0a               )..
-0000fa90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000faa0: 5f6f 6772 5f75 7469 6c2e 7665 6374 6f72  _ogr_util.vector
-0000fab0: 5f74 7261 6e73 6c61 7465 280d 0a20 2020  _translate(..   
-0000fac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fad0: 2069 6e70 7574 5f70 6174 683d 6f75 7470   input_path=outp
-0000fae0: 7574 5f74 6d70 5f70 6174 682c 0d0a 2020  ut_tmp_path,..  
-0000faf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fb00: 2020 6f75 7470 7574 5f70 6174 683d 6f75    output_path=ou
-0000fb10: 7470 7574 5f74 6d70 325f 6669 6e61 6c5f  tput_tmp2_final_
-0000fb20: 7061 7468 2c0d 0a20 2020 2020 2020 2020  path,..         
-0000fb30: 2020 2020 2020 2020 2020 206f 7574 7075             outpu
-0000fb40: 745f 6c61 7965 723d 6f75 7470 7574 5f6c  t_layer=output_l
-0000fb50: 6179 6572 2c0d 0a20 2020 2020 2020 2020  ayer,..         
-0000fb60: 2020 2020 2020 2020 2020 2073 716c 5f73             sql_s
-0000fb70: 746d 743d 7371 6c5f 7374 6d74 2c0d 0a20  tmt=sql_stmt,.. 
-0000fb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fb90: 2020 2073 716c 5f64 6961 6c65 6374 3d22     sql_dialect="
-0000fba0: 5351 4c49 5445 222c 0d0a 2020 2020 2020  SQLITE",..      
-0000fbb0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-0000fbc0: 7263 655f 6f75 7470 7574 5f67 656f 6d65  rce_output_geome
-0000fbd0: 7472 7974 7970 653d 6f75 7470 7574 5f67  trytype=output_g
-0000fbe0: 656f 6d65 7472 7974 7970 652c 0d0a 2020  eometrytype,..  
-0000fbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fc00: 2020 6578 706c 6f64 6563 6f6c 6c65 6374    explodecollect
-0000fc10: 696f 6e73 3d65 7870 6c6f 6465 636f 6c6c  ions=explodecoll
-0000fc20: 6563 7469 6f6e 732c 0d0a 2020 2020 2020  ections,..      
-0000fc30: 2020 2020 2020 2020 2020 2020 2020 6f70                op
-0000fc40: 7469 6f6e 733d 7b22 4c41 5945 525f 4352  tions={"LAYER_CR
-0000fc50: 4541 5449 4f4e 2e53 5041 5449 414c 5f49  EATION.SPATIAL_I
-0000fc60: 4e44 4558 223a 2063 7265 6174 655f 7370  NDEX": create_sp
-0000fc70: 6174 6961 6c5f 696e 6465 787d 2c0d 0a20  atial_index},.. 
-0000fc80: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-0000fc90: 0d0a 0d0a 2020 2020 2020 2020 2020 2020  ....            
-0000fca0: 2020 2020 2320 5765 2073 7469 6c6c 206e      # We still n
-0000fcb0: 6565 6420 746f 2061 7070 6c79 2074 6865  eed to apply the
-0000fcc0: 2077 6865 7265 5f70 6f73 7420 6669 6c74   where_post filt
-0000fcd0: 6572 0d0a 2020 2020 2020 2020 2020 2020  er..            
-0000fce0: 2020 2020 6966 2077 6865 7265 5f70 6f73      if where_pos
-0000fcf0: 7420 6973 206e 6f74 204e 6f6e 653a 0d0a  t is not None:..
-0000fd00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fd10: 2020 2020 6e61 6d65 203d 2066 226f 7574      name = f"out
-0000fd20: 7075 745f 746d 7033 5f77 6865 7265 7b6f  put_tmp3_where{o
-0000fd30: 7574 7075 745f 7061 7468 2e73 7566 6669  utput_path.suffi
-0000fd40: 787d 220d 0a20 2020 2020 2020 2020 2020  x}"..           
-0000fd50: 2020 2020 2020 2020 206f 7574 7075 745f           output_
-0000fd60: 746d 7033 5f77 6865 7265 5f70 6174 6820  tmp3_where_path 
-0000fd70: 3d20 7465 6d70 6469 7220 2f20 6e61 6d65  = tempdir / name
-0000fd80: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000fd90: 2020 2020 2020 6f75 7470 7574 5f74 6d70        output_tmp
-0000fda0: 325f 696e 666f 203d 2067 666f 2e67 6574  2_info = gfo.get
-0000fdb0: 5f6c 6179 6572 696e 666f 286f 7574 7075  _layerinfo(outpu
-0000fdc0: 745f 746d 7032 5f66 696e 616c 5f70 6174  t_tmp2_final_pat
-0000fdd0: 6829 0d0a 2020 2020 2020 2020 2020 2020  h)..            
-0000fde0: 2020 2020 2020 2020 7768 6572 655f 706f          where_po
-0000fdf0: 7374 203d 2077 6865 7265 5f70 6f73 742e  st = where_post.
-0000fe00: 666f 726d 6174 280d 0a20 2020 2020 2020  format(..       
-0000fe10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fe20: 2067 656f 6d65 7472 7963 6f6c 756d 6e3d   geometrycolumn=
-0000fe30: 6f75 7470 7574 5f74 6d70 325f 696e 666f  output_tmp2_info
-0000fe40: 2e67 656f 6d65 7472 7963 6f6c 756d 6e0d  .geometrycolumn.
-0000fe50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000fe60: 2020 2020 2029 0d0a 2020 2020 2020 2020       )..        
-0000fe70: 2020 2020 2020 2020 2020 2020 7371 6c5f              sql_
-0000fe80: 7374 6d74 203d 2066 2222 220d 0a20 2020  stmt = f"""..   
-0000fe90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fea0: 2020 2020 2053 454c 4543 5420 2a20 4652       SELECT * FR
-0000feb0: 4f4d 2022 7b6f 7574 7075 745f 6c61 7965  OM "{output_laye
-0000fec0: 727d 220d 0a20 2020 2020 2020 2020 2020  r}"..           
-0000fed0: 2020 2020 2020 2020 2020 2020 2020 5748                WH
-0000fee0: 4552 4520 7b77 6865 7265 5f70 6f73 747d  ERE {where_post}
-0000fef0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000ff00: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-0000ff10: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0000ff20: 6d70 5f69 6e66 6f20 3d20 6766 6f2e 6765  mp_info = gfo.ge
-0000ff30: 745f 6c61 7965 7269 6e66 6f28 6f75 7470  t_layerinfo(outp
-0000ff40: 7574 5f74 6d70 325f 6669 6e61 6c5f 7061  ut_tmp2_final_pa
-0000ff50: 7468 2c20 6f75 7470 7574 5f6c 6179 6572  th, output_layer
-0000ff60: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-0000ff70: 2020 2020 2020 2073 716c 5f73 746d 7420         sql_stmt 
-0000ff80: 3d20 7371 6c5f 7374 6d74 2e66 6f72 6d61  = sql_stmt.forma
-0000ff90: 7428 6765 6f6d 6574 7279 636f 6c75 6d6e  t(geometrycolumn
-0000ffa0: 3d74 6d70 5f69 6e66 6f2e 6765 6f6d 6574  =tmp_info.geomet
-0000ffb0: 7279 636f 6c75 6d6e 290d 0a20 2020 2020  rycolumn)..     
-0000ffc0: 2020 2020 2020 2020 2020 2020 2020 205f                 _
-0000ffd0: 6f67 725f 7574 696c 2e76 6563 746f 725f  ogr_util.vector_
-0000ffe0: 7472 616e 736c 6174 6528 0d0a 2020 2020  translate(..    
-0000fff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010000: 2020 2020 696e 7075 745f 7061 7468 3d6f      input_path=o
-00010010: 7574 7075 745f 746d 7032 5f66 696e 616c  utput_tmp2_final
-00010020: 5f70 6174 682c 0d0a 2020 2020 2020 2020  _path,..        
-00010030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010040: 6f75 7470 7574 5f70 6174 683d 6f75 7470  output_path=outp
-00010050: 7574 5f74 6d70 335f 7768 6572 655f 7061  ut_tmp3_where_pa
-00010060: 7468 2c0d 0a20 2020 2020 2020 2020 2020  th,..           
-00010070: 2020 2020 2020 2020 2020 2020 206f 7574               out
-00010080: 7075 745f 6c61 7965 723d 6f75 7470 7574  put_layer=output
-00010090: 5f6c 6179 6572 2c0d 0a20 2020 2020 2020  _layer,..       
-000100a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000100b0: 2066 6f72 6365 5f6f 7574 7075 745f 6765   force_output_ge
-000100c0: 6f6d 6574 7279 7479 7065 3d6f 7574 7075  ometrytype=outpu
-000100d0: 745f 6765 6f6d 6574 7279 7479 7065 2c0d  t_geometrytype,.
-000100e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000100f0: 2020 2020 2020 2020 2073 716c 5f73 746d           sql_stm
-00010100: 743d 7371 6c5f 7374 6d74 2c0d 0a20 2020  t=sql_stmt,..   
-00010110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010120: 2020 2020 2073 716c 5f64 6961 6c65 6374       sql_dialect
-00010130: 3d22 5351 4c49 5445 222c 0d0a 2020 2020  ="SQLITE",..    
-00010140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010150: 2020 2020 6f70 7469 6f6e 733d 7b22 4c41      options={"LA
-00010160: 5945 525f 4352 4541 5449 4f4e 2e53 5041  YER_CREATION.SPA
-00010170: 5449 414c 5f49 4e44 4558 223a 2054 7275  TIAL_INDEX": Tru
-00010180: 657d 2c0d 0a20 2020 2020 2020 2020 2020  e},..           
-00010190: 2020 2020 2020 2020 2029 0d0a 2020 2020           )..    
-000101a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000101b0: 6f75 7470 7574 5f74 6d70 325f 6669 6e61  output_tmp2_fina
-000101c0: 6c5f 7061 7468 203d 206f 7574 7075 745f  l_path = output_
-000101d0: 746d 7033 5f77 6865 7265 5f70 6174 680d  tmp3_where_path.
-000101e0: 0a0d 0a20 2020 2020 2020 2020 2020 2020  ...             
-000101f0: 2020 2023 204e 6f77 2077 6520 6172 6520     # Now we are 
-00010200: 7265 6164 7920 746f 206d 6f76 6520 7468  ready to move th
-00010210: 6520 7265 7375 6c74 2074 6f20 7468 6520  e result to the 
-00010220: 6669 6e61 6c20 7370 6f74 2e2e 2e0d 0a20  final spot..... 
-00010230: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-00010240: 666f 2e6d 6f76 6528 6f75 7470 7574 5f74  fo.move(output_t
-00010250: 6d70 325f 6669 6e61 6c5f 7061 7468 2c20  mp2_final_path, 
-00010260: 6f75 7470 7574 5f70 6174 6829 0d0a 0d0a  output_path)....
-00010270: 2020 2020 2020 2020 6669 6e61 6c6c 793a          finally:
-00010280: 0d0a 2020 2020 2020 2020 2020 2020 7368  ..            sh
-00010290: 7574 696c 2e72 6d74 7265 6528 7465 6d70  util.rmtree(temp
-000102a0: 6469 722c 2069 676e 6f72 655f 6572 726f  dir, ignore_erro
-000102b0: 7273 3d54 7275 6529 0d0a 2020 2020 656c  rs=True)..    el
-000102c0: 7365 3a0d 0a20 2020 2020 2020 2072 6169  se:..        rai
-000102d0: 7365 204e 6f74 496d 706c 656d 656e 7465  se NotImplemente
-000102e0: 6445 7272 6f72 280d 0a20 2020 2020 2020  dError(..       
-000102f0: 2020 2020 2066 2255 6e73 7570 706f 7274       f"Unsupport
-00010300: 6564 2069 6e70 7574 2067 656f 6d65 7472  ed input geometr
-00010310: 7974 7970 653a 207b 696e 7075 745f 6c61  ytype: {input_la
-00010320: 7965 7269 6e66 6f2e 6765 6f6d 6574 7279  yerinfo.geometry
-00010330: 7479 7065 7d22 0d0a 2020 2020 2020 2020  type}"..        
-00010340: 290d 0a0d 0a20 2020 2023 2052 6574 7572  )....    # Retur
-00010350: 6e20 7265 7375 6c74 2069 6e66 6f0d 0a20  n result info.. 
-00010360: 2020 2072 6573 756c 745f 696e 666f 5b22     result_info["
-00010370: 6d65 7373 6167 6522 5d20 3d20 6622 5265  message"] = f"Re
-00010380: 6164 792c 2074 6f6f 6b20 7b64 6174 6574  ady, took {datet
-00010390: 696d 652e 6e6f 7728 292d 7374 6172 745f  ime.now()-start_
-000103a0: 7469 6d65 7d22 0d0a 2020 2020 6c6f 6767  time}"..    logg
-000103b0: 6572 2e69 6e66 6f28 7265 7375 6c74 5f69  er.info(result_i
-000103c0: 6e66 6f5b 226d 6573 7361 6765 225d 290d  nfo["message"]).
-000103d0: 0a20 2020 2072 6574 7572 6e20 7265 7375  .    return resu
-000103e0: 6c74 5f69 6e66 6f0d 0a0d 0a0d 0a64 6566  lt_info......def
-000103f0: 205f 6469 7373 6f6c 7665 5f70 6f6c 7967   _dissolve_polyg
-00010400: 6f6e 735f 7061 7373 280d 0a20 2020 2069  ons_pass(..    i
-00010410: 6e70 7574 5f70 6174 683a 2050 6174 682c  nput_path: Path,
-00010420: 0d0a 2020 2020 6f75 7470 7574 5f6e 6f74  ..    output_not
-00010430: 6f6e 626f 7264 6572 5f70 6174 683a 2050  onborder_path: P
-00010440: 6174 682c 0d0a 2020 2020 6f75 7470 7574  ath,..    output
-00010450: 5f6f 6e62 6f72 6465 725f 7061 7468 3a20  _onborder_path: 
-00010460: 5061 7468 2c0d 0a20 2020 2065 7870 6c6f  Path,..    explo
-00010470: 6465 636f 6c6c 6563 7469 6f6e 733a 2062  decollections: b
-00010480: 6f6f 6c2c 0d0a 2020 2020 6772 6f75 7062  ool,..    groupb
-00010490: 795f 636f 6c75 6d6e 733a 204f 7074 696f  y_columns: Optio
-000104a0: 6e61 6c5b 4974 6572 6162 6c65 5b73 7472  nal[Iterable[str
-000104b0: 5d5d 2c0d 0a20 2020 2061 6767 5f63 6f6c  ]],..    agg_col
-000104c0: 756d 6e73 3a20 4f70 7469 6f6e 616c 5b64  umns: Optional[d
-000104d0: 6963 745d 2c0d 0a20 2020 2074 696c 6573  ict],..    tiles
-000104e0: 5f67 6466 3a20 6770 642e 4765 6f44 6174  _gdf: gpd.GeoDat
-000104f0: 6146 7261 6d65 2c0d 0a20 2020 2069 6e70  aFrame,..    inp
-00010500: 7574 5f6c 6179 6572 3a20 4f70 7469 6f6e  ut_layer: Option
-00010510: 616c 5b73 7472 5d2c 0d0a 2020 2020 6f75  al[str],..    ou
-00010520: 7470 7574 5f6c 6179 6572 3a20 4f70 7469  tput_layer: Opti
-00010530: 6f6e 616c 5b73 7472 5d2c 0d0a 2020 2020  onal[str],..    
-00010540: 6772 6964 7369 7a65 3a20 666c 6f61 742c  gridsize: float,
-00010550: 0d0a 2020 2020 6b65 6570 5f65 6d70 7479  ..    keep_empty
-00010560: 5f67 656f 6d73 3a20 626f 6f6c 2c0d 0a20  _geoms: bool,.. 
-00010570: 2020 206e 625f 7061 7261 6c6c 656c 3a20     nb_parallel: 
-00010580: 696e 742c 0d0a 293a 0d0a 2020 2020 7374  int,..):..    st
-00010590: 6172 745f 7469 6d65 203d 2064 6174 6574  art_time = datet
-000105a0: 696d 652e 6e6f 7728 290d 0a0d 0a20 2020  ime.now()....   
-000105b0: 2023 204d 616b 6520 7375 7265 2074 6865   # Make sure the
-000105c0: 2069 6e70 7574 2066 696c 6520 6861 7320   input file has 
-000105d0: 6120 7370 6174 6961 6c20 696e 6465 780d  a spatial index.
-000105e0: 0a20 2020 2067 666f 2e63 7265 6174 655f  .    gfo.create_
-000105f0: 7370 6174 6961 6c5f 696e 6465 7828 696e  spatial_index(in
-00010600: 7075 745f 7061 7468 2c20 6c61 7965 723d  put_path, layer=
-00010610: 696e 7075 745f 6c61 7965 722c 2065 7869  input_layer, exi
-00010620: 7374 5f6f 6b3d 5472 7565 290d 0a0d 0a20  st_ok=True).... 
-00010630: 2020 2023 2053 7461 7274 2063 616c 6375     # Start calcu
-00010640: 6c61 7469 6f6e 2069 6e20 7061 7261 6c6c  lation in parall
-00010650: 656c 0d0a 2020 2020 696e 7075 745f 6c61  el..    input_la
-00010660: 7965 7269 6e66 6f20 3d20 6766 6f2e 6765  yerinfo = gfo.ge
-00010670: 745f 6c61 7965 7269 6e66 6f28 696e 7075  t_layerinfo(inpu
-00010680: 745f 7061 7468 2c20 696e 7075 745f 6c61  t_path, input_la
-00010690: 7965 7229 0d0a 0d0a 2020 2020 2320 5072  yer)....    # Pr
-000106a0: 6f63 6573 7369 6e67 2069 6e20 7468 7265  ocessing in thre
-000106b0: 6164 7320 6973 2032 7820 6661 7374 6572  ads is 2x faster
-000106c0: 2066 6f72 2073 6d61 6c6c 2064 6174 6173   for small datas
-000106d0: 6574 7320 286f 6e20 5769 6e64 6f77 7329  ets (on Windows)
-000106e0: 0d0a 2020 2020 6361 6c63 756c 6174 655f  ..    calculate_
-000106f0: 696e 5f74 6872 6561 6473 203d 2054 7275  in_threads = Tru
-00010700: 6520 6966 2069 6e70 7574 5f6c 6179 6572  e if input_layer
-00010710: 696e 666f 2e66 6561 7475 7265 636f 756e  info.featurecoun
-00010720: 7420 3c3d 2031 3030 2065 6c73 6520 4661  t <= 100 else Fa
-00010730: 6c73 650d 0a20 2020 2077 6974 6820 5f70  lse..    with _p
-00010740: 726f 6365 7373 696e 675f 7574 696c 2e50  rocessing_util.P
-00010750: 6f6f 6c65 6445 7865 6375 746f 7246 6163  ooledExecutorFac
-00010760: 746f 7279 280d 0a20 2020 2020 2020 2074  tory(..        t
-00010770: 6872 6561 6470 6f6f 6c3d 6361 6c63 756c  hreadpool=calcul
-00010780: 6174 655f 696e 5f74 6872 6561 6473 2c0d  ate_in_threads,.
-00010790: 0a20 2020 2020 2020 206d 6178 5f77 6f72  .        max_wor
-000107a0: 6b65 7273 3d6e 625f 7061 7261 6c6c 656c  kers=nb_parallel
-000107b0: 2c0d 0a20 2020 2020 2020 2069 6e69 7469  ,..        initi
-000107c0: 616c 697a 6572 3d5f 7072 6f63 6573 7369  alizer=_processi
-000107d0: 6e67 5f75 7469 6c2e 696e 6974 6961 6c69  ng_util.initiali
-000107e0: 7a65 5f77 6f72 6b65 7228 292c 0d0a 2020  ze_worker(),..  
-000107f0: 2020 2920 6173 2063 616c 6375 6c61 7465    ) as calculate
-00010800: 5f70 6f6f 6c3a 0d0a 2020 2020 2020 2020  _pool:..        
-00010810: 2320 5072 6570 6172 6520 6f75 7470 7574  # Prepare output
-00010820: 2066 696c 656e 616d 650d 0a20 2020 2020   filename..     
-00010830: 2020 2074 656d 7064 6972 203d 206f 7574     tempdir = out
-00010840: 7075 745f 6f6e 626f 7264 6572 5f70 6174  put_onborder_pat
-00010850: 682e 7061 7265 6e74 0d0a 0d0a 2020 2020  h.parent....    
-00010860: 2020 2020 6261 7463 6865 733a 2044 6963      batches: Dic
-00010870: 745b 696e 742c 2064 6963 745d 203d 207b  t[int, dict] = {
-00010880: 7d0d 0a20 2020 2020 2020 206e 625f 6261  }..        nb_ba
-00010890: 7463 6865 7320 3d20 6c65 6e28 7469 6c65  tches = len(tile
-000108a0: 735f 6764 6629 0d0a 2020 2020 2020 2020  s_gdf)..        
-000108b0: 6e62 5f62 6174 6368 6573 5f64 6f6e 6520  nb_batches_done 
-000108c0: 3d20 300d 0a20 2020 2020 2020 2066 7574  = 0..        fut
-000108d0: 7572 655f 746f 5f62 6174 6368 5f69 6420  ure_to_batch_id 
-000108e0: 3d20 7b7d 0d0a 2020 2020 2020 2020 6e62  = {}..        nb
-000108f0: 5f72 6f77 735f 646f 6e65 203d 2030 0d0a  _rows_done = 0..
-00010900: 2020 2020 2020 2020 666f 7220 6261 7463          for batc
-00010910: 685f 6964 2c20 7469 6c65 5f72 6f77 2069  h_id, tile_row i
-00010920: 6e20 656e 756d 6572 6174 6528 7469 6c65  n enumerate(tile
-00010930: 735f 6764 662e 6974 6572 7475 706c 6573  s_gdf.itertuples
-00010940: 2829 293a 0d0a 2020 2020 2020 2020 2020  ()):..          
-00010950: 2020 6261 7463 6865 735b 6261 7463 685f    batches[batch_
-00010960: 6964 5d20 3d20 7b7d 0d0a 2020 2020 2020  id] = {}..      
-00010970: 2020 2020 2020 6261 7463 6865 735b 6261        batches[ba
-00010980: 7463 685f 6964 5d5b 226c 6179 6572 225d  tch_id]["layer"]
-00010990: 203d 206f 7574 7075 745f 6c61 7965 720d   = output_layer.
-000109a0: 0a20 2020 2020 2020 2020 2020 2062 6174  .            bat
-000109b0: 6368 6573 5b62 6174 6368 5f69 645d 5b22  ches[batch_id]["
-000109c0: 626f 756e 6473 225d 203d 2074 696c 655f  bounds"] = tile_
-000109d0: 726f 772e 6765 6f6d 6574 7279 2e62 6f75  row.geometry.bou
-000109e0: 6e64 730d 0a0d 0a20 2020 2020 2020 2020  nds....         
-000109f0: 2020 2023 204f 7574 7075 7420 6561 6368     # Output each
-00010a00: 2062 6174 6368 2074 6f20 6120 7365 7065   batch to a sepe
-00010a10: 7261 7465 2074 656d 706f 7261 7279 2066  rate temporary f
-00010a20: 696c 652c 206f 7468 6572 7769 7365 2074  ile, otherwise t
-00010a30: 6865 7265 0d0a 2020 2020 2020 2020 2020  here..          
-00010a40: 2020 2320 6172 6520 7469 6d65 6f75 7420    # are timeout 
-00010a50: 6973 7375 6573 2077 6865 6e20 7072 6f63  issues when proc
-00010a60: 6573 7369 6e67 206c 6172 6765 2066 696c  essing large fil
-00010a70: 6573 0d0a 2020 2020 2020 2020 2020 2020  es..            
-00010a80: 7375 6666 6978 203d 206f 7574 7075 745f  suffix = output_
-00010a90: 6e6f 746f 6e62 6f72 6465 725f 7061 7468  notonborder_path
-00010aa0: 2e73 7566 6669 780d 0a20 2020 2020 2020  .suffix..       
-00010ab0: 2020 2020 206e 616d 6520 3d20 6622 7b6f       name = f"{o
-00010ac0: 7574 7075 745f 6e6f 746f 6e62 6f72 6465  utput_notonborde
-00010ad0: 725f 7061 7468 2e73 7465 6d7d 5f7b 6261  r_path.stem}_{ba
-00010ae0: 7463 685f 6964 7d7b 7375 6666 6978 7d22  tch_id}{suffix}"
-00010af0: 0d0a 2020 2020 2020 2020 2020 2020 6f75  ..            ou
-00010b00: 7470 7574 5f6e 6f74 6f6e 626f 7264 6572  tput_notonborder
-00010b10: 5f74 6d70 5f70 6172 7469 616c 5f70 6174  _tmp_partial_pat
-00010b20: 6820 3d20 7465 6d70 6469 7220 2f20 6e61  h = tempdir / na
-00010b30: 6d65 0d0a 2020 2020 2020 2020 2020 2020  me..            
-00010b40: 6261 7463 6865 735b 6261 7463 685f 6964  batches[batch_id
-00010b50: 5d5b 0d0a 2020 2020 2020 2020 2020 2020  ][..            
-00010b60: 2020 2020 226f 7574 7075 745f 6e6f 746f      "output_noto
-00010b70: 6e62 6f72 6465 725f 746d 705f 7061 7274  nborder_tmp_part
-00010b80: 6961 6c5f 7061 7468 220d 0a20 2020 2020  ial_path"..     
-00010b90: 2020 2020 2020 205d 203d 206f 7574 7075         ] = outpu
-00010ba0: 745f 6e6f 746f 6e62 6f72 6465 725f 746d  t_notonborder_tm
-00010bb0: 705f 7061 7274 6961 6c5f 7061 7468 0d0a  p_partial_path..
-00010bc0: 2020 2020 2020 2020 2020 2020 6e61 6d65              name
-00010bd0: 203d 2066 227b 6f75 7470 7574 5f6f 6e62   = f"{output_onb
-00010be0: 6f72 6465 725f 7061 7468 2e73 7465 6d7d  order_path.stem}
-00010bf0: 5f7b 6261 7463 685f 6964 7d7b 7375 6666  _{batch_id}{suff
-00010c00: 6978 7d22 0d0a 2020 2020 2020 2020 2020  ix}"..          
-00010c10: 2020 6f75 7470 7574 5f6f 6e62 6f72 6465    output_onborde
-00010c20: 725f 746d 705f 7061 7274 6961 6c5f 7061  r_tmp_partial_pa
-00010c30: 7468 203d 2074 656d 7064 6972 202f 206e  th = tempdir / n
-00010c40: 616d 650d 0a20 2020 2020 2020 2020 2020  ame..           
-00010c50: 2062 6174 6368 6573 5b62 6174 6368 5f69   batches[batch_i
-00010c60: 645d 5b0d 0a20 2020 2020 2020 2020 2020  d][..           
-00010c70: 2020 2020 2022 6f75 7470 7574 5f6f 6e62       "output_onb
-00010c80: 6f72 6465 725f 746d 705f 7061 7274 6961  order_tmp_partia
-00010c90: 6c5f 7061 7468 220d 0a20 2020 2020 2020  l_path"..       
-00010ca0: 2020 2020 205d 203d 206f 7574 7075 745f       ] = output_
-00010cb0: 6f6e 626f 7264 6572 5f74 6d70 5f70 6172  onborder_tmp_par
-00010cc0: 7469 616c 5f70 6174 680d 0a0d 0a20 2020  tial_path....   
-00010cd0: 2020 2020 2020 2020 2023 2047 6574 2074           # Get t
-00010ce0: 696c 655f 6964 2069 6620 7072 6573 656e  ile_id if presen
-00010cf0: 740d 0a20 2020 2020 2020 2020 2020 2074  t..            t
-00010d00: 696c 655f 6964 203d 2074 696c 655f 726f  ile_id = tile_ro
-00010d10: 772e 7469 6c65 5f69 6420 6966 2022 7469  w.tile_id if "ti
-00010d20: 6c65 5f69 6422 2069 6e20 7469 6c65 5f72  le_id" in tile_r
-00010d30: 6f77 2e5f 6669 656c 6473 2065 6c73 6520  ow._fields else 
-00010d40: 4e6f 6e65 0d0a 0d0a 2020 2020 2020 2020  None....        
-00010d50: 2020 2020 6675 7475 7265 203d 2063 616c      future = cal
-00010d60: 6375 6c61 7465 5f70 6f6f 6c2e 7375 626d  culate_pool.subm
-00010d70: 6974 280d 0a20 2020 2020 2020 2020 2020  it(..           
-00010d80: 2020 2020 205f 6469 7373 6f6c 7665 5f70       _dissolve_p
-00010d90: 6f6c 7967 6f6e 732c 0d0a 2020 2020 2020  olygons,..      
-00010da0: 2020 2020 2020 2020 2020 696e 7075 745f            input_
-00010db0: 7061 7468 3d69 6e70 7574 5f70 6174 682c  path=input_path,
-00010dc0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00010dd0: 2020 6f75 7470 7574 5f6e 6f74 6f6e 626f    output_notonbo
-00010de0: 7264 6572 5f70 6174 683d 6f75 7470 7574  rder_path=output
-00010df0: 5f6e 6f74 6f6e 626f 7264 6572 5f74 6d70  _notonborder_tmp
-00010e00: 5f70 6172 7469 616c 5f70 6174 682c 0d0a  _partial_path,..
-00010e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e20: 6f75 7470 7574 5f6f 6e62 6f72 6465 725f  output_onborder_
-00010e30: 7061 7468 3d6f 7574 7075 745f 6f6e 626f  path=output_onbo
-00010e40: 7264 6572 5f74 6d70 5f70 6172 7469 616c  rder_tmp_partial
-00010e50: 5f70 6174 682c 0d0a 2020 2020 2020 2020  _path,..        
-00010e60: 2020 2020 2020 2020 6578 706c 6f64 6563          explodec
-00010e70: 6f6c 6c65 6374 696f 6e73 3d65 7870 6c6f  ollections=explo
-00010e80: 6465 636f 6c6c 6563 7469 6f6e 732c 0d0a  decollections,..
-00010e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010ea0: 6772 6f75 7062 795f 636f 6c75 6d6e 733d  groupby_columns=
-00010eb0: 6772 6f75 7062 795f 636f 6c75 6d6e 732c  groupby_columns,
-00010ec0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00010ed0: 2020 6167 675f 636f 6c75 6d6e 733d 6167    agg_columns=ag
-00010ee0: 675f 636f 6c75 6d6e 732c 0d0a 2020 2020  g_columns,..    
-00010ef0: 2020 2020 2020 2020 2020 2020 696e 7075              inpu
-00010f00: 745f 6765 6f6d 6574 7279 7479 7065 3d69  t_geometrytype=i
-00010f10: 6e70 7574 5f6c 6179 6572 696e 666f 2e67  nput_layerinfo.g
-00010f20: 656f 6d65 7472 7974 7970 652c 0d0a 2020  eometrytype,..  
-00010f30: 2020 2020 2020 2020 2020 2020 2020 696e                in
-00010f40: 7075 745f 6c61 7965 723d 696e 7075 745f  put_layer=input_
-00010f50: 6c61 7965 722c 0d0a 2020 2020 2020 2020  layer,..        
-00010f60: 2020 2020 2020 2020 6f75 7470 7574 5f6c          output_l
-00010f70: 6179 6572 3d6f 7574 7075 745f 6c61 7965  ayer=output_laye
-00010f80: 722c 0d0a 2020 2020 2020 2020 2020 2020  r,..            
-00010f90: 2020 2020 6262 6f78 3d74 696c 655f 726f      bbox=tile_ro
-00010fa0: 772e 6765 6f6d 6574 7279 2e62 6f75 6e64  w.geometry.bound
-00010fb0: 732c 0d0a 2020 2020 2020 2020 2020 2020  s,..            
-00010fc0: 2020 2020 7469 6c65 5f69 643d 7469 6c65      tile_id=tile
-00010fd0: 5f69 642c 0d0a 2020 2020 2020 2020 2020  _id,..          
-00010fe0: 2020 2020 2020 6772 6964 7369 7a65 3d67        gridsize=g
-00010ff0: 7269 6473 697a 652c 0d0a 2020 2020 2020  ridsize,..      
-00011000: 2020 2020 2020 2020 2020 6b65 6570 5f65            keep_e
-00011010: 6d70 7479 5f67 656f 6d73 3d6b 6565 705f  mpty_geoms=keep_
-00011020: 656d 7074 795f 6765 6f6d 732c 0d0a 2020  empty_geoms,..  
-00011030: 2020 2020 2020 2020 2020 290d 0a20 2020            )..   
-00011040: 2020 2020 2020 2020 2066 7574 7572 655f           future_
-00011050: 746f 5f62 6174 6368 5f69 645b 6675 7475  to_batch_id[futu
-00011060: 7265 5d20 3d20 6261 7463 685f 6964 0d0a  re] = batch_id..
-00011070: 0d0a 2020 2020 2020 2020 2320 4c6f 6f70  ..        # Loop
-00011080: 2074 696c 6c20 616c 6c20 7061 7261 6c6c   till all parall
-00011090: 656c 2070 726f 6365 7373 6573 2061 7265  el processes are
-000110a0: 2072 6561 6479 2c20 6275 7420 7072 6f63   ready, but proc
-000110b0: 6573 7320 6561 6368 206f 6e65 0d0a 2020  ess each one..  
-000110c0: 2020 2020 2020 2320 7468 6174 2069 7320        # that is 
-000110d0: 7265 6164 7920 616c 7265 6164 790d 0a20  ready already.. 
-000110e0: 2020 2020 2020 205f 6765 6e65 7261 6c5f         _general_
-000110f0: 7574 696c 2e72 6570 6f72 745f 7072 6f67  util.report_prog
-00011100: 7265 7373 280d 0a20 2020 2020 2020 2020  ress(..         
-00011110: 2020 2073 7461 7274 5f74 696d 652c 206e     start_time, n
-00011120: 625f 6261 7463 6865 735f 646f 6e65 2c20  b_batches_done, 
-00011130: 6e62 5f62 6174 6368 6573 2c20 2264 6973  nb_batches, "dis
-00011140: 736f 6c76 6522 0d0a 2020 2020 2020 2020  solve"..        
-00011150: 290d 0a20 2020 2020 2020 2066 6f72 2066  )..        for f
-00011160: 7574 7572 6520 696e 2066 7574 7572 6573  uture in futures
-00011170: 2e61 735f 636f 6d70 6c65 7465 6428 6675  .as_completed(fu
-00011180: 7475 7265 5f74 6f5f 6261 7463 685f 6964  ture_to_batch_id
-00011190: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-000111a0: 7472 793a 0d0a 2020 2020 2020 2020 2020  try:..          
-000111b0: 2020 2020 2020 2320 4966 2074 6865 2063        # If the c
-000111c0: 616c 6375 6c61 7465 2067 6176 6520 7265  alculate gave re
-000111d0: 7375 6c74 730d 0a20 2020 2020 2020 2020  sults..         
-000111e0: 2020 2020 2020 206e 625f 6261 7463 6865         nb_batche
-000111f0: 735f 646f 6e65 202b 3d20 310d 0a20 2020  s_done += 1..   
-00011200: 2020 2020 2020 2020 2020 2020 2062 6174               bat
-00011210: 6368 5f69 6420 3d20 6675 7475 7265 5f74  ch_id = future_t
-00011220: 6f5f 6261 7463 685f 6964 5b66 7574 7572  o_batch_id[futur
-00011230: 655d 0d0a 2020 2020 2020 2020 2020 2020  e]..            
-00011240: 2020 2020 7265 7375 6c74 203d 2066 7574      result = fut
-00011250: 7572 652e 7265 7375 6c74 2829 0d0a 0d0a  ure.result()....
-00011260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011270: 6966 2072 6573 756c 7420 6973 206e 6f74  if result is not
-00011280: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-00011290: 2020 2020 2020 2020 2020 2020 6e62 5f72              nb_r
-000112a0: 6f77 735f 646f 6e65 202b 3d20 7265 7375  ows_done += resu
-000112b0: 6c74 5b22 6e62 5f72 6f77 735f 646f 6e65  lt["nb_rows_done
-000112c0: 225d 0d0a 2020 2020 2020 2020 2020 2020  "]..            
-000112d0: 2020 2020 2020 2020 6966 2072 6573 756c          if resul
-000112e0: 745b 226e 625f 726f 7773 5f64 6f6e 6522  t["nb_rows_done"
-000112f0: 5d20 3e20 3020 616e 6420 7265 7375 6c74  ] > 0 and result
-00011300: 5b22 746f 7461 6c5f 7469 6d65 225d 203e  ["total_time"] >
-00011310: 2030 3a0d 0a20 2020 2020 2020 2020 2020   0:..           
-00011320: 2020 2020 2020 2020 2020 2020 2072 6f77               row
-00011330: 735f 7065 725f 7365 6320 3d20 726f 756e  s_per_sec = roun
-00011340: 6428 0d0a 2020 2020 2020 2020 2020 2020  d(..            
+0000f9e0: 2020 2020 206f 7574 7075 745f 6c61 7965       output_laye
+0000f9f0: 723d 6f75 7470 7574 5f6c 6179 6572 2c0a  r=output_layer,.
+0000fa00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fa10: 2020 2020 2020 2020 666f 7263 655f 6f75          force_ou
+0000fa20: 7470 7574 5f67 656f 6d65 7472 7974 7970  tput_geometrytyp
+0000fa30: 653d 6f75 7470 7574 5f67 656f 6d65 7472  e=output_geometr
+0000fa40: 7974 7970 652c 0a20 2020 2020 2020 2020  ytype,.         
+0000fa50: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000fa60: 716c 5f73 746d 743d 7371 6c5f 7374 6d74  ql_stmt=sql_stmt
+0000fa70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000fa80: 2020 2020 2020 2020 2020 7371 6c5f 6469            sql_di
+0000fa90: 616c 6563 743d 2253 514c 4954 4522 2c0a  alect="SQLITE",.
+0000faa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fab0: 2020 2020 2020 2020 6f70 7469 6f6e 733d          options=
+0000fac0: 7b22 4c41 5945 525f 4352 4541 5449 4f4e  {"LAYER_CREATION
+0000fad0: 2e53 5041 5449 414c 5f49 4e44 4558 223a  .SPATIAL_INDEX":
+0000fae0: 2054 7275 657d 2c0a 2020 2020 2020 2020   True},.        
+0000faf0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0000fb00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fb10: 2020 6f75 7470 7574 5f74 6d70 325f 6669    output_tmp2_fi
+0000fb20: 6e61 6c5f 7061 7468 203d 206f 7574 7075  nal_path = outpu
+0000fb30: 745f 746d 7033 5f77 6865 7265 5f70 6174  t_tmp3_where_pat
+0000fb40: 680a 0a20 2020 2020 2020 2020 2020 2020  h..             
+0000fb50: 2020 2023 204e 6f77 2077 6520 6172 6520     # Now we are 
+0000fb60: 7265 6164 7920 746f 206d 6f76 6520 7468  ready to move th
+0000fb70: 6520 7265 7375 6c74 2074 6f20 7468 6520  e result to the 
+0000fb80: 6669 6e61 6c20 7370 6f74 2e2e 2e0a 2020  final spot....  
+0000fb90: 2020 2020 2020 2020 2020 2020 2020 6766                gf
+0000fba0: 6f2e 6d6f 7665 286f 7574 7075 745f 746d  o.move(output_tm
+0000fbb0: 7032 5f66 696e 616c 5f70 6174 682c 206f  p2_final_path, o
+0000fbc0: 7574 7075 745f 7061 7468 290a 0a20 2020  utput_path)..   
+0000fbd0: 2020 2020 2066 696e 616c 6c79 3a0a 2020       finally:.  
+0000fbe0: 2020 2020 2020 2020 2020 7368 7574 696c            shutil
+0000fbf0: 2e72 6d74 7265 6528 7465 6d70 6469 722c  .rmtree(tempdir,
+0000fc00: 2069 676e 6f72 655f 6572 726f 7273 3d54   ignore_errors=T
+0000fc10: 7275 6529 0a20 2020 2065 6c73 653a 0a20  rue).    else:. 
+0000fc20: 2020 2020 2020 2072 6169 7365 204e 6f74         raise Not
+0000fc30: 496d 706c 656d 656e 7465 6445 7272 6f72  ImplementedError
+0000fc40: 280a 2020 2020 2020 2020 2020 2020 6622  (.            f"
+0000fc50: 556e 7375 7070 6f72 7465 6420 696e 7075  Unsupported inpu
+0000fc60: 7420 6765 6f6d 6574 7279 7479 7065 3a20  t geometrytype: 
+0000fc70: 7b69 6e70 7574 5f6c 6179 6572 696e 666f  {input_layerinfo
+0000fc80: 2e67 656f 6d65 7472 7974 7970 657d 220a  .geometrytype}".
+0000fc90: 2020 2020 2020 2020 290a 0a20 2020 2023          )..    #
+0000fca0: 2052 6574 7572 6e20 7265 7375 6c74 2069   Return result i
+0000fcb0: 6e66 6f0a 2020 2020 7265 7375 6c74 5f69  nfo.    result_i
+0000fcc0: 6e66 6f5b 226d 6573 7361 6765 225d 203d  nfo["message"] =
+0000fcd0: 2066 2252 6561 6479 2c20 746f 6f6b 207b   f"Ready, took {
+0000fce0: 6461 7465 7469 6d65 2e6e 6f77 2829 2d73  datetime.now()-s
+0000fcf0: 7461 7274 5f74 696d 657d 220a 2020 2020  tart_time}".    
+0000fd00: 6c6f 6767 6572 2e69 6e66 6f28 7265 7375  logger.info(resu
+0000fd10: 6c74 5f69 6e66 6f5b 226d 6573 7361 6765  lt_info["message
+0000fd20: 225d 290a 2020 2020 7265 7475 726e 2072  "]).    return r
+0000fd30: 6573 756c 745f 696e 666f 0a0a 0a64 6566  esult_info...def
+0000fd40: 205f 6469 7373 6f6c 7665 5f70 6f6c 7967   _dissolve_polyg
+0000fd50: 6f6e 735f 7061 7373 280a 2020 2020 696e  ons_pass(.    in
+0000fd60: 7075 745f 7061 7468 3a20 5061 7468 2c0a  put_path: Path,.
+0000fd70: 2020 2020 6f75 7470 7574 5f6e 6f74 6f6e      output_noton
+0000fd80: 626f 7264 6572 5f70 6174 683a 2050 6174  border_path: Pat
+0000fd90: 682c 0a20 2020 206f 7574 7075 745f 6f6e  h,.    output_on
+0000fda0: 626f 7264 6572 5f70 6174 683a 2050 6174  border_path: Pat
+0000fdb0: 682c 0a20 2020 2065 7870 6c6f 6465 636f  h,.    explodeco
+0000fdc0: 6c6c 6563 7469 6f6e 733a 2062 6f6f 6c2c  llections: bool,
+0000fdd0: 0a20 2020 2067 726f 7570 6279 5f63 6f6c  .    groupby_col
+0000fde0: 756d 6e73 3a20 4f70 7469 6f6e 616c 5b49  umns: Optional[I
+0000fdf0: 7465 7261 626c 655b 7374 725d 5d2c 0a20  terable[str]],. 
+0000fe00: 2020 2061 6767 5f63 6f6c 756d 6e73 3a20     agg_columns: 
+0000fe10: 4f70 7469 6f6e 616c 5b64 6963 745d 2c0a  Optional[dict],.
+0000fe20: 2020 2020 7469 6c65 735f 6764 663a 2067      tiles_gdf: g
+0000fe30: 7064 2e47 656f 4461 7461 4672 616d 652c  pd.GeoDataFrame,
+0000fe40: 0a20 2020 2069 6e70 7574 5f6c 6179 6572  .    input_layer
+0000fe50: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d2c  : Optional[str],
+0000fe60: 0a20 2020 206f 7574 7075 745f 6c61 7965  .    output_laye
+0000fe70: 723a 204f 7074 696f 6e61 6c5b 7374 725d  r: Optional[str]
+0000fe80: 2c0a 2020 2020 6772 6964 7369 7a65 3a20  ,.    gridsize: 
+0000fe90: 666c 6f61 742c 0a20 2020 206b 6565 705f  float,.    keep_
+0000fea0: 656d 7074 795f 6765 6f6d 733a 2062 6f6f  empty_geoms: boo
+0000feb0: 6c2c 0a20 2020 206e 625f 7061 7261 6c6c  l,.    nb_parall
+0000fec0: 656c 3a20 696e 742c 0a29 3a0a 2020 2020  el: int,.):.    
+0000fed0: 7374 6172 745f 7469 6d65 203d 2064 6174  start_time = dat
+0000fee0: 6574 696d 652e 6e6f 7728 290a 0a20 2020  etime.now()..   
+0000fef0: 2023 204d 616b 6520 7375 7265 2074 6865   # Make sure the
+0000ff00: 2069 6e70 7574 2066 696c 6520 6861 7320   input file has 
+0000ff10: 6120 7370 6174 6961 6c20 696e 6465 780a  a spatial index.
+0000ff20: 2020 2020 6766 6f2e 6372 6561 7465 5f73      gfo.create_s
+0000ff30: 7061 7469 616c 5f69 6e64 6578 2869 6e70  patial_index(inp
+0000ff40: 7574 5f70 6174 682c 206c 6179 6572 3d69  ut_path, layer=i
+0000ff50: 6e70 7574 5f6c 6179 6572 2c20 6578 6973  nput_layer, exis
+0000ff60: 745f 6f6b 3d54 7275 6529 0a0a 2020 2020  t_ok=True)..    
+0000ff70: 2320 5374 6172 7420 6361 6c63 756c 6174  # Start calculat
+0000ff80: 696f 6e20 696e 2070 6172 616c 6c65 6c0a  ion in parallel.
+0000ff90: 2020 2020 696e 7075 745f 6c61 7965 7269      input_layeri
+0000ffa0: 6e66 6f20 3d20 6766 6f2e 6765 745f 6c61  nfo = gfo.get_la
+0000ffb0: 7965 7269 6e66 6f28 696e 7075 745f 7061  yerinfo(input_pa
+0000ffc0: 7468 2c20 696e 7075 745f 6c61 7965 7229  th, input_layer)
+0000ffd0: 0a0a 2020 2020 2320 5072 6f63 6573 7369  ..    # Processi
+0000ffe0: 6e67 2069 6e20 7468 7265 6164 7320 6973  ng in threads is
+0000fff0: 2032 7820 6661 7374 6572 2066 6f72 2073   2x faster for s
+00010000: 6d61 6c6c 2064 6174 6173 6574 7320 286f  mall datasets (o
+00010010: 6e20 5769 6e64 6f77 7329 0a20 2020 2063  n Windows).    c
+00010020: 616c 6375 6c61 7465 5f69 6e5f 7468 7265  alculate_in_thre
+00010030: 6164 7320 3d20 5472 7565 2069 6620 696e  ads = True if in
+00010040: 7075 745f 6c61 7965 7269 6e66 6f2e 6665  put_layerinfo.fe
+00010050: 6174 7572 6563 6f75 6e74 203c 3d20 3130  aturecount <= 10
+00010060: 3020 656c 7365 2046 616c 7365 0a20 2020  0 else False.   
+00010070: 2077 6974 6820 5f70 726f 6365 7373 696e   with _processin
+00010080: 675f 7574 696c 2e50 6f6f 6c65 6445 7865  g_util.PooledExe
+00010090: 6375 746f 7246 6163 746f 7279 280a 2020  cutorFactory(.  
+000100a0: 2020 2020 2020 7468 7265 6164 706f 6f6c        threadpool
+000100b0: 3d63 616c 6375 6c61 7465 5f69 6e5f 7468  =calculate_in_th
+000100c0: 7265 6164 732c 0a20 2020 2020 2020 206d  reads,.        m
+000100d0: 6178 5f77 6f72 6b65 7273 3d6e 625f 7061  ax_workers=nb_pa
+000100e0: 7261 6c6c 656c 2c0a 2020 2020 2020 2020  rallel,.        
+000100f0: 696e 6974 6961 6c69 7a65 723d 5f70 726f  initializer=_pro
+00010100: 6365 7373 696e 675f 7574 696c 2e69 6e69  cessing_util.ini
+00010110: 7469 616c 697a 655f 776f 726b 6572 2829  tialize_worker()
+00010120: 2c0a 2020 2020 2920 6173 2063 616c 6375  ,.    ) as calcu
+00010130: 6c61 7465 5f70 6f6f 6c3a 0a20 2020 2020  late_pool:.     
+00010140: 2020 2023 2050 7265 7061 7265 206f 7574     # Prepare out
+00010150: 7075 7420 6669 6c65 6e61 6d65 0a20 2020  put filename.   
+00010160: 2020 2020 2074 656d 7064 6972 203d 206f       tempdir = o
+00010170: 7574 7075 745f 6f6e 626f 7264 6572 5f70  utput_onborder_p
+00010180: 6174 682e 7061 7265 6e74 0a0a 2020 2020  ath.parent..    
+00010190: 2020 2020 6261 7463 6865 733a 2044 6963      batches: Dic
+000101a0: 745b 696e 742c 2064 6963 745d 203d 207b  t[int, dict] = {
+000101b0: 7d0a 2020 2020 2020 2020 6e62 5f62 6174  }.        nb_bat
+000101c0: 6368 6573 203d 206c 656e 2874 696c 6573  ches = len(tiles
+000101d0: 5f67 6466 290a 2020 2020 2020 2020 6e62  _gdf).        nb
+000101e0: 5f62 6174 6368 6573 5f64 6f6e 6520 3d20  _batches_done = 
+000101f0: 300a 2020 2020 2020 2020 6675 7475 7265  0.        future
+00010200: 5f74 6f5f 6261 7463 685f 6964 203d 207b  _to_batch_id = {
+00010210: 7d0a 2020 2020 2020 2020 6e62 5f72 6f77  }.        nb_row
+00010220: 735f 646f 6e65 203d 2030 0a20 2020 2020  s_done = 0.     
+00010230: 2020 2066 6f72 2062 6174 6368 5f69 642c     for batch_id,
+00010240: 2074 696c 655f 726f 7720 696e 2065 6e75   tile_row in enu
+00010250: 6d65 7261 7465 2874 696c 6573 5f67 6466  merate(tiles_gdf
+00010260: 2e69 7465 7274 7570 6c65 7328 2929 3a0a  .itertuples()):.
+00010270: 2020 2020 2020 2020 2020 2020 6261 7463              batc
+00010280: 6865 735b 6261 7463 685f 6964 5d20 3d20  hes[batch_id] = 
+00010290: 7b7d 0a20 2020 2020 2020 2020 2020 2062  {}.            b
+000102a0: 6174 6368 6573 5b62 6174 6368 5f69 645d  atches[batch_id]
+000102b0: 5b22 6c61 7965 7222 5d20 3d20 6f75 7470  ["layer"] = outp
+000102c0: 7574 5f6c 6179 6572 0a20 2020 2020 2020  ut_layer.       
+000102d0: 2020 2020 2062 6174 6368 6573 5b62 6174       batches[bat
+000102e0: 6368 5f69 645d 5b22 626f 756e 6473 225d  ch_id]["bounds"]
+000102f0: 203d 2074 696c 655f 726f 772e 6765 6f6d   = tile_row.geom
+00010300: 6574 7279 2e62 6f75 6e64 730a 0a20 2020  etry.bounds..   
+00010310: 2020 2020 2020 2020 2023 204f 7574 7075           # Outpu
+00010320: 7420 6561 6368 2062 6174 6368 2074 6f20  t each batch to 
+00010330: 6120 7365 7065 7261 7465 2074 656d 706f  a seperate tempo
+00010340: 7261 7279 2066 696c 652c 206f 7468 6572  rary file, other
+00010350: 7769 7365 2074 6865 7265 0a20 2020 2020  wise there.     
+00010360: 2020 2020 2020 2023 2061 7265 2074 696d         # are tim
+00010370: 656f 7574 2069 7373 7565 7320 7768 656e  eout issues when
+00010380: 2070 726f 6365 7373 696e 6720 6c61 7267   processing larg
+00010390: 6520 6669 6c65 730a 2020 2020 2020 2020  e files.        
+000103a0: 2020 2020 7375 6666 6978 203d 206f 7574      suffix = out
+000103b0: 7075 745f 6e6f 746f 6e62 6f72 6465 725f  put_notonborder_
+000103c0: 7061 7468 2e73 7566 6669 780a 2020 2020  path.suffix.    
+000103d0: 2020 2020 2020 2020 6e61 6d65 203d 2066          name = f
+000103e0: 227b 6f75 7470 7574 5f6e 6f74 6f6e 626f  "{output_notonbo
+000103f0: 7264 6572 5f70 6174 682e 7374 656d 7d5f  rder_path.stem}_
+00010400: 7b62 6174 6368 5f69 647d 7b73 7566 6669  {batch_id}{suffi
+00010410: 787d 220a 2020 2020 2020 2020 2020 2020  x}".            
+00010420: 6f75 7470 7574 5f6e 6f74 6f6e 626f 7264  output_notonbord
+00010430: 6572 5f74 6d70 5f70 6172 7469 616c 5f70  er_tmp_partial_p
+00010440: 6174 6820 3d20 7465 6d70 6469 7220 2f20  ath = tempdir / 
+00010450: 6e61 6d65 0a20 2020 2020 2020 2020 2020  name.           
+00010460: 2062 6174 6368 6573 5b62 6174 6368 5f69   batches[batch_i
+00010470: 645d 5b0a 2020 2020 2020 2020 2020 2020  d][.            
+00010480: 2020 2020 226f 7574 7075 745f 6e6f 746f      "output_noto
+00010490: 6e62 6f72 6465 725f 746d 705f 7061 7274  nborder_tmp_part
+000104a0: 6961 6c5f 7061 7468 220a 2020 2020 2020  ial_path".      
+000104b0: 2020 2020 2020 5d20 3d20 6f75 7470 7574        ] = output
+000104c0: 5f6e 6f74 6f6e 626f 7264 6572 5f74 6d70  _notonborder_tmp
+000104d0: 5f70 6172 7469 616c 5f70 6174 680a 2020  _partial_path.  
+000104e0: 2020 2020 2020 2020 2020 6e61 6d65 203d            name =
+000104f0: 2066 227b 6f75 7470 7574 5f6f 6e62 6f72   f"{output_onbor
+00010500: 6465 725f 7061 7468 2e73 7465 6d7d 5f7b  der_path.stem}_{
+00010510: 6261 7463 685f 6964 7d7b 7375 6666 6978  batch_id}{suffix
+00010520: 7d22 0a20 2020 2020 2020 2020 2020 206f  }".            o
+00010530: 7574 7075 745f 6f6e 626f 7264 6572 5f74  utput_onborder_t
+00010540: 6d70 5f70 6172 7469 616c 5f70 6174 6820  mp_partial_path 
+00010550: 3d20 7465 6d70 6469 7220 2f20 6e61 6d65  = tempdir / name
+00010560: 0a20 2020 2020 2020 2020 2020 2062 6174  .            bat
+00010570: 6368 6573 5b62 6174 6368 5f69 645d 5b0a  ches[batch_id][.
+00010580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010590: 226f 7574 7075 745f 6f6e 626f 7264 6572  "output_onborder
+000105a0: 5f74 6d70 5f70 6172 7469 616c 5f70 6174  _tmp_partial_pat
+000105b0: 6822 0a20 2020 2020 2020 2020 2020 205d  h".            ]
+000105c0: 203d 206f 7574 7075 745f 6f6e 626f 7264   = output_onbord
+000105d0: 6572 5f74 6d70 5f70 6172 7469 616c 5f70  er_tmp_partial_p
+000105e0: 6174 680a 0a20 2020 2020 2020 2020 2020  ath..           
+000105f0: 2023 2047 6574 2074 696c 655f 6964 2069   # Get tile_id i
+00010600: 6620 7072 6573 656e 740a 2020 2020 2020  f present.      
+00010610: 2020 2020 2020 7469 6c65 5f69 6420 3d20        tile_id = 
+00010620: 7469 6c65 5f72 6f77 2e74 696c 655f 6964  tile_row.tile_id
+00010630: 2069 6620 2274 696c 655f 6964 2220 696e   if "tile_id" in
+00010640: 2074 696c 655f 726f 772e 5f66 6965 6c64   tile_row._field
+00010650: 7320 656c 7365 204e 6f6e 650a 0a20 2020  s else None..   
+00010660: 2020 2020 2020 2020 2066 7574 7572 6520           future 
+00010670: 3d20 6361 6c63 756c 6174 655f 706f 6f6c  = calculate_pool
+00010680: 2e73 7562 6d69 7428 0a20 2020 2020 2020  .submit(.       
+00010690: 2020 2020 2020 2020 205f 6469 7373 6f6c           _dissol
+000106a0: 7665 5f70 6f6c 7967 6f6e 732c 0a20 2020  ve_polygons,.   
+000106b0: 2020 2020 2020 2020 2020 2020 2069 6e70               inp
+000106c0: 7574 5f70 6174 683d 696e 7075 745f 7061  ut_path=input_pa
+000106d0: 7468 2c0a 2020 2020 2020 2020 2020 2020  th,.            
+000106e0: 2020 2020 6f75 7470 7574 5f6e 6f74 6f6e      output_noton
+000106f0: 626f 7264 6572 5f70 6174 683d 6f75 7470  border_path=outp
+00010700: 7574 5f6e 6f74 6f6e 626f 7264 6572 5f74  ut_notonborder_t
+00010710: 6d70 5f70 6172 7469 616c 5f70 6174 682c  mp_partial_path,
+00010720: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010730: 206f 7574 7075 745f 6f6e 626f 7264 6572   output_onborder
+00010740: 5f70 6174 683d 6f75 7470 7574 5f6f 6e62  _path=output_onb
+00010750: 6f72 6465 725f 746d 705f 7061 7274 6961  order_tmp_partia
+00010760: 6c5f 7061 7468 2c0a 2020 2020 2020 2020  l_path,.        
+00010770: 2020 2020 2020 2020 6578 706c 6f64 6563          explodec
+00010780: 6f6c 6c65 6374 696f 6e73 3d65 7870 6c6f  ollections=explo
+00010790: 6465 636f 6c6c 6563 7469 6f6e 732c 0a20  decollections,. 
+000107a0: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+000107b0: 726f 7570 6279 5f63 6f6c 756d 6e73 3d67  roupby_columns=g
+000107c0: 726f 7570 6279 5f63 6f6c 756d 6e73 2c0a  roupby_columns,.
+000107d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000107e0: 6167 675f 636f 6c75 6d6e 733d 6167 675f  agg_columns=agg_
+000107f0: 636f 6c75 6d6e 732c 0a20 2020 2020 2020  columns,.       
+00010800: 2020 2020 2020 2020 2069 6e70 7574 5f67           input_g
+00010810: 656f 6d65 7472 7974 7970 653d 696e 7075  eometrytype=inpu
+00010820: 745f 6c61 7965 7269 6e66 6f2e 6765 6f6d  t_layerinfo.geom
+00010830: 6574 7279 7479 7065 2c0a 2020 2020 2020  etrytype,.      
+00010840: 2020 2020 2020 2020 2020 696e 7075 745f            input_
+00010850: 6c61 7965 723d 696e 7075 745f 6c61 7965  layer=input_laye
+00010860: 722c 0a20 2020 2020 2020 2020 2020 2020  r,.             
+00010870: 2020 206f 7574 7075 745f 6c61 7965 723d     output_layer=
+00010880: 6f75 7470 7574 5f6c 6179 6572 2c0a 2020  output_layer,.  
+00010890: 2020 2020 2020 2020 2020 2020 2020 6262                bb
+000108a0: 6f78 3d74 696c 655f 726f 772e 6765 6f6d  ox=tile_row.geom
+000108b0: 6574 7279 2e62 6f75 6e64 732c 0a20 2020  etry.bounds,.   
+000108c0: 2020 2020 2020 2020 2020 2020 2074 696c               til
+000108d0: 655f 6964 3d74 696c 655f 6964 2c0a 2020  e_id=tile_id,.  
+000108e0: 2020 2020 2020 2020 2020 2020 2020 6772                gr
+000108f0: 6964 7369 7a65 3d67 7269 6473 697a 652c  idsize=gridsize,
+00010900: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010910: 206b 6565 705f 656d 7074 795f 6765 6f6d   keep_empty_geom
+00010920: 733d 6b65 6570 5f65 6d70 7479 5f67 656f  s=keep_empty_geo
+00010930: 6d73 2c0a 2020 2020 2020 2020 2020 2020  ms,.            
+00010940: 290a 2020 2020 2020 2020 2020 2020 6675  ).            fu
+00010950: 7475 7265 5f74 6f5f 6261 7463 685f 6964  ture_to_batch_id
+00010960: 5b66 7574 7572 655d 203d 2062 6174 6368  [future] = batch
+00010970: 5f69 640a 0a20 2020 2020 2020 2023 204c  _id..        # L
+00010980: 6f6f 7020 7469 6c6c 2061 6c6c 2070 6172  oop till all par
+00010990: 616c 6c65 6c20 7072 6f63 6573 7365 7320  allel processes 
+000109a0: 6172 6520 7265 6164 792c 2062 7574 2070  are ready, but p
+000109b0: 726f 6365 7373 2065 6163 6820 6f6e 650a  rocess each one.
+000109c0: 2020 2020 2020 2020 2320 7468 6174 2069          # that i
+000109d0: 7320 7265 6164 7920 616c 7265 6164 790a  s ready already.
+000109e0: 2020 2020 2020 2020 5f67 656e 6572 616c          _general
+000109f0: 5f75 7469 6c2e 7265 706f 7274 5f70 726f  _util.report_pro
+00010a00: 6772 6573 7328 0a20 2020 2020 2020 2020  gress(.         
+00010a10: 2020 2073 7461 7274 5f74 696d 652c 206e     start_time, n
+00010a20: 625f 6261 7463 6865 735f 646f 6e65 2c20  b_batches_done, 
+00010a30: 6e62 5f62 6174 6368 6573 2c20 2264 6973  nb_batches, "dis
+00010a40: 736f 6c76 6522 0a20 2020 2020 2020 2029  solve".        )
+00010a50: 0a20 2020 2020 2020 2066 6f72 2066 7574  .        for fut
+00010a60: 7572 6520 696e 2066 7574 7572 6573 2e61  ure in futures.a
+00010a70: 735f 636f 6d70 6c65 7465 6428 6675 7475  s_completed(futu
+00010a80: 7265 5f74 6f5f 6261 7463 685f 6964 293a  re_to_batch_id):
+00010a90: 0a20 2020 2020 2020 2020 2020 2074 7279  .            try
+00010aa0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00010ab0: 2020 2320 4966 2074 6865 2063 616c 6375    # If the calcu
+00010ac0: 6c61 7465 2067 6176 6520 7265 7375 6c74  late gave result
+00010ad0: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+00010ae0: 2020 6e62 5f62 6174 6368 6573 5f64 6f6e    nb_batches_don
+00010af0: 6520 2b3d 2031 0a20 2020 2020 2020 2020  e += 1.         
+00010b00: 2020 2020 2020 2062 6174 6368 5f69 6420         batch_id 
+00010b10: 3d20 6675 7475 7265 5f74 6f5f 6261 7463  = future_to_batc
+00010b20: 685f 6964 5b66 7574 7572 655d 0a20 2020  h_id[future].   
+00010b30: 2020 2020 2020 2020 2020 2020 2072 6573               res
+00010b40: 756c 7420 3d20 6675 7475 7265 2e72 6573  ult = future.res
+00010b50: 756c 7428 290a 0a20 2020 2020 2020 2020  ult()..         
+00010b60: 2020 2020 2020 2069 6620 7265 7375 6c74         if result
+00010b70: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+00010b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010b90: 2020 6e62 5f72 6f77 735f 646f 6e65 202b    nb_rows_done +
+00010ba0: 3d20 7265 7375 6c74 5b22 6e62 5f72 6f77  = result["nb_row
+00010bb0: 735f 646f 6e65 225d 0a20 2020 2020 2020  s_done"].       
+00010bc0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00010bd0: 7265 7375 6c74 5b22 6e62 5f72 6f77 735f  result["nb_rows_
+00010be0: 646f 6e65 225d 203e 2030 2061 6e64 2072  done"] > 0 and r
+00010bf0: 6573 756c 745b 2274 6f74 616c 5f74 696d  esult["total_tim
+00010c00: 6522 5d20 3e20 303a 0a20 2020 2020 2020  e"] > 0:.       
+00010c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010c20: 2072 6f77 735f 7065 725f 7365 6320 3d20   rows_per_sec = 
+00010c30: 726f 756e 6428 0a20 2020 2020 2020 2020  round(.         
+00010c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010c50: 2020 2072 6573 756c 745b 226e 625f 726f     result["nb_ro
+00010c60: 7773 5f64 6f6e 6522 5d20 2f20 7265 7375  ws_done"] / resu
+00010c70: 6c74 5b22 746f 7461 6c5f 7469 6d65 225d  lt["total_time"]
+00010c80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010c90: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00010ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010cb0: 2020 206c 6f67 6765 722e 6465 6275 6728     logger.debug(
+00010cc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010cd0: 2020 2020 2020 2020 2020 2020 2066 2242               f"B
+00010ce0: 6174 6368 207b 6261 7463 685f 6964 7d20  atch {batch_id} 
+00010cf0: 7072 6f63 6573 7365 6420 7b72 6573 756c  processed {resul
+00010d00: 745b 276e 625f 726f 7773 5f64 6f6e 6527  t['nb_rows_done'
+00010d10: 5d7d 2072 6f77 7320 220a 2020 2020 2020  ]} rows ".      
+00010d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010d30: 2020 2020 2020 6622 287b 726f 7773 5f70        f"({rows_p
+00010d40: 6572 5f73 6563 7d2f 7365 6329 220a 2020  er_sec}/sec)".  
+00010d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010d60: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00010d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010d80: 6966 2022 7065 7266 7374 7269 6e67 2220  if "perfstring" 
+00010d90: 696e 2072 6573 756c 743a 0a20 2020 2020  in result:.     
+00010da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010db0: 2020 2020 2020 206c 6f67 6765 722e 6465         logger.de
+00010dc0: 6275 6728 6622 5065 7266 7374 7269 6e67  bug(f"Perfstring
+00010dd0: 3a20 7b72 6573 756c 745b 2770 6572 6673  : {result['perfs
+00010de0: 7472 696e 6727 5d7d 2229 0a0a 2020 2020  tring']}")..    
+00010df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010e00: 2320 5374 6172 7420 636f 7079 206f 6620  # Start copy of 
+00010e10: 7468 6520 7265 7375 6c74 2074 6f20 6120  the result to a 
+00010e20: 636f 6d6d 6f6e 2066 696c 650a 2020 2020  common file.    
+00010e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010e40: 6261 7463 685f 6964 203d 2066 7574 7572  batch_id = futur
+00010e50: 655f 746f 5f62 6174 6368 5f69 645b 6675  e_to_batch_id[fu
+00010e60: 7475 7265 5d0a 0a20 2020 2020 2020 2020  ture]..         
+00010e70: 2020 2020 2020 2020 2020 2023 2049 6620             # If 
+00010e80: 6361 6c63 756c 6174 6520 6761 7665 206e  calculate gave n
+00010e90: 6f74 6f6e 626f 7264 6572 2072 6573 756c  otonborder resul
+00010ea0: 7473 2c20 6170 7065 6e64 2074 6f20 6f75  ts, append to ou
+00010eb0: 7470 7574 0a20 2020 2020 2020 2020 2020  tput.           
+00010ec0: 2020 2020 2020 2020 206f 7574 7075 745f           output_
+00010ed0: 6e6f 746f 6e62 6f72 6465 725f 746d 705f  notonborder_tmp_
+00010ee0: 7061 7274 6961 6c5f 7061 7468 203d 2062  partial_path = b
+00010ef0: 6174 6368 6573 5b62 6174 6368 5f69 645d  atches[batch_id]
+00010f00: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+00010f10: 2020 2020 2020 2020 2020 226f 7574 7075            "outpu
+00010f20: 745f 6e6f 746f 6e62 6f72 6465 725f 746d  t_notonborder_tm
+00010f30: 705f 7061 7274 6961 6c5f 7061 7468 220a  p_partial_path".
+00010f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010f50: 2020 2020 5d0a 2020 2020 2020 2020 2020      ].          
+00010f60: 2020 2020 2020 2020 2020 6966 2028 0a20            if (. 
+00010f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010f80: 2020 2020 2020 206f 7574 7075 745f 6e6f         output_no
+00010f90: 746f 6e62 6f72 6465 725f 746d 705f 7061  tonborder_tmp_pa
+00010fa0: 7274 6961 6c5f 7061 7468 2e65 7869 7374  rtial_path.exist
+00010fb0: 7328 290a 2020 2020 2020 2020 2020 2020  s().            
+00010fc0: 2020 2020 2020 2020 2020 2020 616e 6420              and 
+00010fd0: 6f75 7470 7574 5f6e 6f74 6f6e 626f 7264  output_notonbord
+00010fe0: 6572 5f74 6d70 5f70 6172 7469 616c 5f70  er_tmp_partial_p
+00010ff0: 6174 682e 7374 6174 2829 2e73 745f 7369  ath.stat().st_si
+00011000: 7a65 203e 2030 0a20 2020 2020 2020 2020  ze > 0.         
+00011010: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
+00011020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011030: 2020 2020 2020 6669 6c65 6f70 732e 5f61        fileops._a
+00011040: 7070 656e 645f 746f 5f6e 6f6c 6f63 6b28  ppend_to_nolock(
+00011050: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011060: 2020 2020 2020 2020 2020 2020 2073 7263               src
+00011070: 3d6f 7574 7075 745f 6e6f 746f 6e62 6f72  =output_notonbor
+00011080: 6465 725f 746d 705f 7061 7274 6961 6c5f  der_tmp_partial_
+00011090: 7061 7468 2c0a 2020 2020 2020 2020 2020  path,.          
+000110a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000110b0: 2020 6473 743d 6f75 7470 7574 5f6e 6f74    dst=output_not
+000110c0: 6f6e 626f 7264 6572 5f70 6174 682c 0a20  onborder_path,. 
+000110d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000110e0: 2020 2020 2020 2020 2020 2063 7265 6174             creat
+000110f0: 655f 7370 6174 6961 6c5f 696e 6465 783d  e_spatial_index=
+00011100: 4661 6c73 652c 0a20 2020 2020 2020 2020  False,.         
+00011110: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+00011120: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011130: 2020 2020 2020 2020 2067 666f 2e72 656d           gfo.rem
+00011140: 6f76 6528 6f75 7470 7574 5f6e 6f74 6f6e  ove(output_noton
+00011150: 626f 7264 6572 5f74 6d70 5f70 6172 7469  border_tmp_parti
+00011160: 616c 5f70 6174 6829 0a0a 2020 2020 2020  al_path)..      
+00011170: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00011180: 4966 2063 616c 6375 6c61 7465 2067 6176  If calculate gav
+00011190: 6520 6f6e 626f 7264 6572 2072 6573 756c  e onborder resul
+000111a0: 7473 2c20 6170 7065 6e64 2074 6f20 6f75  ts, append to ou
+000111b0: 7470 7574 0a20 2020 2020 2020 2020 2020  tput.           
+000111c0: 2020 2020 2020 2020 206f 7574 7075 745f           output_
+000111d0: 6f6e 626f 7264 6572 5f74 6d70 5f70 6172  onborder_tmp_par
+000111e0: 7469 616c 5f70 6174 6820 3d20 6261 7463  tial_path = batc
+000111f0: 6865 735b 6261 7463 685f 6964 5d5b 0a20  hes[batch_id][. 
+00011200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011210: 2020 2020 2020 2022 6f75 7470 7574 5f6f         "output_o
+00011220: 6e62 6f72 6465 725f 746d 705f 7061 7274  nborder_tmp_part
+00011230: 6961 6c5f 7061 7468 220a 2020 2020 2020  ial_path".      
+00011240: 2020 2020 2020 2020 2020 2020 2020 5d0a                ].
+00011250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011260: 2020 2020 6966 2028 0a20 2020 2020 2020      if (.       
+00011270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011280: 206f 7574 7075 745f 6f6e 626f 7264 6572   output_onborder
+00011290: 5f74 6d70 5f70 6172 7469 616c 5f70 6174  _tmp_partial_pat
+000112a0: 682e 6578 6973 7473 2829 0a20 2020 2020  h.exists().     
+000112b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000112c0: 2020 2061 6e64 206f 7574 7075 745f 6f6e     and output_on
+000112d0: 626f 7264 6572 5f74 6d70 5f70 6172 7469  border_tmp_parti
+000112e0: 616c 5f70 6174 682e 7374 6174 2829 2e73  al_path.stat().s
+000112f0: 745f 7369 7a65 203e 2030 0a20 2020 2020  t_size > 0.     
+00011300: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+00011310: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00011320: 2020 2020 2020 2020 2020 6669 6c65 6f70            fileop
+00011330: 732e 5f61 7070 656e 645f 746f 5f6e 6f6c  s._append_to_nol
+00011340: 6f63 6b28 0a20 2020 2020 2020 2020 2020  ock(.           
 00011350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011360: 7265 7375 6c74 5b22 6e62 5f72 6f77 735f  result["nb_rows_
-00011370: 646f 6e65 225d 202f 2072 6573 756c 745b  done"] / result[
-00011380: 2274 6f74 616c 5f74 696d 6522 5d0d 0a20  "total_time"].. 
+00011360: 2073 7263 3d6f 7574 7075 745f 6f6e 626f   src=output_onbo
+00011370: 7264 6572 5f74 6d70 5f70 6172 7469 616c  rder_tmp_partial
+00011380: 5f70 6174 682c 0a20 2020 2020 2020 2020  _path,.         
 00011390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000113a0: 2020 2020 2020 2029 0d0a 2020 2020 2020         )..      
-000113b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000113c0: 2020 6c6f 6767 6572 2e64 6562 7567 280d    logger.debug(.
-000113d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000113e0: 2020 2020 2020 2020 2020 2020 2066 2242               f"B
-000113f0: 6174 6368 207b 6261 7463 685f 6964 7d20  atch {batch_id} 
-00011400: 7072 6f63 6573 7365 6420 7b72 6573 756c  processed {resul
-00011410: 745b 276e 625f 726f 7773 5f64 6f6e 6527  t['nb_rows_done'
-00011420: 5d7d 2072 6f77 7320 220d 0a20 2020 2020  ]} rows "..     
-00011430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011440: 2020 2020 2020 2066 2228 7b72 6f77 735f         f"({rows_
-00011450: 7065 725f 7365 637d 2f73 6563 2922 0d0a  per_sec}/sec)"..
-00011460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011470: 2020 2020 2020 2020 290d 0a20 2020 2020          )..     
-00011480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011490: 2020 2069 6620 2270 6572 6673 7472 696e     if "perfstrin
-000114a0: 6722 2069 6e20 7265 7375 6c74 3a0d 0a20  g" in result:.. 
-000114b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000114c0: 2020 2020 2020 2020 2020 206c 6f67 6765             logge
-000114d0: 722e 6465 6275 6728 6622 5065 7266 7374  r.debug(f"Perfst
-000114e0: 7269 6e67 3a20 7b72 6573 756c 745b 2770  ring: {result['p
-000114f0: 6572 6673 7472 696e 6727 5d7d 2229 0d0a  erfstring']}")..
-00011500: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00011510: 2020 2020 2020 2320 5374 6172 7420 636f        # Start co
-00011520: 7079 206f 6620 7468 6520 7265 7375 6c74  py of the result
-00011530: 2074 6f20 6120 636f 6d6d 6f6e 2066 696c   to a common fil
-00011540: 650d 0a20 2020 2020 2020 2020 2020 2020  e..             
-00011550: 2020 2020 2020 2062 6174 6368 5f69 6420         batch_id 
-00011560: 3d20 6675 7475 7265 5f74 6f5f 6261 7463  = future_to_batc
-00011570: 685f 6964 5b66 7574 7572 655d 0d0a 0d0a  h_id[future]....
-00011580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011590: 2020 2020 2320 4966 2063 616c 6375 6c61      # If calcula
-000115a0: 7465 2067 6176 6520 6e6f 746f 6e62 6f72  te gave notonbor
-000115b0: 6465 7220 7265 7375 6c74 732c 2061 7070  der results, app
-000115c0: 656e 6420 746f 206f 7574 7075 740d 0a20  end to output.. 
-000115d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000115e0: 2020 206f 7574 7075 745f 6e6f 746f 6e62     output_notonb
-000115f0: 6f72 6465 725f 746d 705f 7061 7274 6961  order_tmp_partia
-00011600: 6c5f 7061 7468 203d 2062 6174 6368 6573  l_path = batches
-00011610: 5b62 6174 6368 5f69 645d 5b0d 0a20 2020  [batch_id][..   
-00011620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011630: 2020 2020 2022 6f75 7470 7574 5f6e 6f74       "output_not
-00011640: 6f6e 626f 7264 6572 5f74 6d70 5f70 6172  onborder_tmp_par
-00011650: 7469 616c 5f70 6174 6822 0d0a 2020 2020  tial_path"..    
-00011660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011670: 5d0d 0a20 2020 2020 2020 2020 2020 2020  ]..             
-00011680: 2020 2020 2020 2069 6620 280d 0a20 2020         if (..   
-00011690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000116a0: 2020 2020 206f 7574 7075 745f 6e6f 746f       output_noto
-000116b0: 6e62 6f72 6465 725f 746d 705f 7061 7274  nborder_tmp_part
-000116c0: 6961 6c5f 7061 7468 2e65 7869 7374 7328  ial_path.exists(
-000116d0: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-000116e0: 2020 2020 2020 2020 2020 2061 6e64 206f             and o
-000116f0: 7574 7075 745f 6e6f 746f 6e62 6f72 6465  utput_notonborde
-00011700: 725f 746d 705f 7061 7274 6961 6c5f 7061  r_tmp_partial_pa
-00011710: 7468 2e73 7461 7428 292e 7374 5f73 697a  th.stat().st_siz
-00011720: 6520 3e20 300d 0a20 2020 2020 2020 2020  e > 0..         
-00011730: 2020 2020 2020 2020 2020 2029 3a0d 0a20             ):.. 
-00011740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011750: 2020 2020 2020 2066 696c 656f 7073 2e5f         fileops._
-00011760: 6170 7065 6e64 5f74 6f5f 6e6f 6c6f 636b  append_to_nolock
-00011770: 280d 0a20 2020 2020 2020 2020 2020 2020  (..             
-00011780: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00011790: 7263 3d6f 7574 7075 745f 6e6f 746f 6e62  rc=output_notonb
-000117a0: 6f72 6465 725f 746d 705f 7061 7274 6961  order_tmp_partia
-000117b0: 6c5f 7061 7468 2c0d 0a20 2020 2020 2020  l_path,..       
-000117c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000117d0: 2020 2020 2064 7374 3d6f 7574 7075 745f       dst=output_
-000117e0: 6e6f 746f 6e62 6f72 6465 725f 7061 7468  notonborder_path
-000117f0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00011800: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00011810: 7265 6174 655f 7370 6174 6961 6c5f 696e  reate_spatial_in
-00011820: 6465 783d 4661 6c73 652c 0d0a 2020 2020  dex=False,..    
-00011830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011840: 2020 2020 290d 0a20 2020 2020 2020 2020      )..         
-00011850: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-00011860: 666f 2e72 656d 6f76 6528 6f75 7470 7574  fo.remove(output
-00011870: 5f6e 6f74 6f6e 626f 7264 6572 5f74 6d70  _notonborder_tmp
-00011880: 5f70 6172 7469 616c 5f70 6174 6829 0d0a  _partial_path)..
-00011890: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000118a0: 2020 2020 2020 2320 4966 2063 616c 6375        # If calcu
-000118b0: 6c61 7465 2067 6176 6520 6f6e 626f 7264  late gave onbord
-000118c0: 6572 2072 6573 756c 7473 2c20 6170 7065  er results, appe
-000118d0: 6e64 2074 6f20 6f75 7470 7574 0d0a 2020  nd to output..  
-000118e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000118f0: 2020 6f75 7470 7574 5f6f 6e62 6f72 6465    output_onborde
-00011900: 725f 746d 705f 7061 7274 6961 6c5f 7061  r_tmp_partial_pa
-00011910: 7468 203d 2062 6174 6368 6573 5b62 6174  th = batches[bat
-00011920: 6368 5f69 645d 5b0d 0a20 2020 2020 2020  ch_id][..       
-00011930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011940: 2022 6f75 7470 7574 5f6f 6e62 6f72 6465   "output_onborde
-00011950: 725f 746d 705f 7061 7274 6961 6c5f 7061  r_tmp_partial_pa
-00011960: 7468 220d 0a20 2020 2020 2020 2020 2020  th"..           
-00011970: 2020 2020 2020 2020 205d 0d0a 2020 2020           ]..    
-00011980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011990: 6966 2028 0d0a 2020 2020 2020 2020 2020  if (..          
-000119a0: 2020 2020 2020 2020 2020 2020 2020 6f75                ou
-000119b0: 7470 7574 5f6f 6e62 6f72 6465 725f 746d  tput_onborder_tm
-000119c0: 705f 7061 7274 6961 6c5f 7061 7468 2e65  p_partial_path.e
-000119d0: 7869 7374 7328 290d 0a20 2020 2020 2020  xists()..       
-000119e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000119f0: 2061 6e64 206f 7574 7075 745f 6f6e 626f   and output_onbo
-00011a00: 7264 6572 5f74 6d70 5f70 6172 7469 616c  rder_tmp_partial
-00011a10: 5f70 6174 682e 7374 6174 2829 2e73 745f  _path.stat().st_
-00011a20: 7369 7a65 203e 2030 0d0a 2020 2020 2020  size > 0..      
-00011a30: 2020 2020 2020 2020 2020 2020 2020 293a                ):
-00011a40: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00011a50: 2020 2020 2020 2020 2020 6669 6c65 6f70            fileop
-00011a60: 732e 5f61 7070 656e 645f 746f 5f6e 6f6c  s._append_to_nol
-00011a70: 6f63 6b28 0d0a 2020 2020 2020 2020 2020  ock(..          
-00011a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011a90: 2020 7372 633d 6f75 7470 7574 5f6f 6e62    src=output_onb
-00011aa0: 6f72 6465 725f 746d 705f 7061 7274 6961  order_tmp_partia
-00011ab0: 6c5f 7061 7468 2c0d 0a20 2020 2020 2020  l_path,..       
-00011ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011ad0: 2020 2020 2064 7374 3d6f 7574 7075 745f       dst=output_
-00011ae0: 6f6e 626f 7264 6572 5f70 6174 682c 0d0a  onborder_path,..
-00011af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b00: 2020 2020 2020 2020 2020 2020 6372 6561              crea
-00011b10: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
-00011b20: 3d46 616c 7365 2c0d 0a20 2020 2020 2020  =False,..       
-00011b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b40: 2029 0d0a 2020 2020 2020 2020 2020 2020   )..            
-00011b50: 2020 2020 2020 2020 2020 2020 6766 6f2e              gfo.
-00011b60: 7265 6d6f 7665 286f 7574 7075 745f 6f6e  remove(output_on
-00011b70: 626f 7264 6572 5f74 6d70 5f70 6172 7469  border_tmp_parti
-00011b80: 616c 5f70 6174 6829 0d0a 0d0a 2020 2020  al_path)....    
-00011b90: 2020 2020 2020 2020 6578 6365 7074 2045          except E
-00011ba0: 7863 6570 7469 6f6e 2061 7320 6578 3a0d  xception as ex:.
-00011bb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011bc0: 2062 6174 6368 5f69 6420 3d20 6675 7475   batch_id = futu
-00011bd0: 7265 5f74 6f5f 6261 7463 685f 6964 5b66  re_to_batch_id[f
-00011be0: 7574 7572 655d 0d0a 2020 2020 2020 2020  uture]..        
-00011bf0: 2020 2020 2020 2020 6d65 7373 6167 6520          message 
-00011c00: 3d20 6622 4572 726f 7220 6578 6563 7574  = f"Error execut
-00011c10: 696e 6720 7b62 6174 6368 6573 5b62 6174  ing {batches[bat
-00011c20: 6368 5f69 645d 7d3a 207b 6578 7d22 0d0a  ch_id]}: {ex}"..
-00011c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011c40: 6c6f 6767 6572 2e65 7863 6570 7469 6f6e  logger.exception
-00011c50: 286d 6573 7361 6765 290d 0a20 2020 2020  (message)..     
-00011c60: 2020 2020 2020 2020 2020 2063 616c 6375             calcu
-00011c70: 6c61 7465 5f70 6f6f 6c2e 7368 7574 646f  late_pool.shutdo
-00011c80: 776e 2829 0d0a 2020 2020 2020 2020 2020  wn()..          
-00011c90: 2020 2020 2020 7261 6973 6520 4578 6365        raise Exce
-00011ca0: 7074 696f 6e28 6d65 7373 6167 6529 2066  ption(message) f
-00011cb0: 726f 6d20 6578 0d0a 0d0a 2020 2020 2020  rom ex....      
-00011cc0: 2020 2020 2020 2320 4c6f 6720 7468 6520        # Log the 
-00011cd0: 7072 6f67 7265 7373 2061 6e64 2070 7265  progress and pre
-00011ce0: 6469 6374 696f 6e20 7370 6565 640d 0a20  diction speed.. 
-00011cf0: 2020 2020 2020 2020 2020 205f 6765 6e65             _gene
-00011d00: 7261 6c5f 7574 696c 2e72 6570 6f72 745f  ral_util.report_
-00011d10: 7072 6f67 7265 7373 280d 0a20 2020 2020  progress(..     
-00011d20: 2020 2020 2020 2020 2020 2073 7461 7274             start
-00011d30: 5f74 696d 652c 206e 625f 6261 7463 6865  _time, nb_batche
-00011d40: 735f 646f 6e65 2c20 6e62 5f62 6174 6368  s_done, nb_batch
-00011d50: 6573 2c20 2264 6973 736f 6c76 6522 0d0a  es, "dissolve"..
-00011d60: 2020 2020 2020 2020 2020 2020 290d 0a0d              )...
-00011d70: 0a0d 0a64 6566 205f 6469 7373 6f6c 7665  ...def _dissolve
-00011d80: 5f70 6f6c 7967 6f6e 7328 0d0a 2020 2020  _polygons(..    
-00011d90: 696e 7075 745f 7061 7468 3a20 5061 7468  input_path: Path
-00011da0: 2c0d 0a20 2020 206f 7574 7075 745f 6e6f  ,..    output_no
-00011db0: 746f 6e62 6f72 6465 725f 7061 7468 3a20  tonborder_path: 
-00011dc0: 5061 7468 2c0d 0a20 2020 206f 7574 7075  Path,..    outpu
-00011dd0: 745f 6f6e 626f 7264 6572 5f70 6174 683a  t_onborder_path:
-00011de0: 2050 6174 682c 0d0a 2020 2020 6578 706c   Path,..    expl
-00011df0: 6f64 6563 6f6c 6c65 6374 696f 6e73 3a20  odecollections: 
-00011e00: 626f 6f6c 2c0d 0a20 2020 2067 726f 7570  bool,..    group
-00011e10: 6279 5f63 6f6c 756d 6e73 3a20 4f70 7469  by_columns: Opti
-00011e20: 6f6e 616c 5b49 7465 7261 626c 655b 7374  onal[Iterable[st
-00011e30: 725d 5d2c 0d0a 2020 2020 6167 675f 636f  r]],..    agg_co
-00011e40: 6c75 6d6e 733a 204f 7074 696f 6e61 6c5b  lumns: Optional[
-00011e50: 6469 6374 5d2c 0d0a 2020 2020 696e 7075  dict],..    inpu
-00011e60: 745f 6765 6f6d 6574 7279 7479 7065 3a20  t_geometrytype: 
-00011e70: 4765 6f6d 6574 7279 5479 7065 2c0d 0a20  GeometryType,.. 
-00011e80: 2020 2069 6e70 7574 5f6c 6179 6572 3a20     input_layer: 
-00011e90: 4f70 7469 6f6e 616c 5b73 7472 5d2c 0d0a  Optional[str],..
-00011ea0: 2020 2020 6f75 7470 7574 5f6c 6179 6572      output_layer
-00011eb0: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d2c  : Optional[str],
-00011ec0: 0d0a 2020 2020 6262 6f78 3a20 5475 706c  ..    bbox: Tupl
-00011ed0: 655b 666c 6f61 742c 2066 6c6f 6174 2c20  e[float, float, 
-00011ee0: 666c 6f61 742c 2066 6c6f 6174 5d2c 0d0a  float, float],..
-00011ef0: 2020 2020 7469 6c65 5f69 643a 204f 7074      tile_id: Opt
-00011f00: 696f 6e61 6c5b 696e 745d 2c0d 0a20 2020  ional[int],..   
-00011f10: 2067 7269 6473 697a 653a 2066 6c6f 6174   gridsize: float
-00011f20: 2c0d 0a20 2020 206b 6565 705f 656d 7074  ,..    keep_empt
-00011f30: 795f 6765 6f6d 733a 2062 6f6f 6c2c 0d0a  y_geoms: bool,..
-00011f40: 2920 2d3e 2064 6963 743a 0d0a 2020 2020  ) -> dict:..    
-00011f50: 2320 496e 6974 0d0a 2020 2020 7065 7266  # Init..    perf
-00011f60: 696e 666f 3a20 4469 6374 5b73 7472 2c20  info: Dict[str, 
-00011f70: 666c 6f61 745d 203d 207b 7d0d 0a20 2020  float] = {}..   
-00011f80: 2073 7461 7274 5f74 696d 6520 3d20 6461   start_time = da
-00011f90: 7465 7469 6d65 2e6e 6f77 2829 0d0a 2020  tetime.now()..  
-00011fa0: 2020 7265 7475 726e 5f69 6e66 6f20 3d20    return_info = 
-00011fb0: 7b0d 0a20 2020 2020 2020 2022 696e 7075  {..        "inpu
-00011fc0: 745f 7061 7468 223a 2069 6e70 7574 5f70  t_path": input_p
-00011fd0: 6174 682c 0d0a 2020 2020 2020 2020 226f  ath,..        "o
-00011fe0: 7574 7075 745f 6e6f 746f 6e62 6f72 6465  utput_notonborde
-00011ff0: 725f 7061 7468 223a 206f 7574 7075 745f  r_path": output_
-00012000: 6e6f 746f 6e62 6f72 6465 725f 7061 7468  notonborder_path
-00012010: 2c0d 0a20 2020 2020 2020 2022 6f75 7470  ,..        "outp
-00012020: 7574 5f6f 6e62 6f72 6465 725f 7061 7468  ut_onborder_path
-00012030: 223a 206f 7574 7075 745f 6f6e 626f 7264  ": output_onbord
-00012040: 6572 5f70 6174 682c 0d0a 2020 2020 2020  er_path,..      
-00012050: 2020 2262 626f 7822 3a20 6262 6f78 2c0d    "bbox": bbox,.
-00012060: 0a20 2020 2020 2020 2022 7469 6c65 5f69  .        "tile_i
-00012070: 6422 3a20 7469 6c65 5f69 642c 0d0a 2020  d": tile_id,..  
-00012080: 2020 2020 2020 2267 7269 6473 697a 6522        "gridsize"
-00012090: 3a20 6772 6964 7369 7a65 2c0d 0a20 2020  : gridsize,..   
-000120a0: 2020 2020 2022 6e62 5f72 6f77 735f 646f       "nb_rows_do
-000120b0: 6e65 223a 2030 2c0d 0a20 2020 2020 2020  ne": 0,..       
-000120c0: 2022 746f 7461 6c5f 7469 6d65 223a 2030   "total_time": 0
-000120d0: 2c0d 0a20 2020 2020 2020 2022 7065 7266  ,..        "perf
-000120e0: 696e 666f 223a 2022 222c 0d0a 2020 2020  info": "",..    
-000120f0: 7d0d 0a0d 0a20 2020 2023 2052 6561 6420  }....    # Read 
-00012100: 616c 6c20 7265 636f 7264 7320 7468 6174  all records that
-00012110: 2061 7265 2069 6e20 7468 6520 6262 6f78   are in the bbox
-00012120: 0d0a 2020 2020 7265 7472 795f 636f 756e  ..    retry_coun
-00012130: 7420 3d20 300d 0a20 2020 2073 7461 7274  t = 0..    start
-00012140: 5f72 6561 6420 3d20 6461 7465 7469 6d65  _read = datetime
-00012150: 2e6e 6f77 2829 0d0a 2020 2020 6167 675f  .now()..    agg_
-00012160: 636f 6c75 6d6e 735f 6e65 6564 6564 203d  columns_needed =
-00012170: 204e 6f6e 650d 0a20 2020 2077 6869 6c65   None..    while
-00012180: 2054 7275 653a 0d0a 2020 2020 2020 2020   True:..        
-00012190: 7472 793a 0d0a 2020 2020 2020 2020 2020  try:..          
-000121a0: 2020 636f 6c75 6d6e 735f 746f 5f72 6561    columns_to_rea
-000121b0: 643a 2053 6574 5b73 7472 5d20 3d20 7365  d: Set[str] = se
-000121c0: 7428 290d 0a20 2020 2020 2020 2020 2020  t()..           
-000121d0: 2069 6e66 6f20 3d20 6766 6f2e 6765 745f   info = gfo.get_
-000121e0: 6c61 7965 7269 6e66 6f28 696e 7075 745f  layerinfo(input_
-000121f0: 7061 7468 2c20 696e 7075 745f 6c61 7965  path, input_laye
-00012200: 7229 0d0a 2020 2020 2020 2020 2020 2020  r)..            
-00012210: 6966 2067 726f 7570 6279 5f63 6f6c 756d  if groupby_colum
-00012220: 6e73 2069 7320 6e6f 7420 4e6f 6e65 3a0d  ns is not None:.
-00012230: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012240: 2063 6f6c 756d 6e73 5f74 6f5f 7265 6164   columns_to_read
-00012250: 2e75 7064 6174 6528 6772 6f75 7062 795f  .update(groupby_
-00012260: 636f 6c75 6d6e 7329 0d0a 2020 2020 2020  columns)..      
-00012270: 2020 2020 2020 6669 645f 6173 5f69 6e64        fid_as_ind
-00012280: 6578 203d 2046 616c 7365 0d0a 2020 2020  ex = False..    
-00012290: 2020 2020 2020 2020 6966 2061 6767 5f63          if agg_c
-000122a0: 6f6c 756d 6e73 2069 7320 6e6f 7420 4e6f  olumns is not No
-000122b0: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-000122c0: 2020 2020 2066 6964 5f61 735f 696e 6465       fid_as_inde
-000122d0: 7820 3d20 5472 7565 0d0a 2020 2020 2020  x = True..      
-000122e0: 2020 2020 2020 2020 2020 6966 2022 5f5f            if "__
-000122f0: 4449 5353 4f4c 5645 5f54 4f4a 534f 4e22  DISSOLVE_TOJSON"
-00012300: 2069 6e20 696e 666f 2e63 6f6c 756d 6e73   in info.columns
-00012310: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00012320: 2020 2020 2020 2023 2049 6620 7765 2061         # If we a
-00012330: 7265 206e 6f74 2069 6e20 7468 6520 6669  re not in the fi
-00012340: 7273 7420 7061 7373 2c20 7468 6520 636f  rst pass, the co
-00012350: 6c75 6d6e 7320 746f 2062 6520 7265 6164  lumns to be read
-00012360: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00012370: 2020 2020 2020 2320 6172 6520 616c 7265        # are alre
-00012380: 6164 7920 696e 2074 6865 206a 736f 6e20  ady in the json 
-00012390: 636f 6c75 6d6e 0d0a 2020 2020 2020 2020  column..        
-000123a0: 2020 2020 2020 2020 2020 2020 636f 6c75              colu
-000123b0: 6d6e 735f 746f 5f72 6561 642e 6164 6428  mns_to_read.add(
-000123c0: 225f 5f44 4953 534f 4c56 455f 544f 4a53  "__DISSOLVE_TOJS
-000123d0: 4f4e 2229 0d0a 2020 2020 2020 2020 2020  ON")..          
-000123e0: 2020 2020 2020 656c 7365 3a0d 0a20 2020        else:..   
-000123f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012400: 2023 2054 6865 2066 6972 7374 2070 6173   # The first pas
-00012410: 732c 2073 6f20 7265 6164 2061 6c6c 2072  s, so read all r
-00012420: 656c 6576 616e 7420 636f 6c75 6d6e 7320  elevant columns 
-00012430: 746f 2063 6f64 650d 0a20 2020 2020 2020  to code..       
-00012440: 2020 2020 2020 2020 2020 2020 2023 2074               # t
-00012450: 6865 6d20 696e 206a 736f 6e0d 0a20 2020  hem in json..   
-00012460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012470: 2069 6620 226a 736f 6e22 2069 6e20 6167   if "json" in ag
-00012480: 675f 636f 6c75 6d6e 733a 0d0a 2020 2020  g_columns:..    
-00012490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000124a0: 2020 2020 6167 675f 636f 6c75 6d6e 735f      agg_columns_
-000124b0: 6e65 6564 6564 203d 2061 6767 5f63 6f6c  needed = agg_col
-000124c0: 756d 6e73 5b22 6a73 6f6e 225d 0d0a 2020  umns["json"]..  
-000124d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000124e0: 2020 656c 6966 2022 636f 6c75 6d6e 7322    elif "columns"
-000124f0: 2069 6e20 6167 675f 636f 6c75 6d6e 733a   in agg_columns:
-00012500: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00012510: 2020 2020 2020 2020 2020 6167 675f 636f            agg_co
-00012520: 6c75 6d6e 735f 6e65 6564 6564 203d 205b  lumns_needed = [
-00012530: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00012540: 2020 2020 2020 2020 2020 2020 2020 6167                ag
-00012550: 675f 636f 6c75 6d6e 5b22 636f 6c75 6d6e  g_column["column
-00012560: 225d 0d0a 2020 2020 2020 2020 2020 2020  "]..            
-00012570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012580: 666f 7220 6167 675f 636f 6c75 6d6e 2069  for agg_column i
-00012590: 6e20 6167 675f 636f 6c75 6d6e 735b 2263  n agg_columns["c
-000125a0: 6f6c 756d 6e73 225d 0d0a 2020 2020 2020  olumns"]..      
-000125b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000125c0: 2020 5d0d 0a20 2020 2020 2020 2020 2020    ]..           
-000125d0: 2020 2020 2020 2020 2069 6620 6167 675f           if agg_
-000125e0: 636f 6c75 6d6e 735f 6e65 6564 6564 2069  columns_needed i
-000125f0: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
-00012600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012610: 2020 2020 2063 6f6c 756d 6e73 5f74 6f5f       columns_to_
-00012620: 7265 6164 2e75 7064 6174 6528 6167 675f  read.update(agg_
-00012630: 636f 6c75 6d6e 735f 6e65 6564 6564 290d  columns_needed).
-00012640: 0a0d 0a20 2020 2020 2020 2020 2020 2069  ...            i
-00012650: 6e70 7574 5f67 6466 203d 2067 666f 2e72  nput_gdf = gfo.r
-00012660: 6561 645f 6669 6c65 280d 0a20 2020 2020  ead_file(..     
-00012670: 2020 2020 2020 2020 2020 2070 6174 683d             path=
-00012680: 696e 7075 745f 7061 7468 2c0d 0a20 2020  input_path,..   
-00012690: 2020 2020 2020 2020 2020 2020 206c 6179               lay
-000126a0: 6572 3d69 6e70 7574 5f6c 6179 6572 2c0d  er=input_layer,.
-000126b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000126c0: 2062 626f 783d 6262 6f78 2c0d 0a20 2020   bbox=bbox,..   
-000126d0: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
-000126e0: 756d 6e73 3d63 6f6c 756d 6e73 5f74 6f5f  umns=columns_to_
-000126f0: 7265 6164 2c0d 0a20 2020 2020 2020 2020  read,..         
-00012700: 2020 2020 2020 2066 6964 5f61 735f 696e         fid_as_in
-00012710: 6465 783d 6669 645f 6173 5f69 6e64 6578  dex=fid_as_index
-00012720: 2c0d 0a20 2020 2020 2020 2020 2020 2029  ,..            )
-00012730: 0d0a 0d0a 2020 2020 2020 2020 2020 2020  ....            
-00012740: 6966 2061 6767 5f63 6f6c 756d 6e73 2069  if agg_columns i
-00012750: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
-00012760: 2020 2020 2020 2020 2020 2020 2069 6e70               inp
-00012770: 7574 5f67 6466 5b22 6669 645f 6f72 6967  ut_gdf["fid_orig
-00012780: 225d 203d 2069 6e70 7574 5f67 6466 2e69  "] = input_gdf.i
-00012790: 6e64 6578 0d0a 2020 2020 2020 2020 2020  ndex..          
-000127a0: 2020 2020 2020 6966 2061 6767 5f63 6f6c        if agg_col
-000127b0: 756d 6e73 5f6e 6565 6465 6420 6973 206e  umns_needed is n
-000127c0: 6f74 204e 6f6e 653a 0d0a 2020 2020 2020  ot None:..      
-000127d0: 2020 2020 2020 2020 2020 2020 2020 6167                ag
-000127e0: 675f 636f 6c75 6d6e 735f 6e65 6564 6564  g_columns_needed
-000127f0: 2e61 7070 656e 6428 2266 6964 5f6f 7269  .append("fid_ori
-00012800: 6722 290d 0a0d 0a20 2020 2020 2020 2020  g")....         
-00012810: 2020 2062 7265 616b 0d0a 2020 2020 2020     break..      
-00012820: 2020 6578 6365 7074 2045 7863 6570 7469    except Excepti
-00012830: 6f6e 2061 7320 6578 3a0d 0a20 2020 2020  on as ex:..     
-00012840: 2020 2020 2020 2069 6620 7374 7228 6578         if str(ex
-00012850: 2920 3d3d 2022 6461 7461 6261 7365 2069  ) == "database i
-00012860: 7320 6c6f 636b 6564 223a 0d0a 2020 2020  s locked":..    
-00012870: 2020 2020 2020 2020 2020 2020 6966 2072              if r
-00012880: 6574 7279 5f63 6f75 6e74 203c 2031 303a  etry_count < 10:
-00012890: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000128a0: 2020 2020 2020 7265 7472 795f 636f 756e        retry_coun
-000128b0: 7420 2b3d 2031 0d0a 2020 2020 2020 2020  t += 1..        
-000128c0: 2020 2020 2020 2020 2020 2020 7469 6d65              time
-000128d0: 2e73 6c65 6570 2831 290d 0a20 2020 2020  .sleep(1)..     
-000128e0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-000128f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00012900: 2020 2020 2020 7261 6973 6520 4578 6365        raise Exce
-00012910: 7074 696f 6e28 2272 6574 7269 6564 2031  ption("retried 1
-00012920: 3020 7469 6d65 732c 2064 6174 6162 6173  0 times, databas
-00012930: 6520 7374 696c 6c20 6c6f 636b 6564 2229  e still locked")
-00012940: 2066 726f 6d20 6578 0d0a 2020 2020 2020   from ex..      
-00012950: 2020 2020 2020 656c 7365 3a0d 0a20 2020        else:..   
-00012960: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-00012970: 7365 2065 780d 0a0d 0a20 2020 2023 2043  se ex....    # C
-00012980: 6865 636b 2072 6573 756c 740d 0a20 2020  heck result..   
-00012990: 2070 6572 6669 6e66 6f5b 2274 696d 655f   perfinfo["time_
-000129a0: 7265 6164 225d 203d 2028 6461 7465 7469  read"] = (dateti
-000129b0: 6d65 2e6e 6f77 2829 202d 2073 7461 7274  me.now() - start
-000129c0: 5f72 6561 6429 2e74 6f74 616c 5f73 6563  _read).total_sec
-000129d0: 6f6e 6473 2829 0d0a 2020 2020 7265 7475  onds()..    retu
-000129e0: 726e 5f69 6e66 6f5b 226e 625f 726f 7773  rn_info["nb_rows
-000129f0: 5f64 6f6e 6522 5d20 3d20 6c65 6e28 696e  _done"] = len(in
-00012a00: 7075 745f 6764 6629 0d0a 2020 2020 6966  put_gdf)..    if
-00012a10: 2072 6574 7572 6e5f 696e 666f 5b22 6e62   return_info["nb
-00012a20: 5f72 6f77 735f 646f 6e65 225d 203d 3d20  _rows_done"] == 
-00012a30: 303a 0d0a 2020 2020 2020 2020 6d65 7373  0:..        mess
-00012a40: 6167 6520 3d20 6622 6469 7373 6f6c 7665  age = f"dissolve
-00012a50: 5f70 6f6c 7967 6f6e 733a 206e 6f20 696e  _polygons: no in
-00012a60: 7075 7420 6765 6f6d 6574 7269 6573 2066  put geometries f
-00012a70: 6f75 6e64 2069 6e20 7b69 6e70 7574 5f70  ound in {input_p
-00012a80: 6174 687d 220d 0a20 2020 2020 2020 206c  ath}"..        l
-00012a90: 6f67 6765 722e 696e 666f 286d 6573 7361  ogger.info(messa
-00012aa0: 6765 290d 0a20 2020 2020 2020 2072 6574  ge)..        ret
-00012ab0: 7572 6e5f 696e 666f 5b22 6d65 7373 6167  urn_info["messag
-00012ac0: 6522 5d20 3d20 6d65 7373 6167 650d 0a20  e"] = message.. 
-00012ad0: 2020 2020 2020 2072 6574 7572 6e5f 696e         return_in
-00012ae0: 666f 5b22 746f 7461 6c5f 7469 6d65 225d  fo["total_time"]
-00012af0: 203d 2028 6461 7465 7469 6d65 2e6e 6f77   = (datetime.now
-00012b00: 2829 202d 2073 7461 7274 5f74 696d 6529  () - start_time)
-00012b10: 2e74 6f74 616c 5f73 6563 6f6e 6473 2829  .total_seconds()
-00012b20: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00012b30: 2072 6574 7572 6e5f 696e 666f 0d0a 0d0a   return_info....
-00012b40: 2020 2020 2320 4e6f 7720 7468 6520 7265      # Now the re
-00012b50: 616c 2070 726f 6365 7373 696e 670d 0a20  al processing.. 
-00012b60: 2020 2061 6767 6675 6e63 3a20 556e 696f     aggfunc: Unio
-00012b70: 6e5b 7374 722c 2064 6963 742c 204e 6f6e  n[str, dict, Non
-00012b80: 655d 203d 204e 6f6e 650d 0a20 2020 2069  e] = None..    i
-00012b90: 6620 6167 675f 636f 6c75 6d6e 7320 6973  f agg_columns is
-00012ba0: 206e 6f74 204e 6f6e 653a 0d0a 2020 2020   not None:..    
-00012bb0: 2020 2020 6966 2022 5f5f 4449 5353 4f4c      if "__DISSOL
-00012bc0: 5645 5f54 4f4a 534f 4e22 206e 6f74 2069  VE_TOJSON" not i
-00012bd0: 6e20 696e 7075 745f 6764 662e 636f 6c75  n input_gdf.colu
-00012be0: 6d6e 733a 0d0a 2020 2020 2020 2020 2020  mns:..          
-00012bf0: 2020 2320 4669 7273 7420 7061 7373 202d    # First pass -
-00012c00: 3e20 7075 7420 7265 6c65 7661 6e74 2063  > put relevant c
-00012c10: 6f6c 756d 6e73 2069 6e20 6a73 6f6e 2066  olumns in json f
-00012c20: 6965 6c64 0d0a 2020 2020 2020 2020 2020  ield..          
-00012c30: 2020 6167 6766 756e 6320 3d20 7b22 746f    aggfunc = {"to
-00012c40: 5f6a 736f 6e22 3a20 6167 675f 636f 6c75  _json": agg_colu
-00012c50: 6d6e 735f 6e65 6564 6564 7d0d 0a20 2020  mns_needed}..   
-00012c60: 2020 2020 2065 6c73 653a 0d0a 2020 2020       else:..    
-00012c70: 2020 2020 2020 2020 2320 436f 6c75 6d6e          # Column
-00012c80: 7320 616c 7265 6164 7920 636f 6465 6420  s already coded 
-00012c90: 696e 2061 206a 736f 6e20 636f 6c75 6d6e  in a json column
-00012ca0: 2c20 736f 206d 6572 6765 206a 736f 6e20  , so merge json 
-00012cb0: 6c69 7374 730d 0a20 2020 2020 2020 2020  lists..         
-00012cc0: 2020 2061 6767 6675 6e63 203d 2022 6d65     aggfunc = "me
-00012cd0: 7267 655f 6a73 6f6e 5f6c 6973 7473 220d  rge_json_lists".
-00012ce0: 0a20 2020 2065 6c73 653a 0d0a 2020 2020  .    else:..    
-00012cf0: 2020 2020 6167 6766 756e 6320 3d20 2266      aggfunc = "f
-00012d00: 6972 7374 220d 0a20 2020 2073 7461 7274  irst"..    start
-00012d10: 5f64 6973 736f 6c76 6520 3d20 6461 7465  _dissolve = date
-00012d20: 7469 6d65 2e6e 6f77 2829 0d0a 2020 2020  time.now()..    
-00012d30: 6469 7373 5f67 6466 203d 205f 6469 7373  diss_gdf = _diss
-00012d40: 6f6c 7665 280d 0a20 2020 2020 2020 2064  olve(..        d
-00012d50: 663d 696e 7075 745f 6764 662c 2062 793d  f=input_gdf, by=
-00012d60: 6772 6f75 7062 795f 636f 6c75 6d6e 732c  groupby_columns,
-00012d70: 2061 6767 6675 6e63 3d61 6767 6675 6e63   aggfunc=aggfunc
-00012d80: 2c20 6173 5f69 6e64 6578 3d46 616c 7365  , as_index=False
-00012d90: 2c20 6472 6f70 6e61 3d46 616c 7365 0d0a  , dropna=False..
-00012da0: 2020 2020 290d 0a20 2020 2070 6572 6669      )..    perfi
-00012db0: 6e66 6f5b 2274 696d 655f 6469 7373 6f6c  nfo["time_dissol
-00012dc0: 7665 225d 203d 2028 6461 7465 7469 6d65  ve"] = (datetime
-00012dd0: 2e6e 6f77 2829 202d 2073 7461 7274 5f64  .now() - start_d
-00012de0: 6973 736f 6c76 6529 2e74 6f74 616c 5f73  issolve).total_s
-00012df0: 6563 6f6e 6473 2829 0d0a 0d0a 2020 2020  econds()....    
-00012e00: 2320 4966 2065 7870 6c6f 6465 636f 6c6c  # If explodecoll
-00012e10: 6563 7469 6f6e 7320 6973 2054 7275 6520  ections is True 
-00012e20: 616e 6420 466f 7220 706f 6c79 676f 6e73  and For polygons
-00012e30: 2c20 6578 706c 6f64 6520 6d75 6c74 692d  , explode multi-
-00012e40: 6765 6f6d 6574 7269 6573 2e0d 0a20 2020  geometries...   
-00012e50: 2023 2049 6620 6e65 6564 6564 2074 6865   # If needed the
-00012e60: 7920 7769 6c6c 2062 6520 2763 6f6c 6c65  y will be 'colle
-00012e70: 6374 6564 2720 6166 7465 7277 6172 6473  cted' afterwards
-00012e80: 2074 6f20 6d75 6c74 6970 6f6c 7967 6f6e   to multipolygon
-00012e90: 7320 6167 6169 6e2e 0d0a 2020 2020 6966  s again...    if
-00012ea0: 2065 7870 6c6f 6465 636f 6c6c 6563 7469   explodecollecti
-00012eb0: 6f6e 7320 6973 2054 7275 6520 6f72 2069  ons is True or i
-00012ec0: 6e70 7574 5f67 656f 6d65 7472 7974 7970  nput_geometrytyp
-00012ed0: 6520 696e 205b 0d0a 2020 2020 2020 2020  e in [..        
-00012ee0: 4765 6f6d 6574 7279 5479 7065 2e50 4f4c  GeometryType.POL
-00012ef0: 5947 4f4e 2c0d 0a20 2020 2020 2020 2047  YGON,..        G
-00012f00: 656f 6d65 7472 7954 7970 652e 4d55 4c54  eometryType.MULT
-00012f10: 4950 4f4c 5947 4f4e 2c0d 0a20 2020 205d  IPOLYGON,..    ]
-00012f20: 3a0d 0a20 2020 2020 2020 2064 6973 735f  :..        diss_
-00012f30: 6764 6620 3d20 6469 7373 5f67 6466 2e65  gdf = diss_gdf.e
-00012f40: 7870 6c6f 6465 2869 676e 6f72 655f 696e  xplode(ignore_in
-00012f50: 6465 783d 5472 7565 290d 0a0d 0a20 2020  dex=True)....   
-00012f60: 2023 2043 6c69 7020 7468 6520 7265 7375   # Clip the resu
-00012f70: 6c74 206f 6e20 7468 6520 626f 7264 6572  lt on the border
-00012f80: 7320 6f66 2074 6865 2062 626f 7820 6e6f  s of the bbox no
-00012f90: 7420 746f 2068 6176 6520 6f76 6572 6c61  t to have overla
-00012fa0: 7073 0d0a 2020 2020 2320 6265 7477 6565  ps..    # betwee
-00012fb0: 6e20 7468 6520 6469 6666 6572 656e 7420  n the different 
-00012fc0: 7469 6c65 732e 0d0a 2020 2020 2320 4966  tiles...    # If
-00012fd0: 2074 6869 7320 6973 206e 6f74 2061 7070   this is not app
-00012fe0: 6c69 6564 2c20 7468 6973 2072 6573 756c  lied, this resul
-00012ff0: 7473 2069 6e20 736f 6d65 2067 656f 6d65  ts in some geome
-00013000: 7472 6965 7320 6e6f 7420 6265 696e 6720  tries not being 
-00013010: 6d65 7267 6564 0d0a 2020 2020 2320 6f72  merged..    # or
-00013020: 2069 6e20 6475 706c 6963 6174 6573 2e0d   in duplicates..
-00013030: 0a20 2020 2023 2052 454d 4152 4b3a 2066  .    # REMARK: f
-00013040: 6f72 2028 6d75 6c74 6929 6c69 6e65 7374  or (multi)linest
-00013050: 7269 6e67 732c 2074 6865 2065 6e64 706f  rings, the endpo
-00013060: 696e 7473 2063 7265 6174 6564 2062 7920  ints created by 
-00013070: 7468 6520 636c 6970 2061 7265 206e 6f74  the clip are not
-00013080: 0d0a 2020 2020 2320 616c 7761 7973 2074  ..    # always t
-00013090: 6865 2073 616d 6520 6475 6520 746f 2072  he same due to r
-000130a0: 6f75 6e64 696e 672c 2073 6f20 6469 7373  ounding, so diss
-000130b0: 6f6c 7669 6e67 2069 6e20 6120 6e65 7874  olving in a next
-000130c0: 2070 6173 7320 646f 6573 6e27 740d 0a20   pass doesn't.. 
-000130d0: 2020 2023 2061 6c77 6179 7320 7265 7375     # always resu
-000130e0: 6c74 2069 6e20 6c69 6e65 7374 7269 6e67  lt in linestring
-000130f0: 7320 6265 696e 6720 7265 2d63 6f6e 6e65  s being re-conne
-00013100: 6374 6564 2e2e 2e20 4265 6361 7573 6520  cted... Because 
-00013110: 6469 7373 6f6c 7669 6e67 0d0a 2020 2020  dissolving..    
-00013120: 2320 6c69 6e65 7320 6973 6e27 7420 736f  # lines isn't so
-00013130: 2063 6f6d 7075 7461 7469 6f6e 616c 6c79   computationally
-00013140: 2068 6561 7679 2061 6e79 7761 792c 2064   heavy anyway, d
-00013150: 726f 7020 7375 7070 6f72 7420 6865 7265  rop support here
-00013160: 2e0d 0a20 2020 2069 6620 6262 6f78 2069  ...    if bbox i
-00013170: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
-00013180: 2020 2020 2073 7461 7274 5f63 6c69 7020       start_clip 
-00013190: 3d20 6461 7465 7469 6d65 2e6e 6f77 2829  = datetime.now()
-000131a0: 0d0a 2020 2020 2020 2020 6262 6f78 5f70  ..        bbox_p
-000131b0: 6f6c 7967 6f6e 203d 2073 685f 6765 6f6d  olygon = sh_geom
-000131c0: 2e50 6f6c 7967 6f6e 280d 0a20 2020 2020  .Polygon(..     
-000131d0: 2020 2020 2020 205b 0d0a 2020 2020 2020         [..      
-000131e0: 2020 2020 2020 2020 2020 2862 626f 785b            (bbox[
-000131f0: 305d 2c20 6262 6f78 5b31 5d29 2c0d 0a20  0], bbox[1]),.. 
-00013200: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-00013210: 6262 6f78 5b30 5d2c 2062 626f 785b 335d  bbox[0], bbox[3]
-00013220: 292c 0d0a 2020 2020 2020 2020 2020 2020  ),..            
-00013230: 2020 2020 2862 626f 785b 325d 2c20 6262      (bbox[2], bb
-00013240: 6f78 5b33 5d29 2c0d 0a20 2020 2020 2020  ox[3]),..       
-00013250: 2020 2020 2020 2020 2028 6262 6f78 5b32           (bbox[2
-00013260: 5d2c 2062 626f 785b 315d 292c 0d0a 2020  ], bbox[1]),..  
-00013270: 2020 2020 2020 2020 2020 2020 2020 2862                (b
-00013280: 626f 785b 305d 2c20 6262 6f78 5b31 5d29  box[0], bbox[1])
-00013290: 2c0d 0a20 2020 2020 2020 2020 2020 205d  ,..            ]
-000132a0: 0d0a 2020 2020 2020 2020 290d 0a20 2020  ..        )..   
-000132b0: 2020 2020 2062 626f 785f 6764 6620 3d20       bbox_gdf = 
-000132c0: 6770 642e 4765 6f44 6174 6146 7261 6d65  gpd.GeoDataFrame
-000132d0: 280d 0a20 2020 2020 2020 2020 2020 2064  (..            d
-000132e0: 6174 613d 5b31 5d2c 2067 656f 6d65 7472  ata=[1], geometr
-000132f0: 793d 5b62 626f 785f 706f 6c79 676f 6e5d  y=[bbox_polygon]
-00013300: 2c20 6372 733d 696e 7075 745f 6764 662e  , crs=input_gdf.
-00013310: 6372 730d 0a20 2020 2020 2020 2029 0d0a  crs..        )..
-00013320: 0d0a 2020 2020 2020 2020 2320 4361 7463  ..        # Catc
-00013330: 6820 6972 7265 6c65 7661 6e74 2070 616e  h irrelevant pan
-00013340: 6461 7320 6675 7475 7265 2077 6172 6e69  das future warni
-00013350: 6e67 0d0a 2020 2020 2020 2020 2320 544f  ng..        # TO
-00013360: 444f 3a20 7768 656e 2072 656d 6f76 6564  DO: when removed
-00013370: 2069 6e20 6c61 7465 7220 7665 7273 696f   in later versio
-00013380: 6e20 6f66 2070 616e 6461 732c 2063 616e  n of pandas, can
-00013390: 2062 6520 7265 6d6f 7665 6420 6865 7265   be removed here
-000133a0: 0d0a 2020 2020 2020 2020 7769 7468 2077  ..        with w
-000133b0: 6172 6e69 6e67 732e 6361 7463 685f 7761  arnings.catch_wa
-000133c0: 726e 696e 6773 2829 3a0d 0a20 2020 2020  rnings():..     
-000133d0: 2020 2020 2020 206d 6573 7361 6765 203d         message =
-000133e0: 2028 0d0a 2020 2020 2020 2020 2020 2020   (..            
-000133f0: 2020 2020 2249 6e20 6120 6675 7475 7265      "In a future
-00013400: 2076 6572 7369 6f6e 2c20 6064 662e 696c   version, `df.il
-00013410: 6f63 5b3a 2c20 695d 203d 206e 6577 7661  oc[:, i] = newva
-00013420: 6c73 6020 7769 6c6c 2061 7474 656d 7074  ls` will attempt
-00013430: 2074 6f20 220d 0a20 2020 2020 2020 2020   to "..         
-00013440: 2020 2020 2020 2022 7365 7420 7468 6520         "set the 
-00013450: 7661 6c75 6573 2069 6e70 6c61 6365 2069  values inplace i
-00013460: 6e73 7465 6164 206f 6620 616c 7761 7973  nstead of always
-00013470: 2073 6574 7469 6e67 2061 206e 6577 2061   setting a new a
-00013480: 7272 6179 2e22 0d0a 2020 2020 2020 2020  rray."..        
-00013490: 2020 2020 290d 0a20 2020 2020 2020 2020      )..         
-000134a0: 2020 2077 6172 6e69 6e67 732e 6669 6c74     warnings.filt
-000134b0: 6572 7761 726e 696e 6773 280d 0a20 2020  erwarnings(..   
-000134c0: 2020 2020 2020 2020 2020 2020 2061 6374               act
-000134d0: 696f 6e3d 2269 676e 6f72 6522 2c20 6361  ion="ignore", ca
-000134e0: 7465 676f 7279 3d46 7574 7572 6557 6172  tegory=FutureWar
-000134f0: 6e69 6e67 2c20 6d65 7373 6167 653d 7265  ning, message=re
-00013500: 2e65 7363 6170 6528 6d65 7373 6167 6529  .escape(message)
-00013510: 0d0a 2020 2020 2020 2020 2020 2020 290d  ..            ).
-00013520: 0a20 2020 2020 2020 2020 2020 2023 206b  .            # k
-00013530: 6565 705f 6765 6f6d 5f74 7970 653d 5472  eep_geom_type=Tr
-00013540: 7565 2067 6176 6520 736f 6d65 7469 6d65  ue gave sometime
-00013550: 7320 6572 726f 722c 2061 6e64 2073 7469  s error, and sti
-00013560: 6c6c 2064 6f65 7320 696e 2030 2e39 2e30  ll does in 0.9.0
-00013570: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00013580: 736f 2075 7365 206f 776e 2069 6d70 6c65  so use own imple
-00013590: 6d65 6e74 6174 696f 6e20 6f66 206b 6565  mentation of kee
-000135a0: 705f 6765 6f6d 5f74 7970 650d 0a20 2020  p_geom_type..   
-000135b0: 2020 2020 2020 2020 2064 6973 735f 6764           diss_gd
-000135c0: 6620 3d20 6770 642e 636c 6970 2864 6973  f = gpd.clip(dis
-000135d0: 735f 6764 662c 2062 626f 785f 6764 6629  s_gdf, bbox_gdf)
-000135e0: 2020 2320 2c20 6b65 6570 5f67 656f 6d5f    # , keep_geom_
-000135f0: 7479 7065 3d54 7275 6529 0d0a 2020 2020  type=True)..    
-00013600: 2020 2020 2020 2020 6173 7365 7274 2069          assert i
-00013610: 7369 6e73 7461 6e63 6528 6469 7373 5f67  sinstance(diss_g
-00013620: 6466 2c20 6770 642e 4765 6f44 6174 6146  df, gpd.GeoDataF
-00013630: 7261 6d65 290d 0a0d 0a20 2020 2020 2020  rame)....       
-00013640: 2023 204f 6e6c 7920 6b65 6570 2067 656f   # Only keep geo
-00013650: 6d65 7472 6965 7320 6f66 2074 6865 2070  metries of the p
-00013660: 7269 6d69 7469 7665 2074 7970 6520 7370  rimitive type sp
-00013670: 6563 6966 6965 6420 6166 7465 7220 636c  ecified after cl
-00013680: 6970 2e2e 2e0d 0a20 2020 2020 2020 2061  ip.....        a
-00013690: 7373 6572 7420 6973 696e 7374 616e 6365  ssert isinstance
-000136a0: 2864 6973 735f 6764 662c 2067 7064 2e47  (diss_gdf, gpd.G
-000136b0: 656f 4461 7461 4672 616d 6529 0d0a 2020  eoDataFrame)..  
-000136c0: 2020 2020 2020 6469 7373 5f67 6466 2e67        diss_gdf.g
-000136d0: 656f 6d65 7472 7920 3d20 7079 6765 6f6f  eometry = pygeoo
-000136e0: 7073 2e63 6f6c 6c65 6374 696f 6e5f 6578  ps.collection_ex
-000136f0: 7472 6163 7428 0d0a 2020 2020 2020 2020  tract(..        
-00013700: 2020 2020 6469 7373 5f67 6466 2e67 656f      diss_gdf.geo
-00013710: 6d65 7472 792c 2070 7269 6d69 7469 7665  metry, primitive
-00013720: 7479 7065 3d69 6e70 7574 5f67 656f 6d65  type=input_geome
-00013730: 7472 7974 7970 652e 746f 5f70 7269 6d69  trytype.to_primi
-00013740: 7469 7665 7479 7065 0d0a 2020 2020 2020  tivetype..      
-00013750: 2020 290d 0a0d 0a20 2020 2020 2020 2070    )....        p
-00013760: 6572 6669 6e66 6f5b 2274 696d 655f 636c  erfinfo["time_cl
-00013770: 6970 225d 203d 2028 6461 7465 7469 6d65  ip"] = (datetime
-00013780: 2e6e 6f77 2829 202d 2073 7461 7274 5f63  .now() - start_c
-00013790: 6c69 7029 2e74 6f74 616c 5f73 6563 6f6e  lip).total_secon
-000137a0: 6473 2829 0d0a 0d0a 2020 2020 2320 5365  ds()....    # Se
-000137b0: 7420 656d 7074 7920 6765 6f6d 6574 7269  t empty geometri
-000137c0: 6573 2074 6f20 6e75 6c6c 2f4e 6f6e 650d  es to null/None.
-000137d0: 0a20 2020 2061 7373 6572 7420 6469 7373  .    assert diss
-000137e0: 5f67 6466 2e67 656f 6d65 7472 7920 6973  _gdf.geometry is
-000137f0: 206e 6f74 204e 6f6e 650d 0a20 2020 2064   not None..    d
-00013800: 6973 735f 6764 662e 6c6f 635b 0d0a 2020  iss_gdf.loc[..  
-00013810: 2020 2020 2020 6469 7373 5f67 6466 2e67        diss_gdf.g
-00013820: 656f 6d65 7472 792e 6973 5f65 6d70 7479  eometry.is_empty
-00013830: 2c20 5b22 6765 6f6d 6574 7279 225d 2020  , ["geometry"]  
-00013840: 2320 7479 7065 3a20 6967 6e6f 7265 5b75  # type: ignore[u
-00013850: 6e69 6f6e 2d61 7474 725d 0d0a 2020 2020  nion-attr]..    
-00013860: 5d20 3d20 4e6f 6e65 0d0a 0d0a 2020 2020  ] = None....    
-00013870: 2320 5265 6d6f 7665 2072 6f77 7320 7768  # Remove rows wh
-00013880: 6572 6520 6765 6f6d 2069 7320 4e6f 6e65  ere geom is None
-00013890: 2f6e 756c 6c2f 656d 7074 790d 0a20 2020  /null/empty..   
-000138a0: 2069 6620 6e6f 7420 6b65 6570 5f65 6d70   if not keep_emp
-000138b0: 7479 5f67 656f 6d73 3a0d 0a20 2020 2020  ty_geoms:..     
-000138c0: 2020 2061 7373 6572 7420 6973 696e 7374     assert isinst
-000138d0: 616e 6365 2864 6973 735f 6764 662c 2067  ance(diss_gdf, g
-000138e0: 7064 2e47 656f 4461 7461 4672 616d 6529  pd.GeoDataFrame)
-000138f0: 0d0a 2020 2020 2020 2020 6469 7373 5f67  ..        diss_g
-00013900: 6466 203d 2064 6973 735f 6764 665b 7e64  df = diss_gdf[~d
-00013910: 6973 735f 6764 662e 6765 6f6d 6574 7279  iss_gdf.geometry
-00013920: 2e69 736e 6128 295d 2020 2320 7479 7065  .isna()]  # type
-00013930: 3a20 6967 6e6f 7265 5b75 6e69 6f6e 2d61  : ignore[union-a
-00013940: 7474 725d 0d0a 0d0a 2020 2020 2320 4966  ttr]....    # If
-00013950: 2074 6865 7265 2069 7320 6e6f 2072 6573   there is no res
-00013960: 756c 742c 2072 6574 7572 6e0d 0a20 2020  ult, return..   
-00013970: 2069 6620 6c65 6e28 6469 7373 5f67 6466   if len(diss_gdf
-00013980: 2920 3d3d 2030 3a0d 0a20 2020 2020 2020  ) == 0:..       
-00013990: 206d 6573 7361 6765 203d 2066 2252 6573   message = f"Res
-000139a0: 756c 7420 6973 2065 6d70 7479 2066 6f72  ult is empty for
-000139b0: 207b 696e 7075 745f 7061 7468 7d22 0d0a   {input_path}"..
-000139c0: 2020 2020 2020 2020 7265 7475 726e 5f69          return_i
-000139d0: 6e66 6f5b 226d 6573 7361 6765 225d 203d  nfo["message"] =
-000139e0: 206d 6573 7361 6765 0d0a 2020 2020 2020   message..      
-000139f0: 2020 7265 7475 726e 5f69 6e66 6f5b 2270    return_info["p
-00013a00: 6572 6669 6e66 6f22 5d20 3d20 7065 7266  erfinfo"] = perf
-00013a10: 696e 666f 0d0a 2020 2020 2020 2020 7265  info..        re
-00013a20: 7475 726e 5f69 6e66 6f5b 2274 6f74 616c  turn_info["total
-00013a30: 5f74 696d 6522 5d20 3d20 2864 6174 6574  _time"] = (datet
-00013a40: 696d 652e 6e6f 7728 2920 2d20 7374 6172  ime.now() - star
-00013a50: 745f 7469 6d65 292e 746f 7461 6c5f 7365  t_time).total_se
-00013a60: 636f 6e64 7328 290d 0a20 2020 2020 2020  conds()..       
-00013a70: 2072 6574 7572 6e20 7265 7475 726e 5f69   return return_i
-00013a80: 6e66 6f0d 0a0d 0a20 2020 2023 2041 6464  nfo....    # Add
-00013a90: 2063 6f6c 756d 6e20 7769 7468 2074 696c   column with til
-00013aa0: 655f 6964 0d0a 2020 2020 6173 7365 7274  e_id..    assert
-00013ab0: 2069 7369 6e73 7461 6e63 6528 6469 7373   isinstance(diss
-00013ac0: 5f67 6466 2c20 6770 642e 4765 6f44 6174  _gdf, gpd.GeoDat
-00013ad0: 6146 7261 6d65 290d 0a20 2020 2069 6620  aFrame)..    if 
-00013ae0: 7469 6c65 5f69 6420 6973 206e 6f74 204e  tile_id is not N
-00013af0: 6f6e 653a 0d0a 2020 2020 2020 2020 6469  one:..        di
-00013b00: 7373 5f67 6466 5b22 7469 6c65 5f69 6422  ss_gdf["tile_id"
-00013b10: 5d20 3d20 7469 6c65 5f69 640d 0a0d 0a20  ] = tile_id.... 
-00013b20: 2020 2069 6620 6772 6964 7369 7a65 2021     if gridsize !
-00013b30: 3d20 302e 303a 0d0a 2020 2020 2020 2020  = 0.0:..        
-00013b40: 6469 7373 5f67 6466 2e67 656f 6d65 7472  diss_gdf.geometr
-00013b50: 7920 3d20 5f67 656f 7365 7269 6573 5f75  y = _geoseries_u
-00013b60: 7469 6c2e 7365 745f 7072 6563 6973 696f  til.set_precisio
-00013b70: 6e28 0d0a 2020 2020 2020 2020 2020 2020  n(..            
-00013b80: 6469 7373 5f67 6466 2e67 656f 6d65 7472  diss_gdf.geometr
-00013b90: 792c 2067 7269 645f 7369 7a65 3d67 7269  y, grid_size=gri
-00013ba0: 6473 697a 652c 2072 6169 7365 5f6f 6e5f  dsize, raise_on_
-00013bb0: 746f 706f 6572 726f 723d 4661 6c73 650d  topoerror=False.
-00013bc0: 0a20 2020 2020 2020 2029 0d0a 0d0a 2020  .        )....  
-00013bd0: 2020 2320 5361 7665 2074 6865 2072 6573    # Save the res
-00013be0: 756c 7420 746f 2064 6573 7469 6e61 7469  ult to destinati
-00013bf0: 6f6e 2066 696c 6528 7329 0d0a 2020 2020  on file(s)..    
-00013c00: 7374 6172 745f 746f 5f66 696c 6520 3d20  start_to_file = 
-00013c10: 6461 7465 7469 6d65 2e6e 6f77 2829 0d0a  datetime.now()..
-00013c20: 0d0a 2020 2020 2320 4966 2074 6865 2074  ..    # If the t
-00013c30: 696c 6573 2064 6f6e 2774 206e 6565 6420  iles don't need 
-00013c40: 746f 2062 6520 6d65 7267 6564 2061 6674  to be merged aft
-00013c50: 6572 7761 7264 732c 2077 6520 6361 6e20  erwards, we can 
-00013c60: 6a75 7374 2073 6176 6520 7468 6520 7265  just save the re
-00013c70: 7375 6c74 2061 730d 0a20 2020 2023 2069  sult as..    # i
-00013c80: 7420 6973 2e0d 0a20 2020 2069 6620 7374  t is...    if st
-00013c90: 7228 6f75 7470 7574 5f6e 6f74 6f6e 626f  r(output_notonbo
-00013ca0: 7264 6572 5f70 6174 6829 203d 3d20 7374  rder_path) == st
-00013cb0: 7228 6f75 7470 7574 5f6f 6e62 6f72 6465  r(output_onborde
-00013cc0: 725f 7061 7468 293a 0d0a 2020 2020 2020  r_path):..      
-00013cd0: 2020 2320 6173 7365 7274 2074 6f20 6176    # assert to av
-00013ce0: 6f69 6420 7079 4c61 6e63 6520 7761 726e  oid pyLance warn
-00013cf0: 696e 670d 0a20 2020 2020 2020 2061 7373  ing..        ass
-00013d00: 6572 7420 6973 696e 7374 616e 6365 2864  ert isinstance(d
-00013d10: 6973 735f 6764 662c 2067 7064 2e47 656f  iss_gdf, gpd.Geo
-00013d20: 4461 7461 4672 616d 6529 0d0a 2020 2020  DataFrame)..    
-00013d30: 2020 2020 2320 5573 6520 666f 7263 655f      # Use force_
-00013d40: 6d75 6c74 6974 7970 652c 2074 6f20 6176  multitype, to av
-00013d50: 6f69 6420 7761 726e 696e 6773 2077 6865  oid warnings whe
-00013d60: 6e20 736f 6d65 2062 6174 6368 6573 2063  n some batches c
-00013d70: 6f6e 7461 696e 0d0a 2020 2020 2020 2020  ontain..        
-00013d80: 2320 7369 6e67 6c65 7479 7065 2061 6e64  # singletype and
-00013d90: 2073 6f6d 6520 636f 6e74 6169 6e20 6d75   some contain mu
-00013da0: 6c74 6974 7970 6520 6765 6f6d 6574 7269  ltitype geometri
-00013db0: 6573 0d0a 2020 2020 2020 2020 6766 6f2e  es..        gfo.
-00013dc0: 746f 5f66 696c 6528 0d0a 2020 2020 2020  to_file(..      
-00013dd0: 2020 2020 2020 6469 7373 5f67 6466 2c0d        diss_gdf,.
-00013de0: 0a20 2020 2020 2020 2020 2020 206f 7574  .            out
-00013df0: 7075 745f 6e6f 746f 6e62 6f72 6465 725f  put_notonborder_
-00013e00: 7061 7468 2c0d 0a20 2020 2020 2020 2020  path,..         
-00013e10: 2020 206c 6179 6572 3d6f 7574 7075 745f     layer=output_
-00013e20: 6c61 7965 722c 0d0a 2020 2020 2020 2020  layer,..        
-00013e30: 2020 2020 666f 7263 655f 6d75 6c74 6974      force_multit
-00013e40: 7970 653d 5472 7565 2c0d 0a20 2020 2020  ype=True,..     
-00013e50: 2020 2020 2020 2069 6e64 6578 3d46 616c         index=Fal
-00013e60: 7365 2c0d 0a20 2020 2020 2020 2020 2020  se,..           
-00013e70: 2063 7265 6174 655f 7370 6174 6961 6c5f   create_spatial_
-00013e80: 696e 6465 783d 4661 6c73 652c 0d0a 2020  index=False,..  
-00013e90: 2020 2020 2020 290d 0a20 2020 2065 6c73        )..    els
-00013ea0: 653a 0d0a 2020 2020 2020 2020 2320 4966  e:..        # If
-00013eb0: 206e 6f74 2c20 7361 7665 2074 6865 2070   not, save the p
-00013ec0: 6f6c 7967 6f6e 7320 6f6e 2074 6865 2062  olygons on the b
-00013ed0: 6f72 6465 7220 7365 7065 7261 7465 6c79  order seperately
-00013ee0: 0d0a 2020 2020 2020 2020 6262 6f78 5f6c  ..        bbox_l
-00013ef0: 696e 6573 203d 2070 7967 656f 6f70 732e  ines = pygeoops.
-00013f00: 6578 706c 6f64 6528 0d0a 2020 2020 2020  explode(..      
-00013f10: 2020 2020 2020 7368 6170 656c 792e 626f        shapely.bo
-00013f20: 756e 6461 7279 2873 685f 6765 6f6d 2e62  undary(sh_geom.b
-00013f30: 6f78 2862 626f 785b 305d 2c20 6262 6f78  ox(bbox[0], bbox
-00013f40: 5b31 5d2c 2062 626f 785b 325d 2c20 6262  [1], bbox[2], bb
-00013f50: 6f78 5b33 5d29 290d 0a20 2020 2020 2020  ox[3]))..       
-00013f60: 2029 0d0a 2020 2020 2020 2020 6262 6f78   )..        bbox
-00013f70: 5f6c 696e 6573 5f67 6466 203d 2067 7064  _lines_gdf = gpd
-00013f80: 2e47 656f 4461 7461 4672 616d 6528 6765  .GeoDataFrame(ge
-00013f90: 6f6d 6574 7279 3d62 626f 785f 6c69 6e65  ometry=bbox_line
-00013fa0: 732c 2063 7273 3d69 6e70 7574 5f67 6466  s, crs=input_gdf
-00013fb0: 2e63 7273 290d 0a20 2020 2020 2020 206f  .crs)..        o
-00013fc0: 6e62 6f72 6465 725f 6764 6620 3d20 6770  nborder_gdf = gp
-00013fd0: 642e 736a 6f69 6e28 6469 7373 5f67 6466  d.sjoin(diss_gdf
-00013fe0: 2c20 6262 6f78 5f6c 696e 6573 5f67 6466  , bbox_lines_gdf
-00013ff0: 2c20 7072 6564 6963 6174 653d 2269 6e74  , predicate="int
-00014000: 6572 7365 6374 7322 290d 0a20 2020 2020  ersects")..     
-00014010: 2020 206f 6e62 6f72 6465 725f 6764 662e     onborder_gdf.
-00014020: 6472 6f70 2822 696e 6465 785f 7269 6768  drop("index_righ
-00014030: 7422 2c20 6178 6973 3d31 2c20 696e 706c  t", axis=1, inpl
-00014040: 6163 653d 5472 7565 290d 0a20 2020 2020  ace=True)..     
-00014050: 2020 2069 6620 6c65 6e28 6f6e 626f 7264     if len(onbord
-00014060: 6572 5f67 6466 2920 3e20 303a 0d0a 2020  er_gdf) > 0:..  
-00014070: 2020 2020 2020 2020 2020 2320 5573 6520            # Use 
-00014080: 666f 7263 655f 6d75 6c74 6974 7970 652c  force_multitype,
-00014090: 2074 6f20 6176 6f69 6420 7761 726e 696e   to avoid warnin
-000140a0: 6773 2077 6865 6e20 736f 6d65 2062 6174  gs when some bat
-000140b0: 6368 6573 2063 6f6e 7461 696e 0d0a 2020  ches contain..  
-000140c0: 2020 2020 2020 2020 2020 2320 7369 6e67            # sing
-000140d0: 6c65 7479 7065 2061 6e64 2073 6f6d 6520  letype and some 
-000140e0: 636f 6e74 6169 6e20 6d75 6c74 6974 7970  contain multityp
-000140f0: 6520 6765 6f6d 6574 7269 6573 0d0a 2020  e geometries..  
-00014100: 2020 2020 2020 2020 2020 6766 6f2e 746f            gfo.to
-00014110: 5f66 696c 6528 0d0a 2020 2020 2020 2020  _file(..        
-00014120: 2020 2020 2020 2020 6f6e 626f 7264 6572          onborder
-00014130: 5f67 6466 2c0d 0a20 2020 2020 2020 2020  _gdf,..         
-00014140: 2020 2020 2020 206f 7574 7075 745f 6f6e         output_on
-00014150: 626f 7264 6572 5f70 6174 682c 0d0a 2020  border_path,..  
-00014160: 2020 2020 2020 2020 2020 2020 2020 6c61                la
-00014170: 7965 723d 6f75 7470 7574 5f6c 6179 6572  yer=output_layer
-00014180: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00014190: 2020 2066 6f72 6365 5f6d 756c 7469 7479     force_multity
-000141a0: 7065 3d54 7275 652c 0d0a 2020 2020 2020  pe=True,..      
-000141b0: 2020 2020 2020 2020 2020 6372 6561 7465            create
-000141c0: 5f73 7061 7469 616c 5f69 6e64 6578 3d46  _spatial_index=F
-000141d0: 616c 7365 2c0d 0a20 2020 2020 2020 2020  alse,..         
-000141e0: 2020 2029 0d0a 0d0a 2020 2020 2020 2020     )....        
-000141f0: 6e6f 746f 6e62 6f72 6465 725f 6764 6620  notonborder_gdf 
-00014200: 3d20 6469 7373 5f67 6466 5b7e 6469 7373  = diss_gdf[~diss
-00014210: 5f67 6466 2e69 6e64 6578 2e69 7369 6e28  _gdf.index.isin(
-00014220: 6f6e 626f 7264 6572 5f67 6466 2e69 6e64  onborder_gdf.ind
-00014230: 6578 295d 0d0a 2020 2020 2020 2020 6966  ex)]..        if
-00014240: 206c 656e 286e 6f74 6f6e 626f 7264 6572   len(notonborder
-00014250: 5f67 6466 2920 3e20 303a 0d0a 2020 2020  _gdf) > 0:..    
-00014260: 2020 2020 2020 2020 2320 5573 6520 666f          # Use fo
-00014270: 7263 655f 6d75 6c74 6974 7970 652c 2074  rce_multitype, t
-00014280: 6f20 6176 6f69 6420 7761 726e 696e 6773  o avoid warnings
-00014290: 2077 6865 6e20 736f 6d65 2062 6174 6368   when some batch
-000142a0: 6573 2063 6f6e 7461 696e 0d0a 2020 2020  es contain..    
-000142b0: 2020 2020 2020 2020 2320 7369 6e67 6c65          # single
-000142c0: 7479 7065 2061 6e64 2073 6f6d 6520 636f  type and some co
-000142d0: 6e74 6169 6e20 6d75 6c74 6974 7970 6520  ntain multitype 
-000142e0: 6765 6f6d 6574 7269 6573 0d0a 2020 2020  geometries..    
-000142f0: 2020 2020 2020 2020 6766 6f2e 746f 5f66          gfo.to_f
-00014300: 696c 6528 0d0a 2020 2020 2020 2020 2020  ile(..          
-00014310: 2020 2020 2020 6e6f 746f 6e62 6f72 6465        notonborde
-00014320: 725f 6764 662c 0d0a 2020 2020 2020 2020  r_gdf,..        
-00014330: 2020 2020 2020 2020 6f75 7470 7574 5f6e          output_n
-00014340: 6f74 6f6e 626f 7264 6572 5f70 6174 682c  otonborder_path,
-00014350: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00014360: 2020 6c61 7965 723d 6f75 7470 7574 5f6c    layer=output_l
-00014370: 6179 6572 2c0d 0a20 2020 2020 2020 2020  ayer,..         
-00014380: 2020 2020 2020 2066 6f72 6365 5f6d 756c         force_mul
-00014390: 7469 7479 7065 3d54 7275 652c 0d0a 2020  titype=True,..  
-000143a0: 2020 2020 2020 2020 2020 2020 2020 696e                in
-000143b0: 6465 783d 4661 6c73 652c 0d0a 2020 2020  dex=False,..    
-000143c0: 2020 2020 2020 2020 2020 2020 6372 6561              crea
-000143d0: 7465 5f73 7061 7469 616c 5f69 6e64 6578  te_spatial_index
-000143e0: 3d46 616c 7365 2c0d 0a20 2020 2020 2020  =False,..       
-000143f0: 2020 2020 2029 0d0a 2020 2020 7065 7266       )..    perf
-00014400: 696e 666f 5b22 7469 6d65 5f74 6f5f 6669  info["time_to_fi
-00014410: 6c65 225d 203d 2028 6461 7465 7469 6d65  le"] = (datetime
-00014420: 2e6e 6f77 2829 202d 2073 7461 7274 5f74  .now() - start_t
-00014430: 6f5f 6669 6c65 292e 746f 7461 6c5f 7365  o_file).total_se
-00014440: 636f 6e64 7328 290d 0a0d 0a20 2020 2023  conds()....    #
-00014450: 2046 696e 616c 6973 652e 2e2e 0d0a 2020   Finalise.....  
-00014460: 2020 6d65 7373 6167 6520 3d20 6622 6469    message = f"di
-00014470: 7373 6f6c 7665 5f70 6f6c 7967 6f6e 733a  ssolve_polygons:
-00014480: 2072 6561 6479 2069 6e20 7b64 6174 6574   ready in {datet
-00014490: 696d 652e 6e6f 7728 292d 7374 6172 745f  ime.now()-start_
-000144a0: 7469 6d65 7d20 6f6e 207b 696e 7075 745f  time} on {input_
-000144b0: 7061 7468 7d22 0d0a 2020 2020 6c6f 6767  path}"..    logg
-000144c0: 6572 2e64 6562 7567 286d 6573 7361 6765  er.debug(message
-000144d0: 290d 0a0d 0a20 2020 2023 2043 6f6c 6c65  )....    # Colle
-000144e0: 6374 2070 6572 6669 6e66 6f0d 0a20 2020  ct perfinfo..   
-000144f0: 2074 6f74 616c 5f70 6572 665f 7469 6d65   total_perf_time
-00014500: 203d 2030 2e30 0d0a 2020 2020 7065 7266   = 0.0..    perf
-00014510: 7374 7269 6e67 203d 2022 220d 0a20 2020  string = ""..   
-00014520: 2066 6f72 2070 6572 6663 6f64 6520 696e   for perfcode in
-00014530: 2070 6572 6669 6e66 6f3a 0d0a 2020 2020   perfinfo:..    
-00014540: 2020 2020 746f 7461 6c5f 7065 7266 5f74      total_perf_t
-00014550: 696d 6520 2b3d 2070 6572 6669 6e66 6f5b  ime += perfinfo[
-00014560: 7065 7266 636f 6465 5d0d 0a20 2020 2020  perfcode]..     
-00014570: 2020 2070 6572 6673 7472 696e 6720 2b3d     perfstring +=
-00014580: 2066 227b 7065 7266 636f 6465 7d3a 207b   f"{perfcode}: {
-00014590: 7065 7266 696e 666f 5b70 6572 6663 6f64  perfinfo[perfcod
-000145a0: 655d 3a2e 3266 7d2c 2022 0d0a 2020 2020  e]:.2f}, "..    
-000145b0: 7265 7475 726e 5f69 6e66 6f5b 2274 6f74  return_info["tot
-000145c0: 616c 5f74 696d 6522 5d20 3d20 2864 6174  al_time"] = (dat
-000145d0: 6574 696d 652e 6e6f 7728 2920 2d20 7374  etime.now() - st
-000145e0: 6172 745f 7469 6d65 292e 746f 7461 6c5f  art_time).total_
-000145f0: 7365 636f 6e64 7328 290d 0a20 2020 2070  seconds()..    p
-00014600: 6572 6669 6e66 6f5b 2275 6e61 6363 6f75  erfinfo["unaccou
-00014610: 6e74 6564 225d 203d 2028 0d0a 2020 2020  nted"] = (..    
-00014620: 2020 2020 7265 7475 726e 5f69 6e66 6f5b      return_info[
-00014630: 2274 6f74 616c 5f74 696d 6522 5d20 2d20  "total_time"] - 
-00014640: 746f 7461 6c5f 7065 7266 5f74 696d 6520  total_perf_time 
-00014650: 2023 2074 7970 653a 2069 676e 6f72 655b   # type: ignore[
-00014660: 6f70 6572 6174 6f72 5d0d 0a20 2020 2029  operator]..    )
-00014670: 0d0a 2020 2020 7065 7266 7374 7269 6e67  ..    perfstring
-00014680: 202b 3d20 6622 756e 6163 636f 756e 7465   += f"unaccounte
-00014690: 643a 207b 7065 7266 696e 666f 5b27 756e  d: {perfinfo['un
-000146a0: 6163 636f 756e 7465 6427 5d3a 2e32 667d  accounted']:.2f}
-000146b0: 220d 0a0d 0a20 2020 2023 2052 6574 7572  "....    # Retur
-000146c0: 6e0d 0a20 2020 2072 6574 7572 6e5f 696e  n..    return_in
-000146d0: 666f 5b22 7065 7266 696e 666f 225d 203d  fo["perfinfo"] =
-000146e0: 2070 6572 6669 6e66 6f0d 0a20 2020 2072   perfinfo..    r
-000146f0: 6574 7572 6e5f 696e 666f 5b22 7065 7266  eturn_info["perf
-00014700: 7374 7269 6e67 225d 203d 2070 6572 6673  string"] = perfs
-00014710: 7472 696e 670d 0a20 2020 2072 6574 7572  tring..    retur
-00014720: 6e5f 696e 666f 5b22 6d65 7373 6167 6522  n_info["message"
-00014730: 5d20 3d20 6d65 7373 6167 650d 0a20 2020  ] = message..   
-00014740: 2072 6574 7572 6e20 7265 7475 726e 5f69   return return_i
-00014750: 6e66 6f0d 0a0d 0a0d 0a64 6566 205f 6469  nfo......def _di
-00014760: 7373 6f6c 7665 280d 0a20 2020 2064 663a  ssolve(..    df:
-00014770: 2067 7064 2e47 656f 4461 7461 4672 616d   gpd.GeoDataFram
-00014780: 652c 0d0a 2020 2020 6279 3d4e 6f6e 652c  e,..    by=None,
-00014790: 0d0a 2020 2020 6167 6766 756e 633a 204f  ..    aggfunc: O
-000147a0: 7074 696f 6e61 6c5b 556e 696f 6e5b 7374  ptional[Union[st
-000147b0: 722c 2064 6963 745d 5d20 3d20 2266 6972  r, dict]] = "fir
-000147c0: 7374 222c 0d0a 2020 2020 6173 5f69 6e64  st",..    as_ind
-000147d0: 6578 3d54 7275 652c 0d0a 2020 2020 6c65  ex=True,..    le
-000147e0: 7665 6c3d 4e6f 6e65 2c0d 0a20 2020 2073  vel=None,..    s
-000147f0: 6f72 743d 5472 7565 2c0d 0a20 2020 206f  ort=True,..    o
-00014800: 6273 6572 7665 643d 4661 6c73 652c 0d0a  bserved=False,..
-00014810: 2020 2020 6472 6f70 6e61 3d54 7275 652c      dropna=True,
-00014820: 0d0a 2920 2d3e 2067 7064 2e47 656f 4461  ..) -> gpd.GeoDa
-00014830: 7461 4672 616d 653a 0d0a 2020 2020 2222  taFrame:..    ""
-00014840: 220d 0a20 2020 2044 6973 736f 6c76 6520  "..    Dissolve 
-00014850: 6765 6f6d 6574 7269 6573 2077 6974 6869  geometries withi
-00014860: 6e20 6067 726f 7570 6279 6020 696e 746f  n `groupby` into
-00014870: 2073 696e 676c 6520 6f62 7365 7276 6174   single observat
-00014880: 696f 6e2e 0d0a 0d0a 2020 2020 5468 6973  ion.....    This
-00014890: 2069 7320 6163 636f 6d70 6c69 7368 6564   is accomplished
-000148a0: 2062 7920 6170 706c 7969 6e67 2074 6865   by applying the
-000148b0: 2060 756e 6172 795f 756e 696f 6e60 206d   `unary_union` m
-000148c0: 6574 686f 640d 0a20 2020 2074 6f20 616c  ethod..    to al
-000148d0: 6c20 6765 6f6d 6574 7269 6573 2077 6974  l geometries wit
-000148e0: 6869 6e20 6120 6772 6f75 7073 656c 662e  hin a groupself.
-000148f0: 0d0a 2020 2020 4f62 7365 7276 6174 696f  ..    Observatio
-00014900: 6e73 2061 7373 6f63 6961 7465 6420 7769  ns associated wi
-00014910: 7468 2065 6163 6820 6067 726f 7570 6279  th each `groupby
-00014920: 6020 6772 6f75 7020 7769 6c6c 2062 6520  ` group will be 
-00014930: 6167 6772 6567 6174 6564 0d0a 2020 2020  aggregated..    
-00014940: 7573 696e 6720 7468 6520 6061 6767 6675  using the `aggfu
-00014950: 6e63 602e 0d0a 2020 2020 5061 7261 6d65  nc`...    Parame
-00014960: 7465 7273 0d0a 2020 2020 2d2d 2d2d 2d2d  ters..    ------
-00014970: 2d2d 2d2d 0d0a 2020 2020 6279 203a 2073  ----..    by : s
-00014980: 7472 696e 672c 2064 6566 6175 6c74 204e  tring, default N
-00014990: 6f6e 650d 0a20 2020 2020 2020 2043 6f6c  one..        Col
-000149a0: 756d 6e20 7768 6f73 6520 7661 6c75 6573  umn whose values
-000149b0: 2064 6566 696e 6520 6772 6f75 7073 2074   define groups t
-000149c0: 6f20 6265 2064 6973 736f 6c76 6564 2e20  o be dissolved. 
-000149d0: 4966 204e 6f6e 652c 0d0a 2020 2020 2020  If None,..      
-000149e0: 2020 7768 6f6c 6520 4765 6f44 6174 6146    whole GeoDataF
-000149f0: 7261 6d65 2069 7320 636f 6e73 6964 6572  rame is consider
-00014a00: 6564 2061 2073 696e 676c 6520 6772 6f75  ed a single grou
-00014a10: 702e 0d0a 2020 2020 6167 6766 756e 6320  p...    aggfunc 
-00014a20: 3a20 6675 6e63 7469 6f6e 2c20 7374 7269  : function, stri
-00014a30: 6e67 206f 7220 6469 6374 2c20 6465 6661  ng or dict, defa
-00014a40: 756c 7420 2266 6972 7374 220d 0a20 2020  ult "first"..   
-00014a50: 2020 2020 2041 6767 7265 6761 7469 6f6e       Aggregation
-00014a60: 2066 756e 6374 696f 6e20 666f 7220 6d61   function for ma
-00014a70: 6e69 7075 6c61 7469 6f6e 206f 6620 6461  nipulation of da
-00014a80: 7461 2061 7373 6f63 6961 7465 640d 0a20  ta associated.. 
-00014a90: 2020 2020 2020 2077 6974 6820 6561 6368         with each
-00014aa0: 2067 726f 7570 2e20 5061 7373 6564 2074   group. Passed t
-00014ab0: 6f20 7061 6e64 6173 2060 6772 6f75 7062  o pandas `groupb
-00014ac0: 792e 6167 6760 206d 6574 686f 642e 0d0a  y.agg` method...
-00014ad0: 2020 2020 6173 5f69 6e64 6578 203a 2062      as_index : b
-00014ae0: 6f6f 6c65 616e 2c20 6465 6661 756c 7420  oolean, default 
-00014af0: 5472 7565 0d0a 2020 2020 2020 2020 4966  True..        If
-00014b00: 2074 7275 652c 2067 726f 7570 6279 2063   true, groupby c
-00014b10: 6f6c 756d 6e73 2062 6563 6f6d 6520 696e  olumns become in
-00014b20: 6465 7820 6f66 2072 6573 756c 742e 0d0a  dex of result...
-00014b30: 2020 2020 6c65 7665 6c20 3a20 696e 7420      level : int 
-00014b40: 6f72 2073 7472 206f 7220 7365 7175 656e  or str or sequen
-00014b50: 6365 206f 6620 696e 7420 6f72 2073 6571  ce of int or seq
-00014b60: 7565 6e63 6520 6f66 2073 7472 2c20 6465  uence of str, de
-00014b70: 6661 756c 7420 4e6f 6e65 0d0a 2020 2020  fault None..    
-00014b80: 2020 2020 4966 2074 6865 2061 7869 7320      If the axis 
-00014b90: 6973 2061 204d 756c 7469 496e 6465 7820  is a MultiIndex 
-00014ba0: 2868 6965 7261 7263 6869 6361 6c29 2c20  (hierarchical), 
-00014bb0: 6772 6f75 7020 6279 2061 0d0a 2020 2020  group by a..    
-00014bc0: 2020 2020 7061 7274 6963 756c 6172 206c      particular l
-00014bd0: 6576 656c 206f 7220 6c65 7665 6c73 2e0d  evel or levels..
-00014be0: 0a20 2020 2020 2020 202e 2e20 7665 7273  .        .. vers
-00014bf0: 696f 6e61 6464 6564 3a3a 2030 2e39 2e30  ionadded:: 0.9.0
-00014c00: 0d0a 2020 2020 736f 7274 203a 2062 6f6f  ..    sort : boo
-00014c10: 6c2c 2064 6566 6175 6c74 2054 7275 650d  l, default True.
-00014c20: 0a20 2020 2020 2020 2053 6f72 7420 6772  .        Sort gr
-00014c30: 6f75 7020 6b65 7973 2e20 4765 7420 6265  oup keys. Get be
-00014c40: 7474 6572 2070 6572 666f 726d 616e 6365  tter performance
-00014c50: 2062 7920 7475 726e 696e 6720 7468 6973   by turning this
-00014c60: 206f 6666 2e0d 0a20 2020 2020 2020 204e   off...        N
-00014c70: 6f74 6520 7468 6973 2064 6f65 7320 6e6f  ote this does no
-00014c80: 7420 696e 666c 7565 6e63 6520 7468 6520  t influence the 
-00014c90: 6f72 6465 7220 6f66 206f 6273 6572 7661  order of observa
-00014ca0: 7469 6f6e 7320 7769 7468 696e 0d0a 2020  tions within..  
-00014cb0: 2020 2020 2020 6561 6368 2067 726f 7570        each group
-00014cc0: 2e20 4772 6f75 7062 7920 7072 6573 6572  . Groupby preser
-00014cd0: 7665 7320 7468 6520 6f72 6465 7220 6f66  ves the order of
-00014ce0: 2072 6f77 7320 7769 7468 696e 2065 6163   rows within eac
-00014cf0: 6820 6772 6f75 702e 0d0a 2020 2020 2020  h group...      
-00014d00: 2020 2e2e 2076 6572 7369 6f6e 6164 6465    .. versionadde
-00014d10: 643a 3a20 302e 392e 300d 0a20 2020 206f  d:: 0.9.0..    o
-00014d20: 6273 6572 7665 6420 3a20 626f 6f6c 2c20  bserved : bool, 
-00014d30: 6465 6661 756c 7420 4661 6c73 650d 0a20  default False.. 
-00014d40: 2020 2020 2020 2054 6869 7320 6f6e 6c79         This only
-00014d50: 2061 7070 6c69 6573 2069 6620 616e 7920   applies if any 
-00014d60: 6f66 2074 6865 2067 726f 7570 6572 7320  of the groupers 
-00014d70: 6172 6520 4361 7465 676f 7269 6361 6c73  are Categoricals
-00014d80: 2e0d 0a20 2020 2020 2020 2049 6620 5472  ...        If Tr
-00014d90: 7565 3a20 6f6e 6c79 2073 686f 7720 6f62  ue: only show ob
-00014da0: 7365 7276 6564 2076 616c 7565 7320 666f  served values fo
-00014db0: 7220 6361 7465 676f 7269 6361 6c20 6772  r categorical gr
-00014dc0: 6f75 7065 7273 2e0d 0a20 2020 2020 2020  oupers...       
-00014dd0: 2049 6620 4661 6c73 653a 2073 686f 7720   If False: show 
-00014de0: 616c 6c20 7661 6c75 6573 2066 6f72 2063  all values for c
-00014df0: 6174 6567 6f72 6963 616c 2067 726f 7570  ategorical group
-00014e00: 6572 732e 0d0a 2020 2020 2020 2020 2e2e  ers...        ..
-00014e10: 2076 6572 7369 6f6e 6164 6465 643a 3a20   versionadded:: 
-00014e20: 302e 392e 300d 0a20 2020 2064 726f 706e  0.9.0..    dropn
-00014e30: 6120 3a20 626f 6f6c 2c20 6465 6661 756c  a : bool, defaul
-00014e40: 7420 5472 7565 0d0a 2020 2020 2020 2020  t True..        
-00014e50: 4966 2054 7275 652c 2061 6e64 2069 6620  If True, and if 
-00014e60: 6772 6f75 7020 6b65 7973 2063 6f6e 7461  group keys conta
-00014e70: 696e 204e 4120 7661 6c75 6573 2c20 4e41  in NA values, NA
-00014e80: 2076 616c 7565 730d 0a20 2020 2020 2020   values..       
-00014e90: 2074 6f67 6574 6865 7220 7769 7468 2072   together with r
-00014ea0: 6f77 2f63 6f6c 756d 6e20 7769 6c6c 2062  ow/column will b
-00014eb0: 6520 6472 6f70 7065 642e 2049 6620 4661  e dropped. If Fa
-00014ec0: 6c73 652c 204e 410d 0a20 2020 2020 2020  lse, NA..       
-00014ed0: 2076 616c 7565 7320 7769 6c6c 2061 6c73   values will als
-00014ee0: 6f20 6265 2074 7265 6174 6564 2061 7320  o be treated as 
-00014ef0: 7468 6520 6b65 7920 696e 2067 726f 7570  the key in group
-00014f00: 732e 0d0a 2020 2020 2020 2020 5468 6973  s...        This
-00014f10: 2070 6172 616d 6574 6572 2069 7320 6e6f   parameter is no
-00014f20: 7420 7375 7070 6f72 7465 6420 666f 7220  t supported for 
-00014f30: 7061 6e64 6173 203c 2031 2e31 2e30 2e0d  pandas < 1.1.0..
-00014f40: 0a20 2020 2020 2020 2041 2077 6172 6e69  .        A warni
-00014f50: 6e67 2077 696c 6c20 6265 2065 6d69 7474  ng will be emitt
-00014f60: 6564 2066 6f72 2065 6172 6c69 6572 2070  ed for earlier p
-00014f70: 616e 6461 7320 7665 7273 696f 6e73 0d0a  andas versions..
-00014f80: 2020 2020 2020 2020 6966 2061 206e 6f6e          if a non
-00014f90: 2d64 6566 6175 6c74 2076 616c 7565 2069  -default value i
-00014fa0: 7320 6769 7665 6e20 666f 7220 7468 6973  s given for this
-00014fb0: 2070 6172 616d 6574 6572 2e0d 0a20 2020   parameter...   
-00014fc0: 2020 2020 202e 2e20 7665 7273 696f 6e61       .. versiona
-00014fd0: 6464 6564 3a3a 2030 2e39 2e30 0d0a 0d0a  dded:: 0.9.0....
-00014fe0: 2020 2020 5265 7475 726e 733a 0d0a 2020      Returns:..  
-00014ff0: 2020 2d2d 2d2d 2d2d 2d0d 0a20 2020 2047    -------..    G
-00015000: 656f 4461 7461 4672 616d 650d 0a0d 0a20  eoDataFrame.... 
-00015010: 2020 2045 7861 6d70 6c65 733a 0d0a 2020     Examples:..  
-00015020: 2020 2d2d 2d2d 2d2d 2d2d 0d0a 2020 2020    --------..    
-00015030: 3e3e 3e20 6672 6f6d 2073 6861 7065 6c79  >>> from shapely
-00015040: 2e67 656f 6d65 7472 7920 696d 706f 7274  .geometry import
-00015050: 2050 6f69 6e74 0d0a 2020 2020 3e3e 3e20   Point..    >>> 
-00015060: 6420 3d20 7b0d 0a20 2020 202e 2e2e 2020  d = {..    ...  
-00015070: 2020 2022 636f 6c31 223a 205b 226e 616d     "col1": ["nam
-00015080: 6531 222c 2022 6e61 6d65 3222 2c20 226e  e1", "name2", "n
-00015090: 616d 6531 225d 2c0d 0a20 2020 202e 2e2e  ame1"],..    ...
-000150a0: 2020 2020 2022 6765 6f6d 6574 7279 223a       "geometry":
-000150b0: 205b 506f 696e 7428 312c 2032 292c 2050   [Point(1, 2), P
-000150c0: 6f69 6e74 2832 2c20 3129 2c20 506f 696e  oint(2, 1), Poin
-000150d0: 7428 302c 2031 295d 2c0d 0a20 2020 202e  t(0, 1)],..    .
-000150e0: 2e2e 207d 0d0a 2020 2020 3e3e 3e20 6764  .. }..    >>> gd
-000150f0: 6620 3d20 6765 6f70 616e 6461 732e 4765  f = geopandas.Ge
-00015100: 6f44 6174 6146 7261 6d65 2864 2c20 6372  oDataFrame(d, cr
-00015110: 733d 3433 3236 290d 0a20 2020 203e 3e3e  s=4326)..    >>>
-00015120: 2067 6466 0d0a 2020 2020 2020 2020 636f   gdf..        co
-00015130: 6c31 2020 2020 2020 2020 2020 2020 2020  l1              
-00015140: 2020 2067 656f 6d65 7472 790d 0a20 2020     geometry..   
-00015150: 2030 2020 6e61 6d65 3120 2050 4f49 4e54   0  name1  POINT
-00015160: 2028 312e 3030 3030 3020 322e 3030 3030   (1.00000 2.0000
-00015170: 3029 0d0a 2020 2020 3120 206e 616d 6532  0)..    1  name2
-00015180: 2020 504f 494e 5420 2832 2e30 3030 3030    POINT (2.00000
-00015190: 2031 2e30 3030 3030 290d 0a20 2020 2032   1.00000)..    2
-000151a0: 2020 6e61 6d65 3120 2050 4f49 4e54 2028    name1  POINT (
-000151b0: 302e 3030 3030 3020 312e 3030 3030 3029  0.00000 1.00000)
-000151c0: 0d0a 2020 2020 3e3e 3e20 6469 7373 6f6c  ..    >>> dissol
-000151d0: 7665 6420 3d20 6764 662e 6469 7373 6f6c  ved = gdf.dissol
-000151e0: 7665 2827 636f 6c31 2729 0d0a 2020 2020  ve('col1')..    
-000151f0: 3e3e 3e20 6469 7373 6f6c 7665 6420 2023  >>> dissolved  #
-00015200: 2064 6f63 7465 7374 3a20 2b53 4b49 500d   doctest: +SKIP.
-00015210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015240: 2067 656f 6d65 7472 790d 0a20 2020 2063   geometry..    c
-00015250: 6f6c 310d 0a20 2020 206e 616d 6531 2020  ol1..    name1  
-00015260: 4d55 4c54 4950 4f49 4e54 2028 302e 3030  MULTIPOINT (0.00
-00015270: 3030 3020 312e 3030 3030 302c 2031 2e30  000 1.00000, 1.0
-00015280: 3030 3030 2032 2e30 3030 3030 290d 0a20  0000 2.00000).. 
-00015290: 2020 206e 616d 6532 2020 2020 2020 2020     name2        
-000152a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000152b0: 504f 494e 5420 2832 2e30 3030 3030 2031  POINT (2.00000 1
-000152c0: 2e30 3030 3030 290d 0a0d 0a20 2020 2053  .00000)....    S
-000152d0: 6565 2041 6c73 6f3a 0d0a 2020 2020 2d2d  ee Also:..    --
-000152e0: 2d2d 2d2d 2d2d 0d0a 2020 2020 4765 6f44  ------..    GeoD
-000152f0: 6174 6146 7261 6d65 2e65 7870 6c6f 6465  ataFrame.explode
-00015300: 203a 2065 7870 6c6f 6465 206d 756c 7469   : explode multi
-00015310: 2d70 6172 7420 6765 6f6d 6574 7269 6573  -part geometries
-00015320: 2069 6e74 6f20 7369 6e67 6c65 2067 656f   into single geo
-00015330: 6d65 7472 6965 730d 0a20 2020 2022 2222  metries..    """
-00015340: 0d0a 2020 2020 6966 2062 7920 6973 204e  ..    if by is N
-00015350: 6f6e 6520 616e 6420 6c65 7665 6c20 6973  one and level is
-00015360: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-00015370: 6279 5f6c 6f63 616c 203d 206e 702e 7a65  by_local = np.ze
-00015380: 726f 7328 6c65 6e28 6466 292c 2064 7479  ros(len(df), dty
-00015390: 7065 3d22 696e 7436 3422 290d 0a20 2020  pe="int64")..   
-000153a0: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-000153b0: 6279 5f6c 6f63 616c 203d 2062 790d 0a0d  by_local = by...
-000153c0: 0a20 2020 2067 726f 7570 6279 5f6b 7761  .    groupby_kwa
-000153d0: 7267 7320 3d20 7b0d 0a20 2020 2020 2020  rgs = {..       
-000153e0: 2022 6279 223a 2062 795f 6c6f 6361 6c2c   "by": by_local,
-000153f0: 0d0a 2020 2020 2020 2020 226c 6576 656c  ..        "level
-00015400: 223a 206c 6576 656c 2c0d 0a20 2020 2020  ": level,..     
-00015410: 2020 2022 736f 7274 223a 2073 6f72 742c     "sort": sort,
-00015420: 0d0a 2020 2020 2020 2020 226f 6273 6572  ..        "obser
-00015430: 7665 6422 3a20 6f62 7365 7276 6564 2c0d  ved": observed,.
-00015440: 0a20 2020 2020 2020 2022 6472 6f70 6e61  .        "dropna
-00015450: 223a 2064 726f 706e 612c 0d0a 2020 2020  ": dropna,..    
-00015460: 7d0d 0a20 2020 2022 2222 0d0a 2020 2020  }..    """..    
-00015470: 6966 206e 6f74 2063 6f6d 7061 742e 5041  if not compat.PA
-00015480: 4e44 4153 5f47 455f 3131 3a0d 0a20 2020  NDAS_GE_11:..   
-00015490: 2020 2020 2067 726f 7570 6279 5f6b 7761       groupby_kwa
-000154a0: 7267 732e 706f 7028 2264 726f 706e 6122  rgs.pop("dropna"
-000154b0: 290d 0a0d 0a20 2020 2020 2020 2069 6620  )....        if 
-000154c0: 6e6f 7420 6472 6f70 6e61 3a20 2023 2049  not dropna:  # I
-000154d0: 6620 7468 6579 2070 6173 7365 6420 6120  f they passed a 
-000154e0: 6e6f 6e2d 6465 6661 756c 7420 6472 6f70  non-default drop
-000154f0: 6e61 2076 616c 7565 0d0a 2020 2020 2020  na value..      
-00015500: 2020 2020 2020 7761 726e 696e 6773 2e77        warnings.w
-00015510: 6172 6e28 2264 726f 706e 6120 6b77 6172  arn("dropna kwar
-00015520: 6720 6973 206e 6f74 2073 7570 706f 7274  g is not support
-00015530: 6564 2066 6f72 2070 616e 6461 7320 3c20  ed for pandas < 
-00015540: 312e 312e 3022 290d 0a20 2020 2022 2222  1.1.0")..    """
-00015550: 0d0a 0d0a 2020 2020 2320 5072 6f63 6573  ....    # Proces
-00015560: 7320 6e6f 6e2d 7370 6174 6961 6c20 636f  s non-spatial co
-00015570: 6d70 6f6e 656e 740d 0a20 2020 2064 6174  mponent..    dat
-00015580: 6120 3d20 7064 2e44 6174 6146 7261 6d65  a = pd.DataFrame
-00015590: 2864 662e 6472 6f70 2863 6f6c 756d 6e73  (df.drop(columns
-000155a0: 3d64 662e 6765 6f6d 6574 7279 2e6e 616d  =df.geometry.nam
-000155b0: 6529 290d 0a0d 0a20 2020 2069 6620 6167  e))....    if ag
-000155c0: 6766 756e 6320 6973 206e 6f74 204e 6f6e  gfunc is not Non
-000155d0: 6520 616e 6420 6973 696e 7374 616e 6365  e and isinstance
-000155e0: 2861 6767 6675 6e63 2c20 6469 6374 2920  (aggfunc, dict) 
-000155f0: 616e 6420 2274 6f5f 6a73 6f6e 2220 696e  and "to_json" in
-00015600: 2061 6767 6675 6e63 3a0d 0a20 2020 2020   aggfunc:..     
-00015610: 2020 2061 6767 5f63 6f6c 756d 6e73 203d     agg_columns =
-00015620: 206c 6973 7428 7365 7428 6167 6766 756e   list(set(aggfun
-00015630: 635b 2274 6f5f 6a73 6f6e 225d 2929 0d0a  c["to_json"]))..
-00015640: 2020 2020 2020 2020 6167 675f 6461 7461          agg_data
-00015650: 203d 2028 0d0a 2020 2020 2020 2020 2020   = (..          
-00015660: 2020 6461 7461 2e67 726f 7570 6279 282a    data.groupby(*
-00015670: 2a67 726f 7570 6279 5f6b 7761 7267 7329  *groupby_kwargs)
-00015680: 0d0a 2020 2020 2020 2020 2020 2020 2e61  ..            .a
-00015690: 7070 6c79 280d 0a20 2020 2020 2020 2020  pply(..         
-000156a0: 2020 2020 2020 206c 616d 6264 6120 673a         lambda g:
-000156b0: 2067 5b61 6767 5f63 6f6c 756d 6e73 5d2e   g[agg_columns].
-000156c0: 746f 5f6a 736f 6e28 6f72 6965 6e74 3d22  to_json(orient="
-000156d0: 7265 636f 7264 7322 290d 0a20 2020 2020  records")..     
-000156e0: 2020 2020 2020 2029 2020 2320 7479 7065         )  # type
-000156f0: 3a20 6967 6e6f 7265 5b69 6e64 6578 5d0d  : ignore[index].
-00015700: 0a20 2020 2020 2020 2020 2020 202e 746f  .            .to
-00015710: 5f66 7261 6d65 286e 616d 653d 225f 5f44  _frame(name="__D
-00015720: 4953 534f 4c56 455f 544f 4a53 4f4e 2229  ISSOLVE_TOJSON")
-00015730: 0d0a 2020 2020 2020 2020 290d 0a20 2020  ..        )..   
-00015740: 2065 6c69 6620 6973 696e 7374 616e 6365   elif isinstance
-00015750: 2861 6767 6675 6e63 2c20 7374 7229 2061  (aggfunc, str) a
-00015760: 6e64 2061 6767 6675 6e63 203d 3d20 226d  nd aggfunc == "m
-00015770: 6572 6765 5f6a 736f 6e5f 6c69 7374 7322  erge_json_lists"
-00015780: 3a0d 0a20 2020 2020 2020 2023 204d 6572  :..        # Mer
-00015790: 6765 2061 6e64 2066 6c61 7474 656e 2074  ge and flatten t
-000157a0: 6865 206a 736f 6e20 6c69 7374 7320 696e  he json lists in
-000157b0: 2074 6865 2067 726f 7570 730d 0a20 2020   the groups..   
-000157c0: 2020 2020 2064 6566 2067 726f 7570 5f66       def group_f
-000157d0: 6c61 7474 656e 5f6a 736f 6e5f 6c69 7374  latten_json_list
-000157e0: 2867 293a 0d0a 2020 2020 2020 2020 2020  (g):..          
-000157f0: 2020 2320 4576 616c 7561 7465 2061 6c6c    # Evaluate all
-00015800: 2067 726f 7570 6564 2072 6f77 7320 746f   grouped rows to
-00015810: 206a 736f 6e20 6f62 6a65 6374 732e 2054   json objects. T
-00015820: 6869 7320 7265 7375 6c74 7320 696e 2061  his results in a
-00015830: 206c 6973 7420 6f66 0d0a 2020 2020 2020   list of..      
-00015840: 2020 2020 2020 2320 6c69 7374 7320 6f66        # lists of
-00015850: 206a 736f 6e20 6f62 6a65 6374 732e 0d0a   json objects...
-00015860: 2020 2020 2020 2020 2020 2020 6a73 6f6e              json
-00015870: 5f6e 6573 7465 645f 6c69 7374 7320 3d20  _nested_lists = 
-00015880: 5b0d 0a20 2020 2020 2020 2020 2020 2020  [..             
-00015890: 2020 206a 736f 6e2e 6c6f 6164 7328 6a73     json.loads(js
-000158a0: 6f6e 5f76 616c 7565 7329 2066 6f72 206a  on_values) for j
-000158b0: 736f 6e5f 7661 6c75 6573 2069 6e20 675b  son_values in g[
-000158c0: 225f 5f44 4953 534f 4c56 455f 544f 4a53  "__DISSOLVE_TOJS
-000158d0: 4f4e 225d 0d0a 2020 2020 2020 2020 2020  ON"]..          
-000158e0: 2020 5d0d 0a0d 0a20 2020 2020 2020 2020    ]....         
-000158f0: 2020 2023 2045 7874 7261 6374 2074 6865     # Extract the
-00015900: 2072 6f77 7320 6672 6f6d 2074 6865 206e   rows from the n
-00015910: 6573 7465 6420 6c69 7374 7320 2b20 7075  ested lists + pu
-00015920: 7420 696e 2061 2066 6c61 7420 6c69 7374  t in a flat list
-00015930: 2061 7320 7374 7269 6e67 730d 0a20 2020   as strings..   
-00015940: 2020 2020 2020 2020 206a 736f 6e73 7472           jsonstr
-00015950: 5f66 6c61 7420 3d20 5b0d 0a20 2020 2020  _flat = [..     
-00015960: 2020 2020 2020 2020 2020 206a 736f 6e2e             json.
-00015970: 6475 6d70 7328 6a73 6f6e 5f76 616c 7565  dumps(json_value
-00015980: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-00015990: 2020 2066 6f72 206a 736f 6e5f 7661 6c75     for json_valu
-000159a0: 6573 2069 6e20 6a73 6f6e 5f6e 6573 7465  es in json_neste
-000159b0: 645f 6c69 7374 730d 0a20 2020 2020 2020  d_lists..       
-000159c0: 2020 2020 2020 2020 2066 6f72 206a 736f           for jso
-000159d0: 6e5f 7661 6c75 6520 696e 206a 736f 6e5f  n_value in json_
-000159e0: 7661 6c75 6573 0d0a 2020 2020 2020 2020  values..        
-000159f0: 2020 2020 5d0d 0a0d 0a20 2020 2020 2020      ]....       
-00015a00: 2020 2020 2023 2052 656d 6f76 6520 6475       # Remove du
-00015a10: 706c 6963 6174 6573 0d0a 2020 2020 2020  plicates..      
-00015a20: 2020 2020 2020 6a73 6f6e 7373 7472 5f64        jsonsstr_d
-00015a30: 6973 7469 6e63 7420 3d20 7365 7428 6a73  istinct = set(js
-00015a40: 6f6e 7374 725f 666c 6174 290d 0a0d 0a20  onstr_flat).... 
-00015a50: 2020 2020 2020 2020 2020 2023 2043 6f6e             # Con
-00015a60: 7665 7274 2074 6865 2064 6174 6120 6167  vert the data ag
-00015a70: 6169 6e20 746f 2061 206c 6973 7420 6f66  ain to a list of
-00015a80: 206a 736f 6e20 6f62 6a65 6374 730d 0a20   json objects.. 
-00015a90: 2020 2020 2020 2020 2020 206a 736f 6e5f             json_
-00015aa0: 6469 7374 696e 6374 203d 205b 6a73 6f6e  distinct = [json
-00015ab0: 2e6c 6f61 6473 286a 736f 6e5f 7661 6c75  .loads(json_valu
-00015ac0: 6529 2066 6f72 206a 736f 6e5f 7661 6c75  e) for json_valu
-00015ad0: 6520 696e 206a 736f 6e73 7374 725f 6469  e in jsonsstr_di
-00015ae0: 7374 696e 6374 5d0d 0a0d 0a20 2020 2020  stinct]....     
-00015af0: 2020 2020 2020 2023 2052 6574 7572 6e20         # Return 
-00015b00: 6173 206a 736f 6e20 7374 7269 6e67 0d0a  as json string..
-00015b10: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00015b20: 726e 206a 736f 6e2e 6475 6d70 7328 6a73  rn json.dumps(js
-00015b30: 6f6e 5f64 6973 7469 6e63 7429 0d0a 0d0a  on_distinct)....
-00015b40: 2020 2020 2020 2020 6167 675f 6461 7461          agg_data
-00015b50: 203d 2028 0d0a 2020 2020 2020 2020 2020   = (..          
-00015b60: 2020 6461 7461 2e67 726f 7570 6279 282a    data.groupby(*
-00015b70: 2a67 726f 7570 6279 5f6b 7761 7267 7329  *groupby_kwargs)
-00015b80: 0d0a 2020 2020 2020 2020 2020 2020 2e61  ..            .a
-00015b90: 7070 6c79 286c 616d 6264 6120 673a 2067  pply(lambda g: g
-00015ba0: 726f 7570 5f66 6c61 7474 656e 5f6a 736f  roup_flatten_jso
-00015bb0: 6e5f 6c69 7374 2867 2929 0d0a 2020 2020  n_list(g))..    
-00015bc0: 2020 2020 2020 2020 2e74 6f5f 6672 616d          .to_fram
-00015bd0: 6528 6e61 6d65 3d22 5f5f 4449 5353 4f4c  e(name="__DISSOL
-00015be0: 5645 5f54 4f4a 534f 4e22 290d 0a20 2020  VE_TOJSON")..   
-00015bf0: 2020 2020 2029 0d0a 2020 2020 656c 7365       )..    else
-00015c00: 3a0d 0a20 2020 2020 2020 2061 6767 5f64  :..        agg_d
-00015c10: 6174 6120 3d20 6461 7461 2e67 726f 7570  ata = data.group
-00015c20: 6279 282a 2a67 726f 7570 6279 5f6b 7761  by(**groupby_kwa
-00015c30: 7267 7329 2e61 6767 2861 6767 6675 6e63  rgs).agg(aggfunc
-00015c40: 2920 2023 2074 7970 653a 2069 676e 6f72  )  # type: ignor
-00015c50: 655b 6172 672d 7479 7065 5d0d 0a20 2020  e[arg-type]..   
-00015c60: 2020 2020 2023 2043 6865 636b 2069 6620       # Check if 
-00015c70: 616c 6c20 636f 6c75 6d6e 7320 7765 7265  all columns were
-00015c80: 2070 726f 7065 726c 7920 6167 6772 6567   properly aggreg
-00015c90: 6174 6564 0d0a 2020 2020 2020 2020 6173  ated..        as
-00015ca0: 7365 7274 2062 795f 6c6f 6361 6c20 6973  sert by_local is
-00015cb0: 206e 6f74 204e 6f6e 650d 0a20 2020 2020   not None..     
-00015cc0: 2020 2063 6f6c 756d 6e73 5f74 6f5f 6167     columns_to_ag
-00015cd0: 6720 3d20 5b63 6f6c 756d 6e20 666f 7220  g = [column for 
-00015ce0: 636f 6c75 6d6e 2069 6e20 6461 7461 2e63  column in data.c
-00015cf0: 6f6c 756d 6e73 2069 6620 636f 6c75 6d6e  olumns if column
-00015d00: 206e 6f74 2069 6e20 6279 5f6c 6f63 616c   not in by_local
-00015d10: 5d0d 0a20 2020 2020 2020 2069 6620 6c65  ]..        if le
-00015d20: 6e28 636f 6c75 6d6e 735f 746f 5f61 6767  n(columns_to_agg
-00015d30: 2920 213d 206c 656e 2861 6767 5f64 6174  ) != len(agg_dat
-00015d40: 612e 636f 6c75 6d6e 7329 3a0d 0a20 2020  a.columns):..   
-00015d50: 2020 2020 2020 2020 2064 726f 7070 6564           dropped
-00015d60: 5f63 6f6c 756d 6e73 203d 205b 0d0a 2020  _columns = [..  
-00015d70: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00015d80: 6c75 6d6e 2066 6f72 2063 6f6c 756d 6e20  lumn for column 
-00015d90: 696e 2063 6f6c 756d 6e73 5f74 6f5f 6167  in columns_to_ag
-00015da0: 6720 6966 2063 6f6c 756d 6e20 6e6f 7420  g if column not 
-00015db0: 696e 2061 6767 5f64 6174 612e 636f 6c75  in agg_data.colu
-00015dc0: 6d6e 730d 0a20 2020 2020 2020 2020 2020  mns..           
-00015dd0: 205d 0d0a 2020 2020 2020 2020 2020 2020   ]..            
-00015de0: 7261 6973 6520 4578 6365 7074 696f 6e28  raise Exception(
-00015df0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00015e00: 2020 6622 436f 6c75 6d6e 2873 2920 7b64    f"Column(s) {d
-00015e10: 726f 7070 6564 5f63 6f6c 756d 6e73 7d20  ropped_columns} 
-00015e20: 6172 6520 6e6f 7420 7375 7070 6f72 7465  are not supporte
-00015e30: 6420 666f 7220 6167 6772 6567 6174 696f  d for aggregatio
-00015e40: 6e2c 2073 746f 7022 0d0a 2020 2020 2020  n, stop"..      
-00015e50: 2020 2020 2020 290d 0a0d 0a20 2020 2023        )....    #
-00015e60: 2050 726f 6365 7373 2073 7061 7469 616c   Process spatial
-00015e70: 2063 6f6d 706f 6e65 6e74 0d0a 2020 2020   component..    
-00015e80: 6465 6620 6d65 7267 655f 6765 6f6d 6574  def merge_geomet
-00015e90: 7269 6573 2862 6c6f 636b 293a 0d0a 2020  ries(block):..  
-00015ea0: 2020 2020 2020 6d65 7267 6564 5f67 656f        merged_geo
-00015eb0: 6d20 3d20 626c 6f63 6b2e 756e 6172 795f  m = block.unary_
-00015ec0: 756e 696f 6e0d 0a20 2020 2020 2020 2072  union..        r
-00015ed0: 6574 7572 6e20 6d65 7267 6564 5f67 656f  eturn merged_geo
-00015ee0: 6d0d 0a0d 0a20 2020 2067 203d 2064 662e  m....    g = df.
-00015ef0: 6772 6f75 7062 7928 6772 6f75 705f 6b65  groupby(group_ke
-00015f00: 7973 3d46 616c 7365 2c20 2a2a 6772 6f75  ys=False, **grou
-00015f10: 7062 795f 6b77 6172 6773 295b 6466 2e67  pby_kwargs)[df.g
-00015f20: 656f 6d65 7472 792e 6e61 6d65 5d2e 6167  eometry.name].ag
-00015f30: 6728 0d0a 2020 2020 2020 2020 6d65 7267  g(..        merg
-00015f40: 655f 6765 6f6d 6574 7269 6573 0d0a 2020  e_geometries..  
-00015f50: 2020 290d 0a0d 0a20 2020 2023 2041 6767    )....    # Agg
-00015f60: 7265 6761 7465 0d0a 2020 2020 6167 6772  regate..    aggr
-00015f70: 6567 6174 6564 5f67 656f 6d65 7472 7920  egated_geometry 
-00015f80: 3d20 6770 642e 4765 6f44 6174 6146 7261  = gpd.GeoDataFra
-00015f90: 6d65 280d 0a20 2020 2020 2020 2064 6174  me(..        dat
-00015fa0: 613d 672c 2067 656f 6d65 7472 793d 6466  a=g, geometry=df
-00015fb0: 2e67 656f 6d65 7472 792e 6e61 6d65 2c20  .geometry.name, 
-00015fc0: 6372 733d 6466 2e63 7273 0d0a 2020 2020  crs=df.crs..    
-00015fd0: 290d 0a20 2020 2023 2052 6563 6f6d 6269  )..    # Recombi
-00015fe0: 6e65 0d0a 2020 2020 6167 6772 6567 6174  ne..    aggregat
-00015ff0: 6564 203d 2061 6767 7265 6761 7465 645f  ed = aggregated_
-00016000: 6765 6f6d 6574 7279 2e6a 6f69 6e28 6167  geometry.join(ag
-00016010: 675f 6461 7461 290d 0a0d 0a20 2020 2023  g_data)....    #
-00016020: 2052 6573 6574 2069 6620 7265 7175 6573   Reset if reques
-00016030: 7465 640d 0a20 2020 2069 6620 6e6f 7420  ted..    if not 
-00016040: 6173 5f69 6e64 6578 3a0d 0a20 2020 2020  as_index:..     
-00016050: 2020 2061 6767 7265 6761 7465 6420 3d20     aggregated = 
-00016060: 6167 6772 6567 6174 6564 2e72 6573 6574  aggregated.reset
-00016070: 5f69 6e64 6578 2829 0d0a 0d0a 2020 2020  _index()....    
-00016080: 2320 4d61 6b65 2073 7572 6520 6f75 7470  # Make sure outp
-00016090: 7574 2074 7970 6573 206f 6620 6772 6f75  ut types of grou
-000160a0: 7065 6420 636f 6c75 6d6e 7320 6172 6520  ped columns are 
-000160b0: 7468 6520 7361 6d65 2061 7320 696e 7075  the same as inpu
-000160c0: 7420 7479 7065 732e 0d0a 2020 2020 2320  t types...    # 
-000160d0: 452e 672e 206f 626a 6563 7420 636f 6c75  E.g. object colu
-000160e0: 6d6e 7320 6265 636f 6d65 2066 6c6f 6174  mns become float
-000160f0: 2069 6620 616c 6c20 7661 6c75 6573 2061   if all values a
-00016100: 7265 204e 6f6e 652e 0d0a 2020 2020 6966  re None...    if
-00016110: 2062 7920 6973 206e 6f74 204e 6f6e 653a   by is not None:
-00016120: 0d0a 2020 2020 2020 2020 6966 2069 7369  ..        if isi
-00016130: 6e73 7461 6e63 6528 6279 2c20 7374 7229  nstance(by, str)
-00016140: 3a0d 0a20 2020 2020 2020 2020 2020 2069  :..            i
-00016150: 6620 6279 2069 6e20 6167 6772 6567 6174  f by in aggregat
-00016160: 6564 2e63 6f6c 756d 6e73 2061 6e64 2064  ed.columns and d
-00016170: 665b 6279 5d2e 6474 7970 6520 213d 2061  f[by].dtype != a
-00016180: 6767 7265 6761 7465 645b 6279 5d2e 6474  ggregated[by].dt
-00016190: 7970 653a 0d0a 2020 2020 2020 2020 2020  ype:..          
-000161a0: 2020 2020 2020 6167 6772 6567 6174 6564        aggregated
-000161b0: 5b62 795d 203d 2061 6767 7265 6761 7465  [by] = aggregate
-000161c0: 645b 6279 5d2e 6173 7479 7065 2864 665b  d[by].astype(df[
-000161d0: 6279 5d2e 6474 7970 6529 0d0a 2020 2020  by].dtype)..    
-000161e0: 2020 2020 656c 6966 2069 7369 6e73 7461      elif isinsta
-000161f0: 6e63 6528 6279 2c20 4974 6572 6162 6c65  nce(by, Iterable
-00016200: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-00016210: 666f 7220 636f 6c20 696e 2062 793a 0d0a  for col in by:..
-00016220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016230: 6966 2063 6f6c 2069 6e20 6167 6772 6567  if col in aggreg
-00016240: 6174 6564 2e63 6f6c 756d 6e73 2061 6e64  ated.columns and
-00016250: 2064 665b 636f 6c5d 2e64 7479 7065 2021   df[col].dtype !
-00016260: 3d20 6167 6772 6567 6174 6564 5b63 6f6c  = aggregated[col
-00016270: 5d2e 6474 7970 653a 0d0a 2020 2020 2020  ].dtype:..      
-00016280: 2020 2020 2020 2020 2020 2020 2020 6167                ag
-00016290: 6772 6567 6174 6564 5b63 6f6c 5d20 3d20  gregated[col] = 
-000162a0: 6167 6772 6567 6174 6564 5b63 6f6c 5d2e  aggregated[col].
-000162b0: 6173 7479 7065 2864 665b 636f 6c5d 2e64  astype(df[col].d
-000162c0: 7479 7065 290d 0a0d 0a20 2020 2061 7373  type)....    ass
-000162d0: 6572 7420 6973 696e 7374 616e 6365 2861  ert isinstance(a
-000162e0: 6767 7265 6761 7465 642c 2067 7064 2e47  ggregated, gpd.G
-000162f0: 656f 4461 7461 4672 616d 6529 0d0a 2020  eoDataFrame)..  
-00016300: 2020 7265 7475 726e 2061 6767 7265 6761    return aggrega
-00016310: 7465 640d 0a0d 0a0d 0a64 6566 205f 6164  ted......def _ad
-00016320: 645f 6f72 6465 7262 795f 636f 6c75 6d6e  d_orderby_column
-00016330: 2870 6174 683a 2050 6174 682c 206c 6179  (path: Path, lay
-00016340: 6572 3a20 7374 722c 206e 616d 653a 2073  er: str, name: s
-00016350: 7472 293a 0d0a 2020 2020 2320 5072 6570  tr):..    # Prep
-00016360: 6172 6520 7468 6520 6578 7072 6573 7369  are the expressi
-00016370: 6f6e 2074 6f20 6361 6c63 756c 6174 6520  on to calculate 
-00016380: 7468 6520 6f72 6465 7262 7920 636f 6c75  the orderby colu
-00016390: 6d6e 2e0d 0a20 2020 2023 2049 6e20 6120  mn...    # In a 
-000163a0: 7370 6174 6961 6c20 6669 6c65 2c20 6120  spatial file, a 
-000163b0: 7370 6174 6961 6c20 6f72 6465 7220 7769  spatial order wi
-000163c0: 6c6c 206d 616b 6520 6c61 7465 7220 7573  ll make later us
-000163d0: 6520 6d6f 7265 2065 6666 6963 69c3 ab6e  e more effici..n
-000163e0: 742c 0d0a 2020 2020 2320 736f 2075 7365  t,..    # so use
-000163f0: 2061 2067 656f 6861 7368 2e0d 0a20 2020   a geohash...   
-00016400: 206c 6179 6572 696e 666f 203d 2067 666f   layerinfo = gfo
-00016410: 2e67 6574 5f6c 6179 6572 696e 666f 2870  .get_layerinfo(p
-00016420: 6174 6829 0d0a 2020 2020 6966 206c 6179  ath)..    if lay
-00016430: 6572 696e 666f 2e63 7273 2069 7320 6e6f  erinfo.crs is no
-00016440: 7420 4e6f 6e65 2061 6e64 206c 6179 6572  t None and layer
-00016450: 696e 666f 2e63 7273 2e69 735f 6765 6f67  info.crs.is_geog
-00016460: 7261 7068 6963 3a0d 0a20 2020 2020 2020  raphic:..       
-00016470: 2023 2049 6620 7468 6520 636f 6f72 6469   # If the coordi
-00016480: 6e61 7465 7320 6172 6520 6765 6f67 7261  nates are geogra
-00016490: 7068 6963 2028 696e 206c 6174 2f6c 6f6e  phic (in lat/lon
-000164a0: 2064 6567 7265 6573 292c 206f 6b0d 0a20   degrees), ok.. 
-000164b0: 2020 2020 2020 2065 7870 7265 7373 696f         expressio
-000164c0: 6e20 3d20 6622 5354 5f47 656f 4861 7368  n = f"ST_GeoHash
-000164d0: 287b 6c61 7965 7269 6e66 6f2e 6765 6f6d  ({layerinfo.geom
-000164e0: 6574 7279 636f 6c75 6d6e 7d2c 2031 3029  etrycolumn}, 10)
-000164f0: 220d 0a20 2020 2065 6c73 653a 0d0a 2020  "..    else:..  
-00016500: 2020 2020 2020 2320 4966 2074 6865 7920        # If they 
-00016510: 6172 6520 6e6f 7420 6765 6f67 7261 7068  are not geograph
-00016520: 6963 2028 696e 206c 6174 2f6c 6f6e 2064  ic (in lat/lon d
-00016530: 6567 7265 6573 292c 2074 6865 7920 6e65  egrees), they ne
-00016540: 6564 2074 6f20 6265 0d0a 2020 2020 2020  ed to be..      
-00016550: 2020 2320 636f 6e76 6572 7465 6420 746f    # converted to
-00016560: 207e 2064 6567 7265 6573 2074 6f20 6265   ~ degrees to be
-00016570: 2061 626c 6520 746f 2063 616c 6375 6c61   able to calcula
-00016580: 7465 2061 2067 656f 6861 7368 2e0d 0a0d  te a geohash....
-00016590: 0a20 2020 2020 2020 2023 2050 726f 7065  .        # Prope
-000165a0: 726c 7920 6361 6c63 756c 6174 696e 6720  rly calculating 
-000165b0: 7468 6520 7472 616e 7366 6f72 6d61 7469  the transformati
-000165c0: 6f6e 2074 6f20 6567 2e20 5747 5320 6973  on to eg. WGS is
-000165d0: 2074 6572 7269 626c 7920 736c 6f77 2e2e   terribly slow..
-000165e0: 2e0d 0a20 2020 2020 2020 2023 2065 7870  ...        # exp
-000165f0: 7265 7373 696f 6e20 3d20 6622 2222 5354  ression = f"""ST
-00016600: 5f47 656f 4861 7368 2853 545f 5472 616e  _GeoHash(ST_Tran
-00016610: 7366 6f72 6d28 4d61 6b65 506f 696e 7428  sform(MakePoint(
-00016620: 0d0a 2020 2020 2020 2020 2320 2020 2020  ..        #     
-00016630: 2020 284d 6272 4d61 7858 2867 656f 6d29    (MbrMaxX(geom)
-00016640: 2b4d 6272 4d69 6e58 2867 656f 6d29 292f  +MbrMinX(geom))/
-00016650: 322c 0d0a 2020 2020 2020 2020 2320 2020  2,..        #   
-00016660: 2020 2020 284d 6272 4d69 6e59 2867 656f      (MbrMinY(geo
-00016670: 6d29 2b4d 6272 4d61 7859 2867 656f 6d29  m)+MbrMaxY(geom)
-00016680: 292f 322c 2053 545f 5352 4944 2867 656f  )/2, ST_SRID(geo
-00016690: 6d29 292c 2034 3332 3629 2c20 3130 2922  m)), 4326), 10)"
-000166a0: 2222 0d0a 2020 2020 2020 2020 2320 536f  ""..        # So
-000166b0: 2c20 646f 2073 6f6d 6574 6869 6e67 2065  , do something e
-000166c0: 6c73 6520 7468 6174 2773 2066 6173 7465  lse that's faste
-000166d0: 7220 616e 6420 7374 696c 6c20 6769 7665  r and still give
-000166e0: 7320 6120 676f 6f64 0d0a 2020 2020 2020  s a good..      
-000166f0: 2020 2320 6765 6f67 7261 7068 6963 2063    # geographic c
-00016700: 6c75 7374 6572 696e 672e 0d0a 2020 2020  lustering...    
-00016710: 2020 2020 746f 5f67 656f 6772 6170 6869      to_geographi
-00016720: 635f 6661 6374 6f72 5f61 7070 726f 7820  c_factor_approx 
-00016730: 3d20 3930 202f 206d 6178 286c 6179 6572  = 90 / max(layer
-00016740: 696e 666f 2e74 6f74 616c 5f62 6f75 6e64  info.total_bound
-00016750: 7329 0d0a 2020 2020 2020 2020 6578 7072  s)..        expr
-00016760: 6573 7369 6f6e 203d 2066 2222 2253 545f  ession = f"""ST_
-00016770: 4765 6f48 6173 6828 4d61 6b65 506f 696e  GeoHash(MakePoin
-00016780: 7428 0d0a 2020 2020 2020 2020 2020 2020  t(..            
-00016790: 2020 2020 2828 4d62 724d 6178 5828 7b6c      ((MbrMaxX({l
-000167a0: 6179 6572 696e 666f 2e67 656f 6d65 7472  ayerinfo.geometr
-000167b0: 7963 6f6c 756d 6e7d 290d 0a20 2020 2020  ycolumn})..     
-000167c0: 2020 2020 2020 2020 2020 2020 202b 4d62               +Mb
-000167d0: 724d 696e 5828 7b6c 6179 6572 696e 666f  rMinX({layerinfo
-000167e0: 2e67 656f 6d65 7472 7963 6f6c 756d 6e7d  .geometrycolumn}
-000167f0: 2929 2f32 0d0a 2020 2020 2020 2020 2020  ))/2..          
-00016800: 2020 2020 2020 292a 7b74 6f5f 6765 6f67        )*{to_geog
-00016810: 7261 7068 6963 5f66 6163 746f 725f 6170  raphic_factor_ap
-00016820: 7072 6f78 7d2c 0d0a 2020 2020 2020 2020  prox},..        
-00016830: 2020 2020 2020 2020 2828 4d62 724d 696e          ((MbrMin
-00016840: 5928 7b6c 6179 6572 696e 666f 2e67 656f  Y({layerinfo.geo
-00016850: 6d65 7472 7963 6f6c 756d 6e7d 290d 0a20  metrycolumn}).. 
-00016860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016870: 202b 4d62 724d 6178 5928 7b6c 6179 6572   +MbrMaxY({layer
-00016880: 696e 666f 2e67 656f 6d65 7472 7963 6f6c  info.geometrycol
-00016890: 756d 6e7d 2929 2f32 0d0a 2020 2020 2020  umn}))/2..      
-000168a0: 2020 2020 2020 2020 2020 292a 7b74 6f5f            )*{to_
-000168b0: 6765 6f67 7261 7068 6963 5f66 6163 746f  geographic_facto
-000168c0: 725f 6170 7072 6f78 7d2c 2034 3332 3629  r_approx}, 4326)
-000168d0: 2c20 3130 2922 2222 0d0a 0d0a 2020 2020  , 10)"""....    
-000168e0: 2320 4e6f 7720 7765 2063 616e 2061 6374  # Now we can act
-000168f0: 7561 6c6c 7920 6164 6420 7468 6520 636f  ually add the co
-00016900: 6c75 6d6e 2e0d 0a20 2020 2067 666f 2e61  lumn...    gfo.a
-00016910: 6464 5f63 6f6c 756d 6e28 7061 7468 3d70  dd_column(path=p
-00016920: 6174 682c 206e 616d 653d 6e61 6d65 2c20  ath, name=name, 
-00016930: 7479 7065 3d67 666f 2e44 6174 6154 7970  type=gfo.DataTyp
-00016940: 652e 5445 5854 2c20 6578 7072 6573 7369  e.TEXT, expressi
-00016950: 6f6e 3d65 7870 7265 7373 696f 6e29 0d0a  on=expression)..
-00016960: 2020 2020 7371 6c69 7465 5f73 746d 7420      sqlite_stmt 
-00016970: 3d20 6627 4352 4541 5445 2049 4e44 4558  = f'CREATE INDEX
-00016980: 207b 6e61 6d65 7d5f 6964 7820 4f4e 2022   {name}_idx ON "
-00016990: 7b6c 6179 6572 7d22 287b 6e61 6d65 7d29  {layer}"({name})
-000169a0: 270d 0a20 2020 2067 666f 2e65 7865 6375  '..    gfo.execu
-000169b0: 7465 5f73 716c 2870 6174 683d 7061 7468  te_sql(path=path
-000169c0: 2c20 7371 6c5f 7374 6d74 3d73 716c 6974  , sql_stmt=sqlit
-000169d0: 655f 7374 6d74 290d 0a                   e_stmt)..
+000113a0: 2020 2064 7374 3d6f 7574 7075 745f 6f6e     dst=output_on
+000113b0: 626f 7264 6572 5f70 6174 682c 0a20 2020  border_path,.   
+000113c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000113d0: 2020 2020 2020 2020 2063 7265 6174 655f           create_
+000113e0: 7370 6174 6961 6c5f 696e 6465 783d 4661  spatial_index=Fa
+000113f0: 6c73 652c 0a20 2020 2020 2020 2020 2020  lse,.           
+00011400: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+00011410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011420: 2020 2020 2020 2067 666f 2e72 656d 6f76         gfo.remov
+00011430: 6528 6f75 7470 7574 5f6f 6e62 6f72 6465  e(output_onborde
+00011440: 725f 746d 705f 7061 7274 6961 6c5f 7061  r_tmp_partial_pa
+00011450: 7468 290a 0a20 2020 2020 2020 2020 2020  th)..           
+00011460: 2065 7863 6570 7420 4578 6365 7074 696f   except Exceptio
+00011470: 6e20 6173 2065 783a 0a20 2020 2020 2020  n as ex:.       
+00011480: 2020 2020 2020 2020 2062 6174 6368 5f69           batch_i
+00011490: 6420 3d20 6675 7475 7265 5f74 6f5f 6261  d = future_to_ba
+000114a0: 7463 685f 6964 5b66 7574 7572 655d 0a20  tch_id[future]. 
+000114b0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+000114c0: 6573 7361 6765 203d 2066 2245 7272 6f72  essage = f"Error
+000114d0: 2065 7865 6375 7469 6e67 207b 6261 7463   executing {batc
+000114e0: 6865 735b 6261 7463 685f 6964 5d7d 3a20  hes[batch_id]}: 
+000114f0: 7b65 787d 220a 2020 2020 2020 2020 2020  {ex}".          
+00011500: 2020 2020 2020 6c6f 6767 6572 2e65 7863        logger.exc
+00011510: 6570 7469 6f6e 286d 6573 7361 6765 290a  eption(message).
+00011520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011530: 6361 6c63 756c 6174 655f 706f 6f6c 2e73  calculate_pool.s
+00011540: 6875 7464 6f77 6e28 290a 2020 2020 2020  hutdown().      
+00011550: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00011560: 4578 6365 7074 696f 6e28 6d65 7373 6167  Exception(messag
+00011570: 6529 2066 726f 6d20 6578 0a0a 2020 2020  e) from ex..    
+00011580: 2020 2020 2020 2020 2320 4c6f 6720 7468          # Log th
+00011590: 6520 7072 6f67 7265 7373 2061 6e64 2070  e progress and p
+000115a0: 7265 6469 6374 696f 6e20 7370 6565 640a  rediction speed.
+000115b0: 2020 2020 2020 2020 2020 2020 5f67 656e              _gen
+000115c0: 6572 616c 5f75 7469 6c2e 7265 706f 7274  eral_util.report
+000115d0: 5f70 726f 6772 6573 7328 0a20 2020 2020  _progress(.     
+000115e0: 2020 2020 2020 2020 2020 2073 7461 7274             start
+000115f0: 5f74 696d 652c 206e 625f 6261 7463 6865  _time, nb_batche
+00011600: 735f 646f 6e65 2c20 6e62 5f62 6174 6368  s_done, nb_batch
+00011610: 6573 2c20 2264 6973 736f 6c76 6522 0a20  es, "dissolve". 
+00011620: 2020 2020 2020 2020 2020 2029 0a0a 0a64             )...d
+00011630: 6566 205f 6469 7373 6f6c 7665 5f70 6f6c  ef _dissolve_pol
+00011640: 7967 6f6e 7328 0a20 2020 2069 6e70 7574  ygons(.    input
+00011650: 5f70 6174 683a 2050 6174 682c 0a20 2020  _path: Path,.   
+00011660: 206f 7574 7075 745f 6e6f 746f 6e62 6f72   output_notonbor
+00011670: 6465 725f 7061 7468 3a20 5061 7468 2c0a  der_path: Path,.
+00011680: 2020 2020 6f75 7470 7574 5f6f 6e62 6f72      output_onbor
+00011690: 6465 725f 7061 7468 3a20 5061 7468 2c0a  der_path: Path,.
+000116a0: 2020 2020 6578 706c 6f64 6563 6f6c 6c65      explodecolle
+000116b0: 6374 696f 6e73 3a20 626f 6f6c 2c0a 2020  ctions: bool,.  
+000116c0: 2020 6772 6f75 7062 795f 636f 6c75 6d6e    groupby_column
+000116d0: 733a 204f 7074 696f 6e61 6c5b 4974 6572  s: Optional[Iter
+000116e0: 6162 6c65 5b73 7472 5d5d 2c0a 2020 2020  able[str]],.    
+000116f0: 6167 675f 636f 6c75 6d6e 733a 204f 7074  agg_columns: Opt
+00011700: 696f 6e61 6c5b 6469 6374 5d2c 0a20 2020  ional[dict],.   
+00011710: 2069 6e70 7574 5f67 656f 6d65 7472 7974   input_geometryt
+00011720: 7970 653a 2047 656f 6d65 7472 7954 7970  ype: GeometryTyp
+00011730: 652c 0a20 2020 2069 6e70 7574 5f6c 6179  e,.    input_lay
+00011740: 6572 3a20 4f70 7469 6f6e 616c 5b73 7472  er: Optional[str
+00011750: 5d2c 0a20 2020 206f 7574 7075 745f 6c61  ],.    output_la
+00011760: 7965 723a 204f 7074 696f 6e61 6c5b 7374  yer: Optional[st
+00011770: 725d 2c0a 2020 2020 6262 6f78 3a20 5475  r],.    bbox: Tu
+00011780: 706c 655b 666c 6f61 742c 2066 6c6f 6174  ple[float, float
+00011790: 2c20 666c 6f61 742c 2066 6c6f 6174 5d2c  , float, float],
+000117a0: 0a20 2020 2074 696c 655f 6964 3a20 4f70  .    tile_id: Op
+000117b0: 7469 6f6e 616c 5b69 6e74 5d2c 0a20 2020  tional[int],.   
+000117c0: 2067 7269 6473 697a 653a 2066 6c6f 6174   gridsize: float
+000117d0: 2c0a 2020 2020 6b65 6570 5f65 6d70 7479  ,.    keep_empty
+000117e0: 5f67 656f 6d73 3a20 626f 6f6c 2c0a 2920  _geoms: bool,.) 
+000117f0: 2d3e 2064 6963 743a 0a20 2020 2023 2049  -> dict:.    # I
+00011800: 6e69 740a 2020 2020 7065 7266 696e 666f  nit.    perfinfo
+00011810: 3a20 4469 6374 5b73 7472 2c20 666c 6f61  : Dict[str, floa
+00011820: 745d 203d 207b 7d0a 2020 2020 7374 6172  t] = {}.    star
+00011830: 745f 7469 6d65 203d 2064 6174 6574 696d  t_time = datetim
+00011840: 652e 6e6f 7728 290a 2020 2020 7265 7475  e.now().    retu
+00011850: 726e 5f69 6e66 6f20 3d20 7b0a 2020 2020  rn_info = {.    
+00011860: 2020 2020 2269 6e70 7574 5f70 6174 6822      "input_path"
+00011870: 3a20 696e 7075 745f 7061 7468 2c0a 2020  : input_path,.  
+00011880: 2020 2020 2020 226f 7574 7075 745f 6e6f        "output_no
+00011890: 746f 6e62 6f72 6465 725f 7061 7468 223a  tonborder_path":
+000118a0: 206f 7574 7075 745f 6e6f 746f 6e62 6f72   output_notonbor
+000118b0: 6465 725f 7061 7468 2c0a 2020 2020 2020  der_path,.      
+000118c0: 2020 226f 7574 7075 745f 6f6e 626f 7264    "output_onbord
+000118d0: 6572 5f70 6174 6822 3a20 6f75 7470 7574  er_path": output
+000118e0: 5f6f 6e62 6f72 6465 725f 7061 7468 2c0a  _onborder_path,.
+000118f0: 2020 2020 2020 2020 2262 626f 7822 3a20          "bbox": 
+00011900: 6262 6f78 2c0a 2020 2020 2020 2020 2274  bbox,.        "t
+00011910: 696c 655f 6964 223a 2074 696c 655f 6964  ile_id": tile_id
+00011920: 2c0a 2020 2020 2020 2020 2267 7269 6473  ,.        "grids
+00011930: 697a 6522 3a20 6772 6964 7369 7a65 2c0a  ize": gridsize,.
+00011940: 2020 2020 2020 2020 226e 625f 726f 7773          "nb_rows
+00011950: 5f64 6f6e 6522 3a20 302c 0a20 2020 2020  _done": 0,.     
+00011960: 2020 2022 746f 7461 6c5f 7469 6d65 223a     "total_time":
+00011970: 2030 2c0a 2020 2020 2020 2020 2270 6572   0,.        "per
+00011980: 6669 6e66 6f22 3a20 2222 2c0a 2020 2020  finfo": "",.    
+00011990: 7d0a 0a20 2020 2023 2052 6561 6420 616c  }..    # Read al
+000119a0: 6c20 7265 636f 7264 7320 7468 6174 2061  l records that a
+000119b0: 7265 2069 6e20 7468 6520 6262 6f78 0a20  re in the bbox. 
+000119c0: 2020 2072 6574 7279 5f63 6f75 6e74 203d     retry_count =
+000119d0: 2030 0a20 2020 2073 7461 7274 5f72 6561   0.    start_rea
+000119e0: 6420 3d20 6461 7465 7469 6d65 2e6e 6f77  d = datetime.now
+000119f0: 2829 0a20 2020 2061 6767 5f63 6f6c 756d  ().    agg_colum
+00011a00: 6e73 5f6e 6565 6465 6420 3d20 4e6f 6e65  ns_needed = None
+00011a10: 0a20 2020 2077 6869 6c65 2054 7275 653a  .    while True:
+00011a20: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
+00011a30: 2020 2020 2020 2020 2020 636f 6c75 6d6e            column
+00011a40: 735f 746f 5f72 6561 643a 2053 6574 5b73  s_to_read: Set[s
+00011a50: 7472 5d20 3d20 7365 7428 290a 2020 2020  tr] = set().    
+00011a60: 2020 2020 2020 2020 696e 666f 203d 2067          info = g
+00011a70: 666f 2e67 6574 5f6c 6179 6572 696e 666f  fo.get_layerinfo
+00011a80: 2869 6e70 7574 5f70 6174 682c 2069 6e70  (input_path, inp
+00011a90: 7574 5f6c 6179 6572 290a 2020 2020 2020  ut_layer).      
+00011aa0: 2020 2020 2020 6966 2067 726f 7570 6279        if groupby
+00011ab0: 5f63 6f6c 756d 6e73 2069 7320 6e6f 7420  _columns is not 
+00011ac0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00011ad0: 2020 2020 2020 636f 6c75 6d6e 735f 746f        columns_to
+00011ae0: 5f72 6561 642e 7570 6461 7465 2867 726f  _read.update(gro
+00011af0: 7570 6279 5f63 6f6c 756d 6e73 290a 2020  upby_columns).  
+00011b00: 2020 2020 2020 2020 2020 6669 645f 6173            fid_as
+00011b10: 5f69 6e64 6578 203d 2046 616c 7365 0a20  _index = False. 
+00011b20: 2020 2020 2020 2020 2020 2069 6620 6167             if ag
+00011b30: 675f 636f 6c75 6d6e 7320 6973 206e 6f74  g_columns is not
+00011b40: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00011b50: 2020 2020 2020 2066 6964 5f61 735f 696e         fid_as_in
+00011b60: 6465 7820 3d20 5472 7565 0a20 2020 2020  dex = True.     
+00011b70: 2020 2020 2020 2020 2020 2069 6620 225f             if "_
+00011b80: 5f44 4953 534f 4c56 455f 544f 4a53 4f4e  _DISSOLVE_TOJSON
+00011b90: 2220 696e 2069 6e66 6f2e 636f 6c75 6d6e  " in info.column
+00011ba0: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+00011bb0: 2020 2020 2020 2023 2049 6620 7765 2061         # If we a
+00011bc0: 7265 206e 6f74 2069 6e20 7468 6520 6669  re not in the fi
+00011bd0: 7273 7420 7061 7373 2c20 7468 6520 636f  rst pass, the co
+00011be0: 6c75 6d6e 7320 746f 2062 6520 7265 6164  lumns to be read
+00011bf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011c00: 2020 2020 2023 2061 7265 2061 6c72 6561       # are alrea
+00011c10: 6479 2069 6e20 7468 6520 6a73 6f6e 2063  dy in the json c
+00011c20: 6f6c 756d 6e0a 2020 2020 2020 2020 2020  olumn.          
+00011c30: 2020 2020 2020 2020 2020 636f 6c75 6d6e            column
+00011c40: 735f 746f 5f72 6561 642e 6164 6428 225f  s_to_read.add("_
+00011c50: 5f44 4953 534f 4c56 455f 544f 4a53 4f4e  _DISSOLVE_TOJSON
+00011c60: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
+00011c70: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00011c80: 2020 2020 2020 2020 2020 2020 2023 2054               # T
+00011c90: 6865 2066 6972 7374 2070 6173 732c 2073  he first pass, s
+00011ca0: 6f20 7265 6164 2061 6c6c 2072 656c 6576  o read all relev
+00011cb0: 616e 7420 636f 6c75 6d6e 7320 746f 2063  ant columns to c
+00011cc0: 6f64 650a 2020 2020 2020 2020 2020 2020  ode.            
+00011cd0: 2020 2020 2020 2020 2320 7468 656d 2069          # them i
+00011ce0: 6e20 6a73 6f6e 0a20 2020 2020 2020 2020  n json.         
+00011cf0: 2020 2020 2020 2020 2020 2069 6620 226a             if "j
+00011d00: 736f 6e22 2069 6e20 6167 675f 636f 6c75  son" in agg_colu
+00011d10: 6d6e 733a 0a20 2020 2020 2020 2020 2020  mns:.           
+00011d20: 2020 2020 2020 2020 2020 2020 2061 6767               agg
+00011d30: 5f63 6f6c 756d 6e73 5f6e 6565 6465 6420  _columns_needed 
+00011d40: 3d20 6167 675f 636f 6c75 6d6e 735b 226a  = agg_columns["j
+00011d50: 736f 6e22 5d0a 2020 2020 2020 2020 2020  son"].          
+00011d60: 2020 2020 2020 2020 2020 656c 6966 2022            elif "
+00011d70: 636f 6c75 6d6e 7322 2069 6e20 6167 675f  columns" in agg_
+00011d80: 636f 6c75 6d6e 733a 0a20 2020 2020 2020  columns:.       
+00011d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011da0: 2061 6767 5f63 6f6c 756d 6e73 5f6e 6565   agg_columns_nee
+00011db0: 6465 6420 3d20 5b0a 2020 2020 2020 2020  ded = [.        
+00011dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011dd0: 2020 2020 6167 675f 636f 6c75 6d6e 5b22      agg_column["
+00011de0: 636f 6c75 6d6e 225d 0a20 2020 2020 2020  column"].       
+00011df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011e00: 2020 2020 2066 6f72 2061 6767 5f63 6f6c       for agg_col
+00011e10: 756d 6e20 696e 2061 6767 5f63 6f6c 756d  umn in agg_colum
+00011e20: 6e73 5b22 636f 6c75 6d6e 7322 5d0a 2020  ns["columns"].  
+00011e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011e40: 2020 2020 2020 5d0a 2020 2020 2020 2020        ].        
+00011e50: 2020 2020 2020 2020 2020 2020 6966 2061              if a
+00011e60: 6767 5f63 6f6c 756d 6e73 5f6e 6565 6465  gg_columns_neede
+00011e70: 6420 6973 206e 6f74 204e 6f6e 653a 0a20  d is not None:. 
+00011e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011e90: 2020 2020 2020 2063 6f6c 756d 6e73 5f74         columns_t
+00011ea0: 6f5f 7265 6164 2e75 7064 6174 6528 6167  o_read.update(ag
+00011eb0: 675f 636f 6c75 6d6e 735f 6e65 6564 6564  g_columns_needed
+00011ec0: 290a 0a20 2020 2020 2020 2020 2020 2069  )..            i
+00011ed0: 6e70 7574 5f67 6466 203d 2067 666f 2e72  nput_gdf = gfo.r
+00011ee0: 6561 645f 6669 6c65 280a 2020 2020 2020  ead_file(.      
+00011ef0: 2020 2020 2020 2020 2020 7061 7468 3d69            path=i
+00011f00: 6e70 7574 5f70 6174 682c 0a20 2020 2020  nput_path,.     
+00011f10: 2020 2020 2020 2020 2020 206c 6179 6572             layer
+00011f20: 3d69 6e70 7574 5f6c 6179 6572 2c0a 2020  =input_layer,.  
+00011f30: 2020 2020 2020 2020 2020 2020 2020 6262                bb
+00011f40: 6f78 3d62 626f 782c 0a20 2020 2020 2020  ox=bbox,.       
+00011f50: 2020 2020 2020 2020 2063 6f6c 756d 6e73           columns
+00011f60: 3d63 6f6c 756d 6e73 5f74 6f5f 7265 6164  =columns_to_read
+00011f70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00011f80: 2020 6669 645f 6173 5f69 6e64 6578 3d66    fid_as_index=f
+00011f90: 6964 5f61 735f 696e 6465 782c 0a20 2020  id_as_index,.   
+00011fa0: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+00011fb0: 2020 2020 2020 2020 6966 2061 6767 5f63          if agg_c
+00011fc0: 6f6c 756d 6e73 2069 7320 6e6f 7420 4e6f  olumns is not No
+00011fd0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00011fe0: 2020 2020 696e 7075 745f 6764 665b 2266      input_gdf["f
+00011ff0: 6964 5f6f 7269 6722 5d20 3d20 696e 7075  id_orig"] = inpu
+00012000: 745f 6764 662e 696e 6465 780a 2020 2020  t_gdf.index.    
+00012010: 2020 2020 2020 2020 2020 2020 6966 2061              if a
+00012020: 6767 5f63 6f6c 756d 6e73 5f6e 6565 6465  gg_columns_neede
+00012030: 6420 6973 206e 6f74 204e 6f6e 653a 0a20  d is not None:. 
+00012040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012050: 2020 2061 6767 5f63 6f6c 756d 6e73 5f6e     agg_columns_n
+00012060: 6565 6465 642e 6170 7065 6e64 2822 6669  eeded.append("fi
+00012070: 645f 6f72 6967 2229 0a0a 2020 2020 2020  d_orig")..      
+00012080: 2020 2020 2020 6272 6561 6b0a 2020 2020        break.    
+00012090: 2020 2020 6578 6365 7074 2045 7863 6570      except Excep
+000120a0: 7469 6f6e 2061 7320 6578 3a0a 2020 2020  tion as ex:.    
+000120b0: 2020 2020 2020 2020 6966 2073 7472 2865          if str(e
+000120c0: 7829 203d 3d20 2264 6174 6162 6173 6520  x) == "database 
+000120d0: 6973 206c 6f63 6b65 6422 3a0a 2020 2020  is locked":.    
+000120e0: 2020 2020 2020 2020 2020 2020 6966 2072              if r
+000120f0: 6574 7279 5f63 6f75 6e74 203c 2031 303a  etry_count < 10:
+00012100: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012110: 2020 2020 2072 6574 7279 5f63 6f75 6e74       retry_count
+00012120: 202b 3d20 310a 2020 2020 2020 2020 2020   += 1.          
+00012130: 2020 2020 2020 2020 2020 7469 6d65 2e73            time.s
+00012140: 6c65 6570 2831 290a 2020 2020 2020 2020  leep(1).        
+00012150: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00012160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012170: 2020 7261 6973 6520 4578 6365 7074 696f    raise Exceptio
+00012180: 6e28 2272 6574 7269 6564 2031 3020 7469  n("retried 10 ti
+00012190: 6d65 732c 2064 6174 6162 6173 6520 7374  mes, database st
+000121a0: 696c 6c20 6c6f 636b 6564 2229 2066 726f  ill locked") fro
+000121b0: 6d20 6578 0a20 2020 2020 2020 2020 2020  m ex.           
+000121c0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+000121d0: 2020 2020 2020 2072 6169 7365 2065 780a         raise ex.
+000121e0: 0a20 2020 2023 2043 6865 636b 2072 6573  .    # Check res
+000121f0: 756c 740a 2020 2020 7065 7266 696e 666f  ult.    perfinfo
+00012200: 5b22 7469 6d65 5f72 6561 6422 5d20 3d20  ["time_read"] = 
+00012210: 2864 6174 6574 696d 652e 6e6f 7728 2920  (datetime.now() 
+00012220: 2d20 7374 6172 745f 7265 6164 292e 746f  - start_read).to
+00012230: 7461 6c5f 7365 636f 6e64 7328 290a 2020  tal_seconds().  
+00012240: 2020 7265 7475 726e 5f69 6e66 6f5b 226e    return_info["n
+00012250: 625f 726f 7773 5f64 6f6e 6522 5d20 3d20  b_rows_done"] = 
+00012260: 6c65 6e28 696e 7075 745f 6764 6629 0a20  len(input_gdf). 
+00012270: 2020 2069 6620 7265 7475 726e 5f69 6e66     if return_inf
+00012280: 6f5b 226e 625f 726f 7773 5f64 6f6e 6522  o["nb_rows_done"
+00012290: 5d20 3d3d 2030 3a0a 2020 2020 2020 2020  ] == 0:.        
+000122a0: 6d65 7373 6167 6520 3d20 6622 6469 7373  message = f"diss
+000122b0: 6f6c 7665 5f70 6f6c 7967 6f6e 733a 206e  olve_polygons: n
+000122c0: 6f20 696e 7075 7420 6765 6f6d 6574 7269  o input geometri
+000122d0: 6573 2066 6f75 6e64 2069 6e20 7b69 6e70  es found in {inp
+000122e0: 7574 5f70 6174 687d 220a 2020 2020 2020  ut_path}".      
+000122f0: 2020 6c6f 6767 6572 2e69 6e66 6f28 6d65    logger.info(me
+00012300: 7373 6167 6529 0a20 2020 2020 2020 2072  ssage).        r
+00012310: 6574 7572 6e5f 696e 666f 5b22 6d65 7373  eturn_info["mess
+00012320: 6167 6522 5d20 3d20 6d65 7373 6167 650a  age"] = message.
+00012330: 2020 2020 2020 2020 7265 7475 726e 5f69          return_i
+00012340: 6e66 6f5b 2274 6f74 616c 5f74 696d 6522  nfo["total_time"
+00012350: 5d20 3d20 2864 6174 6574 696d 652e 6e6f  ] = (datetime.no
+00012360: 7728 2920 2d20 7374 6172 745f 7469 6d65  w() - start_time
+00012370: 292e 746f 7461 6c5f 7365 636f 6e64 7328  ).total_seconds(
+00012380: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00012390: 2072 6574 7572 6e5f 696e 666f 0a0a 2020   return_info..  
+000123a0: 2020 2320 4e6f 7720 7468 6520 7265 616c    # Now the real
+000123b0: 2070 726f 6365 7373 696e 670a 2020 2020   processing.    
+000123c0: 6167 6766 756e 633a 2055 6e69 6f6e 5b73  aggfunc: Union[s
+000123d0: 7472 2c20 6469 6374 2c20 4e6f 6e65 5d20  tr, dict, None] 
+000123e0: 3d20 4e6f 6e65 0a20 2020 2069 6620 6167  = None.    if ag
+000123f0: 675f 636f 6c75 6d6e 7320 6973 206e 6f74  g_columns is not
+00012400: 204e 6f6e 653a 0a20 2020 2020 2020 2069   None:.        i
+00012410: 6620 225f 5f44 4953 534f 4c56 455f 544f  f "__DISSOLVE_TO
+00012420: 4a53 4f4e 2220 6e6f 7420 696e 2069 6e70  JSON" not in inp
+00012430: 7574 5f67 6466 2e63 6f6c 756d 6e73 3a0a  ut_gdf.columns:.
+00012440: 2020 2020 2020 2020 2020 2020 2320 4669              # Fi
+00012450: 7273 7420 7061 7373 202d 3e20 7075 7420  rst pass -> put 
+00012460: 7265 6c65 7661 6e74 2063 6f6c 756d 6e73  relevant columns
+00012470: 2069 6e20 6a73 6f6e 2066 6965 6c64 0a20   in json field. 
+00012480: 2020 2020 2020 2020 2020 2061 6767 6675             aggfu
+00012490: 6e63 203d 207b 2274 6f5f 6a73 6f6e 223a  nc = {"to_json":
+000124a0: 2061 6767 5f63 6f6c 756d 6e73 5f6e 6565   agg_columns_nee
+000124b0: 6465 647d 0a20 2020 2020 2020 2065 6c73  ded}.        els
+000124c0: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
+000124d0: 2043 6f6c 756d 6e73 2061 6c72 6561 6479   Columns already
+000124e0: 2063 6f64 6564 2069 6e20 6120 6a73 6f6e   coded in a json
+000124f0: 2063 6f6c 756d 6e2c 2073 6f20 6d65 7267   column, so merg
+00012500: 6520 6a73 6f6e 206c 6973 7473 0a20 2020  e json lists.   
+00012510: 2020 2020 2020 2020 2061 6767 6675 6e63           aggfunc
+00012520: 203d 2022 6d65 7267 655f 6a73 6f6e 5f6c   = "merge_json_l
+00012530: 6973 7473 220a 2020 2020 656c 7365 3a0a  ists".    else:.
+00012540: 2020 2020 2020 2020 6167 6766 756e 6320          aggfunc 
+00012550: 3d20 2266 6972 7374 220a 2020 2020 7374  = "first".    st
+00012560: 6172 745f 6469 7373 6f6c 7665 203d 2064  art_dissolve = d
+00012570: 6174 6574 696d 652e 6e6f 7728 290a 2020  atetime.now().  
+00012580: 2020 6469 7373 5f67 6466 203d 205f 6469    diss_gdf = _di
+00012590: 7373 6f6c 7665 280a 2020 2020 2020 2020  ssolve(.        
+000125a0: 6466 3d69 6e70 7574 5f67 6466 2c20 6279  df=input_gdf, by
+000125b0: 3d67 726f 7570 6279 5f63 6f6c 756d 6e73  =groupby_columns
+000125c0: 2c20 6167 6766 756e 633d 6167 6766 756e  , aggfunc=aggfun
+000125d0: 632c 2061 735f 696e 6465 783d 4661 6c73  c, as_index=Fals
+000125e0: 652c 2064 726f 706e 613d 4661 6c73 650a  e, dropna=False.
+000125f0: 2020 2020 290a 2020 2020 7065 7266 696e      ).    perfin
+00012600: 666f 5b22 7469 6d65 5f64 6973 736f 6c76  fo["time_dissolv
+00012610: 6522 5d20 3d20 2864 6174 6574 696d 652e  e"] = (datetime.
+00012620: 6e6f 7728 2920 2d20 7374 6172 745f 6469  now() - start_di
+00012630: 7373 6f6c 7665 292e 746f 7461 6c5f 7365  ssolve).total_se
+00012640: 636f 6e64 7328 290a 0a20 2020 2023 2049  conds()..    # I
+00012650: 6620 6578 706c 6f64 6563 6f6c 6c65 6374  f explodecollect
+00012660: 696f 6e73 2069 7320 5472 7565 2061 6e64  ions is True and
+00012670: 2046 6f72 2070 6f6c 7967 6f6e 732c 2065   For polygons, e
+00012680: 7870 6c6f 6465 206d 756c 7469 2d67 656f  xplode multi-geo
+00012690: 6d65 7472 6965 732e 0a20 2020 2023 2049  metries..    # I
+000126a0: 6620 6e65 6564 6564 2074 6865 7920 7769  f needed they wi
+000126b0: 6c6c 2062 6520 2763 6f6c 6c65 6374 6564  ll be 'collected
+000126c0: 2720 6166 7465 7277 6172 6473 2074 6f20  ' afterwards to 
+000126d0: 6d75 6c74 6970 6f6c 7967 6f6e 7320 6167  multipolygons ag
+000126e0: 6169 6e2e 0a20 2020 2069 6620 6578 706c  ain..    if expl
+000126f0: 6f64 6563 6f6c 6c65 6374 696f 6e73 2069  odecollections i
+00012700: 7320 5472 7565 206f 7220 696e 7075 745f  s True or input_
+00012710: 6765 6f6d 6574 7279 7479 7065 2069 6e20  geometrytype in 
+00012720: 5b0a 2020 2020 2020 2020 4765 6f6d 6574  [.        Geomet
+00012730: 7279 5479 7065 2e50 4f4c 5947 4f4e 2c0a  ryType.POLYGON,.
+00012740: 2020 2020 2020 2020 4765 6f6d 6574 7279          Geometry
+00012750: 5479 7065 2e4d 554c 5449 504f 4c59 474f  Type.MULTIPOLYGO
+00012760: 4e2c 0a20 2020 205d 3a0a 2020 2020 2020  N,.    ]:.      
+00012770: 2020 6469 7373 5f67 6466 203d 2064 6973    diss_gdf = dis
+00012780: 735f 6764 662e 6578 706c 6f64 6528 6967  s_gdf.explode(ig
+00012790: 6e6f 7265 5f69 6e64 6578 3d54 7275 6529  nore_index=True)
+000127a0: 0a0a 2020 2020 2320 436c 6970 2074 6865  ..    # Clip the
+000127b0: 2072 6573 756c 7420 6f6e 2074 6865 2062   result on the b
+000127c0: 6f72 6465 7273 206f 6620 7468 6520 6262  orders of the bb
+000127d0: 6f78 206e 6f74 2074 6f20 6861 7665 206f  ox not to have o
+000127e0: 7665 726c 6170 730a 2020 2020 2320 6265  verlaps.    # be
+000127f0: 7477 6565 6e20 7468 6520 6469 6666 6572  tween the differ
+00012800: 656e 7420 7469 6c65 732e 0a20 2020 2023  ent tiles..    #
+00012810: 2049 6620 7468 6973 2069 7320 6e6f 7420   If this is not 
+00012820: 6170 706c 6965 642c 2074 6869 7320 7265  applied, this re
+00012830: 7375 6c74 7320 696e 2073 6f6d 6520 6765  sults in some ge
+00012840: 6f6d 6574 7269 6573 206e 6f74 2062 6569  ometries not bei
+00012850: 6e67 206d 6572 6765 640a 2020 2020 2320  ng merged.    # 
+00012860: 6f72 2069 6e20 6475 706c 6963 6174 6573  or in duplicates
+00012870: 2e0a 2020 2020 2320 5245 4d41 524b 3a20  ..    # REMARK: 
+00012880: 666f 7220 286d 756c 7469 296c 696e 6573  for (multi)lines
+00012890: 7472 696e 6773 2c20 7468 6520 656e 6470  trings, the endp
+000128a0: 6f69 6e74 7320 6372 6561 7465 6420 6279  oints created by
+000128b0: 2074 6865 2063 6c69 7020 6172 6520 6e6f   the clip are no
+000128c0: 740a 2020 2020 2320 616c 7761 7973 2074  t.    # always t
+000128d0: 6865 2073 616d 6520 6475 6520 746f 2072  he same due to r
+000128e0: 6f75 6e64 696e 672c 2073 6f20 6469 7373  ounding, so diss
+000128f0: 6f6c 7669 6e67 2069 6e20 6120 6e65 7874  olving in a next
+00012900: 2070 6173 7320 646f 6573 6e27 740a 2020   pass doesn't.  
+00012910: 2020 2320 616c 7761 7973 2072 6573 756c    # always resul
+00012920: 7420 696e 206c 696e 6573 7472 696e 6773  t in linestrings
+00012930: 2062 6569 6e67 2072 652d 636f 6e6e 6563   being re-connec
+00012940: 7465 642e 2e2e 2042 6563 6175 7365 2064  ted... Because d
+00012950: 6973 736f 6c76 696e 670a 2020 2020 2320  issolving.    # 
+00012960: 6c69 6e65 7320 6973 6e27 7420 736f 2063  lines isn't so c
+00012970: 6f6d 7075 7461 7469 6f6e 616c 6c79 2068  omputationally h
+00012980: 6561 7679 2061 6e79 7761 792c 2064 726f  eavy anyway, dro
+00012990: 7020 7375 7070 6f72 7420 6865 7265 2e0a  p support here..
+000129a0: 2020 2020 6966 2062 626f 7820 6973 206e      if bbox is n
+000129b0: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+000129c0: 2073 7461 7274 5f63 6c69 7020 3d20 6461   start_clip = da
+000129d0: 7465 7469 6d65 2e6e 6f77 2829 0a20 2020  tetime.now().   
+000129e0: 2020 2020 2062 626f 785f 706f 6c79 676f       bbox_polygo
+000129f0: 6e20 3d20 7368 5f67 656f 6d2e 506f 6c79  n = sh_geom.Poly
+00012a00: 676f 6e28 0a20 2020 2020 2020 2020 2020  gon(.           
+00012a10: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
+00012a20: 2020 2028 6262 6f78 5b30 5d2c 2062 626f     (bbox[0], bbo
+00012a30: 785b 315d 292c 0a20 2020 2020 2020 2020  x[1]),.         
+00012a40: 2020 2020 2020 2028 6262 6f78 5b30 5d2c         (bbox[0],
+00012a50: 2062 626f 785b 335d 292c 0a20 2020 2020   bbox[3]),.     
+00012a60: 2020 2020 2020 2020 2020 2028 6262 6f78             (bbox
+00012a70: 5b32 5d2c 2062 626f 785b 335d 292c 0a20  [2], bbox[3]),. 
+00012a80: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+00012a90: 6262 6f78 5b32 5d2c 2062 626f 785b 315d  bbox[2], bbox[1]
+00012aa0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00012ab0: 2020 2028 6262 6f78 5b30 5d2c 2062 626f     (bbox[0], bbo
+00012ac0: 785b 315d 292c 0a20 2020 2020 2020 2020  x[1]),.         
+00012ad0: 2020 205d 0a20 2020 2020 2020 2029 0a20     ].        ). 
+00012ae0: 2020 2020 2020 2062 626f 785f 6764 6620         bbox_gdf 
+00012af0: 3d20 6770 642e 4765 6f44 6174 6146 7261  = gpd.GeoDataFra
+00012b00: 6d65 280a 2020 2020 2020 2020 2020 2020  me(.            
+00012b10: 6461 7461 3d5b 315d 2c20 6765 6f6d 6574  data=[1], geomet
+00012b20: 7279 3d5b 6262 6f78 5f70 6f6c 7967 6f6e  ry=[bbox_polygon
+00012b30: 5d2c 2063 7273 3d69 6e70 7574 5f67 6466  ], crs=input_gdf
+00012b40: 2e63 7273 0a20 2020 2020 2020 2029 0a0a  .crs.        )..
+00012b50: 2020 2020 2020 2020 2320 4361 7463 6820          # Catch 
+00012b60: 6972 7265 6c65 7661 6e74 2070 616e 6461  irrelevant panda
+00012b70: 7320 6675 7475 7265 2077 6172 6e69 6e67  s future warning
+00012b80: 0a20 2020 2020 2020 2023 2054 4f44 4f3a  .        # TODO:
+00012b90: 2077 6865 6e20 7265 6d6f 7665 6420 696e   when removed in
+00012ba0: 206c 6174 6572 2076 6572 7369 6f6e 206f   later version o
+00012bb0: 6620 7061 6e64 6173 2c20 6361 6e20 6265  f pandas, can be
+00012bc0: 2072 656d 6f76 6564 2068 6572 650a 2020   removed here.  
+00012bd0: 2020 2020 2020 7769 7468 2077 6172 6e69        with warni
+00012be0: 6e67 732e 6361 7463 685f 7761 726e 696e  ngs.catch_warnin
+00012bf0: 6773 2829 3a0a 2020 2020 2020 2020 2020  gs():.          
+00012c00: 2020 6d65 7373 6167 6520 3d20 280a 2020    message = (.  
+00012c10: 2020 2020 2020 2020 2020 2020 2020 2249                "I
+00012c20: 6e20 6120 6675 7475 7265 2076 6572 7369  n a future versi
+00012c30: 6f6e 2c20 6064 662e 696c 6f63 5b3a 2c20  on, `df.iloc[:, 
+00012c40: 695d 203d 206e 6577 7661 6c73 6020 7769  i] = newvals` wi
+00012c50: 6c6c 2061 7474 656d 7074 2074 6f20 220a  ll attempt to ".
+00012c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012c70: 2273 6574 2074 6865 2076 616c 7565 7320  "set the values 
+00012c80: 696e 706c 6163 6520 696e 7374 6561 6420  inplace instead 
+00012c90: 6f66 2061 6c77 6179 7320 7365 7474 696e  of always settin
+00012ca0: 6720 6120 6e65 7720 6172 7261 792e 220a  g a new array.".
+00012cb0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00012cc0: 2020 2020 2020 2020 2020 7761 726e 696e            warnin
+00012cd0: 6773 2e66 696c 7465 7277 6172 6e69 6e67  gs.filterwarning
+00012ce0: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
+00012cf0: 2020 2061 6374 696f 6e3d 2269 676e 6f72     action="ignor
+00012d00: 6522 2c20 6361 7465 676f 7279 3d46 7574  e", category=Fut
+00012d10: 7572 6557 6172 6e69 6e67 2c20 6d65 7373  ureWarning, mess
+00012d20: 6167 653d 7265 2e65 7363 6170 6528 6d65  age=re.escape(me
+00012d30: 7373 6167 6529 0a20 2020 2020 2020 2020  ssage).         
+00012d40: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+00012d50: 2023 206b 6565 705f 6765 6f6d 5f74 7970   # keep_geom_typ
+00012d60: 653d 5472 7565 2067 6176 6520 736f 6d65  e=True gave some
+00012d70: 7469 6d65 7320 6572 726f 722c 2061 6e64  times error, and
+00012d80: 2073 7469 6c6c 2064 6f65 7320 696e 2030   still does in 0
+00012d90: 2e39 2e30 0a20 2020 2020 2020 2020 2020  .9.0.           
+00012da0: 2023 2073 6f20 7573 6520 6f77 6e20 696d   # so use own im
+00012db0: 706c 656d 656e 7461 7469 6f6e 206f 6620  plementation of 
+00012dc0: 6b65 6570 5f67 656f 6d5f 7479 7065 0a20  keep_geom_type. 
+00012dd0: 2020 2020 2020 2020 2020 2064 6973 735f             diss_
+00012de0: 6764 6620 3d20 6770 642e 636c 6970 2864  gdf = gpd.clip(d
+00012df0: 6973 735f 6764 662c 2062 626f 785f 6764  iss_gdf, bbox_gd
+00012e00: 6629 2020 2320 2c20 6b65 6570 5f67 656f  f)  # , keep_geo
+00012e10: 6d5f 7479 7065 3d54 7275 6529 0a20 2020  m_type=True).   
+00012e20: 2020 2020 2020 2020 2061 7373 6572 7420           assert 
+00012e30: 6973 696e 7374 616e 6365 2864 6973 735f  isinstance(diss_
+00012e40: 6764 662c 2067 7064 2e47 656f 4461 7461  gdf, gpd.GeoData
+00012e50: 4672 616d 6529 0a0a 2020 2020 2020 2020  Frame)..        
+00012e60: 2320 4f6e 6c79 206b 6565 7020 6765 6f6d  # Only keep geom
+00012e70: 6574 7269 6573 206f 6620 7468 6520 7072  etries of the pr
+00012e80: 696d 6974 6976 6520 7479 7065 2073 7065  imitive type spe
+00012e90: 6369 6669 6564 2061 6674 6572 2063 6c69  cified after cli
+00012ea0: 702e 2e2e 0a20 2020 2020 2020 2061 7373  p....        ass
+00012eb0: 6572 7420 6973 696e 7374 616e 6365 2864  ert isinstance(d
+00012ec0: 6973 735f 6764 662c 2067 7064 2e47 656f  iss_gdf, gpd.Geo
+00012ed0: 4461 7461 4672 616d 6529 0a20 2020 2020  DataFrame).     
+00012ee0: 2020 2064 6973 735f 6764 662e 6765 6f6d     diss_gdf.geom
+00012ef0: 6574 7279 203d 2070 7967 656f 6f70 732e  etry = pygeoops.
+00012f00: 636f 6c6c 6563 7469 6f6e 5f65 7874 7261  collection_extra
+00012f10: 6374 280a 2020 2020 2020 2020 2020 2020  ct(.            
+00012f20: 6469 7373 5f67 6466 2e67 656f 6d65 7472  diss_gdf.geometr
+00012f30: 792c 2070 7269 6d69 7469 7665 7479 7065  y, primitivetype
+00012f40: 3d69 6e70 7574 5f67 656f 6d65 7472 7974  =input_geometryt
+00012f50: 7970 652e 746f 5f70 7269 6d69 7469 7665  ype.to_primitive
+00012f60: 7479 7065 0a20 2020 2020 2020 2029 0a0a  type.        )..
+00012f70: 2020 2020 2020 2020 7065 7266 696e 666f          perfinfo
+00012f80: 5b22 7469 6d65 5f63 6c69 7022 5d20 3d20  ["time_clip"] = 
+00012f90: 2864 6174 6574 696d 652e 6e6f 7728 2920  (datetime.now() 
+00012fa0: 2d20 7374 6172 745f 636c 6970 292e 746f  - start_clip).to
+00012fb0: 7461 6c5f 7365 636f 6e64 7328 290a 0a20  tal_seconds().. 
+00012fc0: 2020 2069 6620 6772 6964 7369 7a65 2021     if gridsize !
+00012fd0: 3d20 302e 303a 0a20 2020 2020 2020 2064  = 0.0:.        d
+00012fe0: 6973 735f 6764 662e 6765 6f6d 6574 7279  iss_gdf.geometry
+00012ff0: 203d 205f 6765 6f73 6572 6965 735f 7574   = _geoseries_ut
+00013000: 696c 2e73 6574 5f70 7265 6369 7369 6f6e  il.set_precision
+00013010: 280a 2020 2020 2020 2020 2020 2020 6469  (.            di
+00013020: 7373 5f67 6466 2e67 656f 6d65 7472 792c  ss_gdf.geometry,
+00013030: 2067 7269 645f 7369 7a65 3d67 7269 6473   grid_size=grids
+00013040: 697a 652c 2072 6169 7365 5f6f 6e5f 746f  ize, raise_on_to
+00013050: 706f 6572 726f 723d 4661 6c73 650a 2020  poerror=False.  
+00013060: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00013070: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
+00013080: 6528 6469 7373 5f67 6466 2e67 656f 6d65  e(diss_gdf.geome
+00013090: 7472 792c 2067 7064 2e47 656f 5365 7269  try, gpd.GeoSeri
+000130a0: 6573 290a 0a20 2020 2023 2053 6574 2065  es)..    # Set e
+000130b0: 6d70 7479 2067 656f 6d65 7472 6965 7320  mpty geometries 
+000130c0: 746f 204e 6f6e 650a 2020 2020 6469 7373  to None.    diss
+000130d0: 5f67 6466 2e6c 6f63 5b64 6973 735f 6764  _gdf.loc[diss_gd
+000130e0: 662e 6765 6f6d 6574 7279 2e69 735f 656d  f.geometry.is_em
+000130f0: 7074 792c 2064 6973 735f 6764 662e 6765  pty, diss_gdf.ge
+00013100: 6f6d 6574 7279 2e6e 616d 655d 203d 204e  ometry.name] = N
+00013110: 6f6e 650a 0a20 2020 2069 6620 6e6f 7420  one..    if not 
+00013120: 6b65 6570 5f65 6d70 7479 5f67 656f 6d73  keep_empty_geoms
+00013130: 3a0a 2020 2020 2020 2020 2320 5265 6d6f  :.        # Remo
+00013140: 7665 2072 6f77 7320 7768 6572 6520 6765  ve rows where ge
+00013150: 6f6d 2069 7320 4e6f 6e65 0a20 2020 2020  om is None.     
+00013160: 2020 2061 7373 6572 7420 6973 696e 7374     assert isinst
+00013170: 616e 6365 2864 6973 735f 6764 662c 2067  ance(diss_gdf, g
+00013180: 7064 2e47 656f 4461 7461 4672 616d 6529  pd.GeoDataFrame)
+00013190: 0a20 2020 2020 2020 2064 6973 735f 6764  .        diss_gd
+000131a0: 6620 3d20 6469 7373 5f67 6466 5b7e 6469  f = diss_gdf[~di
+000131b0: 7373 5f67 6466 2e67 656f 6d65 7472 792e  ss_gdf.geometry.
+000131c0: 6973 6e61 2829 5d0a 0a20 2020 2023 2049  isna()]..    # I
+000131d0: 6620 7468 6572 6520 6973 206e 6f20 7265  f there is no re
+000131e0: 7375 6c74 2c20 7265 7475 726e 0a20 2020  sult, return.   
+000131f0: 2069 6620 6c65 6e28 6469 7373 5f67 6466   if len(diss_gdf
+00013200: 2920 3d3d 2030 3a0a 2020 2020 2020 2020  ) == 0:.        
+00013210: 6d65 7373 6167 6520 3d20 6622 5265 7375  message = f"Resu
+00013220: 6c74 2069 7320 656d 7074 7920 666f 7220  lt is empty for 
+00013230: 7b69 6e70 7574 5f70 6174 687d 220a 2020  {input_path}".  
+00013240: 2020 2020 2020 7265 7475 726e 5f69 6e66        return_inf
+00013250: 6f5b 226d 6573 7361 6765 225d 203d 206d  o["message"] = m
+00013260: 6573 7361 6765 0a20 2020 2020 2020 2072  essage.        r
+00013270: 6574 7572 6e5f 696e 666f 5b22 7065 7266  eturn_info["perf
+00013280: 696e 666f 225d 203d 2070 6572 6669 6e66  info"] = perfinf
+00013290: 6f0a 2020 2020 2020 2020 7265 7475 726e  o.        return
+000132a0: 5f69 6e66 6f5b 2274 6f74 616c 5f74 696d  _info["total_tim
+000132b0: 6522 5d20 3d20 2864 6174 6574 696d 652e  e"] = (datetime.
+000132c0: 6e6f 7728 2920 2d20 7374 6172 745f 7469  now() - start_ti
+000132d0: 6d65 292e 746f 7461 6c5f 7365 636f 6e64  me).total_second
+000132e0: 7328 290a 2020 2020 2020 2020 7265 7475  s().        retu
+000132f0: 726e 2072 6574 7572 6e5f 696e 666f 0a0a  rn return_info..
+00013300: 2020 2020 2320 4164 6420 636f 6c75 6d6e      # Add column
+00013310: 2077 6974 6820 7469 6c65 5f69 640a 2020   with tile_id.  
+00013320: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+00013330: 6e63 6528 6469 7373 5f67 6466 2c20 6770  nce(diss_gdf, gp
+00013340: 642e 4765 6f44 6174 6146 7261 6d65 290a  d.GeoDataFrame).
+00013350: 2020 2020 6966 2074 696c 655f 6964 2069      if tile_id i
+00013360: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00013370: 2020 2020 6469 7373 5f67 6466 5b22 7469      diss_gdf["ti
+00013380: 6c65 5f69 6422 5d20 3d20 7469 6c65 5f69  le_id"] = tile_i
+00013390: 640a 0a20 2020 2023 2053 6176 6520 7468  d..    # Save th
+000133a0: 6520 7265 7375 6c74 2074 6f20 6465 7374  e result to dest
+000133b0: 696e 6174 696f 6e20 6669 6c65 2873 290a  ination file(s).
+000133c0: 2020 2020 7374 6172 745f 746f 5f66 696c      start_to_fil
+000133d0: 6520 3d20 6461 7465 7469 6d65 2e6e 6f77  e = datetime.now
+000133e0: 2829 0a0a 2020 2020 2320 4966 2074 6865  ()..    # If the
+000133f0: 2074 696c 6573 2064 6f6e 2774 206e 6565   tiles don't nee
+00013400: 6420 746f 2062 6520 6d65 7267 6564 2061  d to be merged a
+00013410: 6674 6572 7761 7264 732c 2077 6520 6361  fterwards, we ca
+00013420: 6e20 6a75 7374 2073 6176 6520 7468 6520  n just save the 
+00013430: 7265 7375 6c74 2061 730a 2020 2020 2320  result as.    # 
+00013440: 6974 2069 732e 0a20 2020 2069 6620 7374  it is..    if st
+00013450: 7228 6f75 7470 7574 5f6e 6f74 6f6e 626f  r(output_notonbo
+00013460: 7264 6572 5f70 6174 6829 203d 3d20 7374  rder_path) == st
+00013470: 7228 6f75 7470 7574 5f6f 6e62 6f72 6465  r(output_onborde
+00013480: 725f 7061 7468 293a 0a20 2020 2020 2020  r_path):.       
+00013490: 2023 2061 7373 6572 7420 746f 2061 766f   # assert to avo
+000134a0: 6964 2070 794c 616e 6365 2077 6172 6e69  id pyLance warni
+000134b0: 6e67 0a20 2020 2020 2020 2061 7373 6572  ng.        asser
+000134c0: 7420 6973 696e 7374 616e 6365 2864 6973  t isinstance(dis
+000134d0: 735f 6764 662c 2067 7064 2e47 656f 4461  s_gdf, gpd.GeoDa
+000134e0: 7461 4672 616d 6529 0a20 2020 2020 2020  taFrame).       
+000134f0: 2023 2055 7365 2066 6f72 6365 5f6d 756c   # Use force_mul
+00013500: 7469 7479 7065 2c20 746f 2061 766f 6964  titype, to avoid
+00013510: 2077 6172 6e69 6e67 7320 7768 656e 2073   warnings when s
+00013520: 6f6d 6520 6261 7463 6865 7320 636f 6e74  ome batches cont
+00013530: 6169 6e0a 2020 2020 2020 2020 2320 7369  ain.        # si
+00013540: 6e67 6c65 7479 7065 2061 6e64 2073 6f6d  ngletype and som
+00013550: 6520 636f 6e74 6169 6e20 6d75 6c74 6974  e contain multit
+00013560: 7970 6520 6765 6f6d 6574 7269 6573 0a20  ype geometries. 
+00013570: 2020 2020 2020 2067 666f 2e74 6f5f 6669         gfo.to_fi
+00013580: 6c65 280a 2020 2020 2020 2020 2020 2020  le(.            
+00013590: 6469 7373 5f67 6466 2c0a 2020 2020 2020  diss_gdf,.      
+000135a0: 2020 2020 2020 6f75 7470 7574 5f6e 6f74        output_not
+000135b0: 6f6e 626f 7264 6572 5f70 6174 682c 0a20  onborder_path,. 
+000135c0: 2020 2020 2020 2020 2020 206c 6179 6572             layer
+000135d0: 3d6f 7574 7075 745f 6c61 7965 722c 0a20  =output_layer,. 
+000135e0: 2020 2020 2020 2020 2020 2066 6f72 6365             force
+000135f0: 5f6d 756c 7469 7479 7065 3d54 7275 652c  _multitype=True,
+00013600: 0a20 2020 2020 2020 2020 2020 2069 6e64  .            ind
+00013610: 6578 3d46 616c 7365 2c0a 2020 2020 2020  ex=False,.      
+00013620: 2020 2020 2020 6372 6561 7465 5f73 7061        create_spa
+00013630: 7469 616c 5f69 6e64 6578 3d46 616c 7365  tial_index=False
+00013640: 2c0a 2020 2020 2020 2020 290a 2020 2020  ,.        ).    
+00013650: 656c 7365 3a0a 2020 2020 2020 2020 2320  else:.        # 
+00013660: 4966 206e 6f74 2c20 7361 7665 2074 6865  If not, save the
+00013670: 2070 6f6c 7967 6f6e 7320 6f6e 2074 6865   polygons on the
+00013680: 2062 6f72 6465 7220 7365 7065 7261 7465   border seperate
+00013690: 6c79 0a20 2020 2020 2020 2062 626f 785f  ly.        bbox_
+000136a0: 6c69 6e65 7320 3d20 7079 6765 6f6f 7073  lines = pygeoops
+000136b0: 2e65 7870 6c6f 6465 280a 2020 2020 2020  .explode(.      
+000136c0: 2020 2020 2020 7368 6170 656c 792e 626f        shapely.bo
+000136d0: 756e 6461 7279 2873 685f 6765 6f6d 2e62  undary(sh_geom.b
+000136e0: 6f78 2862 626f 785b 305d 2c20 6262 6f78  ox(bbox[0], bbox
+000136f0: 5b31 5d2c 2062 626f 785b 325d 2c20 6262  [1], bbox[2], bb
+00013700: 6f78 5b33 5d29 290a 2020 2020 2020 2020  ox[3])).        
+00013710: 290a 2020 2020 2020 2020 6262 6f78 5f6c  ).        bbox_l
+00013720: 696e 6573 5f67 6466 203d 2067 7064 2e47  ines_gdf = gpd.G
+00013730: 656f 4461 7461 4672 616d 6528 6765 6f6d  eoDataFrame(geom
+00013740: 6574 7279 3d62 626f 785f 6c69 6e65 732c  etry=bbox_lines,
+00013750: 2063 7273 3d69 6e70 7574 5f67 6466 2e63   crs=input_gdf.c
+00013760: 7273 290a 2020 2020 2020 2020 6f6e 626f  rs).        onbo
+00013770: 7264 6572 5f67 6466 203d 2067 7064 2e73  rder_gdf = gpd.s
+00013780: 6a6f 696e 2864 6973 735f 6764 662c 2062  join(diss_gdf, b
+00013790: 626f 785f 6c69 6e65 735f 6764 662c 2070  box_lines_gdf, p
+000137a0: 7265 6469 6361 7465 3d22 696e 7465 7273  redicate="inters
+000137b0: 6563 7473 2229 0a20 2020 2020 2020 206f  ects").        o
+000137c0: 6e62 6f72 6465 725f 6764 662e 6472 6f70  nborder_gdf.drop
+000137d0: 2822 696e 6465 785f 7269 6768 7422 2c20  ("index_right", 
+000137e0: 6178 6973 3d31 2c20 696e 706c 6163 653d  axis=1, inplace=
+000137f0: 5472 7565 290a 2020 2020 2020 2020 6966  True).        if
+00013800: 206c 656e 286f 6e62 6f72 6465 725f 6764   len(onborder_gd
+00013810: 6629 203e 2030 3a0a 2020 2020 2020 2020  f) > 0:.        
+00013820: 2020 2020 2320 5573 6520 666f 7263 655f      # Use force_
+00013830: 6d75 6c74 6974 7970 652c 2074 6f20 6176  multitype, to av
+00013840: 6f69 6420 7761 726e 696e 6773 2077 6865  oid warnings whe
+00013850: 6e20 736f 6d65 2062 6174 6368 6573 2063  n some batches c
+00013860: 6f6e 7461 696e 0a20 2020 2020 2020 2020  ontain.         
+00013870: 2020 2023 2073 696e 676c 6574 7970 6520     # singletype 
+00013880: 616e 6420 736f 6d65 2063 6f6e 7461 696e  and some contain
+00013890: 206d 756c 7469 7479 7065 2067 656f 6d65   multitype geome
+000138a0: 7472 6965 730a 2020 2020 2020 2020 2020  tries.          
+000138b0: 2020 6766 6f2e 746f 5f66 696c 6528 0a20    gfo.to_file(. 
+000138c0: 2020 2020 2020 2020 2020 2020 2020 206f                 o
+000138d0: 6e62 6f72 6465 725f 6764 662c 0a20 2020  nborder_gdf,.   
+000138e0: 2020 2020 2020 2020 2020 2020 206f 7574               out
+000138f0: 7075 745f 6f6e 626f 7264 6572 5f70 6174  put_onborder_pat
+00013900: 682c 0a20 2020 2020 2020 2020 2020 2020  h,.             
+00013910: 2020 206c 6179 6572 3d6f 7574 7075 745f     layer=output_
+00013920: 6c61 7965 722c 0a20 2020 2020 2020 2020  layer,.         
+00013930: 2020 2020 2020 2066 6f72 6365 5f6d 756c         force_mul
+00013940: 7469 7479 7065 3d54 7275 652c 0a20 2020  titype=True,.   
+00013950: 2020 2020 2020 2020 2020 2020 2063 7265               cre
+00013960: 6174 655f 7370 6174 6961 6c5f 696e 6465  ate_spatial_inde
+00013970: 783d 4661 6c73 652c 0a20 2020 2020 2020  x=False,.       
+00013980: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+00013990: 6e6f 746f 6e62 6f72 6465 725f 6764 6620  notonborder_gdf 
+000139a0: 3d20 6469 7373 5f67 6466 5b7e 6469 7373  = diss_gdf[~diss
+000139b0: 5f67 6466 2e69 6e64 6578 2e69 7369 6e28  _gdf.index.isin(
+000139c0: 6f6e 626f 7264 6572 5f67 6466 2e69 6e64  onborder_gdf.ind
+000139d0: 6578 295d 0a20 2020 2020 2020 2069 6620  ex)].        if 
+000139e0: 6c65 6e28 6e6f 746f 6e62 6f72 6465 725f  len(notonborder_
+000139f0: 6764 6629 203e 2030 3a0a 2020 2020 2020  gdf) > 0:.      
+00013a00: 2020 2020 2020 2320 5573 6520 666f 7263        # Use forc
+00013a10: 655f 6d75 6c74 6974 7970 652c 2074 6f20  e_multitype, to 
+00013a20: 6176 6f69 6420 7761 726e 696e 6773 2077  avoid warnings w
+00013a30: 6865 6e20 736f 6d65 2062 6174 6368 6573  hen some batches
+00013a40: 2063 6f6e 7461 696e 0a20 2020 2020 2020   contain.       
+00013a50: 2020 2020 2023 2073 696e 676c 6574 7970       # singletyp
+00013a60: 6520 616e 6420 736f 6d65 2063 6f6e 7461  e and some conta
+00013a70: 696e 206d 756c 7469 7479 7065 2067 656f  in multitype geo
+00013a80: 6d65 7472 6965 730a 2020 2020 2020 2020  metries.        
+00013a90: 2020 2020 6766 6f2e 746f 5f66 696c 6528      gfo.to_file(
+00013aa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013ab0: 206e 6f74 6f6e 626f 7264 6572 5f67 6466   notonborder_gdf
+00013ac0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00013ad0: 2020 6f75 7470 7574 5f6e 6f74 6f6e 626f    output_notonbo
+00013ae0: 7264 6572 5f70 6174 682c 0a20 2020 2020  rder_path,.     
+00013af0: 2020 2020 2020 2020 2020 206c 6179 6572             layer
+00013b00: 3d6f 7574 7075 745f 6c61 7965 722c 0a20  =output_layer,. 
+00013b10: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00013b20: 6f72 6365 5f6d 756c 7469 7479 7065 3d54  orce_multitype=T
+00013b30: 7275 652c 0a20 2020 2020 2020 2020 2020  rue,.           
+00013b40: 2020 2020 2069 6e64 6578 3d46 616c 7365       index=False
+00013b50: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00013b60: 2020 6372 6561 7465 5f73 7061 7469 616c    create_spatial
+00013b70: 5f69 6e64 6578 3d46 616c 7365 2c0a 2020  _index=False,.  
+00013b80: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00013b90: 7065 7266 696e 666f 5b22 7469 6d65 5f74  perfinfo["time_t
+00013ba0: 6f5f 6669 6c65 225d 203d 2028 6461 7465  o_file"] = (date
+00013bb0: 7469 6d65 2e6e 6f77 2829 202d 2073 7461  time.now() - sta
+00013bc0: 7274 5f74 6f5f 6669 6c65 292e 746f 7461  rt_to_file).tota
+00013bd0: 6c5f 7365 636f 6e64 7328 290a 0a20 2020  l_seconds()..   
+00013be0: 2023 2046 696e 616c 6973 652e 2e2e 0a20   # Finalise.... 
+00013bf0: 2020 206d 6573 7361 6765 203d 2066 2264     message = f"d
+00013c00: 6973 736f 6c76 655f 706f 6c79 676f 6e73  issolve_polygons
+00013c10: 3a20 7265 6164 7920 696e 207b 6461 7465  : ready in {date
+00013c20: 7469 6d65 2e6e 6f77 2829 2d73 7461 7274  time.now()-start
+00013c30: 5f74 696d 657d 206f 6e20 7b69 6e70 7574  _time} on {input
+00013c40: 5f70 6174 687d 220a 2020 2020 6c6f 6767  _path}".    logg
+00013c50: 6572 2e64 6562 7567 286d 6573 7361 6765  er.debug(message
+00013c60: 290a 0a20 2020 2023 2043 6f6c 6c65 6374  )..    # Collect
+00013c70: 2070 6572 6669 6e66 6f0a 2020 2020 746f   perfinfo.    to
+00013c80: 7461 6c5f 7065 7266 5f74 696d 6520 3d20  tal_perf_time = 
+00013c90: 302e 300a 2020 2020 7065 7266 7374 7269  0.0.    perfstri
+00013ca0: 6e67 203d 2022 220a 2020 2020 666f 7220  ng = "".    for 
+00013cb0: 7065 7266 636f 6465 2069 6e20 7065 7266  perfcode in perf
+00013cc0: 696e 666f 3a0a 2020 2020 2020 2020 746f  info:.        to
+00013cd0: 7461 6c5f 7065 7266 5f74 696d 6520 2b3d  tal_perf_time +=
+00013ce0: 2070 6572 6669 6e66 6f5b 7065 7266 636f   perfinfo[perfco
+00013cf0: 6465 5d0a 2020 2020 2020 2020 7065 7266  de].        perf
+00013d00: 7374 7269 6e67 202b 3d20 6622 7b70 6572  string += f"{per
+00013d10: 6663 6f64 657d 3a20 7b70 6572 6669 6e66  fcode}: {perfinf
+00013d20: 6f5b 7065 7266 636f 6465 5d3a 2e32 667d  o[perfcode]:.2f}
+00013d30: 2c20 220a 2020 2020 7265 7475 726e 5f69  , ".    return_i
+00013d40: 6e66 6f5b 2274 6f74 616c 5f74 696d 6522  nfo["total_time"
+00013d50: 5d20 3d20 2864 6174 6574 696d 652e 6e6f  ] = (datetime.no
+00013d60: 7728 2920 2d20 7374 6172 745f 7469 6d65  w() - start_time
+00013d70: 292e 746f 7461 6c5f 7365 636f 6e64 7328  ).total_seconds(
+00013d80: 290a 2020 2020 7065 7266 696e 666f 5b22  ).    perfinfo["
+00013d90: 756e 6163 636f 756e 7465 6422 5d20 3d20  unaccounted"] = 
+00013da0: 280a 2020 2020 2020 2020 7265 7475 726e  (.        return
+00013db0: 5f69 6e66 6f5b 2274 6f74 616c 5f74 696d  _info["total_tim
+00013dc0: 6522 5d20 2d20 746f 7461 6c5f 7065 7266  e"] - total_perf
+00013dd0: 5f74 696d 6520 2023 2074 7970 653a 2069  _time  # type: i
+00013de0: 676e 6f72 655b 6f70 6572 6174 6f72 5d0a  gnore[operator].
+00013df0: 2020 2020 290a 2020 2020 7065 7266 7374      ).    perfst
+00013e00: 7269 6e67 202b 3d20 6622 756e 6163 636f  ring += f"unacco
+00013e10: 756e 7465 643a 207b 7065 7266 696e 666f  unted: {perfinfo
+00013e20: 5b27 756e 6163 636f 756e 7465 6427 5d3a  ['unaccounted']:
+00013e30: 2e32 667d 220a 0a20 2020 2023 2052 6574  .2f}"..    # Ret
+00013e40: 7572 6e0a 2020 2020 7265 7475 726e 5f69  urn.    return_i
+00013e50: 6e66 6f5b 2270 6572 6669 6e66 6f22 5d20  nfo["perfinfo"] 
+00013e60: 3d20 7065 7266 696e 666f 0a20 2020 2072  = perfinfo.    r
+00013e70: 6574 7572 6e5f 696e 666f 5b22 7065 7266  eturn_info["perf
+00013e80: 7374 7269 6e67 225d 203d 2070 6572 6673  string"] = perfs
+00013e90: 7472 696e 670a 2020 2020 7265 7475 726e  tring.    return
+00013ea0: 5f69 6e66 6f5b 226d 6573 7361 6765 225d  _info["message"]
+00013eb0: 203d 206d 6573 7361 6765 0a20 2020 2072   = message.    r
+00013ec0: 6574 7572 6e20 7265 7475 726e 5f69 6e66  eturn return_inf
+00013ed0: 6f0a 0a0a 6465 6620 5f64 6973 736f 6c76  o...def _dissolv
+00013ee0: 6528 0a20 2020 2064 663a 2067 7064 2e47  e(.    df: gpd.G
+00013ef0: 656f 4461 7461 4672 616d 652c 0a20 2020  eoDataFrame,.   
+00013f00: 2062 793d 4e6f 6e65 2c0a 2020 2020 6167   by=None,.    ag
+00013f10: 6766 756e 633a 204f 7074 696f 6e61 6c5b  gfunc: Optional[
+00013f20: 556e 696f 6e5b 7374 722c 2064 6963 745d  Union[str, dict]
+00013f30: 5d20 3d20 2266 6972 7374 222c 0a20 2020  ] = "first",.   
+00013f40: 2061 735f 696e 6465 783d 5472 7565 2c0a   as_index=True,.
+00013f50: 2020 2020 6c65 7665 6c3d 4e6f 6e65 2c0a      level=None,.
+00013f60: 2020 2020 736f 7274 3d54 7275 652c 0a20      sort=True,. 
+00013f70: 2020 206f 6273 6572 7665 643d 4661 6c73     observed=Fals
+00013f80: 652c 0a20 2020 2064 726f 706e 613d 5472  e,.    dropna=Tr
+00013f90: 7565 2c0a 2920 2d3e 2067 7064 2e47 656f  ue,.) -> gpd.Geo
+00013fa0: 4461 7461 4672 616d 653a 0a20 2020 2022  DataFrame:.    "
+00013fb0: 2222 0a20 2020 2044 6973 736f 6c76 6520  "".    Dissolve 
+00013fc0: 6765 6f6d 6574 7269 6573 2077 6974 6869  geometries withi
+00013fd0: 6e20 6067 726f 7570 6279 6020 696e 746f  n `groupby` into
+00013fe0: 2073 696e 676c 6520 6f62 7365 7276 6174   single observat
+00013ff0: 696f 6e2e 0a0a 2020 2020 5468 6973 2069  ion...    This i
+00014000: 7320 6163 636f 6d70 6c69 7368 6564 2062  s accomplished b
+00014010: 7920 6170 706c 7969 6e67 2074 6865 2060  y applying the `
+00014020: 756e 6172 795f 756e 696f 6e60 206d 6574  unary_union` met
+00014030: 686f 640a 2020 2020 746f 2061 6c6c 2067  hod.    to all g
+00014040: 656f 6d65 7472 6965 7320 7769 7468 696e  eometries within
+00014050: 2061 2067 726f 7570 7365 6c66 2e0a 2020   a groupself..  
+00014060: 2020 4f62 7365 7276 6174 696f 6e73 2061    Observations a
+00014070: 7373 6f63 6961 7465 6420 7769 7468 2065  ssociated with e
+00014080: 6163 6820 6067 726f 7570 6279 6020 6772  ach `groupby` gr
+00014090: 6f75 7020 7769 6c6c 2062 6520 6167 6772  oup will be aggr
+000140a0: 6567 6174 6564 0a20 2020 2075 7369 6e67  egated.    using
+000140b0: 2074 6865 2060 6167 6766 756e 6360 2e0a   the `aggfunc`..
+000140c0: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
+000140d0: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
+000140e0: 2020 6279 203a 2073 7472 696e 672c 2064    by : string, d
+000140f0: 6566 6175 6c74 204e 6f6e 650a 2020 2020  efault None.    
+00014100: 2020 2020 436f 6c75 6d6e 2077 686f 7365      Column whose
+00014110: 2076 616c 7565 7320 6465 6669 6e65 2067   values define g
+00014120: 726f 7570 7320 746f 2062 6520 6469 7373  roups to be diss
+00014130: 6f6c 7665 642e 2049 6620 4e6f 6e65 2c0a  olved. If None,.
+00014140: 2020 2020 2020 2020 7768 6f6c 6520 4765          whole Ge
+00014150: 6f44 6174 6146 7261 6d65 2069 7320 636f  oDataFrame is co
+00014160: 6e73 6964 6572 6564 2061 2073 696e 676c  nsidered a singl
+00014170: 6520 6772 6f75 702e 0a20 2020 2061 6767  e group..    agg
+00014180: 6675 6e63 203a 2066 756e 6374 696f 6e2c  func : function,
+00014190: 2073 7472 696e 6720 6f72 2064 6963 742c   string or dict,
+000141a0: 2064 6566 6175 6c74 2022 6669 7273 7422   default "first"
+000141b0: 0a20 2020 2020 2020 2041 6767 7265 6761  .        Aggrega
+000141c0: 7469 6f6e 2066 756e 6374 696f 6e20 666f  tion function fo
+000141d0: 7220 6d61 6e69 7075 6c61 7469 6f6e 206f  r manipulation o
+000141e0: 6620 6461 7461 2061 7373 6f63 6961 7465  f data associate
+000141f0: 640a 2020 2020 2020 2020 7769 7468 2065  d.        with e
+00014200: 6163 6820 6772 6f75 702e 2050 6173 7365  ach group. Passe
+00014210: 6420 746f 2070 616e 6461 7320 6067 726f  d to pandas `gro
+00014220: 7570 6279 2e61 6767 6020 6d65 7468 6f64  upby.agg` method
+00014230: 2e0a 2020 2020 6173 5f69 6e64 6578 203a  ..    as_index :
+00014240: 2062 6f6f 6c65 616e 2c20 6465 6661 756c   boolean, defaul
+00014250: 7420 5472 7565 0a20 2020 2020 2020 2049  t True.        I
+00014260: 6620 7472 7565 2c20 6772 6f75 7062 7920  f true, groupby 
+00014270: 636f 6c75 6d6e 7320 6265 636f 6d65 2069  columns become i
+00014280: 6e64 6578 206f 6620 7265 7375 6c74 2e0a  ndex of result..
+00014290: 2020 2020 6c65 7665 6c20 3a20 696e 7420      level : int 
+000142a0: 6f72 2073 7472 206f 7220 7365 7175 656e  or str or sequen
+000142b0: 6365 206f 6620 696e 7420 6f72 2073 6571  ce of int or seq
+000142c0: 7565 6e63 6520 6f66 2073 7472 2c20 6465  uence of str, de
+000142d0: 6661 756c 7420 4e6f 6e65 0a20 2020 2020  fault None.     
+000142e0: 2020 2049 6620 7468 6520 6178 6973 2069     If the axis i
+000142f0: 7320 6120 4d75 6c74 6949 6e64 6578 2028  s a MultiIndex (
+00014300: 6869 6572 6172 6368 6963 616c 292c 2067  hierarchical), g
+00014310: 726f 7570 2062 7920 610a 2020 2020 2020  roup by a.      
+00014320: 2020 7061 7274 6963 756c 6172 206c 6576    particular lev
+00014330: 656c 206f 7220 6c65 7665 6c73 2e0a 2020  el or levels..  
+00014340: 2020 2020 2020 2e2e 2076 6572 7369 6f6e        .. version
+00014350: 6164 6465 643a 3a20 302e 392e 300a 2020  added:: 0.9.0.  
+00014360: 2020 736f 7274 203a 2062 6f6f 6c2c 2064    sort : bool, d
+00014370: 6566 6175 6c74 2054 7275 650a 2020 2020  efault True.    
+00014380: 2020 2020 536f 7274 2067 726f 7570 206b      Sort group k
+00014390: 6579 732e 2047 6574 2062 6574 7465 7220  eys. Get better 
+000143a0: 7065 7266 6f72 6d61 6e63 6520 6279 2074  performance by t
+000143b0: 7572 6e69 6e67 2074 6869 7320 6f66 662e  urning this off.
+000143c0: 0a20 2020 2020 2020 204e 6f74 6520 7468  .        Note th
+000143d0: 6973 2064 6f65 7320 6e6f 7420 696e 666c  is does not infl
+000143e0: 7565 6e63 6520 7468 6520 6f72 6465 7220  uence the order 
+000143f0: 6f66 206f 6273 6572 7661 7469 6f6e 7320  of observations 
+00014400: 7769 7468 696e 0a20 2020 2020 2020 2065  within.        e
+00014410: 6163 6820 6772 6f75 702e 2047 726f 7570  ach group. Group
+00014420: 6279 2070 7265 7365 7276 6573 2074 6865  by preserves the
+00014430: 206f 7264 6572 206f 6620 726f 7773 2077   order of rows w
+00014440: 6974 6869 6e20 6561 6368 2067 726f 7570  ithin each group
+00014450: 2e0a 2020 2020 2020 2020 2e2e 2076 6572  ..        .. ver
+00014460: 7369 6f6e 6164 6465 643a 3a20 302e 392e  sionadded:: 0.9.
+00014470: 300a 2020 2020 6f62 7365 7276 6564 203a  0.    observed :
+00014480: 2062 6f6f 6c2c 2064 6566 6175 6c74 2046   bool, default F
+00014490: 616c 7365 0a20 2020 2020 2020 2054 6869  alse.        Thi
+000144a0: 7320 6f6e 6c79 2061 7070 6c69 6573 2069  s only applies i
+000144b0: 6620 616e 7920 6f66 2074 6865 2067 726f  f any of the gro
+000144c0: 7570 6572 7320 6172 6520 4361 7465 676f  upers are Catego
+000144d0: 7269 6361 6c73 2e0a 2020 2020 2020 2020  ricals..        
+000144e0: 4966 2054 7275 653a 206f 6e6c 7920 7368  If True: only sh
+000144f0: 6f77 206f 6273 6572 7665 6420 7661 6c75  ow observed valu
+00014500: 6573 2066 6f72 2063 6174 6567 6f72 6963  es for categoric
+00014510: 616c 2067 726f 7570 6572 732e 0a20 2020  al groupers..   
+00014520: 2020 2020 2049 6620 4661 6c73 653a 2073       If False: s
+00014530: 686f 7720 616c 6c20 7661 6c75 6573 2066  how all values f
+00014540: 6f72 2063 6174 6567 6f72 6963 616c 2067  or categorical g
+00014550: 726f 7570 6572 732e 0a20 2020 2020 2020  roupers..       
+00014560: 202e 2e20 7665 7273 696f 6e61 6464 6564   .. versionadded
+00014570: 3a3a 2030 2e39 2e30 0a20 2020 2064 726f  :: 0.9.0.    dro
+00014580: 706e 6120 3a20 626f 6f6c 2c20 6465 6661  pna : bool, defa
+00014590: 756c 7420 5472 7565 0a20 2020 2020 2020  ult True.       
+000145a0: 2049 6620 5472 7565 2c20 616e 6420 6966   If True, and if
+000145b0: 2067 726f 7570 206b 6579 7320 636f 6e74   group keys cont
+000145c0: 6169 6e20 4e41 2076 616c 7565 732c 204e  ain NA values, N
+000145d0: 4120 7661 6c75 6573 0a20 2020 2020 2020  A values.       
+000145e0: 2074 6f67 6574 6865 7220 7769 7468 2072   together with r
+000145f0: 6f77 2f63 6f6c 756d 6e20 7769 6c6c 2062  ow/column will b
+00014600: 6520 6472 6f70 7065 642e 2049 6620 4661  e dropped. If Fa
+00014610: 6c73 652c 204e 410a 2020 2020 2020 2020  lse, NA.        
+00014620: 7661 6c75 6573 2077 696c 6c20 616c 736f  values will also
+00014630: 2062 6520 7472 6561 7465 6420 6173 2074   be treated as t
+00014640: 6865 206b 6579 2069 6e20 6772 6f75 7073  he key in groups
+00014650: 2e0a 2020 2020 2020 2020 5468 6973 2070  ..        This p
+00014660: 6172 616d 6574 6572 2069 7320 6e6f 7420  arameter is not 
+00014670: 7375 7070 6f72 7465 6420 666f 7220 7061  supported for pa
+00014680: 6e64 6173 203c 2031 2e31 2e30 2e0a 2020  ndas < 1.1.0..  
+00014690: 2020 2020 2020 4120 7761 726e 696e 6720        A warning 
+000146a0: 7769 6c6c 2062 6520 656d 6974 7465 6420  will be emitted 
+000146b0: 666f 7220 6561 726c 6965 7220 7061 6e64  for earlier pand
+000146c0: 6173 2076 6572 7369 6f6e 730a 2020 2020  as versions.    
+000146d0: 2020 2020 6966 2061 206e 6f6e 2d64 6566      if a non-def
+000146e0: 6175 6c74 2076 616c 7565 2069 7320 6769  ault value is gi
+000146f0: 7665 6e20 666f 7220 7468 6973 2070 6172  ven for this par
+00014700: 616d 6574 6572 2e0a 2020 2020 2020 2020  ameter..        
+00014710: 2e2e 2076 6572 7369 6f6e 6164 6465 643a  .. versionadded:
+00014720: 3a20 302e 392e 300a 0a20 2020 2052 6574  : 0.9.0..    Ret
+00014730: 7572 6e73 3a0a 2020 2020 2d2d 2d2d 2d2d  urns:.    ------
+00014740: 2d0a 2020 2020 4765 6f44 6174 6146 7261  -.    GeoDataFra
+00014750: 6d65 0a0a 2020 2020 4578 616d 706c 6573  me..    Examples
+00014760: 3a0a 2020 2020 2d2d 2d2d 2d2d 2d2d 0a20  :.    --------. 
+00014770: 2020 203e 3e3e 2066 726f 6d20 7368 6170     >>> from shap
+00014780: 656c 792e 6765 6f6d 6574 7279 2069 6d70  ely.geometry imp
+00014790: 6f72 7420 506f 696e 740a 2020 2020 3e3e  ort Point.    >>
+000147a0: 3e20 6420 3d20 7b0a 2020 2020 2e2e 2e20  > d = {.    ... 
+000147b0: 2020 2020 2263 6f6c 3122 3a20 5b22 6e61      "col1": ["na
+000147c0: 6d65 3122 2c20 226e 616d 6532 222c 2022  me1", "name2", "
+000147d0: 6e61 6d65 3122 5d2c 0a20 2020 202e 2e2e  name1"],.    ...
+000147e0: 2020 2020 2022 6765 6f6d 6574 7279 223a       "geometry":
+000147f0: 205b 506f 696e 7428 312c 2032 292c 2050   [Point(1, 2), P
+00014800: 6f69 6e74 2832 2c20 3129 2c20 506f 696e  oint(2, 1), Poin
+00014810: 7428 302c 2031 295d 2c0a 2020 2020 2e2e  t(0, 1)],.    ..
+00014820: 2e20 7d0a 2020 2020 3e3e 3e20 6764 6620  . }.    >>> gdf 
+00014830: 3d20 6765 6f70 616e 6461 732e 4765 6f44  = geopandas.GeoD
+00014840: 6174 6146 7261 6d65 2864 2c20 6372 733d  ataFrame(d, crs=
+00014850: 3433 3236 290a 2020 2020 3e3e 3e20 6764  4326).    >>> gd
+00014860: 660a 2020 2020 2020 2020 636f 6c31 2020  f.        col1  
+00014870: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+00014880: 656f 6d65 7472 790a 2020 2020 3020 206e  eometry.    0  n
+00014890: 616d 6531 2020 504f 494e 5420 2831 2e30  ame1  POINT (1.0
+000148a0: 3030 3030 2032 2e30 3030 3030 290a 2020  0000 2.00000).  
+000148b0: 2020 3120 206e 616d 6532 2020 504f 494e    1  name2  POIN
+000148c0: 5420 2832 2e30 3030 3030 2031 2e30 3030  T (2.00000 1.000
+000148d0: 3030 290a 2020 2020 3220 206e 616d 6531  00).    2  name1
+000148e0: 2020 504f 494e 5420 2830 2e30 3030 3030    POINT (0.00000
+000148f0: 2031 2e30 3030 3030 290a 2020 2020 3e3e   1.00000).    >>
+00014900: 3e20 6469 7373 6f6c 7665 6420 3d20 6764  > dissolved = gd
+00014910: 662e 6469 7373 6f6c 7665 2827 636f 6c31  f.dissolve('col1
+00014920: 2729 0a20 2020 203e 3e3e 2064 6973 736f  ').    >>> disso
+00014930: 6c76 6564 2020 2320 646f 6374 6573 743a  lved  # doctest:
+00014940: 202b 534b 4950 0a20 2020 2020 2020 2020   +SKIP.         
+00014950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014970: 2020 2020 2020 2067 656f 6d65 7472 790a         geometry.
+00014980: 2020 2020 636f 6c31 0a20 2020 206e 616d      col1.    nam
+00014990: 6531 2020 4d55 4c54 4950 4f49 4e54 2028  e1  MULTIPOINT (
+000149a0: 302e 3030 3030 3020 312e 3030 3030 302c  0.00000 1.00000,
+000149b0: 2031 2e30 3030 3030 2032 2e30 3030 3030   1.00000 2.00000
+000149c0: 290a 2020 2020 6e61 6d65 3220 2020 2020  ).    name2     
+000149d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000149e0: 2020 2050 4f49 4e54 2028 322e 3030 3030     POINT (2.0000
+000149f0: 3020 312e 3030 3030 3029 0a0a 2020 2020  0 1.00000)..    
+00014a00: 5365 6520 416c 736f 3a0a 2020 2020 2d2d  See Also:.    --
+00014a10: 2d2d 2d2d 2d2d 0a20 2020 2047 656f 4461  ------.    GeoDa
+00014a20: 7461 4672 616d 652e 6578 706c 6f64 6520  taFrame.explode 
+00014a30: 3a20 6578 706c 6f64 6520 6d75 6c74 692d  : explode multi-
+00014a40: 7061 7274 2067 656f 6d65 7472 6965 7320  part geometries 
+00014a50: 696e 746f 2073 696e 676c 6520 6765 6f6d  into single geom
+00014a60: 6574 7269 6573 0a20 2020 2022 2222 0a20  etries.    """. 
+00014a70: 2020 2069 6620 6279 2069 7320 4e6f 6e65     if by is None
+00014a80: 2061 6e64 206c 6576 656c 2069 7320 4e6f   and level is No
+00014a90: 6e65 3a0a 2020 2020 2020 2020 6279 5f6c  ne:.        by_l
+00014aa0: 6f63 616c 203d 206e 702e 7a65 726f 7328  ocal = np.zeros(
+00014ab0: 6c65 6e28 6466 292c 2064 7479 7065 3d22  len(df), dtype="
+00014ac0: 696e 7436 3422 290a 2020 2020 656c 7365  int64").    else
+00014ad0: 3a0a 2020 2020 2020 2020 6279 5f6c 6f63  :.        by_loc
+00014ae0: 616c 203d 2062 790a 0a20 2020 2067 726f  al = by..    gro
+00014af0: 7570 6279 5f6b 7761 7267 7320 3d20 7b0a  upby_kwargs = {.
+00014b00: 2020 2020 2020 2020 2262 7922 3a20 6279          "by": by
+00014b10: 5f6c 6f63 616c 2c0a 2020 2020 2020 2020  _local,.        
+00014b20: 226c 6576 656c 223a 206c 6576 656c 2c0a  "level": level,.
+00014b30: 2020 2020 2020 2020 2273 6f72 7422 3a20          "sort": 
+00014b40: 736f 7274 2c0a 2020 2020 2020 2020 226f  sort,.        "o
+00014b50: 6273 6572 7665 6422 3a20 6f62 7365 7276  bserved": observ
+00014b60: 6564 2c0a 2020 2020 2020 2020 2264 726f  ed,.        "dro
+00014b70: 706e 6122 3a20 6472 6f70 6e61 2c0a 2020  pna": dropna,.  
+00014b80: 2020 7d0a 2020 2020 2222 220a 2020 2020    }.    """.    
+00014b90: 6966 206e 6f74 2063 6f6d 7061 742e 5041  if not compat.PA
+00014ba0: 4e44 4153 5f47 455f 3131 3a0a 2020 2020  NDAS_GE_11:.    
+00014bb0: 2020 2020 6772 6f75 7062 795f 6b77 6172      groupby_kwar
+00014bc0: 6773 2e70 6f70 2822 6472 6f70 6e61 2229  gs.pop("dropna")
+00014bd0: 0a0a 2020 2020 2020 2020 6966 206e 6f74  ..        if not
+00014be0: 2064 726f 706e 613a 2020 2320 4966 2074   dropna:  # If t
+00014bf0: 6865 7920 7061 7373 6564 2061 206e 6f6e  hey passed a non
+00014c00: 2d64 6566 6175 6c74 2064 726f 706e 6120  -default dropna 
+00014c10: 7661 6c75 650a 2020 2020 2020 2020 2020  value.          
+00014c20: 2020 7761 726e 696e 6773 2e77 6172 6e28    warnings.warn(
+00014c30: 2264 726f 706e 6120 6b77 6172 6720 6973  "dropna kwarg is
+00014c40: 206e 6f74 2073 7570 706f 7274 6564 2066   not supported f
+00014c50: 6f72 2070 616e 6461 7320 3c20 312e 312e  or pandas < 1.1.
+00014c60: 3022 290a 2020 2020 2222 220a 0a20 2020  0").    """..   
+00014c70: 2023 2050 726f 6365 7373 206e 6f6e 2d73   # Process non-s
+00014c80: 7061 7469 616c 2063 6f6d 706f 6e65 6e74  patial component
+00014c90: 0a20 2020 2064 6174 6120 3d20 7064 2e44  .    data = pd.D
+00014ca0: 6174 6146 7261 6d65 2864 662e 6472 6f70  ataFrame(df.drop
+00014cb0: 2863 6f6c 756d 6e73 3d64 662e 6765 6f6d  (columns=df.geom
+00014cc0: 6574 7279 2e6e 616d 6529 290a 0a20 2020  etry.name))..   
+00014cd0: 2069 6620 6167 6766 756e 6320 6973 206e   if aggfunc is n
+00014ce0: 6f74 204e 6f6e 6520 616e 6420 6973 696e  ot None and isin
+00014cf0: 7374 616e 6365 2861 6767 6675 6e63 2c20  stance(aggfunc, 
+00014d00: 6469 6374 2920 616e 6420 2274 6f5f 6a73  dict) and "to_js
+00014d10: 6f6e 2220 696e 2061 6767 6675 6e63 3a0a  on" in aggfunc:.
+00014d20: 2020 2020 2020 2020 6167 675f 636f 6c75          agg_colu
+00014d30: 6d6e 7320 3d20 6c69 7374 2873 6574 2861  mns = list(set(a
+00014d40: 6767 6675 6e63 5b22 746f 5f6a 736f 6e22  ggfunc["to_json"
+00014d50: 5d29 290a 2020 2020 2020 2020 6167 675f  ])).        agg_
+00014d60: 6461 7461 203d 2028 0a20 2020 2020 2020  data = (.       
+00014d70: 2020 2020 2064 6174 612e 6772 6f75 7062       data.groupb
+00014d80: 7928 2a2a 6772 6f75 7062 795f 6b77 6172  y(**groupby_kwar
+00014d90: 6773 290a 2020 2020 2020 2020 2020 2020  gs).            
+00014da0: 2e61 7070 6c79 286c 616d 6264 6120 673a  .apply(lambda g:
+00014db0: 2067 5b61 6767 5f63 6f6c 756d 6e73 5d2e   g[agg_columns].
+00014dc0: 746f 5f6a 736f 6e28 6f72 6965 6e74 3d22  to_json(orient="
+00014dd0: 7265 636f 7264 7322 2929 0a20 2020 2020  records")).     
+00014de0: 2020 2020 2020 202e 746f 5f66 7261 6d65         .to_frame
+00014df0: 286e 616d 653d 225f 5f44 4953 534f 4c56  (name="__DISSOLV
+00014e00: 455f 544f 4a53 4f4e 2229 0a20 2020 2020  E_TOJSON").     
+00014e10: 2020 2029 0a20 2020 2065 6c69 6620 6973     ).    elif is
+00014e20: 696e 7374 616e 6365 2861 6767 6675 6e63  instance(aggfunc
+00014e30: 2c20 7374 7229 2061 6e64 2061 6767 6675  , str) and aggfu
+00014e40: 6e63 203d 3d20 226d 6572 6765 5f6a 736f  nc == "merge_jso
+00014e50: 6e5f 6c69 7374 7322 3a0a 2020 2020 2020  n_lists":.      
+00014e60: 2020 2320 4d65 7267 6520 616e 6420 666c    # Merge and fl
+00014e70: 6174 7465 6e20 7468 6520 6a73 6f6e 206c  atten the json l
+00014e80: 6973 7473 2069 6e20 7468 6520 6772 6f75  ists in the grou
+00014e90: 7073 0a20 2020 2020 2020 2064 6566 2067  ps.        def g
+00014ea0: 726f 7570 5f66 6c61 7474 656e 5f6a 736f  roup_flatten_jso
+00014eb0: 6e5f 6c69 7374 2867 293a 0a20 2020 2020  n_list(g):.     
+00014ec0: 2020 2020 2020 2023 2045 7661 6c75 6174         # Evaluat
+00014ed0: 6520 616c 6c20 6772 6f75 7065 6420 726f  e all grouped ro
+00014ee0: 7773 2074 6f20 6a73 6f6e 206f 626a 6563  ws to json objec
+00014ef0: 7473 2e20 5468 6973 2072 6573 756c 7473  ts. This results
+00014f00: 2069 6e20 6120 6c69 7374 206f 660a 2020   in a list of.  
+00014f10: 2020 2020 2020 2020 2020 2320 6c69 7374            # list
+00014f20: 7320 6f66 206a 736f 6e20 6f62 6a65 6374  s of json object
+00014f30: 732e 0a20 2020 2020 2020 2020 2020 206a  s..            j
+00014f40: 736f 6e5f 6e65 7374 6564 5f6c 6973 7473  son_nested_lists
+00014f50: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
+00014f60: 2020 2020 206a 736f 6e2e 6c6f 6164 7328       json.loads(
+00014f70: 6a73 6f6e 5f76 616c 7565 7329 2066 6f72  json_values) for
+00014f80: 206a 736f 6e5f 7661 6c75 6573 2069 6e20   json_values in 
+00014f90: 675b 225f 5f44 4953 534f 4c56 455f 544f  g["__DISSOLVE_TO
+00014fa0: 4a53 4f4e 225d 0a20 2020 2020 2020 2020  JSON"].         
+00014fb0: 2020 205d 0a0a 2020 2020 2020 2020 2020     ]..          
+00014fc0: 2020 2320 4578 7472 6163 7420 7468 6520    # Extract the 
+00014fd0: 726f 7773 2066 726f 6d20 7468 6520 6e65  rows from the ne
+00014fe0: 7374 6564 206c 6973 7473 202b 2070 7574  sted lists + put
+00014ff0: 2069 6e20 6120 666c 6174 206c 6973 7420   in a flat list 
+00015000: 6173 2073 7472 696e 6773 0a20 2020 2020  as strings.     
+00015010: 2020 2020 2020 206a 736f 6e73 7472 5f66         jsonstr_f
+00015020: 6c61 7420 3d20 5b0a 2020 2020 2020 2020  lat = [.        
+00015030: 2020 2020 2020 2020 6a73 6f6e 2e64 756d          json.dum
+00015040: 7073 286a 736f 6e5f 7661 6c75 6529 0a20  ps(json_value). 
+00015050: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00015060: 6f72 206a 736f 6e5f 7661 6c75 6573 2069  or json_values i
+00015070: 6e20 6a73 6f6e 5f6e 6573 7465 645f 6c69  n json_nested_li
+00015080: 7374 730a 2020 2020 2020 2020 2020 2020  sts.            
+00015090: 2020 2020 666f 7220 6a73 6f6e 5f76 616c      for json_val
+000150a0: 7565 2069 6e20 6a73 6f6e 5f76 616c 7565  ue in json_value
+000150b0: 730a 2020 2020 2020 2020 2020 2020 5d0a  s.            ].
+000150c0: 0a20 2020 2020 2020 2020 2020 2023 2052  .            # R
+000150d0: 656d 6f76 6520 6475 706c 6963 6174 6573  emove duplicates
+000150e0: 0a20 2020 2020 2020 2020 2020 206a 736f  .            jso
+000150f0: 6e73 7374 725f 6469 7374 696e 6374 203d  nsstr_distinct =
+00015100: 2073 6574 286a 736f 6e73 7472 5f66 6c61   set(jsonstr_fla
+00015110: 7429 0a0a 2020 2020 2020 2020 2020 2020  t)..            
+00015120: 2320 436f 6e76 6572 7420 7468 6520 6461  # Convert the da
+00015130: 7461 2061 6761 696e 2074 6f20 6120 6c69  ta again to a li
+00015140: 7374 206f 6620 6a73 6f6e 206f 626a 6563  st of json objec
+00015150: 7473 0a20 2020 2020 2020 2020 2020 206a  ts.            j
+00015160: 736f 6e5f 6469 7374 696e 6374 203d 205b  son_distinct = [
+00015170: 6a73 6f6e 2e6c 6f61 6473 286a 736f 6e5f  json.loads(json_
+00015180: 7661 6c75 6529 2066 6f72 206a 736f 6e5f  value) for json_
+00015190: 7661 6c75 6520 696e 206a 736f 6e73 7374  value in jsonsst
+000151a0: 725f 6469 7374 696e 6374 5d0a 0a20 2020  r_distinct]..   
+000151b0: 2020 2020 2020 2020 2023 2052 6574 7572           # Retur
+000151c0: 6e20 6173 206a 736f 6e20 7374 7269 6e67  n as json string
+000151d0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+000151e0: 7572 6e20 6a73 6f6e 2e64 756d 7073 286a  urn json.dumps(j
+000151f0: 736f 6e5f 6469 7374 696e 6374 290a 0a20  son_distinct).. 
+00015200: 2020 2020 2020 2061 6767 5f64 6174 6120         agg_data 
+00015210: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+00015220: 6461 7461 2e67 726f 7570 6279 282a 2a67  data.groupby(**g
+00015230: 726f 7570 6279 5f6b 7761 7267 7329 0a20  roupby_kwargs). 
+00015240: 2020 2020 2020 2020 2020 202e 6170 706c             .appl
+00015250: 7928 6c61 6d62 6461 2067 3a20 6772 6f75  y(lambda g: grou
+00015260: 705f 666c 6174 7465 6e5f 6a73 6f6e 5f6c  p_flatten_json_l
+00015270: 6973 7428 6729 290a 2020 2020 2020 2020  ist(g)).        
+00015280: 2020 2020 2e74 6f5f 6672 616d 6528 6e61      .to_frame(na
+00015290: 6d65 3d22 5f5f 4449 5353 4f4c 5645 5f54  me="__DISSOLVE_T
+000152a0: 4f4a 534f 4e22 290a 2020 2020 2020 2020  OJSON").        
+000152b0: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
+000152c0: 2020 2020 6167 675f 6461 7461 203d 2064      agg_data = d
+000152d0: 6174 612e 6772 6f75 7062 7928 2a2a 6772  ata.groupby(**gr
+000152e0: 6f75 7062 795f 6b77 6172 6773 292e 6167  oupby_kwargs).ag
+000152f0: 6728 6167 6766 756e 6329 2020 2320 7479  g(aggfunc)  # ty
+00015300: 7065 3a20 6967 6e6f 7265 5b61 7267 2d74  pe: ignore[arg-t
+00015310: 7970 655d 0a20 2020 2020 2020 2023 2043  ype].        # C
+00015320: 6865 636b 2069 6620 616c 6c20 636f 6c75  heck if all colu
+00015330: 6d6e 7320 7765 7265 2070 726f 7065 726c  mns were properl
+00015340: 7920 6167 6772 6567 6174 6564 0a20 2020  y aggregated.   
+00015350: 2020 2020 2061 7373 6572 7420 6279 5f6c       assert by_l
+00015360: 6f63 616c 2069 7320 6e6f 7420 4e6f 6e65  ocal is not None
+00015370: 0a20 2020 2020 2020 2063 6f6c 756d 6e73  .        columns
+00015380: 5f74 6f5f 6167 6720 3d20 5b63 6f6c 756d  _to_agg = [colum
+00015390: 6e20 666f 7220 636f 6c75 6d6e 2069 6e20  n for column in 
+000153a0: 6461 7461 2e63 6f6c 756d 6e73 2069 6620  data.columns if 
+000153b0: 636f 6c75 6d6e 206e 6f74 2069 6e20 6279  column not in by
+000153c0: 5f6c 6f63 616c 5d0a 2020 2020 2020 2020  _local].        
+000153d0: 6966 206c 656e 2863 6f6c 756d 6e73 5f74  if len(columns_t
+000153e0: 6f5f 6167 6729 2021 3d20 6c65 6e28 6167  o_agg) != len(ag
+000153f0: 675f 6461 7461 2e63 6f6c 756d 6e73 293a  g_data.columns):
+00015400: 0a20 2020 2020 2020 2020 2020 2064 726f  .            dro
+00015410: 7070 6564 5f63 6f6c 756d 6e73 203d 205b  pped_columns = [
+00015420: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015430: 2063 6f6c 756d 6e20 666f 7220 636f 6c75   column for colu
+00015440: 6d6e 2069 6e20 636f 6c75 6d6e 735f 746f  mn in columns_to
+00015450: 5f61 6767 2069 6620 636f 6c75 6d6e 206e  _agg if column n
+00015460: 6f74 2069 6e20 6167 675f 6461 7461 2e63  ot in agg_data.c
+00015470: 6f6c 756d 6e73 0a20 2020 2020 2020 2020  olumns.         
+00015480: 2020 205d 0a20 2020 2020 2020 2020 2020     ].           
+00015490: 2072 6169 7365 2045 7863 6570 7469 6f6e   raise Exception
+000154a0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+000154b0: 2020 6622 436f 6c75 6d6e 2873 2920 7b64    f"Column(s) {d
+000154c0: 726f 7070 6564 5f63 6f6c 756d 6e73 7d20  ropped_columns} 
+000154d0: 6172 6520 6e6f 7420 7375 7070 6f72 7465  are not supporte
+000154e0: 6420 666f 7220 6167 6772 6567 6174 696f  d for aggregatio
+000154f0: 6e2c 2073 746f 7022 0a20 2020 2020 2020  n, stop".       
+00015500: 2020 2020 2029 0a0a 2020 2020 2320 5072       )..    # Pr
+00015510: 6f63 6573 7320 7370 6174 6961 6c20 636f  ocess spatial co
+00015520: 6d70 6f6e 656e 740a 2020 2020 6465 6620  mponent.    def 
+00015530: 6d65 7267 655f 6765 6f6d 6574 7269 6573  merge_geometries
+00015540: 2862 6c6f 636b 293a 0a20 2020 2020 2020  (block):.       
+00015550: 206d 6572 6765 645f 6765 6f6d 203d 2062   merged_geom = b
+00015560: 6c6f 636b 2e75 6e61 7279 5f75 6e69 6f6e  lock.unary_union
+00015570: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00015580: 6d65 7267 6564 5f67 656f 6d0a 0a20 2020  merged_geom..   
+00015590: 2067 203d 2064 662e 6772 6f75 7062 7928   g = df.groupby(
+000155a0: 6772 6f75 705f 6b65 7973 3d46 616c 7365  group_keys=False
+000155b0: 2c20 2a2a 6772 6f75 7062 795f 6b77 6172  , **groupby_kwar
+000155c0: 6773 295b 6466 2e67 656f 6d65 7472 792e  gs)[df.geometry.
+000155d0: 6e61 6d65 5d2e 6167 6728 0a20 2020 2020  name].agg(.     
+000155e0: 2020 206d 6572 6765 5f67 656f 6d65 7472     merge_geometr
+000155f0: 6965 730a 2020 2020 290a 0a20 2020 2023  ies.    )..    #
+00015600: 2041 6767 7265 6761 7465 0a20 2020 2061   Aggregate.    a
+00015610: 6767 7265 6761 7465 645f 6765 6f6d 6574  ggregated_geomet
+00015620: 7279 203d 2067 7064 2e47 656f 4461 7461  ry = gpd.GeoData
+00015630: 4672 616d 6528 0a20 2020 2020 2020 2064  Frame(.        d
+00015640: 6174 613d 672c 2067 656f 6d65 7472 793d  ata=g, geometry=
+00015650: 6466 2e67 656f 6d65 7472 792e 6e61 6d65  df.geometry.name
+00015660: 2c20 6372 733d 6466 2e63 7273 0a20 2020  , crs=df.crs.   
+00015670: 2029 0a20 2020 2023 2052 6563 6f6d 6269   ).    # Recombi
+00015680: 6e65 0a20 2020 2061 6767 7265 6761 7465  ne.    aggregate
+00015690: 6420 3d20 6167 6772 6567 6174 6564 5f67  d = aggregated_g
+000156a0: 656f 6d65 7472 792e 6a6f 696e 2861 6767  eometry.join(agg
+000156b0: 5f64 6174 6129 0a0a 2020 2020 2320 5265  _data)..    # Re
+000156c0: 7365 7420 6966 2072 6571 7565 7374 6564  set if requested
+000156d0: 0a20 2020 2069 6620 6e6f 7420 6173 5f69  .    if not as_i
+000156e0: 6e64 6578 3a0a 2020 2020 2020 2020 6167  ndex:.        ag
+000156f0: 6772 6567 6174 6564 203d 2061 6767 7265  gregated = aggre
+00015700: 6761 7465 642e 7265 7365 745f 696e 6465  gated.reset_inde
+00015710: 7828 290a 0a20 2020 2023 204d 616b 6520  x()..    # Make 
+00015720: 7375 7265 206f 7574 7075 7420 7479 7065  sure output type
+00015730: 7320 6f66 2067 726f 7570 6564 2063 6f6c  s of grouped col
+00015740: 756d 6e73 2061 7265 2074 6865 2073 616d  umns are the sam
+00015750: 6520 6173 2069 6e70 7574 2074 7970 6573  e as input types
+00015760: 2e0a 2020 2020 2320 452e 672e 206f 626a  ..    # E.g. obj
+00015770: 6563 7420 636f 6c75 6d6e 7320 6265 636f  ect columns beco
+00015780: 6d65 2066 6c6f 6174 2069 6620 616c 6c20  me float if all 
+00015790: 7661 6c75 6573 2061 7265 204e 6f6e 652e  values are None.
+000157a0: 0a20 2020 2069 6620 6279 2069 7320 6e6f  .    if by is no
+000157b0: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
+000157c0: 6966 2069 7369 6e73 7461 6e63 6528 6279  if isinstance(by
+000157d0: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
+000157e0: 2020 2020 6966 2062 7920 696e 2061 6767      if by in agg
+000157f0: 7265 6761 7465 642e 636f 6c75 6d6e 7320  regated.columns 
+00015800: 616e 6420 6466 5b62 795d 2e64 7479 7065  and df[by].dtype
+00015810: 2021 3d20 6167 6772 6567 6174 6564 5b62   != aggregated[b
+00015820: 795d 2e64 7479 7065 3a0a 2020 2020 2020  y].dtype:.      
+00015830: 2020 2020 2020 2020 2020 6167 6772 6567            aggreg
+00015840: 6174 6564 5b62 795d 203d 2061 6767 7265  ated[by] = aggre
+00015850: 6761 7465 645b 6279 5d2e 6173 7479 7065  gated[by].astype
+00015860: 2864 665b 6279 5d2e 6474 7970 6529 0a20  (df[by].dtype). 
+00015870: 2020 2020 2020 2065 6c69 6620 6973 696e         elif isin
+00015880: 7374 616e 6365 2862 792c 2049 7465 7261  stance(by, Itera
+00015890: 626c 6529 3a0a 2020 2020 2020 2020 2020  ble):.          
+000158a0: 2020 666f 7220 636f 6c20 696e 2062 793a    for col in by:
+000158b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000158c0: 2069 6620 636f 6c20 696e 2061 6767 7265   if col in aggre
+000158d0: 6761 7465 642e 636f 6c75 6d6e 7320 616e  gated.columns an
+000158e0: 6420 6466 5b63 6f6c 5d2e 6474 7970 6520  d df[col].dtype 
+000158f0: 213d 2061 6767 7265 6761 7465 645b 636f  != aggregated[co
+00015900: 6c5d 2e64 7479 7065 3a0a 2020 2020 2020  l].dtype:.      
+00015910: 2020 2020 2020 2020 2020 2020 2020 6167                ag
+00015920: 6772 6567 6174 6564 5b63 6f6c 5d20 3d20  gregated[col] = 
+00015930: 6167 6772 6567 6174 6564 5b63 6f6c 5d2e  aggregated[col].
+00015940: 6173 7479 7065 2864 665b 636f 6c5d 2e64  astype(df[col].d
+00015950: 7479 7065 290a 0a20 2020 2061 7373 6572  type)..    asser
+00015960: 7420 6973 696e 7374 616e 6365 2861 6767  t isinstance(agg
+00015970: 7265 6761 7465 642c 2067 7064 2e47 656f  regated, gpd.Geo
+00015980: 4461 7461 4672 616d 6529 0a20 2020 2072  DataFrame).    r
+00015990: 6574 7572 6e20 6167 6772 6567 6174 6564  eturn aggregated
+000159a0: 0a0a 0a64 6566 205f 6164 645f 6f72 6465  ...def _add_orde
+000159b0: 7262 795f 636f 6c75 6d6e 2870 6174 683a  rby_column(path:
+000159c0: 2050 6174 682c 206c 6179 6572 3a20 7374   Path, layer: st
+000159d0: 722c 206e 616d 653a 2073 7472 293a 0a20  r, name: str):. 
+000159e0: 2020 2023 2050 7265 7061 7265 2074 6865     # Prepare the
+000159f0: 2065 7870 7265 7373 696f 6e20 746f 2063   expression to c
+00015a00: 616c 6375 6c61 7465 2074 6865 206f 7264  alculate the ord
+00015a10: 6572 6279 2063 6f6c 756d 6e2e 0a20 2020  erby column..   
+00015a20: 2023 2049 6e20 6120 7370 6174 6961 6c20   # In a spatial 
+00015a30: 6669 6c65 2c20 6120 7370 6174 6961 6c20  file, a spatial 
+00015a40: 6f72 6465 7220 7769 6c6c 206d 616b 6520  order will make 
+00015a50: 6c61 7465 7220 7573 6520 6d6f 7265 2065  later use more e
+00015a60: 6666 6963 69c3 ab6e 742c 0a20 2020 2023  ffici..nt,.    #
+00015a70: 2073 6f20 7573 6520 6120 6765 6f68 6173   so use a geohas
+00015a80: 682e 0a20 2020 206c 6179 6572 696e 666f  h..    layerinfo
+00015a90: 203d 2067 666f 2e67 6574 5f6c 6179 6572   = gfo.get_layer
+00015aa0: 696e 666f 2870 6174 6829 0a20 2020 2069  info(path).    i
+00015ab0: 6620 6c61 7965 7269 6e66 6f2e 6372 7320  f layerinfo.crs 
+00015ac0: 6973 206e 6f74 204e 6f6e 6520 616e 6420  is not None and 
+00015ad0: 6c61 7965 7269 6e66 6f2e 6372 732e 6973  layerinfo.crs.is
+00015ae0: 5f67 656f 6772 6170 6869 633a 0a20 2020  _geographic:.   
+00015af0: 2020 2020 2023 2049 6620 7468 6520 636f       # If the co
+00015b00: 6f72 6469 6e61 7465 7320 6172 6520 6765  ordinates are ge
+00015b10: 6f67 7261 7068 6963 2028 696e 206c 6174  ographic (in lat
+00015b20: 2f6c 6f6e 2064 6567 7265 6573 292c 206f  /lon degrees), o
+00015b30: 6b0a 2020 2020 2020 2020 6578 7072 6573  k.        expres
+00015b40: 7369 6f6e 203d 2066 2253 545f 4765 6f48  sion = f"ST_GeoH
+00015b50: 6173 6828 7b6c 6179 6572 696e 666f 2e67  ash({layerinfo.g
+00015b60: 656f 6d65 7472 7963 6f6c 756d 6e7d 2c20  eometrycolumn}, 
+00015b70: 3130 2922 0a20 2020 2065 6c73 653a 0a20  10)".    else:. 
+00015b80: 2020 2020 2020 2023 2049 6620 7468 6579         # If they
+00015b90: 2061 7265 206e 6f74 2067 656f 6772 6170   are not geograp
+00015ba0: 6869 6320 2869 6e20 6c61 742f 6c6f 6e20  hic (in lat/lon 
+00015bb0: 6465 6772 6565 7329 2c20 7468 6579 206e  degrees), they n
+00015bc0: 6565 6420 746f 2062 650a 2020 2020 2020  eed to be.      
+00015bd0: 2020 2320 636f 6e76 6572 7465 6420 746f    # converted to
+00015be0: 207e 2064 6567 7265 6573 2074 6f20 6265   ~ degrees to be
+00015bf0: 2061 626c 6520 746f 2063 616c 6375 6c61   able to calcula
+00015c00: 7465 2061 2067 656f 6861 7368 2e0a 0a20  te a geohash... 
+00015c10: 2020 2020 2020 2023 2050 726f 7065 726c         # Properl
+00015c20: 7920 6361 6c63 756c 6174 696e 6720 7468  y calculating th
+00015c30: 6520 7472 616e 7366 6f72 6d61 7469 6f6e  e transformation
+00015c40: 2074 6f20 6567 2e20 5747 5320 6973 2074   to eg. WGS is t
+00015c50: 6572 7269 626c 7920 736c 6f77 2e2e 2e0a  erribly slow....
+00015c60: 2020 2020 2020 2020 2320 6578 7072 6573          # expres
+00015c70: 7369 6f6e 203d 2066 2222 2253 545f 4765  sion = f"""ST_Ge
+00015c80: 6f48 6173 6828 5354 5f54 7261 6e73 666f  oHash(ST_Transfo
+00015c90: 726d 284d 616b 6550 6f69 6e74 280a 2020  rm(MakePoint(.  
+00015ca0: 2020 2020 2020 2320 2020 2020 2020 284d        #       (M
+00015cb0: 6272 4d61 7858 2867 656f 6d29 2b4d 6272  brMaxX(geom)+Mbr
+00015cc0: 4d69 6e58 2867 656f 6d29 292f 322c 0a20  MinX(geom))/2,. 
+00015cd0: 2020 2020 2020 2023 2020 2020 2020 2028         #       (
+00015ce0: 4d62 724d 696e 5928 6765 6f6d 292b 4d62  MbrMinY(geom)+Mb
+00015cf0: 724d 6178 5928 6765 6f6d 2929 2f32 2c20  rMaxY(geom))/2, 
+00015d00: 5354 5f53 5249 4428 6765 6f6d 2929 2c20  ST_SRID(geom)), 
+00015d10: 3433 3236 292c 2031 3029 2222 220a 2020  4326), 10)""".  
+00015d20: 2020 2020 2020 2320 536f 2c20 646f 2073        # So, do s
+00015d30: 6f6d 6574 6869 6e67 2065 6c73 6520 7468  omething else th
+00015d40: 6174 2773 2066 6173 7465 7220 616e 6420  at's faster and 
+00015d50: 7374 696c 6c20 6769 7665 7320 6120 676f  still gives a go
+00015d60: 6f64 0a20 2020 2020 2020 2023 2067 656f  od.        # geo
+00015d70: 6772 6170 6869 6320 636c 7573 7465 7269  graphic clusteri
+00015d80: 6e67 2e0a 2020 2020 2020 2020 746f 5f67  ng..        to_g
+00015d90: 656f 6772 6170 6869 635f 6661 6374 6f72  eographic_factor
+00015da0: 5f61 7070 726f 7820 3d20 3930 202f 206d  _approx = 90 / m
+00015db0: 6178 286c 6179 6572 696e 666f 2e74 6f74  ax(layerinfo.tot
+00015dc0: 616c 5f62 6f75 6e64 7329 0a20 2020 2020  al_bounds).     
+00015dd0: 2020 2065 7870 7265 7373 696f 6e20 3d20     expression = 
+00015de0: 6622 2222 5354 5f47 656f 4861 7368 284d  f"""ST_GeoHash(M
+00015df0: 616b 6550 6f69 6e74 280a 2020 2020 2020  akePoint(.      
+00015e00: 2020 2020 2020 2020 2020 2828 4d62 724d            ((MbrM
+00015e10: 6178 5828 7b6c 6179 6572 696e 666f 2e67  axX({layerinfo.g
+00015e20: 656f 6d65 7472 7963 6f6c 756d 6e7d 290a  eometrycolumn}).
+00015e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015e40: 2020 2b4d 6272 4d69 6e58 287b 6c61 7965    +MbrMinX({laye
+00015e50: 7269 6e66 6f2e 6765 6f6d 6574 7279 636f  rinfo.geometryco
+00015e60: 6c75 6d6e 7d29 292f 320a 2020 2020 2020  lumn}))/2.      
+00015e70: 2020 2020 2020 2020 2020 292a 7b74 6f5f            )*{to_
+00015e80: 6765 6f67 7261 7068 6963 5f66 6163 746f  geographic_facto
+00015e90: 725f 6170 7072 6f78 7d2c 0a20 2020 2020  r_approx},.     
+00015ea0: 2020 2020 2020 2020 2020 2028 284d 6272             ((Mbr
+00015eb0: 4d69 6e59 287b 6c61 7965 7269 6e66 6f2e  MinY({layerinfo.
+00015ec0: 6765 6f6d 6574 7279 636f 6c75 6d6e 7d29  geometrycolumn})
+00015ed0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015ee0: 2020 202b 4d62 724d 6178 5928 7b6c 6179     +MbrMaxY({lay
+00015ef0: 6572 696e 666f 2e67 656f 6d65 7472 7963  erinfo.geometryc
+00015f00: 6f6c 756d 6e7d 2929 2f32 0a20 2020 2020  olumn}))/2.     
+00015f10: 2020 2020 2020 2020 2020 2029 2a7b 746f             )*{to
+00015f20: 5f67 656f 6772 6170 6869 635f 6661 6374  _geographic_fact
+00015f30: 6f72 5f61 7070 726f 787d 2c20 3433 3236  or_approx}, 4326
+00015f40: 292c 2031 3029 2222 220a 0a20 2020 2023  ), 10)"""..    #
+00015f50: 204e 6f77 2077 6520 6361 6e20 6163 7475   Now we can actu
+00015f60: 616c 6c79 2061 6464 2074 6865 2063 6f6c  ally add the col
+00015f70: 756d 6e2e 0a20 2020 2067 666f 2e61 6464  umn..    gfo.add
+00015f80: 5f63 6f6c 756d 6e28 7061 7468 3d70 6174  _column(path=pat
+00015f90: 682c 206e 616d 653d 6e61 6d65 2c20 7479  h, name=name, ty
+00015fa0: 7065 3d67 666f 2e44 6174 6154 7970 652e  pe=gfo.DataType.
+00015fb0: 5445 5854 2c20 6578 7072 6573 7369 6f6e  TEXT, expression
+00015fc0: 3d65 7870 7265 7373 696f 6e29 0a20 2020  =expression).   
+00015fd0: 2073 716c 6974 655f 7374 6d74 203d 2066   sqlite_stmt = f
+00015fe0: 2743 5245 4154 4520 494e 4445 5820 7b6e  'CREATE INDEX {n
+00015ff0: 616d 657d 5f69 6478 204f 4e20 227b 6c61  ame}_idx ON "{la
+00016000: 7965 727d 2228 7b6e 616d 657d 2927 0a20  yer}"({name})'. 
+00016010: 2020 2067 666f 2e65 7865 6375 7465 5f73     gfo.execute_s
+00016020: 716c 2870 6174 683d 7061 7468 2c20 7371  ql(path=path, sq
+00016030: 6c5f 7374 6d74 3d73 716c 6974 655f 7374  l_stmt=sqlite_st
+00016040: 6d74 290a                                mt).
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_geoops_ogr.py` & `geofileops-0.8.2/geofileops/util/_geoops_ogr.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,167 +1,167 @@
-from datetime import datetime
-import logging
-from pathlib import Path
-from typing import List, Literal, Optional, Tuple, Union
-
-from pygeoops import GeometryType
-from shapely import wkt
-
-import geofileops as gfo
-from geofileops.util import _ogr_util
-
-logger = logging.getLogger(__name__)
-
-
-def clip_by_geometry(
-    input_path: Path,
-    output_path: Path,
-    clip_geometry: Union[Tuple[float, float, float, float], str],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    spatial_filter = None
-    if isinstance(clip_geometry, str):
-        geom = wkt.loads(clip_geometry)
-        spatial_filter = tuple(geom.bounds)
-
-    options = {"LAYER_CREATION.SPATIAL_INDEX": True}
-    _run_ogr(
-        operation="clip_by_geometry",
-        input_path=input_path,
-        output_path=output_path,
-        spatial_filter=spatial_filter,  # type: ignore[arg-type]
-        clip_geometry=clip_geometry,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        options=options,
-        force=force,
-    )
-
-
-def export_by_bounds(
-    input_path: Path,
-    output_path: Path,
-    bounds: Tuple[float, float, float, float],
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    options = {"LAYER_CREATION.SPATIAL_INDEX": True}
-    _run_ogr(
-        operation="export_by_bounds",
-        input_path=input_path,
-        output_path=output_path,
-        spatial_filter=bounds,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        options=options,
-        force=force,
-    )
-
-
-def warp(
-    input_path: Path,
-    output_path: Path,
-    gcps: List[Tuple[float, float, float, float, Optional[float]]],
-    algorithm: str = "polynomial",
-    order: Optional[int] = None,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force: bool = False,
-):
-    warp = {
-        "gcps": gcps,
-        "algorithm": algorithm,
-        "order": order,
-    }
-
-    _run_ogr(
-        operation="warp",
-        input_path=input_path,
-        output_path=output_path,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        warp=warp,
-        force=force,
-    )
-
-
-def _run_ogr(
-    operation: str,
-    input_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    input_srs: Union[int, str, None] = None,
-    output_srs: Union[int, str, None] = None,
-    reproject: bool = False,
-    spatial_filter: Optional[Tuple[float, float, float, float]] = None,
-    clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
-    sql_stmt: Optional[str] = None,
-    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
-    transaction_size: int = 65536,
-    append: bool = False,
-    update: bool = False,
-    explodecollections: bool = False,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    options: dict = {},
-    columns: Optional[List[str]] = None,
-    warp: Optional[dict] = None,
-    force: bool = False,
-) -> bool:
-    # Init
-    logger = logging.getLogger(f"geofileops.{operation}")
-    start_time = datetime.now()
-    if input_layer is None:
-        input_layer = gfo.get_only_layer(input_path)
-    if output_path.exists():
-        if force:
-            gfo.remove(output_path)
-        else:
-            logger.info(f"Stop, output exists already {output_path}")
-            return True
-
-    if input_layer is None:
-        input_layer = gfo.get_only_layer(input_path)
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    info = _ogr_util.VectorTranslateInfo(
-        input_path=input_path,
-        output_path=output_path,
-        input_layers=input_layer,
-        output_layer=output_layer,
-        input_srs=input_srs,
-        output_srs=output_srs,
-        reproject=reproject,
-        spatial_filter=spatial_filter,
-        clip_geometry=clip_geometry,
-        sql_stmt=sql_stmt,
-        sql_dialect=sql_dialect,
-        transaction_size=transaction_size,
-        append=append,
-        update=update,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        options=options,
-        columns=columns,
-        warp=warp,
-    )
-
-    # Run + return result
-    result = _ogr_util.vector_translate_by_info(info)
-    logger.info(f"Ready, took {datetime.now()-start_time}")
-    return result
+from datetime import datetime
+import logging
+from pathlib import Path
+from typing import List, Literal, Optional, Tuple, Union
+
+from pygeoops import GeometryType
+from shapely import wkt
+
+import geofileops as gfo
+from geofileops.util import _ogr_util
+
+logger = logging.getLogger(__name__)
+
+
+def clip_by_geometry(
+    input_path: Path,
+    output_path: Path,
+    clip_geometry: Union[Tuple[float, float, float, float], str],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    spatial_filter = None
+    if isinstance(clip_geometry, str):
+        geom = wkt.loads(clip_geometry)
+        spatial_filter = tuple(geom.bounds)
+
+    options = {"LAYER_CREATION.SPATIAL_INDEX": True}
+    _run_ogr(
+        operation="clip_by_geometry",
+        input_path=input_path,
+        output_path=output_path,
+        spatial_filter=spatial_filter,  # type: ignore[arg-type]
+        clip_geometry=clip_geometry,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        options=options,
+        force=force,
+    )
+
+
+def export_by_bounds(
+    input_path: Path,
+    output_path: Path,
+    bounds: Tuple[float, float, float, float],
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    options = {"LAYER_CREATION.SPATIAL_INDEX": True}
+    _run_ogr(
+        operation="export_by_bounds",
+        input_path=input_path,
+        output_path=output_path,
+        spatial_filter=bounds,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        options=options,
+        force=force,
+    )
+
+
+def warp(
+    input_path: Path,
+    output_path: Path,
+    gcps: List[Tuple[float, float, float, float, Optional[float]]],
+    algorithm: str = "polynomial",
+    order: Optional[int] = None,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force: bool = False,
+):
+    warp = {
+        "gcps": gcps,
+        "algorithm": algorithm,
+        "order": order,
+    }
+
+    _run_ogr(
+        operation="warp",
+        input_path=input_path,
+        output_path=output_path,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        warp=warp,
+        force=force,
+    )
+
+
+def _run_ogr(
+    operation: str,
+    input_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    input_srs: Union[int, str, None] = None,
+    output_srs: Union[int, str, None] = None,
+    reproject: bool = False,
+    spatial_filter: Optional[Tuple[float, float, float, float]] = None,
+    clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
+    sql_stmt: Optional[str] = None,
+    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
+    transaction_size: int = 65536,
+    append: bool = False,
+    update: bool = False,
+    explodecollections: bool = False,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    options: dict = {},
+    columns: Optional[List[str]] = None,
+    warp: Optional[dict] = None,
+    force: bool = False,
+) -> bool:
+    # Init
+    logger = logging.getLogger(f"geofileops.{operation}")
+    start_time = datetime.now()
+    if input_layer is None:
+        input_layer = gfo.get_only_layer(input_path)
+    if output_path.exists():
+        if force:
+            gfo.remove(output_path)
+        else:
+            logger.info(f"Stop, output exists already {output_path}")
+            return True
+
+    if input_layer is None:
+        input_layer = gfo.get_only_layer(input_path)
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    info = _ogr_util.VectorTranslateInfo(
+        input_path=input_path,
+        output_path=output_path,
+        input_layers=input_layer,
+        output_layer=output_layer,
+        input_srs=input_srs,
+        output_srs=output_srs,
+        reproject=reproject,
+        spatial_filter=spatial_filter,
+        clip_geometry=clip_geometry,
+        sql_stmt=sql_stmt,
+        sql_dialect=sql_dialect,
+        transaction_size=transaction_size,
+        append=append,
+        update=update,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        options=options,
+        columns=columns,
+        warp=warp,
+    )
+
+    # Run + return result
+    result = _ogr_util.vector_translate_by_info(info)
+    logger.info(f"Ready, took {datetime.now()-start_time}")
+    return result
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_geoops_sql.py` & `geofileops-0.8.2/geofileops/util/_geoops_sql.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,3387 +1,3412 @@
-"""
-Module containing the implementation of Geofile operations using a sql statement.
-"""
-
-from concurrent import futures
-from datetime import datetime
-import json
-import logging
-import logging.config
-import math
-import multiprocessing
-from pathlib import Path
-import shutil
-import string
-from typing import Dict, Iterable, List, Literal, Optional, Tuple, Union
-import warnings
-
-import pandas as pd
-import pygeoops
-import shapely
-
-import geofileops as gfo
-from geofileops import GeometryType, PrimitiveType
-from geofileops import fileops
-
-from geofileops._compat import SPATIALITE_GTE_51
-from geofileops.fileops import _append_to_nolock
-from geofileops.util import _general_util
-from geofileops.util import _geofileinfo
-from geofileops.util import _geoops_gpd
-from geofileops.util import _io_util
-from geofileops.util import _ogr_sql_util
-from geofileops.util import _ogr_util
-from geofileops.helpers import _parameter_helper
-from geofileops.util import _processing_util
-from geofileops.util import _sqlite_util
-
-logger = logging.getLogger(__name__)
-
-# -----------------------
-# Operations on one layer
-# -----------------------
-
-
-def buffer(
-    input_path: Path,
-    output_path: Path,
-    distance: float,
-    quadrantsegments: int = 5,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    keep_empty_geoms: bool = True,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Init + prepare sql template for this operation
-    # ----------------------------------------------
-    operation = f"ST_Buffer({{geometrycolumn}}, {distance}, {quadrantsegments})"
-
-    # For a double sided buffer, a negative buffer is only relevant for polygon types,
-    # so only keep polygon results.
-    # Negative buffer creates invalid stuff, so use collectionextract to keep only
-    # polygons.
-    if distance < 0:
-        operation = f"ST_CollectionExtract({operation}, 3)"
-
-    # Create the final template
-    sql_template = f"""
-        SELECT {operation} AS {{geometrycolumn}}
-              {{columns_to_select_str}}
-            FROM "{{input_layer}}" layer
-            WHERE 1=1
-              {{batch_filter}}
-    """
-
-    # Buffer operation always results in polygons...
-    if explodecollections:
-        force_output_geometrytype = GeometryType.POLYGON
-    else:
-        force_output_geometrytype = GeometryType.MULTIPOLYGON
-
-    # Go!
-    # ---
-    return _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        geom_selected=True,
-        operation_name="buffer",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        gridsize=gridsize,
-        keep_empty_geoms=keep_empty_geoms,
-        where_post=where_post,
-        sql_dialect="SQLITE",
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def convexhull(
-    input_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    keep_empty_geoms: bool = False,  # Should become True
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Init + prepare sql template for this operation
-    # ----------------------------------------------
-    input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
-    sql_template = """
-        SELECT ST_ConvexHull({geometrycolumn}) AS {geometrycolumn}
-                {columns_to_select_str}
-          FROM "{input_layer}" layer
-         WHERE 1=1
-           {batch_filter}
-    """
-
-    # Go!
-    # ---
-    # Output geometry type same as input geometry type
-    return _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        geom_selected=True,
-        operation_name="convexhull",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=input_layerinfo.geometrytype,
-        gridsize=gridsize,
-        keep_empty_geoms=keep_empty_geoms,
-        where_post=where_post,
-        sql_dialect="SQLITE",
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def delete_duplicate_geometries(
-    input_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    keep_empty_geoms: bool = True,
-    where_post: Optional[str] = None,
-    force: bool = False,
-):
-    # The query as written doesn't give correct results when parallelized,
-    # but it isn't useful to do it for this operation.
-    sql_template = """
-        SELECT {geometrycolumn} AS {geometrycolumn}
-              {columns_to_select_str}
-          FROM "{input_layer}" layer
-         WHERE layer.rowid IN (
-                SELECT MIN(layer_sub.rowid) AS rowid_to_keep
-                  FROM "{input_layer}" layer_sub
-                 GROUP BY layer_sub.{geometrycolumn}
-            )
-    """
-
-    # Go!
-    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
-    return _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        geom_selected=True,
-        operation_name="delete_duplicate_geometries",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=input_layer_info.geometrytype,
-        gridsize=0.0,
-        keep_empty_geoms=keep_empty_geoms,
-        where_post=where_post,
-        sql_dialect="SQLITE",
-        nb_parallel=1,
-        batchsize=-1,
-        force=force,
-    )
-
-
-def isvalid(
-    input_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    validate_attribute_data: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-) -> bool:
-    # Prepare sql template for this operation
-    sql_template = """
-        SELECT ST_IsValidDetail({geometrycolumn}) AS {geometrycolumn}
-              ,ST_IsValid({geometrycolumn}) AS isvalid
-              ,ST_IsValidReason({geometrycolumn}) AS isvalidreason
-              {columns_to_select_str}
-          FROM "{input_layer}" layer
-         WHERE ST_IsValid({geometrycolumn}) <> 1
-           {batch_filter}
-    """
-
-    _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        geom_selected=True,
-        operation_name="isvalid",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=GeometryType.POINT,
-        gridsize=0.0,
-        keep_empty_geoms=False,
-        where_post=None,
-        sql_dialect="SQLITE",
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-    # Check the number of invalid files
-    nb_invalid_geoms = 0
-    if output_path.exists():
-        nb_invalid_geoms = gfo.get_layerinfo(output_path).featurecount
-        if nb_invalid_geoms == 0:
-            # Empty result, so everything was valid: remove output file
-            gfo.remove(output_path)
-
-    # If output is sqlite based, check if all data can be read
-    logger = logging.getLogger("geofileops.isvalid")
-    if validate_attribute_data:
-        try:
-            input_info = _geofileinfo.get_geofileinfo(input_path)
-            if input_info.is_spatialite_based:
-                _sqlite_util.test_data_integrity(path=input_path)
-                logger.debug("test_data_integrity was succesfull")
-        except Exception:
-            logger.exception(
-                f"nb_invalid_geoms: {nb_invalid_geoms} + some attributes "
-                "could not be read!"
-            )
-            return False
-
-    if nb_invalid_geoms > 0:
-        logger.info(f"Found {nb_invalid_geoms} invalid geoms in {output_path}")
-        return False
-
-    # Nothing invalid found
-    return True
-
-
-def makevalid(
-    input_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    gridsize: float = 0.0,
-    keep_empty_geoms: bool = True,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # If output file exists already, either clean up or return...
-    operation_name = "makevalid"
-    logger = logging.getLogger(f"geofileops.{operation_name}")
-    if not force and output_path.exists():
-        logger.info(f"Stop, output exists already {output_path}")
-        return
-
-    # Determine output_geometrytype + make it multitype if it wasn't specified.
-    # Otherwise makevalid can result in column type 'GEOMETRY'/'UNKNOWN(ANY)'.
-    if force_output_geometrytype is None:
-        input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
-        force_output_geometrytype = input_layerinfo.geometrytype
-        if not explodecollections:
-            force_output_geometrytype = force_output_geometrytype.to_multitype
-
-    # Init + prepare sql template for this operation
-    # ----------------------------------------------
-    # Only apply makevalid if the geometry is truly invalid, this is faster
-    if SPATIALITE_GTE_51:
-        operation = """
-            IIF(ST_IsValid({geometrycolumn}) = 1,
-                {geometrycolumn},
-                GEOSMakeValid({geometrycolumn}, 0)
-            )"""
-    else:
-        # Prepare sql template for this operation
-        operation = """
-            IIF(ST_IsValid({geometrycolumn}) = 1,
-                {geometrycolumn},
-                ST_MakeValid({geometrycolumn})
-            )"""
-
-        # If we want a specific geometrytype, only extract the relevant type
-        if force_output_geometrytype is not GeometryType.GEOMETRYCOLLECTION:
-            primitivetypeid = force_output_geometrytype.to_primitivetype.value
-            operation = f"ST_CollectionExtract({operation}, {primitivetypeid})"
-
-    # Now we can prepare the entire statement
-    sql_template = f"""
-        SELECT {operation} AS {{geometrycolumn}}
-              {{columns_to_select_str}}
-          FROM "{{input_layer}}" layer
-         WHERE 1=1
-           {{batch_filter}}
-    """
-
-    _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        geom_selected=True,
-        operation_name=operation_name,
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        gridsize=gridsize,
-        keep_empty_geoms=keep_empty_geoms,
-        where_post=where_post,
-        sql_dialect="SQLITE",
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def select(
-    input_path: Path,
-    output_path: Path,
-    sql_stmt: str,
-    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = "SQLITE",
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    gridsize: float = 0.0,
-    keep_empty_geoms: bool = True,
-    nb_parallel: int = 1,
-    batchsize: int = -1,
-    force: bool = False,
-    operation_prefix: str = "",
-):
-    # Check if output exists already here, to avoid to much logging to be written
-    logger = logging.getLogger(f"geofileops.{operation_prefix}select")
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop, output exists already {output_path}")
-            return
-    logger.debug(f"  -> select to execute:\n{sql_stmt}")
-
-    # If no output geometrytype is specified, use the geometrytype of the input layer
-    if force_output_geometrytype is None:
-        force_output_geometrytype = gfo.get_layerinfo(
-            input_path, input_layer, raise_on_nogeom=False
-        ).geometrytype
-        if force_output_geometrytype is not None and not explodecollections:
-            force_output_geometrytype = force_output_geometrytype.to_multitype
-
-        logger.info(
-            "No force_output_geometrytype specified, so defaults to input "
-            f"layer geometrytype: {force_output_geometrytype}"
-        )
-
-    # Go!
-    return _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_stmt,
-        geom_selected=None,
-        operation_name=f"{operation_prefix}select",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        gridsize=gridsize,
-        keep_empty_geoms=keep_empty_geoms,
-        where_post=None,
-        sql_dialect=sql_dialect,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def simplify(
-    input_path: Path,
-    output_path: Path,
-    tolerance: float,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    columns: Optional[List[str]] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    keep_empty_geoms: bool = True,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Init + prepare sql template for this operation
-    # ----------------------------------------------
-    sql_template = f"""
-        SELECT ST_SimplifyPreserveTopology({{geometrycolumn}}, {tolerance}
-               ) AS {{geometrycolumn}}
-              {{columns_to_select_str}}
-            FROM "{{input_layer}}" layer
-            WHERE 1=1
-            {{batch_filter}}
-    """
-
-    # Output geometry type same as input geometry type
-    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
-    return _single_layer_vector_operation(
-        input_path=input_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        geom_selected=True,
-        operation_name="simplify",
-        input_layer=input_layer,
-        output_layer=output_layer,
-        columns=columns,
-        explodecollections=explodecollections,
-        force_output_geometrytype=input_layer_info.geometrytype,
-        gridsize=gridsize,
-        keep_empty_geoms=keep_empty_geoms,
-        where_post=where_post,
-        sql_dialect="SQLITE",
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def _single_layer_vector_operation(
-    input_path: Path,
-    output_path: Path,
-    sql_template: str,
-    geom_selected: Optional[bool],
-    operation_name: str,
-    input_layer: Optional[str],
-    output_layer: Optional[str],
-    columns: Optional[List[str]],
-    explodecollections: bool,
-    force_output_geometrytype: Optional[GeometryType],
-    gridsize: float,
-    keep_empty_geoms: bool,
-    where_post: Optional[str],
-    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]],
-    nb_parallel: int,
-    batchsize: int,
-    force: bool,
-):
-    """
-    Execute a sql query template on the input layer.
-
-    Args:
-        input_path (Path): _description_
-        output_path (Path): _description_
-        sql_template (str): _description_
-        geom_selected (Optional[bool]): True if a geometry column is selected in the
-            sql_template. False if no geometry column is selected. None if it is
-            unclear.
-        operation_name (str): _description_
-        input_layer (Optional[str]): _description_
-        output_layer (Optional[str]): _description_
-        columns (Optional[List[str]]): _description_
-        explodecollections (bool): _description_
-        force_output_geometrytype (Optional[GeometryType]): _description_
-        gridsize (float): _description_
-        keep_empty_geoms (bool): _description_
-        where_post (Optional[str]): _description_
-        sql_dialect (Optional[Literal["SQLITE", "OGRSQL"]]): _description_
-        nb_parallel (int): _description_
-        batchsize (int): _description_
-        force (bool): _description_
-
-    Raises:
-        ValueError: _description_
-        ValueError: _description_
-        ValueError: _description_
-        Exception: _description_
-    """
-    # Init
-    start_time = datetime.now()
-    logger = logging.getLogger(f"geofileops.{operation_name}")
-
-    # Check/clean input parameters...
-    if not input_path.exists():
-        raise ValueError(f"{operation_name}: input_path doesn't exist: {input_path}")
-    if input_path == output_path:
-        raise ValueError(f"{operation_name}: output_path must not equal input_path")
-    if where_post is not None and where_post == "":
-        where_post = None
-
-    # Check/get layer names
-    if input_layer is None:
-        input_layer = gfo.get_only_layer(input_path)
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    # If output file exists already, either clean up or return...
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop, output exists already {output_path}")
-            return
-        else:
-            gfo.remove(output_path)
-
-    # Determine if fid can be preserved
-    preserve_fid = False
-    if (
-        not explodecollections
-        and _geofileinfo.get_geofileinfo(input_path).is_spatialite_based
-        and _geofileinfo.get_geofileinfo(output_path).is_spatialite_based
-    ):
-        preserve_fid = True
-
-    # Calculate
-    tempdir = _io_util.create_tempdir(f"geofileops/{operation_name.replace(' ', '_')}")
-    try:
-        # If gridsize != 0.0 or if geom_selected is None we need an sqlite file to be
-        # able to determine the columns later on.
-        convert_to_spatialite_based = (
-            True if gridsize != 0.0 or geom_selected is None else False
-        )
-        processing_params = _prepare_processing_params(
-            input1_path=input_path,
-            input1_layer=input_layer,
-            input1_layer_alias="layer",
-            tempdir=tempdir,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            convert_to_spatialite_based=convert_to_spatialite_based,
-        )
-        # If None is returned, just stop.
-        if processing_params is None or processing_params.batches is None:
-            return
-
-        # Get layer info of the input layer to use
-        assert processing_params.input1_path is not None
-        input_layerinfo = gfo.get_layerinfo(
-            processing_params.input1_path, input_layer, raise_on_nogeom=False
-        )
-
-        # If multiple batches, there should be a batch_filter placeholder sql_template
-        nb_batches = len(processing_params.batches)
-        if nb_batches > 1:
-            placeholders = [
-                name for _, name, _, _ in string.Formatter().parse(sql_template) if name
-            ]
-            if "batch_filter" not in placeholders:
-                raise ValueError(
-                    "Number batches > 1 requires a batch_filter placeholder in "
-                    f"sql_template {sql_template}"
-                )
-
-        # Format column string for use in select
-        column_formatter = _ogr_sql_util.ColumnFormatter(
-            columns_asked=columns,
-            columns_in_layer=input_layerinfo.columns,
-            fid_column=input_layerinfo.fid_column,
-        )
-
-        # Fill out template already for known info
-        columns_to_select_str = column_formatter.prefixed_aliased()
-        if input_layerinfo.fid_column != "":
-            # If there is an fid column defined, select that column as well so the fids
-            # can be retained in the output if possible.
-            columns_to_select_str = (
-                f",{input_layerinfo.fid_column}{columns_to_select_str}"
-            )
-        sql_template = sql_template.format(
-            geometrycolumn=input_layerinfo.geometrycolumn,
-            columns_to_select_str=columns_to_select_str,
-            input_layer=processing_params.input1_layer,
-            batch_filter="{batch_filter}",
-        )
-
-        #  to Check if a geometry column is available + selected
-        if geom_selected is None:
-            if input_layerinfo.geometrycolumn is None:
-                # There is no geometry column in the source file
-                geom_selected = False
-            else:
-                # There is a geometry column in the source file, check if it is selected
-                sql_tmp = sql_template.format(batch_filter="")
-                cols = _sqlite_util.get_columns(
-                    sql_stmt=sql_tmp,
-                    input1_path=processing_params.input1_path,
-                )
-                geom_selected = input_layerinfo.geometrycolumn in cols
-
-        # Fill out/add to the sql_template what is already possible
-        # ---------------------------------------------------------
-
-        # Add application of gridsize around sql_template if specified
-        if geom_selected and gridsize != 0.0:
-            gridsize_op = _format_apply_gridsize_operation(
-                geometrycolumn=f"sub_gridsize.{input_layerinfo.geometrycolumn}",
-                gridsize=gridsize,
-                force_output_geometrytype=force_output_geometrytype,
-            )
-
-            # Get all columns of the sql_template
-            sql_tmp = sql_template.format(batch_filter="")
-            cols = _sqlite_util.get_columns(
-                sql_stmt=sql_tmp, input1_path=processing_params.input1_path
-            )
-            attributes = [
-                col for col in cols if col.lower() != input_layerinfo.geometrycolumn
-            ]
-            columns_to_select = _ogr_sql_util.columns_quoted(attributes)
-            sql_template = f"""
-                SELECT {gridsize_op} AS {input_layerinfo.geometrycolumn}
-                      {columns_to_select}
-                  FROM
-                    ( {sql_template}
-                       LIMIT -1 OFFSET 0
-                    ) sub_gridsize
-            """
-
-        # If empty/null geometries don't need to be kept, filter them away
-        if geom_selected and not keep_empty_geoms:
-            sql_template = f"""
-                SELECT * FROM
-                    ( {sql_template}
-                       LIMIT -1 OFFSET 0
-                    )
-                 WHERE {input_layerinfo.geometrycolumn} IS NOT NULL
-            """
-
-        # Prepare/apply where_post parameter
-        if where_post is not None and not explodecollections:
-            # explodecollections is not True, so we can add where_post to sql_stmt.
-            # If explodecollections would be True, we need to wait to apply the
-            # where_post till after explodecollections is applied, so when appending the
-            # partial results to the output file.
-            sql_template = f"""
-                SELECT * FROM
-                    ( {sql_template}
-                       LIMIT -1 OFFSET 0
-                    )
-                    WHERE {where_post}
-            """
-            # where_post has been applied already so set to None.
-            where_post = None
-
-        # When null geometries are being kept, we need to make sure the geom in the
-        # first row is not NULL because of a bug in gdal, so add ORDER BY as last step.
-        #   -> https://github.com/geofileops/geofileops/issues/308
-        if geom_selected and keep_empty_geoms:
-            sql_template = f"""
-                SELECT * FROM
-                    ( {sql_template}
-                       LIMIT -1 OFFSET 0
-                    )
-                 ORDER BY {input_layerinfo.geometrycolumn} IS NULL
-            """
-
-        # Fill out geometrycolumn again as there might have popped up extra ones
-        sql_template = sql_template.format(
-            geometrycolumn=input_layerinfo.geometrycolumn,
-            batch_filter="{batch_filter}",
-        )
-
-        logger.info(
-            f"Start processing ({processing_params.nb_parallel} "
-            f"parallel workers, batch size: {processing_params.batchsize})"
-        )
-
-        # Prepare temp output filename
-        tmp_output_path = tempdir / output_path.name
-
-        # Processing in threads is 2x faster for small datasets (on Windows)
-        calculate_in_threads = True if input_layerinfo.featurecount <= 100 else False
-        with _processing_util.PooledExecutorFactory(
-            threadpool=calculate_in_threads,
-            max_workers=processing_params.nb_parallel,
-            initializer=_processing_util.initialize_worker(),
-        ) as calculate_pool:
-            batches: Dict[int, dict] = {}
-            future_to_batch_id = {}
-            for batch_id in processing_params.batches:
-                batches[batch_id] = {}
-                batches[batch_id]["layer"] = output_layer
-
-                tmp_partial_output_path = (
-                    tempdir / f"{output_path.stem}_{batch_id}.gpkg"
-                )
-                batches[batch_id]["tmp_partial_output_path"] = tmp_partial_output_path
-
-                # Fill out sql_template
-                sql_stmt = sql_template.format(
-                    batch_filter=processing_params.batches[batch_id]["batch_filter"]
-                )
-                batches[batch_id]["sql_stmt"] = sql_stmt
-
-                # If there is only one batch, it is faster to create the spatial index
-                # immediately. Otherwise no index needed, because partial files still
-                # need to be merged to one file later on.
-                create_spatial_index = False
-                if nb_batches == 1:
-                    create_spatial_index = True
-                translate_info = _ogr_util.VectorTranslateInfo(
-                    input_path=processing_params.batches[batch_id]["input1_path"],
-                    output_path=tmp_partial_output_path,
-                    output_layer=output_layer,
-                    sql_stmt=sql_stmt,
-                    sql_dialect=sql_dialect,
-                    explodecollections=explodecollections,
-                    force_output_geometrytype=force_output_geometrytype,
-                    options={"LAYER_CREATION.SPATIAL_INDEX": create_spatial_index},
-                    preserve_fid=preserve_fid,
-                )
-                future = calculate_pool.submit(
-                    _ogr_util.vector_translate_by_info, info=translate_info
-                )
-                future_to_batch_id[future] = batch_id
-
-            # Loop till all parallel processes are ready, but process each one
-            # that is ready already.
-            # Calculating can be done in parallel, but only one process can write to
-            # the same file at the time.
-            nb_done = 0
-            _general_util.report_progress(
-                start_time,
-                nb_done,
-                nb_todo=nb_batches,
-                operation=operation_name,
-                nb_parallel=processing_params.nb_parallel,
-            )
-            for future in futures.as_completed(future_to_batch_id):
-                try:
-                    _ = future.result()
-                except Exception as ex:
-                    batch_id = future_to_batch_id[future]
-                    error = str(ex).partition("\n")[0]
-                    message = f"Error <{error}> executing {batches[batch_id]}"
-                    logger.exception(message)
-                    raise Exception(message) from ex
-
-                # Start copy of the result to a common file
-                # Remark: give higher priority, because this is the slowest factor
-                batch_id = future_to_batch_id[future]
-                tmp_partial_output_path = batches[batch_id]["tmp_partial_output_path"]
-                nb_done += 1
-
-                # Normally all partial files should exist, but to be sure.
-                if not tmp_partial_output_path.exists():
-                    logger.warning(f"Result file {tmp_partial_output_path} not found")
-                    continue
-
-                if (
-                    nb_batches == 1
-                    and tmp_partial_output_path.suffix == tmp_output_path.suffix
-                    and where_post is None
-                ):
-                    # If there is only one batch
-                    #   + partial file is already is correct file format
-                    #   + no more where_post needs to be applied
-                    # -> just rename partial file, because it is already OK.
-                    gfo.move(tmp_partial_output_path, tmp_output_path)
-                else:
-                    # Append partial file to full destination file
-                    if where_post is not None:
-                        info = gfo.get_layerinfo(tmp_partial_output_path, output_layer)
-                        where_post = where_post.format(
-                            geometrycolumn=info.geometrycolumn
-                        )
-                    fileops._append_to_nolock(
-                        src=tmp_partial_output_path,
-                        dst=tmp_output_path,
-                        explodecollections=explodecollections,
-                        force_output_geometrytype=force_output_geometrytype,
-                        where=where_post,
-                        create_spatial_index=False,
-                        preserve_fid=preserve_fid,
-                    )
-                    gfo.remove(tmp_partial_output_path)
-
-                # Log the progress and prediction speed
-                _general_util.report_progress(
-                    start_time,
-                    nb_done,
-                    nb_todo=nb_batches,
-                    operation=operation_name,
-                    nb_parallel=processing_params.nb_parallel,
-                )
-
-        # Round up and clean up
-        # Now create spatial index and move to output location
-        if tmp_output_path.exists():
-            if (
-                gfo.get_layerinfo(
-                    path=tmp_output_path, layer=output_layer, raise_on_nogeom=False
-                ).geometrycolumn
-                is not None
-            ):
-                gfo.create_spatial_index(
-                    path=tmp_output_path, layer=output_layer, exist_ok=True
-                )
-            output_path.parent.mkdir(parents=True, exist_ok=True)
-            gfo.move(tmp_output_path, output_path)
-        elif (
-            gfo.get_driver(tmp_output_path) == "ESRI Shapefile"
-            and tmp_output_path.with_suffix(".dbf").exists()
-        ):
-            # If the output shapefile doesn't have a geometry column, the .shp file
-            # doesn't exist but the .dbf does
-            output_path.parent.mkdir(parents=True, exist_ok=True)
-            gfo.move(
-                tmp_output_path.with_suffix(".dbf"), output_path.with_suffix(".dbf")
-            )
-        else:
-            logger.debug("Result was empty!")
-
-    finally:
-        # Clean tmp dir
-        shutil.rmtree(tempdir, ignore_errors=True)
-
-    logger.info(f"Ready, took {datetime.now()-start_time}")
-
-
-# ------------------------
-# Operations on two layers
-# ------------------------
-
-
-def clip(
-    input_path: Path,
-    clip_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    input_columns: Optional[List[str]] = None,
-    clip_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-    input_columns_prefix: str = "",
-    output_with_spatial_index: bool = True,
-):
-    # Init
-    # In the query, important to only extract the geometry types that are expected
-    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
-    primitivetypeid = input_layer_info.geometrytype.to_primitivetype.value
-
-    # If explodecollections is False and the input type is not point, force the output
-    # type to multi, because erase clip cause eg. polygons to be split to multipolygons.
-    force_output_geometrytype = input_layer_info.geometrytype
-    if not explodecollections and force_output_geometrytype is not GeometryType.POINT:
-        force_output_geometrytype = force_output_geometrytype.to_multitype
-
-    # Prepare sql template for this operation
-    # Remarks:
-    # - ST_intersection(geometry , NULL) gives NULL as result! -> hence the CASE
-    # - use of the with instead of an inline view is a lot faster
-    # - use "LIMIT -1 OFFSET 0" to avoid the subquery flattening. Flattening e.g.
-    #   "geom IS NOT NULL" leads to geom operation to be calculated twice!
-    # - WHERE geom IS NOT NULL to avoid rows with a NULL geom, they give issues in
-    #   later operations.
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        SELECT * FROM
-          ( WITH layer2_unioned AS (
-              SELECT layer1.rowid AS layer1_rowid
-                    ,ST_union(layer2.{{input2_geometrycolumn}}) AS geom
-                FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                  ON layer1.fid = layer1tree.id
-                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                  ON layer2.fid = layer2tree.id
-               WHERE 1=1
-                 {{batch_filter}}
-                 AND layer1tree.minx <= layer2tree.maxx
-                 AND layer1tree.maxx >= layer2tree.minx
-                 AND layer1tree.miny <= layer2tree.maxy
-                 AND layer1tree.maxy >= layer2tree.miny
-                 AND ST_Intersects(
-                        layer1.{{input1_geometrycolumn}},
-                        layer2.{{input2_geometrycolumn}}) = 1
-                 --AND ST_Touches(
-                 --       layer1.{{input1_geometrycolumn}},
-                 --       layer2.{{input2_geometrycolumn}}) = 0
-               GROUP BY layer1.rowid
-               LIMIT -1 OFFSET 0
-            )
-            SELECT CASE WHEN layer2_unioned.geom IS NULL THEN NULL
-                        ELSE ST_CollectionExtract(
-                               ST_intersection(layer1.{{input1_geometrycolumn}},
-                                               layer2_unioned.geom), {primitivetypeid})
-                   END as geom
-                  {{layer1_columns_prefix_alias_str}}
-              FROM {{input1_databasename}}."{{input1_layer}}" layer1
-              JOIN layer2_unioned ON layer1.rowid = layer2_unioned.layer1_rowid
-             WHERE 1=1
-               {{batch_filter}}
-             LIMIT -1 OFFSET 0
-          )
-         WHERE geom IS NOT NULL
-    """
-
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input_path,
-        input2_path=clip_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="clip",
-        input1_layer=input_layer,
-        input1_columns=input_columns,
-        input1_columns_prefix=input_columns_prefix,
-        input2_layer=clip_layer,
-        input2_columns=None,
-        input2_columns_prefix="",
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        gridsize=gridsize,
-        where_post=where_post,
-        force_output_geometrytype=force_output_geometrytype,
-        output_with_spatial_index=output_with_spatial_index,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def erase(
-    input_path: Path,
-    erase_path: Path,
-    output_path: Path,
-    input_layer: Optional[str] = None,
-    input_columns: Optional[List[str]] = None,
-    erase_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    subdivide_coords: int = 2000,
-    force: bool = False,
-    input_columns_prefix: str = "",
-    output_with_spatial_index: bool = True,
-    operation_prefix: str = "",
-):
-    # Because there might be extra preparation of the erase layer before going ahead
-    # with the real calculation, do some additional init + checks here...
-    operation = f"{operation_prefix}erase"
-    logger = logging.getLogger(f"geofileops.{operation}")
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop, output exists already {output_path}")
-            return
-        else:
-            gfo.remove(output_path)
-
-    # Init
-    start_time = datetime.now()
-    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
-    primitivetypeid = input_layer_info.geometrytype.to_primitivetype.value
-
-    # If explodecollections is False and the input type is not point, force the output
-    # type to multi, because erase can cause eg. polygons to be split to multipolygons.
-    force_output_geometrytype = input_layer_info.geometrytype
-    if not explodecollections and force_output_geometrytype is not GeometryType.POINT:
-        force_output_geometrytype = force_output_geometrytype.to_multitype
-
-    # If the erase layer is made out of polygons, subdivide them if needed
-    tmp_dir = None
-    erase_layer_info = gfo.get_layerinfo(erase_path, erase_layer)
-    if (
-        subdivide_coords > 0
-        and erase_layer_info.geometrytype.to_primitivetype == PrimitiveType.POLYGON
-    ):
-        erase_layer = erase_layer_info.name
-
-        # If erase layer has complex geometries, subdivide them to speed up processing.
-        complexgeom_sql = f"""
-            SELECT 1
-              FROM "{erase_layer}" layer
-             WHERE ST_NPoints({erase_layer_info.geometrycolumn}) > {subdivide_coords}
-             LIMIT 1
-        """
-        logger.info(
-            f"Check if complex geometries in erase layer (> {subdivide_coords} coords)"
-        )
-        complexgeom_df = gfo.read_file(
-            erase_path, sql_stmt=complexgeom_sql, sql_dialect="SQLITE"
-        )
-        if len(complexgeom_df) > 0:
-            logger.info("Subdivide needed: complex geometries found")
-
-            # Do subdivide using python function, because all spatialite options didn't
-            # seem to work.
-            # Check out commits in https://github.com/geofileops/geofileops/pull/433
-            def subdivide(geom, num_coords_max):
-                result = pygeoops.subdivide(geom, num_coords_max=num_coords_max)
-
-                if result is None:
-                    return None
-                if not hasattr(result, "__len__"):
-                    return result
-                if len(result) == 1:
-                    return result[0]
-
-                # Explode because
-                #   - they will be exploded anyway by spatialite.ST_Collect
-                #   - spatialite.ST_AsBinary and/or spatialite.ST_GeomFromWkb don't seem
-                #     to handle nested collections well.
-                return shapely.GeometryCollection(shapely.get_parts(result).tolist())
-
-            tmp_dir = _io_util.create_tempdir("geofileops/erase_input")
-            erase_subdidided_path = tmp_dir / f"{erase_path.stem}_subdivided.gpkg"
-            _geoops_gpd.apply(
-                input_path=erase_path,
-                input_layer=erase_layer,
-                output_path=erase_subdidided_path,
-                output_layer=erase_layer,
-                func=lambda geom: subdivide(geom, num_coords_max=subdivide_coords),
-                operation_name="erase/subdivide",
-                columns=[],
-                explodecollections=True,
-                nb_parallel=nb_parallel,
-                batchsize=batchsize,
-                parallelization_config=_geoops_gpd.ParallelizationConfig(
-                    bytes_per_row=2000, max_rows_per_batch=50000
-                ),
-            )
-
-            erase_path = erase_subdidided_path
-
-    # Prepare sql template for this operation
-    # - WHERE geom IS NOT NULL to avoid rows with a NULL geom, they give issues in
-    #   later operations
-    # - use "LIMIT -1 OFFSET 0" to avoid the subquery flattening. Flattening e.g.
-    #   "geom IS NOT NULL" leads to GFO_Difference_Collection calculated double!
-    # - ST_Intersects and ST_Touches slow down a lot when the data contains huge geoms
-    # - Calculate difference in correlated subquery in SELECT clause reduces memory
-    #   usage by a factor 10 compared with a WITH with GROUP BY. The WITH with a GROUP
-    #   BY on layer1.rowid was a few % faster, but this is not worth it. E.g. for one
-    #   test file 4-7 GB per process versus 70-700 MB). For another: crash.
-    # - Check if the result of GFO_Difference_Collection is empty (NULL) using IFNULL,
-    #   and if this is the case set to 'DIFF_EMPTY'. This way we can make the
-    #   distinction whether the subquery is finding a row (no match with spatial index)
-    #   or if the difference results in an empty/NULL geometry.
-    #   Tried to return EMPTY GEOMETRY from GFO_Difference_Collection, but it didn't
-    #   work to use spatialite's ST_IsEmpty(geom) = 0 to filter on this for an unclear
-    #   reason.
-    # - ST_difference(geometry , NULL) gives NULL as result -> handle explicitly
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-
-    sql_template = f"""
-        SELECT * FROM (
-          SELECT IFNULL(
-                   ( SELECT IFNULL(
-                               IIF(ST_NPoints(layer1.{{input1_geometrycolumn}})
-                                        < {subdivide_coords},
-                                   IIF(ST_Union(layer2_sub.{{input2_geometrycolumn}})
-                                            IS NULL,
-                                       layer1.{{input1_geometrycolumn}},
-                                       ST_CollectionExtract(
-                                          ST_difference(
-                                             layer1.{{input1_geometrycolumn}},
-                                             ST_Union(
-                                                layer2_sub.{{input2_geometrycolumn}})
-                                          ),
-                                          {primitivetypeid}
-                                       )
-                                   ),
-                                   ST_GeomFromWKB(GFO_Difference_Collection(
-                                      ST_AsBinary(layer1.{{input1_geometrycolumn}}),
-                                      ST_AsBinary(ST_Collect(
-                                         layer2_sub.{{input2_geometrycolumn}}
-                                      )),
-                                      1,
-                                      {subdivide_coords}
-                                   ))
-                               ),
-                               'DIFF_EMPTY'
-                            ) AS diff_geom
-                       FROM {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                       JOIN {{input2_databasename}}."{{input2_layer}}" layer2_sub
-                       JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                         ON layer2_sub.rowid = layer2tree.id
-                      WHERE layer1tree.id = layer1.rowid
-                        AND layer1tree.minx <= layer2tree.maxx
-                        AND layer1tree.maxx >= layer2tree.minx
-                        AND layer1tree.miny <= layer2tree.maxy
-                        AND layer1tree.maxy >= layer2tree.miny
-                        AND ST_intersects(layer1.{{input1_geometrycolumn}},
-                                          layer2_sub.{{input2_geometrycolumn}}) = 1
-                      LIMIT -1 OFFSET 0
-                   ),
-                   layer1.{{input1_geometrycolumn}}
-                 ) AS geom
-                {{layer1_columns_prefix_alias_str}}
-                {{layer2_columns_prefix_alias_null_str}}
-            FROM {{input1_databasename}}."{{input1_layer}}" layer1
-           WHERE 1=1
-             {{batch_filter}}
-           LIMIT -1 OFFSET 0
-          )
-         WHERE geom IS NOT NULL
-           AND geom <> 'DIFF_EMPTY'
-    """
-
-    # Go!
-    try:
-        _two_layer_vector_operation(
-            input1_path=input_path,
-            input2_path=erase_path,
-            output_path=output_path,
-            sql_template=sql_template,
-            operation_name=operation,
-            input1_layer=input_layer,
-            input1_columns=input_columns,
-            input1_columns_prefix=input_columns_prefix,
-            input2_layer=erase_layer,
-            input2_columns=[],
-            input2_columns_prefix="",
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            force_output_geometrytype=force_output_geometrytype,
-            gridsize=gridsize,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-            output_with_spatial_index=output_with_spatial_index,
-        )
-    finally:
-        if tmp_dir is not None:
-            shutil.rmtree(tmp_dir, ignore_errors=True)
-
-    # Print time taken
-    logger.info(f"Ready, full erase took {datetime.now()-start_time}")
-
-
-def export_by_location(
-    input_path: Path,
-    input_to_compare_with_path: Path,
-    output_path: Path,
-    min_area_intersect: Optional[float] = None,
-    area_inters_column_name: Optional[str] = None,
-    input_layer: Optional[str] = None,
-    input_columns: Optional[List[str]] = None,
-    input_to_compare_with_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Prepare sql template for this operation
-    # TODO: test performance difference between the following two queries
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-
-    # If intersect area needs to be calculated, other query needed
-    if area_inters_column_name is None and min_area_intersect is None:
-        sql_template = f"""
-            SELECT layer1.{{input1_geometrycolumn}} AS geom
-                  {{layer1_columns_prefix_alias_str}}
-              FROM {{input1_databasename}}."{{input1_layer}}" layer1
-              JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                ON layer1.fid = layer1tree.id
-             WHERE 1=1
-               {{batch_filter}}
-               AND EXISTS (
-                  SELECT 1
-                    FROM {{input2_databasename}}."{{input2_layer}}" layer2
-                    JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                      ON layer2.fid = layer2tree.id
-                   WHERE layer1tree.minx <= layer2tree.maxx
-                     AND layer1tree.maxx >= layer2tree.minx
-                     AND layer1tree.miny <= layer2tree.maxy
-                     AND layer1tree.maxy >= layer2tree.miny
-                     AND ST_intersects(layer1.{{input1_geometrycolumn}},
-                                       layer2.{{input2_geometrycolumn}}) = 1
-                     AND ST_touches(layer1.{{input1_geometrycolumn}},
-                                    layer2.{{input2_geometrycolumn}}) = 0)
-            """
-    else:
-        # Intersect area needs to be calculated
-        if area_inters_column_name is None:
-            area_inters_column_name = "area_inters"
-        area_inters_column_expression = f"""
-            ,ST_area(ST_intersection(
-                    ST_union(layer1.{{input1_geometrycolumn}}),
-                    ST_union(layer2.{{input2_geometrycolumn}})
-                )) AS {area_inters_column_name}
-        """
-
-        # Prepare sql template with intersect area calculation
-        sql_template = f"""
-            SELECT ST_union(layer1.{{input1_geometrycolumn}}) as geom
-                  {{layer1_columns_prefix_str}}
-                  {area_inters_column_expression}
-              FROM {{input1_databasename}}."{{input1_layer}}" layer1
-              JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                ON layer1.fid = layer1tree.id
-              JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-              JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                ON layer2.fid = layer2tree.id
-             WHERE 1=1
-               {{batch_filter}}
-               AND layer1tree.minx <= layer2tree.maxx
-               AND layer1tree.maxx >= layer2tree.minx
-               AND layer1tree.miny <= layer2tree.maxy
-               AND layer1tree.maxy >= layer2tree.miny
-               AND ST_Intersects(layer1.{{input1_geometrycolumn}},
-                                 layer2.{{input2_geometrycolumn}}) = 1
-               AND ST_Touches(layer1.{{input1_geometrycolumn}},
-                              layer2.{{input2_geometrycolumn}}) = 0
-             GROUP BY layer1.rowid {{layer1_columns_prefix_str}}
-        """
-
-        # Filter on intersect area if necessary
-        if min_area_intersect is not None:
-            sql_template = f"""
-                SELECT sub.* FROM
-                  ( {sql_template}
-                     LIMIT -1 OFFSET 0
-                  ) sub
-                WHERE sub.{area_inters_column_name} >= {min_area_intersect}
-            """
-
-    # Go!
-    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
-    return _two_layer_vector_operation(
-        input1_path=input_path,
-        input2_path=input_to_compare_with_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="export_by_location",
-        input1_layer=input_layer,
-        input1_columns=input_columns,
-        input1_columns_prefix="",
-        input2_layer=input_to_compare_with_layer,
-        input2_columns=[],
-        input2_columns_prefix="",
-        output_layer=output_layer,
-        explodecollections=False,
-        force_output_geometrytype=input_layer_info.geometrytype,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def export_by_distance(
-    input_to_select_from_path: Path,
-    input_to_compare_with_path: Path,
-    output_path: Path,
-    max_distance: float,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input2_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Prepare sql template for this operation
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        SELECT geom
-              {{layer1_columns_prefix_alias_str}}
-          FROM {{input1_databasename}}."{{input1_layer}}" layer1
-          JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-            ON layer1.fid = layer1tree.id
-         WHERE 1=1
-               {{batch_filter}}
-               AND EXISTS (
-                    SELECT 1
-                      FROM {{input2_databasename}}."{{input2_layer}}" layer2
-                      JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                        ON layer2.fid = layer2tree.id
-                     WHERE (layer1tree.minx-{max_distance}) <= layer2tree.maxx
-                       AND (layer1tree.maxx+{max_distance}) >= layer2tree.minx
-                       AND (layer1tree.miny-{max_distance}) <= layer2tree.maxy
-                       AND (layer1tree.maxy+{max_distance}) >= layer2tree.miny
-                       AND ST_distance(
-                            layer1.{{input1_geometrycolumn}},
-                            layer2.{{input2_geometrycolumn}}) <= {max_distance})
-    """
-
-    input_layer_info = gfo.get_layerinfo(input_to_select_from_path, input1_layer)
-
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input_to_select_from_path,
-        input2_path=input_to_compare_with_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="export_by_distance",
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix="",
-        input2_layer=input2_layer,
-        input2_columns=[],
-        input2_columns_prefix="",
-        output_layer=output_layer,
-        explodecollections=False,
-        force_output_geometrytype=input_layer_info.geometrytype,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def intersection(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-    output_with_spatial_index: bool = True,
-    operation_prefix: str = "",
-):
-    # In the query, important to only extract the geometry types that are expected
-    # TODO: test for geometrycollection, line, point,...
-    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
-    input2_layer_info = gfo.get_layerinfo(input2_path, input2_layer)
-    primitivetype_to_extract = PrimitiveType(
-        min(
-            input1_layer_info.geometrytype.to_primitivetype.value,
-            input2_layer_info.geometrytype.to_primitivetype.value,
-        )
-    )
-
-    # Force MULTI variant if explodecollections is False to avoid ugly warnings/issues.
-    if explodecollections:
-        force_output_geometrytype = primitivetype_to_extract.to_singletype
-    else:
-        force_output_geometrytype = primitivetype_to_extract.to_multitype
-
-    # Prepare sql template for this operation
-    #
-    # Remarks:
-    # - ST_Intersects is fine, but ST_Touches slows down. Especially when the data
-    #   contains huge geoms, time doubles or worse. The filter on sub.geom IS NOT NULL
-    #   removes rows without intersection anyway.
-    # - use "LIMIT -1 OFFSET 0" to avoid the subquery flattening. Flattening e.g.
-    #   "geom IS NOT NULL" leads to geom operation to be calculated twice!
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        SELECT sub.geom
-             {{layer1_columns_from_subselect_str}}
-             {{layer2_columns_from_subselect_str}}
-          FROM
-            ( SELECT ST_CollectionExtract(
-                       ST_Intersection(
-                            layer1.{{input1_geometrycolumn}},
-                            layer2.{{input2_geometrycolumn}}),
-                            {primitivetype_to_extract.value}) AS geom
-                    {{layer1_columns_prefix_alias_str}}
-                    {{layer2_columns_prefix_alias_str}}
-                FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                  ON layer1.fid = layer1tree.id
-                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                  ON layer2.fid = layer2tree.id
-               WHERE 1=1
-                 {{batch_filter}}
-                 AND layer1tree.minx <= layer2tree.maxx
-                 AND layer1tree.maxx >= layer2tree.minx
-                 AND layer1tree.miny <= layer2tree.maxy
-                 AND layer1tree.maxy >= layer2tree.miny
-                 AND ST_Intersects(
-                        layer1.{{input1_geometrycolumn}},
-                        layer2.{{input2_geometrycolumn}}) = 1
-                 --AND ST_Touches(
-                 --       layer1.{{input1_geometrycolumn}},
-                 --       layer2.{{input2_geometrycolumn}}) = 0
-               LIMIT -1 OFFSET 0
-            ) sub
-         WHERE sub.geom IS NOT NULL
-    """
-
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name=f"{operation_prefix}intersection",
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-        output_with_spatial_index=output_with_spatial_index,
-    )
-
-
-def join_by_location(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    spatial_relations_query: str = "intersects is True",
-    discard_nonmatching: bool = True,
-    min_area_intersect: Optional[float] = None,
-    area_inters_column_name: Optional[str] = None,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Prepare sql template for this operation
-    # Prepare intersection area columns/filter
-    area_inters_column_expression = ""
-    area_inters_column_in_output = ""
-    area_inters_column_0_in_output = ""
-    area_inters_filter = ""
-    if area_inters_column_name is not None or min_area_intersect is not None:
-        if area_inters_column_name is not None:
-            area_inters_column_name_touse = area_inters_column_name
-            area_inters_column_in_output = f',"{area_inters_column_name}"'
-            area_inters_column_0_in_output = f',0 AS "{area_inters_column_name}"'
-        else:
-            area_inters_column_name_touse = "area_inters"
-        area_inters_column_expression = (
-            ",ST_area(ST_intersection(sub_filter.geom, sub_filter.l2_geom)) "
-            f'as "{area_inters_column_name_touse}"'
-        )
-        if min_area_intersect is not None:
-            area_inters_filter = (
-                f'WHERE sub_area."{area_inters_column_name_touse}" '
-                f">= {min_area_intersect}"
-            )
-
-    # Prepare spatial relations filter
-    if spatial_relations_query != "intersects is True":
-        # joining should only be possible on features that at least have an
-        # interaction! So, add "intersects is True" to query to avoid errors!
-        spatial_relations_query = f"({spatial_relations_query}) and intersects is True"
-    spatial_relations_filter = _prepare_spatial_relations_filter(
-        spatial_relations_query
-    )
-
-    # Prepare sql template
-    #
-    # Remark: use "LIMIT -1 OFFSET 0" to avoid that the sqlite query optimizer
-    #     "flattens" the subquery, as that makes checking the spatial
-    #     relations (using ST_RelateMatch) very slow!
-    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
-    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
-    sql_template = f"""
-        WITH layer1_relations_filtered AS (
-          SELECT sub_area.*
-            FROM (
-              SELECT sub_filter.*
-                    {area_inters_column_expression}
-                FROM (
-                  SELECT layer1.{{input1_geometrycolumn}} as geom
-                        ,layer1.fid l1_fid
-                        ,layer2.{{input2_geometrycolumn}} as l2_geom
-                        {{layer1_columns_prefix_alias_str}}
-                        {{layer2_columns_prefix_alias_str}}
-                        ,ST_relate(layer1.{{input1_geometrycolumn}},
-                                   layer2.{{input2_geometrycolumn}}) as spatial_relation
-                    FROM {{input1_databasename}}."{{input1_layer}}" layer1
-                    JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
-                      ON layer1.fid = layer1tree.id
-                    JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                    JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
-                      ON layer2.fid = layer2tree.id
-                   WHERE 1=1
-                     {{batch_filter}}
-                     AND layer1tree.minx <= layer2tree.maxx
-                     AND layer1tree.maxx >= layer2tree.minx
-                     AND layer1tree.miny <= layer2tree.maxy
-                     AND layer1tree.maxy >= layer2tree.miny
-                   LIMIT -1 OFFSET 0
-                  ) sub_filter
-               WHERE {spatial_relations_filter.format(
-                    spatial_relation="sub_filter.spatial_relation")}
-               LIMIT -1 OFFSET 0
-              ) sub_area
-           {area_inters_filter}
-          )
-        SELECT sub.geom
-              {{layer1_columns_from_subselect_str}}
-              {{layer2_columns_from_subselect_str}}
-              ,sub.spatial_relation
-              {area_inters_column_in_output}
-          FROM layer1_relations_filtered sub
-    """
-
-    # If a left join is asked, add all features from layer1 that weren't
-    # matched.
-    if discard_nonmatching is False:
-        sql_template = f"""
-            {sql_template}
-            UNION ALL
-            SELECT layer1.{{input1_geometrycolumn}} as geom
-                  {{layer1_columns_prefix_alias_str}}
-                  {{layer2_columns_prefix_alias_null_str}}
-                  ,NULL as spatial_relation
-                  {area_inters_column_0_in_output}
-              FROM {{input1_databasename}}."{{input1_layer}}" layer1
-             WHERE 1=1
-               {{batch_filter}}
-               AND layer1.fid NOT IN (
-                   SELECT l1_fid FROM layer1_relations_filtered)
-        """
-
-    # Go!
-    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
-    return _two_layer_vector_operation(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="join_by_location",
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=input1_layer_info.geometrytype,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def _prepare_spatial_relations_filter(query: str) -> str:
-    named_spatial_relations = {
-        # "disjoint": ["FF*FF****"],
-        "equals": ["TFFF*FFF*"],
-        "touches": ["FT*******", "F**T*****", "F***T****"],
-        "within": ["T*F**F***"],
-        "overlaps": ["T*T***T**", "1*T***T**"],
-        "crosses": ["T*T******", "T*****T**", "0********"],
-        "intersects": ["T********", "*T*******", "***T*****", "****T****"],
-        "contains": ["T*****FF*"],
-        "covers": ["T*****FF*", "*T****FF*", "***T**FF*", "****T*FF*"],
-        "coveredby": ["T*F**F***", "*TF**F***", "**FT*F***", "**F*TF***"],
-    }
-
-    # Parse query and replace things that need to be replaced
-    import re
-
-    query_tokens = re.split("([ =()])", query)
-
-    query_tokens_prepared = []
-    nb_unclosed_brackets = 0
-    for token in query_tokens:
-        if token == "":
-            continue
-        elif token in [" ", "\n", "\t", "and", "or"]:
-            query_tokens_prepared.append(token)
-        elif token == "(":
-            nb_unclosed_brackets += 1
-            query_tokens_prepared.append(token)
-        elif token == ")":
-            nb_unclosed_brackets -= 1
-            query_tokens_prepared.append(token)
-        elif token == "is":
-            query_tokens_prepared.append("=")
-        elif token == "True":
-            query_tokens_prepared.append("1")
-        elif token == "False":
-            query_tokens_prepared.append("0")
-        elif token in named_spatial_relations:
-            match_list = []
-            for spatial_relation in named_spatial_relations[token]:
-                match = (
-                    f"ST_RelateMatch({{spatial_relation}}, '{spatial_relation}') = 1"
-                )
-                match_list.append(match)
-            query_tokens_prepared.append(f"({' or '.join(match_list)})")
-        elif len(token) == 9 and re.fullmatch("^[FT012*]+$", token) is not None:
-            token_prepared = f"ST_RelateMatch({{spatial_relation}}, '{token}')"
-            query_tokens_prepared.append(token_prepared)
-        else:
-            raise ValueError(
-                f"Unexpected token in query (query is case sensitive!): {token}"
-            )
-
-    # If there are unclosed brackets, raise
-    if nb_unclosed_brackets > 0:
-        raise ValueError(f"not all brackets are closed in query {query}")
-    elif nb_unclosed_brackets < 0:
-        raise ValueError(f"more closing brackets than opening ones in query {query}")
-
-    result = f"({''.join(query_tokens_prepared)})"
-    return result
-
-
-def join_nearest(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    nb_nearest: int,
-    distance: float,
-    expand: bool,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    force: bool = False,
-):
-    # Init some things...
-    # Because there is preprocessing done in this function, check output path
-    # here already
-    logger = logging.getLogger("geofileops.join_nearest")
-    if output_path.exists() and force is False:
-        logger.info(f"Stop, output exists already {output_path}")
-        return
-    if input1_layer is None:
-        input1_layer = gfo.get_only_layer(input1_path)
-    if input2_layer is None:
-        input2_layer = gfo.get_only_layer(input2_path)
-
-    # If spatialite >= 5.1, check some more parameters
-    if SPATIALITE_GTE_51:
-        if distance is None:
-            raise ValueError("distance is mandatory with spatialite >= 5.1")
-        if expand is None:
-            raise ValueError("expand is mandatory with spatialite >= 5.1")
-        expand_int = 1 if expand else False
-    else:
-        if expand is not None and not expand:
-            raise ValueError("expand=False is not supported with spatialite < 5.1")
-
-    # Prepare input files
-    # To use knn index, the input layers need to be in sqlite file format
-    # (not a .gpkg!), so prepare this
-    if input1_path == input2_path and gfo.get_driver(input1_path) == "SQLite":
-        # Input files already ok...
-        input1_tmp_path = input1_path
-        input1_tmp_layer = input1_layer
-        input2_tmp_path = input2_path
-        input2_tmp_layer = input2_layer
-    else:
-        # Put input2 layer in sqlite gfo...
-        tempdir = _io_util.create_tempdir("geofileops/join_nearest")
-        input1_tmp_path = tempdir / "both_input_layers.sqlite"
-        input1_tmp_layer = "input1_layer"
-        gfo.copy_layer(
-            src=input1_path,
-            src_layer=input1_layer,
-            dst=input1_tmp_path,
-            dst_layer=input1_tmp_layer,
-            preserve_fid=True,
-        )
-
-        # Add input2 layer to sqlite gfo...
-        input2_tmp_path = input1_tmp_path
-        input2_tmp_layer = "input2_layer"
-        gfo.append_to(
-            src=input2_path,
-            src_layer=input2_layer,
-            dst=input2_tmp_path,
-            dst_layer=input2_tmp_layer,
-            preserve_fid=True,
-        )
-
-    # Remark: the 2 input layers need to be in one file!
-    if SPATIALITE_GTE_51:
-        sql_template = f"""
-            SELECT layer1.{{input1_geometrycolumn}} as geom
-                  {{layer1_columns_prefix_alias_str}}
-                  {{layer2_columns_prefix_alias_str}}
-                  ,k.pos, k.distance_m AS distance, k.distance_crs
-              FROM "{{input1_layer}}" layer1
-              JOIN knn2 k
-              JOIN "{{input2_layer}}" layer2 ON layer2.rowid = k.fid
-             WHERE f_table_name = '{{input2_layer}}'
-               AND f_geometry_column = '{{input2_geometrycolumn}}'
-               AND ref_geometry = ST_Centroid(layer1.{{input1_geometrycolumn}})
-               AND radius = {distance}
-               AND max_items = {nb_nearest}
-               AND expand = {expand_int}
-               {{batch_filter}}
-        """
-    else:
-        sql_template = f"""
-            SELECT layer1.{{input1_geometrycolumn}} as geom
-                  {{layer1_columns_prefix_alias_str}}
-                  {{layer2_columns_prefix_alias_str}}
-                  ,k.pos, k.distance
-              FROM {{input1_databasename}}."{{input1_layer}}" layer1
-              JOIN {{input2_databasename}}.knn k
-              JOIN {{input2_databasename}}."{{input2_layer}}" layer2
-                ON layer2.rowid = k.fid
-             WHERE k.f_table_name = '{{input2_layer}}'
-               AND k.f_geometry_column = '{{input2_geometrycolumn}}'
-               AND k.ref_geometry = layer1.{{input1_geometrycolumn}}
-               AND k.max_items = {nb_nearest}
-               {{batch_filter}}
-        """
-
-    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
-
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input1_tmp_path,
-        input2_path=input2_tmp_path,
-        output_path=output_path,
-        sql_template=sql_template,
-        operation_name="join_nearest",
-        input1_layer=input1_tmp_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_tmp_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        force_output_geometrytype=input1_layer_info.geometrytype,
-        explodecollections=explodecollections,
-        gridsize=0.0,
-        where_post=None,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-        use_ogr=True,
-    )
-
-
-def select_two_layers(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    sql_stmt: str,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    force_output_geometrytype: Optional[GeometryType] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = 1,
-    batchsize: int = -1,
-    force: bool = False,
-    operation_prefix: str = "",
-):
-    # Go!
-    return _two_layer_vector_operation(
-        input1_path=input1_path,
-        input2_path=input2_path,
-        output_path=output_path,
-        sql_template=sql_stmt,
-        operation_name=f"{operation_prefix}select_two_layers",
-        input1_layer=input1_layer,
-        input1_columns=input1_columns,
-        input1_columns_prefix=input1_columns_prefix,
-        input2_layer=input2_layer,
-        input2_columns=input2_columns,
-        input2_columns_prefix=input2_columns_prefix,
-        output_layer=output_layer,
-        explodecollections=explodecollections,
-        force_output_geometrytype=force_output_geometrytype,
-        gridsize=gridsize,
-        where_post=where_post,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        force=force,
-    )
-
-
-def identity(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = 1,
-    batchsize: int = -1,
-    subdivide_coords: int = 2000,
-    force: bool = False,
-):
-    # An identity is the combination of the results of an "intersection" of input1 and
-    # input2 and an erase of input2 with input1.
-
-    # Because the calculations of the intermediate results will be towards temp files,
-    # we need to do some additional init + checks here...
-    logger = logging.getLogger("geofileops.identity")
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop, output exists already {output_path}")
-            return
-        else:
-            gfo.remove(output_path)
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    start_time = datetime.now()
-    tempdir = _io_util.create_tempdir("geofileops/identity")
-    try:
-        # First calculate intersection of input1 with input2 to a temporary output file
-        logger.info("Step 1 of 3: intersection")
-        intersection_output_path = tempdir / "intersection_output.gpkg"
-        intersection(
-            input1_path=input1_path,
-            input2_path=input2_path,
-            output_path=intersection_output_path,
-            input1_layer=input1_layer,
-            input1_columns=input1_columns,
-            input1_columns_prefix=input1_columns_prefix,
-            input2_layer=input2_layer,
-            input2_columns=input2_columns,
-            input2_columns_prefix=input2_columns_prefix,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-            output_with_spatial_index=False,
-            operation_prefix="identity/",
-        )
-
-        # Now erase input1 from input2 to another temporary output gfo...
-        logger.info("Step 2 of 3: erase")
-        erase_output_path = tempdir / "erase_output.gpkg"
-        erase(
-            input_path=input1_path,
-            erase_path=input2_path,
-            output_path=erase_output_path,
-            input_layer=input1_layer,
-            input_columns=input1_columns,
-            input_columns_prefix=input1_columns_prefix,
-            erase_layer=input2_layer,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            subdivide_coords=subdivide_coords,
-            force=force,
-            output_with_spatial_index=False,
-            operation_prefix="identity/",
-        )
-
-        # Now append
-        logger.info("Step 3 of 3: finalize")
-        # Note: append will never create an index on an already existing layer.
-        _append_to_nolock(
-            src=erase_output_path,
-            dst=intersection_output_path,
-            src_layer=output_layer,
-            dst_layer=output_layer,
-        )
-
-        # Convert or add spatial index
-        tmp_output_path = intersection_output_path
-        if intersection_output_path.suffix != output_path.suffix:
-            # Output file should be in different format, so convert
-            tmp_output_path = tempdir / output_path.name
-            gfo.copy_layer(src=intersection_output_path, dst=tmp_output_path)
-        else:
-            # Create spatial index
-            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
-
-        # Now we are ready to move the result to the final spot...
-        gfo.move(tmp_output_path, output_path)
-
-    finally:
-        shutil.rmtree(tempdir, ignore_errors=True)
-
-    logger.info(f"Ready, full identity took {datetime.now()-start_time}")
-
-
-def symmetric_difference(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    subdivide_coords: int = 2000,
-    force: bool = False,
-):
-    # A symmetric difference can be simulated by doing an "erase" of input1
-    # and input2 and then append the result of an erase of input2 with
-    # input1...
-
-    # Because both erase calculations will be towards temp files,
-    # we need to do some additional init + checks here...
-    if force is False and output_path.exists():
-        return
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    start_time = datetime.now()
-    logger = logging.getLogger("geofileops.symmetric_difference")
-    logger.info(
-        f"Start, with input1: {input1_path}, "
-        f"input2: {input2_path}, output: {output_path}"
-    )
-    tempdir = _io_util.create_tempdir("geofileops/symmdiff")
-    try:
-        # First erase input2 from input1 to a temporary output file
-        logger.info("Step 1 of 3: erase 1")
-        erase1_output_path = tempdir / "layer1_erase_layer2_output.gpkg"
-        erase(
-            input_path=input1_path,
-            erase_path=input2_path,
-            output_path=erase1_output_path,
-            input_layer=input1_layer,
-            input_columns=input1_columns,
-            input_columns_prefix=input1_columns_prefix,
-            erase_layer=input2_layer,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            subdivide_coords=subdivide_coords,
-            force=force,
-            output_with_spatial_index=False,
-            operation_prefix="symmetric_difference/",
-        )
-
-        if input2_columns is None or len(input2_columns) > 0:
-            input2_info = gfo.get_layerinfo(input2_path)
-            columns_to_add = (
-                input2_columns if input2_columns is not None else input2_info.columns
-            )
-            for column in columns_to_add:
-                gfo.add_column(
-                    erase1_output_path,
-                    name=f"{input2_columns_prefix}{column}",
-                    type=input2_info.columns[column].gdal_type,
-                )
-
-        # Now erase input1 from input2 to another temporary output file
-        logger.info("Step 2 of 3: erase 2")
-        erase2_output_path = tempdir / "layer2_erase_layer1_output.gpkg"
-        erase(
-            input_path=input2_path,
-            erase_path=input1_path,
-            output_path=erase2_output_path,
-            input_layer=input2_layer,
-            input_columns=input2_columns,
-            input_columns_prefix=input2_columns_prefix,
-            erase_layer=input1_layer,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            subdivide_coords=subdivide_coords,
-            force=force,
-            output_with_spatial_index=False,
-            operation_prefix="symmetric_difference/",
-        )
-
-        # Now append
-        logger.info("Step 3 of 3: finalize")
-        # Note: append will never create an index on an already existing layer.
-        _append_to_nolock(
-            src=erase2_output_path,
-            dst=erase1_output_path,
-            src_layer=output_layer,
-            dst_layer=output_layer,
-        )
-
-        # Convert or add spatial index
-        tmp_output_path = erase1_output_path
-        if erase1_output_path.suffix != output_path.suffix:
-            # Output file should be in diffent format, so convert
-            tmp_output_path = tempdir / output_path.name
-            gfo.copy_layer(src=erase1_output_path, dst=tmp_output_path)
-        else:
-            # Create spatial index
-            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
-
-        # Now we are ready to move the result to the final spot...
-        if output_path.exists():
-            gfo.remove(output_path)
-        gfo.move(tmp_output_path, output_path)
-
-    finally:
-        shutil.rmtree(tempdir, ignore_errors=True)
-
-    logger.info(f"Ready, full symmetric_difference took {datetime.now()-start_time}")
-
-
-def union(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    input1_layer: Optional[str] = None,
-    input1_columns: Optional[List[str]] = None,
-    input1_columns_prefix: str = "l1_",
-    input2_layer: Optional[str] = None,
-    input2_columns: Optional[List[str]] = None,
-    input2_columns_prefix: str = "l2_",
-    output_layer: Optional[str] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    where_post: Optional[str] = None,
-    nb_parallel: int = -1,
-    batchsize: int = -1,
-    subdivide_coords: int = 2000,
-    force: bool = False,
-):
-    # A union is the combination of the results of an intersection of input1 and input2,
-    # the result of an erase of input2 with input1 and the erase of input1 with input2.
-
-    # Because the calculations of the intermediate results will be towards temp files,
-    # we need to do some additional init + checks here...
-    logger = logging.getLogger("geofileops.union")
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop, output exists already {output_path}")
-            return
-        else:
-            gfo.remove(output_path)
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    start_time = datetime.now()
-    tempdir = _io_util.create_tempdir("geofileops/union")
-    try:
-        # First apply intersection of input1 with input2 to a temporary output file...
-        logger.info("Step 1 of 4: intersection")
-        intersection_output_path = tempdir / "intersection_output.gpkg"
-        intersection(
-            input1_path=input1_path,
-            input2_path=input2_path,
-            output_path=intersection_output_path,
-            input1_layer=input1_layer,
-            input1_columns=input1_columns,
-            input1_columns_prefix=input1_columns_prefix,
-            input2_layer=input2_layer,
-            input2_columns=input2_columns,
-            input2_columns_prefix=input2_columns_prefix,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            force=force,
-            output_with_spatial_index=False,
-            operation_prefix="union/",
-        )
-
-        # Now erase input1 from input2 to another temporary output gfo...
-        logger.info("Step 2 of 4: erase input 1 from input 2")
-        erase1_output_path = tempdir / "erase_input1_from_input2_output.gpkg"
-        erase(
-            input_path=input2_path,
-            erase_path=input1_path,
-            output_path=erase1_output_path,
-            input_layer=input2_layer,
-            input_columns=input2_columns,
-            input_columns_prefix=input2_columns_prefix,
-            erase_layer=input1_layer,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            subdivide_coords=subdivide_coords,
-            force=force,
-            output_with_spatial_index=False,
-            operation_prefix="union/",
-        )
-
-        # Now erase input2 from input1 to another temporary output gfo...
-        logger.info("Step 3 of 4: erase input 2 from input 1")
-        erase2_output_path = tempdir / "erase_input2_from_input1_output.gpkg"
-        erase(
-            input_path=input1_path,
-            erase_path=input2_path,
-            output_path=erase2_output_path,
-            input_layer=input1_layer,
-            input_columns=input1_columns,
-            input_columns_prefix=input1_columns_prefix,
-            erase_layer=input2_layer,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            gridsize=gridsize,
-            where_post=where_post,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            subdivide_coords=subdivide_coords,
-            force=force,
-            output_with_spatial_index=False,
-            operation_prefix="union/",
-        )
-
-        # Now append
-        logger.info("Step 4 of 4: finalize")
-        # Note: append will never create an index on an already existing layer.
-        _append_to_nolock(
-            src=erase1_output_path,
-            dst=intersection_output_path,
-            src_layer=output_layer,
-            dst_layer=output_layer,
-        )
-        _append_to_nolock(
-            src=erase2_output_path,
-            dst=intersection_output_path,
-            src_layer=output_layer,
-            dst_layer=output_layer,
-        )
-
-        # Convert or add spatial index
-        tmp_output_path = intersection_output_path
-        if intersection_output_path.suffix != output_path.suffix:
-            # Output file should be in different format, so convert
-            tmp_output_path = tempdir / output_path.name
-            gfo.copy_layer(src=intersection_output_path, dst=tmp_output_path)
-        else:
-            # Create spatial index
-            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
-
-        # Now we are ready to move the result to the final spot...
-        gfo.move(tmp_output_path, output_path)
-
-    finally:
-        shutil.rmtree(tempdir, ignore_errors=True)
-
-    logger.info(f"Ready, full union took {datetime.now()-start_time}")
-
-
-def _two_layer_vector_operation(
-    input1_path: Path,
-    input2_path: Path,
-    output_path: Path,
-    sql_template: str,
-    operation_name: str,
-    input1_layer: Optional[str],
-    input1_columns: Optional[List[str]],
-    input1_columns_prefix: str,
-    input2_layer: Optional[str],
-    input2_columns: Optional[List[str]],
-    input2_columns_prefix: str,
-    output_layer: Optional[str],
-    explodecollections: bool,
-    force_output_geometrytype: Optional[GeometryType],
-    gridsize: float,
-    where_post: Optional[str],
-    nb_parallel: int,
-    batchsize: int,
-    force: bool,
-    use_ogr: bool = False,
-    output_with_spatial_index: bool = True,
-):
-    """
-    Executes an operation that needs 2 input files.
-
-    Args:
-        input1_path (str): the file to export features from
-        input2_path (str): the file to check intersections with
-        output_path (str): output file
-                input1_layer (str, optional): input layer name. Optional if the
-            file only contains one layer. Defaults to None.
-        operation_name (str): name of the operation to be used in logging.
-        sql_template (str): the SELECT sql statement to be executed.
-        input1_layer (str): input1 layer name.
-        input1_columns (List[str]): list of columns to retain. If None, all
-            standard columns are retained. In addition to standard columns, it is also
-            possible to specify "fid", a unique index available in all input files. Note
-            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
-            "fid_1".
-        input1_columns_prefix (str): prefix to use in the column aliases.
-        input2_layer (str): input2 layer name.
-        input2_columns (List[str]): columns to select. If None is specified,
-            all columns are selected. As explained for input1_columns, it is also
-            possible to specify "fid".
-        input2_columns_prefix (str): prefix to use in the column aliases.
-        output_layer (str): [description]. Defaults to None.
-        explodecollections (bool, optional): Explode collecions in output.
-            Defaults to False.
-        force_output_geometrytype (GeometryType, optional): Defaults to None.
-        gridsize (float, optional): the size of the grid the coordinates of the ouput
-            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
-            the precision. Defaults to 0.0.
-        where_post (str, optional): sql filter to apply after all other processing,
-            including e.g. explodecollections. It should be in sqlite syntax and
-            |spatialite_reference_link| functions can be used. Defaults to None.
-        nb_parallel (int, optional): [description]. Defaults to -1.
-        batchsize (int, optional): indicative number of rows to process per
-            batch. A smaller batch size, possibly in combination with a
-            smaller nb_parallel, will reduce the memory usage.
-            Defaults to -1: (try to) determine optimal size automatically.
-        force (bool, optional): [description]. Defaults to False.
-        use_ogr (bool, optional): If True, ogr is used to do the processing,
-            In this case different input files (input1_path, input2_path) are
-            NOT supported. If False, sqlite3 is used directly.
-            Defaults to False.
-        output_with_spatial_index (bool, optional): True to create output file with
-            spatial index. Defaults to True.
-
-    Raises:
-        ValueError: [description]
-
-    .. |spatialite_reference_link| raw:: html
-
-        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
-
-    """  # noqa: E501
-    # Init
-    logger = logging.getLogger(f"geofileops.{operation_name}")
-
-    if not input1_path.exists():
-        raise ValueError(f"{operation_name}: input1_path doesn't exist: {input1_path}")
-    if not input2_path.exists():
-        raise ValueError(f"{operation_name}: input2_path doesn't exist: {input2_path}")
-    if output_path in (input1_path, input2_path):
-        raise ValueError(
-            f"{operation_name}: output_path must not equal one of input paths"
-        )
-    if use_ogr is True and input1_path != input2_path:
-        raise ValueError(
-            f"{operation_name}: if use_ogr True, input1_path should equal input2_path!"
-        )
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop, output exists already {output_path}")
-            return
-        else:
-            gfo.remove(output_path)
-
-    # Check if spatialite is properly installed to execute this query
-    _sqlite_util.spatialite_version_info()
-
-    # Init layer info
-    start_time = datetime.now()
-    if input1_layer is None:
-        input1_layer = gfo.get_only_layer(input1_path)
-    if input2_layer is None:
-        input2_layer = gfo.get_only_layer(input2_path)
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-    tempdir = _io_util.create_tempdir(f"geofileops/{operation_name}")
-
-    # Prepare output filename
-    tmp_output_path = tempdir / output_path.name
-    tmp_output_path.parent.mkdir(exist_ok=True, parents=True)
-    gfo.remove(tmp_output_path)
-
-    try:
-        # Prepare tmp files/batches
-        # -------------------------
-        logger.debug(f"Prepare input (params), tempdir: {tempdir}")
-        processing_params = _prepare_processing_params(
-            input1_path=input1_path,
-            input1_layer=input1_layer,
-            input1_layer_alias="layer1",
-            input2_path=input2_path,
-            input2_layer=input2_layer,
-            tempdir=tempdir,
-            nb_parallel=nb_parallel,
-            batchsize=batchsize,
-            convert_to_spatialite_based=True,
-        )
-        if processing_params is None or processing_params.batches is None:
-            return
-
-        # Do some checks on the placeholders
-        sql_template_placeholders = [
-            name for _, name, _, _ in string.Formatter().parse(sql_template) if name
-        ]
-
-        # Warn no if "{input*_databasename}". placeholders present
-        if "input1_databasename" not in sql_template_placeholders:
-            logger.warning(
-                'A placeholder "{input1_databasename}". is recommended '
-                "as prefix for the input1 layer/rtree/tables used in sql_stmt."
-            )
-        if "input2_databasename" not in sql_template_placeholders:
-            logger.warning(
-                'A placeholder "{input2_databasename}". is recommended '
-                "as prefix for the input2 layer/rtree/tables used in sql_stmt."
-            )
-
-        # If multiple batches, mandatory "batch_filter" placeholder in sql_template
-        nb_batches = len(processing_params.batches)
-        if nb_batches > 1:
-            if "batch_filter" not in sql_template_placeholders:
-                raise ValueError(
-                    "Number batches > 1 requires a batch_filter placeholder in "
-                    f"sql_template {sql_template}"
-                )
-
-        # Prepare column names,... to format the select
-        # ---------------------------------------------
-        # Format column strings for use in select
-        assert processing_params.input1_path is not None
-        input1_tmp_layerinfo = gfo.get_layerinfo(
-            processing_params.input1_path,
-            processing_params.input1_layer,
-            raise_on_nogeom=False,
-        )
-        input1_col_strs = _ogr_sql_util.ColumnFormatter(
-            columns_asked=input1_columns,
-            columns_in_layer=input1_tmp_layerinfo.columns,
-            fid_column=input1_tmp_layerinfo.fid_column,
-            table_alias="layer1",
-            column_alias_prefix=input1_columns_prefix,
-        )
-        assert processing_params.input2_path is not None
-        input2_tmp_layerinfo = gfo.get_layerinfo(
-            processing_params.input2_path,
-            processing_params.input2_layer,
-            raise_on_nogeom=False,
-        )
-        input2_col_strs = _ogr_sql_util.ColumnFormatter(
-            columns_asked=input2_columns,
-            columns_in_layer=input2_tmp_layerinfo.columns,
-            fid_column=input2_tmp_layerinfo.fid_column,
-            table_alias="layer2",
-            column_alias_prefix=input2_columns_prefix,
-        )
-
-        # Check input crs'es
-        if input1_tmp_layerinfo.crs != input2_tmp_layerinfo.crs:
-            logger.warning(
-                f"input1 has a different crs than input2: \n\tinput1: "
-                f"{input1_tmp_layerinfo.crs} \n\tinput2: {input2_tmp_layerinfo.crs}"
-            )
-
-        # Fill out sql_template as much as possible already
-        # -------------------------------------------------
-        # Keep input1_tmp_layer and input2_tmp_layer for backwards compatibility
-        sql_template = sql_template.format(
-            input1_databasename="{input1_databasename}",
-            input2_databasename="{input2_databasename}",
-            layer1_columns_from_subselect_str=input1_col_strs.from_subselect(),
-            layer1_columns_prefix_alias_str=input1_col_strs.prefixed_aliased(),
-            layer1_columns_prefix_str=input1_col_strs.prefixed(),
-            input1_layer=processing_params.input1_layer,
-            input1_tmp_layer=processing_params.input1_layer,
-            input1_geometrycolumn=input1_tmp_layerinfo.geometrycolumn,
-            layer2_columns_from_subselect_str=input2_col_strs.from_subselect(),
-            layer2_columns_prefix_alias_str=input2_col_strs.prefixed_aliased(),
-            layer2_columns_prefix_str=input2_col_strs.prefixed(),
-            layer2_columns_prefix_alias_null_str=input2_col_strs.null_aliased(),
-            input2_layer=processing_params.input2_layer,
-            input2_tmp_layer=processing_params.input2_layer,
-            input2_geometrycolumn=input2_tmp_layerinfo.geometrycolumn,
-            batch_filter="{batch_filter}",
-        )
-
-        # Determine column names and types based on sql statement
-        column_datatypes = None
-        # Use first batch_filter to improve performance
-        sql_stmt = sql_template.format(
-            input1_databasename="{input1_databasename}",
-            input2_databasename="{input2_databasename}",
-            batch_filter=processing_params.batches[0]["batch_filter"],
-        )
-        column_datatypes = _sqlite_util.get_columns(
-            sql_stmt=sql_stmt,
-            input1_path=processing_params.input1_path,
-            input2_path=processing_params.input2_path,
-        )
-
-        # Apply gridsize if it is specified
-        if gridsize != 0.0:
-            if SPATIALITE_GTE_51:
-                # Spatialite >= 5.1 available, so we can try ST_ReducePrecision first,
-                # which should be faster.
-                gridsize_op = f"""
-                    IIF(sub_gridsize.geom IS NULL,
-                        NULL,
-                        IFNULL(
-                            ST_ReducePrecision(sub_gridsize.geom, {gridsize}),
-                            ST_GeomFromWKB(GFO_ReducePrecision(
-                                ST_AsBinary(sub_gridsize.geom), {gridsize}
-                            ))
-                        )
-                    )
-                """
-            else:
-                gridsize_op = (
-                    "ST_GeomFromWKB(GFO_ReducePrecision("
-                    f"ST_AsBinary(sub_gridsize.geom), {gridsize}))"
-                )
-
-            # All columns need to be specified
-            # Remark:
-            # - use "LIMIT -1 OFFSET 0" to avoid the subquery flattening. Flattening
-            #   "geom IS NOT NULL" leads to GFO_Difference_Collection calculated double!
-            cols = [col for col in column_datatypes if col.lower() != "geom"]
-            columns_to_select = _ogr_sql_util.columns_quoted(cols)
-            sql_template = f"""
-                SELECT {gridsize_op} AS geom
-                        {columns_to_select}
-                  FROM ( {sql_template}
-                         LIMIT -1 OFFSET 0
-                  ) sub_gridsize
-            """
-
-        # Prepare/apply where_post parameter
-        if where_post is not None and not explodecollections:
-            # explodecollections is not True, so we can add where_post to sql_stmt.
-            # If explodecollections would be True, we need to wait to apply the
-            # where_post till after explodecollections is applied, so when appending the
-            # partial results to the output file.
-            sql_template = f"""
-                SELECT * FROM
-                    ( {sql_template}
-                      LIMIT -1 OFFSET 0
-                    )
-                 WHERE {where_post}
-            """
-            # where_post has been applied already so set to None.
-            where_post = None
-
-        # Calculate
-        # ---------
-        # Processing in threads is 2x faster for small datasets (on Windows)
-        calculate_in_threads = (
-            True if input1_tmp_layerinfo.featurecount <= 100 else False
-        )
-        logger.info(
-            f"Start processing ({processing_params.nb_parallel} "
-            f"parallel workers, batch size: {processing_params.batchsize})"
-        )
-        with _processing_util.PooledExecutorFactory(
-            threadpool=calculate_in_threads,
-            max_workers=processing_params.nb_parallel,
-            initializer=_processing_util.initialize_worker(),
-        ) as calculate_pool:
-            # Start looping
-            batches: Dict[int, dict] = {}
-            future_to_batch_id = {}
-            for batch_id in processing_params.batches:
-                batches[batch_id] = {}
-                batches[batch_id]["layer"] = output_layer
-
-                tmp_partial_output_path = (
-                    tempdir / f"{output_path.stem}_{batch_id}.gpkg"
-                )
-                batches[batch_id]["tmp_partial_output_path"] = tmp_partial_output_path
-
-                # Fill out final things in sql_template
-                sql_stmt = sql_template.format(
-                    input1_databasename="{input1_databasename}",
-                    input2_databasename="{input2_databasename}",
-                    batch_filter=processing_params.batches[batch_id]["batch_filter"],
-                )
-                batches[batch_id]["sqlite_stmt"] = sql_stmt
-
-                # calculate_two_layers doesn't support explodecollections in one step:
-                # there is an extra layer copy involved.
-                # Normally explodecollections can be deferred to the appending of the
-                # partial files, but if explodecollections and there is a where_post to
-                # be applied, it needs to be applied now already. Otherwise the
-                # where_post in the append of partial files later on won't give correct
-                # results!
-                explodecollections_now = False
-                output_geometrytype_now = force_output_geometrytype
-                if explodecollections and where_post is not None:
-                    explodecollections_now = True
-                if (
-                    force_output_geometrytype is not None
-                    and explodecollections
-                    and not explodecollections_now
-                ):
-                    # convert geometrytype to multitype to avoid ogr warnings
-                    output_geometrytype_now = force_output_geometrytype.to_multitype
-
-                # Remark: this temp file doesn't need spatial index
-                future = calculate_pool.submit(
-                    calculate_two_layers,
-                    input1_path=processing_params.batches[batch_id]["input1_path"],
-                    input1_layer=processing_params.batches[batch_id]["input1_layer"],
-                    input2_path=processing_params.batches[batch_id]["input2_path"],
-                    input2_layer=processing_params.batches[batch_id]["input2_layer"],
-                    output_path=tmp_partial_output_path,
-                    sql_stmt=sql_stmt,
-                    output_layer=output_layer,
-                    explodecollections=explodecollections_now,
-                    force_output_geometrytype=output_geometrytype_now,
-                    use_ogr=use_ogr,
-                    create_spatial_index=False,
-                    column_datatypes=column_datatypes,
-                )
-                future_to_batch_id[future] = batch_id
-
-            # Loop till all parallel processes are ready, but process each one
-            # that is ready already
-            nb_done = 0
-            _general_util.report_progress(
-                start_time,
-                nb_done,
-                nb_batches,
-                operation_name,
-                processing_params.nb_parallel,
-            )
-            for future in futures.as_completed(future_to_batch_id):
-                try:
-                    # Get the result
-                    result = future.result()
-                    if result is not None:
-                        logger.debug(f"{result}")
-                except Exception as ex:
-                    batch_id = future_to_batch_id[future]
-                    error = str(ex).partition("\n")[0]
-                    message = f"Error <{error}> executing {batches[batch_id]}"
-                    logger.exception(message)
-                    raise Exception(message) from ex
-
-                # If the calculate gave results, copy/append to output
-                batch_id = future_to_batch_id[future]
-                tmp_partial_output_path = batches[batch_id]["tmp_partial_output_path"]
-                nb_done += 1
-
-                # Normally all partial files should exist, but to be sure...
-                if not tmp_partial_output_path.exists():
-                    logger.warning(f"Result file {tmp_partial_output_path} not found")
-                    continue
-
-                # If there is only one tmp_partial file and it is already ok as
-                # output file, just rename/move it.
-                if (
-                    nb_batches == 1
-                    and not explodecollections
-                    and force_output_geometrytype is None
-                    and where_post is None
-                    and tmp_partial_output_path.suffix.lower()
-                    == tmp_output_path.suffix.lower()
-                ):
-                    gfo.move(tmp_partial_output_path, tmp_output_path)
-                else:
-                    # If there is only one batch, it is faster to create the spatial
-                    # index immediately
-                    create_spatial_index = False
-                    if nb_batches == 1 and output_with_spatial_index:
-                        create_spatial_index = True
-
-                    fileops._append_to_nolock(
-                        src=tmp_partial_output_path,
-                        dst=tmp_output_path,
-                        explodecollections=explodecollections,
-                        force_output_geometrytype=force_output_geometrytype,
-                        where=where_post,
-                        create_spatial_index=create_spatial_index,
-                        preserve_fid=False,
-                    )
-                    gfo.remove(tmp_partial_output_path)
-
-                # Log the progress and prediction speed
-                _general_util.report_progress(
-                    start_time=start_time,
-                    nb_done=nb_done,
-                    nb_todo=nb_batches,
-                    operation=operation_name,
-                    nb_parallel=processing_params.nb_parallel,
-                )
-
-        # Round up and clean up
-        # Now create spatial index and move to output location
-        if tmp_output_path.exists():
-            if output_with_spatial_index:
-                gfo.create_spatial_index(
-                    path=tmp_output_path,
-                    layer=output_layer,
-                    exist_ok=True,
-                    no_geom_ok=True,
-                )
-            if tmp_output_path != output_path:
-                output_path.parent.mkdir(parents=True, exist_ok=True)
-                gfo.move(tmp_output_path, output_path)
-        else:
-            logger.debug("Result was empty!")
-
-        logger.info(f"Ready, took {datetime.now()-start_time}")
-    except Exception:
-        gfo.remove(output_path, missing_ok=True)
-        gfo.remove(tmp_output_path, missing_ok=True)
-        raise
-    finally:
-        shutil.rmtree(tempdir, ignore_errors=True)
-
-
-def calculate_two_layers(
-    input1_path: Path,
-    input1_layer: str,
-    input2_path: Path,
-    input2_layer: str,
-    output_path: Path,
-    sql_stmt: str,
-    output_layer: str,
-    explodecollections: bool,
-    force_output_geometrytype: Optional[GeometryType],
-    create_spatial_index: bool,
-    column_datatypes: dict,
-    use_ogr: bool,
-):
-    if use_ogr is False:
-        # If explodecollections, write first to tmp file, then apply explodecollections
-        # to the final output file.
-        output_tmp_path = output_path
-        if explodecollections:
-            output_name = f"{output_path.stem}_tmp{output_path.suffix}"
-            output_tmp_path = output_path.parent / output_name
-        _sqlite_util.create_table_as_sql(
-            input1_path=input1_path,
-            input1_layer=input1_layer,
-            input2_path=input2_path,
-            input2_layer=input2_layer,
-            output_path=output_tmp_path,
-            sql_stmt=sql_stmt,
-            output_layer=output_layer,
-            output_geometrytype=force_output_geometrytype,
-            create_spatial_index=create_spatial_index,
-            profile=_sqlite_util.SqliteProfile.SPEED,
-            column_datatypes=column_datatypes,
-        )
-        if explodecollections:
-            _ogr_util.vector_translate(
-                input_path=output_tmp_path,
-                input_layers=output_layer,
-                output_path=output_path,
-                output_layer=output_layer,
-                explodecollections=explodecollections,
-                force_output_geometrytype=force_output_geometrytype,
-                options={"LAYER_CREATION.SPATIAL_INDEX": create_spatial_index},
-                preserve_fid=False,
-            )
-            gfo.remove(output_tmp_path)
-    else:
-        # Use ogr to run the query
-        #   * input2 path (= using attach) doesn't seem to work
-        #   * ogr doesn't fill out database names, so do it now
-        sql_stmt = sql_stmt.format(
-            input1_databasename="main",
-            input2_databasename="main",
-        )
-
-        _ogr_util.vector_translate(
-            input_path=input1_path,
-            output_path=output_path,
-            sql_stmt=sql_stmt,
-            output_layer=output_layer,
-            explodecollections=explodecollections,
-            force_output_geometrytype=force_output_geometrytype,
-            options={"LAYER_CREATION.SPATIAL_INDEX": create_spatial_index},
-        )
-
-
-class ProcessingParams:
-    def __init__(
-        self,
-        input1_path: Path,
-        input1_layer: str,
-        input2_path: Optional[Path],
-        input2_layer: Optional[str],
-        nb_parallel: int,
-        batches: dict,
-        batchsize: int,
-    ):
-        self.input1_path = input1_path
-        self.input1_layer = input1_layer
-        self.input2_path = input2_path
-        self.input2_layer = input2_layer
-        self.nb_parallel = nb_parallel
-        self.batches = batches
-        self.batchsize = batchsize
-
-    def to_json(self, path: Path):
-        prepared = _general_util.prepare_for_serialize(vars(self))
-        with open(path, "w") as file:
-            file.write(json.dumps(prepared, indent=4, sort_keys=True))
-
-
-def _prepare_processing_params(
-    input1_path: Path,
-    input1_layer: str,
-    tempdir: Path,
-    convert_to_spatialite_based: bool,
-    nb_parallel: int,
-    batchsize: int = -1,
-    input1_layer_alias: Optional[str] = None,
-    input2_path: Optional[Path] = None,
-    input2_layer: Optional[str] = None,
-) -> Optional[ProcessingParams]:
-    # Init
-    input1_layerinfo = gfo.get_layerinfo(
-        input1_path, input1_layer, raise_on_nogeom=False
-    )
-
-    # Prepare input files for the calculation
-    if convert_to_spatialite_based:
-        # Check if the input files are of the correct geofiletype
-        input1_info = _geofileinfo.get_geofileinfo(input1_path)
-        input2_info = (
-            None if input2_path is None else _geofileinfo.get_geofileinfo(input2_path)
-        )
-
-        # If input files are of the same format + are spatialite compatible,
-        # just use them
-        if input1_info.is_spatialite_based and (
-            input2_info is None or input1_info.driver == input2_info.driver
-        ):
-            if (
-                input1_info.driver == "GPKG"
-                and input1_layerinfo.geometrycolumn is not None
-            ):
-                # HasSpatialindex doesn't work for spatialite file
-                gfo.create_spatial_index(input1_path, input1_layer, exist_ok=True)
-        else:
-            # If not ok, copy the input layer to gpkg
-            input1_tmp_path = tempdir / f"{input1_path.stem}.gpkg"
-            gfo.copy_layer(
-                src=input1_path,
-                src_layer=input1_layer,
-                dst=input1_tmp_path,
-                dst_layer=input1_layer,
-                preserve_fid=True,
-            )
-            input1_path = input1_tmp_path
-
-        if input2_path is not None and input2_info is not None:
-            if (
-                input2_info.driver == input1_info.driver
-                and input2_info.is_spatialite_based
-            ):
-                input2_layerinfo = gfo.get_layerinfo(
-                    input2_path, input2_layer, raise_on_nogeom=False
-                )
-                if (
-                    input2_info.driver == "GPKG"
-                    and input2_layerinfo.geometrycolumn is not None
-                ):
-                    # HasSpatialindex doesn't work for spatialite file
-                    gfo.create_spatial_index(input2_path, input2_layer, exist_ok=True)
-            else:
-                # If not spatialite compatible, copy the input layer to gpkg
-                input2_tmp_path = tempdir / f"{input2_path.stem}.gpkg"
-                gfo.copy_layer(
-                    src=input2_path,
-                    src_layer=input2_layer,
-                    dst=input2_tmp_path,
-                    dst_layer=input2_layer,
-                    preserve_fid=True,
-                )
-                input2_path = input2_tmp_path
-
-    # Prepare batches to process
-    layer1_info = gfo.get_layerinfo(input1_path, input1_layer, raise_on_nogeom=False)
-    nb_rows_input_layer = layer1_info.featurecount
-
-    # Determine optimal number of batches
-    nb_parallel, nb_batches = _determine_nb_batches(
-        nb_rows_input_layer=nb_rows_input_layer,
-        nb_parallel=nb_parallel,
-        batchsize=batchsize,
-        is_twolayer_operation=input2_path is not None,
-    )
-
-    # Check number of batches + appoint nb rows to batches
-    batches: Dict[int, dict] = {}
-    if nb_batches == 1:
-        # If only one batch, no filtering is needed
-        batches[0] = {}
-        batches[0]["input1_path"] = input1_path
-        batches[0]["input1_layer"] = input1_layer
-        batches[0]["input2_path"] = input2_path
-        batches[0]["input2_layer"] = input2_layer
-        batches[0]["batch_filter"] = ""
-    else:
-        # Determine the min_rowid and max_rowid
-        # Remark: SELECT MIN(rowid), MAX(rowid) FROM ... is a lot slower than UNION ALL!
-        sql_stmt = f"""
-            SELECT MIN(rowid) minmax_rowid FROM "{layer1_info.name}"
-            UNION ALL
-            SELECT MAX(rowid) minmax_rowid FROM "{layer1_info.name}"
-        """
-        batch_info_df = gfo.read_file(
-            path=input1_path, sql_stmt=sql_stmt, sql_dialect="SQLITE"
-        )
-        min_rowid = pd.to_numeric(batch_info_df["minmax_rowid"][0]).item()
-        max_rowid = pd.to_numeric(batch_info_df["minmax_rowid"][1]).item()
-
-        # Determine the exact batches to use
-        if ((max_rowid - min_rowid) / nb_rows_input_layer) < 1.1:
-            # If the rowid's are quite consecutive, use an imperfect, but
-            # fast distribution in batches
-            batch_info_list = []
-            nb_rows_per_batch = round(nb_rows_input_layer / nb_batches)
-            start_rowid = min_rowid
-            offset_per_batch = round((max_rowid - min_rowid) / nb_batches)
-            for batch_id in range(nb_batches):
-                if batch_id < (nb_batches - 1):
-                    # End rowid for this batch is the next start_rowid - 1
-                    end_rowid = start_rowid + offset_per_batch - 1
-                else:
-                    # For the last batch, take the max_rowid so no rowid's are
-                    # 'lost' due to rounding errors
-                    end_rowid = max_rowid
-                batch_info_list.append(
-                    (batch_id, nb_rows_per_batch, start_rowid, end_rowid)
-                )
-                start_rowid += offset_per_batch
-            batch_info_df = pd.DataFrame(
-                batch_info_list, columns=["id", "nb_rows", "start_rowid", "end_rowid"]
-            )
-        else:
-            # The rowids are not consecutive, so determine the optimal rowid
-            # ranges for each batch so each batch has same number of elements
-            # Remark: - this might take some seconds for larger datasets!
-            #         - (batch_id - 1) AS id to make the id zero-based
-            sql_stmt = f"""
-                SELECT (batch_id - 1) AS id
-                      ,COUNT(*) AS nb_rows
-                      ,MIN(rowid) AS start_rowid
-                      ,MAX(rowid) AS end_rowid
-                  FROM
-                    ( SELECT rowid
-                            ,NTILE({nb_batches}) OVER (ORDER BY rowid) batch_id
-                        FROM "{layer1_info.name}"
-                    )
-                 GROUP BY batch_id;
-            """
-            batch_info_df = gfo.read_file(path=input1_path, sql_stmt=sql_stmt)
-
-        # Prepare the layer alias to use in the batch filter
-        layer_alias_d = ""
-        if input1_layer_alias is not None:
-            layer_alias_d = f"{input1_layer_alias}."
-
-        # Now loop over all batch ranges to build up the necessary filters
-        for batch_info in batch_info_df.itertuples():
-            # Fill out the batch properties
-            batches[batch_info.id] = {}
-            batches[batch_info.id]["input1_path"] = input1_path
-            batches[batch_info.id]["input1_layer"] = input1_layer
-            batches[batch_info.id]["input2_path"] = input2_path
-            batches[batch_info.id]["input2_layer"] = input2_layer
-
-            # The batch filter
-            if batch_info.id < nb_batches - 1:
-                batches[batch_info.id]["batch_filter"] = (
-                    f"AND ({layer_alias_d}rowid >= {batch_info.start_rowid} "
-                    f"AND {layer_alias_d}rowid <= {batch_info.end_rowid}) "
-                )
-            else:
-                batches[batch_info.id][
-                    "batch_filter"
-                ] = f"AND {layer_alias_d}rowid >= {batch_info.start_rowid} "
-
-    # No use starting more processes than the number of batches...
-    if len(batches) < nb_parallel:
-        nb_parallel = len(batches)
-
-    returnvalue = ProcessingParams(
-        input1_path=input1_path,
-        input1_layer=input1_layer,
-        input2_path=input2_path,
-        input2_layer=input2_layer,
-        nb_parallel=nb_parallel,
-        batches=batches,
-        batchsize=int(nb_rows_input_layer / len(batches)),
-    )
-    returnvalue.to_json(tempdir / "processing_params.json")
-    return returnvalue
-
-
-def _determine_nb_batches(
-    nb_rows_input_layer: int,
-    nb_parallel: int,
-    batchsize: int,
-    is_twolayer_operation: bool,
-    cpu_count: Optional[int] = None,
-) -> Tuple[int, int]:
-    """
-    Determine an optimal number of batches and parallel workers.
-
-    Args:
-        nb_rows_input_layer (int): number of input rows
-        nb_parallel (int): recommended number of workers
-        batchsize (int): recommended number of rows per batch
-        is_twolayer_operation (bool): True if optimization for a two layer operation,
-            False if it involves a single layer operation.
-        cpu_count (int, optional): the number of CPU's available. If None, this is
-            determined automatically if needed.
-
-    Returns:
-        Tuple[int, int]: Tuple of (nb_parallel, nb_batches)
-    """
-    # If no or 1 input rows or if 1 parallel worker is asked
-    # Remark: especially for 'select' operation, if nb_parallel is 1 nb_batches should
-    # be 1 (select might give wrong results)
-    if nb_rows_input_layer <= 1 or nb_parallel == 1:
-        return (1, 1)
-
-    if cpu_count is None:
-        cpu_count = multiprocessing.cpu_count()
-
-    # Determine the optimal number of parallel workers
-    if nb_parallel == -1:
-        # If no batch size specified, put at least 100 rows in a batch
-        if batchsize <= 0:
-            min_rows_per_batch = 100
-        else:
-            # If batchsize is specified, use the batch size
-            min_rows_per_batch = batchsize
-
-        max_parallel = max(int(nb_rows_input_layer / min_rows_per_batch), 1)
-        nb_parallel = min(cpu_count, max_parallel)
-
-    # Determine optimal number of batches
-    if nb_parallel > 1:
-        # Limit number of rows processed in parallel to limit memory use
-        if batchsize > 0:
-            max_rows_parallel = batchsize * nb_parallel
-        else:
-            max_rows_parallel = 1000000
-            if is_twolayer_operation:
-                max_rows_parallel = 200000
-
-        # Adapt number of batches to max_rows_parallel
-        if nb_rows_input_layer > max_rows_parallel:
-            # If more rows than can be handled simultanously in parallel
-            nb_batches = math.ceil(
-                nb_rows_input_layer / (max_rows_parallel / nb_parallel)
-            )
-            # Round up to the nearest multiple of nb_parallel
-            nb_batches = math.ceil(nb_batches / nb_parallel) * nb_parallel
-        elif batchsize > 0:
-            # If a batchsize is specified, try to honer it
-            nb_batches = nb_parallel
-        else:
-            nb_batches = nb_parallel
-
-            # If no batchsize specified and 2 layer processing, add some batches to
-            # reduce impact of possible unbalanced batches on total processing time.
-            if is_twolayer_operation:
-                nb_batches *= 2
-
-    elif batchsize > 0:
-        nb_batches = math.ceil(nb_rows_input_layer / batchsize)
-
-    else:
-        nb_batches = 1
-
-    # If more batches than rows, limit nb batches
-    if nb_batches > nb_rows_input_layer:
-        nb_batches = nb_rows_input_layer
-    # If more parallel than number of batches, limit nb_parallel
-    if nb_parallel > nb_batches:
-        nb_parallel = nb_batches
-
-    return (nb_parallel, nb_batches)
-
-
-def dissolve_singlethread(
-    input_path: Path,
-    output_path: Path,
-    groupby_columns: Union[str, Iterable[str], None] = None,
-    agg_columns: Optional[dict] = None,
-    explodecollections: bool = False,
-    gridsize: float = 0.0,
-    keep_empty_geoms: bool = True,
-    where_post: Optional[str] = None,
-    input_layer: Optional[str] = None,
-    output_layer: Optional[str] = None,
-    force: bool = False,
-):
-    """
-    Remark: this is not a parallelized version!!!
-    """
-    # Init
-    logger = logging.getLogger("geofileops.dissolve")
-    start_time = datetime.now()
-
-    # Check input params
-    if not input_path.exists():
-        raise ValueError(f"input_path doesn't exist: {input_path}")
-    if input_path == output_path:
-        raise ValueError("output_path must not equal input_path")
-    if where_post is not None and where_post == "":
-        where_post = None
-
-    # Check layer names
-    if input_layer is None:
-        input_layer = gfo.get_only_layer(input_path)
-    if output_layer is None:
-        output_layer = gfo.get_default_layer(output_path)
-
-    # Use get_layerinfo to check if the layer definition is OK
-    input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
-    fid_column = (
-        input_layerinfo.fid_column if input_layerinfo.fid_column != "" else "rowid"
-    )
-
-    # Prepare some lists for later use
-    columns_available = list(input_layerinfo.columns) + ["fid"]
-    columns_available_upper = [column.upper() for column in columns_available]
-    groupby_columns_upper_dict = {}
-    if groupby_columns is not None:
-        groupby_columns_upper_dict = {col.upper(): col for col in groupby_columns}
-
-    # Prepare the strings regarding groupby_columns to use in the select statement.
-    if groupby_columns is not None:
-        # Standardize parameter to simplify the rest of the code
-        if isinstance(groupby_columns, str):
-            # If a string is passed, convert to list
-            groupby_columns = [groupby_columns]
-
-        # Check if all groupby columns exist
-        for column in groupby_columns:
-            if column.upper() not in columns_available_upper:
-                raise ValueError(f"column in groupby_columns not in input: {column}")
-
-        # Because the query uses a subselect, the groupby columns need to be prefixed.
-        columns_prefixed = [f'layer."{column}"' for column in groupby_columns]
-        groupby_columns_for_groupby_str = ", ".join(columns_prefixed)
-        columns_prefixed_aliased = [
-            f'layer."{column}" "{column}"' for column in groupby_columns
-        ]
-        groupby_columns_for_select_str = f", {', '.join(columns_prefixed_aliased)}"
-    else:
-        # Even if no groupby is provided, we still need to use a groupby clause,
-        # otherwise ST_union doesn't seem to work.
-        groupby_columns_for_groupby_str = "'1'"
-        groupby_columns_for_select_str = ""
-
-    # Prepare the strings regarding agg_columns to use in the select statement.
-    agg_columns_str = ""
-    if agg_columns is not None:
-        # Validate the dict structure, so we can assume everything is OK further on
-        _parameter_helper.validate_agg_columns(agg_columns)
-
-        # Start preparation of agg_columns_str
-        if "json" in agg_columns:
-            # Determine the columns to be put in json
-            columns = []
-            if agg_columns["json"] is None:
-                # If columns specified is None: all columns not in groupby_columns
-                for column in input_layerinfo.columns:
-                    if column.upper() not in groupby_columns_upper_dict:
-                        columns.append(column)
-            else:
-                for column in agg_columns["json"]:
-                    columns.append(column)
-            json_columns = [f"'{column}', layer.\"{column}\"" for column in columns]
-
-            # The fid should be added as well, but make name unique
-            fid_orig_column = "fid_orig"
-            for idx in range(99999):
-                if idx != 0:
-                    fid_orig_column = f"fid_orig{idx}"
-                if fid_orig_column not in columns:
-                    break
-            json_columns.append(f"'{fid_orig_column}', layer.\"{fid_column}\"")
-
-            # Now we are ready to prepare final str
-            agg_columns_str = (
-                f", json_group_array(json_object({', '.join(json_columns)})) as json"
-            )
-        elif "columns" in agg_columns:
-            for agg_column in agg_columns["columns"]:
-                # Init
-                distinct_str = ""
-                extra_param_str = ""
-
-                # Prepare aggregation keyword
-                if agg_column["agg"].lower() in [
-                    "count",
-                    "sum",
-                    "min",
-                    "max",
-                    "median",
-                ]:
-                    aggregation_str = agg_column["agg"]
-                elif agg_column["agg"].lower() in ["mean", "avg"]:
-                    aggregation_str = "avg"
-                elif agg_column["agg"].lower() == "concat":
-                    aggregation_str = "group_concat"
-                    if "sep" in agg_column:
-                        extra_param_str = f", '{agg_column['sep']}'"
-                else:
-                    raise ValueError(f"aggregation {agg_column['agg']} not supported!")
-
-                # If distinct is specified, add the distinct keyword
-                if "distinct" in agg_column and agg_column["distinct"] is True:
-                    distinct_str = "DISTINCT "
-
-                # Prepare column name string
-                column = agg_column["column"]
-                if column.upper() not in columns_available_upper:
-                    raise ValueError(f"{column} not available in: {columns_available}")
-                if column.upper() == "FID":
-                    column_str = f'layer."{fid_column}"'
-                else:
-                    column_str = f'layer."{column}"'
-
-                # Now put everything together
-                agg_columns_str += (
-                    f", {aggregation_str}({distinct_str}{column_str}{extra_param_str}) "
-                    f'AS "{agg_column["as"]}"'
-                )
-
-    # Check output path
-    if output_path.exists():
-        if force is False:
-            logger.info(f"Stop, output exists already {output_path}")
-            return
-        else:
-            gfo.remove(output_path)
-
-    # Now prepare the sql statement
-    # Remark: calculating the area in the enclosing selects halves the processing time
-
-    # The operation to run on the geometry
-    operation = f"ST_union(layer.{input_layerinfo.geometrycolumn})"
-
-    # If the input is a linestring, also apply st_linemerge(), otherwise the individual
-    # lines are just concatenated together and common points are not removed, resulting
-    # in the original seperate lines again if explodecollections is True.
-    if input_layerinfo.geometrytype.to_primitivetype == PrimitiveType.LINESTRING:
-        operation = f"ST_LineMerge({operation})"
-
-    # If the output file results in no rows gdal needs force_output_geometrytype to be
-    # able to create an empty output file with the right geometry type.
-    if explodecollections:
-        force_output_geometrytype = input_layerinfo.geometrytype.to_singletype
-    else:
-        force_output_geometrytype = input_layerinfo.geometrytype.to_multitype
-
-    # Apply tolerance gridsize on result
-    if gridsize != 0.0:
-        operation = _format_apply_gridsize_operation(
-            geometrycolumn=operation,
-            gridsize=gridsize,
-            force_output_geometrytype=force_output_geometrytype,
-        )
-
-    # Now the sql query can be assembled
-    sql_stmt = f"""
-        SELECT {operation} AS geom
-            {groupby_columns_for_select_str}
-            {agg_columns_str}
-        FROM "{input_layer}" layer
-        GROUP BY {groupby_columns_for_groupby_str}
-    """
-
-    # If empty/null geometries don't need to be kept, filter them away
-    if not keep_empty_geoms:
-        sql_stmt = f"""
-            SELECT * FROM
-                ( {sql_stmt}
-                )
-             WHERE geom IS NOT NULL
-        """
-
-    # Prepare/apply where_post parameter
-    if where_post is not None and not explodecollections:
-        # explodecollections is not True, so we can add where_post to sql_stmt.
-        # If explodecollections would be True, we need to wait to apply the
-        # where_post till after explodecollections is applied, so when appending
-        # the partial results to the output file.
-        where_post = where_post.format(geometrycolumn="geom")
-        sql_stmt = f"""
-            SELECT * FROM
-                ( {sql_stmt}
-                )
-                WHERE {where_post}
-        """
-        # where_post has been applied already so set to None.
-        where_post = None
-
-    # When null geometries are being kept, we need to make sure the geom in the
-    # first row is not NULL because of a bug in gdal, so add ORDER BY as last step.
-    #   -> https://github.com/geofileops/geofileops/issues/308
-    if keep_empty_geoms:
-        sql_stmt = f"""
-            SELECT * FROM
-                ( {sql_stmt}
-                )
-             ORDER BY geom IS NULL
-        """
-
-    # Now we can really start
-    tempdir = _io_util.create_tempdir("geofileops/dissolve_singlethread")
-    try:
-        create_spatial_index = True
-        suffix = output_path.suffix
-        if where_post is not None:
-            # where_post needs to be applied still, so no spatial index needed
-            create_spatial_index = False
-            suffix = ".gpkg"
-        tmp_output_path = tempdir / f"output_tmp{suffix}"
-
-        _ogr_util.vector_translate(
-            input_path=input_path,
-            output_path=tmp_output_path,
-            output_layer=output_layer,
-            sql_stmt=sql_stmt,
-            sql_dialect="SQLITE",
-            force_output_geometrytype=force_output_geometrytype,
-            explodecollections=explodecollections,
-            options={"LAYER_CREATION.SPATIAL_INDEX": create_spatial_index},
-        )
-
-        # We still need to apply the where_post filter
-        if where_post is not None:
-            tmp_output_where_path = tempdir / f"output_tmp2_where{output_path.suffix}"
-            tmp_output_info = gfo.get_layerinfo(tmp_output_path)
-            where_post = where_post.format(
-                geometrycolumn=tmp_output_info.geometrycolumn
-            )
-            sql_stmt = f"""
-                SELECT * FROM "{output_layer}"
-                 WHERE {where_post}
-            """
-            _ogr_util.vector_translate(
-                input_path=tmp_output_path,
-                output_path=tmp_output_where_path,
-                output_layer=output_layer,
-                force_output_geometrytype=force_output_geometrytype,
-                sql_stmt=sql_stmt,
-                sql_dialect="SQLITE",
-                options={"LAYER_CREATION.SPATIAL_INDEX": True},
-            )
-            tmp_output_path = tmp_output_where_path
-
-        # Now we are ready to move the result to the final spot...
-        gfo.move(tmp_output_path, output_path)
-
-    finally:
-        shutil.rmtree(tempdir, ignore_errors=True)
-
-    logger.info(f"Ready, took {datetime.now()-start_time}")
-
-
-def _format_apply_gridsize_operation(
-    geometrycolumn: str, gridsize: float, force_output_geometrytype: GeometryType
-) -> str:
-    if SPATIALITE_GTE_51:
-        # ST_ReducePrecision and GeosMakeValid only available for spatialite >= 5.1
-        # Retry with applying makevalid.
-        # It is not possible to return the original geometry if error stays after
-        # makevalid, because spatialite functions return NULL for failures as well as
-        # when the result is correctly NULL, so not possible to make the distinction.
-        gridsize_op = f"""
-            IIF({geometrycolumn} IS NULL,
-                NULL,
-                IFNULL(
-                    ST_ReducePrecision({geometrycolumn}, {gridsize}),
-                    ST_ReducePrecision(GeosMakeValid({geometrycolumn}, 0), {gridsize})
-                )
-            )
-        """
-    else:
-        # Apply snaptogrid, but this results in invalid geometries, so also
-        # Makevalid.
-        gridsize_op = f"ST_MakeValid(SnapToGrid({geometrycolumn}, {gridsize}))"
-
-        # SnapToGrid + ST_MakeValid can result in collapsed (pieces of)
-        # geometries, so finally apply collectionextract as well.
-        if force_output_geometrytype is None:
-            warnings.warn(
-                "a gridsize is specified but no force_output_geometrytype, "
-                "this can result in inconsistent geometries in the output",
-                stacklevel=3,
-            )
-        else:
-            primitivetypeid = force_output_geometrytype.to_primitivetype.value
-            gridsize_op = f"ST_CollectionExtract({gridsize_op}, {primitivetypeid})"
-
-    return gridsize_op
+"""
+Module containing the implementation of Geofile operations using a sql statement.
+"""
+
+from concurrent import futures
+from datetime import datetime
+import json
+import logging
+import logging.config
+import math
+import multiprocessing
+from pathlib import Path
+import shutil
+import string
+from typing import Dict, Iterable, List, Literal, Optional, Tuple, Union
+import warnings
+
+import pandas as pd
+import pygeoops
+import shapely
+
+import geofileops as gfo
+from geofileops import GeometryType, PrimitiveType
+from geofileops import fileops
+
+from geofileops._compat import SPATIALITE_GTE_51
+from geofileops.fileops import _append_to_nolock
+from geofileops.util import _general_util
+from geofileops.util import _geofileinfo
+from geofileops.util import _geoops_gpd
+from geofileops.util import _io_util
+from geofileops.util import _ogr_sql_util
+from geofileops.util import _ogr_util
+from geofileops.helpers import _parameter_helper
+from geofileops.util import _processing_util
+from geofileops.util import _sqlite_util
+
+logger = logging.getLogger(__name__)
+
+# -----------------------
+# Operations on one layer
+# -----------------------
+
+
+def buffer(
+    input_path: Path,
+    output_path: Path,
+    distance: float,
+    quadrantsegments: int = 5,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    keep_empty_geoms: bool = True,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Init + prepare sql template for this operation
+    # ----------------------------------------------
+    operation = f"ST_Buffer({{geometrycolumn}}, {distance}, {quadrantsegments})"
+
+    # For a double sided buffer, a negative buffer is only relevant for polygon types,
+    # so only keep polygon results.
+    # Negative buffer creates invalid stuff, so use collectionextract to keep only
+    # polygons.
+    if distance < 0:
+        operation = f"ST_CollectionExtract({operation}, 3)"
+
+    # Create the final template
+    sql_template = f"""
+        SELECT {operation} AS {{geometrycolumn}}
+              {{columns_to_select_str}}
+            FROM "{{input_layer}}" layer
+            WHERE 1=1
+              {{batch_filter}}
+    """
+
+    # Buffer operation always results in polygons...
+    if explodecollections:
+        force_output_geometrytype = GeometryType.POLYGON
+    else:
+        force_output_geometrytype = GeometryType.MULTIPOLYGON
+
+    # Go!
+    # ---
+    return _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        geom_selected=True,
+        operation_name="buffer",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        gridsize=gridsize,
+        keep_empty_geoms=keep_empty_geoms,
+        where_post=where_post,
+        sql_dialect="SQLITE",
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def convexhull(
+    input_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    keep_empty_geoms: bool = False,  # Should become True
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Init + prepare sql template for this operation
+    # ----------------------------------------------
+    input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
+    sql_template = """
+        SELECT ST_ConvexHull({geometrycolumn}) AS {geometrycolumn}
+                {columns_to_select_str}
+          FROM "{input_layer}" layer
+         WHERE 1=1
+           {batch_filter}
+    """
+
+    # Go!
+    # ---
+    # Output geometry type same as input geometry type
+    return _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        geom_selected=True,
+        operation_name="convexhull",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=input_layerinfo.geometrytype,
+        gridsize=gridsize,
+        keep_empty_geoms=keep_empty_geoms,
+        where_post=where_post,
+        sql_dialect="SQLITE",
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def delete_duplicate_geometries(
+    input_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    keep_empty_geoms: bool = True,
+    where_post: Optional[str] = None,
+    force: bool = False,
+):
+    # The query as written doesn't give correct results when parallelized,
+    # but it isn't useful to do it for this operation.
+    sql_template = """
+        SELECT {geometrycolumn} AS {geometrycolumn}
+              {columns_to_select_str}
+          FROM "{input_layer}" layer
+         WHERE layer.rowid IN (
+                SELECT MIN(layer_sub.rowid) AS rowid_to_keep
+                  FROM "{input_layer}" layer_sub
+                 GROUP BY layer_sub.{geometrycolumn}
+            )
+    """
+
+    # Go!
+    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
+    return _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        geom_selected=True,
+        operation_name="delete_duplicate_geometries",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=input_layer_info.geometrytype,
+        gridsize=0.0,
+        keep_empty_geoms=keep_empty_geoms,
+        where_post=where_post,
+        sql_dialect="SQLITE",
+        nb_parallel=1,
+        batchsize=-1,
+        force=force,
+    )
+
+
+def isvalid(
+    input_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    validate_attribute_data: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+) -> bool:
+    # Prepare sql template for this operation
+    sql_template = """
+        SELECT ST_IsValidDetail({geometrycolumn}) AS {geometrycolumn}
+              ,ST_IsValid({geometrycolumn}) AS isvalid
+              ,ST_IsValidReason({geometrycolumn}) AS isvalidreason
+              {columns_to_select_str}
+          FROM "{input_layer}" layer
+         WHERE ST_IsValid({geometrycolumn}) <> 1
+           {batch_filter}
+    """
+
+    _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        geom_selected=True,
+        operation_name="isvalid",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=GeometryType.POINT,
+        gridsize=0.0,
+        keep_empty_geoms=False,
+        where_post=None,
+        sql_dialect="SQLITE",
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+    # Check the number of invalid files
+    nb_invalid_geoms = 0
+    if output_path.exists():
+        nb_invalid_geoms = gfo.get_layerinfo(output_path).featurecount
+        if nb_invalid_geoms == 0:
+            # Empty result, so everything was valid: remove output file
+            gfo.remove(output_path)
+
+    # If output is sqlite based, check if all data can be read
+    logger = logging.getLogger("geofileops.isvalid")
+    if validate_attribute_data:
+        try:
+            input_info = _geofileinfo.get_geofileinfo(input_path)
+            if input_info.is_spatialite_based:
+                _sqlite_util.test_data_integrity(path=input_path)
+                logger.debug("test_data_integrity was succesfull")
+        except Exception:
+            logger.exception(
+                f"nb_invalid_geoms: {nb_invalid_geoms} + some attributes "
+                "could not be read!"
+            )
+            return False
+
+    if nb_invalid_geoms > 0:
+        logger.info(f"Found {nb_invalid_geoms} invalid geoms in {output_path}")
+        return False
+
+    # Nothing invalid found
+    return True
+
+
+def makevalid(
+    input_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    gridsize: float = 0.0,
+    keep_empty_geoms: bool = True,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # If output file exists already, either clean up or return...
+    operation_name = "makevalid"
+    logger = logging.getLogger(f"geofileops.{operation_name}")
+    if not force and output_path.exists():
+        logger.info(f"Stop, output exists already {output_path}")
+        return
+
+    # Determine output_geometrytype + make it multitype if it wasn't specified.
+    # Otherwise makevalid can result in column type 'GEOMETRY'/'UNKNOWN(ANY)'.
+    if force_output_geometrytype is None:
+        input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
+        force_output_geometrytype = input_layerinfo.geometrytype
+        if not explodecollections:
+            force_output_geometrytype = force_output_geometrytype.to_multitype
+
+    # Init + prepare sql template for this operation
+    # ----------------------------------------------
+    # Only apply makevalid if the geometry is truly invalid, this is faster.
+    # GEOSMakeValid crashes with EMPTY input, so check this first.
+    if SPATIALITE_GTE_51:
+        operation = """
+            IIF({geometrycolumn} IS NULL OR ST_IsEmpty({geometrycolumn}) <> 0,
+                NULL,
+                IIF(ST_IsValid({geometrycolumn}) = 1,
+                    {geometrycolumn},
+                    GEOSMakeValid({geometrycolumn}, 0)
+               )
+            )"""
+    else:
+        # Prepare sql template for this operation
+        operation = """
+            IIF(ST_IsValid({geometrycolumn}) = 1,
+                {geometrycolumn},
+                ST_MakeValid({geometrycolumn})
+            )"""
+
+        # If we want a specific geometrytype, only extract the relevant type
+        if force_output_geometrytype is not GeometryType.GEOMETRYCOLLECTION:
+            primitivetypeid = force_output_geometrytype.to_primitivetype.value
+            operation = f"ST_CollectionExtract({operation}, {primitivetypeid})"
+
+    # Now we can prepare the entire statement
+    sql_template = f"""
+        SELECT {operation} AS {{geometrycolumn}}
+              {{columns_to_select_str}}
+          FROM "{{input_layer}}" layer
+         WHERE 1=1
+           {{batch_filter}}
+    """
+
+    _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        geom_selected=True,
+        operation_name=operation_name,
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        gridsize=gridsize,
+        keep_empty_geoms=keep_empty_geoms,
+        where_post=where_post,
+        sql_dialect="SQLITE",
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def select(
+    input_path: Path,
+    output_path: Path,
+    sql_stmt: str,
+    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = "SQLITE",
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    gridsize: float = 0.0,
+    keep_empty_geoms: bool = True,
+    nb_parallel: int = 1,
+    batchsize: int = -1,
+    force: bool = False,
+    operation_prefix: str = "",
+):
+    # Check if output exists already here, to avoid to much logging to be written
+    logger = logging.getLogger(f"geofileops.{operation_prefix}select")
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop, output exists already {output_path}")
+            return
+    logger.debug(f"  -> select to execute:\n{sql_stmt}")
+
+    # If no output geometrytype is specified, use the geometrytype of the input layer
+    if force_output_geometrytype is None:
+        force_output_geometrytype = gfo.get_layerinfo(
+            input_path, input_layer, raise_on_nogeom=False
+        ).geometrytype
+        if force_output_geometrytype is not None and not explodecollections:
+            force_output_geometrytype = force_output_geometrytype.to_multitype
+
+        logger.info(
+            "No force_output_geometrytype specified, so defaults to input "
+            f"layer geometrytype: {force_output_geometrytype}"
+        )
+
+    # Go!
+    return _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_stmt,
+        geom_selected=None,
+        operation_name=f"{operation_prefix}select",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        gridsize=gridsize,
+        keep_empty_geoms=keep_empty_geoms,
+        where_post=None,
+        sql_dialect=sql_dialect,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def simplify(
+    input_path: Path,
+    output_path: Path,
+    tolerance: float,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    columns: Optional[List[str]] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    keep_empty_geoms: bool = True,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Init + prepare sql template for this operation
+    # ----------------------------------------------
+    sql_template = f"""
+        SELECT ST_SimplifyPreserveTopology({{geometrycolumn}}, {tolerance}
+               ) AS {{geometrycolumn}}
+              {{columns_to_select_str}}
+            FROM "{{input_layer}}" layer
+            WHERE 1=1
+            {{batch_filter}}
+    """
+
+    # Output geometry type same as input geometry type
+    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
+    return _single_layer_vector_operation(
+        input_path=input_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        geom_selected=True,
+        operation_name="simplify",
+        input_layer=input_layer,
+        output_layer=output_layer,
+        columns=columns,
+        explodecollections=explodecollections,
+        force_output_geometrytype=input_layer_info.geometrytype,
+        gridsize=gridsize,
+        keep_empty_geoms=keep_empty_geoms,
+        where_post=where_post,
+        sql_dialect="SQLITE",
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def _single_layer_vector_operation(
+    input_path: Path,
+    output_path: Path,
+    sql_template: str,
+    geom_selected: Optional[bool],
+    operation_name: str,
+    input_layer: Optional[str],
+    output_layer: Optional[str],
+    columns: Optional[List[str]],
+    explodecollections: bool,
+    force_output_geometrytype: Optional[GeometryType],
+    gridsize: float,
+    keep_empty_geoms: bool,
+    where_post: Optional[str],
+    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]],
+    nb_parallel: int,
+    batchsize: int,
+    force: bool,
+):
+    """
+    Execute a sql query template on the input layer.
+
+    Args:
+        input_path (Path): _description_
+        output_path (Path): _description_
+        sql_template (str): _description_
+        geom_selected (Optional[bool]): True if a geometry column is selected in the
+            sql_template. False if no geometry column is selected. None if it is
+            unclear.
+        operation_name (str): _description_
+        input_layer (Optional[str]): _description_
+        output_layer (Optional[str]): _description_
+        columns (Optional[List[str]]): _description_
+        explodecollections (bool): _description_
+        force_output_geometrytype (Optional[GeometryType]): _description_
+        gridsize (float): _description_
+        keep_empty_geoms (bool): _description_
+        where_post (Optional[str]): _description_
+        sql_dialect (Optional[Literal["SQLITE", "OGRSQL"]]): _description_
+        nb_parallel (int): _description_
+        batchsize (int): _description_
+        force (bool): _description_
+
+    Raises:
+        ValueError: _description_
+        ValueError: _description_
+        ValueError: _description_
+        Exception: _description_
+    """
+    # Init
+    start_time = datetime.now()
+    logger = logging.getLogger(f"geofileops.{operation_name}")
+
+    # Check/clean input parameters...
+    if not input_path.exists():
+        raise ValueError(f"{operation_name}: input_path doesn't exist: {input_path}")
+    if input_path == output_path:
+        raise ValueError(f"{operation_name}: output_path must not equal input_path")
+    if where_post is not None and where_post == "":
+        where_post = None
+
+    # Check/get layer names
+    if input_layer is None:
+        input_layer = gfo.get_only_layer(input_path)
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    # If output file exists already, either clean up or return...
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop, output exists already {output_path}")
+            return
+        else:
+            gfo.remove(output_path)
+
+    # Determine if fid can be preserved
+    preserve_fid = False
+    if (
+        not explodecollections
+        and _geofileinfo.get_geofileinfo(input_path).is_spatialite_based
+        and _geofileinfo.get_geofileinfo(output_path).is_spatialite_based
+    ):
+        preserve_fid = True
+
+    # Calculate
+    tempdir = _io_util.create_tempdir(f"geofileops/{operation_name.replace(' ', '_')}")
+    try:
+        # If gridsize != 0.0 or if geom_selected is None we need an sqlite file to be
+        # able to determine the columns later on.
+        convert_to_spatialite_based = (
+            True if gridsize != 0.0 or geom_selected is None else False
+        )
+        processing_params = _prepare_processing_params(
+            input1_path=input_path,
+            input1_layer=input_layer,
+            input1_layer_alias="layer",
+            tempdir=tempdir,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            convert_to_spatialite_based=convert_to_spatialite_based,
+        )
+        # If None is returned, just stop.
+        if processing_params is None or processing_params.batches is None:
+            return
+
+        # Get layer info of the input layer to use
+        assert processing_params.input1_path is not None
+        input_layerinfo = gfo.get_layerinfo(
+            processing_params.input1_path, input_layer, raise_on_nogeom=False
+        )
+
+        # If multiple batches, there should be a batch_filter placeholder sql_template
+        nb_batches = len(processing_params.batches)
+        if nb_batches > 1:
+            placeholders = [
+                name for _, name, _, _ in string.Formatter().parse(sql_template) if name
+            ]
+            if "batch_filter" not in placeholders:
+                raise ValueError(
+                    "Number batches > 1 requires a batch_filter placeholder in "
+                    f"sql_template {sql_template}"
+                )
+
+        # Format column string for use in select
+        column_formatter = _ogr_sql_util.ColumnFormatter(
+            columns_asked=columns,
+            columns_in_layer=input_layerinfo.columns,
+            fid_column=input_layerinfo.fid_column,
+        )
+
+        # Fill out template already for known info
+        columns_to_select_str = column_formatter.prefixed_aliased()
+        if input_layerinfo.fid_column != "":
+            # If there is an fid column defined, select that column as well so the fids
+            # can be retained in the output if possible.
+            columns_to_select_str = (
+                f",{input_layerinfo.fid_column}{columns_to_select_str}"
+            )
+        sql_template = sql_template.format(
+            geometrycolumn=input_layerinfo.geometrycolumn,
+            columns_to_select_str=columns_to_select_str,
+            input_layer=processing_params.input1_layer,
+            batch_filter="{batch_filter}",
+        )
+
+        #  to Check if a geometry column is available + selected
+        if geom_selected is None:
+            if input_layerinfo.geometrycolumn is None:
+                # There is no geometry column in the source file
+                geom_selected = False
+            else:
+                # There is a geometry column in the source file, check if it is selected
+                sql_tmp = sql_template.format(batch_filter="")
+                cols = _sqlite_util.get_columns(
+                    sql_stmt=sql_tmp,
+                    input1_path=processing_params.input1_path,
+                )
+                geom_selected = input_layerinfo.geometrycolumn in cols
+
+        # Fill out/add to the sql_template what is already possible
+        # ---------------------------------------------------------
+
+        # Add application of gridsize around sql_template if specified
+        if geom_selected and gridsize != 0.0:
+            gridsize_op = _format_apply_gridsize_operation(
+                geometrycolumn=f"sub_gridsize.{input_layerinfo.geometrycolumn}",
+                gridsize=gridsize,
+                force_output_geometrytype=force_output_geometrytype,
+            )
+
+            # Get all columns of the sql_template
+            sql_tmp = sql_template.format(batch_filter="")
+            cols = _sqlite_util.get_columns(
+                sql_stmt=sql_tmp, input1_path=processing_params.input1_path
+            )
+            attributes = [
+                col for col in cols if col.lower() != input_layerinfo.geometrycolumn
+            ]
+            columns_to_select = _ogr_sql_util.columns_quoted(attributes)
+            sql_template = f"""
+                SELECT {gridsize_op} AS {input_layerinfo.geometrycolumn}
+                      {columns_to_select}
+                  FROM
+                    ( {sql_template}
+                       LIMIT -1 OFFSET 0
+                    ) sub_gridsize
+            """
+
+        # If empty/null geometries don't need to be kept, filter them away
+        if geom_selected and not keep_empty_geoms:
+            sql_template = f"""
+                SELECT * FROM
+                    ( {sql_template}
+                       LIMIT -1 OFFSET 0
+                    )
+                 WHERE {input_layerinfo.geometrycolumn} IS NOT NULL
+            """
+
+        # Prepare/apply where_post parameter
+        if where_post is not None and not explodecollections:
+            # explodecollections is not True, so we can add where_post to sql_stmt.
+            # If explodecollections would be True, we need to wait to apply the
+            # where_post till after explodecollections is applied, so when appending the
+            # partial results to the output file.
+            sql_template = f"""
+                SELECT * FROM
+                    ( {sql_template}
+                       LIMIT -1 OFFSET 0
+                    )
+                    WHERE {where_post}
+            """
+            # where_post has been applied already so set to None.
+            where_post = None
+
+        # When null geometries are being kept, we need to make sure the geom in the
+        # first row is not NULL because of a bug in gdal, so add ORDER BY as last step.
+        #   -> https://github.com/geofileops/geofileops/issues/308
+        if geom_selected and keep_empty_geoms:
+            sql_template = f"""
+                SELECT * FROM
+                    ( {sql_template}
+                       LIMIT -1 OFFSET 0
+                    )
+                 ORDER BY {input_layerinfo.geometrycolumn} IS NULL
+            """
+
+        # Fill out geometrycolumn again as there might have popped up extra ones
+        sql_template = sql_template.format(
+            geometrycolumn=input_layerinfo.geometrycolumn,
+            batch_filter="{batch_filter}",
+        )
+
+        logger.info(
+            f"Start processing ({processing_params.nb_parallel} "
+            f"parallel workers, batch size: {processing_params.batchsize})"
+        )
+
+        # Prepare temp output filename
+        tmp_output_path = tempdir / output_path.name
+
+        # Processing in threads is 2x faster for small datasets (on Windows)
+        calculate_in_threads = True if input_layerinfo.featurecount <= 100 else False
+        with _processing_util.PooledExecutorFactory(
+            threadpool=calculate_in_threads,
+            max_workers=processing_params.nb_parallel,
+            initializer=_processing_util.initialize_worker(),
+        ) as calculate_pool:
+            batches: Dict[int, dict] = {}
+            future_to_batch_id = {}
+            for batch_id in processing_params.batches:
+                batches[batch_id] = {}
+                batches[batch_id]["layer"] = output_layer
+
+                tmp_partial_output_path = (
+                    tempdir / f"{output_path.stem}_{batch_id}.gpkg"
+                )
+                batches[batch_id]["tmp_partial_output_path"] = tmp_partial_output_path
+
+                # Fill out sql_template
+                sql_stmt = sql_template.format(
+                    batch_filter=processing_params.batches[batch_id]["batch_filter"]
+                )
+                batches[batch_id]["sql_stmt"] = sql_stmt
+
+                # If there is only one batch, it is faster to create the spatial index
+                # immediately. Otherwise no index needed, because partial files still
+                # need to be merged to one file later on.
+                create_spatial_index = False
+                if nb_batches == 1:
+                    create_spatial_index = True
+                translate_info = _ogr_util.VectorTranslateInfo(
+                    input_path=processing_params.batches[batch_id]["input1_path"],
+                    output_path=tmp_partial_output_path,
+                    output_layer=output_layer,
+                    sql_stmt=sql_stmt,
+                    sql_dialect=sql_dialect,
+                    explodecollections=explodecollections,
+                    force_output_geometrytype=force_output_geometrytype,
+                    options={"LAYER_CREATION.SPATIAL_INDEX": create_spatial_index},
+                    preserve_fid=preserve_fid,
+                )
+                future = calculate_pool.submit(
+                    _ogr_util.vector_translate_by_info, info=translate_info
+                )
+                future_to_batch_id[future] = batch_id
+
+            # Loop till all parallel processes are ready, but process each one
+            # that is ready already.
+            # Calculating can be done in parallel, but only one process can write to
+            # the same file at the time.
+            nb_done = 0
+            _general_util.report_progress(
+                start_time,
+                nb_done,
+                nb_todo=nb_batches,
+                operation=operation_name,
+                nb_parallel=processing_params.nb_parallel,
+            )
+            for future in futures.as_completed(future_to_batch_id):
+                try:
+                    _ = future.result()
+                except Exception as ex:
+                    batch_id = future_to_batch_id[future]
+                    error = str(ex).partition("\n")[0]
+                    message = f"Error <{error}> executing {batches[batch_id]}"
+                    logger.exception(message)
+                    raise Exception(message) from ex
+
+                # Start copy of the result to a common file
+                # Remark: give higher priority, because this is the slowest factor
+                batch_id = future_to_batch_id[future]
+                tmp_partial_output_path = batches[batch_id]["tmp_partial_output_path"]
+                nb_done += 1
+
+                # Normally all partial files should exist, but to be sure.
+                if not tmp_partial_output_path.exists():
+                    logger.warning(f"Result file {tmp_partial_output_path} not found")
+                    continue
+
+                if (
+                    nb_batches == 1
+                    and tmp_partial_output_path.suffix == tmp_output_path.suffix
+                    and where_post is None
+                ):
+                    # If there is only one batch
+                    #   + partial file is already is correct file format
+                    #   + no more where_post needs to be applied
+                    # -> just rename partial file, because it is already OK.
+                    gfo.move(tmp_partial_output_path, tmp_output_path)
+                else:
+                    # Append partial file to full destination file
+                    if where_post is not None:
+                        info = gfo.get_layerinfo(tmp_partial_output_path, output_layer)
+                        where_post = where_post.format(
+                            geometrycolumn=info.geometrycolumn
+                        )
+                    fileops._append_to_nolock(
+                        src=tmp_partial_output_path,
+                        dst=tmp_output_path,
+                        explodecollections=explodecollections,
+                        force_output_geometrytype=force_output_geometrytype,
+                        where=where_post,
+                        create_spatial_index=False,
+                        preserve_fid=preserve_fid,
+                    )
+                    gfo.remove(tmp_partial_output_path)
+
+                # Log the progress and prediction speed
+                _general_util.report_progress(
+                    start_time,
+                    nb_done,
+                    nb_todo=nb_batches,
+                    operation=operation_name,
+                    nb_parallel=processing_params.nb_parallel,
+                )
+
+        # Round up and clean up
+        # Now create spatial index and move to output location
+        if tmp_output_path.exists():
+            if (
+                gfo.get_layerinfo(
+                    path=tmp_output_path, layer=output_layer, raise_on_nogeom=False
+                ).geometrycolumn
+                is not None
+            ):
+                gfo.create_spatial_index(
+                    path=tmp_output_path, layer=output_layer, exist_ok=True
+                )
+            output_path.parent.mkdir(parents=True, exist_ok=True)
+            gfo.move(tmp_output_path, output_path)
+        elif (
+            gfo.get_driver(tmp_output_path) == "ESRI Shapefile"
+            and tmp_output_path.with_suffix(".dbf").exists()
+        ):
+            # If the output shapefile doesn't have a geometry column, the .shp file
+            # doesn't exist but the .dbf does
+            output_path.parent.mkdir(parents=True, exist_ok=True)
+            gfo.move(
+                tmp_output_path.with_suffix(".dbf"), output_path.with_suffix(".dbf")
+            )
+        else:
+            logger.debug("Result was empty!")
+
+    finally:
+        # Clean tmp dir
+        shutil.rmtree(tempdir, ignore_errors=True)
+
+    logger.info(f"Ready, took {datetime.now()-start_time}")
+
+
+# ------------------------
+# Operations on two layers
+# ------------------------
+
+
+def clip(
+    input_path: Path,
+    clip_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    input_columns: Optional[List[str]] = None,
+    clip_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+    input_columns_prefix: str = "",
+    output_with_spatial_index: bool = True,
+):
+    # Init
+    # In the query, important to only extract the geometry types that are expected
+    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
+    primitivetypeid = input_layer_info.geometrytype.to_primitivetype.value
+
+    # If explodecollections is False and the input type is not point, force the output
+    # type to multi, because erase clip cause eg. polygons to be split to multipolygons.
+    force_output_geometrytype = input_layer_info.geometrytype
+    if not explodecollections and force_output_geometrytype is not GeometryType.POINT:
+        force_output_geometrytype = force_output_geometrytype.to_multitype
+
+    # Prepare sql template for this operation
+    # Remarks:
+    # - ST_intersection(geometry , NULL) gives NULL as result! -> hence the CASE
+    # - use of the with instead of an inline view is a lot faster
+    # - use "LIMIT -1 OFFSET 0" to avoid the subquery flattening. Flattening e.g.
+    #   "geom IS NOT NULL" leads to geom operation to be calculated twice!
+    # - WHERE geom IS NOT NULL to avoid rows with a NULL geom, they give issues in
+    #   later operations.
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        SELECT * FROM
+          ( WITH layer2_unioned AS (
+              SELECT layer1.rowid AS layer1_rowid
+                    ,ST_union(layer2.{{input2_geometrycolumn}}) AS geom
+                FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                  ON layer1.fid = layer1tree.id
+                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                  ON layer2.fid = layer2tree.id
+               WHERE 1=1
+                 {{batch_filter}}
+                 AND layer1tree.minx <= layer2tree.maxx
+                 AND layer1tree.maxx >= layer2tree.minx
+                 AND layer1tree.miny <= layer2tree.maxy
+                 AND layer1tree.maxy >= layer2tree.miny
+                 AND ST_Intersects(
+                        layer1.{{input1_geometrycolumn}},
+                        layer2.{{input2_geometrycolumn}}) = 1
+                 --AND ST_Touches(
+                 --       layer1.{{input1_geometrycolumn}},
+                 --       layer2.{{input2_geometrycolumn}}) = 0
+               GROUP BY layer1.rowid
+               LIMIT -1 OFFSET 0
+            )
+            SELECT CASE WHEN layer2_unioned.geom IS NULL THEN NULL
+                        ELSE ST_CollectionExtract(
+                               ST_intersection(layer1.{{input1_geometrycolumn}},
+                                               layer2_unioned.geom), {primitivetypeid})
+                   END as geom
+                  {{layer1_columns_prefix_alias_str}}
+              FROM {{input1_databasename}}."{{input1_layer}}" layer1
+              JOIN layer2_unioned ON layer1.rowid = layer2_unioned.layer1_rowid
+             WHERE 1=1
+               {{batch_filter}}
+             LIMIT -1 OFFSET 0
+          )
+         WHERE geom IS NOT NULL
+    """
+
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input_path,
+        input2_path=clip_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="clip",
+        input1_layer=input_layer,
+        input1_columns=input_columns,
+        input1_columns_prefix=input_columns_prefix,
+        input2_layer=clip_layer,
+        input2_columns=None,
+        input2_columns_prefix="",
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        gridsize=gridsize,
+        where_post=where_post,
+        force_output_geometrytype=force_output_geometrytype,
+        output_with_spatial_index=output_with_spatial_index,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def erase(
+    input_path: Path,
+    erase_path: Path,
+    output_path: Path,
+    input_layer: Optional[str] = None,
+    input_columns: Optional[List[str]] = None,
+    erase_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    subdivide_coords: int = 2000,
+    force: bool = False,
+    input_columns_prefix: str = "",
+    output_with_spatial_index: bool = True,
+    operation_prefix: str = "",
+):
+    # Because there might be extra preparation of the erase layer before going ahead
+    # with the real calculation, do some additional init + checks here...
+    if subdivide_coords < 0:
+        raise ValueError("subdivide_coords < 0 is not allowed")
+
+    operation = f"{operation_prefix}erase"
+    logger = logging.getLogger(f"geofileops.{operation}")
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop, output exists already {output_path}")
+            return
+        else:
+            gfo.remove(output_path)
+
+    # Init
+    start_time = datetime.now()
+    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
+    primitivetypeid = input_layer_info.geometrytype.to_primitivetype.value
+
+    # If explodecollections is False and the input type is not point, force the output
+    # type to multi, because erase can cause eg. polygons to be split to multipolygons.
+    force_output_geometrytype = input_layer_info.geometrytype
+    if not explodecollections and force_output_geometrytype is not GeometryType.POINT:
+        force_output_geometrytype = force_output_geometrytype.to_multitype
+
+    # If the erase layer is made out of polygons, subdivide them if needed
+    tmp_dir = None
+    erase_layer_info = gfo.get_layerinfo(erase_path, erase_layer)
+    if (
+        subdivide_coords > 0
+        and erase_layer_info.geometrytype.to_primitivetype == PrimitiveType.POLYGON
+    ):
+        erase_layer = erase_layer_info.name
+
+        # If erase layer has complex geometries, subdivide them to speed up processing.
+        complexgeom_sql = f"""
+            SELECT 1
+              FROM "{erase_layer}" layer
+             WHERE ST_NPoints({erase_layer_info.geometrycolumn}) > {subdivide_coords}
+             LIMIT 1
+        """
+        logger.info(
+            f"Check if complex geometries in erase layer (> {subdivide_coords} coords)"
+        )
+        complexgeom_df = gfo.read_file(
+            erase_path, sql_stmt=complexgeom_sql, sql_dialect="SQLITE"
+        )
+        if len(complexgeom_df) > 0:
+            logger.info("Subdivide needed: complex geometries found")
+
+            # Do subdivide using python function, because all spatialite options didn't
+            # seem to work.
+            # Check out commits in https://github.com/geofileops/geofileops/pull/433
+            def subdivide(geom, num_coords_max):
+                result = pygeoops.subdivide(geom, num_coords_max=num_coords_max)
+
+                if result is None:
+                    return None
+                if not hasattr(result, "__len__"):
+                    return result
+                if len(result) == 1:
+                    return result[0]
+
+                # Explode because
+                #   - they will be exploded anyway by spatialite.ST_Collect
+                #   - spatialite.ST_AsBinary and/or spatialite.ST_GeomFromWkb don't seem
+                #     to handle nested collections well.
+                return shapely.GeometryCollection(shapely.get_parts(result).tolist())
+
+            tmp_dir = _io_util.create_tempdir("geofileops/erase_input")
+            erase_subdidided_path = tmp_dir / f"{erase_path.stem}_subdivided.gpkg"
+            _geoops_gpd.apply(
+                input_path=erase_path,
+                input_layer=erase_layer,
+                output_path=erase_subdidided_path,
+                output_layer=erase_layer,
+                func=lambda geom: subdivide(geom, num_coords_max=subdivide_coords),
+                operation_name="erase/subdivide",
+                columns=[],
+                explodecollections=True,
+                nb_parallel=nb_parallel,
+                batchsize=batchsize,
+                parallelization_config=_geoops_gpd.ParallelizationConfig(
+                    bytes_per_row=2000, max_rows_per_batch=50000
+                ),
+            )
+
+            erase_path = erase_subdidided_path
+
+    # Prepare sql template for this operation
+    # - WHERE geom IS NOT NULL to avoid rows with a NULL geom, they give issues in
+    #   later operations
+    # - use "LIMIT -1 OFFSET 0" to avoid the subquery flattening. Flattening e.g.
+    #   "geom IS NOT NULL" leads to GFO_Difference_Collection calculated double!
+    # - ST_Intersects and ST_Touches slow down a lot when the data contains huge geoms
+    # - Calculate difference in correlated subquery in SELECT clause reduces memory
+    #   usage by a factor 10 compared with a WITH with GROUP BY. The WITH with a GROUP
+    #   BY on layer1.rowid was a few % faster, but this is not worth it. E.g. for one
+    #   test file 4-7 GB per process versus 70-700 MB). For another: crash.
+    # - Check if the result of GFO_Difference_Collection is empty (NULL) using IFNULL,
+    #   and if this is the case set to 'DIFF_EMPTY'. This way we can make the
+    #   distinction whether the subquery is finding a row (no match with spatial index)
+    #   or if the difference results in an empty/NULL geometry.
+    #   Tried to return EMPTY GEOMETRY from GFO_Difference_Collection, but it didn't
+    #   work to use spatialite's ST_IsEmpty(geom) = 0 to filter on this, probably
+    #   because ST_GeomFromWKB doesn't seem to support empty polygons.
+    # - ST_difference(geometry , NULL) gives NULL as result -> handle explicitly
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+
+    sql_template = f"""
+        SELECT * FROM (
+          SELECT IFNULL(
+                   ( SELECT IFNULL(
+                               IIF({subdivide_coords} <= 0
+                                      OR ST_NPoints(layer1.{{input1_geometrycolumn}})
+                                             < {subdivide_coords},
+                                   IIF(ST_Union(layer2_sub.{{input2_geometrycolumn}})
+                                            IS NULL,
+                                       layer1.{{input1_geometrycolumn}},
+                                       ST_CollectionExtract(
+                                          ST_difference(
+                                             layer1.{{input1_geometrycolumn}},
+                                             ST_Union(
+                                                layer2_sub.{{input2_geometrycolumn}})
+                                          ),
+                                          {primitivetypeid}
+                                       )
+                                   ),
+                                   ST_GeomFromWKB(GFO_Difference_Collection(
+                                      ST_AsBinary(layer1.{{input1_geometrycolumn}}),
+                                      ST_AsBinary(ST_Collect(
+                                         layer2_sub.{{input2_geometrycolumn}}
+                                      )),
+                                      1,
+                                      {subdivide_coords}
+                                   ))
+                               ),
+                               'DIFF_EMPTY'
+                            ) AS diff_geom
+                       FROM {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                       JOIN {{input2_databasename}}."{{input2_layer}}" layer2_sub
+                       JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                         ON layer2_sub.rowid = layer2tree.id
+                      WHERE layer1tree.id = layer1.rowid
+                        AND layer1tree.minx <= layer2tree.maxx
+                        AND layer1tree.maxx >= layer2tree.minx
+                        AND layer1tree.miny <= layer2tree.maxy
+                        AND layer1tree.maxy >= layer2tree.miny
+                        AND ST_intersects(layer1.{{input1_geometrycolumn}},
+                                          layer2_sub.{{input2_geometrycolumn}}) = 1
+                      LIMIT -1 OFFSET 0
+                   ),
+                   layer1.{{input1_geometrycolumn}}
+                 ) AS geom
+                {{layer1_columns_prefix_alias_str}}
+                {{layer2_columns_prefix_alias_null_str}}
+            FROM {{input1_databasename}}."{{input1_layer}}" layer1
+           WHERE 1=1
+             {{batch_filter}}
+           LIMIT -1 OFFSET 0
+          )
+         WHERE geom IS NOT NULL
+           AND geom <> 'DIFF_EMPTY'
+           AND ST_IsEmpty(geom) = 0
+    """
+
+    # Go!
+    try:
+        _two_layer_vector_operation(
+            input1_path=input_path,
+            input2_path=erase_path,
+            output_path=output_path,
+            sql_template=sql_template,
+            operation_name=operation,
+            input1_layer=input_layer,
+            input1_columns=input_columns,
+            input1_columns_prefix=input_columns_prefix,
+            input2_layer=erase_layer,
+            input2_columns=[],
+            input2_columns_prefix="",
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            force_output_geometrytype=force_output_geometrytype,
+            gridsize=gridsize,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+            output_with_spatial_index=output_with_spatial_index,
+        )
+    finally:
+        if tmp_dir is not None:
+            shutil.rmtree(tmp_dir, ignore_errors=True)
+
+    # Print time taken
+    logger.info(f"Ready, full erase took {datetime.now()-start_time}")
+
+
+def export_by_location(
+    input_path: Path,
+    input_to_compare_with_path: Path,
+    output_path: Path,
+    min_area_intersect: Optional[float] = None,
+    area_inters_column_name: Optional[str] = None,
+    input_layer: Optional[str] = None,
+    input_columns: Optional[List[str]] = None,
+    input_to_compare_with_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Prepare sql template for this operation
+    # TODO: test performance difference between the following two queries
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+
+    # If intersect area needs to be calculated, other query needed
+    if area_inters_column_name is None and min_area_intersect is None:
+        sql_template = f"""
+            SELECT layer1.{{input1_geometrycolumn}} AS geom
+                  {{layer1_columns_prefix_alias_str}}
+              FROM {{input1_databasename}}."{{input1_layer}}" layer1
+              JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                ON layer1.fid = layer1tree.id
+             WHERE 1=1
+               {{batch_filter}}
+               AND EXISTS (
+                  SELECT 1
+                    FROM {{input2_databasename}}."{{input2_layer}}" layer2
+                    JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                      ON layer2.fid = layer2tree.id
+                   WHERE layer1tree.minx <= layer2tree.maxx
+                     AND layer1tree.maxx >= layer2tree.minx
+                     AND layer1tree.miny <= layer2tree.maxy
+                     AND layer1tree.maxy >= layer2tree.miny
+                     AND ST_intersects(layer1.{{input1_geometrycolumn}},
+                                       layer2.{{input2_geometrycolumn}}) = 1
+                     AND ST_touches(layer1.{{input1_geometrycolumn}},
+                                    layer2.{{input2_geometrycolumn}}) = 0)
+            """
+    else:
+        # Intersect area needs to be calculated
+        if area_inters_column_name is None:
+            area_inters_column_name = "area_inters"
+        area_inters_column_expression = f"""
+            ,ST_area(ST_intersection(
+                    ST_union(layer1.{{input1_geometrycolumn}}),
+                    ST_union(layer2.{{input2_geometrycolumn}})
+                )) AS {area_inters_column_name}
+        """
+
+        # Prepare sql template with intersect area calculation
+        sql_template = f"""
+            SELECT ST_union(layer1.{{input1_geometrycolumn}}) as geom
+                  {{layer1_columns_prefix_str}}
+                  {area_inters_column_expression}
+              FROM {{input1_databasename}}."{{input1_layer}}" layer1
+              JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                ON layer1.fid = layer1tree.id
+              JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+              JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                ON layer2.fid = layer2tree.id
+             WHERE 1=1
+               {{batch_filter}}
+               AND layer1tree.minx <= layer2tree.maxx
+               AND layer1tree.maxx >= layer2tree.minx
+               AND layer1tree.miny <= layer2tree.maxy
+               AND layer1tree.maxy >= layer2tree.miny
+               AND ST_Intersects(layer1.{{input1_geometrycolumn}},
+                                 layer2.{{input2_geometrycolumn}}) = 1
+               AND ST_Touches(layer1.{{input1_geometrycolumn}},
+                              layer2.{{input2_geometrycolumn}}) = 0
+             GROUP BY layer1.rowid {{layer1_columns_prefix_str}}
+        """
+
+        # Filter on intersect area if necessary
+        if min_area_intersect is not None:
+            sql_template = f"""
+                SELECT sub.* FROM
+                  ( {sql_template}
+                     LIMIT -1 OFFSET 0
+                  ) sub
+                WHERE sub.{area_inters_column_name} >= {min_area_intersect}
+            """
+
+    # Go!
+    input_layer_info = gfo.get_layerinfo(input_path, input_layer)
+    return _two_layer_vector_operation(
+        input1_path=input_path,
+        input2_path=input_to_compare_with_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="export_by_location",
+        input1_layer=input_layer,
+        input1_columns=input_columns,
+        input1_columns_prefix="",
+        input2_layer=input_to_compare_with_layer,
+        input2_columns=[],
+        input2_columns_prefix="",
+        output_layer=output_layer,
+        explodecollections=False,
+        force_output_geometrytype=input_layer_info.geometrytype,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def export_by_distance(
+    input_to_select_from_path: Path,
+    input_to_compare_with_path: Path,
+    output_path: Path,
+    max_distance: float,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input2_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Prepare sql template for this operation
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        SELECT geom
+              {{layer1_columns_prefix_alias_str}}
+          FROM {{input1_databasename}}."{{input1_layer}}" layer1
+          JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+            ON layer1.fid = layer1tree.id
+         WHERE 1=1
+               {{batch_filter}}
+               AND EXISTS (
+                    SELECT 1
+                      FROM {{input2_databasename}}."{{input2_layer}}" layer2
+                      JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                        ON layer2.fid = layer2tree.id
+                     WHERE (layer1tree.minx-{max_distance}) <= layer2tree.maxx
+                       AND (layer1tree.maxx+{max_distance}) >= layer2tree.minx
+                       AND (layer1tree.miny-{max_distance}) <= layer2tree.maxy
+                       AND (layer1tree.maxy+{max_distance}) >= layer2tree.miny
+                       AND ST_distance(
+                            layer1.{{input1_geometrycolumn}},
+                            layer2.{{input2_geometrycolumn}}) <= {max_distance})
+    """
+
+    input_layer_info = gfo.get_layerinfo(input_to_select_from_path, input1_layer)
+
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input_to_select_from_path,
+        input2_path=input_to_compare_with_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="export_by_distance",
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix="",
+        input2_layer=input2_layer,
+        input2_columns=[],
+        input2_columns_prefix="",
+        output_layer=output_layer,
+        explodecollections=False,
+        force_output_geometrytype=input_layer_info.geometrytype,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def intersection(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+    output_with_spatial_index: bool = True,
+    operation_prefix: str = "",
+):
+    # In the query, important to only extract the geometry types that are expected
+    # TODO: test for geometrycollection, line, point,...
+    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
+    input2_layer_info = gfo.get_layerinfo(input2_path, input2_layer)
+    primitivetype_to_extract = PrimitiveType(
+        min(
+            input1_layer_info.geometrytype.to_primitivetype.value,
+            input2_layer_info.geometrytype.to_primitivetype.value,
+        )
+    )
+
+    # Force MULTI variant if explodecollections is False to avoid ugly warnings/issues.
+    if explodecollections:
+        force_output_geometrytype = primitivetype_to_extract.to_singletype
+    else:
+        force_output_geometrytype = primitivetype_to_extract.to_multitype
+
+    # Prepare sql template for this operation
+    #
+    # Remarks:
+    # - ST_Intersects is fine, but ST_Touches slows down. Especially when the data
+    #   contains huge geoms, time doubles or worse. The filter on sub.geom IS NOT NULL
+    #   removes rows without intersection anyway.
+    # - use "LIMIT -1 OFFSET 0" to avoid the subquery flattening. Flattening e.g.
+    #   "geom IS NOT NULL" leads to geom operation to be calculated twice!
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        SELECT sub.geom
+             {{layer1_columns_from_subselect_str}}
+             {{layer2_columns_from_subselect_str}}
+          FROM
+            ( SELECT ST_CollectionExtract(
+                       ST_Intersection(
+                            layer1.{{input1_geometrycolumn}},
+                            layer2.{{input2_geometrycolumn}}),
+                            {primitivetype_to_extract.value}) AS geom
+                    {{layer1_columns_prefix_alias_str}}
+                    {{layer2_columns_prefix_alias_str}}
+                FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                  ON layer1.fid = layer1tree.id
+                JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                  ON layer2.fid = layer2tree.id
+               WHERE 1=1
+                 {{batch_filter}}
+                 AND layer1tree.minx <= layer2tree.maxx
+                 AND layer1tree.maxx >= layer2tree.minx
+                 AND layer1tree.miny <= layer2tree.maxy
+                 AND layer1tree.maxy >= layer2tree.miny
+                 AND ST_Intersects(
+                        layer1.{{input1_geometrycolumn}},
+                        layer2.{{input2_geometrycolumn}}) = 1
+                 --AND ST_Touches(
+                 --       layer1.{{input1_geometrycolumn}},
+                 --       layer2.{{input2_geometrycolumn}}) = 0
+               LIMIT -1 OFFSET 0
+            ) sub
+         WHERE sub.geom IS NOT NULL
+    """
+
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name=f"{operation_prefix}intersection",
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+        output_with_spatial_index=output_with_spatial_index,
+    )
+
+
+def join_by_location(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    spatial_relations_query: str = "intersects is True",
+    discard_nonmatching: bool = True,
+    min_area_intersect: Optional[float] = None,
+    area_inters_column_name: Optional[str] = None,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Prepare sql template for this operation
+    # Prepare intersection area columns/filter
+    area_inters_column_expression = ""
+    area_inters_column_in_output = ""
+    area_inters_column_0_in_output = ""
+    area_inters_filter = ""
+    if area_inters_column_name is not None or min_area_intersect is not None:
+        if area_inters_column_name is not None:
+            area_inters_column_name_touse = area_inters_column_name
+            area_inters_column_in_output = f',"{area_inters_column_name}"'
+            area_inters_column_0_in_output = f',0 AS "{area_inters_column_name}"'
+        else:
+            area_inters_column_name_touse = "area_inters"
+        area_inters_column_expression = (
+            ",ST_area(ST_intersection(sub_filter.geom, sub_filter.l2_geom)) "
+            f'as "{area_inters_column_name_touse}"'
+        )
+        if min_area_intersect is not None:
+            area_inters_filter = (
+                f'WHERE sub_area."{area_inters_column_name_touse}" '
+                f">= {min_area_intersect}"
+            )
+
+    # Prepare spatial relations filter
+    if spatial_relations_query != "intersects is True":
+        # joining should only be possible on features that at least have an
+        # interaction! So, add "intersects is True" to query to avoid errors!
+        spatial_relations_query = f"({spatial_relations_query}) and intersects is True"
+    spatial_relations_filter = _prepare_spatial_relations_filter(
+        spatial_relations_query
+    )
+
+    # Prepare sql template
+    #
+    # Remark: use "LIMIT -1 OFFSET 0" to avoid that the sqlite query optimizer
+    #     "flattens" the subquery, as that makes checking the spatial
+    #     relations (using ST_RelateMatch) very slow!
+    input1_layer_rtree = "rtree_{input1_layer}_{input1_geometrycolumn}"
+    input2_layer_rtree = "rtree_{input2_layer}_{input2_geometrycolumn}"
+    sql_template = f"""
+        WITH layer1_relations_filtered AS (
+          SELECT sub_area.*
+            FROM (
+              SELECT sub_filter.*
+                    {area_inters_column_expression}
+                FROM (
+                  SELECT layer1.{{input1_geometrycolumn}} AS geom
+                        ,layer1.fid l1_fid
+                        ,layer2.{{input2_geometrycolumn}} AS l2_geom
+                        {{layer1_columns_prefix_alias_str}}
+                        {{layer2_columns_prefix_alias_str}}
+                        ,ST_relate(
+                            layer1.{{input1_geometrycolumn}},
+                            layer2.{{input2_geometrycolumn}}
+                         ) AS "GFO_$TEMP$_SPATIAL_RELATION"
+                    FROM {{input1_databasename}}."{{input1_layer}}" layer1
+                    JOIN {{input1_databasename}}."{input1_layer_rtree}" layer1tree
+                      ON layer1.fid = layer1tree.id
+                    JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                    JOIN {{input2_databasename}}."{input2_layer_rtree}" layer2tree
+                      ON layer2.fid = layer2tree.id
+                   WHERE 1=1
+                     {{batch_filter}}
+                     AND layer1tree.minx <= layer2tree.maxx
+                     AND layer1tree.maxx >= layer2tree.minx
+                     AND layer1tree.miny <= layer2tree.maxy
+                     AND layer1tree.maxy >= layer2tree.miny
+                   LIMIT -1 OFFSET 0
+                  ) sub_filter
+               WHERE {spatial_relations_filter.format(
+                    spatial_relation='sub_filter."GFO_$TEMP$_SPATIAL_RELATION"')}
+               LIMIT -1 OFFSET 0
+              ) sub_area
+           {area_inters_filter}
+          )
+        SELECT sub.geom
+              {{layer1_columns_from_subselect_str}}
+              {{layer2_columns_from_subselect_str}}
+              ,sub."GFO_$TEMP$_SPATIAL_RELATION" AS spatial_relation
+              {area_inters_column_in_output}
+          FROM layer1_relations_filtered sub
+    """
+
+    # If a left join is asked, add all features from layer1 that weren't
+    # matched.
+    if discard_nonmatching is False:
+        sql_template = f"""
+            {sql_template}
+            UNION ALL
+            SELECT layer1.{{input1_geometrycolumn}} as geom
+                  {{layer1_columns_prefix_alias_str}}
+                  {{layer2_columns_prefix_alias_null_str}}
+                  ,NULL AS spatial_relation
+                  {area_inters_column_0_in_output}
+              FROM {{input1_databasename}}."{{input1_layer}}" layer1
+             WHERE 1=1
+               {{batch_filter}}
+               AND layer1.fid NOT IN (
+                   SELECT l1_fid FROM layer1_relations_filtered)
+        """
+
+    # Go!
+    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
+    return _two_layer_vector_operation(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="join_by_location",
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=input1_layer_info.geometrytype,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def _prepare_spatial_relations_filter(query: str) -> str:
+    named_spatial_relations = {
+        # "disjoint": ["FF*FF****"],
+        "equals": ["TFFF*FFF*"],
+        "touches": ["FT*******", "F**T*****", "F***T****"],
+        "within": ["T*F**F***"],
+        "overlaps": ["T*T***T**", "1*T***T**"],
+        "crosses": ["T*T******", "T*****T**", "0********"],
+        "intersects": ["T********", "*T*******", "***T*****", "****T****"],
+        "contains": ["T*****FF*"],
+        "covers": ["T*****FF*", "*T****FF*", "***T**FF*", "****T*FF*"],
+        "coveredby": ["T*F**F***", "*TF**F***", "**FT*F***", "**F*TF***"],
+    }
+
+    # Parse query and replace things that need to be replaced
+    import re
+
+    query_tokens = re.split("([ =()])", query)
+
+    query_tokens_prepared = []
+    nb_unclosed_brackets = 0
+    for token in query_tokens:
+        if token == "":
+            continue
+        elif token in [" ", "\n", "\t", "and", "or"]:
+            query_tokens_prepared.append(token)
+        elif token == "(":
+            nb_unclosed_brackets += 1
+            query_tokens_prepared.append(token)
+        elif token == ")":
+            nb_unclosed_brackets -= 1
+            query_tokens_prepared.append(token)
+        elif token == "is":
+            query_tokens_prepared.append("=")
+        elif token == "True":
+            query_tokens_prepared.append("1")
+        elif token == "False":
+            query_tokens_prepared.append("0")
+        elif token in named_spatial_relations:
+            match_list = []
+            for spatial_relation in named_spatial_relations[token]:
+                match = (
+                    f"ST_RelateMatch({{spatial_relation}}, '{spatial_relation}') = 1"
+                )
+                match_list.append(match)
+            query_tokens_prepared.append(f"({' or '.join(match_list)})")
+        elif len(token) == 9 and re.fullmatch("^[FT012*]+$", token) is not None:
+            token_prepared = f"ST_RelateMatch({{spatial_relation}}, '{token}')"
+            query_tokens_prepared.append(token_prepared)
+        else:
+            raise ValueError(
+                f"Unexpected token in query (query is case sensitive!): {token}"
+            )
+
+    # If there are unclosed brackets, raise
+    if nb_unclosed_brackets > 0:
+        raise ValueError(f"not all brackets are closed in query {query}")
+    elif nb_unclosed_brackets < 0:
+        raise ValueError(f"more closing brackets than opening ones in query {query}")
+
+    result = f"({''.join(query_tokens_prepared)})"
+    return result
+
+
+def join_nearest(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    nb_nearest: int,
+    distance: float,
+    expand: bool,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    force: bool = False,
+):
+    # Init some things...
+    # Because there is preprocessing done in this function, check output path
+    # here already
+    logger = logging.getLogger("geofileops.join_nearest")
+    if output_path.exists() and force is False:
+        logger.info(f"Stop, output exists already {output_path}")
+        return
+    if input1_layer is None:
+        input1_layer = gfo.get_only_layer(input1_path)
+    if input2_layer is None:
+        input2_layer = gfo.get_only_layer(input2_path)
+
+    # If spatialite >= 5.1, check some more parameters
+    if SPATIALITE_GTE_51:
+        if distance is None:
+            raise ValueError("distance is mandatory with spatialite >= 5.1")
+        if expand is None:
+            raise ValueError("expand is mandatory with spatialite >= 5.1")
+        expand_int = 1 if expand else False
+    else:
+        if expand is not None and not expand:
+            raise ValueError("expand=False is not supported with spatialite < 5.1")
+
+    # Prepare input files
+    # To use knn index, the input layers need to be in sqlite file format
+    # (not a .gpkg!), so prepare this
+    if input1_path == input2_path and gfo.get_driver(input1_path) == "SQLite":
+        # Input files already ok...
+        input1_tmp_path = input1_path
+        input1_tmp_layer = input1_layer
+        input2_tmp_path = input2_path
+        input2_tmp_layer = input2_layer
+    else:
+        # Put input2 layer in sqlite gfo...
+        tempdir = _io_util.create_tempdir("geofileops/join_nearest")
+        input1_tmp_path = tempdir / "both_input_layers.sqlite"
+        input1_tmp_layer = "input1_layer"
+        gfo.copy_layer(
+            src=input1_path,
+            src_layer=input1_layer,
+            dst=input1_tmp_path,
+            dst_layer=input1_tmp_layer,
+            preserve_fid=True,
+        )
+
+        # Add input2 layer to sqlite gfo...
+        input2_tmp_path = input1_tmp_path
+        input2_tmp_layer = "input2_layer"
+        gfo.append_to(
+            src=input2_path,
+            src_layer=input2_layer,
+            dst=input2_tmp_path,
+            dst_layer=input2_tmp_layer,
+            preserve_fid=True,
+        )
+
+    # Remark: the 2 input layers need to be in one file!
+    if SPATIALITE_GTE_51:
+        sql_template = f"""
+            SELECT layer1.{{input1_geometrycolumn}} as geom
+                  {{layer1_columns_prefix_alias_str}}
+                  {{layer2_columns_prefix_alias_str}}
+                  ,k.pos, k.distance_m AS distance, k.distance_crs
+              FROM "{{input1_layer}}" layer1
+              JOIN knn2 k
+              JOIN "{{input2_layer}}" layer2 ON layer2.rowid = k.fid
+             WHERE f_table_name = '{{input2_layer}}'
+               AND f_geometry_column = '{{input2_geometrycolumn}}'
+               AND ref_geometry = ST_Centroid(layer1.{{input1_geometrycolumn}})
+               AND radius = {distance}
+               AND max_items = {nb_nearest}
+               AND expand = {expand_int}
+               {{batch_filter}}
+        """
+    else:
+        sql_template = f"""
+            SELECT layer1.{{input1_geometrycolumn}} as geom
+                  {{layer1_columns_prefix_alias_str}}
+                  {{layer2_columns_prefix_alias_str}}
+                  ,k.pos, k.distance
+              FROM {{input1_databasename}}."{{input1_layer}}" layer1
+              JOIN {{input2_databasename}}.knn k
+              JOIN {{input2_databasename}}."{{input2_layer}}" layer2
+                ON layer2.rowid = k.fid
+             WHERE k.f_table_name = '{{input2_layer}}'
+               AND k.f_geometry_column = '{{input2_geometrycolumn}}'
+               AND k.ref_geometry = layer1.{{input1_geometrycolumn}}
+               AND k.max_items = {nb_nearest}
+               {{batch_filter}}
+        """
+
+    input1_layer_info = gfo.get_layerinfo(input1_path, input1_layer)
+
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input1_tmp_path,
+        input2_path=input2_tmp_path,
+        output_path=output_path,
+        sql_template=sql_template,
+        operation_name="join_nearest",
+        input1_layer=input1_tmp_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_tmp_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        force_output_geometrytype=input1_layer_info.geometrytype,
+        explodecollections=explodecollections,
+        gridsize=0.0,
+        where_post=None,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+        use_ogr=True,
+    )
+
+
+def select_two_layers(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    sql_stmt: str,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    force_output_geometrytype: Optional[GeometryType] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = 1,
+    batchsize: int = -1,
+    force: bool = False,
+    operation_prefix: str = "",
+):
+    # Go!
+    return _two_layer_vector_operation(
+        input1_path=input1_path,
+        input2_path=input2_path,
+        output_path=output_path,
+        sql_template=sql_stmt,
+        operation_name=f"{operation_prefix}select_two_layers",
+        input1_layer=input1_layer,
+        input1_columns=input1_columns,
+        input1_columns_prefix=input1_columns_prefix,
+        input2_layer=input2_layer,
+        input2_columns=input2_columns,
+        input2_columns_prefix=input2_columns_prefix,
+        output_layer=output_layer,
+        explodecollections=explodecollections,
+        force_output_geometrytype=force_output_geometrytype,
+        gridsize=gridsize,
+        where_post=where_post,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        force=force,
+    )
+
+
+def identity(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = 1,
+    batchsize: int = -1,
+    subdivide_coords: int = 2000,
+    force: bool = False,
+):
+    # An identity is the combination of the results of an "intersection" of input1 and
+    # input2 and an erase of input2 with input1.
+
+    # Because the calculations of the intermediate results will be towards temp files,
+    # we need to do some additional init + checks here...
+    if subdivide_coords < 0:
+        raise ValueError("subdivide_coords < 0 is not allowed")
+    logger = logging.getLogger("geofileops.identity")
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop, output exists already {output_path}")
+            return
+        else:
+            gfo.remove(output_path)
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    start_time = datetime.now()
+    tempdir = _io_util.create_tempdir("geofileops/identity")
+    try:
+        # First calculate intersection of input1 with input2 to a temporary output file
+        logger.info("Step 1 of 3: intersection")
+        intersection_output_path = tempdir / "intersection_output.gpkg"
+        intersection(
+            input1_path=input1_path,
+            input2_path=input2_path,
+            output_path=intersection_output_path,
+            input1_layer=input1_layer,
+            input1_columns=input1_columns,
+            input1_columns_prefix=input1_columns_prefix,
+            input2_layer=input2_layer,
+            input2_columns=input2_columns,
+            input2_columns_prefix=input2_columns_prefix,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+            output_with_spatial_index=False,
+            operation_prefix="identity/",
+        )
+
+        # Now erase input1 from input2 to another temporary output gfo...
+        logger.info("Step 2 of 3: erase")
+        erase_output_path = tempdir / "erase_output.gpkg"
+        erase(
+            input_path=input1_path,
+            erase_path=input2_path,
+            output_path=erase_output_path,
+            input_layer=input1_layer,
+            input_columns=input1_columns,
+            input_columns_prefix=input1_columns_prefix,
+            erase_layer=input2_layer,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            subdivide_coords=subdivide_coords,
+            force=force,
+            output_with_spatial_index=False,
+            operation_prefix="identity/",
+        )
+
+        # Now append
+        logger.info("Step 3 of 3: finalize")
+        # Note: append will never create an index on an already existing layer.
+        _append_to_nolock(
+            src=erase_output_path,
+            dst=intersection_output_path,
+            src_layer=output_layer,
+            dst_layer=output_layer,
+        )
+
+        # Convert or add spatial index
+        tmp_output_path = intersection_output_path
+        if intersection_output_path.suffix != output_path.suffix:
+            # Output file should be in different format, so convert
+            tmp_output_path = tempdir / output_path.name
+            gfo.copy_layer(src=intersection_output_path, dst=tmp_output_path)
+        else:
+            # Create spatial index
+            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
+
+        # Now we are ready to move the result to the final spot...
+        gfo.move(tmp_output_path, output_path)
+
+    finally:
+        shutil.rmtree(tempdir, ignore_errors=True)
+
+    logger.info(f"Ready, full identity took {datetime.now()-start_time}")
+
+
+def symmetric_difference(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    subdivide_coords: int = 2000,
+    force: bool = False,
+):
+    # A symmetric difference can be simulated by doing an "erase" of input1
+    # and input2 and then append the result of an erase of input2 with
+    # input1...
+
+    # Because both erase calculations will be towards temp files,
+    # we need to do some additional init + checks here...
+    if subdivide_coords < 0:
+        raise ValueError("subdivide_coords < 0 is not allowed")
+    if force is False and output_path.exists():
+        return
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    start_time = datetime.now()
+    logger = logging.getLogger("geofileops.symmetric_difference")
+    logger.info(
+        f"Start, with input1: {input1_path}, "
+        f"input2: {input2_path}, output: {output_path}"
+    )
+    tempdir = _io_util.create_tempdir("geofileops/symmdiff")
+    try:
+        # First erase input2 from input1 to a temporary output file
+        logger.info("Step 1 of 3: erase 1")
+        erase1_output_path = tempdir / "layer1_erase_layer2_output.gpkg"
+        erase(
+            input_path=input1_path,
+            erase_path=input2_path,
+            output_path=erase1_output_path,
+            input_layer=input1_layer,
+            input_columns=input1_columns,
+            input_columns_prefix=input1_columns_prefix,
+            erase_layer=input2_layer,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            subdivide_coords=subdivide_coords,
+            force=force,
+            output_with_spatial_index=False,
+            operation_prefix="symmetric_difference/",
+        )
+
+        if input2_columns is None or len(input2_columns) > 0:
+            input2_info = gfo.get_layerinfo(input2_path)
+            columns_to_add = (
+                input2_columns if input2_columns is not None else input2_info.columns
+            )
+            for column in columns_to_add:
+                gfo.add_column(
+                    erase1_output_path,
+                    name=f"{input2_columns_prefix}{column}",
+                    type=input2_info.columns[column].gdal_type,
+                )
+
+        # Now erase input1 from input2 to another temporary output file
+        logger.info("Step 2 of 3: erase 2")
+        erase2_output_path = tempdir / "layer2_erase_layer1_output.gpkg"
+        erase(
+            input_path=input2_path,
+            erase_path=input1_path,
+            output_path=erase2_output_path,
+            input_layer=input2_layer,
+            input_columns=input2_columns,
+            input_columns_prefix=input2_columns_prefix,
+            erase_layer=input1_layer,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            subdivide_coords=subdivide_coords,
+            force=force,
+            output_with_spatial_index=False,
+            operation_prefix="symmetric_difference/",
+        )
+
+        # Now append
+        logger.info("Step 3 of 3: finalize")
+        # Note: append will never create an index on an already existing layer.
+        _append_to_nolock(
+            src=erase2_output_path,
+            dst=erase1_output_path,
+            src_layer=output_layer,
+            dst_layer=output_layer,
+        )
+
+        # Convert or add spatial index
+        tmp_output_path = erase1_output_path
+        if erase1_output_path.suffix != output_path.suffix:
+            # Output file should be in diffent format, so convert
+            tmp_output_path = tempdir / output_path.name
+            gfo.copy_layer(src=erase1_output_path, dst=tmp_output_path)
+        else:
+            # Create spatial index
+            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
+
+        # Now we are ready to move the result to the final spot...
+        if output_path.exists():
+            gfo.remove(output_path)
+        gfo.move(tmp_output_path, output_path)
+
+    finally:
+        shutil.rmtree(tempdir, ignore_errors=True)
+
+    logger.info(f"Ready, full symmetric_difference took {datetime.now()-start_time}")
+
+
+def union(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    input1_layer: Optional[str] = None,
+    input1_columns: Optional[List[str]] = None,
+    input1_columns_prefix: str = "l1_",
+    input2_layer: Optional[str] = None,
+    input2_columns: Optional[List[str]] = None,
+    input2_columns_prefix: str = "l2_",
+    output_layer: Optional[str] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    where_post: Optional[str] = None,
+    nb_parallel: int = -1,
+    batchsize: int = -1,
+    subdivide_coords: int = 2000,
+    force: bool = False,
+):
+    # A union is the combination of the results of an intersection of input1 and input2,
+    # the result of an erase of input2 with input1 and the erase of input1 with input2.
+
+    # Because the calculations of the intermediate results will be towards temp files,
+    # we need to do some additional init + checks here...
+    if subdivide_coords < 0:
+        raise ValueError("subdivide_coords < 0 is not allowed")
+
+    logger = logging.getLogger("geofileops.union")
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop, output exists already {output_path}")
+            return
+        else:
+            gfo.remove(output_path)
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    start_time = datetime.now()
+    tempdir = _io_util.create_tempdir("geofileops/union")
+    try:
+        # First apply intersection of input1 with input2 to a temporary output file...
+        logger.info("Step 1 of 4: intersection")
+        intersection_output_path = tempdir / "intersection_output.gpkg"
+        intersection(
+            input1_path=input1_path,
+            input2_path=input2_path,
+            output_path=intersection_output_path,
+            input1_layer=input1_layer,
+            input1_columns=input1_columns,
+            input1_columns_prefix=input1_columns_prefix,
+            input2_layer=input2_layer,
+            input2_columns=input2_columns,
+            input2_columns_prefix=input2_columns_prefix,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            force=force,
+            output_with_spatial_index=False,
+            operation_prefix="union/",
+        )
+
+        # Now erase input1 from input2 to another temporary output gfo...
+        logger.info("Step 2 of 4: erase input 1 from input 2")
+        erase1_output_path = tempdir / "erase_input1_from_input2_output.gpkg"
+        erase(
+            input_path=input2_path,
+            erase_path=input1_path,
+            output_path=erase1_output_path,
+            input_layer=input2_layer,
+            input_columns=input2_columns,
+            input_columns_prefix=input2_columns_prefix,
+            erase_layer=input1_layer,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            subdivide_coords=subdivide_coords,
+            force=force,
+            output_with_spatial_index=False,
+            operation_prefix="union/",
+        )
+
+        # Now erase input2 from input1 to another temporary output gfo...
+        logger.info("Step 3 of 4: erase input 2 from input 1")
+        erase2_output_path = tempdir / "erase_input2_from_input1_output.gpkg"
+        erase(
+            input_path=input1_path,
+            erase_path=input2_path,
+            output_path=erase2_output_path,
+            input_layer=input1_layer,
+            input_columns=input1_columns,
+            input_columns_prefix=input1_columns_prefix,
+            erase_layer=input2_layer,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            gridsize=gridsize,
+            where_post=where_post,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            subdivide_coords=subdivide_coords,
+            force=force,
+            output_with_spatial_index=False,
+            operation_prefix="union/",
+        )
+
+        # Now append
+        logger.info("Step 4 of 4: finalize")
+        # Note: append will never create an index on an already existing layer.
+        _append_to_nolock(
+            src=erase1_output_path,
+            dst=intersection_output_path,
+            src_layer=output_layer,
+            dst_layer=output_layer,
+        )
+        _append_to_nolock(
+            src=erase2_output_path,
+            dst=intersection_output_path,
+            src_layer=output_layer,
+            dst_layer=output_layer,
+        )
+
+        # Convert or add spatial index
+        tmp_output_path = intersection_output_path
+        if intersection_output_path.suffix != output_path.suffix:
+            # Output file should be in different format, so convert
+            tmp_output_path = tempdir / output_path.name
+            gfo.copy_layer(src=intersection_output_path, dst=tmp_output_path)
+        else:
+            # Create spatial index
+            gfo.create_spatial_index(path=tmp_output_path, layer=output_layer)
+
+        # Now we are ready to move the result to the final spot...
+        gfo.move(tmp_output_path, output_path)
+
+    finally:
+        shutil.rmtree(tempdir, ignore_errors=True)
+
+    logger.info(f"Ready, full union took {datetime.now()-start_time}")
+
+
+def _two_layer_vector_operation(
+    input1_path: Path,
+    input2_path: Path,
+    output_path: Path,
+    sql_template: str,
+    operation_name: str,
+    input1_layer: Optional[str],
+    input1_columns: Optional[List[str]],
+    input1_columns_prefix: str,
+    input2_layer: Optional[str],
+    input2_columns: Optional[List[str]],
+    input2_columns_prefix: str,
+    output_layer: Optional[str],
+    explodecollections: bool,
+    force_output_geometrytype: Optional[GeometryType],
+    gridsize: float,
+    where_post: Optional[str],
+    nb_parallel: int,
+    batchsize: int,
+    force: bool,
+    use_ogr: bool = False,
+    output_with_spatial_index: bool = True,
+):
+    """
+    Executes an operation that needs 2 input files.
+
+    Args:
+        input1_path (str): the file to export features from
+        input2_path (str): the file to check intersections with
+        output_path (str): output file
+                input1_layer (str, optional): input layer name. Optional if the
+            file only contains one layer. Defaults to None.
+        operation_name (str): name of the operation to be used in logging.
+        sql_template (str): the SELECT sql statement to be executed.
+        input1_layer (str): input1 layer name.
+        input1_columns (List[str]): list of columns to retain. If None, all
+            standard columns are retained. In addition to standard columns, it is also
+            possible to specify "fid", a unique index available in all input files. Note
+            that the "fid" will be aliased even if input1_columns_prefix is "", eg. to
+            "fid_1".
+        input1_columns_prefix (str): prefix to use in the column aliases.
+        input2_layer (str): input2 layer name.
+        input2_columns (List[str]): columns to select. If None is specified,
+            all columns are selected. As explained for input1_columns, it is also
+            possible to specify "fid".
+        input2_columns_prefix (str): prefix to use in the column aliases.
+        output_layer (str): [description]. Defaults to None.
+        explodecollections (bool, optional): Explode collecions in output.
+            Defaults to False.
+        force_output_geometrytype (GeometryType, optional): Defaults to None.
+        gridsize (float, optional): the size of the grid the coordinates of the ouput
+            will be rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change
+            the precision. Defaults to 0.0.
+        where_post (str, optional): sql filter to apply after all other processing,
+            including e.g. explodecollections. It should be in sqlite syntax and
+            |spatialite_reference_link| functions can be used. Defaults to None.
+        nb_parallel (int, optional): [description]. Defaults to -1.
+        batchsize (int, optional): indicative number of rows to process per
+            batch. A smaller batch size, possibly in combination with a
+            smaller nb_parallel, will reduce the memory usage.
+            Defaults to -1: (try to) determine optimal size automatically.
+        force (bool, optional): [description]. Defaults to False.
+        use_ogr (bool, optional): If True, ogr is used to do the processing,
+            In this case different input files (input1_path, input2_path) are
+            NOT supported. If False, sqlite3 is used directly.
+            Defaults to False.
+        output_with_spatial_index (bool, optional): True to create output file with
+            spatial index. Defaults to True.
+
+    Raises:
+        ValueError: [description]
+
+    .. |spatialite_reference_link| raw:: html
+
+        <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-latest.html" target="_blank">spatialite reference</a>
+
+    """  # noqa: E501
+    # Init
+    logger = logging.getLogger(f"geofileops.{operation_name}")
+
+    if not input1_path.exists():
+        raise ValueError(f"{operation_name}: input1_path doesn't exist: {input1_path}")
+    if not input2_path.exists():
+        raise ValueError(f"{operation_name}: input2_path doesn't exist: {input2_path}")
+    if output_path in (input1_path, input2_path):
+        raise ValueError(
+            f"{operation_name}: output_path must not equal one of input paths"
+        )
+    if use_ogr is True and input1_path != input2_path:
+        raise ValueError(
+            f"{operation_name}: if use_ogr True, input1_path should equal input2_path!"
+        )
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop, output exists already {output_path}")
+            return
+        else:
+            gfo.remove(output_path)
+
+    # Check if spatialite is properly installed to execute this query
+    _sqlite_util.spatialite_version_info()
+
+    # Init layer info
+    start_time = datetime.now()
+    if input1_layer is None:
+        input1_layer = gfo.get_only_layer(input1_path)
+    if input2_layer is None:
+        input2_layer = gfo.get_only_layer(input2_path)
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+    tempdir = _io_util.create_tempdir(f"geofileops/{operation_name}")
+
+    # Prepare output filename
+    tmp_output_path = tempdir / output_path.name
+    tmp_output_path.parent.mkdir(exist_ok=True, parents=True)
+    gfo.remove(tmp_output_path)
+
+    try:
+        # Prepare tmp files/batches
+        # -------------------------
+        logger.debug(f"Prepare input (params), tempdir: {tempdir}")
+        processing_params = _prepare_processing_params(
+            input1_path=input1_path,
+            input1_layer=input1_layer,
+            input1_layer_alias="layer1",
+            input2_path=input2_path,
+            input2_layer=input2_layer,
+            tempdir=tempdir,
+            nb_parallel=nb_parallel,
+            batchsize=batchsize,
+            convert_to_spatialite_based=True,
+        )
+        if processing_params is None or processing_params.batches is None:
+            return
+
+        # Do some checks on the placeholders
+        sql_template_placeholders = [
+            name for _, name, _, _ in string.Formatter().parse(sql_template) if name
+        ]
+
+        # Warn no if "{input*_databasename}". placeholders present
+        if "input1_databasename" not in sql_template_placeholders:
+            logger.warning(
+                'A placeholder "{input1_databasename}". is recommended '
+                "as prefix for the input1 layer/rtree/tables used in sql_stmt."
+            )
+        if "input2_databasename" not in sql_template_placeholders:
+            logger.warning(
+                'A placeholder "{input2_databasename}". is recommended '
+                "as prefix for the input2 layer/rtree/tables used in sql_stmt."
+            )
+
+        # If multiple batches, mandatory "batch_filter" placeholder in sql_template
+        nb_batches = len(processing_params.batches)
+        if nb_batches > 1:
+            if "batch_filter" not in sql_template_placeholders:
+                raise ValueError(
+                    "Number batches > 1 requires a batch_filter placeholder in "
+                    f"sql_template {sql_template}"
+                )
+
+        # Prepare column names,... to format the select
+        # ---------------------------------------------
+        # Format column strings for use in select
+        assert processing_params.input1_path is not None
+        input1_tmp_layerinfo = gfo.get_layerinfo(
+            processing_params.input1_path,
+            processing_params.input1_layer,
+            raise_on_nogeom=False,
+        )
+        input1_col_strs = _ogr_sql_util.ColumnFormatter(
+            columns_asked=input1_columns,
+            columns_in_layer=input1_tmp_layerinfo.columns,
+            fid_column=input1_tmp_layerinfo.fid_column,
+            table_alias="layer1",
+            column_alias_prefix=input1_columns_prefix,
+        )
+        assert processing_params.input2_path is not None
+        input2_tmp_layerinfo = gfo.get_layerinfo(
+            processing_params.input2_path,
+            processing_params.input2_layer,
+            raise_on_nogeom=False,
+        )
+        input2_col_strs = _ogr_sql_util.ColumnFormatter(
+            columns_asked=input2_columns,
+            columns_in_layer=input2_tmp_layerinfo.columns,
+            fid_column=input2_tmp_layerinfo.fid_column,
+            table_alias="layer2",
+            column_alias_prefix=input2_columns_prefix,
+        )
+
+        # Check input crs'es
+        if input1_tmp_layerinfo.crs != input2_tmp_layerinfo.crs:
+            logger.warning(
+                f"input1 has a different crs than input2: \n\tinput1: "
+                f"{input1_tmp_layerinfo.crs} \n\tinput2: {input2_tmp_layerinfo.crs}"
+            )
+
+        # Fill out sql_template as much as possible already
+        # -------------------------------------------------
+        # Keep input1_tmp_layer and input2_tmp_layer for backwards compatibility
+        sql_template = sql_template.format(
+            input1_databasename="{input1_databasename}",
+            input2_databasename="{input2_databasename}",
+            layer1_columns_from_subselect_str=input1_col_strs.from_subselect(),
+            layer1_columns_prefix_alias_str=input1_col_strs.prefixed_aliased(),
+            layer1_columns_prefix_str=input1_col_strs.prefixed(),
+            input1_layer=processing_params.input1_layer,
+            input1_tmp_layer=processing_params.input1_layer,
+            input1_geometrycolumn=input1_tmp_layerinfo.geometrycolumn,
+            layer2_columns_from_subselect_str=input2_col_strs.from_subselect(),
+            layer2_columns_prefix_alias_str=input2_col_strs.prefixed_aliased(),
+            layer2_columns_prefix_str=input2_col_strs.prefixed(),
+            layer2_columns_prefix_alias_null_str=input2_col_strs.null_aliased(),
+            input2_layer=processing_params.input2_layer,
+            input2_tmp_layer=processing_params.input2_layer,
+            input2_geometrycolumn=input2_tmp_layerinfo.geometrycolumn,
+            batch_filter="{batch_filter}",
+        )
+
+        # Determine column names and types based on sql statement
+        column_datatypes = None
+        # Use first batch_filter to improve performance
+        sql_stmt = sql_template.format(
+            input1_databasename="{input1_databasename}",
+            input2_databasename="{input2_databasename}",
+            batch_filter=processing_params.batches[0]["batch_filter"],
+        )
+        column_datatypes = _sqlite_util.get_columns(
+            sql_stmt=sql_stmt,
+            input1_path=processing_params.input1_path,
+            input2_path=processing_params.input2_path,
+        )
+
+        # Apply gridsize if it is specified
+        if gridsize != 0.0:
+            if SPATIALITE_GTE_51:
+                # Spatialite >= 5.1 available, so we can try ST_ReducePrecision first,
+                # which should be faster.
+                # ST_ReducePrecision seems to crash on EMPTY geometry, so check
+                # ST_IsEmpty not being 0 (result can be -1, 0 or 1).
+                gridsize_op = f"""
+                    IIF(sub_gridsize.geom IS NULL OR ST_IsEmpty(sub_gridsize.geom) <> 0,
+                        NULL,
+                        IFNULL(
+                            ST_ReducePrecision(sub_gridsize.geom, {gridsize}),
+                            ST_GeomFromWKB(GFO_ReducePrecision(
+                                ST_AsBinary(sub_gridsize.geom), {gridsize}
+                            ))
+                        )
+                    )
+                """
+            else:
+                gridsize_op = (
+                    "ST_GeomFromWKB(GFO_ReducePrecision("
+                    f"ST_AsBinary(sub_gridsize.geom), {gridsize}))"
+                )
+
+            # All columns need to be specified
+            # Remark:
+            # - use "LIMIT -1 OFFSET 0" to avoid the subquery flattening. Flattening
+            #   "geom IS NOT NULL" leads to GFO_Difference_Collection calculated double!
+            cols = [col for col in column_datatypes if col.lower() != "geom"]
+            columns_to_select = _ogr_sql_util.columns_quoted(cols)
+            sql_template = f"""
+                SELECT * FROM
+                  ( SELECT {gridsize_op} AS geom
+                          {columns_to_select}
+                      FROM ( {sql_template}
+                              LIMIT -1 OFFSET 0
+                      ) sub_gridsize
+                     LIMIT -1 OFFSET 0
+                  ) sub_gridsize2
+                 WHERE sub_gridsize2.geom IS NOT NULL
+            """
+
+        # Prepare/apply where_post parameter
+        if where_post is not None and not explodecollections:
+            # explodecollections is not True, so we can add where_post to sql_stmt.
+            # If explodecollections would be True, we need to wait to apply the
+            # where_post till after explodecollections is applied, so when appending the
+            # partial results to the output file.
+            sql_template = f"""
+                SELECT * FROM
+                    ( {sql_template}
+                      LIMIT -1 OFFSET 0
+                    )
+                 WHERE {where_post}
+            """
+            # where_post has been applied already so set to None.
+            where_post = None
+
+        # Calculate
+        # ---------
+        # Processing in threads is 2x faster for small datasets (on Windows)
+        calculate_in_threads = (
+            True if input1_tmp_layerinfo.featurecount <= 100 else False
+        )
+        logger.info(
+            f"Start processing ({processing_params.nb_parallel} "
+            f"parallel workers, batch size: {processing_params.batchsize})"
+        )
+        with _processing_util.PooledExecutorFactory(
+            threadpool=calculate_in_threads,
+            max_workers=processing_params.nb_parallel,
+            initializer=_processing_util.initialize_worker(),
+        ) as calculate_pool:
+            # Start looping
+            batches: Dict[int, dict] = {}
+            future_to_batch_id = {}
+            for batch_id in processing_params.batches:
+                batches[batch_id] = {}
+                batches[batch_id]["layer"] = output_layer
+
+                tmp_partial_output_path = (
+                    tempdir / f"{output_path.stem}_{batch_id}.gpkg"
+                )
+                batches[batch_id]["tmp_partial_output_path"] = tmp_partial_output_path
+
+                # Fill out final things in sql_template
+                sql_stmt = sql_template.format(
+                    input1_databasename="{input1_databasename}",
+                    input2_databasename="{input2_databasename}",
+                    batch_filter=processing_params.batches[batch_id]["batch_filter"],
+                )
+                batches[batch_id]["sqlite_stmt"] = sql_stmt
+
+                # calculate_two_layers doesn't support explodecollections in one step:
+                # there is an extra layer copy involved.
+                # Normally explodecollections can be deferred to the appending of the
+                # partial files, but if explodecollections and there is a where_post to
+                # be applied, it needs to be applied now already. Otherwise the
+                # where_post in the append of partial files later on won't give correct
+                # results!
+                explodecollections_now = False
+                output_geometrytype_now = force_output_geometrytype
+                if explodecollections and where_post is not None:
+                    explodecollections_now = True
+                if (
+                    force_output_geometrytype is not None
+                    and explodecollections
+                    and not explodecollections_now
+                ):
+                    # convert geometrytype to multitype to avoid ogr warnings
+                    output_geometrytype_now = force_output_geometrytype.to_multitype
+
+                # Remark: this temp file doesn't need spatial index
+                future = calculate_pool.submit(
+                    calculate_two_layers,
+                    input1_path=processing_params.batches[batch_id]["input1_path"],
+                    input1_layer=processing_params.batches[batch_id]["input1_layer"],
+                    input2_path=processing_params.batches[batch_id]["input2_path"],
+                    input2_layer=processing_params.batches[batch_id]["input2_layer"],
+                    output_path=tmp_partial_output_path,
+                    sql_stmt=sql_stmt,
+                    output_layer=output_layer,
+                    explodecollections=explodecollections_now,
+                    force_output_geometrytype=output_geometrytype_now,
+                    use_ogr=use_ogr,
+                    create_spatial_index=False,
+                    column_datatypes=column_datatypes,
+                )
+                future_to_batch_id[future] = batch_id
+
+            # Loop till all parallel processes are ready, but process each one
+            # that is ready already
+            nb_done = 0
+            _general_util.report_progress(
+                start_time,
+                nb_done,
+                nb_batches,
+                operation_name,
+                processing_params.nb_parallel,
+            )
+            for future in futures.as_completed(future_to_batch_id):
+                try:
+                    # Get the result
+                    result = future.result()
+                    if result is not None:
+                        logger.debug(f"{result}")
+                except Exception as ex:
+                    batch_id = future_to_batch_id[future]
+                    error = str(ex).partition("\n")[0]
+                    message = f"Error <{error}> executing {batches[batch_id]}"
+                    logger.exception(message)
+                    raise Exception(message) from ex
+
+                # If the calculate gave results, copy/append to output
+                batch_id = future_to_batch_id[future]
+                tmp_partial_output_path = batches[batch_id]["tmp_partial_output_path"]
+                nb_done += 1
+
+                # Normally all partial files should exist, but to be sure...
+                if not tmp_partial_output_path.exists():
+                    logger.warning(f"Result file {tmp_partial_output_path} not found")
+                    continue
+
+                # If there is only one tmp_partial file and it is already ok as
+                # output file, just rename/move it.
+                if (
+                    nb_batches == 1
+                    and not explodecollections
+                    and force_output_geometrytype is None
+                    and where_post is None
+                    and tmp_partial_output_path.suffix.lower()
+                    == tmp_output_path.suffix.lower()
+                ):
+                    gfo.move(tmp_partial_output_path, tmp_output_path)
+                else:
+                    # If there is only one batch, it is faster to create the spatial
+                    # index immediately
+                    create_spatial_index = False
+                    if nb_batches == 1 and output_with_spatial_index:
+                        create_spatial_index = True
+
+                    fileops._append_to_nolock(
+                        src=tmp_partial_output_path,
+                        dst=tmp_output_path,
+                        explodecollections=explodecollections,
+                        force_output_geometrytype=force_output_geometrytype,
+                        where=where_post,
+                        create_spatial_index=create_spatial_index,
+                        preserve_fid=False,
+                    )
+                    gfo.remove(tmp_partial_output_path)
+
+                # Log the progress and prediction speed
+                _general_util.report_progress(
+                    start_time=start_time,
+                    nb_done=nb_done,
+                    nb_todo=nb_batches,
+                    operation=operation_name,
+                    nb_parallel=processing_params.nb_parallel,
+                )
+
+        # Round up and clean up
+        # Now create spatial index and move to output location
+        if tmp_output_path.exists():
+            if output_with_spatial_index:
+                gfo.create_spatial_index(
+                    path=tmp_output_path,
+                    layer=output_layer,
+                    exist_ok=True,
+                    no_geom_ok=True,
+                )
+            if tmp_output_path != output_path:
+                output_path.parent.mkdir(parents=True, exist_ok=True)
+                gfo.move(tmp_output_path, output_path)
+        else:
+            logger.debug("Result was empty!")
+
+        logger.info(f"Ready, took {datetime.now()-start_time}")
+        shutil.rmtree(tempdir, ignore_errors=True)
+    except Exception:
+        gfo.remove(output_path, missing_ok=True)
+        gfo.remove(tmp_output_path, missing_ok=True)
+        raise
+
+
+def calculate_two_layers(
+    input1_path: Path,
+    input1_layer: str,
+    input2_path: Path,
+    input2_layer: str,
+    output_path: Path,
+    sql_stmt: str,
+    output_layer: str,
+    explodecollections: bool,
+    force_output_geometrytype: Optional[GeometryType],
+    create_spatial_index: bool,
+    column_datatypes: dict,
+    use_ogr: bool,
+):
+    if use_ogr is False:
+        # If explodecollections, write first to tmp file, then apply explodecollections
+        # to the final output file.
+        output_tmp_path = output_path
+        if explodecollections:
+            output_name = f"{output_path.stem}_tmp{output_path.suffix}"
+            output_tmp_path = output_path.parent / output_name
+        _sqlite_util.create_table_as_sql(
+            input1_path=input1_path,
+            input1_layer=input1_layer,
+            input2_path=input2_path,
+            input2_layer=input2_layer,
+            output_path=output_tmp_path,
+            sql_stmt=sql_stmt,
+            output_layer=output_layer,
+            output_geometrytype=force_output_geometrytype,
+            create_spatial_index=create_spatial_index,
+            profile=_sqlite_util.SqliteProfile.SPEED,
+            column_datatypes=column_datatypes,
+        )
+        if explodecollections:
+            _ogr_util.vector_translate(
+                input_path=output_tmp_path,
+                input_layers=output_layer,
+                output_path=output_path,
+                output_layer=output_layer,
+                explodecollections=explodecollections,
+                force_output_geometrytype=force_output_geometrytype,
+                options={"LAYER_CREATION.SPATIAL_INDEX": create_spatial_index},
+                preserve_fid=False,
+            )
+            gfo.remove(output_tmp_path)
+    else:
+        # Use ogr to run the query
+        #   * input2 path (= using attach) doesn't seem to work
+        #   * ogr doesn't fill out database names, so do it now
+        sql_stmt = sql_stmt.format(
+            input1_databasename="main",
+            input2_databasename="main",
+        )
+
+        _ogr_util.vector_translate(
+            input_path=input1_path,
+            output_path=output_path,
+            sql_stmt=sql_stmt,
+            output_layer=output_layer,
+            explodecollections=explodecollections,
+            force_output_geometrytype=force_output_geometrytype,
+            options={"LAYER_CREATION.SPATIAL_INDEX": create_spatial_index},
+        )
+
+
+class ProcessingParams:
+    def __init__(
+        self,
+        input1_path: Path,
+        input1_layer: str,
+        input2_path: Optional[Path],
+        input2_layer: Optional[str],
+        nb_parallel: int,
+        batches: dict,
+        batchsize: int,
+    ):
+        self.input1_path = input1_path
+        self.input1_layer = input1_layer
+        self.input2_path = input2_path
+        self.input2_layer = input2_layer
+        self.nb_parallel = nb_parallel
+        self.batches = batches
+        self.batchsize = batchsize
+
+    def to_json(self, path: Path):
+        prepared = _general_util.prepare_for_serialize(vars(self))
+        with open(path, "w") as file:
+            file.write(json.dumps(prepared, indent=4, sort_keys=True))
+
+
+def _prepare_processing_params(
+    input1_path: Path,
+    input1_layer: str,
+    tempdir: Path,
+    convert_to_spatialite_based: bool,
+    nb_parallel: int,
+    batchsize: int = -1,
+    input1_layer_alias: Optional[str] = None,
+    input2_path: Optional[Path] = None,
+    input2_layer: Optional[str] = None,
+) -> Optional[ProcessingParams]:
+    # Init
+    input1_layerinfo = gfo.get_layerinfo(
+        input1_path, input1_layer, raise_on_nogeom=False
+    )
+
+    # Prepare input files for the calculation
+    if convert_to_spatialite_based:
+        # Check if the input files are of the correct geofiletype
+        input1_info = _geofileinfo.get_geofileinfo(input1_path)
+        input2_info = (
+            None if input2_path is None else _geofileinfo.get_geofileinfo(input2_path)
+        )
+
+        # If input files are of the same format + are spatialite compatible,
+        # just use them
+        if input1_info.is_spatialite_based and (
+            input2_info is None or input1_info.driver == input2_info.driver
+        ):
+            if (
+                input1_info.driver == "GPKG"
+                and input1_layerinfo.geometrycolumn is not None
+            ):
+                # HasSpatialindex doesn't work for spatialite file
+                gfo.create_spatial_index(input1_path, input1_layer, exist_ok=True)
+        else:
+            # If not ok, copy the input layer to gpkg
+            input1_tmp_path = tempdir / f"{input1_path.stem}.gpkg"
+            gfo.copy_layer(
+                src=input1_path,
+                src_layer=input1_layer,
+                dst=input1_tmp_path,
+                dst_layer=input1_layer,
+                preserve_fid=True,
+            )
+            input1_path = input1_tmp_path
+
+        if input2_path is not None and input2_info is not None:
+            if (
+                input2_info.driver == input1_info.driver
+                and input2_info.is_spatialite_based
+            ):
+                input2_layerinfo = gfo.get_layerinfo(
+                    input2_path, input2_layer, raise_on_nogeom=False
+                )
+                if (
+                    input2_info.driver == "GPKG"
+                    and input2_layerinfo.geometrycolumn is not None
+                ):
+                    # HasSpatialindex doesn't work for spatialite file
+                    gfo.create_spatial_index(input2_path, input2_layer, exist_ok=True)
+            else:
+                # If not spatialite compatible, copy the input layer to gpkg
+                input2_tmp_path = tempdir / f"{input2_path.stem}.gpkg"
+                gfo.copy_layer(
+                    src=input2_path,
+                    src_layer=input2_layer,
+                    dst=input2_tmp_path,
+                    dst_layer=input2_layer,
+                    preserve_fid=True,
+                )
+                input2_path = input2_tmp_path
+
+    # Prepare batches to process
+    layer1_info = gfo.get_layerinfo(input1_path, input1_layer, raise_on_nogeom=False)
+    nb_rows_input_layer = layer1_info.featurecount
+
+    # Determine optimal number of batches
+    nb_parallel, nb_batches = _determine_nb_batches(
+        nb_rows_input_layer=nb_rows_input_layer,
+        nb_parallel=nb_parallel,
+        batchsize=batchsize,
+        is_twolayer_operation=input2_path is not None,
+    )
+
+    # Check number of batches + appoint nb rows to batches
+    batches: Dict[int, dict] = {}
+    if nb_batches == 1:
+        # If only one batch, no filtering is needed
+        batches[0] = {}
+        batches[0]["input1_path"] = input1_path
+        batches[0]["input1_layer"] = input1_layer
+        batches[0]["input2_path"] = input2_path
+        batches[0]["input2_layer"] = input2_layer
+        batches[0]["batch_filter"] = ""
+    else:
+        # Determine the min_rowid and max_rowid
+        # Remark: SELECT MIN(rowid), MAX(rowid) FROM ... is a lot slower than UNION ALL!
+        sql_stmt = f"""
+            SELECT MIN(rowid) minmax_rowid FROM "{layer1_info.name}"
+            UNION ALL
+            SELECT MAX(rowid) minmax_rowid FROM "{layer1_info.name}"
+        """
+        batch_info_df = gfo.read_file(
+            path=input1_path, sql_stmt=sql_stmt, sql_dialect="SQLITE"
+        )
+        min_rowid = pd.to_numeric(batch_info_df["minmax_rowid"][0]).item()
+        max_rowid = pd.to_numeric(batch_info_df["minmax_rowid"][1]).item()
+
+        # Determine the exact batches to use
+        if ((max_rowid - min_rowid) / nb_rows_input_layer) < 1.1:
+            # If the rowid's are quite consecutive, use an imperfect, but
+            # fast distribution in batches
+            batch_info_list = []
+            nb_rows_per_batch = round(nb_rows_input_layer / nb_batches)
+            start_rowid = min_rowid
+            offset_per_batch = round((max_rowid - min_rowid) / nb_batches)
+            for batch_id in range(nb_batches):
+                if batch_id < (nb_batches - 1):
+                    # End rowid for this batch is the next start_rowid - 1
+                    end_rowid = start_rowid + offset_per_batch - 1
+                else:
+                    # For the last batch, take the max_rowid so no rowid's are
+                    # 'lost' due to rounding errors
+                    end_rowid = max_rowid
+                batch_info_list.append(
+                    (batch_id, nb_rows_per_batch, start_rowid, end_rowid)
+                )
+                start_rowid += offset_per_batch
+            batch_info_df = pd.DataFrame(
+                batch_info_list, columns=["id", "nb_rows", "start_rowid", "end_rowid"]
+            )
+        else:
+            # The rowids are not consecutive, so determine the optimal rowid
+            # ranges for each batch so each batch has same number of elements
+            # Remark: - this might take some seconds for larger datasets!
+            #         - (batch_id - 1) AS id to make the id zero-based
+            sql_stmt = f"""
+                SELECT (batch_id - 1) AS id
+                      ,COUNT(*) AS nb_rows
+                      ,MIN(rowid) AS start_rowid
+                      ,MAX(rowid) AS end_rowid
+                  FROM
+                    ( SELECT rowid
+                            ,NTILE({nb_batches}) OVER (ORDER BY rowid) batch_id
+                        FROM "{layer1_info.name}"
+                    )
+                 GROUP BY batch_id;
+            """
+            batch_info_df = gfo.read_file(path=input1_path, sql_stmt=sql_stmt)
+
+        # Prepare the layer alias to use in the batch filter
+        layer_alias_d = ""
+        if input1_layer_alias is not None:
+            layer_alias_d = f"{input1_layer_alias}."
+
+        # Now loop over all batch ranges to build up the necessary filters
+        for batch_info in batch_info_df.itertuples():
+            # Fill out the batch properties
+            batches[batch_info.id] = {}
+            batches[batch_info.id]["input1_path"] = input1_path
+            batches[batch_info.id]["input1_layer"] = input1_layer
+            batches[batch_info.id]["input2_path"] = input2_path
+            batches[batch_info.id]["input2_layer"] = input2_layer
+
+            # The batch filter
+            if batch_info.id < nb_batches - 1:
+                batches[batch_info.id]["batch_filter"] = (
+                    f"AND ({layer_alias_d}rowid >= {batch_info.start_rowid} "
+                    f"AND {layer_alias_d}rowid <= {batch_info.end_rowid}) "
+                )
+            else:
+                batches[batch_info.id][
+                    "batch_filter"
+                ] = f"AND {layer_alias_d}rowid >= {batch_info.start_rowid} "
+
+    # No use starting more processes than the number of batches...
+    if len(batches) < nb_parallel:
+        nb_parallel = len(batches)
+
+    returnvalue = ProcessingParams(
+        input1_path=input1_path,
+        input1_layer=input1_layer,
+        input2_path=input2_path,
+        input2_layer=input2_layer,
+        nb_parallel=nb_parallel,
+        batches=batches,
+        batchsize=int(nb_rows_input_layer / len(batches)),
+    )
+    returnvalue.to_json(tempdir / "processing_params.json")
+    return returnvalue
+
+
+def _determine_nb_batches(
+    nb_rows_input_layer: int,
+    nb_parallel: int,
+    batchsize: int,
+    is_twolayer_operation: bool,
+    cpu_count: Optional[int] = None,
+) -> Tuple[int, int]:
+    """
+    Determine an optimal number of batches and parallel workers.
+
+    Args:
+        nb_rows_input_layer (int): number of input rows
+        nb_parallel (int): recommended number of workers
+        batchsize (int): recommended number of rows per batch
+        is_twolayer_operation (bool): True if optimization for a two layer operation,
+            False if it involves a single layer operation.
+        cpu_count (int, optional): the number of CPU's available. If None, this is
+            determined automatically if needed.
+
+    Returns:
+        Tuple[int, int]: Tuple of (nb_parallel, nb_batches)
+    """
+    # If no or 1 input rows or if 1 parallel worker is asked
+    # Remark: especially for 'select' operation, if nb_parallel is 1 nb_batches should
+    # be 1 (select might give wrong results)
+    if nb_rows_input_layer <= 1 or nb_parallel == 1:
+        return (1, 1)
+
+    if cpu_count is None:
+        cpu_count = multiprocessing.cpu_count()
+
+    # Determine the optimal number of parallel workers
+    if nb_parallel == -1:
+        # If no batch size specified, put at least 100 rows in a batch
+        if batchsize <= 0:
+            min_rows_per_batch = 100
+        else:
+            # If batchsize is specified, use the batch size
+            min_rows_per_batch = batchsize
+
+        max_parallel = max(int(nb_rows_input_layer / min_rows_per_batch), 1)
+        nb_parallel = min(cpu_count, max_parallel)
+
+    # Determine optimal number of batches
+    if nb_parallel > 1:
+        # Limit number of rows processed in parallel to limit memory use
+        if batchsize > 0:
+            max_rows_parallel = batchsize * nb_parallel
+        else:
+            max_rows_parallel = 1000000
+            if is_twolayer_operation:
+                max_rows_parallel = 200000
+
+        # Adapt number of batches to max_rows_parallel
+        if nb_rows_input_layer > max_rows_parallel:
+            # If more rows than can be handled simultanously in parallel
+            nb_batches = math.ceil(
+                nb_rows_input_layer / (max_rows_parallel / nb_parallel)
+            )
+            # Round up to the nearest multiple of nb_parallel
+            nb_batches = math.ceil(nb_batches / nb_parallel) * nb_parallel
+        elif batchsize > 0:
+            # If a batchsize is specified, try to honer it
+            nb_batches = nb_parallel
+        else:
+            nb_batches = nb_parallel
+
+            # If no batchsize specified and 2 layer processing, add some batches to
+            # reduce impact of possible unbalanced batches on total processing time.
+            if is_twolayer_operation:
+                nb_batches *= 2
+
+    elif batchsize > 0:
+        nb_batches = math.ceil(nb_rows_input_layer / batchsize)
+
+    else:
+        nb_batches = 1
+
+    # If more batches than rows, limit nb batches
+    if nb_batches > nb_rows_input_layer:
+        nb_batches = nb_rows_input_layer
+    # If more parallel than number of batches, limit nb_parallel
+    if nb_parallel > nb_batches:
+        nb_parallel = nb_batches
+
+    return (nb_parallel, nb_batches)
+
+
+def dissolve_singlethread(
+    input_path: Path,
+    output_path: Path,
+    groupby_columns: Union[str, Iterable[str], None] = None,
+    agg_columns: Optional[dict] = None,
+    explodecollections: bool = False,
+    gridsize: float = 0.0,
+    keep_empty_geoms: bool = True,
+    where_post: Optional[str] = None,
+    input_layer: Optional[str] = None,
+    output_layer: Optional[str] = None,
+    force: bool = False,
+):
+    """
+    Remark: this is not a parallelized version!!!
+    """
+    # Init
+    logger = logging.getLogger("geofileops.dissolve")
+    start_time = datetime.now()
+
+    # Check input params
+    if not input_path.exists():
+        raise ValueError(f"input_path doesn't exist: {input_path}")
+    if input_path == output_path:
+        raise ValueError("output_path must not equal input_path")
+    if where_post is not None and where_post == "":
+        where_post = None
+
+    # Check layer names
+    if input_layer is None:
+        input_layer = gfo.get_only_layer(input_path)
+    if output_layer is None:
+        output_layer = gfo.get_default_layer(output_path)
+
+    # Use get_layerinfo to check if the layer definition is OK
+    input_layerinfo = gfo.get_layerinfo(input_path, input_layer)
+    fid_column = (
+        input_layerinfo.fid_column if input_layerinfo.fid_column != "" else "rowid"
+    )
+
+    # Prepare some lists for later use
+    columns_available = list(input_layerinfo.columns) + ["fid"]
+    columns_available_upper = [column.upper() for column in columns_available]
+    groupby_columns_upper_dict = {}
+    if groupby_columns is not None:
+        groupby_columns_upper_dict = {col.upper(): col for col in groupby_columns}
+
+    # Prepare the strings regarding groupby_columns to use in the select statement.
+    if groupby_columns is not None:
+        # Standardize parameter to simplify the rest of the code
+        if isinstance(groupby_columns, str):
+            # If a string is passed, convert to list
+            groupby_columns = [groupby_columns]
+
+        # Check if all groupby columns exist
+        for column in groupby_columns:
+            if column.upper() not in columns_available_upper:
+                raise ValueError(f"column in groupby_columns not in input: {column}")
+
+        # Because the query uses a subselect, the groupby columns need to be prefixed.
+        columns_prefixed = [f'layer."{column}"' for column in groupby_columns]
+        groupby_columns_for_groupby_str = ", ".join(columns_prefixed)
+        columns_prefixed_aliased = [
+            f'layer."{column}" "{column}"' for column in groupby_columns
+        ]
+        groupby_columns_for_select_str = f", {', '.join(columns_prefixed_aliased)}"
+    else:
+        # Even if no groupby is provided, we still need to use a groupby clause,
+        # otherwise ST_union doesn't seem to work.
+        groupby_columns_for_groupby_str = "'1'"
+        groupby_columns_for_select_str = ""
+
+    # Prepare the strings regarding agg_columns to use in the select statement.
+    agg_columns_str = ""
+    if agg_columns is not None:
+        # Validate the dict structure, so we can assume everything is OK further on
+        _parameter_helper.validate_agg_columns(agg_columns)
+
+        # Start preparation of agg_columns_str
+        if "json" in agg_columns:
+            # Determine the columns to be put in json
+            columns = []
+            if agg_columns["json"] is None:
+                # If columns specified is None: all columns not in groupby_columns
+                for column in input_layerinfo.columns:
+                    if column.upper() not in groupby_columns_upper_dict:
+                        columns.append(column)
+            else:
+                for column in agg_columns["json"]:
+                    columns.append(column)
+            json_columns = [f"'{column}', layer.\"{column}\"" for column in columns]
+
+            # The fid should be added as well, but make name unique
+            fid_orig_column = "fid_orig"
+            for idx in range(99999):
+                if idx != 0:
+                    fid_orig_column = f"fid_orig{idx}"
+                if fid_orig_column not in columns:
+                    break
+            json_columns.append(f"'{fid_orig_column}', layer.\"{fid_column}\"")
+
+            # Now we are ready to prepare final str
+            agg_columns_str = (
+                f", json_group_array(json_object({', '.join(json_columns)})) as json"
+            )
+        elif "columns" in agg_columns:
+            for agg_column in agg_columns["columns"]:
+                # Init
+                distinct_str = ""
+                extra_param_str = ""
+
+                # Prepare aggregation keyword
+                if agg_column["agg"].lower() in [
+                    "count",
+                    "sum",
+                    "min",
+                    "max",
+                    "median",
+                ]:
+                    aggregation_str = agg_column["agg"]
+                elif agg_column["agg"].lower() in ["mean", "avg"]:
+                    aggregation_str = "avg"
+                elif agg_column["agg"].lower() == "concat":
+                    aggregation_str = "group_concat"
+                    if "sep" in agg_column:
+                        extra_param_str = f", '{agg_column['sep']}'"
+                else:
+                    raise ValueError(f"aggregation {agg_column['agg']} not supported!")
+
+                # If distinct is specified, add the distinct keyword
+                if "distinct" in agg_column and agg_column["distinct"] is True:
+                    distinct_str = "DISTINCT "
+
+                # Prepare column name string
+                column = agg_column["column"]
+                if column.upper() not in columns_available_upper:
+                    raise ValueError(f"{column} not available in: {columns_available}")
+                if column.upper() == "FID":
+                    column_str = f'layer."{fid_column}"'
+                else:
+                    column_str = f'layer."{column}"'
+
+                # Now put everything together
+                agg_columns_str += (
+                    f", {aggregation_str}({distinct_str}{column_str}{extra_param_str}) "
+                    f'AS "{agg_column["as"]}"'
+                )
+
+    # Check output path
+    if output_path.exists():
+        if force is False:
+            logger.info(f"Stop, output exists already {output_path}")
+            return
+        else:
+            gfo.remove(output_path)
+
+    # Now prepare the sql statement
+    # Remark: calculating the area in the enclosing selects halves the processing time
+
+    # The operation to run on the geometry
+    operation = f"ST_union(layer.{input_layerinfo.geometrycolumn})"
+
+    # If the input is a linestring, also apply st_linemerge(), otherwise the individual
+    # lines are just concatenated together and common points are not removed, resulting
+    # in the original seperate lines again if explodecollections is True.
+    if input_layerinfo.geometrytype.to_primitivetype == PrimitiveType.LINESTRING:
+        operation = f"ST_LineMerge({operation})"
+
+    # If the output file results in no rows gdal needs force_output_geometrytype to be
+    # able to create an empty output file with the right geometry type.
+    if explodecollections:
+        force_output_geometrytype = input_layerinfo.geometrytype.to_singletype
+    else:
+        force_output_geometrytype = input_layerinfo.geometrytype.to_multitype
+
+    # Apply tolerance gridsize on result
+    if gridsize != 0.0:
+        operation = _format_apply_gridsize_operation(
+            geometrycolumn=operation,
+            gridsize=gridsize,
+            force_output_geometrytype=force_output_geometrytype,
+        )
+
+    # Now the sql query can be assembled
+    sql_stmt = f"""
+        SELECT {operation} AS geom
+            {groupby_columns_for_select_str}
+            {agg_columns_str}
+        FROM "{input_layer}" layer
+        GROUP BY {groupby_columns_for_groupby_str}
+    """
+
+    # If empty/null geometries don't need to be kept, filter them away
+    if not keep_empty_geoms:
+        sql_stmt = f"""
+            SELECT * FROM
+                ( {sql_stmt}
+                )
+             WHERE geom IS NOT NULL
+        """
+
+    # Prepare/apply where_post parameter
+    if where_post is not None and not explodecollections:
+        # explodecollections is not True, so we can add where_post to sql_stmt.
+        # If explodecollections would be True, we need to wait to apply the
+        # where_post till after explodecollections is applied, so when appending
+        # the partial results to the output file.
+        where_post = where_post.format(geometrycolumn="geom")
+        sql_stmt = f"""
+            SELECT * FROM
+                ( {sql_stmt}
+                )
+                WHERE {where_post}
+        """
+        # where_post has been applied already so set to None.
+        where_post = None
+
+    # When null geometries are being kept, we need to make sure the geom in the
+    # first row is not NULL because of a bug in gdal, so add ORDER BY as last step.
+    #   -> https://github.com/geofileops/geofileops/issues/308
+    if keep_empty_geoms:
+        sql_stmt = f"""
+            SELECT * FROM
+                ( {sql_stmt}
+                )
+             ORDER BY geom IS NULL
+        """
+
+    # Now we can really start
+    tempdir = _io_util.create_tempdir("geofileops/dissolve_singlethread")
+    try:
+        create_spatial_index = True
+        suffix = output_path.suffix
+        if where_post is not None:
+            # where_post needs to be applied still, so no spatial index needed
+            create_spatial_index = False
+            suffix = ".gpkg"
+        tmp_output_path = tempdir / f"output_tmp{suffix}"
+
+        _ogr_util.vector_translate(
+            input_path=input_path,
+            output_path=tmp_output_path,
+            output_layer=output_layer,
+            sql_stmt=sql_stmt,
+            sql_dialect="SQLITE",
+            force_output_geometrytype=force_output_geometrytype,
+            explodecollections=explodecollections,
+            options={"LAYER_CREATION.SPATIAL_INDEX": create_spatial_index},
+        )
+
+        # We still need to apply the where_post filter
+        if where_post is not None:
+            tmp_output_where_path = tempdir / f"output_tmp2_where{output_path.suffix}"
+            tmp_output_info = gfo.get_layerinfo(tmp_output_path)
+            where_post = where_post.format(
+                geometrycolumn=tmp_output_info.geometrycolumn
+            )
+            sql_stmt = f"""
+                SELECT * FROM "{output_layer}"
+                 WHERE {where_post}
+            """
+            _ogr_util.vector_translate(
+                input_path=tmp_output_path,
+                output_path=tmp_output_where_path,
+                output_layer=output_layer,
+                force_output_geometrytype=force_output_geometrytype,
+                sql_stmt=sql_stmt,
+                sql_dialect="SQLITE",
+                options={"LAYER_CREATION.SPATIAL_INDEX": True},
+            )
+            tmp_output_path = tmp_output_where_path
+
+        # Now we are ready to move the result to the final spot...
+        gfo.move(tmp_output_path, output_path)
+
+    finally:
+        shutil.rmtree(tempdir, ignore_errors=True)
+
+    logger.info(f"Ready, took {datetime.now()-start_time}")
+
+
+def _format_apply_gridsize_operation(
+    geometrycolumn: str, gridsize: float, force_output_geometrytype: GeometryType
+) -> str:
+    if SPATIALITE_GTE_51:
+        # ST_ReducePrecision and GeosMakeValid only available for spatialite >= 5.1
+        # Retry with applying makevalid.
+        # It is not possible to return the original geometry if error stays after
+        # makevalid, because spatialite functions return NULL for failures as well as
+        # when the result is correctly NULL, so not possible to make the distinction.
+        # ST_ReducePrecision seems to crash on EMPTY geometry, so check ST_IsEmpty not
+        # being 0 (result can be -1, 0 or 1).
+        gridsize_op = f"""
+            IIF({geometrycolumn} IS NULL OR ST_IsEmpty({geometrycolumn}) <> 0,
+                NULL,
+                IFNULL(
+                    ST_ReducePrecision({geometrycolumn}, {gridsize}),
+                    ST_ReducePrecision(GeosMakeValid({geometrycolumn}, 0), {gridsize})
+                )
+            )
+        """
+    else:
+        # Apply snaptogrid, but this results in invalid geometries, so also
+        # Makevalid.
+        gridsize_op = f"ST_MakeValid(SnapToGrid({geometrycolumn}, {gridsize}))"
+
+        # SnapToGrid + ST_MakeValid can result in collapsed (pieces of)
+        # geometries, so finally apply collectionextract as well.
+        if force_output_geometrytype is None:
+            warnings.warn(
+                "a gridsize is specified but no force_output_geometrytype, "
+                "this can result in inconsistent geometries in the output",
+                stacklevel=3,
+            )
+        else:
+            primitivetypeid = force_output_geometrytype.to_primitivetype.value
+            gridsize_op = f"ST_CollectionExtract({gridsize_op}, {primitivetypeid})"
+
+    return gridsize_op
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_geoseries_util.py` & `geofileops-0.8.2/geofileops/util/_geoseries_util.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,284 +1,284 @@
-"""
-Module containing utilities regarding operations on geoseries.
-"""
-
-import logging
-from typing import List, Union
-import warnings
-
-import geopandas as gpd
-import geopandas._compat as gpd_compat
-import numpy as np
-from numpy.typing import NDArray
-import pandas as pd
-from pygeoops import GeometryType
-from pygeoops._general import _extract_0dim_ndarray
-import pygeoops
-import shapely
-from shapely.geometry.base import BaseGeometry
-
-if gpd_compat.USE_PYGEOS:
-    import pygeos as shapely2_or_pygeos
-else:
-    import shapely as shapely2_or_pygeos
-
-# Get a logger...
-logger = logging.getLogger(__name__)
-
-
-def get_geometrytypes(
-    geoseries: gpd.GeoSeries, ignore_empty_geometries: bool = True
-) -> List[GeometryType]:
-    """
-    Determine the geometry types in the GeoDataFrame.
-
-    Args:
-        geoseries (gpd.GeoSeries): input geoseries.
-        ignore_empty_geometries (bool, optional): True to ignore empty geometries.
-            Defaults to True.
-
-    Returns:
-        List[GeometryType]: [description]
-    """
-    if ignore_empty_geometries is True:
-        input_geoseries = geoseries[~geoseries.is_empty]
-    else:
-        input_geoseries = geoseries
-    geom_types_2D = input_geoseries[~input_geoseries.has_z].geom_type.unique()
-    geom_types_2D = [gtype for gtype in geom_types_2D if gtype is not None]
-    geom_types_3D = input_geoseries[input_geoseries.has_z].geom_type.unique()
-    geom_types_3D = ["3D " + gtype for gtype in geom_types_3D if gtype is not None]
-    geom_types = geom_types_3D + geom_types_2D
-
-    if len(geom_types) == 0:
-        return [GeometryType.GEOMETRY]
-
-    geometrytypes_list = [GeometryType[geom_type.upper()] for geom_type in geom_types]
-    return geometrytypes_list
-
-
-def harmonize_geometrytypes(
-    geoseries: gpd.GeoSeries, force_multitype: bool = False
-) -> gpd.GeoSeries:
-    """
-    Tries to harmonize the geometries in the geoseries to one type.
-
-    Eg. if Polygons and MultiPolygons are present in the geoseries, all
-    geometries are converted to MultiPolygons.
-
-    Empty geometries are changed to None.
-
-    If they cannot be harmonized, the original series is returned...
-
-    Args:
-        geoseries (gpd.GeoSeries): The geoseries to harmonize.
-        force_multitype (bool, optional): True to force all geometries to the
-            corresponding multitype. Defaults to False.
-
-    Returns:
-        gpd.GeoSeries: the harmonized geoseries if possible, otherwise the
-            original one.
-    """
-    # Get unique list of geometrytypes in gdf
-    geometrytypes = get_geometrytypes(geoseries)
-
-    # If already only one geometrytype...
-    if len(geometrytypes) == 1:
-        if force_multitype is True:
-            # If it is already a multitype, return
-            if geometrytypes[0].is_multitype is True:
-                return geoseries
-            else:
-                # Else convert to corresponding multitype
-                return _harmonize_to_multitype(geoseries, geometrytypes[0].to_multitype)
-        else:
-            return geoseries
-    elif (
-        len(geometrytypes) == 2
-        and geometrytypes[0].to_primitivetype == geometrytypes[1].to_primitivetype
-    ):
-        # There are two geometrytypes, but they are of the same primitive type,
-        # so can just be harmonized to the multitype
-        return _harmonize_to_multitype(geoseries, geometrytypes[0].to_multitype)
-    else:
-        # Too difficult to harmonize, so just return
-        return geoseries
-
-
-def is_valid_reason(geoseries: gpd.GeoSeries) -> pd.Series:
-    # Get result and keep geoseries indexes
-    return pd.Series(
-        data=shapely.is_valid_reason(geoseries),
-        index=geoseries.index,
-    )
-
-
-def _harmonize_to_multitype(
-    geoseries: gpd.GeoSeries, dest_geometrytype: GeometryType
-) -> gpd.GeoSeries:
-    # Copy geoseries data to new array
-    if gpd_compat.USE_PYGEOS:
-        geometries_arr = geoseries.array.data.copy()
-    else:
-        geometries_arr = geoseries.copy()
-
-    # Set empty geometries to None
-    empty_idxs = shapely2_or_pygeos.is_empty(geometries_arr)
-    if empty_idxs.sum():
-        geometries_arr[empty_idxs] = None
-
-    # Cast all geometries that are not of the correct multitype yet
-    # Remark: all rows need to be retained, so the same indexers exist in the
-    # returned geoseries
-    if dest_geometrytype is GeometryType.MULTIPOLYGON:
-        # Convert polygons to multipolygons
-        single_idxs = shapely2_or_pygeos.get_type_id(geometries_arr) == 3
-        if single_idxs.sum():
-            geometries_arr[single_idxs] = np.apply_along_axis(
-                shapely2_or_pygeos.multipolygons,
-                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
-                axis=1,
-            )
-    elif dest_geometrytype is GeometryType.MULTILINESTRING:
-        # Convert linestrings to multilinestrings
-        single_idxs = shapely2_or_pygeos.get_type_id(geometries_arr) == 1
-        if single_idxs.sum():
-            geometries_arr[single_idxs] = np.apply_along_axis(
-                shapely2_or_pygeos.multilinestrings,
-                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
-                axis=1,
-            )
-    elif dest_geometrytype is GeometryType.MULTIPOINT:
-        single_idxs = shapely2_or_pygeos.get_type_id(geometries_arr) == 0
-        if single_idxs.sum():
-            geometries_arr[single_idxs] = np.apply_along_axis(
-                shapely2_or_pygeos.multipoints,
-                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
-                axis=1,
-            )
-    else:
-        raise Exception(f"Unsupported destination GeometryType: {dest_geometrytype}")
-
-    # Prepare result to return
-    geoseries_result = gpd.GeoSeries(
-        geometries_arr, index=geoseries.index, crs=geoseries.crs
-    )
-    assert isinstance(geoseries_result, gpd.GeoSeries)
-    return geoseries_result
-
-
-def set_precision(
-    geometry,
-    grid_size: float,
-    mode: str = "valid_output",
-    raise_on_topoerror: bool = True,
-) -> Union[BaseGeometry, NDArray[BaseGeometry], None]:
-    """
-    Returns geometry with the precision set to a precision grid size.
-
-    By default, geometries use double precision coordinates (grid_size = 0).
-
-    Coordinates will be rounded if a precision grid is less precise than the input
-    geometry. Duplicated vertices will be dropped from lines and polygons for grid sizes
-    greater than 0. Line and polygon geometries may collapse to empty geometries if all
-    vertices are closer together than grid_size. Z values, if present, will not be
-    modified.
-
-    Note: subsequent operations will always be performed in the precision of the
-    geometry with higher precision (smaller "grid_size"). That same precision will be
-    attached to the operation outputs.
-
-    Also note: input geometries should be geometrically valid; unexpected results may
-    occur if input geometries are not.
-
-    Args:
-        geometry: Geometry or array_like
-        grid_size (float): Precision grid size. If 0, will use double precision (will
-            not modify geometry if precision grid size was not previously set). If this
-            value is more precise than input geometry, the input geometry will not be
-            modified.
-        mode (str, optional): This parameter determines how to handle invalid output
-            geometries. There are three modes:
-
-            1. 'valid_output' (default):  The output is always valid. Collapsed
-                geometry elements  (including both polygons and lines) are removed.
-                Duplicate vertices are removed.
-            2. 'pointwise': Precision reduction is performed pointwise. Output geometry
-                may be invalid due to collapse or self-intersection. Duplicate vertices
-                are not removed. In GEOS this option is called NO_TOPO.
-            3. 'keep_collapsed': Like the default mode, except that collapsed linear
-                geometry elements are preserved. Collapsed polygonal input elements are
-                removed. Duplicate vertices are removed.
-        raise_on_topoerror (bool, optional): If False, instead of raising an error on a
-            topology error, retries after applying make_valid and returns the input if
-            it still fails. Defaults to True.
-
-    Returns:
-        geometry or array_like: The input with the precision applied. Returns None if
-            geometry is None.
-    """
-    if raise_on_topoerror:
-        return shapely.set_precision(geometry, grid_size=grid_size, mode=mode)
-
-    # Don't return an error when topologyerror occurs
-    try:
-        return shapely.set_precision(geometry, grid_size=grid_size, mode=mode)
-
-    except shapely.errors.GEOSException as ex:
-        if not str(ex).lower().startswith("topologyexception"):  # pragma: no cover
-            raise
-
-        # If set_precision fails with TopologyException, try again after make_valid
-        # Because it is applied on a GeoDataFrame with typically many rows, we don't
-        # know which row is invalid, so use only_if_invalid=True.
-        geometry = pygeoops.make_valid(
-            geometry, keep_collapsed=False, only_if_invalid=True
-        )
-
-        # Try again now
-        try:
-            geometry = shapely.set_precision(geometry, grid_size=grid_size, mode=mode)
-            warnings.warn(
-                f"error setting grid_size, but it succeeded after makevalid: <{ex}>",
-                stacklevel=1,
-            )
-            return geometry
-
-        except shapely.errors.GEOSException as ex:
-            if not str(ex).lower().startswith("topologyexception"):  # pragma: no cover
-                raise
-
-            # Still getting a TopologyException, so apply set_precision to each element
-            # seperately and keep the input for the ones giving an error.
-            # Deal with 0 dim arrays as input
-            geometry = _extract_0dim_ndarray(geometry)
-
-            # If there is only one element, just return the input
-            if not hasattr(geometry, "__len__"):
-                warnings.warn(
-                    f"error setting grid_size, input was returned, for {geometry}, "
-                    f"error: {ex}",
-                    stacklevel=1,
-                )
-                return geometry
-
-            # The input is arraylike... so try set_precision on each element
-            result = []
-            for geom in geometry:
-                try:
-                    result.append(
-                        shapely.set_precision(geom, grid_size=grid_size, mode=mode)
-                    )
-                except shapely.errors.GEOSException as ex:
-                    if not str(ex).lower().startswith("topologyexception"):
-                        raise
-
-                    # Just return the input
-                    result.append(geom)
-                    warnings.warn(
-                        f"error setting grid_size, input was returned, for {geom}, "
-                        f"error: {ex}",
-                        stacklevel=1,
-                    )
-
-            return np.array(result)
+"""
+Module containing utilities regarding operations on geoseries.
+"""
+
+import logging
+from typing import List, Union
+import warnings
+
+import geopandas as gpd
+import geopandas._compat as gpd_compat
+import numpy as np
+from numpy.typing import NDArray
+import pandas as pd
+from pygeoops import GeometryType
+from pygeoops._general import _extract_0dim_ndarray
+import pygeoops
+import shapely
+from shapely.geometry.base import BaseGeometry
+
+if gpd_compat.USE_PYGEOS:
+    import pygeos as shapely2_or_pygeos
+else:
+    import shapely as shapely2_or_pygeos
+
+# Get a logger...
+logger = logging.getLogger(__name__)
+
+
+def get_geometrytypes(
+    geoseries: gpd.GeoSeries, ignore_empty_geometries: bool = True
+) -> List[GeometryType]:
+    """
+    Determine the geometry types in the GeoDataFrame.
+
+    Args:
+        geoseries (gpd.GeoSeries): input geoseries.
+        ignore_empty_geometries (bool, optional): True to ignore empty geometries.
+            Defaults to True.
+
+    Returns:
+        List[GeometryType]: [description]
+    """
+    if ignore_empty_geometries is True:
+        input_geoseries = geoseries[~geoseries.is_empty]
+    else:
+        input_geoseries = geoseries
+    geom_types_2D = input_geoseries[~input_geoseries.has_z].geom_type.unique()
+    geom_types_2D = [gtype for gtype in geom_types_2D if gtype is not None]
+    geom_types_3D = input_geoseries[input_geoseries.has_z].geom_type.unique()
+    geom_types_3D = ["3D " + gtype for gtype in geom_types_3D if gtype is not None]
+    geom_types = geom_types_3D + geom_types_2D
+
+    if len(geom_types) == 0:
+        return [GeometryType.GEOMETRY]
+
+    geometrytypes_list = [GeometryType[geom_type.upper()] for geom_type in geom_types]
+    return geometrytypes_list
+
+
+def harmonize_geometrytypes(
+    geoseries: gpd.GeoSeries, force_multitype: bool = False
+) -> gpd.GeoSeries:
+    """
+    Tries to harmonize the geometries in the geoseries to one type.
+
+    Eg. if Polygons and MultiPolygons are present in the geoseries, all
+    geometries are converted to MultiPolygons.
+
+    Empty geometries are changed to None.
+
+    If they cannot be harmonized, the original series is returned...
+
+    Args:
+        geoseries (gpd.GeoSeries): The geoseries to harmonize.
+        force_multitype (bool, optional): True to force all geometries to the
+            corresponding multitype. Defaults to False.
+
+    Returns:
+        gpd.GeoSeries: the harmonized geoseries if possible, otherwise the
+            original one.
+    """
+    # Get unique list of geometrytypes in gdf
+    geometrytypes = get_geometrytypes(geoseries)
+
+    # If already only one geometrytype...
+    if len(geometrytypes) == 1:
+        if force_multitype is True:
+            # If it is already a multitype, return
+            if geometrytypes[0].is_multitype is True:
+                return geoseries
+            else:
+                # Else convert to corresponding multitype
+                return _harmonize_to_multitype(geoseries, geometrytypes[0].to_multitype)
+        else:
+            return geoseries
+    elif (
+        len(geometrytypes) == 2
+        and geometrytypes[0].to_primitivetype == geometrytypes[1].to_primitivetype
+    ):
+        # There are two geometrytypes, but they are of the same primitive type,
+        # so can just be harmonized to the multitype
+        return _harmonize_to_multitype(geoseries, geometrytypes[0].to_multitype)
+    else:
+        # Too difficult to harmonize, so just return
+        return geoseries
+
+
+def is_valid_reason(geoseries: gpd.GeoSeries) -> pd.Series:
+    # Get result and keep geoseries indexes
+    return pd.Series(
+        data=shapely.is_valid_reason(geoseries),
+        index=geoseries.index,
+    )
+
+
+def _harmonize_to_multitype(
+    geoseries: gpd.GeoSeries, dest_geometrytype: GeometryType
+) -> gpd.GeoSeries:
+    # Copy geoseries data to new array
+    if gpd_compat.USE_PYGEOS:
+        geometries_arr = geoseries.array.data.copy()
+    else:
+        geometries_arr = geoseries.copy()
+
+    # Set empty geometries to None
+    empty_idxs = shapely2_or_pygeos.is_empty(geometries_arr)
+    if empty_idxs.sum():
+        geometries_arr[empty_idxs] = None
+
+    # Cast all geometries that are not of the correct multitype yet
+    # Remark: all rows need to be retained, so the same indexers exist in the
+    # returned geoseries
+    if dest_geometrytype is GeometryType.MULTIPOLYGON:
+        # Convert polygons to multipolygons
+        single_idxs = shapely2_or_pygeos.get_type_id(geometries_arr) == 3
+        if single_idxs.sum():
+            geometries_arr[single_idxs] = np.apply_along_axis(
+                shapely2_or_pygeos.multipolygons,
+                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
+                axis=1,
+            )
+    elif dest_geometrytype is GeometryType.MULTILINESTRING:
+        # Convert linestrings to multilinestrings
+        single_idxs = shapely2_or_pygeos.get_type_id(geometries_arr) == 1
+        if single_idxs.sum():
+            geometries_arr[single_idxs] = np.apply_along_axis(
+                shapely2_or_pygeos.multilinestrings,
+                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
+                axis=1,
+            )
+    elif dest_geometrytype is GeometryType.MULTIPOINT:
+        single_idxs = shapely2_or_pygeos.get_type_id(geometries_arr) == 0
+        if single_idxs.sum():
+            geometries_arr[single_idxs] = np.apply_along_axis(
+                shapely2_or_pygeos.multipoints,
+                arr=(np.expand_dims(geometries_arr[single_idxs], 1)),
+                axis=1,
+            )
+    else:
+        raise Exception(f"Unsupported destination GeometryType: {dest_geometrytype}")
+
+    # Prepare result to return
+    geoseries_result = gpd.GeoSeries(
+        geometries_arr, index=geoseries.index, crs=geoseries.crs
+    )
+    assert isinstance(geoseries_result, gpd.GeoSeries)
+    return geoseries_result
+
+
+def set_precision(
+    geometry,
+    grid_size: float,
+    mode: str = "valid_output",
+    raise_on_topoerror: bool = True,
+) -> Union[BaseGeometry, NDArray[BaseGeometry], None]:
+    """
+    Returns geometry with the precision set to a precision grid size.
+
+    By default, geometries use double precision coordinates (grid_size = 0).
+
+    Coordinates will be rounded if a precision grid is less precise than the input
+    geometry. Duplicated vertices will be dropped from lines and polygons for grid sizes
+    greater than 0. Line and polygon geometries may collapse to empty geometries if all
+    vertices are closer together than grid_size. Z values, if present, will not be
+    modified.
+
+    Note: subsequent operations will always be performed in the precision of the
+    geometry with higher precision (smaller "grid_size"). That same precision will be
+    attached to the operation outputs.
+
+    Also note: input geometries should be geometrically valid; unexpected results may
+    occur if input geometries are not.
+
+    Args:
+        geometry: Geometry or array_like
+        grid_size (float): Precision grid size. If 0, will use double precision (will
+            not modify geometry if precision grid size was not previously set). If this
+            value is more precise than input geometry, the input geometry will not be
+            modified.
+        mode (str, optional): This parameter determines how to handle invalid output
+            geometries. There are three modes:
+
+            1. 'valid_output' (default):  The output is always valid. Collapsed
+                geometry elements  (including both polygons and lines) are removed.
+                Duplicate vertices are removed.
+            2. 'pointwise': Precision reduction is performed pointwise. Output geometry
+                may be invalid due to collapse or self-intersection. Duplicate vertices
+                are not removed. In GEOS this option is called NO_TOPO.
+            3. 'keep_collapsed': Like the default mode, except that collapsed linear
+                geometry elements are preserved. Collapsed polygonal input elements are
+                removed. Duplicate vertices are removed.
+        raise_on_topoerror (bool, optional): If False, instead of raising an error on a
+            topology error, retries after applying make_valid and returns the input if
+            it still fails. Defaults to True.
+
+    Returns:
+        geometry or array_like: The input with the precision applied. Returns None if
+            geometry is None.
+    """
+    if raise_on_topoerror:
+        return shapely.set_precision(geometry, grid_size=grid_size, mode=mode)
+
+    # Don't return an error when topologyerror occurs
+    try:
+        return shapely.set_precision(geometry, grid_size=grid_size, mode=mode)
+
+    except shapely.errors.GEOSException as ex:
+        if not str(ex).lower().startswith("topologyexception"):  # pragma: no cover
+            raise
+
+        # If set_precision fails with TopologyException, try again after make_valid
+        # Because it is applied on a GeoDataFrame with typically many rows, we don't
+        # know which row is invalid, so use only_if_invalid=True.
+        geometry = pygeoops.make_valid(
+            geometry, keep_collapsed=False, only_if_invalid=True
+        )
+
+        # Try again now
+        try:
+            geometry = shapely.set_precision(geometry, grid_size=grid_size, mode=mode)
+            warnings.warn(
+                f"error setting grid_size, but it succeeded after makevalid: <{ex}>",
+                stacklevel=1,
+            )
+            return geometry
+
+        except shapely.errors.GEOSException as ex:
+            if not str(ex).lower().startswith("topologyexception"):  # pragma: no cover
+                raise
+
+            # Still getting a TopologyException, so apply set_precision to each element
+            # seperately and keep the input for the ones giving an error.
+            # Deal with 0 dim arrays as input
+            geometry = _extract_0dim_ndarray(geometry)
+
+            # If there is only one element, just return the input
+            if not hasattr(geometry, "__len__"):
+                warnings.warn(
+                    f"error setting grid_size, input was returned, for {geometry}, "
+                    f"error: {ex}",
+                    stacklevel=1,
+                )
+                return geometry
+
+            # The input is arraylike... so try set_precision on each element
+            result = []
+            for geom in geometry:
+                try:
+                    result.append(
+                        shapely.set_precision(geom, grid_size=grid_size, mode=mode)
+                    )
+                except shapely.errors.GEOSException as ex:
+                    if not str(ex).lower().startswith("topologyexception"):
+                        raise
+
+                    # Just return the input
+                    result.append(geom)
+                    warnings.warn(
+                        f"error setting grid_size, input was returned, for {geom}, "
+                        f"error: {ex}",
+                        stacklevel=1,
+                    )
+
+            return np.array(result)
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_io_util.py` & `geofileops-0.8.2/geofileops/util/_io_util.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,132 +1,132 @@
-"""
-Module containing some utilities regarding io.
-"""
-
-import os
-from pathlib import Path
-import tempfile
-from typing import Optional, Tuple
-
-
-def create_tempdir(base_dirname: str, parent_dir: Optional[Path] = None) -> Path:
-    """
-    Creates a new tempdir in the default temp location.
-
-    Remark: the temp dir won't be cleaned up automatically!
-
-    Examples:
-        - base_dirname="foo" -> /tmp/foo_000001
-        - base_dirname="foo/bar" -> /tmp/foo/bar_000001
-
-    Args:
-        base_dirname (str): The name the tempdir will start with. The name will be
-            suffixed with a number to make the directory name unique. If a "/" is part
-            of the base_dirname a subdirectory will be created: e.g. "foo/bar".
-        parent_dir (Path, optional): The dir to create the tempdir in. If None, the
-            system temp dir is used. Defaults to None.
-
-    Raises:
-        Exception: if it wasn't possible to create the temp dir because there
-            wasn't found a unique directory name.
-
-    Returns:
-        Path: the path to the temp dir created.
-    """
-    if parent_dir is None:
-        parent_dir = Path(tempfile.gettempdir())
-
-    for i in range(1, 999999):
-        try:
-            tempdir = parent_dir / f"{base_dirname}_{i:06d}"
-            tempdir.mkdir(parents=True)
-            return tempdir
-        except FileExistsError:
-            continue
-
-    raise Exception(
-        f"Wasn't able to create a temporary dir with basedir: "
-        f"{parent_dir / base_dirname}"
-    )
-
-
-def get_tempfile_locked(
-    base_filename: str,
-    suffix: str = ".tmp",
-    dirname: Optional[str] = None,
-    tempdir: Optional[Path] = None,
-) -> Tuple[Path, Path]:
-    """
-    Formats a temp file path, and creates a corresponding lock file.
-
-    This way you can treat it immediately as being locked.
-
-    Args:
-        base_filename (str): The base filename to use. A numeric suffix will be
-            appended to make the filename unique.
-        suffix (str, optional): The suffix/extension of the tempfile.
-            Defaults to '.tmp'.
-        dirname (str, optional): Name of the subdir to put the tempfile in.
-            Defaults to None, then the tempfile created is put directly in the
-            root of the tempdir.
-        tempdir (Path, optional): Root temp dir to create the file in. If no
-            tempdir is specified, the default temp dir will be used.
-            Defaults to None.
-
-    Raises:
-        Exception: if it wasn't possible to create the temp dir because there
-            wasn't found a unique file name.
-
-    Returns:
-        Tuple[Path, Path]: First path is the temp file, second one is the lock file.
-    """
-    # If no dir specified, use default temp dir
-    if tempdir is None:
-        tempdir = Path(tempfile.gettempdir())
-    if dirname is not None:
-        tempdir = tempdir / dirname
-        tempdir.mkdir(parents=True, exist_ok=True)
-
-    # Now look for a unique filename based on the base_filename and put a lock file
-    for i in range(1, 999999):
-        tempfile_path = tempdir / f"{base_filename}_{i:06d}{suffix}"
-        tempfilelock_path = tempdir / f"{base_filename}_{i:06d}{suffix}.lock"
-        result = create_file_atomic(tempfilelock_path)
-        if result is True:
-            if not tempfile_path.exists():
-                # OK!
-                return (tempfile_path, tempfilelock_path)
-            else:
-                # Apparently the lock file didn't exist yet, but the file did.
-                # So delete lock file and try again.
-                tempfilelock_path.unlink()
-
-    raise Exception(
-        f"Wasn't able to create a temporary file with base_filename: {base_filename}, "
-        f"dir: {dir}"
-    )
-
-
-def create_file_atomic(filename) -> bool:
-    """
-    Create a lock file in an atomic way, so it is threadsafe.
-
-    Returns True if the file was created by this thread, False if the file existed
-    already.
-    """
-    try:
-        fd = os.open(filename, os.O_CREAT | os.O_EXCL)
-        os.close(fd)
-        return True
-    except FileExistsError:
-        return False
-    except OSError as ex:  # pragma: no cover
-        if ex.errno == 13:
-            return False
-        else:
-            raise Exception("Error creating lock file {filename}") from ex
-
-
-def with_stem(path: Path, new_stem) -> Path:
-    # Remark: from python 3.9 this is available on any Path, but to avoid
-    # having to require 3.9 for this, this hack...
-    return path.parent / f"{new_stem}{path.suffix}"
+"""
+Module containing some utilities regarding io.
+"""
+
+import os
+from pathlib import Path
+import tempfile
+from typing import Optional, Tuple
+
+
+def create_tempdir(base_dirname: str, parent_dir: Optional[Path] = None) -> Path:
+    """
+    Creates a new tempdir in the default temp location.
+
+    Remark: the temp dir won't be cleaned up automatically!
+
+    Examples:
+        - base_dirname="foo" -> /tmp/foo_000001
+        - base_dirname="foo/bar" -> /tmp/foo/bar_000001
+
+    Args:
+        base_dirname (str): The name the tempdir will start with. The name will be
+            suffixed with a number to make the directory name unique. If a "/" is part
+            of the base_dirname a subdirectory will be created: e.g. "foo/bar".
+        parent_dir (Path, optional): The dir to create the tempdir in. If None, the
+            system temp dir is used. Defaults to None.
+
+    Raises:
+        Exception: if it wasn't possible to create the temp dir because there
+            wasn't found a unique directory name.
+
+    Returns:
+        Path: the path to the temp dir created.
+    """
+    if parent_dir is None:
+        parent_dir = Path(tempfile.gettempdir())
+
+    for i in range(1, 999999):
+        try:
+            tempdir = parent_dir / f"{base_dirname}_{i:06d}"
+            tempdir.mkdir(parents=True)
+            return tempdir
+        except FileExistsError:
+            continue
+
+    raise Exception(
+        f"Wasn't able to create a temporary dir with basedir: "
+        f"{parent_dir / base_dirname}"
+    )
+
+
+def get_tempfile_locked(
+    base_filename: str,
+    suffix: str = ".tmp",
+    dirname: Optional[str] = None,
+    tempdir: Optional[Path] = None,
+) -> Tuple[Path, Path]:
+    """
+    Formats a temp file path, and creates a corresponding lock file.
+
+    This way you can treat it immediately as being locked.
+
+    Args:
+        base_filename (str): The base filename to use. A numeric suffix will be
+            appended to make the filename unique.
+        suffix (str, optional): The suffix/extension of the tempfile.
+            Defaults to '.tmp'.
+        dirname (str, optional): Name of the subdir to put the tempfile in.
+            Defaults to None, then the tempfile created is put directly in the
+            root of the tempdir.
+        tempdir (Path, optional): Root temp dir to create the file in. If no
+            tempdir is specified, the default temp dir will be used.
+            Defaults to None.
+
+    Raises:
+        Exception: if it wasn't possible to create the temp dir because there
+            wasn't found a unique file name.
+
+    Returns:
+        Tuple[Path, Path]: First path is the temp file, second one is the lock file.
+    """
+    # If no dir specified, use default temp dir
+    if tempdir is None:
+        tempdir = Path(tempfile.gettempdir())
+    if dirname is not None:
+        tempdir = tempdir / dirname
+        tempdir.mkdir(parents=True, exist_ok=True)
+
+    # Now look for a unique filename based on the base_filename and put a lock file
+    for i in range(1, 999999):
+        tempfile_path = tempdir / f"{base_filename}_{i:06d}{suffix}"
+        tempfilelock_path = tempdir / f"{base_filename}_{i:06d}{suffix}.lock"
+        result = create_file_atomic(tempfilelock_path)
+        if result is True:
+            if not tempfile_path.exists():
+                # OK!
+                return (tempfile_path, tempfilelock_path)
+            else:
+                # Apparently the lock file didn't exist yet, but the file did.
+                # So delete lock file and try again.
+                tempfilelock_path.unlink()
+
+    raise Exception(
+        f"Wasn't able to create a temporary file with base_filename: {base_filename}, "
+        f"dir: {dir}"
+    )
+
+
+def create_file_atomic(filename) -> bool:
+    """
+    Create a lock file in an atomic way, so it is threadsafe.
+
+    Returns True if the file was created by this thread, False if the file existed
+    already.
+    """
+    try:
+        fd = os.open(filename, os.O_CREAT | os.O_EXCL)
+        os.close(fd)
+        return True
+    except FileExistsError:
+        return False
+    except OSError as ex:  # pragma: no cover
+        if ex.errno == 13:
+            return False
+        else:
+            raise Exception("Error creating lock file {filename}") from ex
+
+
+def with_stem(path: Path, new_stem) -> Path:
+    # Remark: from python 3.9 this is available on any Path, but to avoid
+    # having to require 3.9 for this, this hack...
+    return path.parent / f"{new_stem}{path.suffix}"
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_ogr_sql_util.py` & `geofileops-0.8.2/geofileops/util/_ogr_sql_util.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,192 +1,192 @@
-"""
-Module with utilities to format sql statements meant for use with ogr.
-"""
-
-from typing import Iterable, List, Optional
-
-
-class ColumnFormatter:
-    """
-    Format strings with the columns for use in sql statements.
-
-    There are some specific hacks that are related to specific behaviours of ogr, mainly
-    regarding the handling of the special "fid" column.
-    """
-
-    _aliases_cache: Optional[List[str]] = None
-
-    def __init__(
-        self,
-        columns_asked: Optional[List[str]],
-        columns_in_layer: Iterable[str],
-        fid_column: str,
-        table_alias: str = "",
-        column_alias_prefix: str = "",
-    ):
-        """
-        Format strings with column names for use in sql statements.
-
-        Args:
-            columns_asked (Optional[List[str]]): the column names to read from the
-                file. If None, all available columns in the layer should be read.
-                In addition to standard columns, it is also possible to specify "fid",
-                a unique index available in all input files.
-                Note that the "fid" will be aliased even if column_alias_prefix is "",
-                eg. to "fid_1".
-            columns_in_layer (Iterable[str]): the column names of the columns available
-                in the layer that is being read from.
-            fid_column (str): fid column name as reported by the gdal GetFIDColumn()
-                function. For file types that don't store the fid this is "".
-            table_alias (str, optional): table alias to be used.
-                Defaults to "": no table alias.
-            column_alias_prefix (str, optional): prefix to use for column aliases.
-                Defaults to "": no prefix.
-
-        Raises:
-            ValueError: if columns are asked that are not available in the layer.
-        """
-        self._columns_in_layer = columns_in_layer
-        self._fid_column = fid_column
-        self._table_prefix = f"{table_alias}." if table_alias != "" else ""
-        self._table_alias = table_alias
-        self._columnname_prefix = column_alias_prefix
-
-        # Now prepare the actual column list to use
-        if columns_asked is not None:
-            # Add special column "fid" to available columns so it can be specified
-            columns_in_layer = list(columns_in_layer) + ["fid"]
-            # Case-insensitive check if input1_columns contains columns not in layer...
-            columns_in_layer_upper = {
-                column.upper(): column for column in columns_in_layer
-            }
-            missing_columns = [
-                col
-                for col in columns_asked
-                if (col.upper() not in columns_in_layer_upper)
-            ]
-            if len(missing_columns) > 0:
-                raise ValueError(
-                    "columns_asked contains columns not in columns_in_layer: "
-                    f"{missing_columns}. Available: {columns_in_layer}"
-                )
-
-            # Create column list to keep in the casing of the original columns
-            columns = [columns_in_layer_upper[col.upper()] for col in columns_asked]
-        else:
-            columns = list(columns_in_layer)
-            columns_asked = columns
-
-        self._columns = columns
-        self._columns_asked = columns_asked
-
-    def _columns_prefixed(self) -> List[str]:
-        columns_prefixed = [
-            f'{self._table_prefix}"{column}"' for column in self._columns
-        ]
-        columns_prefixed = self._fix_fid_columns(columns_prefixed)
-        return columns_prefixed
-
-    def _fix_fid_columns(self, columns: List[str]) -> List[str]:
-        """
-        Fix the fid columns.
-
-        Useful if the "fid" special column needs some extra treatment:
-            - if the fid_column name as reported by gdal is "", this means that the file
-              format doesn't actually save the fid (eg. shapefile) but uses a row number
-              in the file. When using sql in sql_dialect "SQLITE", "rowid" is the
-              equivalent.
-            - if the fid_column name as reported by gdal is "fid", ogr will treat the
-              selected column as "fid" in the destination file as well, even if an alias
-              is specified. To stop ogr from doing this, putting a CAST(... AS INT)
-              around it prevents ogr from recognizing it.
-              Remark: the ogr2ogr -unsetFid switch didn't help.
-            - if the fid_column name as reported by gdal is some other string, "fid"
-              just needs to be replaced by the fid_column value.
-        """
-        columns = list(columns)
-        fid_column_indexes = [
-            idx for idx, col in enumerate(self._columns) if col.upper() == "FID"
-        ]
-        if self._fid_column.lower() == "fid":
-            # Put CAST() around "fid"
-            for fid_column_index in fid_column_indexes:
-                columns[fid_column_index] = f"CAST({columns[fid_column_index]} AS INT)"
-        else:
-            # Replace "fid" by the fid_column or rowid
-            replace_fid_column = self._fid_column if self._fid_column != "" else "rowid"
-            for fid_column_index in fid_column_indexes:
-                columns[fid_column_index] = columns[fid_column_index].replace(
-                    self._columns[fid_column_index], replace_fid_column
-                )
-
-        return columns
-
-    def _aliases(self) -> List[str]:
-        if self._aliases_cache is not None:
-            return self._aliases_cache
-
-        # Use columns_asked to keep asked casing
-        aliases = [
-            f"{self._columnname_prefix}{column}" for column in self._columns_asked
-        ]
-
-        # If no prefix, create a unique alias for fid column(s)
-        if self._columnname_prefix == "":
-            for alias_idx, alias in enumerate(aliases):
-                if alias.lower() == "fid":
-                    # If alias "fid", change it + make sure the alias isn't in use yet
-                    for idx in range(1, 100):
-                        alias_with_id = f"{alias}_{idx}"
-                        if alias_with_id not in aliases:
-                            aliases[alias_idx] = alias_with_id
-                            break
-
-        self._aliases_cache = aliases
-        return self._aliases_cache
-
-    def quoted(self) -> str:
-        if len(self._columns) == 0:
-            return ""
-
-        columns_quoted = [f'"{column}"' for column in self._columns]
-        columns_quoted = self._fix_fid_columns(columns_quoted)
-        return f",{', '.join(columns_quoted)}"
-
-    def prefixed(self) -> str:
-        if len(self._columns) == 0:
-            return ""
-        return f",{', '.join(self._columns_prefixed())}"
-
-    def prefixed_aliased(self):
-        if len(self._columns) == 0:
-            return ""
-
-        columns_prefixed_aliased = [
-            f'{column_prefixed} "{column_alias}"'
-            for column_prefixed, column_alias in zip(
-                self._columns_prefixed(), self._aliases()
-            )
-        ]
-        return f",{', '.join(columns_prefixed_aliased)}"
-
-    def null_aliased(self):
-        if len(self._columns) == 0:
-            return ""
-
-        columns_null_aliased = [f'NULL "{alias}"' for alias in self._aliases()]
-        return f",{', '.join(columns_null_aliased)}"
-
-    def from_subselect(self, subselect_alias: str = "sub"):
-        if len(self._columns) == 0:
-            return ""
-
-        prefix = "" if subselect_alias == "" else f"{subselect_alias}."
-        columns_from_subselect = [f'{prefix}"{alias}"' for alias in self._aliases()]
-        return f",{', '.join(columns_from_subselect)}"
-
-
-def columns_quoted(columns: List[str]):
-    if len(columns) == 0:
-        return ""
-    columns_quoted = [f'"{column}"' for column in columns]
-    return f",{', '.join(columns_quoted)}"
+"""
+Module with utilities to format sql statements meant for use with ogr.
+"""
+
+from typing import Iterable, List, Optional
+
+
+class ColumnFormatter:
+    """
+    Format strings with the columns for use in sql statements.
+
+    There are some specific hacks that are related to specific behaviours of ogr, mainly
+    regarding the handling of the special "fid" column.
+    """
+
+    _aliases_cache: Optional[List[str]] = None
+
+    def __init__(
+        self,
+        columns_asked: Optional[List[str]],
+        columns_in_layer: Iterable[str],
+        fid_column: str,
+        table_alias: str = "",
+        column_alias_prefix: str = "",
+    ):
+        """
+        Format strings with column names for use in sql statements.
+
+        Args:
+            columns_asked (Optional[List[str]]): the column names to read from the
+                file. If None, all available columns in the layer should be read.
+                In addition to standard columns, it is also possible to specify "fid",
+                a unique index available in all input files.
+                Note that the "fid" will be aliased even if column_alias_prefix is "",
+                eg. to "fid_1".
+            columns_in_layer (Iterable[str]): the column names of the columns available
+                in the layer that is being read from.
+            fid_column (str): fid column name as reported by the gdal GetFIDColumn()
+                function. For file types that don't store the fid this is "".
+            table_alias (str, optional): table alias to be used.
+                Defaults to "": no table alias.
+            column_alias_prefix (str, optional): prefix to use for column aliases.
+                Defaults to "": no prefix.
+
+        Raises:
+            ValueError: if columns are asked that are not available in the layer.
+        """
+        self._columns_in_layer = columns_in_layer
+        self._fid_column = fid_column
+        self._table_prefix = f"{table_alias}." if table_alias != "" else ""
+        self._table_alias = table_alias
+        self._columnname_prefix = column_alias_prefix
+
+        # Now prepare the actual column list to use
+        if columns_asked is not None:
+            # Add special column "fid" to available columns so it can be specified
+            columns_in_layer = list(columns_in_layer) + ["fid"]
+            # Case-insensitive check if input1_columns contains columns not in layer...
+            columns_in_layer_upper = {
+                column.upper(): column for column in columns_in_layer
+            }
+            missing_columns = [
+                col
+                for col in columns_asked
+                if (col.upper() not in columns_in_layer_upper)
+            ]
+            if len(missing_columns) > 0:
+                raise ValueError(
+                    "columns_asked contains columns not in columns_in_layer: "
+                    f"{missing_columns}. Available: {columns_in_layer}"
+                )
+
+            # Create column list to keep in the casing of the original columns
+            columns = [columns_in_layer_upper[col.upper()] for col in columns_asked]
+        else:
+            columns = list(columns_in_layer)
+            columns_asked = columns
+
+        self._columns = columns
+        self._columns_asked = columns_asked
+
+    def _columns_prefixed(self) -> List[str]:
+        columns_prefixed = [
+            f'{self._table_prefix}"{column}"' for column in self._columns
+        ]
+        columns_prefixed = self._fix_fid_columns(columns_prefixed)
+        return columns_prefixed
+
+    def _fix_fid_columns(self, columns: List[str]) -> List[str]:
+        """
+        Fix the fid columns.
+
+        Useful if the "fid" special column needs some extra treatment:
+            - if the fid_column name as reported by gdal is "", this means that the file
+              format doesn't actually save the fid (eg. shapefile) but uses a row number
+              in the file. When using sql in sql_dialect "SQLITE", "rowid" is the
+              equivalent.
+            - if the fid_column name as reported by gdal is "fid", ogr will treat the
+              selected column as "fid" in the destination file as well, even if an alias
+              is specified. To stop ogr from doing this, putting a CAST(... AS INT)
+              around it prevents ogr from recognizing it.
+              Remark: the ogr2ogr -unsetFid switch didn't help.
+            - if the fid_column name as reported by gdal is some other string, "fid"
+              just needs to be replaced by the fid_column value.
+        """
+        columns = list(columns)
+        fid_column_indexes = [
+            idx for idx, col in enumerate(self._columns) if col.upper() == "FID"
+        ]
+        if self._fid_column.lower() == "fid":
+            # Put CAST() around "fid"
+            for fid_column_index in fid_column_indexes:
+                columns[fid_column_index] = f"CAST({columns[fid_column_index]} AS INT)"
+        else:
+            # Replace "fid" by the fid_column or rowid
+            replace_fid_column = self._fid_column if self._fid_column != "" else "rowid"
+            for fid_column_index in fid_column_indexes:
+                columns[fid_column_index] = columns[fid_column_index].replace(
+                    self._columns[fid_column_index], replace_fid_column
+                )
+
+        return columns
+
+    def _aliases(self) -> List[str]:
+        if self._aliases_cache is not None:
+            return self._aliases_cache
+
+        # Use columns_asked to keep asked casing
+        aliases = [
+            f"{self._columnname_prefix}{column}" for column in self._columns_asked
+        ]
+
+        # If no prefix, create a unique alias for fid column(s)
+        if self._columnname_prefix == "":
+            for alias_idx, alias in enumerate(aliases):
+                if alias.lower() == "fid":
+                    # If alias "fid", change it + make sure the alias isn't in use yet
+                    for idx in range(1, 100):
+                        alias_with_id = f"{alias}_{idx}"
+                        if alias_with_id not in aliases:
+                            aliases[alias_idx] = alias_with_id
+                            break
+
+        self._aliases_cache = aliases
+        return self._aliases_cache
+
+    def quoted(self) -> str:
+        if len(self._columns) == 0:
+            return ""
+
+        columns_quoted = [f'"{column}"' for column in self._columns]
+        columns_quoted = self._fix_fid_columns(columns_quoted)
+        return f",{', '.join(columns_quoted)}"
+
+    def prefixed(self) -> str:
+        if len(self._columns) == 0:
+            return ""
+        return f",{', '.join(self._columns_prefixed())}"
+
+    def prefixed_aliased(self):
+        if len(self._columns) == 0:
+            return ""
+
+        columns_prefixed_aliased = [
+            f'{column_prefixed} "{column_alias}"'
+            for column_prefixed, column_alias in zip(
+                self._columns_prefixed(), self._aliases()
+            )
+        ]
+        return f",{', '.join(columns_prefixed_aliased)}"
+
+    def null_aliased(self):
+        if len(self._columns) == 0:
+            return ""
+
+        columns_null_aliased = [f'NULL "{alias}"' for alias in self._aliases()]
+        return f",{', '.join(columns_null_aliased)}"
+
+    def from_subselect(self, subselect_alias: str = "sub"):
+        if len(self._columns) == 0:
+            return ""
+
+        prefix = "" if subselect_alias == "" else f"{subselect_alias}."
+        columns_from_subselect = [f'{prefix}"{alias}"' for alias in self._aliases()]
+        return f",{', '.join(columns_from_subselect)}"
+
+
+def columns_quoted(columns: List[str]):
+    if len(columns) == 0:
+        return ""
+    columns_quoted = [f'"{column}"' for column in columns]
+    return f",{', '.join(columns_quoted)}"
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_ogr_util.py` & `geofileops-0.8.2/geofileops/util/_ogr_util.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,692 +1,688 @@
-"""
-Module containing utilities regarding the usage of ogr/gdal functionalities.
-"""
-
-import logging
-import os
-from pathlib import Path
-import tempfile
-from threading import Lock
-from typing import Dict, List, Literal, Optional, Tuple, Union
-
-from osgeo import gdal
-from osgeo import ogr
-from pygeoops import GeometryType
-
-import geofileops as gfo
-from geofileops import fileops
-
-# Make sure only one instance per process is running
-lock = Lock()
-
-# Get a logger...
-logger = logging.getLogger(__name__)
-
-
-class GDALError(Exception):
-    """Error with extra gdal info."""
-
-    def __init__(
-        self,
-        message: str,
-        log_details: [List[str]] = [],
-        error_details: [List[str]] = [],
-    ):
-        self.message = message
-        self.log_details = log_details
-        self.error_details = error_details
-        super().__init__(self.message)
-
-    def __str__(self):
-        retstring = ""
-        if len(self.error_details) > 0:
-            retstring += "\n    GDAL CPL_LOG ERRORS"
-            retstring += "\n    -------------------"
-            retstring += "\n    "
-            retstring += "\n    ".join(self.error_details)
-        if len(self.log_details) > 0:
-            retstring += "\n    GDAL CPL_LOG ALL"
-            retstring += "\n    ----------------"
-            retstring += "\n    "
-            retstring += "\n    ".join(self.log_details)
-
-        if len(retstring) > 0:
-            return f"{retstring}\n{super().__str__()}"
-        else:
-            return super().__str__()
-
-
-ogrtype_to_geometrytype = {
-    ogr.wkbNone: None,
-    ogr.wkbUnknown: GeometryType.GEOMETRY,
-    ogr.wkbPoint: GeometryType.POINT,
-    ogr.wkbLineString: GeometryType.LINESTRING,
-    ogr.wkbPolygon: GeometryType.POLYGON,
-    ogr.wkbTriangle: GeometryType.TRIANGLE,
-    ogr.wkbMultiPoint: GeometryType.MULTIPOINT,
-    ogr.wkbMultiLineString: GeometryType.MULTILINESTRING,
-    ogr.wkbMultiPolygon: GeometryType.MULTIPOLYGON,
-    ogr.wkbGeometryCollection: GeometryType.GEOMETRYCOLLECTION,
-    ogr.wkbPolyhedralSurface: GeometryType.POLYHEDRALSURFACE,
-    ogr.wkbTIN: GeometryType.TIN,
-    ogr.wkbPoint25D: GeometryType.POINTZ,
-    ogr.wkbLineString25D: GeometryType.LINESTRINGZ,
-    ogr.wkbPolygon25D: GeometryType.POLYGONZ,
-    ogr.wkbTriangleZ: GeometryType.TRIANGLEZ,
-    ogr.wkbMultiPoint25D: GeometryType.MULTIPOINTZ,
-    ogr.wkbMultiLineString25D: GeometryType.MULTILINESTRINGZ,
-    ogr.wkbMultiPolygon25D: GeometryType.MULTIPOLYGONZ,
-    ogr.wkbGeometryCollection25D: GeometryType.GEOMETRYCOLLECTIONZ,
-    ogr.wkbPolyhedralSurfaceZ: GeometryType.POLYHEDRALSURFACEZ,
-    ogr.wkbTINZ: GeometryType.TINZ,
-    ogr.wkbPointM: GeometryType.POINTM,
-    ogr.wkbLineStringM: GeometryType.LINESTRINGM,
-    ogr.wkbPolygonM: GeometryType.POLYGONM,
-    ogr.wkbTriangleM: GeometryType.TRIANGLEM,
-    ogr.wkbMultiPointM: GeometryType.MULTIPOINTM,
-    ogr.wkbMultiLineStringM: GeometryType.MULTILINESTRINGM,
-    ogr.wkbMultiPolygonM: GeometryType.MULTIPOLYGONM,
-    ogr.wkbGeometryCollectionM: GeometryType.GEOMETRYCOLLECTIONM,
-    ogr.wkbPolyhedralSurfaceM: GeometryType.POLYHEDRALSURFACEM,
-    ogr.wkbTINM: GeometryType.TINM,
-    ogr.wkbPointZM: GeometryType.POINTZM,
-    ogr.wkbLineStringZM: GeometryType.LINESTRINGZM,
-    ogr.wkbPolygonZM: GeometryType.POLYGONZM,
-    ogr.wkbTriangleZM: GeometryType.TRIANGLEZM,
-    ogr.wkbMultiPointZM: GeometryType.MULTIPOINTZM,
-    ogr.wkbMultiLineStringZM: GeometryType.MULTILINESTRINGZM,
-    ogr.wkbMultiPolygonZM: GeometryType.MULTIPOLYGONZM,
-    ogr.wkbGeometryCollectionZM: GeometryType.GEOMETRYCOLLECTIONZM,
-    ogr.wkbPolyhedralSurfaceZM: GeometryType.POLYHEDRALSURFACEZM,
-    ogr.wkbTINZM: GeometryType.TINZM,
-}
-
-
-def get_drivers() -> dict:
-    drivers = {}
-    for i in range(gdal.GetDriverCount()):
-        driver = gdal.GetDriver(i)
-        drivers[driver.ShortName] = driver.GetDescription()
-    return drivers
-
-
-def read_cpl_log(path: Path) -> Tuple[List[str], List[str]]:
-    """
-    Reads a cpl_log file and returns a list with log lines and errors.
-
-    Args:
-        path (Path): the file path to the cpl_log file.
-
-    Returns:
-        Tuple[List[str], List[str]]: tuple with a list of all log lines and a list of
-            errors.
-    """
-    if not path.exists() or path.stat().st_size == 0:
-        return ([], [])
-
-    with open(path) as logfile:
-        log_lines = logfile.readlines()
-
-    # Cleanup + check for errors
-    lines_cleaned = []
-    lines_error = []
-    for line in log_lines:
-        line = line.strip("\0\n ")
-        if line != "":
-            lines_cleaned.append(line)
-            if line.startswith("ERROR"):
-                lines_error.append(line)
-
-    return (lines_cleaned, lines_error)
-
-
-class VectorTranslateInfo:
-    def __init__(
-        self,
-        input_path: Path,
-        output_path: Path,
-        input_layers: Union[List[str], str, None] = None,
-        output_layer: Optional[str] = None,
-        input_srs: Union[int, str, None] = None,
-        output_srs: Union[int, str, None] = None,
-        reproject: bool = False,
-        spatial_filter: Optional[Tuple[float, float, float, float]] = None,
-        clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
-        sql_stmt: Optional[str] = None,
-        sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
-        where: Optional[str] = None,
-        transaction_size: int = 65536,
-        append: bool = False,
-        update: bool = False,
-        explodecollections: bool = False,
-        force_output_geometrytype: Union[GeometryType, str, None] = None,
-        options: dict = {},
-        columns: Optional[List[str]] = None,
-        warp: Optional[dict] = None,
-        preserve_fid: Optional[bool] = None,
-        dst_dimensions: Optional[str] = None,
-    ):
-        self.input_path = input_path
-        self.output_path = output_path
-        self.input_layers = input_layers
-        self.output_layer = output_layer
-        self.input_srs = input_srs
-        self.output_srs = output_srs
-        self.reproject = reproject
-        self.spatial_filter = spatial_filter
-        self.clip_geometry = clip_geometry
-        self.sql_stmt = sql_stmt
-        self.sql_dialect = sql_dialect
-        self.where = where
-        self.transaction_size = transaction_size
-        self.append = append
-        self.update = update
-        self.explodecollections = explodecollections
-        self.force_output_geometrytype = force_output_geometrytype
-        self.options = options
-        self.columns = columns
-        self.warp = warp
-        self.preserve_fid = preserve_fid
-        self.dst_dimensions = dst_dimensions
-
-
-def vector_translate_by_info(info: VectorTranslateInfo):
-    return vector_translate(
-        input_path=info.input_path,
-        output_path=info.output_path,
-        input_layers=info.input_layers,
-        output_layer=info.output_layer,
-        input_srs=info.input_srs,
-        output_srs=info.output_srs,
-        reproject=info.reproject,
-        spatial_filter=info.spatial_filter,
-        clip_geometry=info.clip_geometry,
-        sql_stmt=info.sql_stmt,
-        sql_dialect=info.sql_dialect,
-        where=info.where,
-        transaction_size=info.transaction_size,
-        append=info.append,
-        update=info.update,
-        explodecollections=info.explodecollections,
-        force_output_geometrytype=info.force_output_geometrytype,
-        options=info.options,
-        columns=info.columns,
-        warp=info.warp,
-        preserve_fid=info.preserve_fid,
-        dst_dimensions=info.dst_dimensions,
-    )
-
-
-def vector_translate(
-    input_path: Union[Path, str],
-    output_path: Path,
-    input_layers: Union[List[str], str, None] = None,
-    output_layer: Optional[str] = None,
-    input_srs: Union[int, str, None] = None,
-    output_srs: Union[int, str, None] = None,
-    reproject: bool = False,
-    spatial_filter: Optional[Tuple[float, float, float, float]] = None,
-    clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
-    sql_stmt: Optional[str] = None,
-    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
-    where: Optional[str] = None,
-    transaction_size: int = 65536,
-    append: bool = False,
-    update: bool = False,
-    explodecollections: bool = False,
-    force_output_geometrytype: Union[GeometryType, str, None] = None,
-    options: dict = {},
-    columns: Optional[List[str]] = None,
-    warp: Optional[dict] = None,
-    preserve_fid: Optional[bool] = None,
-    dst_dimensions: Optional[bool] = None,
-) -> bool:
-    # API Doc of VectorTranslateOptions:
-    #   https://gdal.org/api/python/osgeo.gdal.html#osgeo.gdal.VectorTranslateOptions
-    args = []
-    if isinstance(input_path, str):
-        input_path = Path(input_path)
-    gdal_options = _prepare_gdal_options(options, split_by_option_type=True)
-
-    # Input file parameters
-    input_info = fileops._geofileinfo.get_geofileinfo(input_path)
-    # Cleanup the input_layers variable.
-    if input_info.driver == "ESRI Shapefile":
-        # For shapefiles, having input_layers not None gives issues
-        input_layers = None
-    elif sql_stmt is not None:
-        # If a sql statement is passed, the input layers are not relevant,
-        # and ogr2ogr will give a warning, so clear it.
-        input_layers = None
-    if input_layers is not None and isinstance(input_layers, str):
-        input_layers = [input_layers]
-
-    # SRS
-    if input_srs is not None and isinstance(input_srs, int):
-        input_srs = f"EPSG:{input_srs}"
-
-    # Sql'ing, Filtering, clipping
-    if spatial_filter is not None:
-        args.extend(["-spat"])
-        bounds = [str(coord) for coord in spatial_filter]
-        args.extend(bounds)
-    if sql_stmt is not None:
-        # If sql_stmt starts with "\n" or "\t" for gpkg or with " " for a shp,
-        # VectorTranslate outputs no or an invalid file if the statement doesn't return
-        # any rows...
-        sql_stmt = sql_stmt.lstrip("\n\t ")
-    if clip_geometry is not None:
-        args.extend(["-clipsrc"])
-        if isinstance(clip_geometry, str):
-            args.extend([clip_geometry])
-        else:
-            bounds = [str(coord) for coord in clip_geometry]
-            args.extend(bounds)
-    if columns is not None:
-        args.extend(["-select", ",".join(columns)])
-    if sql_stmt is not None and where is not None:
-        raise ValueError("it is not supported to specify both sql_stmt and where")
-
-    # Warp
-    if warp is not None:
-        gcps = warp.get("gcps", [])
-        for gcp in gcps:
-            args.extend(["-gcp"])
-            args.extend([str(coord) for coord in gcp if coord is not None])
-        algorithm = warp.get("algorithm", "polynomial")
-        if algorithm == "polynomial":
-            order = warp.get("order", None)
-            if order is not None:
-                args.extend(["-order", order])
-        elif algorithm == "tps":
-            args.extend(["-tps"])
-        else:
-            raise ValueError(f"unsupported warp algorithm: {algorithm}")
-
-    # Input dataset open options
-    for option_name, value in gdal_options["INPUT_OPEN"].items():
-        args.extend(["-oo", f"{option_name}={value}"])
-
-    # Output file parameters
-    # Get driver for the output_path
-    output_info = fileops._geofileinfo.get_geofileinfo(output_path)
-
-    # Shapefiles only can have one layer, and the layer name == the stem of the file
-    if output_info.driver == "ESRI Shapefile":
-        output_layer = output_path.stem
-
-    # SRS
-    if output_srs is not None and isinstance(output_srs, int):
-        output_srs = f"EPSG:{output_srs}"
-
-    # Output basic options
-    if output_path.exists() is True:
-        if append is True:
-            args.append("-append")
-        if update is True:
-            args.append("-update")
-
-    datasetCreationOptions = []
-    # Output dataset creation options are only applicable if a new output file
-    # will be created
-    if output_path.exists() is False or update is False:
-        dataset_creation_options = gdal_options["DATASET_CREATION"]
-        if output_info.driver == "SQLite":
-            # If SQLite file, use the spatialite type of sqlite by default
-            if "SPATIALITE" not in dataset_creation_options:
-                dataset_creation_options["SPATIALITE"] = "YES"
-        for option_name, value in dataset_creation_options.items():
-            datasetCreationOptions.extend([f"{option_name}={value}"])
-
-    # Output layer options
-    if explodecollections is True:
-        args.append("-explodecollections")
-    output_geometrytypes = []
-    if force_output_geometrytype is not None:
-        if isinstance(force_output_geometrytype, GeometryType):
-            output_geometrytypes.append(force_output_geometrytype.name)
-        else:
-            output_geometrytypes.append(force_output_geometrytype)
-    else:
-        if not explodecollections:
-            output_geometrytypes.append("PROMOTE_TO_MULTI")
-    if transaction_size is not None:
-        args.extend(["-gt", str(transaction_size)])
-    if preserve_fid is None:
-        if explodecollections:
-            # If explodecollections is specified, explicitly disable fid to avoid errors
-            args.append("-unsetFid")
-    else:
-        if preserve_fid:
-            args.append("-preserve_fid")
-        else:
-            args.append("-unsetFid")
-
-    # Output layer creation options are only applicable if a new layer will be
-    # created
-    layerCreationOptions = []
-    if output_path.exists() is False or (update is True and append is False):
-        for option_name, value in gdal_options["LAYER_CREATION"].items():
-            layerCreationOptions.extend([f"{option_name}={value}"])
-
-    # General configuration options
-    # Remark: passing them as parameter using --config doesn't work, but they are set as
-    # runtime config options later on (using a context manager).
-    config_options = dict(gdal_options["CONFIG"])
-    if input_info.is_spatialite_based or output_info.is_spatialite_based:
-        # If spatialite based file, increase SQLITE cache size by default
-        if "OGR_SQLITE_CACHE" not in config_options:
-            config_options["OGR_SQLITE_CACHE"] = "128"
-
-    # Have gdal throw exception on error
-    gdal.UseExceptions()
-
-    # In some cases gdal only raises the last exception instead of the stack in
-    # VectorTranslate, so you then you would lose necessary details!
-    # Solution: have gdal log everything to a file using the CPL_LOG config setting,
-    # and if an error occurs, add the contents of the log file to the exception.
-    # I also tried using gdal.ConfigurePythonLogging, but with enable_debug=True all
-    # gdal debug logging is always logged, which is quite verbose and messy, and
-    # with enable_debug=True nothing is logged. In addition, after
-    # gdal.ConfigurePythonLogging is called, the CPL_LOG config setting is ignored.
-    if "CPL_LOG" not in config_options:
-        gdal_cpl_log_dir = Path(tempfile.gettempdir()) / "geofileops/gdal_cpl_log"
-        gdal_cpl_log_dir.mkdir(parents=True, exist_ok=True)
-        fd, gdal_cpl_log_path = tempfile.mkstemp(suffix=".log", dir=gdal_cpl_log_dir)
-        os.close(fd)
-        config_options["CPL_LOG"] = gdal_cpl_log_path
-        gdal_cpl_log_path = Path(gdal_cpl_log_path)
-    else:
-        gdal_cpl_log_path = Path(config_options["CPL_LOG"])
-    if "CPL_LOG_ERRORS" not in config_options:
-        config_options["CPL_LOG_ERRORS"] = "ON"
-    if "CPL_DEBUG" not in config_options:
-        config_options["CPL_DEBUG"] = "ON"
-
-    # Now we can really get to work
-    output_ds = None
-    try:
-        # Go!
-        with set_config_options(config_options):
-            # Open input datasource already
-            input_ds = gdal.OpenEx(
-                str(input_path),
-                nOpenFlags=gdal.OF_VECTOR | gdal.OF_READONLY | gdal.OF_SHARED,
-            )
-
-            # If output_srs is not specified and the result has 0 rows, gdal creates the
-            # output file without srs.
-            # documented in https://github.com/geofileops/geofileops/issues/313
-            if output_srs is None:
-                set_output_srs = True
-                datasource_layer = None
-                if input_layers is not None and len(input_layers) == 1:
-                    datasource_layer = input_ds.GetLayer(input_layers[0])
-                else:
-                    nb_layers = input_ds.GetLayerCount()
-                    if nb_layers == 1:
-                        datasource_layer = input_ds.GetLayerByIndex(0)
-                    elif nb_layers == 0:
-                        # We never actually get here, because opening a file without
-                        # layers already gives an error.
-                        raise ValueError(f"no layers found in {input_path}")
-                    else:
-                        # If multiple layers and not explicitly specified, it is in the
-                        # sql statement so difficult to determine... so pass
-                        set_output_srs = False
-
-                if set_output_srs:
-                    # If the layer doesn't exist, return
-                    if datasource_layer is None:
-                        raise RuntimeError(
-                            f"input_layers {input_layers} not found in: {input_path}"
-                        )
-                    spatialref = datasource_layer.GetSpatialRef()
-                    if spatialref is not None:
-                        output_srs = spatialref.ExportToWkt()
-
-            # If the output is a shapefile and the input geometries are NULL, gdal
-            # creates an attribute column "geometry" in the output file. To be able to
-            # detect this case later on, check here if the input file already has an
-            # attribute column "geometry".
-            input_has_geom_attribute = False
-            input_has_geometry_attribute = False
-            input_layer = input_ds.GetLayer()
-            layer_defn = input_layer.GetLayerDefn()
-            for field_idx in range(layer_defn.GetFieldCount()):
-                field_name_lower = layer_defn.GetFieldDefn(field_idx).GetName().lower()
-                if field_name_lower == "geom":
-                    input_has_geom_attribute = True
-                elif field_name_lower == "geometry":
-                    input_has_geometry_attribute = True
-
-            # Consolidate all parameters
-            # First take copy of args, because gdal.VectorTranslateOptions adds all
-            # other parameters to the list passed (by ref)!!!
-            args_copy = list(args)
-            options = gdal.VectorTranslateOptions(
-                options=args_copy,
-                format=output_info.driver,
-                accessMode=None,
-                srcSRS=input_srs,
-                dstSRS=output_srs,
-                reproject=reproject,
-                SQLStatement=sql_stmt,
-                SQLDialect=sql_dialect,
-                where=where,
-                selectFields=None,
-                addFields=False,
-                forceNullable=False,
-                spatFilter=spatial_filter,
-                spatSRS=None,
-                datasetCreationOptions=datasetCreationOptions,
-                layerCreationOptions=layerCreationOptions,
-                layers=input_layers,
-                layerName=output_layer,
-                geometryType=output_geometrytypes,
-                dim=dst_dimensions,
-                segmentizeMaxDist=None,
-                zField=None,
-                skipFailures=False,
-                limit=None,
-                callback=None,
-                callback_data=None,
-            )
-
-            output_ds = gdal.VectorTranslate(
-                destNameOrDestDS=str(output_path), srcDS=input_ds, options=options
-            )
-
-        # If the resulting datasource is None, something went wrong
-        if output_ds is None:
-            raise RuntimeError("output_ds is None")
-
-        # Sometimes an invalid output file is written, so close and try to reopen it.
-        output_ds = None
-        if output_path.exists():
-            try:
-                output_ds = gdal.OpenEx(
-                    str(output_path), nOpenFlags=gdal.OF_VECTOR | gdal.OF_UPDATE
-                )
-
-                # If the (first) output row contains NULL as geom/geometry, gdal will
-                # add an attribute column with the name of the (alias of) the geometry
-                # column: so "geometry" or "geom".
-                # To fix this, delete the "geom" or "geometry" attribute column if
-                # present if the input file didn't have an attribute column with this
-                # name.
-                # Bug documented in https://github.com/geofileops/geofileops/issues/313
-                #
-                # Remark: this check must be done on the reopened output file because
-                # in some cases the "geometrycolumn" is incorrectly listed in the field
-                # list of the Dataset returned by VectorTranslate. E.g. when the input
-                # file is empty.
-                if not input_has_geometry_attribute or not input_has_geom_attribute:
-                    assert isinstance(output_ds, gdal.Dataset)
-                    if output_layer is not None:
-                        result_layer = output_ds.GetLayer(output_layer)
-                    elif output_ds.GetLayerCount() == 1:
-                        result_layer = output_ds.GetLayerByIndex(0)
-                    else:
-                        result_layer = None
-                        logger.warning(
-                            "Unable to determine output layer, so not able to remove "
-                            "possibly incorrect geom and geometry text columns, with "
-                            f"input_path: {input_path}, output_path: {output_path}"
-                        )
-
-                    # Output layer was found, so check it
-                    if result_layer is not None:
-                        layer_defn = result_layer.GetLayerDefn()
-                        for field_idx in range(layer_defn.GetFieldCount()):
-                            name = layer_defn.GetFieldDefn(field_idx).GetName().lower()
-                            if (name == "geom" and not input_has_geom_attribute) or (
-                                name == "geometry" and not input_has_geometry_attribute
-                            ):
-                                result_layer.DeleteField(field_idx)
-                                break
-
-            except Exception as ex:
-                logger.info(
-                    f"Opening output file gave error, probably the input file was "
-                    f"empty, no rows were selected or geom was NULL: {ex}"
-                )
-                gfo.remove(output_path)
-            finally:
-                output_ds = None
-
-    except Exception as ex:
-        output_ds = None
-
-        # Prepare exception message
-        message = f"Error {ex} while creating/updating {output_path}"
-        if sql_stmt is not None:
-            message = f"{message} using sql_stmt {sql_stmt}"
-
-        # Read cpl_log file
-        log_lines, log_errors = read_cpl_log(gdal_cpl_log_path)
-
-        # Raise
-        raise GDALError(
-            message, log_details=log_lines, error_details=log_errors
-        ).with_traceback(ex.__traceback__)
-
-    finally:
-        output_ds = None
-        input_ds = None
-
-        if gdal_cpl_log_path.exists():
-            # Truncate the cpl log file already, because sometimes it is locked and
-            # cannot be unlinked.
-            with open(gdal_cpl_log_path, "r+") as logfile:
-                logfile.truncate(0)  # size '0' necessary when using r+
-            try:
-                gdal_cpl_log_path.unlink(missing_ok=True)
-            except Exception:
-                pass
-
-    return True
-
-
-def _prepare_gdal_options(options: dict, split_by_option_type: bool = False) -> dict:
-    """
-    Prepares the options so they are ready to pass on to gdal.
-
-        - Uppercase the option key
-        - Check if the option types are on of the supported ones:
-
-            - LAYER_CREATION: layer creation option (lco)
-            - DATASET_CREATION: dataset creation option (dsco)
-            - INPUT_OPEN: input dataset open option (oo)
-            - DESTINATION_OPEN: destination dataset open option (doo)
-            - CONFIG: config option (config)
-        - Prepare the option values
-            - convert bool to YES/NO
-            - convert all values to str
-
-    Args:
-        options (dict): options to pass to gdal.
-        split_by_option_type (optional, bool): True to split the options in a
-            seperate dict per option type. Defaults to False.
-
-    Returns:
-        dict: prepared options. If split_by_option_type: a dict of dicts for each
-            occuring option type.
-    """
-    # Init prepared options with all existing option types
-    option_types = [
-        "LAYER_CREATION",
-        "DATASET_CREATION",
-        "INPUT_OPEN",
-        "DESTINATION_OPEN",
-        "CONFIG",
-    ]
-    prepared_options: Dict[str, dict] = {
-        option_type: {} for option_type in option_types
-    }
-
-    # Loop through options specified to add them
-    for option, value in options.items():
-        # Prepare option type and name
-        option_type, option_name = option.split(".")
-        option_type = option_type.strip().upper()
-        option_name = option_name.strip().upper()
-        if option_type not in option_types:
-            raise ValueError(
-                f"Unsupported option type: {option_type}, not one of {option_types}"
-            )
-
-        # Prepare value
-        if isinstance(value, bool):
-            value = "YES" if value is True else "NO"
-
-        # Add to prepared options
-        if option_name in prepared_options[option_type]:
-            raise ValueError(
-                f"option {option_type}.{option_name} specified more than once"
-            )
-        prepared_options[option_type][option_name] = str(value)
-
-    # If no split is asked, convert back to original format
-    if split_by_option_type is True:
-        result = prepared_options
-    else:
-        result = {}
-        for option_type in prepared_options:
-            for option_name, value in prepared_options[option_type].items():
-                result[f"{option_type}.{option_name}"] = value
-
-    return result
-
-
-class set_config_options:
-    """
-    Context manager to set config options.
-
-    Args:
-        config_options (dict): dict with config options to set.
-            `Eg. { "OGR_SQLITE_CACHE", 128 }`
-    """
-
-    def __init__(self, config_options: dict):
-        self.config_options = config_options
-
-    def __enter__(self):
-        # TODO: uncomment if GetConfigOptions() is supported
-        # self.config_options_backup = gdal.GetConfigOptions()
-        for name, value in self.config_options.items():
-            # Prepare value
-            if value is None:
-                pass
-            elif isinstance(value, bool):
-                value = "YES" if value is True else "NO"
-            else:
-                value = str(value)
-            gdal.SetConfigOption(str(name), value)
-
-    def __exit__(self, type, value, traceback):
-        # Remove config options that were set
-        # TODO: delete loop + uncomment if SetConfigOptions() is supported
-        for name, value in self.config_options.items():
-            gdal.SetConfigOption(name, None)
-        # gdal.SetConfigOptions(self.config_options_backup)
+"""
+Module containing utilities regarding the usage of ogr/gdal functionalities.
+"""
+
+import logging
+import os
+from pathlib import Path
+import tempfile
+from threading import Lock
+from typing import Dict, List, Literal, Optional, Tuple, Union
+
+from osgeo import gdal
+from osgeo import ogr
+from pygeoops import GeometryType
+
+import geofileops as gfo
+from geofileops import fileops
+
+# Make sure only one instance per process is running
+lock = Lock()
+
+# Get a logger...
+logger = logging.getLogger(__name__)
+
+
+class GDALError(Exception):
+    """Error with extra gdal info."""
+
+    def __init__(
+        self,
+        message: str,
+        log_details: [List[str]] = [],
+        error_details: [List[str]] = [],
+    ):
+        self.message = message
+        self.log_details = log_details
+        self.error_details = error_details
+        super().__init__(self.message)
+
+    def __str__(self):
+        retstring = ""
+        if len(self.error_details) > 0:
+            retstring += "\n    GDAL CPL_LOG ERRORS"
+            retstring += "\n    -------------------"
+            retstring += "\n    "
+            retstring += "\n    ".join(self.error_details)
+        if len(self.log_details) > 0:
+            retstring += "\n    GDAL CPL_LOG ALL"
+            retstring += "\n    ----------------"
+            retstring += "\n    "
+            retstring += "\n    ".join(self.log_details)
+
+        if len(retstring) > 0:
+            return f"{retstring}\n{super().__str__()}"
+        else:
+            return super().__str__()
+
+
+ogrtype_to_geometrytype = {
+    ogr.wkbNone: None,
+    ogr.wkbUnknown: GeometryType.GEOMETRY,
+    ogr.wkbPoint: GeometryType.POINT,
+    ogr.wkbLineString: GeometryType.LINESTRING,
+    ogr.wkbPolygon: GeometryType.POLYGON,
+    ogr.wkbTriangle: GeometryType.TRIANGLE,
+    ogr.wkbMultiPoint: GeometryType.MULTIPOINT,
+    ogr.wkbMultiLineString: GeometryType.MULTILINESTRING,
+    ogr.wkbMultiPolygon: GeometryType.MULTIPOLYGON,
+    ogr.wkbGeometryCollection: GeometryType.GEOMETRYCOLLECTION,
+    ogr.wkbPolyhedralSurface: GeometryType.POLYHEDRALSURFACE,
+    ogr.wkbTIN: GeometryType.TIN,
+    ogr.wkbPoint25D: GeometryType.POINTZ,
+    ogr.wkbLineString25D: GeometryType.LINESTRINGZ,
+    ogr.wkbPolygon25D: GeometryType.POLYGONZ,
+    ogr.wkbTriangleZ: GeometryType.TRIANGLEZ,
+    ogr.wkbMultiPoint25D: GeometryType.MULTIPOINTZ,
+    ogr.wkbMultiLineString25D: GeometryType.MULTILINESTRINGZ,
+    ogr.wkbMultiPolygon25D: GeometryType.MULTIPOLYGONZ,
+    ogr.wkbGeometryCollection25D: GeometryType.GEOMETRYCOLLECTIONZ,
+    ogr.wkbPolyhedralSurfaceZ: GeometryType.POLYHEDRALSURFACEZ,
+    ogr.wkbTINZ: GeometryType.TINZ,
+    ogr.wkbPointM: GeometryType.POINTM,
+    ogr.wkbLineStringM: GeometryType.LINESTRINGM,
+    ogr.wkbPolygonM: GeometryType.POLYGONM,
+    ogr.wkbTriangleM: GeometryType.TRIANGLEM,
+    ogr.wkbMultiPointM: GeometryType.MULTIPOINTM,
+    ogr.wkbMultiLineStringM: GeometryType.MULTILINESTRINGM,
+    ogr.wkbMultiPolygonM: GeometryType.MULTIPOLYGONM,
+    ogr.wkbGeometryCollectionM: GeometryType.GEOMETRYCOLLECTIONM,
+    ogr.wkbPolyhedralSurfaceM: GeometryType.POLYHEDRALSURFACEM,
+    ogr.wkbTINM: GeometryType.TINM,
+    ogr.wkbPointZM: GeometryType.POINTZM,
+    ogr.wkbLineStringZM: GeometryType.LINESTRINGZM,
+    ogr.wkbPolygonZM: GeometryType.POLYGONZM,
+    ogr.wkbTriangleZM: GeometryType.TRIANGLEZM,
+    ogr.wkbMultiPointZM: GeometryType.MULTIPOINTZM,
+    ogr.wkbMultiLineStringZM: GeometryType.MULTILINESTRINGZM,
+    ogr.wkbMultiPolygonZM: GeometryType.MULTIPOLYGONZM,
+    ogr.wkbGeometryCollectionZM: GeometryType.GEOMETRYCOLLECTIONZM,
+    ogr.wkbPolyhedralSurfaceZM: GeometryType.POLYHEDRALSURFACEZM,
+    ogr.wkbTINZM: GeometryType.TINZM,
+}
+
+
+def get_drivers() -> dict:
+    drivers = {}
+    for i in range(gdal.GetDriverCount()):
+        driver = gdal.GetDriver(i)
+        drivers[driver.ShortName] = driver.GetDescription()
+    return drivers
+
+
+def read_cpl_log(path: Path) -> Tuple[List[str], List[str]]:
+    """
+    Reads a cpl_log file and returns a list with log lines and errors.
+
+    Args:
+        path (Path): the file path to the cpl_log file.
+
+    Returns:
+        Tuple[List[str], List[str]]: tuple with a list of all log lines and a list of
+            errors.
+    """
+    if not path.exists() or path.stat().st_size == 0:
+        return ([], [])
+
+    with open(path) as logfile:
+        log_lines = logfile.readlines()
+
+    # Cleanup + check for errors
+    lines_cleaned = []
+    lines_error = []
+    for line in log_lines:
+        line = line.strip("\0\n ")
+        if line != "":
+            lines_cleaned.append(line)
+            if line.startswith("ERROR"):
+                lines_error.append(line)
+
+    return (lines_cleaned, lines_error)
+
+
+class VectorTranslateInfo:
+    def __init__(
+        self,
+        input_path: Path,
+        output_path: Path,
+        input_layers: Union[List[str], str, None] = None,
+        output_layer: Optional[str] = None,
+        input_srs: Union[int, str, None] = None,
+        output_srs: Union[int, str, None] = None,
+        reproject: bool = False,
+        spatial_filter: Optional[Tuple[float, float, float, float]] = None,
+        clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
+        sql_stmt: Optional[str] = None,
+        sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
+        where: Optional[str] = None,
+        transaction_size: int = 65536,
+        append: bool = False,
+        update: bool = False,
+        explodecollections: bool = False,
+        force_output_geometrytype: Union[GeometryType, str, None] = None,
+        options: dict = {},
+        columns: Optional[List[str]] = None,
+        warp: Optional[dict] = None,
+        preserve_fid: Optional[bool] = None,
+        dst_dimensions: Optional[str] = None,
+    ):
+        self.input_path = input_path
+        self.output_path = output_path
+        self.input_layers = input_layers
+        self.output_layer = output_layer
+        self.input_srs = input_srs
+        self.output_srs = output_srs
+        self.reproject = reproject
+        self.spatial_filter = spatial_filter
+        self.clip_geometry = clip_geometry
+        self.sql_stmt = sql_stmt
+        self.sql_dialect = sql_dialect
+        self.where = where
+        self.transaction_size = transaction_size
+        self.append = append
+        self.update = update
+        self.explodecollections = explodecollections
+        self.force_output_geometrytype = force_output_geometrytype
+        self.options = options
+        self.columns = columns
+        self.warp = warp
+        self.preserve_fid = preserve_fid
+        self.dst_dimensions = dst_dimensions
+
+
+def vector_translate_by_info(info: VectorTranslateInfo):
+    return vector_translate(
+        input_path=info.input_path,
+        output_path=info.output_path,
+        input_layers=info.input_layers,
+        output_layer=info.output_layer,
+        input_srs=info.input_srs,
+        output_srs=info.output_srs,
+        reproject=info.reproject,
+        spatial_filter=info.spatial_filter,
+        clip_geometry=info.clip_geometry,
+        sql_stmt=info.sql_stmt,
+        sql_dialect=info.sql_dialect,
+        where=info.where,
+        transaction_size=info.transaction_size,
+        append=info.append,
+        update=info.update,
+        explodecollections=info.explodecollections,
+        force_output_geometrytype=info.force_output_geometrytype,
+        options=info.options,
+        columns=info.columns,
+        warp=info.warp,
+        preserve_fid=info.preserve_fid,
+        dst_dimensions=info.dst_dimensions,
+    )
+
+
+def vector_translate(
+    input_path: Union[Path, str],
+    output_path: Path,
+    input_layers: Union[List[str], str, None] = None,
+    output_layer: Optional[str] = None,
+    input_srs: Union[int, str, None] = None,
+    output_srs: Union[int, str, None] = None,
+    reproject: bool = False,
+    spatial_filter: Optional[Tuple[float, float, float, float]] = None,
+    clip_geometry: Optional[Union[Tuple[float, float, float, float], str]] = None,
+    sql_stmt: Optional[str] = None,
+    sql_dialect: Optional[Literal["SQLITE", "OGRSQL"]] = None,
+    where: Optional[str] = None,
+    transaction_size: int = 65536,
+    append: bool = False,
+    update: bool = False,
+    explodecollections: bool = False,
+    force_output_geometrytype: Union[GeometryType, str, None] = None,
+    options: dict = {},
+    columns: Optional[List[str]] = None,
+    warp: Optional[dict] = None,
+    preserve_fid: Optional[bool] = None,
+    dst_dimensions: Optional[bool] = None,
+) -> bool:
+    # API Doc of VectorTranslateOptions:
+    #   https://gdal.org/api/python/osgeo.gdal.html#osgeo.gdal.VectorTranslateOptions
+    args = []
+    if isinstance(input_path, str):
+        input_path = Path(input_path)
+    gdal_options = _prepare_gdal_options(options, split_by_option_type=True)
+
+    # Input file parameters
+    input_info = fileops._geofileinfo.get_geofileinfo(input_path)
+    # Cleanup the input_layers variable.
+    if input_info.driver == "ESRI Shapefile":
+        # For shapefiles, having input_layers not None gives issues
+        input_layers = None
+    elif sql_stmt is not None:
+        # If a sql statement is passed, the input layers are not relevant,
+        # and ogr2ogr will give a warning, so clear it.
+        input_layers = None
+    if input_layers is not None and isinstance(input_layers, str):
+        input_layers = [input_layers]
+
+    # SRS
+    if input_srs is not None and isinstance(input_srs, int):
+        input_srs = f"EPSG:{input_srs}"
+
+    # Sql'ing, Filtering, clipping
+    if sql_stmt is not None:
+        # If sql_stmt starts with "\n" or "\t" for gpkg or with " " for a shp,
+        # VectorTranslate outputs no or an invalid file if the statement doesn't return
+        # any rows...
+        sql_stmt = sql_stmt.lstrip("\n\t ")
+    if clip_geometry is not None:
+        args.extend(["-clipsrc"])
+        if isinstance(clip_geometry, str):
+            args.extend([clip_geometry])
+        else:
+            bounds = [str(coord) for coord in clip_geometry]
+            args.extend(bounds)
+    if columns is not None:
+        args.extend(["-select", ",".join(columns)])
+    if sql_stmt is not None and where is not None:
+        raise ValueError("it is not supported to specify both sql_stmt and where")
+
+    # Warp
+    if warp is not None:
+        gcps = warp.get("gcps", [])
+        for gcp in gcps:
+            args.extend(["-gcp"])
+            args.extend([str(coord) for coord in gcp if coord is not None])
+        algorithm = warp.get("algorithm", "polynomial")
+        if algorithm == "polynomial":
+            order = warp.get("order", None)
+            if order is not None:
+                args.extend(["-order", order])
+        elif algorithm == "tps":
+            args.extend(["-tps"])
+        else:
+            raise ValueError(f"unsupported warp algorithm: {algorithm}")
+
+    # Input dataset open options
+    for option_name, value in gdal_options["INPUT_OPEN"].items():
+        args.extend(["-oo", f"{option_name}={value}"])
+
+    # Output file parameters
+    # Get driver for the output_path
+    output_info = fileops._geofileinfo.get_geofileinfo(output_path)
+
+    # Shapefiles only can have one layer, and the layer name == the stem of the file
+    if output_info.driver == "ESRI Shapefile":
+        output_layer = output_path.stem
+
+    # SRS
+    if output_srs is not None and isinstance(output_srs, int):
+        output_srs = f"EPSG:{output_srs}"
+
+    # Output basic options
+    if output_path.exists() is True:
+        if append is True:
+            args.append("-append")
+        if update is True:
+            args.append("-update")
+
+    datasetCreationOptions = []
+    # Output dataset creation options are only applicable if a new output file
+    # will be created
+    if output_path.exists() is False or update is False:
+        dataset_creation_options = gdal_options["DATASET_CREATION"]
+        if output_info.driver == "SQLite":
+            # If SQLite file, use the spatialite type of sqlite by default
+            if "SPATIALITE" not in dataset_creation_options:
+                dataset_creation_options["SPATIALITE"] = "YES"
+        for option_name, value in dataset_creation_options.items():
+            datasetCreationOptions.extend([f"{option_name}={value}"])
+
+    # Output layer options
+    if explodecollections is True:
+        args.append("-explodecollections")
+    output_geometrytypes = []
+    if force_output_geometrytype is not None:
+        if isinstance(force_output_geometrytype, GeometryType):
+            output_geometrytypes.append(force_output_geometrytype.name)
+        else:
+            output_geometrytypes.append(force_output_geometrytype)
+    else:
+        if not explodecollections:
+            output_geometrytypes.append("PROMOTE_TO_MULTI")
+    if transaction_size is not None:
+        args.extend(["-gt", str(transaction_size)])
+    if preserve_fid is None:
+        if explodecollections:
+            # If explodecollections is specified, explicitly disable fid to avoid errors
+            args.append("-unsetFid")
+    else:
+        if preserve_fid:
+            args.append("-preserve_fid")
+        else:
+            args.append("-unsetFid")
+
+    # Output layer creation options are only applicable if a new layer will be
+    # created
+    layerCreationOptions = []
+    if output_path.exists() is False or (update is True and append is False):
+        for option_name, value in gdal_options["LAYER_CREATION"].items():
+            layerCreationOptions.extend([f"{option_name}={value}"])
+
+    # General configuration options
+    # Remark: passing them as parameter using --config doesn't work, but they are set as
+    # runtime config options later on (using a context manager).
+    config_options = dict(gdal_options["CONFIG"])
+    if input_info.is_spatialite_based or output_info.is_spatialite_based:
+        # If spatialite based file, increase SQLITE cache size by default
+        if "OGR_SQLITE_CACHE" not in config_options:
+            config_options["OGR_SQLITE_CACHE"] = "128"
+
+    # Have gdal throw exception on error
+    gdal.UseExceptions()
+
+    # In some cases gdal only raises the last exception instead of the stack in
+    # VectorTranslate, so you then you would lose necessary details!
+    # Solution: have gdal log everything to a file using the CPL_LOG config setting,
+    # and if an error occurs, add the contents of the log file to the exception.
+    # I also tried using gdal.ConfigurePythonLogging, but with enable_debug=True all
+    # gdal debug logging is always logged, which is quite verbose and messy, and
+    # with enable_debug=True nothing is logged. In addition, after
+    # gdal.ConfigurePythonLogging is called, the CPL_LOG config setting is ignored.
+    if "CPL_LOG" not in config_options:
+        gdal_cpl_log_dir = Path(tempfile.gettempdir()) / "geofileops/gdal_cpl_log"
+        gdal_cpl_log_dir.mkdir(parents=True, exist_ok=True)
+        fd, gdal_cpl_log_path = tempfile.mkstemp(suffix=".log", dir=gdal_cpl_log_dir)
+        os.close(fd)
+        config_options["CPL_LOG"] = gdal_cpl_log_path
+        gdal_cpl_log_path = Path(gdal_cpl_log_path)
+    else:
+        gdal_cpl_log_path = Path(config_options["CPL_LOG"])
+    if "CPL_LOG_ERRORS" not in config_options:
+        config_options["CPL_LOG_ERRORS"] = "ON"
+    if "CPL_DEBUG" not in config_options:
+        config_options["CPL_DEBUG"] = "ON"
+
+    # Now we can really get to work
+    output_ds = None
+    try:
+        # Go!
+        with set_config_options(config_options):
+            # Open input datasource already
+            input_ds = gdal.OpenEx(
+                str(input_path),
+                nOpenFlags=gdal.OF_VECTOR | gdal.OF_READONLY | gdal.OF_SHARED,
+            )
+
+            # If output_srs is not specified and the result has 0 rows, gdal creates the
+            # output file without srs.
+            # documented in https://github.com/geofileops/geofileops/issues/313
+            if output_srs is None:
+                set_output_srs = True
+                datasource_layer = None
+                if input_layers is not None and len(input_layers) == 1:
+                    datasource_layer = input_ds.GetLayer(input_layers[0])
+                else:
+                    nb_layers = input_ds.GetLayerCount()
+                    if nb_layers == 1:
+                        datasource_layer = input_ds.GetLayerByIndex(0)
+                    elif nb_layers == 0:
+                        # We never actually get here, because opening a file without
+                        # layers already gives an error.
+                        raise ValueError(f"no layers found in {input_path}")
+                    else:
+                        # If multiple layers and not explicitly specified, it is in the
+                        # sql statement so difficult to determine... so pass
+                        set_output_srs = False
+
+                if set_output_srs:
+                    # If the layer doesn't exist, return
+                    if datasource_layer is None:
+                        raise RuntimeError(
+                            f"input_layers {input_layers} not found in: {input_path}"
+                        )
+                    spatialref = datasource_layer.GetSpatialRef()
+                    if spatialref is not None:
+                        output_srs = spatialref.ExportToWkt()
+
+            # If the output is a shapefile and the input geometries are NULL, gdal
+            # creates an attribute column "geometry" in the output file. To be able to
+            # detect this case later on, check here if the input file already has an
+            # attribute column "geometry".
+            input_has_geom_attribute = False
+            input_has_geometry_attribute = False
+            input_layer = input_ds.GetLayer()
+            layer_defn = input_layer.GetLayerDefn()
+            for field_idx in range(layer_defn.GetFieldCount()):
+                field_name_lower = layer_defn.GetFieldDefn(field_idx).GetName().lower()
+                if field_name_lower == "geom":
+                    input_has_geom_attribute = True
+                elif field_name_lower == "geometry":
+                    input_has_geometry_attribute = True
+
+            # Consolidate all parameters
+            # First take copy of args, because gdal.VectorTranslateOptions adds all
+            # other parameters to the list passed (by ref)!!!
+            args_copy = list(args)
+            options = gdal.VectorTranslateOptions(
+                options=args_copy,
+                format=output_info.driver,
+                accessMode=None,
+                srcSRS=input_srs,
+                dstSRS=output_srs,
+                reproject=reproject,
+                SQLStatement=sql_stmt,
+                SQLDialect=sql_dialect,
+                where=where,
+                selectFields=None,
+                addFields=False,
+                forceNullable=False,
+                spatFilter=spatial_filter,
+                spatSRS=None,
+                datasetCreationOptions=datasetCreationOptions,
+                layerCreationOptions=layerCreationOptions,
+                layers=input_layers,
+                layerName=output_layer,
+                geometryType=output_geometrytypes,
+                dim=dst_dimensions,
+                segmentizeMaxDist=None,
+                zField=None,
+                skipFailures=False,
+                limit=None,
+                callback=None,
+                callback_data=None,
+            )
+
+            output_ds = gdal.VectorTranslate(
+                destNameOrDestDS=str(output_path), srcDS=input_ds, options=options
+            )
+
+        # If the resulting datasource is None, something went wrong
+        if output_ds is None:
+            raise RuntimeError("output_ds is None")
+
+        # Sometimes an invalid output file is written, so close and try to reopen it.
+        output_ds = None
+        if output_path.exists():
+            try:
+                output_ds = gdal.OpenEx(
+                    str(output_path), nOpenFlags=gdal.OF_VECTOR | gdal.OF_UPDATE
+                )
+
+                # If the (first) output row contains NULL as geom/geometry, gdal will
+                # add an attribute column with the name of the (alias of) the geometry
+                # column: so "geometry" or "geom".
+                # To fix this, delete the "geom" or "geometry" attribute column if
+                # present if the input file didn't have an attribute column with this
+                # name.
+                # Bug documented in https://github.com/geofileops/geofileops/issues/313
+                #
+                # Remark: this check must be done on the reopened output file because
+                # in some cases the "geometrycolumn" is incorrectly listed in the field
+                # list of the Dataset returned by VectorTranslate. E.g. when the input
+                # file is empty.
+                if not input_has_geometry_attribute or not input_has_geom_attribute:
+                    assert isinstance(output_ds, gdal.Dataset)
+                    if output_layer is not None:
+                        result_layer = output_ds.GetLayer(output_layer)
+                    elif output_ds.GetLayerCount() == 1:
+                        result_layer = output_ds.GetLayerByIndex(0)
+                    else:
+                        result_layer = None
+                        logger.warning(
+                            "Unable to determine output layer, so not able to remove "
+                            "possibly incorrect geom and geometry text columns, with "
+                            f"input_path: {input_path}, output_path: {output_path}"
+                        )
+
+                    # Output layer was found, so check it
+                    if result_layer is not None:
+                        layer_defn = result_layer.GetLayerDefn()
+                        for field_idx in range(layer_defn.GetFieldCount()):
+                            name = layer_defn.GetFieldDefn(field_idx).GetName().lower()
+                            if (name == "geom" and not input_has_geom_attribute) or (
+                                name == "geometry" and not input_has_geometry_attribute
+                            ):
+                                result_layer.DeleteField(field_idx)
+                                break
+
+            except Exception as ex:
+                logger.info(
+                    f"Opening output file gave error, probably the input file was "
+                    f"empty, no rows were selected or geom was NULL: {ex}"
+                )
+                gfo.remove(output_path)
+            finally:
+                output_ds = None
+
+    except Exception as ex:
+        output_ds = None
+
+        # Prepare exception message
+        message = f"Error {ex} while creating/updating {output_path}"
+        if sql_stmt is not None:
+            message = f"{message} using sql_stmt {sql_stmt}"
+
+        # Read cpl_log file
+        log_lines, log_errors = read_cpl_log(gdal_cpl_log_path)
+
+        # Raise
+        raise GDALError(
+            message, log_details=log_lines, error_details=log_errors
+        ).with_traceback(ex.__traceback__)
+
+    finally:
+        output_ds = None
+        input_ds = None
+
+        if gdal_cpl_log_path.exists():
+            # Truncate the cpl log file already, because sometimes it is locked and
+            # cannot be unlinked.
+            with open(gdal_cpl_log_path, "r+") as logfile:
+                logfile.truncate(0)  # size '0' necessary when using r+
+            try:
+                gdal_cpl_log_path.unlink(missing_ok=True)
+            except Exception:
+                pass
+
+    return True
+
+
+def _prepare_gdal_options(options: dict, split_by_option_type: bool = False) -> dict:
+    """
+    Prepares the options so they are ready to pass on to gdal.
+
+        - Uppercase the option key
+        - Check if the option types are on of the supported ones:
+
+            - LAYER_CREATION: layer creation option (lco)
+            - DATASET_CREATION: dataset creation option (dsco)
+            - INPUT_OPEN: input dataset open option (oo)
+            - DESTINATION_OPEN: destination dataset open option (doo)
+            - CONFIG: config option (config)
+        - Prepare the option values
+            - convert bool to YES/NO
+            - convert all values to str
+
+    Args:
+        options (dict): options to pass to gdal.
+        split_by_option_type (optional, bool): True to split the options in a
+            seperate dict per option type. Defaults to False.
+
+    Returns:
+        dict: prepared options. If split_by_option_type: a dict of dicts for each
+            occuring option type.
+    """
+    # Init prepared options with all existing option types
+    option_types = [
+        "LAYER_CREATION",
+        "DATASET_CREATION",
+        "INPUT_OPEN",
+        "DESTINATION_OPEN",
+        "CONFIG",
+    ]
+    prepared_options: Dict[str, dict] = {
+        option_type: {} for option_type in option_types
+    }
+
+    # Loop through options specified to add them
+    for option, value in options.items():
+        # Prepare option type and name
+        option_type, option_name = option.split(".")
+        option_type = option_type.strip().upper()
+        option_name = option_name.strip().upper()
+        if option_type not in option_types:
+            raise ValueError(
+                f"Unsupported option type: {option_type}, not one of {option_types}"
+            )
+
+        # Prepare value
+        if isinstance(value, bool):
+            value = "YES" if value is True else "NO"
+
+        # Add to prepared options
+        if option_name in prepared_options[option_type]:
+            raise ValueError(
+                f"option {option_type}.{option_name} specified more than once"
+            )
+        prepared_options[option_type][option_name] = str(value)
+
+    # If no split is asked, convert back to original format
+    if split_by_option_type is True:
+        result = prepared_options
+    else:
+        result = {}
+        for option_type in prepared_options:
+            for option_name, value in prepared_options[option_type].items():
+                result[f"{option_type}.{option_name}"] = value
+
+    return result
+
+
+class set_config_options:
+    """
+    Context manager to set config options.
+
+    Args:
+        config_options (dict): dict with config options to set.
+            `Eg. { "OGR_SQLITE_CACHE", 128 }`
+    """
+
+    def __init__(self, config_options: dict):
+        self.config_options = config_options
+
+    def __enter__(self):
+        # TODO: uncomment if GetConfigOptions() is supported
+        # self.config_options_backup = gdal.GetConfigOptions()
+        for name, value in self.config_options.items():
+            # Prepare value
+            if value is None:
+                pass
+            elif isinstance(value, bool):
+                value = "YES" if value is True else "NO"
+            else:
+                value = str(value)
+            gdal.SetConfigOption(str(name), value)
+
+    def __exit__(self, type, value, traceback):
+        # Remove config options that were set
+        # TODO: delete loop + uncomment if SetConfigOptions() is supported
+        for name, value in self.config_options.items():
+            gdal.SetConfigOption(name, None)
+        # gdal.SetConfigOptions(self.config_options_backup)
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_processing_util.py` & `geofileops-0.8.2/geofileops/util/_processing_util.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,145 +1,145 @@
-"""
-Module containing utilities regarding processes.
-"""
-from concurrent import futures
-import os
-from typing import Optional
-import psutil
-
-
-class PooledExecutorFactory:
-    """
-    Context manager to create an Executor.
-
-    Args:
-        threadpool (bool, optional): True to get a ThreadPoolExecutor,
-            False to get a ProcessPoolExecutor. Defaults to True.
-        max_workers (int, optional): Max number of workers.
-            Defaults to None to get automatic determination.
-        initialisze (function, optional): Function that does initialisations.
-    """
-
-    def __init__(self, threadpool: bool = True, max_workers=None, initializer=None):
-        self.threadpool = threadpool
-        if max_workers is not None and os.name == "nt":
-            self.max_workers = min(max_workers, 61)
-        else:
-            self.max_workers = max_workers
-        self.initializer = initializer
-        self.pool: Optional[futures.Executor] = None
-
-    def __enter__(self) -> futures.Executor:
-        if self.threadpool:
-            self.pool = futures.ThreadPoolExecutor(
-                max_workers=self.max_workers, initializer=self.initializer
-            )
-        else:
-            self.pool = futures.ProcessPoolExecutor(
-                max_workers=self.max_workers, initializer=self.initializer
-            )
-        return self.pool
-
-    def __exit__(self, type, value, traceback):
-        if self.pool is not None:
-            self.pool.shutdown(wait=True)
-
-
-def initialize_worker():
-    # We don't want the workers to block the entire system, so make them nice
-    # if they aren't quite nice already.
-    # Remark: on linux, depending on system settings it is not possible to
-    # decrease niceness, even if it was you who niced before.
-    nice_value = 15
-    if getprocessnice() < nice_value:
-        setprocessnice(nice_value)
-
-
-def getprocessnice() -> int:
-    """
-    Get the niceness of the current process.
-
-    The nice value can (typically) range from 19, which gives all other
-    processes priority, to -20, which means that this process will take
-    maximum priority (which isn't very nice ;-)).
-
-    Remarks for windows:
-        - windows only supports 6 niceness classes. setprocessnice en
-          getprocessnice maps niceness values to these classes.
-        - when setting REALTIME priority (-20 niceness) apparently this
-          results only to HIGH priority.
-    """
-    p = psutil.Process(os.getpid())
-    nice_value = p.nice()
-    if os.name == "nt":
-        return process_priorityclass_to_nice(nice_value)
-    else:
-        return int(nice_value)
-
-
-def setprocessnice(nice_value: int):
-    """
-    Set the niceness of the current process.
-
-    The nice value can (typically) range from 19, which gives all other
-    processes priority, to -20, which means that this process will take
-    maximum priority (which isn't very nice ;-)).
-
-    Remarks for windows:
-        - windows only supports 6 niceness classes. setprocessnice en
-          getprocessnice maps niceness values to these classes.
-        - when setting REALTIME priority (-20 niceness) apparently this
-          results only to HIGH priority.
-
-    Args:
-        nice_value (int): the niceness to be set.
-    """
-    if nice_value < -20 or nice_value > 19:
-        raise ValueError(
-            f"Invalid value for nice_values (min: -20, max: 19): {nice_value}"
-        )
-    if getprocessnice() == nice_value:
-        # If the nice value is already the same... no use setting it
-        return
-
-    try:
-        p = psutil.Process(os.getpid())
-        if os.name == "nt":
-            p.nice(process_nice_to_priorityclass(nice_value))
-        else:
-            p.nice(nice_value)
-    except Exception as ex:  # pragma: no cover
-        raise RuntimeError(
-            f"Error in setprocessnice with nice_value: {nice_value}"
-        ) from ex
-
-
-def process_nice_to_priorityclass(nice_value: int) -> int:  # pragma: no cover
-    if nice_value == -20:
-        return psutil.REALTIME_PRIORITY_CLASS
-    elif nice_value <= -15:
-        return psutil.HIGH_PRIORITY_CLASS
-    elif nice_value <= -10:
-        return psutil.ABOVE_NORMAL_PRIORITY_CLASS
-    elif nice_value <= 0:
-        return psutil.NORMAL_PRIORITY_CLASS
-    elif nice_value <= 10:
-        return psutil.BELOW_NORMAL_PRIORITY_CLASS
-    else:
-        return psutil.IDLE_PRIORITY_CLASS
-
-
-def process_priorityclass_to_nice(priority_class: int) -> int:  # pragma: no cover
-    if priority_class == psutil.REALTIME_PRIORITY_CLASS:
-        return -20
-    elif priority_class == psutil.HIGH_PRIORITY_CLASS:
-        return -15
-    elif priority_class == psutil.ABOVE_NORMAL_PRIORITY_CLASS:
-        return -10
-    elif priority_class == psutil.NORMAL_PRIORITY_CLASS:
-        return 0
-    elif priority_class == psutil.BELOW_NORMAL_PRIORITY_CLASS:
-        return 10
-    elif priority_class == psutil.IDLE_PRIORITY_CLASS:
-        return 19
-    else:
-        return 0
+"""
+Module containing utilities regarding processes.
+"""
+from concurrent import futures
+import os
+from typing import Optional
+import psutil
+
+
+class PooledExecutorFactory:
+    """
+    Context manager to create an Executor.
+
+    Args:
+        threadpool (bool, optional): True to get a ThreadPoolExecutor,
+            False to get a ProcessPoolExecutor. Defaults to True.
+        max_workers (int, optional): Max number of workers.
+            Defaults to None to get automatic determination.
+        initialisze (function, optional): Function that does initialisations.
+    """
+
+    def __init__(self, threadpool: bool = True, max_workers=None, initializer=None):
+        self.threadpool = threadpool
+        if max_workers is not None and os.name == "nt":
+            self.max_workers = min(max_workers, 61)
+        else:
+            self.max_workers = max_workers
+        self.initializer = initializer
+        self.pool: Optional[futures.Executor] = None
+
+    def __enter__(self) -> futures.Executor:
+        if self.threadpool:
+            self.pool = futures.ThreadPoolExecutor(
+                max_workers=self.max_workers, initializer=self.initializer
+            )
+        else:
+            self.pool = futures.ProcessPoolExecutor(
+                max_workers=self.max_workers, initializer=self.initializer
+            )
+        return self.pool
+
+    def __exit__(self, type, value, traceback):
+        if self.pool is not None:
+            self.pool.shutdown(wait=True)
+
+
+def initialize_worker():
+    # We don't want the workers to block the entire system, so make them nice
+    # if they aren't quite nice already.
+    # Remark: on linux, depending on system settings it is not possible to
+    # decrease niceness, even if it was you who niced before.
+    nice_value = 15
+    if getprocessnice() < nice_value:
+        setprocessnice(nice_value)
+
+
+def getprocessnice() -> int:
+    """
+    Get the niceness of the current process.
+
+    The nice value can (typically) range from 19, which gives all other
+    processes priority, to -20, which means that this process will take
+    maximum priority (which isn't very nice ;-)).
+
+    Remarks for windows:
+        - windows only supports 6 niceness classes. setprocessnice en
+          getprocessnice maps niceness values to these classes.
+        - when setting REALTIME priority (-20 niceness) apparently this
+          results only to HIGH priority.
+    """
+    p = psutil.Process(os.getpid())
+    nice_value = p.nice()
+    if os.name == "nt":
+        return process_priorityclass_to_nice(nice_value)
+    else:
+        return int(nice_value)
+
+
+def setprocessnice(nice_value: int):
+    """
+    Set the niceness of the current process.
+
+    The nice value can (typically) range from 19, which gives all other
+    processes priority, to -20, which means that this process will take
+    maximum priority (which isn't very nice ;-)).
+
+    Remarks for windows:
+        - windows only supports 6 niceness classes. setprocessnice en
+          getprocessnice maps niceness values to these classes.
+        - when setting REALTIME priority (-20 niceness) apparently this
+          results only to HIGH priority.
+
+    Args:
+        nice_value (int): the niceness to be set.
+    """
+    if nice_value < -20 or nice_value > 19:
+        raise ValueError(
+            f"Invalid value for nice_values (min: -20, max: 19): {nice_value}"
+        )
+    if getprocessnice() == nice_value:
+        # If the nice value is already the same... no use setting it
+        return
+
+    try:
+        p = psutil.Process(os.getpid())
+        if os.name == "nt":
+            p.nice(process_nice_to_priorityclass(nice_value))
+        else:
+            p.nice(nice_value)
+    except Exception as ex:  # pragma: no cover
+        raise RuntimeError(
+            f"Error in setprocessnice with nice_value: {nice_value}"
+        ) from ex
+
+
+def process_nice_to_priorityclass(nice_value: int) -> int:  # pragma: no cover
+    if nice_value == -20:
+        return psutil.REALTIME_PRIORITY_CLASS
+    elif nice_value <= -15:
+        return psutil.HIGH_PRIORITY_CLASS
+    elif nice_value <= -10:
+        return psutil.ABOVE_NORMAL_PRIORITY_CLASS
+    elif nice_value <= 0:
+        return psutil.NORMAL_PRIORITY_CLASS
+    elif nice_value <= 10:
+        return psutil.BELOW_NORMAL_PRIORITY_CLASS
+    else:
+        return psutil.IDLE_PRIORITY_CLASS
+
+
+def process_priorityclass_to_nice(priority_class: int) -> int:  # pragma: no cover
+    if priority_class == psutil.REALTIME_PRIORITY_CLASS:
+        return -20
+    elif priority_class == psutil.HIGH_PRIORITY_CLASS:
+        return -15
+    elif priority_class == psutil.ABOVE_NORMAL_PRIORITY_CLASS:
+        return -10
+    elif priority_class == psutil.NORMAL_PRIORITY_CLASS:
+        return 0
+    elif priority_class == psutil.BELOW_NORMAL_PRIORITY_CLASS:
+        return 10
+    elif priority_class == psutil.IDLE_PRIORITY_CLASS:
+        return 19
+    else:
+        return 0
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_sqlite_userdefined.py` & `geofileops-0.8.2/geofileops/util/_sqlite_userdefined.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,393 +1,393 @@
-# import datetime
-import logging
-from typing import Optional
-
-import pygeoops
-import shapely
-import shapely.ops
-
-# from pygeoops import _difference as _difference
-# from pygeoops import _paramvalidation as paramvalidation
-import shapely
-
-from geofileops.util import _geoseries_util
-
-# Get a logger...
-logger = logging.getLogger(__name__)
-
-
-def gfo_difference_collection(
-    geom_wkb: bytes,
-    geom_to_subtract_wkb: bytes,
-    keep_geom_type: int = 0,
-    subdivide_coords: int = 2000,
-) -> Optional[bytes]:
-    """
-    Applies the difference of geom_to_subtract on geom.
-
-    If the input geometry has many points, they can be subdivided in smaller parts
-    to potentially speed up processing as controlled by parameter `subdivide_coords`.
-    This will result in extra collinear points being added to the boundaries of the
-    output.
-
-    Note that the geom_to_subtract_wkb won't be subdivided automatically, so if it
-    can contain complex geometries as well you can use `gfo_subdivide` on it/them.
-
-    Args:
-        geom_wkb (bytes): geometry to substract geom_to_subtract_wkb from in wkb format.
-        geom_to_subtract_wkb (bytes): geometry to substract from geom in wkb format.
-            This can be a GeometryCollection containing many other geometries.
-        keep_geom_type (int, optional): 1 to only retain geometries in the results of
-            the same geometry type/dimension as the input. Eg. if input is a Polygon,
-            remove LineStrings and Points from the difference result before returning.
-            Defaults to 0.
-        subdivide_coords (int, optional): if > 0, the input geometry will be
-            subdivided to parts with about this number of points which can speed up
-            processing for complex geometries. Subdividing can result in extra collinear
-            points being added to the boundaries of the output. If <= 0, no subdividing
-            is applied. Defaults to 2000.
-
-    Returns:
-        Optional[bytes]: return the difference. If geom was completely removed due to
-            the difference applied, NULL is returned.
-    """
-    try:
-        # Check/prepare input
-        if geom_wkb is None:
-            return None
-        if geom_to_subtract_wkb is None:
-            return geom_wkb
-        if subdivide_coords <= 0:
-            return geom_wkb
-
-        # Extract wkb's, and return if empty
-        geom = shapely.from_wkb(geom_wkb)
-        if geom.is_empty:
-            return geom_wkb
-        geoms_to_subtract = shapely.from_wkb(geom_to_subtract_wkb)
-        if geoms_to_subtract.is_empty:
-            return geom_wkb
-        del geom_wkb
-        del geom_to_subtract_wkb
-
-        # Check and convert booleanish int inputs to bool.
-        keep_geom_type = _int2bool(keep_geom_type, "keep_geom_type")
-
-    except Exception as ex:  # pragma: no cover
-        # ex.with_traceback()
-        logger.exception(f"Error in gfo_difference_collection: {ex}")
-        raise
-
-    try:
-        # Apply difference
-        result = pygeoops.difference_all_tiled(
-            geom,
-            geoms_to_subtract,
-            keep_geom_type=keep_geom_type,
-            subdivide_coords=subdivide_coords,
-        )
-
-        # If an empty result, return None
-        # Remark: tried to return empty geometry an empty GeometryCollection, but
-        # apparentle ST_IsEmpty of spatialite doesn't work (in combination with gpkg
-        # and/or wkb?).
-        if result is None or result.is_empty:
-            return None
-
-        return shapely.to_wkb(result)
-    except Exception as ex:  # pragma: no cover
-        # ex.with_traceback()
-        logger.exception(f"Error in gfo_difference_collection: {ex}")
-        return None
-
-
-def gfo_reduceprecision(geom_wkb: bytes, gridsize: int) -> Optional[bytes]:
-    """
-    Reduces the precision of the geometry to the gridsize specified.
-
-    If reducing the precison leads to a topologyerror, retries after applying make_valid
-    and returns the input if it still fails.
-
-    By default, geometries use double precision coordinates (grid_size = 0). Coordinates
-    will be rounded if a precision grid is less precise than the input geometry.
-    Duplicated vertices will be dropped from lines and polygons for grid sizes greater
-    than 0. Line and polygon geometries may collapse to empty geometries if all vertices
-    are closer together than grid_size. Z values, if present, will not be modified.
-
-    If the input geometry is found to be invalid while reducing precision, it is retried
-    after makevalid applying makevalid.
-
-    Args:
-        geom_wkb (bytes): geometry to reduce precision from in wkb format.
-        gridsize (int): the size of the grid the coordinates of the ouput will be
-            rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change the
-            precision.
-
-    Returns:
-        Optional[bytes]: return the geometry with the precision reduced.
-    """
-    try:
-        # Check/prepare input
-        if geom_wkb is None:
-            return None
-
-        # Extract wkb's, and return if empty
-        geom = shapely.from_wkb(geom_wkb)
-        if geom.is_empty:
-            return geom_wkb
-        del geom_wkb
-
-    except Exception as ex:  # pragma: no cover
-        # ex.with_traceback()
-        logger.exception(f"Error in gfo_reduceprecision: {ex}")
-        raise
-
-    try:
-        # Apply set_precision
-        result = _geoseries_util.set_precision(
-            geom, grid_size=gridsize, raise_on_topoerror=False
-        )
-
-        # If an empty result, return None
-        # Remark: apparently ST_IsEmpty of spatialite doesn't work (in combination with
-        # gpkg and/or wkb?).
-        if result is None or result.is_empty:
-            return None
-
-        return shapely.to_wkb(result)
-
-    except Exception as ex:  # pragma: no cover
-        # ex.with_traceback()
-        logger.exception(f"Error in gfo_reduceprecision: {ex}")
-        return None
-
-
-def gfo_split(
-    geom_wkb: bytes,
-    blade_wkb: bytes,
-) -> Optional[bytes]:
-    """
-    Applies a split in the geom using the blade specified.
-
-    Args:
-        geom_wkb (bytes): geometry to substract geom_to_subtract_wkb from in wkb format.
-        blade_wkb (bytes): geometry to use as a blade in wkb format.
-
-    Returns:
-        Optional[bytes]: return the geopetry split by the blade. If geom was completely
-            removed due to the split being applied, NULL is returned.
-    """
-    try:
-        # Check/prepare input
-        if geom_wkb is None:
-            return None
-        if blade_wkb is None:
-            return geom_wkb
-
-        # Extract wkb's, and return if empty
-        geom = shapely.from_wkb(geom_wkb)
-        if geom.is_empty:
-            return geom_wkb
-        blade = shapely.from_wkb(blade_wkb)
-        if blade.is_empty:
-            return geom_wkb
-        del geom_wkb
-        del blade_wkb
-
-    except Exception as ex:  # pragma: no cover
-        # ex.with_traceback()
-        logger.exception(f"Error in gfo_difference_collection: {ex}")
-        raise
-
-    try:
-        # Apply split. Only supports single geometries, so explode twice to be sure.
-        result = geom
-        output_primitivetype_id = pygeoops.get_primitivetype_id(geom)
-        for blade_part in shapely.get_parts(blade):
-            for blade_part2 in shapely.get_parts(blade_part):
-                result = shapely.ops.split(result, blade_part2)
-                result = pygeoops.collection_extract(result, output_primitivetype_id)
-
-        # If an empty result, return None
-        # Remark: tried to return empty geometry an empty GeometryCollection, but
-        # apparentle ST_IsEmpty of spatialite doesn't work (in combination with gpkg
-        # and/or wkb?).
-        if result is None or result.is_empty:
-            return None
-
-        return shapely.to_wkb(result)
-    except Exception as ex:  # pragma: no cover
-        # ex.with_traceback()
-        logger.exception(f"Error in gfo_split: {ex}")
-        return None
-
-
-def gfo_subdivide(geom_wkb: bytes, coords: int = 2000):
-    """
-    Divide the input geometry to smaller parts using rectilinear lines.
-
-    Args:
-        geom_wkb (geometry): the geometry to subdivide in wkb format.
-        coords (int): number of coordinates per subdivision to aim for. In the current
-            implementation, coords will be the average number of coordinates the
-            subdividions will consist of. If <= 0, no subdividing is applied.
-            Defaults to 2000.
-
-    Returns:
-        geometry wkb: if geometry has < coords coordinates, the input geometry is
-            returned. Otherwise the subdivisions as a GeometryCollection.
-    """
-    try:
-        # Check/prepare input
-        if geom_wkb is None:
-            return None
-        if coords <= 0:
-            return geom_wkb
-
-        # Extract wkb's, and return if empty
-        geom = shapely.from_wkb(geom_wkb)
-        if geom.is_empty:
-            return geom_wkb
-        del geom_wkb
-
-    except Exception as ex:  # pragma: no cover
-        # ex.with_traceback()
-        logger.exception(f"Error in gfo_subdivide: {ex}")
-        raise
-
-    try:
-        result = pygeoops.subdivide(geom, num_coords_max=coords)
-
-        if result is None:
-            return None
-        if not hasattr(result, "__len__"):
-            return shapely.to_wkb(result)
-        if len(result) == 1:
-            return shapely.to_wkb(result[0])
-
-        # Explode because
-        #   - they will be exploded anyway by spatialite.ST_Collect
-        #   - spatialite.ST_AsBinary and/or spatialite.ST_GeomFromWkb don't seem to
-        #     handle nested collections well.
-        return shapely.to_wkb(
-            shapely.GeometryCollection(shapely.get_parts(result).tolist())
-        )
-
-    except Exception as ex:  # pragma: no cover
-        # ex.with_traceback()
-        logger.exception(f"Error in gfo_subdivide: {ex}")
-        return None
-
-
-"""
-class DifferenceAgg:
-    def __init__(self):
-        self.init_todo = True
-        self.tmpdiff = None
-        self.is_split = False
-        self.geom_mbrp = None
-        self.keep_geom_type_dimension = None
-        self.num_coords_max = 1000
-
-        # Some properties regarding progress writing to file
-        self.enable_progress = False
-        self.step_count = 0
-        self.steps_last_progress = 0
-        self.last_progress = datetime.datetime.now()
-
-    def step(self, geom, geoms_to_subtract, keep_geom_type: int):
-        try:
-            # Init on first call
-            if self.init_todo:
-                self.init_todo = False
-                if geom is None:
-                    self.tmpdiff = None
-                geom = shapely.from_wkb(geom)
-                self.geom_mbrp = shapely.box(*geom.bounds)
-
-                # Determine type/dimension to keep
-                if keep_geom_type == 1:
-                    keep_geom_type_bool = True
-                elif keep_geom_type == 0:
-                    keep_geom_type_bool = False
-                else:
-                    raise ValueError(
-                        "Invalid value for keep_geom_type: only 0 (False) or 1 (True) "
-                        "supported."
-                    )
-                self.keep_geom_type_dimension = (
-                    paramvalidation.keep_geom_type2dimension(
-                        keep_geom_type=keep_geom_type_bool, geometry=geom
-                    )
-                )
-
-                # Split input geometry if needed
-                self.tmpdiff = pygeoops.subdivide(geom, self.num_coords_max)
-
-            # If the difference is already empty, no use to continue
-            if self.tmpdiff is None:
-                return
-
-            # Apply difference
-            geom_to_subtract = shapely.from_wkb(geoms_to_subtract)
-            self.tmpdiff = _difference._difference_intersecting(
-                self.tmpdiff,
-                geom_to_subtract,
-                keep_geom_type=self.keep_geom_type_dimension,
-            )
-
-            # Check for empty results
-            self.tmpdiff = self.tmpdiff[~shapely.is_empty(self.tmpdiff)]
-            if len(self.tmpdiff) == 0:
-                self.tmpdiff = None
-
-            # Write some progress debugging if enabled
-            if self.enable_progress:
-                self.write_progress()
-
-        except Exception as ex:
-            # ex.with_traceback()
-            print(ex)
-
-    def finalize(self):
-        try:
-            if (
-                self.tmpdiff is None
-                or len(self.tmpdiff) == 0
-                or shapely.is_empty(self.tmpdiff).all()
-            ):
-                return None
-            elif len(self.tmpdiff) == 1:
-                return shapely.to_wkb(self.tmpdiff[0])
-            else:
-                return shapely.to_wkb(shapely.unary_union(self.tmpdiff))
-
-        except Exception as ex:
-            raise ex
-
-    def write_progress(self):
-        self.step_count += 1
-        if self.step_count % 100 == 0:
-            now = datetime.datetime.now()
-            nb_steps_per_sec = (self.step_count - self.steps_last_progress) / (
-                now - self.last_progress
-            ).total_seconds()
-            with open("c:/temp/progress.txt", "a") as file:
-                file.write(f"self.progress: {self.step_count}, {nb_steps_per_sec}/s\n")
-            self.steps_last_progress = self.step_count
-            self.last_progress = now
-"""
-
-
-def _int2bool(value: int, variable_name: str) -> bool:
-    if not isinstance(value, int):
-        raise TypeError(
-            f"{variable_name} must be int (0: False or 1: True), not {type(value)}"
-        )
-    if value not in [0, 1]:
-        raise ValueError(f"{variable_name} has invalid value (0=False/1=True): {value}")
-
-    if value == 0:
-        return False
-    else:
-        return True
+# import datetime
+import logging
+from typing import Optional
+
+import pygeoops
+import shapely
+import shapely.ops
+
+# from pygeoops import _difference as _difference
+# from pygeoops import _paramvalidation as paramvalidation
+import shapely
+
+from geofileops.util import _geoseries_util
+
+# Get a logger...
+logger = logging.getLogger(__name__)
+
+
+def gfo_difference_collection(
+    geom_wkb: bytes,
+    geom_to_subtract_wkb: bytes,
+    keep_geom_type: int = 0,
+    subdivide_coords: int = 2000,
+) -> Optional[bytes]:
+    """
+    Applies the difference of geom_to_subtract on geom.
+
+    If the input geometry has many points, they can be subdivided in smaller parts
+    to potentially speed up processing as controlled by parameter `subdivide_coords`.
+    This will result in extra collinear points being added to the boundaries of the
+    output.
+
+    Note that the geom_to_subtract_wkb won't be subdivided automatically, so if it
+    can contain complex geometries as well you can use `gfo_subdivide` on it/them.
+
+    Args:
+        geom_wkb (bytes): geometry to substract geom_to_subtract_wkb from in wkb format.
+        geom_to_subtract_wkb (bytes): geometry to substract from geom in wkb format.
+            This can be a GeometryCollection containing many other geometries.
+        keep_geom_type (int, optional): 1 to only retain geometries in the results of
+            the same geometry type/dimension as the input. Eg. if input is a Polygon,
+            remove LineStrings and Points from the difference result before returning.
+            Defaults to 0.
+        subdivide_coords (int, optional): if > 0, the input geometry will be
+            subdivided to parts with about this number of points which can speed up
+            processing for complex geometries. Subdividing can result in extra collinear
+            points being added to the boundaries of the output. If <= 0, no subdividing
+            is applied. Defaults to 2000.
+
+    Returns:
+        Optional[bytes]: return the difference. If geom was completely removed due to
+            the difference applied, NULL is returned.
+    """
+    try:
+        # Check/prepare input
+        if geom_wkb is None:
+            return None
+        if geom_to_subtract_wkb is None:
+            return geom_wkb
+        if subdivide_coords <= 0:
+            return geom_wkb
+
+        # Extract wkb's, and return if empty
+        geom = shapely.from_wkb(geom_wkb)
+        if geom.is_empty:
+            return geom_wkb
+        geoms_to_subtract = shapely.from_wkb(geom_to_subtract_wkb)
+        if geoms_to_subtract.is_empty:
+            return geom_wkb
+        del geom_wkb
+        del geom_to_subtract_wkb
+
+        # Check and convert booleanish int inputs to bool.
+        keep_geom_type = _int2bool(keep_geom_type, "keep_geom_type")
+
+    except Exception as ex:  # pragma: no cover
+        # ex.with_traceback()
+        logger.exception(f"Error in gfo_difference_collection: {ex}")
+        raise
+
+    try:
+        # Apply difference
+        result = pygeoops.difference_all_tiled(
+            geom,
+            geoms_to_subtract,
+            keep_geom_type=keep_geom_type,
+            subdivide_coords=subdivide_coords,
+        )
+
+        # If an empty result, return None
+        # Remark: tried to return empty geometry an empty GeometryCollection, but
+        # apparentle ST_IsEmpty of spatialite doesn't work (in combination with gpkg
+        # and/or wkb?).
+        if result is None or result.is_empty:
+            return None
+
+        return shapely.to_wkb(result)
+    except Exception as ex:  # pragma: no cover
+        # ex.with_traceback()
+        logger.exception(f"Error in gfo_difference_collection: {ex}")
+        return None
+
+
+def gfo_reduceprecision(geom_wkb: bytes, gridsize: int) -> Optional[bytes]:
+    """
+    Reduces the precision of the geometry to the gridsize specified.
+
+    If reducing the precison leads to a topologyerror, retries after applying make_valid
+    and returns the input if it still fails.
+
+    By default, geometries use double precision coordinates (grid_size = 0). Coordinates
+    will be rounded if a precision grid is less precise than the input geometry.
+    Duplicated vertices will be dropped from lines and polygons for grid sizes greater
+    than 0. Line and polygon geometries may collapse to empty geometries if all vertices
+    are closer together than grid_size. Z values, if present, will not be modified.
+
+    If the input geometry is found to be invalid while reducing precision, it is retried
+    after makevalid applying makevalid.
+
+    Args:
+        geom_wkb (bytes): geometry to reduce precision from in wkb format.
+        gridsize (int): the size of the grid the coordinates of the ouput will be
+            rounded to. Eg. 0.001 to keep 3 decimals. Value 0.0 doesn't change the
+            precision.
+
+    Returns:
+        Optional[bytes]: return the geometry with the precision reduced.
+    """
+    try:
+        # Check/prepare input
+        if geom_wkb is None:
+            return None
+
+        # Extract wkb's, and return if empty
+        geom = shapely.from_wkb(geom_wkb)
+        if geom.is_empty:
+            return geom_wkb
+        del geom_wkb
+
+    except Exception as ex:  # pragma: no cover
+        # ex.with_traceback()
+        logger.exception(f"Error in gfo_reduceprecision: {ex}")
+        raise
+
+    try:
+        # Apply set_precision
+        result = _geoseries_util.set_precision(
+            geom, grid_size=gridsize, raise_on_topoerror=False
+        )
+
+        # If an empty result, return None
+        # Remark: apparently ST_IsEmpty of spatialite doesn't work (in combination with
+        # gpkg and/or wkb?).
+        if result is None or result.is_empty:
+            return None
+
+        return shapely.to_wkb(result)
+
+    except Exception as ex:  # pragma: no cover
+        # ex.with_traceback()
+        logger.exception(f"Error in gfo_reduceprecision: {ex}")
+        return None
+
+
+def gfo_split(
+    geom_wkb: bytes,
+    blade_wkb: bytes,
+) -> Optional[bytes]:
+    """
+    Applies a split in the geom using the blade specified.
+
+    Args:
+        geom_wkb (bytes): geometry to substract geom_to_subtract_wkb from in wkb format.
+        blade_wkb (bytes): geometry to use as a blade in wkb format.
+
+    Returns:
+        Optional[bytes]: return the geopetry split by the blade. If geom was completely
+            removed due to the split being applied, NULL is returned.
+    """
+    try:
+        # Check/prepare input
+        if geom_wkb is None:
+            return None
+        if blade_wkb is None:
+            return geom_wkb
+
+        # Extract wkb's, and return if empty
+        geom = shapely.from_wkb(geom_wkb)
+        if geom.is_empty:
+            return geom_wkb
+        blade = shapely.from_wkb(blade_wkb)
+        if blade.is_empty:
+            return geom_wkb
+        del geom_wkb
+        del blade_wkb
+
+    except Exception as ex:  # pragma: no cover
+        # ex.with_traceback()
+        logger.exception(f"Error in gfo_difference_collection: {ex}")
+        raise
+
+    try:
+        # Apply split. Only supports single geometries, so explode twice to be sure.
+        result = geom
+        output_primitivetype_id = pygeoops.get_primitivetype_id(geom)
+        for blade_part in shapely.get_parts(blade):
+            for blade_part2 in shapely.get_parts(blade_part):
+                result = shapely.ops.split(result, blade_part2)
+                result = pygeoops.collection_extract(result, output_primitivetype_id)
+
+        # If an empty result, return None
+        # Remark: tried to return empty geometry an empty GeometryCollection, but
+        # apparentle ST_IsEmpty of spatialite doesn't work (in combination with gpkg
+        # and/or wkb?).
+        if result is None or result.is_empty:
+            return None
+
+        return shapely.to_wkb(result)
+    except Exception as ex:  # pragma: no cover
+        # ex.with_traceback()
+        logger.exception(f"Error in gfo_split: {ex}")
+        return None
+
+
+def gfo_subdivide(geom_wkb: bytes, coords: int = 2000):
+    """
+    Divide the input geometry to smaller parts using rectilinear lines.
+
+    Args:
+        geom_wkb (geometry): the geometry to subdivide in wkb format.
+        coords (int): number of coordinates per subdivision to aim for. In the current
+            implementation, coords will be the average number of coordinates the
+            subdividions will consist of. If <= 0, no subdividing is applied.
+            Defaults to 2000.
+
+    Returns:
+        geometry wkb: if geometry has < coords coordinates, the input geometry is
+            returned. Otherwise the subdivisions as a GeometryCollection.
+    """
+    try:
+        # Check/prepare input
+        if geom_wkb is None:
+            return None
+        if coords <= 0:
+            return geom_wkb
+
+        # Extract wkb's, and return if empty
+        geom = shapely.from_wkb(geom_wkb)
+        if geom.is_empty:
+            return geom_wkb
+        del geom_wkb
+
+    except Exception as ex:  # pragma: no cover
+        # ex.with_traceback()
+        logger.exception(f"Error in gfo_subdivide: {ex}")
+        raise
+
+    try:
+        result = pygeoops.subdivide(geom, num_coords_max=coords)
+
+        if result is None:
+            return None
+        if not hasattr(result, "__len__"):
+            return shapely.to_wkb(result)
+        if len(result) == 1:
+            return shapely.to_wkb(result[0])
+
+        # Explode because
+        #   - they will be exploded anyway by spatialite.ST_Collect
+        #   - spatialite.ST_AsBinary and/or spatialite.ST_GeomFromWkb don't seem to
+        #     handle nested collections well.
+        return shapely.to_wkb(
+            shapely.GeometryCollection(shapely.get_parts(result).tolist())
+        )
+
+    except Exception as ex:  # pragma: no cover
+        # ex.with_traceback()
+        logger.exception(f"Error in gfo_subdivide: {ex}")
+        return None
+
+
+"""
+class DifferenceAgg:
+    def __init__(self):
+        self.init_todo = True
+        self.tmpdiff = None
+        self.is_split = False
+        self.geom_mbrp = None
+        self.keep_geom_type_dimension = None
+        self.num_coords_max = 1000
+
+        # Some properties regarding progress writing to file
+        self.enable_progress = False
+        self.step_count = 0
+        self.steps_last_progress = 0
+        self.last_progress = datetime.datetime.now()
+
+    def step(self, geom, geoms_to_subtract, keep_geom_type: int):
+        try:
+            # Init on first call
+            if self.init_todo:
+                self.init_todo = False
+                if geom is None:
+                    self.tmpdiff = None
+                geom = shapely.from_wkb(geom)
+                self.geom_mbrp = shapely.box(*geom.bounds)
+
+                # Determine type/dimension to keep
+                if keep_geom_type == 1:
+                    keep_geom_type_bool = True
+                elif keep_geom_type == 0:
+                    keep_geom_type_bool = False
+                else:
+                    raise ValueError(
+                        "Invalid value for keep_geom_type: only 0 (False) or 1 (True) "
+                        "supported."
+                    )
+                self.keep_geom_type_dimension = (
+                    paramvalidation.keep_geom_type2dimension(
+                        keep_geom_type=keep_geom_type_bool, geometry=geom
+                    )
+                )
+
+                # Split input geometry if needed
+                self.tmpdiff = pygeoops.subdivide(geom, self.num_coords_max)
+
+            # If the difference is already empty, no use to continue
+            if self.tmpdiff is None:
+                return
+
+            # Apply difference
+            geom_to_subtract = shapely.from_wkb(geoms_to_subtract)
+            self.tmpdiff = _difference._difference_intersecting(
+                self.tmpdiff,
+                geom_to_subtract,
+                keep_geom_type=self.keep_geom_type_dimension,
+            )
+
+            # Check for empty results
+            self.tmpdiff = self.tmpdiff[~shapely.is_empty(self.tmpdiff)]
+            if len(self.tmpdiff) == 0:
+                self.tmpdiff = None
+
+            # Write some progress debugging if enabled
+            if self.enable_progress:
+                self.write_progress()
+
+        except Exception as ex:
+            # ex.with_traceback()
+            print(ex)
+
+    def finalize(self):
+        try:
+            if (
+                self.tmpdiff is None
+                or len(self.tmpdiff) == 0
+                or shapely.is_empty(self.tmpdiff).all()
+            ):
+                return None
+            elif len(self.tmpdiff) == 1:
+                return shapely.to_wkb(self.tmpdiff[0])
+            else:
+                return shapely.to_wkb(shapely.unary_union(self.tmpdiff))
+
+        except Exception as ex:
+            raise ex
+
+    def write_progress(self):
+        self.step_count += 1
+        if self.step_count % 100 == 0:
+            now = datetime.datetime.now()
+            nb_steps_per_sec = (self.step_count - self.steps_last_progress) / (
+                now - self.last_progress
+            ).total_seconds()
+            with open("c:/temp/progress.txt", "a") as file:
+                file.write(f"self.progress: {self.step_count}, {nb_steps_per_sec}/s\n")
+            self.steps_last_progress = self.step_count
+            self.last_progress = now
+"""
+
+
+def _int2bool(value: int, variable_name: str) -> bool:
+    if not isinstance(value, int):
+        raise TypeError(
+            f"{variable_name} must be int (0: False or 1: True), not {type(value)}"
+        )
+    if value not in [0, 1]:
+        raise ValueError(f"{variable_name} has invalid value (0=False/1=True): {value}")
+
+    if value == 0:
+        return False
+    else:
+        return True
```

### Comparing `geofileops-0.8.1a0/geofileops/util/_sqlite_util.py` & `geofileops-0.8.2/geofileops/util/_sqlite_util.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,715 +1,715 @@
-"""
-Module containing utilities regarding sqlite/spatialite files.
-"""
-
-import datetime
-import enum
-import logging
-from pathlib import Path
-import pprint
-import shutil
-import sqlite3
-import tempfile
-from typing import Dict, List, Optional, Union
-
-import geofileops as gfo
-from geofileops import GeometryType
-from geofileops.util._general_util import MissingRuntimeDependencyError
-from geofileops.util import _sqlite_userdefined as sqlite_userdefined
-
-# Get a logger...
-logger = logging.getLogger(__name__)
-
-
-class EmptyResultError(Exception):
-    """
-    Exception raised when the SQL statement disn't return any rows.
-
-    Attributes:
-        message (str): Exception message
-    """
-
-    def __init__(self, message):
-        self.message = message
-        super().__init__(self.message)
-
-
-def spatialite_version_info() -> Dict[str, str]:
-    """
-    Returns the versions of the spatialite modules.
-
-    Versions returned: spatialite_version, geos_version.
-
-    Raises:
-        RuntimeError: if a runtime dependency is not available.
-
-    Returns:
-        Dict[str, str]: a dict with the version of the runtime dependencies.
-    """
-    test_path = Path(__file__).resolve().parent / "test.gpkg"
-    conn = sqlite3.connect(test_path)
-    try:
-        load_spatialite(conn)
-        sql = "SELECT spatialite_version(), geos_version()"
-        result = conn.execute(sql).fetchall()
-        spatialite_version = result[0][0]
-        geos_version = result[0][1]
-    except MissingRuntimeDependencyError:
-        conn.rollback()
-        raise
-    except Exception as ex:
-        conn.rollback()
-        raise RuntimeError(f"Error {ex} executing {sql}") from ex
-    finally:
-        conn.close()
-
-    versions = {
-        "spatialite_version": spatialite_version,
-        "geos_version": geos_version,
-    }
-    return versions
-
-
-class SqliteProfile(enum.Enum):
-    DEFAULT = 0
-    SPEED = 1
-
-
-def create_new_spatialdb(path: Path, crs_epsg: Optional[int] = None):
-    # Connect to sqlite
-    conn = sqlite3.connect(path)
-    sql = None
-    try:
-        with conn:
-            load_spatialite(conn)
-
-            # Init file
-            output_suffix_lower = path.suffix.lower()
-            if output_suffix_lower == ".gpkg":
-                sql = "SELECT EnableGpkgMode();"
-                # sql = 'SELECT EnableGpkgAmphibiousMode();'
-                conn.execute(sql)
-                # Remark: this only works on the main database!
-                sql = "SELECT gpkgCreateBaseTables();"
-                conn.execute(sql)
-                if crs_epsg is not None and crs_epsg not in [0, -1, 4326]:
-                    sql = f"SELECT gpkgInsertEpsgSRID({crs_epsg})"
-                    conn.execute(sql)
-
-                # If they are present, remove triggers that were removed from the gpkg
-                # spec because of issues but apparently weren't removed in spatialite.
-                # https://github.com/opengeospatial/geopackage/pull/240
-                sql = "DROP TRIGGER gpkg_metadata_reference_row_id_value_insert;"
-                try:
-                    conn.execute(sql)
-                except Exception:  # pragma: no cover
-                    pass
-                sql = "DROP TRIGGER gpkg_metadata_reference_row_id_value_update;"
-                try:
-                    conn.execute(sql)
-                except Exception:  # pragma: no cover
-                    pass
-
-            elif output_suffix_lower == ".sqlite":
-                sql = "SELECT InitSpatialMetaData(1);"
-                conn.execute(sql)
-                if crs_epsg is not None and crs_epsg not in [0, -1, 4326]:
-                    sql = f"SELECT InsertEpsgSrid({crs_epsg})"
-                    conn.execute(sql)
-            else:
-                raise Exception(f"Unsupported output format: {output_suffix_lower}")
-
-    except Exception as ex:
-        raise Exception(f"Error creating spatial db {path}") from ex
-    finally:
-        conn.close()
-
-
-def get_columns(
-    sql_stmt: str,
-    input1_path: Path,
-    input2_path: Optional[Path] = None,
-    empty_output_ok: bool = True,
-    use_spatialite: bool = True,
-    output_geometrytype: Optional[GeometryType] = None,
-) -> Dict[str, str]:
-    # Create temp output db to be sure the output DB is writable, even though we only
-    # create a temporary table.
-    tmp_dir = Path(tempfile.mkdtemp(prefix="geofileops/get_columns_"))
-    tmp_path = tmp_dir / f"temp{input1_path.suffix}"
-    create_new_spatialdb(path=tmp_path)
-
-    sql = None
-    conn = sqlite3.connect(tmp_path, detect_types=sqlite3.PARSE_DECLTYPES)
-    try:
-        # Load spatialite if asked for
-        if use_spatialite:
-            load_spatialite(conn)
-            if tmp_path.suffix.lower() == ".gpkg":
-                sql = "SELECT EnableGpkgMode();"
-                conn.execute(sql)
-
-        # Attach to input1
-        input1_databasename = "input1"
-        sql = f"ATTACH DATABASE ? AS {input1_databasename}"
-        dbSpec = (str(input1_path),)
-        conn.execute(sql, dbSpec)
-
-        # If input2 isn't the same database input1, attach to it
-        input2_databasename = None
-        if input2_path is not None:
-            if input2_path == input1_path:
-                input2_databasename = input1_databasename
-            else:
-                input2_databasename = "input2"
-                sql = f"ATTACH DATABASE ? AS {input2_databasename}"
-                dbSpec = (str(input2_path),)
-                conn.execute(sql, dbSpec)
-
-        # Prepare sql statement for execute
-        sql_stmt_prepared = sql_stmt.format(
-            input1_databasename=input1_databasename,
-            input2_databasename=input2_databasename,
-            batch_filter="",
-        )
-
-        # Log explain plan if debug logging enabled.
-        if logger.isEnabledFor(logging.DEBUG):
-            sql = f"""
-                EXPLAIN QUERY PLAN
-                SELECT * FROM (
-                  {sql_stmt_prepared}
-                );
-            """
-            cur = conn.execute(sql)
-            plan = cur.fetchall()
-            cur.close()
-            logger.debug(pprint.pformat(plan))
-
-        # Create temp table to get the column names + general data types
-        # + fetch one row to use it to determine geometrytype.
-        # Remark: specify redundant OFFSET 0 to keep sqlite from flattings the subquery.
-        sql = f"""
-            CREATE TEMPORARY TABLE tmp AS
-            SELECT *
-              FROM (
-                {sql_stmt_prepared}
-              )
-             LIMIT 1 OFFSET 0;
-        """
-        conn.execute(sql)
-        conn.commit()
-        sql = "PRAGMA TABLE_INFO(tmp)"
-        cur = conn.execute(sql)
-        tmpcolumns = cur.fetchall()
-        cur.close()
-
-        # Fetch one row to try to get more detailed data types if needed
-        sql = "SELECT * FROM tmp"
-        tmpdata = conn.execute(sql).fetchone()
-        if tmpdata is not None and len(tmpdata) == 0:
-            tmpdata = None
-        if not empty_output_ok and tmpdata is None:
-            # If no row was returned, stop
-            raise EmptyResultError(f"Query didn't return any rows: {sql_stmt}")
-
-        # Loop over all columns to determine the data type
-        columns = {}
-        for column_index, column in enumerate(tmpcolumns):
-            columnname = column[1]
-            columntype = column[2]
-
-            if columnname == "geom":
-                # PRAGMA TABLE_INFO gives None as column type for a
-                # geometry column. So if output_geometrytype not specified,
-                # Use ST_GeometryType to get the type
-                # based on the data + apply to_multitype to be sure
-                if output_geometrytype is None:
-                    sql = f"SELECT ST_GeometryType({columnname}) FROM tmp;"
-                    result = conn.execute(sql).fetchall()
-                    if len(result) > 0 and result[0][0] is not None:
-                        output_geometrytype = GeometryType[result[0][0]].to_multitype
-                    else:
-                        output_geometrytype = GeometryType["GEOMETRY"]
-                columns[columnname] = output_geometrytype.name
-            else:
-                # If PRAGMA TABLE_INFO doesn't specify the datatype, determine based
-                # on data.
-                if columntype is None or columntype == "":
-                    sql = f"SELECT typeof({columnname}) FROM tmp;"
-                    result = conn.execute(sql).fetchall()
-                    if len(result) > 0 and result[0][0] is not None:
-                        columns[columnname] = result[0][0]
-                    else:
-                        # If unknown, take the most general types
-                        columns[columnname] = "NUMERIC"
-                elif columntype == "NUM":
-                    # PRAGMA TABLE_INFO sometimes returns 'NUM', but apparently this
-                    # cannot be used in "CREATE TABLE".
-                    if tmpdata is None:
-                        columns[columnname] = "NUMERIC"
-                    elif isinstance(tmpdata[column_index], datetime.date):
-                        columns[columnname] = "DATE"
-                    elif isinstance(tmpdata[column_index], datetime.datetime):
-                        columns[columnname] = "DATETIME"
-                    elif isinstance(tmpdata[column_index], str):
-                        sql = f'SELECT datetime("{columnname}") FROM tmp;'
-                        result = conn.execute(sql).fetchall()
-                        if len(result) > 0 and result[0][0] is not None:
-                            columns[columnname] = "DATETIME"
-                        else:
-                            columns[columnname] = "NUMERIC"
-                    else:
-                        columns[columnname] = "NUMERIC"
-                else:
-                    columns[columnname] = columntype
-
-    except Exception as ex:
-        conn.rollback()
-        raise RuntimeError(f"Error {ex} executing {sql}") from ex
-    finally:
-        conn.close()
-        shutil.rmtree(tmp_dir, ignore_errors=True)
-
-    return columns
-
-
-def create_table_as_sql(
-    input1_path: Path,
-    input1_layer: str,
-    input2_path: Path,
-    input2_layer: str,
-    output_path: Path,
-    sql_stmt: str,
-    output_layer: str,
-    output_geometrytype: Optional[GeometryType],
-    append: bool = False,
-    update: bool = False,
-    create_spatial_index: bool = True,
-    empty_output_ok: bool = True,
-    column_datatypes: Optional[dict] = None,
-    profile: SqliteProfile = SqliteProfile.DEFAULT,
-):
-    """
-    Execute sql statement and save the result in the output file.
-
-    Args:
-        input1_path (Path): the path to the 1st input file.
-        input1_layer (str): the layer/table to select from in het 1st input file
-        input2_path (Path): the path to the 2nd input file.
-        input2_layer (str): the layer/table to select from in het 2nd input file
-        output_path (Path): the path where the output file needs to be created/appended.
-        sql_stmt (str): SELECT statement to run on the input files.
-        output_layer (str): layer/table name to use.
-        output_geometrytype (Optional[GeometryType]): geometry type of the output.
-        append (bool, optional): True to append to an existing file. Defaults to False.
-        update (bool, optional): True to append to an existing layer. Defaults to False.
-        create_spatial_index (bool, optional): True to create a spatial index on the
-            output layer. Defaults to True.
-        empty_output_ok (bool, optional): If the sql_stmt doesn't return any rows and
-            True, create an empty output file. If False, throw EmptyResultError.
-            Defaults to True.
-        column_datatypes (dict, optional): Can be used to specify the data types of
-            columns in the form of {"columnname": "datatype"}. If the data type of
-            (some) columns is not specified, it it automatically determined as good as
-            possible. Defaults to None.
-        profile (SqliteProfile, optional): the set of PRAGMA's to use when creating the
-            table. SqliteProfile.DEFAULT will use default setting. SqliteProfile.SPEED
-            uses settings optimized for speed, but will be less save regarding
-            transaction safety,...
-            Defaults to SqliteProfile.DEFAULT.
-
-    Raises:
-        ValueError: invalid (combinations of) parameters passed.
-        EmptyResultError: the sql_stmt didn't return any rows.
-    """
-    # Check input parameters
-    if append is True or update is True:
-        raise ValueError("append=True nor update=True are implemented.")
-    output_suffix_lower = output_path.suffix.lower()
-    if output_suffix_lower != input1_path.suffix.lower():
-        raise ValueError("output_path and both input paths must have the same suffix!")
-    if input2_path is not None and output_suffix_lower != input2_path.suffix.lower():
-        raise ValueError("output_path and both input paths must have the same suffix!")
-
-    # Check if crs are the same in the input layers + use it (if there is one)
-    input1_info = gfo.get_layerinfo(input1_path, input1_layer, raise_on_nogeom=False)
-    input2_info = None
-    if input2_path is not None:
-        input2_info = gfo.get_layerinfo(
-            input2_path, input2_layer, raise_on_nogeom=False
-        )
-    crs_epsg = -1
-    if input1_info.crs is not None:
-        crs_epsg1 = input1_info.crs.to_epsg()
-        if crs_epsg1 is not None:
-            crs_epsg = crs_epsg1
-        # If input 2 also has a crs, check if it is the same.
-        if (
-            input2_info is not None
-            and input2_info.crs is not None
-            and crs_epsg1 != input2_info.crs.to_epsg()
-        ):
-            logger.warning(
-                "input1 layer doesn't have the same crs as input2 layer: "
-                f"{input1_info.crs} vs {input2_info.crs}"
-            )
-    elif input2_info is not None and input2_info.crs is not None:
-        crs_epsg2 = input2_info.crs.to_epsg()
-        if crs_epsg2 is not None:
-            crs_epsg = crs_epsg2
-
-    # If output file doesn't exist yet, create and init it
-    if not output_path.exists():
-        create_new_spatialdb(path=output_path, crs_epsg=crs_epsg)
-
-    sql = None
-    conn = sqlite3.connect(output_path, detect_types=sqlite3.PARSE_DECLTYPES, uri=True)
-    try:
-        with conn:
-
-            def to_string_for_sql(input) -> str:
-                if input is None:
-                    return "NULL"
-                else:
-                    return str(input)
-
-            # Connect to output database file so it is main, otherwise the
-            # gpkg... functions don't work
-            # Remark: sql statements using knn only work if they are main, so they
-            # are executed with ogr, as the output needs to be main as well :-(.
-            output_databasename = "main"
-            load_spatialite(conn)
-
-            if output_suffix_lower == ".gpkg":
-                sql = "SELECT EnableGpkgMode();"
-                conn.execute(sql)
-
-            # Set cache size to 128 MB (in kibibytes)
-            sql = "PRAGMA cache_size=-128000;"
-            conn.execute(sql)
-            # Set temp storage to MEMORY
-            sql = "PRAGMA temp_store=2;"
-            conn.execute(sql)
-            # Set soft heap limit to 1 GB (in bytes)
-            sql = f"PRAGMA soft_heap_limit={1024*1024*1024};"
-            conn.execute(sql)
-
-            # If attach to input1
-            input1_databasename = "input1"
-            sql = f"ATTACH DATABASE ? AS {input1_databasename}"
-            dbSpec = (str(input1_path),)
-            # input1_uri = f"file:{input1_path}?immutable=1"
-            # dbSpec = (str(input1_uri),)
-            conn.execute(sql, dbSpec)
-
-            # If input2 isn't the same database input1, attach to it
-            input2_databasename = None
-            if input2_path is not None:
-                if input2_path == input1_path:
-                    input2_databasename = input1_databasename
-                else:
-                    input2_databasename = "input2"
-                    sql = f"ATTACH DATABASE ? AS {input2_databasename}"
-                    dbSpec = (str(input2_path),)
-                    # input2_uri = f"file:{input1_path}?immutable=1"
-                    # dbSpec = (str(input2_uri),)
-                    conn.execute(sql, dbSpec)
-
-            # Use the sqlite profile specified
-            if profile is SqliteProfile.SPEED:
-                # Use memory mapped IO: much faster for calculations
-                # (max 30GB)
-                conn.execute("PRAGMA mmap_size=30000000000;")
-
-                # These options don't really make a difference on windows, but
-                # it doesn't hurt and maybe on other platforms...
-                for databasename in [
-                    output_databasename,
-                    input1_databasename,
-                    input2_databasename,
-                ]:
-                    conn.execute(f"PRAGMA {databasename}.journal_mode=OFF;")
-
-                    # These pragma's increase speed
-                    conn.execute(f"PRAGMA {databasename}.locking_mode=EXCLUSIVE;")
-                    conn.execute(f"PRAGMA {databasename}.synchronous=OFF;")
-
-            # Determine columns/datatypes to create the table if not specified
-            column_types = column_datatypes
-            if column_types is None:
-                column_types = get_columns(
-                    sql_stmt=sql_stmt,
-                    input1_path=input1_path,
-                    input2_path=input2_path,
-                    empty_output_ok=empty_output_ok,
-                    use_spatialite=True,
-                    output_geometrytype=output_geometrytype,
-                )
-
-            # If geometry type was not specified, look for it in column_types
-            if output_geometrytype is None and "geom" in column_types:
-                output_geometrytype = GeometryType(column_types["geom"])
-
-            # Prepare sql statement
-            sql_stmt = sql_stmt.format(
-                input1_databasename=input1_databasename,
-                input2_databasename=input2_databasename,
-            )
-
-            # Now we can create the table
-            # Create output table using the gpkgAddGeometryColumn() function
-            # Problem: the spatialite function gpkgAddGeometryColumn() doesn't support
-            # layer names with special characters (eg. '-')...
-            # Solution: mimic the behaviour of gpkgAddGeometryColumn manually.
-            # Create table without geom column
-            """
-            columns_for_create = [
-                f'"{columnname}" {column_types[columnname]}\n' for columnname
-                in column_types if columnname != 'geom'
-            ]
-            sql = (
-                f'CREATE TABLE {output_databasename}."{output_layer}" '
-                f'({", ".join(columns_for_create)})'
-            )
-            conn.execute(sql)
-            # Add geom column with gpkgAddGeometryColumn()
-            # Remark: output_geometrytype.name should be detemined from data if needed,
-            # see above...
-            sql = (
-                f"SELECT gpkgAddGeometryColumn("
-                f"    '{output_layer}', 'geom', '{output_geometrytype.name}', 0, 0, "
-                f"    {to_string_for_sql(crs_epsg)});"
-            conn.execute(sql)
-            """
-            columns_for_create = [
-                f'"{columnname}" {column_types[columnname]}\n'
-                for columnname in column_types
-                if columnname.lower() != "fid"
-            ]
-            sql = f"""
-                CREATE TABLE {output_databasename}."{output_layer}" (
-                    fid INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
-                    {", ".join(columns_for_create)}
-                )
-            """
-            conn.execute(sql)
-
-            # Add metadata
-            if output_suffix_lower == ".gpkg":
-                data_type = "features" if "geom" in column_types else "attributes"
-
-                # ~ mimic behaviour of gpkgAddGeometryColumn()
-                sql = f"""
-                    INSERT INTO {output_databasename}.gpkg_contents (
-                        table_name, data_type, identifier, description, last_change,
-                        min_x, min_y, max_x, max_y, srs_id)
-                    VALUES ('{output_layer}', '{data_type}', NULL, '', DATETIME(),
-                        NULL, NULL, NULL, NULL, {to_string_for_sql(crs_epsg)});
-                """
-                conn.execute(sql)
-
-                # If there is a geometry column, register it
-                if "geom" in column_types:
-                    sql = f"""
-                        INSERT INTO {output_databasename}.gpkg_geometry_columns (
-                            table_name, column_name, geometry_type_name, srs_id, z, m)
-                        VALUES ('{output_layer}', 'geom', '{output_geometrytype.name}',
-                            {to_string_for_sql(crs_epsg)}, 0, 0);
-                    """
-                    conn.execute(sql)
-
-                    # Now add geom triggers
-                    # Remark: this only works on the main database!
-                    sql = f"SELECT gpkgAddGeometryTriggers('{output_layer}', 'geom');"
-                    conn.execute(sql)
-            elif output_suffix_lower == ".sqlite":
-                # Create geom metadata if there is one
-                if "geom" in column_types:
-                    sql = f"""
-                        SELECT RecoverGeometryColumn(
-                          '{output_layer}', 'geom',
-                          {to_string_for_sql(crs_epsg)}, '{output_geometrytype.name}');
-                    """
-                    conn.execute(sql)
-
-            # Insert data using the sql statement specified
-            try:
-                columns_for_insert = [f'"{column}"' for column in column_types]
-                sql = (
-                    f'INSERT INTO {output_databasename}."{output_layer}" '
-                    f'({", ".join(columns_for_insert)})\n{sql_stmt}'
-                )
-                conn.execute(sql)
-
-            except Exception as ex:
-                ex_message = str(ex).lower()
-                if ex_message.startswith(
-                    "unique constraint failed:"
-                ) and ex_message.endswith(".fid"):
-                    ex.args = (
-                        f"{ex}: avoid this by not selecting or aliasing fid "
-                        '("select * will select fid!)',
-                    )
-                raise
-
-            # Create spatial index if needed
-            if "geom" in column_types and create_spatial_index is True:
-                sql = f"SELECT UpdateLayerStatistics('{output_layer}', 'geom');"
-                conn.execute(sql)
-                if output_suffix_lower == ".gpkg":
-                    # Create the necessary empty index, triggers,...
-                    sql = f"SELECT gpkgAddSpatialIndex('{output_layer}', 'geom');"
-                    conn.execute(sql)
-                    # Now fill the index
-                    sql = f"""
-                        INSERT INTO "rtree_{output_layer}_geom"
-                          SELECT fid
-                                ,ST_MinX(geom)
-                                ,ST_MaxX(geom)
-                                ,ST_MinY(geom)
-                                ,ST_MaxY(geom)
-                            FROM "{output_layer}"
-                           WHERE geom IS NOT NULL
-                             AND NOT ST_IsEmpty(geom)
-                    """
-                    conn.execute(sql)
-                elif output_suffix_lower == ".sqlite":
-                    sql = f"SELECT CreateSpatialIndex('{output_layer}', 'geom');"
-                    conn.execute(sql)
-            conn.commit()
-
-    except EmptyResultError:
-        logger.info(f"Query didn't return any rows: {sql_stmt}")
-        conn.close()
-        if output_path.exists():
-            output_path.unlink()
-    except Exception as ex:
-        raise RuntimeError(f"Error {ex} executing {sql}") from ex
-    finally:
-        if conn is not None:
-            conn.close()
-
-
-def execute_sql(
-    path: Path, sql_stmt: Union[str, List[str]], use_spatialite: bool = True
-):
-    # Connect to database file
-    conn = sqlite3.connect(path)
-    sql = None
-
-    try:
-        if use_spatialite is True:
-            load_spatialite(conn)
-            if path.suffix.lower() == ".gpkg":
-                sql = "SELECT EnableGpkgMode();"
-                conn.execute(sql)
-
-        """
-        # Set nb KB of cache
-        sql = "PRAGMA cache_size=-50000;"
-        conn.execute(sql)
-        sql = "PRAGMA temp_store=MEMORY;"
-        conn.execute(sql)
-        conn.execute("PRAGMA journal_mode = WAL")
-        """
-        if isinstance(sql_stmt, str):
-            sql = sql_stmt
-            conn.execute(sql)
-        else:
-            for sql in sql_stmt:
-                conn.execute(sql)
-        conn.commit()
-
-    except Exception as ex:
-        conn.rollback()
-        raise Exception(f"Error executing {sql}") from ex
-    finally:
-        conn.close()
-
-
-def test_data_integrity(path: Path, use_spatialite: bool = True):
-    # Get list of layers in database
-    layers = gfo.listlayers(path=path)
-
-    # Connect to database file
-    conn = sqlite3.connect(path, detect_types=sqlite3.PARSE_DECLTYPES)
-    sql = None
-
-    try:
-        if use_spatialite is True:
-            load_spatialite(conn)
-        if path.suffix.lower() == ".gpkg":
-            sql = "SELECT EnableGpkgMode();"
-            conn.execute(sql)
-
-        # Set nb KB of cache
-        sql = "PRAGMA cache_size=-50000;"
-        conn.execute(sql)
-        # Use memory mapped IO = much faster (max 30GB)
-        conn.execute("PRAGMA mmap_size=30000000000;")
-
-        # Loop over all layers to check if all data is readable
-        for layer in layers:
-            sql = f'SELECT * FROM "{layer}"'
-            cursor = conn.execute(sql)
-
-            # Fetch the data in chunks to avoid excessive memory usage
-            while True:
-                result = cursor.fetchmany(10000)
-                if not result:
-                    # All data was fetched from layer
-                    break
-
-    except Exception as ex:
-        raise Exception(f"Error executing {sql}") from ex
-    finally:
-        conn.close()
-
-
-def load_spatialite(conn):
-    """
-    Load mod_spatialite for an existing sqlite connection.
-
-    Args:
-        conn ([type]): Sqlite connection
-    """
-    conn.enable_load_extension(True)
-    try:
-        conn.load_extension("mod_spatialite")
-    except Exception as ex:  # pragma: no cover
-        raise MissingRuntimeDependencyError(
-            "Error trying to load mod_spatialite."
-        ) from ex
-
-    # Register custom functions
-    conn.create_function(
-        "GFO_Difference_Collection",
-        -1,
-        sqlite_userdefined.gfo_difference_collection,
-        deterministic=True,
-    )
-
-    conn.create_function(
-        "GFO_ReducePrecision",
-        -1,
-        sqlite_userdefined.gfo_reduceprecision,
-        deterministic=True,
-    )
-
-    conn.create_function(
-        "GFO_Split",
-        -1,
-        sqlite_userdefined.gfo_split,
-        deterministic=True,
-    )
-
-    conn.create_function(
-        "GFO_Subdivide",
-        -1,
-        sqlite_userdefined.gfo_subdivide,
-        deterministic=True,
-    )
-
-    # Register custom aggregate function
-    # conn.create_aggregate("GFO_Difference_Agg", 3, userdefined.DifferenceAgg)
+"""
+Module containing utilities regarding sqlite/spatialite files.
+"""
+
+import datetime
+import enum
+import logging
+from pathlib import Path
+import pprint
+import shutil
+import sqlite3
+import tempfile
+from typing import Dict, List, Optional, Union
+
+import geofileops as gfo
+from geofileops import GeometryType
+from geofileops.util._general_util import MissingRuntimeDependencyError
+from geofileops.util import _sqlite_userdefined as sqlite_userdefined
+
+# Get a logger...
+logger = logging.getLogger(__name__)
+
+
+class EmptyResultError(Exception):
+    """
+    Exception raised when the SQL statement disn't return any rows.
+
+    Attributes:
+        message (str): Exception message
+    """
+
+    def __init__(self, message):
+        self.message = message
+        super().__init__(self.message)
+
+
+def spatialite_version_info() -> Dict[str, str]:
+    """
+    Returns the versions of the spatialite modules.
+
+    Versions returned: spatialite_version, geos_version.
+
+    Raises:
+        RuntimeError: if a runtime dependency is not available.
+
+    Returns:
+        Dict[str, str]: a dict with the version of the runtime dependencies.
+    """
+    test_path = Path(__file__).resolve().parent / "test.gpkg"
+    conn = sqlite3.connect(test_path)
+    try:
+        load_spatialite(conn)
+        sql = "SELECT spatialite_version(), geos_version()"
+        result = conn.execute(sql).fetchall()
+        spatialite_version = result[0][0]
+        geos_version = result[0][1]
+    except MissingRuntimeDependencyError:
+        conn.rollback()
+        raise
+    except Exception as ex:
+        conn.rollback()
+        raise RuntimeError(f"Error {ex} executing {sql}") from ex
+    finally:
+        conn.close()
+
+    versions = {
+        "spatialite_version": spatialite_version,
+        "geos_version": geos_version,
+    }
+    return versions
+
+
+class SqliteProfile(enum.Enum):
+    DEFAULT = 0
+    SPEED = 1
+
+
+def create_new_spatialdb(path: Path, crs_epsg: Optional[int] = None):
+    # Connect to sqlite
+    conn = sqlite3.connect(path)
+    sql = None
+    try:
+        with conn:
+            load_spatialite(conn)
+
+            # Init file
+            output_suffix_lower = path.suffix.lower()
+            if output_suffix_lower == ".gpkg":
+                sql = "SELECT EnableGpkgMode();"
+                # sql = 'SELECT EnableGpkgAmphibiousMode();'
+                conn.execute(sql)
+                # Remark: this only works on the main database!
+                sql = "SELECT gpkgCreateBaseTables();"
+                conn.execute(sql)
+                if crs_epsg is not None and crs_epsg not in [0, -1, 4326]:
+                    sql = f"SELECT gpkgInsertEpsgSRID({crs_epsg})"
+                    conn.execute(sql)
+
+                # If they are present, remove triggers that were removed from the gpkg
+                # spec because of issues but apparently weren't removed in spatialite.
+                # https://github.com/opengeospatial/geopackage/pull/240
+                sql = "DROP TRIGGER gpkg_metadata_reference_row_id_value_insert;"
+                try:
+                    conn.execute(sql)
+                except Exception:  # pragma: no cover
+                    pass
+                sql = "DROP TRIGGER gpkg_metadata_reference_row_id_value_update;"
+                try:
+                    conn.execute(sql)
+                except Exception:  # pragma: no cover
+                    pass
+
+            elif output_suffix_lower == ".sqlite":
+                sql = "SELECT InitSpatialMetaData(1);"
+                conn.execute(sql)
+                if crs_epsg is not None and crs_epsg not in [0, -1, 4326]:
+                    sql = f"SELECT InsertEpsgSrid({crs_epsg})"
+                    conn.execute(sql)
+            else:
+                raise Exception(f"Unsupported output format: {output_suffix_lower}")
+
+    except Exception as ex:
+        raise Exception(f"Error creating spatial db {path}") from ex
+    finally:
+        conn.close()
+
+
+def get_columns(
+    sql_stmt: str,
+    input1_path: Path,
+    input2_path: Optional[Path] = None,
+    empty_output_ok: bool = True,
+    use_spatialite: bool = True,
+    output_geometrytype: Optional[GeometryType] = None,
+) -> Dict[str, str]:
+    # Create temp output db to be sure the output DB is writable, even though we only
+    # create a temporary table.
+    tmp_dir = Path(tempfile.mkdtemp(prefix="geofileops/get_columns_"))
+    tmp_path = tmp_dir / f"temp{input1_path.suffix}"
+    create_new_spatialdb(path=tmp_path)
+
+    sql = None
+    conn = sqlite3.connect(tmp_path, detect_types=sqlite3.PARSE_DECLTYPES)
+    try:
+        # Load spatialite if asked for
+        if use_spatialite:
+            load_spatialite(conn)
+            if tmp_path.suffix.lower() == ".gpkg":
+                sql = "SELECT EnableGpkgMode();"
+                conn.execute(sql)
+
+        # Attach to input1
+        input1_databasename = "input1"
+        sql = f"ATTACH DATABASE ? AS {input1_databasename}"
+        dbSpec = (str(input1_path),)
+        conn.execute(sql, dbSpec)
+
+        # If input2 isn't the same database input1, attach to it
+        input2_databasename = None
+        if input2_path is not None:
+            if input2_path == input1_path:
+                input2_databasename = input1_databasename
+            else:
+                input2_databasename = "input2"
+                sql = f"ATTACH DATABASE ? AS {input2_databasename}"
+                dbSpec = (str(input2_path),)
+                conn.execute(sql, dbSpec)
+
+        # Prepare sql statement for execute
+        sql_stmt_prepared = sql_stmt.format(
+            input1_databasename=input1_databasename,
+            input2_databasename=input2_databasename,
+            batch_filter="",
+        )
+
+        # Log explain plan if debug logging enabled.
+        if logger.isEnabledFor(logging.DEBUG):
+            sql = f"""
+                EXPLAIN QUERY PLAN
+                SELECT * FROM (
+                  {sql_stmt_prepared}
+                );
+            """
+            cur = conn.execute(sql)
+            plan = cur.fetchall()
+            cur.close()
+            logger.debug(pprint.pformat(plan))
+
+        # Create temp table to get the column names + general data types
+        # + fetch one row to use it to determine geometrytype.
+        # Remark: specify redundant OFFSET 0 to keep sqlite from flattings the subquery.
+        sql = f"""
+            CREATE TEMPORARY TABLE tmp AS
+            SELECT *
+              FROM (
+                {sql_stmt_prepared}
+              )
+             LIMIT 1 OFFSET 0;
+        """
+        conn.execute(sql)
+        conn.commit()
+        sql = "PRAGMA TABLE_INFO(tmp)"
+        cur = conn.execute(sql)
+        tmpcolumns = cur.fetchall()
+        cur.close()
+
+        # Fetch one row to try to get more detailed data types if needed
+        sql = "SELECT * FROM tmp"
+        tmpdata = conn.execute(sql).fetchone()
+        if tmpdata is not None and len(tmpdata) == 0:
+            tmpdata = None
+        if not empty_output_ok and tmpdata is None:
+            # If no row was returned, stop
+            raise EmptyResultError(f"Query didn't return any rows: {sql_stmt}")
+
+        # Loop over all columns to determine the data type
+        columns = {}
+        for column_index, column in enumerate(tmpcolumns):
+            columnname = column[1]
+            columntype = column[2]
+
+            if columnname == "geom":
+                # PRAGMA TABLE_INFO gives None as column type for a
+                # geometry column. So if output_geometrytype not specified,
+                # Use ST_GeometryType to get the type
+                # based on the data + apply to_multitype to be sure
+                if output_geometrytype is None:
+                    sql = f'SELECT ST_GeometryType("{columnname}") FROM tmp;'
+                    result = conn.execute(sql).fetchall()
+                    if len(result) > 0 and result[0][0] is not None:
+                        output_geometrytype = GeometryType[result[0][0]].to_multitype
+                    else:
+                        output_geometrytype = GeometryType["GEOMETRY"]
+                columns[columnname] = output_geometrytype.name
+            else:
+                # If PRAGMA TABLE_INFO doesn't specify the datatype, determine based
+                # on data.
+                if columntype is None or columntype == "":
+                    sql = f'SELECT typeof("{columnname}") FROM tmp;'
+                    result = conn.execute(sql).fetchall()
+                    if len(result) > 0 and result[0][0] is not None:
+                        columns[columnname] = result[0][0]
+                    else:
+                        # If unknown, take the most general types
+                        columns[columnname] = "NUMERIC"
+                elif columntype == "NUM":
+                    # PRAGMA TABLE_INFO sometimes returns 'NUM', but apparently this
+                    # cannot be used in "CREATE TABLE".
+                    if tmpdata is None:
+                        columns[columnname] = "NUMERIC"
+                    elif isinstance(tmpdata[column_index], datetime.date):
+                        columns[columnname] = "DATE"
+                    elif isinstance(tmpdata[column_index], datetime.datetime):
+                        columns[columnname] = "DATETIME"
+                    elif isinstance(tmpdata[column_index], str):
+                        sql = f'SELECT datetime("{columnname}") FROM tmp;'
+                        result = conn.execute(sql).fetchall()
+                        if len(result) > 0 and result[0][0] is not None:
+                            columns[columnname] = "DATETIME"
+                        else:
+                            columns[columnname] = "NUMERIC"
+                    else:
+                        columns[columnname] = "NUMERIC"
+                else:
+                    columns[columnname] = columntype
+
+    except Exception as ex:
+        conn.rollback()
+        raise RuntimeError(f"Error {ex} executing {sql}") from ex
+    finally:
+        conn.close()
+        shutil.rmtree(tmp_dir, ignore_errors=True)
+
+    return columns
+
+
+def create_table_as_sql(
+    input1_path: Path,
+    input1_layer: str,
+    input2_path: Path,
+    input2_layer: str,
+    output_path: Path,
+    sql_stmt: str,
+    output_layer: str,
+    output_geometrytype: Optional[GeometryType],
+    append: bool = False,
+    update: bool = False,
+    create_spatial_index: bool = True,
+    empty_output_ok: bool = True,
+    column_datatypes: Optional[dict] = None,
+    profile: SqliteProfile = SqliteProfile.DEFAULT,
+):
+    """
+    Execute sql statement and save the result in the output file.
+
+    Args:
+        input1_path (Path): the path to the 1st input file.
+        input1_layer (str): the layer/table to select from in het 1st input file
+        input2_path (Path): the path to the 2nd input file.
+        input2_layer (str): the layer/table to select from in het 2nd input file
+        output_path (Path): the path where the output file needs to be created/appended.
+        sql_stmt (str): SELECT statement to run on the input files.
+        output_layer (str): layer/table name to use.
+        output_geometrytype (Optional[GeometryType]): geometry type of the output.
+        append (bool, optional): True to append to an existing file. Defaults to False.
+        update (bool, optional): True to append to an existing layer. Defaults to False.
+        create_spatial_index (bool, optional): True to create a spatial index on the
+            output layer. Defaults to True.
+        empty_output_ok (bool, optional): If the sql_stmt doesn't return any rows and
+            True, create an empty output file. If False, throw EmptyResultError.
+            Defaults to True.
+        column_datatypes (dict, optional): Can be used to specify the data types of
+            columns in the form of {"columnname": "datatype"}. If the data type of
+            (some) columns is not specified, it it automatically determined as good as
+            possible. Defaults to None.
+        profile (SqliteProfile, optional): the set of PRAGMA's to use when creating the
+            table. SqliteProfile.DEFAULT will use default setting. SqliteProfile.SPEED
+            uses settings optimized for speed, but will be less save regarding
+            transaction safety,...
+            Defaults to SqliteProfile.DEFAULT.
+
+    Raises:
+        ValueError: invalid (combinations of) parameters passed.
+        EmptyResultError: the sql_stmt didn't return any rows.
+    """
+    # Check input parameters
+    if append is True or update is True:
+        raise ValueError("append=True nor update=True are implemented.")
+    output_suffix_lower = output_path.suffix.lower()
+    if output_suffix_lower != input1_path.suffix.lower():
+        raise ValueError("output_path and both input paths must have the same suffix!")
+    if input2_path is not None and output_suffix_lower != input2_path.suffix.lower():
+        raise ValueError("output_path and both input paths must have the same suffix!")
+
+    # Check if crs are the same in the input layers + use it (if there is one)
+    input1_info = gfo.get_layerinfo(input1_path, input1_layer, raise_on_nogeom=False)
+    input2_info = None
+    if input2_path is not None:
+        input2_info = gfo.get_layerinfo(
+            input2_path, input2_layer, raise_on_nogeom=False
+        )
+    crs_epsg = -1
+    if input1_info.crs is not None:
+        crs_epsg1 = input1_info.crs.to_epsg()
+        if crs_epsg1 is not None:
+            crs_epsg = crs_epsg1
+        # If input 2 also has a crs, check if it is the same.
+        if (
+            input2_info is not None
+            and input2_info.crs is not None
+            and crs_epsg1 != input2_info.crs.to_epsg()
+        ):
+            logger.warning(
+                "input1 layer doesn't have the same crs as input2 layer: "
+                f"{input1_info.crs} vs {input2_info.crs}"
+            )
+    elif input2_info is not None and input2_info.crs is not None:
+        crs_epsg2 = input2_info.crs.to_epsg()
+        if crs_epsg2 is not None:
+            crs_epsg = crs_epsg2
+
+    # If output file doesn't exist yet, create and init it
+    if not output_path.exists():
+        create_new_spatialdb(path=output_path, crs_epsg=crs_epsg)
+
+    sql = None
+    conn = sqlite3.connect(output_path, detect_types=sqlite3.PARSE_DECLTYPES, uri=True)
+    try:
+        with conn:
+
+            def to_string_for_sql(input) -> str:
+                if input is None:
+                    return "NULL"
+                else:
+                    return str(input)
+
+            # Connect to output database file so it is main, otherwise the
+            # gpkg... functions don't work
+            # Remark: sql statements using knn only work if they are main, so they
+            # are executed with ogr, as the output needs to be main as well :-(.
+            output_databasename = "main"
+            load_spatialite(conn)
+
+            if output_suffix_lower == ".gpkg":
+                sql = "SELECT EnableGpkgMode();"
+                conn.execute(sql)
+
+            # Set cache size to 128 MB (in kibibytes)
+            sql = "PRAGMA cache_size=-128000;"
+            conn.execute(sql)
+            # Set temp storage to MEMORY
+            sql = "PRAGMA temp_store=2;"
+            conn.execute(sql)
+            # Set soft heap limit to 1 GB (in bytes)
+            sql = f"PRAGMA soft_heap_limit={1024*1024*1024};"
+            conn.execute(sql)
+
+            # If attach to input1
+            input1_databasename = "input1"
+            sql = f"ATTACH DATABASE ? AS {input1_databasename}"
+            dbSpec = (str(input1_path),)
+            # input1_uri = f"file:{input1_path}?immutable=1"
+            # dbSpec = (str(input1_uri),)
+            conn.execute(sql, dbSpec)
+
+            # If input2 isn't the same database input1, attach to it
+            input2_databasename = None
+            if input2_path is not None:
+                if input2_path == input1_path:
+                    input2_databasename = input1_databasename
+                else:
+                    input2_databasename = "input2"
+                    sql = f"ATTACH DATABASE ? AS {input2_databasename}"
+                    dbSpec = (str(input2_path),)
+                    # input2_uri = f"file:{input1_path}?immutable=1"
+                    # dbSpec = (str(input2_uri),)
+                    conn.execute(sql, dbSpec)
+
+            # Use the sqlite profile specified
+            if profile is SqliteProfile.SPEED:
+                # Use memory mapped IO: much faster for calculations
+                # (max 30GB)
+                conn.execute("PRAGMA mmap_size=30000000000;")
+
+                # These options don't really make a difference on windows, but
+                # it doesn't hurt and maybe on other platforms...
+                for databasename in [
+                    output_databasename,
+                    input1_databasename,
+                    input2_databasename,
+                ]:
+                    conn.execute(f"PRAGMA {databasename}.journal_mode=OFF;")
+
+                    # These pragma's increase speed
+                    conn.execute(f"PRAGMA {databasename}.locking_mode=EXCLUSIVE;")
+                    conn.execute(f"PRAGMA {databasename}.synchronous=OFF;")
+
+            # Determine columns/datatypes to create the table if not specified
+            column_types = column_datatypes
+            if column_types is None:
+                column_types = get_columns(
+                    sql_stmt=sql_stmt,
+                    input1_path=input1_path,
+                    input2_path=input2_path,
+                    empty_output_ok=empty_output_ok,
+                    use_spatialite=True,
+                    output_geometrytype=output_geometrytype,
+                )
+
+            # If geometry type was not specified, look for it in column_types
+            if output_geometrytype is None and "geom" in column_types:
+                output_geometrytype = GeometryType(column_types["geom"])
+
+            # Prepare sql statement
+            sql_stmt = sql_stmt.format(
+                input1_databasename=input1_databasename,
+                input2_databasename=input2_databasename,
+            )
+
+            # Now we can create the table
+            # Create output table using the gpkgAddGeometryColumn() function
+            # Problem: the spatialite function gpkgAddGeometryColumn() doesn't support
+            # layer names with special characters (eg. '-')...
+            # Solution: mimic the behaviour of gpkgAddGeometryColumn manually.
+            # Create table without geom column
+            """
+            columns_for_create = [
+                f'"{columnname}" {column_types[columnname]}\n' for columnname
+                in column_types if columnname != 'geom'
+            ]
+            sql = (
+                f'CREATE TABLE {output_databasename}."{output_layer}" '
+                f'({", ".join(columns_for_create)})'
+            )
+            conn.execute(sql)
+            # Add geom column with gpkgAddGeometryColumn()
+            # Remark: output_geometrytype.name should be detemined from data if needed,
+            # see above...
+            sql = (
+                f"SELECT gpkgAddGeometryColumn("
+                f"    '{output_layer}', 'geom', '{output_geometrytype.name}', 0, 0, "
+                f"    {to_string_for_sql(crs_epsg)});"
+            conn.execute(sql)
+            """
+            columns_for_create = [
+                f'"{columnname}" {column_types[columnname]}\n'
+                for columnname in column_types
+                if columnname.lower() != "fid"
+            ]
+            sql = f"""
+                CREATE TABLE {output_databasename}."{output_layer}" (
+                    fid INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
+                    {", ".join(columns_for_create)}
+                )
+            """
+            conn.execute(sql)
+
+            # Add metadata
+            if output_suffix_lower == ".gpkg":
+                data_type = "features" if "geom" in column_types else "attributes"
+
+                # ~ mimic behaviour of gpkgAddGeometryColumn()
+                sql = f"""
+                    INSERT INTO {output_databasename}.gpkg_contents (
+                        table_name, data_type, identifier, description, last_change,
+                        min_x, min_y, max_x, max_y, srs_id)
+                    VALUES ('{output_layer}', '{data_type}', NULL, '', DATETIME(),
+                        NULL, NULL, NULL, NULL, {to_string_for_sql(crs_epsg)});
+                """
+                conn.execute(sql)
+
+                # If there is a geometry column, register it
+                if "geom" in column_types:
+                    sql = f"""
+                        INSERT INTO {output_databasename}.gpkg_geometry_columns (
+                            table_name, column_name, geometry_type_name, srs_id, z, m)
+                        VALUES ('{output_layer}', 'geom', '{output_geometrytype.name}',
+                            {to_string_for_sql(crs_epsg)}, 0, 0);
+                    """
+                    conn.execute(sql)
+
+                    # Now add geom triggers
+                    # Remark: this only works on the main database!
+                    sql = f"SELECT gpkgAddGeometryTriggers('{output_layer}', 'geom');"
+                    conn.execute(sql)
+            elif output_suffix_lower == ".sqlite":
+                # Create geom metadata if there is one
+                if "geom" in column_types:
+                    sql = f"""
+                        SELECT RecoverGeometryColumn(
+                          '{output_layer}', 'geom',
+                          {to_string_for_sql(crs_epsg)}, '{output_geometrytype.name}');
+                    """
+                    conn.execute(sql)
+
+            # Insert data using the sql statement specified
+            try:
+                columns_for_insert = [f'"{column}"' for column in column_types]
+                sql = (
+                    f'INSERT INTO {output_databasename}."{output_layer}" '
+                    f'({", ".join(columns_for_insert)})\n{sql_stmt}'
+                )
+                conn.execute(sql)
+
+            except Exception as ex:
+                ex_message = str(ex).lower()
+                if ex_message.startswith(
+                    "unique constraint failed:"
+                ) and ex_message.endswith(".fid"):
+                    ex.args = (
+                        f"{ex}: avoid this by not selecting or aliasing fid "
+                        '("select * will select fid!)',
+                    )
+                raise
+
+            # Create spatial index if needed
+            if "geom" in column_types and create_spatial_index is True:
+                sql = f"SELECT UpdateLayerStatistics('{output_layer}', 'geom');"
+                conn.execute(sql)
+                if output_suffix_lower == ".gpkg":
+                    # Create the necessary empty index, triggers,...
+                    sql = f"SELECT gpkgAddSpatialIndex('{output_layer}', 'geom');"
+                    conn.execute(sql)
+                    # Now fill the index
+                    sql = f"""
+                        INSERT INTO "rtree_{output_layer}_geom"
+                          SELECT fid
+                                ,ST_MinX(geom)
+                                ,ST_MaxX(geom)
+                                ,ST_MinY(geom)
+                                ,ST_MaxY(geom)
+                            FROM "{output_layer}"
+                           WHERE geom IS NOT NULL
+                             AND ST_IsEmpty(geom) = 0
+                    """
+                    conn.execute(sql)
+                elif output_suffix_lower == ".sqlite":
+                    sql = f"SELECT CreateSpatialIndex('{output_layer}', 'geom');"
+                    conn.execute(sql)
+            conn.commit()
+
+    except EmptyResultError:
+        logger.info(f"Query didn't return any rows: {sql_stmt}")
+        conn.close()
+        if output_path.exists():
+            output_path.unlink()
+    except Exception as ex:
+        raise RuntimeError(f"Error {ex} executing {sql}") from ex
+    finally:
+        if conn is not None:
+            conn.close()
+
+
+def execute_sql(
+    path: Path, sql_stmt: Union[str, List[str]], use_spatialite: bool = True
+):
+    # Connect to database file
+    conn = sqlite3.connect(path)
+    sql = None
+
+    try:
+        if use_spatialite is True:
+            load_spatialite(conn)
+            if path.suffix.lower() == ".gpkg":
+                sql = "SELECT EnableGpkgMode();"
+                conn.execute(sql)
+
+        """
+        # Set nb KB of cache
+        sql = "PRAGMA cache_size=-50000;"
+        conn.execute(sql)
+        sql = "PRAGMA temp_store=MEMORY;"
+        conn.execute(sql)
+        conn.execute("PRAGMA journal_mode = WAL")
+        """
+        if isinstance(sql_stmt, str):
+            sql = sql_stmt
+            conn.execute(sql)
+        else:
+            for sql in sql_stmt:
+                conn.execute(sql)
+        conn.commit()
+
+    except Exception as ex:
+        conn.rollback()
+        raise Exception(f"Error executing {sql}") from ex
+    finally:
+        conn.close()
+
+
+def test_data_integrity(path: Path, use_spatialite: bool = True):
+    # Get list of layers in database
+    layers = gfo.listlayers(path=path)
+
+    # Connect to database file
+    conn = sqlite3.connect(path, detect_types=sqlite3.PARSE_DECLTYPES)
+    sql = None
+
+    try:
+        if use_spatialite is True:
+            load_spatialite(conn)
+        if path.suffix.lower() == ".gpkg":
+            sql = "SELECT EnableGpkgMode();"
+            conn.execute(sql)
+
+        # Set nb KB of cache
+        sql = "PRAGMA cache_size=-50000;"
+        conn.execute(sql)
+        # Use memory mapped IO = much faster (max 30GB)
+        conn.execute("PRAGMA mmap_size=30000000000;")
+
+        # Loop over all layers to check if all data is readable
+        for layer in layers:
+            sql = f'SELECT * FROM "{layer}"'
+            cursor = conn.execute(sql)
+
+            # Fetch the data in chunks to avoid excessive memory usage
+            while True:
+                result = cursor.fetchmany(10000)
+                if not result:
+                    # All data was fetched from layer
+                    break
+
+    except Exception as ex:
+        raise Exception(f"Error executing {sql}") from ex
+    finally:
+        conn.close()
+
+
+def load_spatialite(conn):
+    """
+    Load mod_spatialite for an existing sqlite connection.
+
+    Args:
+        conn ([type]): Sqlite connection
+    """
+    conn.enable_load_extension(True)
+    try:
+        conn.load_extension("mod_spatialite")
+    except Exception as ex:  # pragma: no cover
+        raise MissingRuntimeDependencyError(
+            "Error trying to load mod_spatialite."
+        ) from ex
+
+    # Register custom functions
+    conn.create_function(
+        "GFO_Difference_Collection",
+        -1,
+        sqlite_userdefined.gfo_difference_collection,
+        deterministic=True,
+    )
+
+    conn.create_function(
+        "GFO_ReducePrecision",
+        -1,
+        sqlite_userdefined.gfo_reduceprecision,
+        deterministic=True,
+    )
+
+    conn.create_function(
+        "GFO_Split",
+        -1,
+        sqlite_userdefined.gfo_split,
+        deterministic=True,
+    )
+
+    conn.create_function(
+        "GFO_Subdivide",
+        -1,
+        sqlite_userdefined.gfo_subdivide,
+        deterministic=True,
+    )
+
+    # Register custom aggregate function
+    # conn.create_aggregate("GFO_Difference_Agg", 3, userdefined.DifferenceAgg)
```

### Comparing `geofileops-0.8.1a0/geofileops/util/geodataframe_util.py` & `geofileops-0.8.2/geofileops/util/geodataframe_util.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-"""
-Module containing utilities regarding operations on geoseries.
-"""
-
-import logging
-
-import geopandas as gpd
-
-#####################################################################
-# First define/init some general variables/constants
-#####################################################################
-
-# Get a logger...
-logger = logging.getLogger(__name__)
-# logger.setLevel(logging.DEBUG)
-
-#####################################################################
-# GeoDataFrame helpers
-#####################################################################
-
-
-def sort_values(gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
-    """
-    Sort the values in the GeoDataFrame by the values in all columns.
-
-    For the geometry column, it is first converted to it's WKT.
-
-    Args:
-        gdf (gpd.GeoDataFrame): the input GeoDataFrame.
-
-    Returns:
-        gpd.GeoDataFrame: the result with sorted values.
-    """
-    result_gdf = gdf.copy()
-    result_gdf["tmp_sort_geometry_wkt"] = result_gdf.geometry.to_wkt()
-    columns_no_geom = [
-        str(column) for column in result_gdf.columns if column != "geometry"
-    ]
-    result_gdf = result_gdf.sort_values(by=columns_no_geom)
-    result_gdf = result_gdf.drop(columns="tmp_sort_geometry_wkt")
-
-    assert isinstance(result_gdf, gpd.GeoDataFrame)
-    return result_gdf
+"""
+Module containing utilities regarding operations on geoseries.
+"""
+
+import logging
+
+import geopandas as gpd
+
+#####################################################################
+# First define/init some general variables/constants
+#####################################################################
+
+# Get a logger...
+logger = logging.getLogger(__name__)
+# logger.setLevel(logging.DEBUG)
+
+#####################################################################
+# GeoDataFrame helpers
+#####################################################################
+
+
+def sort_values(gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
+    """
+    Sort the values in the GeoDataFrame by the values in all columns.
+
+    For the geometry column, it is first converted to it's WKT.
+
+    Args:
+        gdf (gpd.GeoDataFrame): the input GeoDataFrame.
+
+    Returns:
+        gpd.GeoDataFrame: the result with sorted values.
+    """
+    result_gdf = gdf.copy()
+    result_gdf["tmp_sort_geometry_wkt"] = result_gdf.geometry.to_wkt()
+    columns_no_geom = [
+        str(column) for column in result_gdf.columns if column != "geometry"
+    ]
+    result_gdf = result_gdf.sort_values(by=columns_no_geom)
+    result_gdf = result_gdf.drop(columns="tmp_sort_geometry_wkt")
+
+    assert isinstance(result_gdf, gpd.GeoDataFrame)
+    return result_gdf
```

### Comparing `geofileops-0.8.1a0/geofileops/util/geofiletypes.csv` & `geofileops-0.8.2/geofileops/util/geofiletypes.csv`

 * *Ordering differences only*

 * *Files 4% similar despite different names*

```diff
@@ -1,6 +1,6 @@
-geofiletype,   ogrdriver,        suffixes,              is_fid_zerobased, is_spatialite_based, suffixes_extrafiles
-ESRIShapefile, "ESRI Shapefile", "['.shp', '.dbf']",    True,             False,               "['.shp', '.dbf', '.shx', '.prj', '.qix', '.sbn', '.sbx']"
-GeoJSON,       GeoJSON,          "['.geojson']",        True,             False,               
-GPKG,          GPKG,             "['.gpkg']",           False,            True,                "['gpkg-journal']"
-SQLite,        SQLite,           "['.sqlite']",         False,            True,                
+geofiletype,   ogrdriver,        suffixes,              is_fid_zerobased, is_spatialite_based, suffixes_extrafiles
+ESRIShapefile, "ESRI Shapefile", "['.shp', '.dbf']",    True,             False,               "['.shp', '.dbf', '.shx', '.prj', '.qix', '.sbn', '.sbx']"
+GeoJSON,       GeoJSON,          "['.geojson']",        True,             False,               
+GPKG,          GPKG,             "['.gpkg']",           False,            True,                "['gpkg-journal']"
+SQLite,        SQLite,           "['.sqlite']",         False,            True,                
 FlatGeobuf,    FlatGeobuf,       "['.fgb']",            True,             False,
```

### Comparing `geofileops-0.8.1a0/geofileops/util/test.gpkg` & `geofileops-0.8.2/geofileops/util/test.gpkg`

 * *Files identical despite different names*

### Comparing `geofileops-0.8.1a0/geofileops.egg-info/PKG-INFO` & `geofileops-0.8.2/geofileops.egg-info/PKG-INFO`

 * *Files 20% similar despite different names*

```diff
@@ -1,47 +1,65 @@
-Metadata-Version: 2.1
-Name: geofileops
-Version: 0.8.1a0
-Summary: Package to do spatial operations on large geo files.
-Home-page: https://github.com/geofileops/geofileops
-Author: Pieter Roggemans
-Author-email: pieter.roggemans@gmail.com
-Classifier: Programming Language :: Python :: 3
-Classifier: Operating System :: OS Independent
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Provides-Extra: full
-License-File: LICENSE.txt
-
-# geofileops 
-
-[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
-[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
-[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
-[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
-[![DOI](https://zenodo.org/badge/203202318.svg)](https://zenodo.org/doi/10.5281/zenodo.10340100)
-
-Geofileops aims to speed up spatial analysis on large/complex vector datasets.
-
-It provides an easy to use API that can accomplish a lot with few lines of code. Most
-typical GIS operations are available: e.g. 
-[buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer), 
-[dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
-[erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
-[intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection), 
-[union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),... 
-
-The spatial operations are tested on geopackage and shapefile input files, but geopackage is recommended as it will give better performance. General [layer](https://geofileops.readthedocs.io/en/stable/reference.html#general-layer-operations) and [file operations](https://geofileops.readthedocs.io/en/stable/reference.html#general-file-operations) can be used on the file formats supported by [GDAL](https://gdal.org/).
-
-The full documentation is available on [readthedocs](https://geofileops.readthedocs.io).
-
-## Performance
-
-Different techniques are used under the hood to be able to process large files as fast as possible:
-- process data in batches
-- subdivide/merge complex geometries on the fly
-- process data in different passes
-- use all available CPUs
-
-The following chart gives an impression of the speed improvement that can be expected when processing larger files. The [benchmarks](https://github.com/geofileops/geobenchmark) ran on a Windows PC with 12 cores and include I/O.
-
-![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
+Metadata-Version: 2.1
+Name: geofileops
+Version: 0.8.2
+Summary: Python toolbox to process large vector files faster.
+Home-page: https://github.com/geofileops/geofileops
+Author: Pieter Roggemans
+Author-email: pieter.roggemans@gmail.com
+Classifier: Programming Language :: Python :: 3
+Classifier: Operating System :: OS Independent
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+License-File: LICENSE.txt
+Requires-Dist: cloudpickle
+Requires-Dist: fiona
+Requires-Dist: gdal<=3.9,>=3.6
+Requires-Dist: geopandas<1,>=0.12
+Requires-Dist: numpy
+Requires-Dist: packaging
+Requires-Dist: pandas
+Requires-Dist: psutil
+Requires-Dist: pygeoops<0.5,>=0.4
+Requires-Dist: pyogrio
+Requires-Dist: pyproj
+Requires-Dist: shapely<2.1,>=2
+Provides-Extra: full
+Requires-Dist: simplification; extra == "full"
+
+# geofileops 
+
+[![Actions Status](https://github.com/geofileops/geofileops/actions/workflows/tests.yml/badge.svg?branch=main)](https://github.com/geofileops/geofileops/actions/workflows/tests.yml?query=workflow%3ATests) 
+[![Coverage Status](https://codecov.io/gh/geofileops/geofileops/branch/main/graph/badge.svg)](https://codecov.io/gh/geofileops/geofileops)
+[![PyPI version](https://img.shields.io/pypi/v/geofileops.svg)](https://pypi.org/project/geofileops)
+[![Conda version](https://anaconda.org/conda-forge/geofileops/badges/version.svg)](https://anaconda.org/conda-forge/geofileops)
+[![DOI](https://zenodo.org/badge/203202318.svg)](https://zenodo.org/doi/10.5281/zenodo.10340100)
+
+Geofileops is a python toolbox to process large vector files faster.
+
+Most typical GIS operations are available: e.g.
+[buffer](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.buffer), 
+[dissolve](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.dissolve),
+[erase](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.erase)/difference, 
+[intersection](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.intersection), 
+[union](https://geofileops.readthedocs.io/en/stable/api/geofileops.apply.html#geofileops.union),... 
+
+The spatial operations are tested on geopackage and shapefile input files, but
+geopackage is recommended as it will give better performance. General 
+[layer](https://geofileops.readthedocs.io/en/stable/reference.html#general-layer-operations)
+and [file operations](https://geofileops.readthedocs.io/en/stable/reference.html#general-file-operations) can be used on the file formats supported by 
+[GDAL](https://gdal.org/).
+
+The full documentation is available on [readthedocs](https://geofileops.readthedocs.io).
+
+Different techniques are used under the hood to be able to process large files as fast
+as possible:
+
+* process data in batches
+* subdivide/merge complex geometries on the fly
+* process data in different passes
+* use all available CPUs
+
+The following chart gives an impression of the speed improvement that can be expected
+when processing larger files. The [benchmarks](https://github.com/geofileops/geobenchmark)
+typically use input file(s) with 500K polygons, ran on a Windows PC with 12 cores and include I/O.
+
+![Geo benchmark](https://github.com/geofileops/geobenchmark/blob/main/results_vector_ops/GeoBenchmark.png)
```

### Comparing `geofileops-0.8.1a0/setup.py` & `geofileops-0.8.2/setup.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,44 +1,44 @@
-"""
-Setup file to package geofileops.
-"""
-
-import setuptools
-
-with open("README.md") as fh:
-    long_description = fh.read()
-
-with open("geofileops/version.txt") as file:
-    version = file.readline()
-
-setuptools.setup(
-    name="geofileops",
-    version=version,
-    author="Pieter Roggemans",
-    author_email="pieter.roggemans@gmail.com",
-    description="Package to do spatial operations on large geo files.",
-    long_description=long_description,
-    long_description_content_type="text/markdown",
-    url="https://github.com/geofileops/geofileops",
-    include_package_data=True,
-    packages=setuptools.find_packages(),
-    install_requires=[
-        "cloudpickle",
-        "fiona",
-        "gdal>=3.6",
-        "geopandas>=0.12,<1",
-        "numpy",
-        "packaging",
-        "pandas",
-        "psutil",
-        "pygeoops>=0.4,<0.5",
-        "pyogrio",
-        "pyproj",
-        "shapely>=2,<2.1",
-    ],
-    extras_require={"full": ["simplification"]},
-    classifiers=[
-        "Programming Language :: Python :: 3",
-        "Operating System :: OS Independent",
-    ],
-    python_requires=">=3.8",
-)
+"""
+Setup file to package geofileops.
+"""
+
+import setuptools
+
+with open("README.md") as fh:
+    long_description = fh.read()
+
+with open("geofileops/version.txt") as file:
+    version = file.readline()
+
+setuptools.setup(
+    name="geofileops",
+    version=version,
+    author="Pieter Roggemans",
+    author_email="pieter.roggemans@gmail.com",
+    description="Python toolbox to process large vector files faster.",
+    long_description=long_description,
+    long_description_content_type="text/markdown",
+    url="https://github.com/geofileops/geofileops",
+    include_package_data=True,
+    packages=setuptools.find_packages(),
+    install_requires=[
+        "cloudpickle",
+        "fiona",
+        "gdal>=3.6,<=3.9",
+        "geopandas>=0.12,<1",
+        "numpy",
+        "packaging",
+        "pandas",
+        "psutil",
+        "pygeoops>=0.4,<0.5",
+        "pyogrio",
+        "pyproj",
+        "shapely>=2,<2.1",
+    ],
+    extras_require={"full": ["simplification"]},
+    classifiers=[
+        "Programming Language :: Python :: 3",
+        "Operating System :: OS Independent",
+    ],
+    python_requires=">=3.8",
+)
```

