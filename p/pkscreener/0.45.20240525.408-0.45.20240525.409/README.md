# Comparing `tmp/pkscreener-0.45.20240525.408-cp311-cp311-win_amd64.whl.zip` & `tmp/pkscreener-0.45.20240525.409-cp311-cp311-macosx_10_9_universal2.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,42 @@
-Zip file size: 682061 bytes, number of entries: 40
--rw-rw-rw-  2.0 fat     1582 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/__init__.py
--rw-rw-rw-  2.0 fat   791436 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/courbd.ttf
--rw-rw-rw-  2.0 fat   147505 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/globals.py
--rw-rw-rw-  2.0 fat     1092 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreener.ini
--rw-rw-rw-  2.0 fat    54099 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreenerbot.py
--rw-rw-rw-  2.0 fat    34505 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreenercli.py
--rw-rw-rw-  2.0 fat    13324 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ArtTexts.py
--rw-rw-rw-  2.0 fat    10156 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Backtest.py
--rw-rw-rw-  2.0 fat     5641 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Barometer.py
--rw-rw-rw-  2.0 fat    17333 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/CandlePatterns.py
--rw-rw-rw-  2.0 fat     1537 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Changelog.py
--rw-rw-rw-  2.0 fat    34244 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ConfigManager.py
--rw-rw-rw-  2.0 fat    10305 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Fetcher.py
--rw-rw-rw-  2.0 fat    13457 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MarketMonitor.py
--rw-rw-rw-  2.0 fat     3673 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MarketStatus.py
--rw-rw-rw-  2.0 fat    45614 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MenuOptions.py
--rw-rw-rw-  2.0 fat    12534 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/OtaUpdater.py
--rw-rw-rw-  2.0 fat    24598 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKMarketOpenCloseAnalyser.py
--rw-rw-rw-  2.0 fat    22819 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScanRunner.py
--rw-rw-rw-  2.0 fat     1623 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScheduledTaskProgress.py
--rw-rw-rw-  2.0 fat     8313 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScheduler.py
--rw-rw-rw-  2.0 fat     8466 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKSpreadsheets.py
--rw-rw-rw-  2.0 fat     1907 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKTask.py
--rw-rw-rw-  2.0 fat    18947 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Pktalib.py
--rw-rw-rw-  2.0 fat    14177 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Portfolio.py
--rw-rw-rw-  2.0 fat    49043 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PortfolioXRay.py
--rw-rw-rw-  2.0 fat   157153 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ScreeningStatistics.py
--rw-rw-rw-  2.0 fat    56940 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/StockScreener.py
--rw-rw-rw-  2.0 fat     4993 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/UserMenuChoicesHandler.py
--rw-rw-rw-  2.0 fat    86151 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Utility.py
--rw-rw-rw-  2.0 fat     3789 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/WorkflowManager.py
--rw-rw-rw-  2.0 fat       28 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/__init__.py
--rw-rw-rw-  2.0 fat     5262 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/keys.py
--rw-rw-rw-  2.0 fat     1086 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1091 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.dist-info/LICENSE-Others
--rw-rw-rw-  2.0 fat    27839 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.dist-info/METADATA
--rw-rw-rw-  2.0 fat      102 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.dist-info/WHEEL
--rw-rw-rw-  2.0 fat      120 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       11 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     5031 b- defN 24-May-25 14:08 pkscreener-0.45.20240525.408.dist-info/RECORD
-40 files, 1697526 bytes uncompressed, 673425 bytes compressed:  60.3%
+Zip file size: 681188 bytes, number of entries: 40
+-rw-r--r--  2.0 unx     1547 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/__init__.py
+-rw-r--r--  2.0 unx   791436 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/courbd.ttf
+-rw-r--r--  2.0 unx   144558 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/globals.py
+-rw-r--r--  2.0 unx     1055 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreener.ini
+-rw-r--r--  2.0 unx    52903 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreenerbot.py
+-rw-r--r--  2.0 unx    33692 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreenercli.py
+-rw-r--r--  2.0 unx    13194 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ArtTexts.py
+-rw-r--r--  2.0 unx     9908 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Backtest.py
+-rw-r--r--  2.0 unx     5537 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Barometer.py
+-rw-r--r--  2.0 unx    16986 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/CandlePatterns.py
+-rw-r--r--  2.0 unx     1494 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Changelog.py
+-rw-r--r--  2.0 unx    33644 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ConfigManager.py
+-rw-r--r--  2.0 unx    10050 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Fetcher.py
+-rw-r--r--  2.0 unx    13213 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MarketMonitor.py
+-rw-r--r--  2.0 unx     3591 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MarketStatus.py
+-rw-r--r--  2.0 unx    44414 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MenuOptions.py
+-rw-r--r--  2.0 unx    12232 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/OtaUpdater.py
+-rw-r--r--  2.0 unx    24198 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKMarketOpenCloseAnalyser.py
+-rw-r--r--  2.0 unx    22357 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScanRunner.py
+-rw-r--r--  2.0 unx     1588 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScheduledTaskProgress.py
+-rw-r--r--  2.0 unx     8143 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScheduler.py
+-rw-r--r--  2.0 unx     8298 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKSpreadsheets.py
+-rw-r--r--  2.0 unx     1867 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKTask.py
+-rw-r--r--  2.0 unx    18470 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Pktalib.py
+-rw-r--r--  2.0 unx    13876 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Portfolio.py
+-rw-r--r--  2.0 unx    47779 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PortfolioXRay.py
+-rw-r--r--  2.0 unx   154008 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ScreeningStatistics.py
+-rw-r--r--  2.0 unx    55902 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/StockScreener.py
+-rw-r--r--  2.0 unx     4885 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/UserMenuChoicesHandler.py
+-rw-r--r--  2.0 unx    84541 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Utility.py
+-rw-r--r--  2.0 unx     3694 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/WorkflowManager.py
+-rw-r--r--  2.0 unx       28 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/__init__.py
+-rw-r--r--  2.0 unx     5122 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/keys.py
+-rw-r--r--  2.0 unx     1065 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1070 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.dist-info/LICENSE-Others
+-rw-r--r--  2.0 unx    28250 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.dist-info/METADATA
+-rw-r--r--  2.0 unx      115 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.dist-info/WHEEL
+-rw-r--r--  2.0 unx      120 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       11 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     5030 b- defN 24-May-25 14:48 pkscreener-0.45.20240525.409.dist-info/RECORD
+40 files, 1679871 bytes uncompressed, 672552 bytes compressed:  60.0%
```

## zipnote {}

```diff
@@ -1,121 +1,121 @@
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/__init__.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/__init__.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/courbd.ttf
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/courbd.ttf
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/globals.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/globals.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreener.ini
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreener.ini
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreenerbot.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreenerbot.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreenercli.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreenercli.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ArtTexts.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ArtTexts.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Backtest.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Backtest.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Barometer.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Barometer.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/CandlePatterns.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/CandlePatterns.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Changelog.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Changelog.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ConfigManager.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ConfigManager.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Fetcher.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Fetcher.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MarketMonitor.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MarketMonitor.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MarketStatus.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MarketStatus.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MenuOptions.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MenuOptions.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/OtaUpdater.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/OtaUpdater.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKMarketOpenCloseAnalyser.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKMarketOpenCloseAnalyser.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScanRunner.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScanRunner.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScheduledTaskProgress.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScheduledTaskProgress.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScheduler.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScheduler.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKSpreadsheets.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKSpreadsheets.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKTask.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKTask.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Pktalib.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Pktalib.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Portfolio.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Portfolio.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PortfolioXRay.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PortfolioXRay.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ScreeningStatistics.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ScreeningStatistics.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/StockScreener.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/StockScreener.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/UserMenuChoicesHandler.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/UserMenuChoicesHandler.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Utility.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Utility.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/WorkflowManager.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/WorkflowManager.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/__init__.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/__init__.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/keys.py
+Filename: pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/keys.py
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.dist-info/LICENSE
+Filename: pkscreener-0.45.20240525.409.dist-info/LICENSE
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.dist-info/LICENSE-Others
+Filename: pkscreener-0.45.20240525.409.dist-info/LICENSE-Others
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.dist-info/METADATA
+Filename: pkscreener-0.45.20240525.409.dist-info/METADATA
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.dist-info/WHEEL
+Filename: pkscreener-0.45.20240525.409.dist-info/WHEEL
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.dist-info/entry_points.txt
+Filename: pkscreener-0.45.20240525.409.dist-info/entry_points.txt
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.dist-info/top_level.txt
+Filename: pkscreener-0.45.20240525.409.dist-info/top_level.txt
 Comment: 
 
-Filename: pkscreener-0.45.20240525.408.dist-info/RECORD
+Filename: pkscreener-0.45.20240525.409.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/__init__.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/__init__.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-from importlib.util import find_spec
-
-Imports = {
-    "scipy": find_spec("scipy") is not None,
-    "sklearn": find_spec("sklearn") is not None,
-    "talib": find_spec("talib") is not None,
-    "pandas_ta": find_spec("pandas_ta") is not None,
-    "tensorflow": find_spec("tensorflow") is not None,
-    "keras": find_spec("keras") is not None,
-    "yfinance": find_spec("yfinance") is not None,
-}
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+from importlib.util import find_spec
+
+Imports = {
+    "scipy": find_spec("scipy") is not None,
+    "sklearn": find_spec("sklearn") is not None,
+    "talib": find_spec("talib") is not None,
+    "pandas_ta": find_spec("pandas_ta") is not None,
+    "tensorflow": find_spec("tensorflow") is not None,
+    "keras": find_spec("keras") is not None,
+    "yfinance": find_spec("yfinance") is not None,
+}
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/courbd.ttf` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/courbd.ttf`

 * *Files identical despite different names*

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/globals.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/globals.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,2947 +1,2947 @@
-#!/usr/bin/python3
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-# Keep module imports prior to classes
-import os
-import random
-import warnings
-warnings.simplefilter("ignore", UserWarning,append=True)
-os.environ["PYTHONWARNINGS"]="ignore::UserWarning"
-os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
-import logging
-import multiprocessing
-import sys
-import time
-import urllib
-import warnings
-from datetime import datetime
-from time import sleep
-
-import numpy as np
-
-warnings.simplefilter("ignore", DeprecationWarning)
-warnings.simplefilter("ignore", FutureWarning)
-import pandas as pd
-from alive_progress import alive_bar
-from PKDevTools.classes.Committer import Committer
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.PKDateUtilities import PKDateUtilities
-from PKDevTools.classes.log import default_logger #, tracelog
-from PKDevTools.classes.SuppressOutput import SuppressOutput
-from PKDevTools.classes.Telegram import (
-    is_token_telegram_configured,
-    send_document,
-    send_message,
-    send_photo
-)
-from PKNSETools.morningstartools.PKMorningstarDataFetcher import morningstarDataFetcher
-from PKNSETools.Nasdaq.PKNasdaqIndex import PKNasdaqIndexFetcher
-from tabulate import tabulate
-
-import pkscreener.classes.ConfigManager as ConfigManager
-import pkscreener.classes.Fetcher as Fetcher
-import pkscreener.classes.ScreeningStatistics as ScreeningStatistics
-import pkscreener.classes.Utility as Utility
-from pkscreener.classes.Utility import STD_ENCODING
-from pkscreener.classes import VERSION, PortfolioXRay
-from pkscreener.classes.Backtest import backtest, backtestSummary
-from pkscreener.classes.PKSpreadsheets import PKSpreadsheets
-from PKDevTools.classes.OutputControls import OutputControls
-from pkscreener.classes.MenuOptions import (
-    level0MenuDict,
-    level1_X_MenuDict,
-    level2_X_MenuDict,
-    level3_X_ChartPattern_MenuDict,
-    level3_X_PopularStocks_MenuDict,
-    level3_X_Reversal_MenuDict,
-    level4_X_Lorenzian_MenuDict,
-    level4_X_ChartPattern_Confluence_MenuDict,
-    level4_X_ChartPattern_BBands_SQZ_MenuDict,
-    menus,
-    MAX_SUPPORTED_MENU_OPTION,
-    MAX_MENU_OPTION,
-    PIPED_SCANNERS,
-    PREDEFINED_SCAN_MENU_KEYS
-)
-from pkscreener.classes.OtaUpdater import OTAUpdater
-from pkscreener.classes.Portfolio import PortfolioCollection
-from pkscreener.classes.PKTask import PKTask
-from pkscreener.classes.PKScheduler import PKScheduler
-from pkscreener.classes.PKScanRunner import PKScanRunner
-from pkscreener.classes.PKMarketOpenCloseAnalyser import PKMarketOpenCloseAnalyser
-
-if __name__ == '__main__':
-    multiprocessing.freeze_support()
-# import dataframe_image as dfi
-# import df2img
-# Try Fixing bug with this symbol
-TEST_STKCODE = "SBIN"
-# Constants
-np.seterr(divide="ignore", invalid="ignore")
-
-# Variabls
-configManager = ConfigManager.tools()
-configManager.getConfig(ConfigManager.parser)
-defaultAnswer = None
-fetcher = Fetcher.screenerStockDataFetcher(configManager)
-mstarFetcher = morningstarDataFetcher(configManager)
-keyboardInterruptEvent = None
-keyboardInterruptEventFired=False
-loadCount = 0
-loadedStockData = False
-m0 = menus()
-m1 = menus()
-m2 = menus()
-m3 = menus()
-maLength = None
-nValueForMenu = 0
-menuChoiceHierarchy = ""
-newlyListedOnly = False
-screenCounter = None
-screener = ScreeningStatistics.ScreeningStatistics(configManager, default_logger())
-screenResults = None
-backtest_df = None
-screenResultsCounter = None
-selectedChoice = {"0": "", "1": "", "2": "", "3": "", "4": ""}
-stockDictPrimary = None
-stockDictSecondary = None
-userPassedArgs = None
-elapsed_time = 0
-start_time = 0
-test_messages_queue = []
-strategyFilter=[]
-listStockCodes = None
-tasks_queue = None
-results_queue = None
-consumers = None
-logging_queue = None
-mp_manager = None
-
-def startMarketMonitor(mp_dict,keyboardevent):
-    from PKDevTools.classes.NSEMarketStatus import NSEMarketStatus
-    NSEMarketStatus(mp_dict,keyboardevent).startMarketMonitor()
-
-def finishScreening(
-    downloadOnly,
-    testing,
-    stockDictPrimary,
-    configManager,
-    loadCount,
-    testBuild,
-    screenResults,
-    saveResults,
-    user=None,
-):
-    if "RUNNER" in os.environ.keys():
-        # There's no need to prompt the user to save xls report or to save data locally.
-        # This scan must have been triggered by github workflow by a user or scheduled job
-        return
-    global defaultAnswer, menuChoiceHierarchy, userPassedArgs, selectedChoice
-    saveDownloadedData(downloadOnly, testing, stockDictPrimary, configManager, loadCount)
-    if not testBuild and not downloadOnly and not testing:
-        saveNotifyResultsFile(
-            screenResults, saveResults, defaultAnswer, menuChoiceHierarchy, user=user
-        )
-
-
-def getDownloadChoices(defaultAnswer=None):
-    global userPassedArgs
-    argsIntraday = userPassedArgs is not None and userPassedArgs.intraday is not None
-    intradayConfig = configManager.isIntradayConfig()
-    intraday = intradayConfig or argsIntraday
-    exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday)
-    if exists:
-        shouldReplace = Utility.tools.promptFileExists(
-            cache_file=cache_file, defaultAnswer=defaultAnswer
-        )
-        if shouldReplace == "N":
-            OutputControls().printOutput(
-                cache_file
-                + colorText.END
-                + " already exists. Exiting as user chose not to replace it!"
-            )
-            sys.exit(0)
-        else:
-            pattern = f"{'intraday_' if intraday else ''}stock_data_*.pkl"
-            configManager.deleteFileWithPattern(pattern)
-    return "X", 12, 0, {"0": "X", "1": "12", "2": "0"}
-
-
-def getHistoricalDays(numStocks, testing):
-    # Generally it takes 40-50 stocks to be processed every second.
-    # We would like the backtest to finish withn 10 minutes (600 seconds).
-    # days = numStocks/40 per second
-    return (
-        2 if testing else configManager.backtestPeriod
-    )  # if numStocks <= 2000 else 120 # (5 if iterations < 5 else (100 if iterations > 100 else iterations))
-
-
-def getScannerMenuChoices(
-    testBuild=False,
-    downloadOnly=False,
-    startupoptions=None,
-    menuOption=None,
-    indexOption=None,
-    executeOption=None,
-    defaultAnswer=None,
-    user=None,
-):
-    global selectedChoice
-    executeOption = executeOption
-    menuOption = menuOption
-    indexOption = indexOption
-    try:
-        if menuOption is None:
-            selectedMenu = initExecution(menuOption=menuOption)
-            menuOption = selectedMenu.menuKey
-        if menuOption in ["H", "U", "T", "E", "Y"]:
-            handleSecondaryMenuChoices(
-                menuOption, testBuild, defaultAnswer=defaultAnswer, user=user
-            )
-            Utility.tools.clearScreen(forceTop=True)
-        elif menuOption in ["X","C"]:
-            indexOption, executeOption = initPostLevel0Execution(
-                menuOption=menuOption,
-                indexOption=indexOption,
-                executeOption=executeOption,
-            )
-            indexOption, executeOption = initPostLevel1Execution(
-                indexOption=indexOption, executeOption=executeOption
-            )
-    except KeyboardInterrupt:
-        input(
-            colorText.BOLD
-            + colorText.FAIL
-            + "[+] Press <Enter> to Exit!"
-            + colorText.END
-        )
-        sys.exit(0)
-    except Exception as e:  # pragma: no cover
-        default_logger().debug(e, exc_info=True)
-    return menuOption, indexOption, executeOption, selectedChoice
-
-
-def getSummaryCorrectnessOfStrategy(resultdf, summaryRequired=True):
-    summarydf = None
-    detaildf = None
-    try:
-        if resultdf is None or len(resultdf) == 0:
-            return None, None
-        results = resultdf.copy()
-        if summaryRequired:
-            _, reportNameSummary = getBacktestReportFilename(optionalName="Summary")
-            dfs = pd.read_html(
-                "https://pkjmesra.github.io/PKScreener/Backtest-Reports/{0}".format(
-                    reportNameSummary.replace("_X_", "_B_").replace("_G_", "_B_").replace("_S_", "_B_")
-                ),encoding="UTF-8", attrs = {'id': 'resultsTable'}
-            )
-        _, reportNameDetail = getBacktestReportFilename()
-        dfd = pd.read_html(
-            "https://pkjmesra.github.io/PKScreener/Backtest-Reports/{0}".format(
-                reportNameDetail.replace("_X_", "_B_").replace("_G_", "_B_").replace("_S_", "_B_")
-            ),encoding="UTF-8", attrs = {'id': 'resultsTable'}
-        )
-
-        if summaryRequired and dfs is not None and len(dfs) > 0:
-            df = dfs[0]
-            summarydf = df[df["Stock"] == "SUMMARY"]
-            for col in summarydf.columns:
-                summarydf.loc[:, col] = summarydf.loc[:, col].apply(
-                    lambda x: Utility.tools.getFormattedBacktestSummary(
-                        x, columnName=col
-                    )
-                )
-            summarydf = summarydf.replace(np.nan, "", regex=True)
-        if dfd is not None and len(dfd) > 0:
-            df = dfd[0]
-            results.reset_index(inplace=True)
-            detaildf = df[df["Stock"].isin(results["Stock"])]
-            for col in detaildf.columns:
-                detaildf.loc[:, col] = detaildf.loc[:, col].apply(
-                    lambda x: Utility.tools.getFormattedBacktestSummary(
-                        x, pnlStats=True, columnName=col
-                    )
-                )
-            detaildf = detaildf.replace(np.nan, "", regex=True)
-            detaildf.loc[:, "Volume"] = detaildf.loc[:, "Volume"].apply(
-                lambda x: Utility.tools.formatRatio(x, configManager.volumeRatio)
-            )
-            detaildf.sort_values(
-                ["Stock", "Date"], ascending=[True, False], inplace=True
-            )
-            detaildf.rename(
-                columns={
-                    "LTP": "LTP on Date",
-                },
-                inplace=True,
-            )
-    except urllib.error.HTTPError as e:
-        if "HTTP Error 404" in str(e):
-            pass
-        else:
-            default_logger().debug(e, exc_info=True)
-    except Exception as e:# pragma: no cover
-        default_logger().debug(e, exc_info=True)
-        pass
-    return summarydf, detaildf
-
-
-def getTestBuildChoices(indexOption=None, executeOption=None, menuOption=None):
-    if menuOption is not None:
-        return (
-            str(menuOption),
-            indexOption if indexOption is not None else 1,
-            executeOption if executeOption is not None else 0,
-            {
-                "0": str(menuOption),
-                "1": (str(indexOption) if indexOption is not None else 1),
-                "2": (str(executeOption) if executeOption is not None else 0),
-            },
-        )
-    return "X", 1, 0, {"0": "X", "1": "1", "2": "0"}
-
-
-def getTopLevelMenuChoices(startupoptions, testBuild, downloadOnly, defaultAnswer=None):
-    global selectedChoice, userPassedArgs
-    executeOption = None
-    menuOption = None
-    indexOption = None
-    options = []
-    if startupoptions is not None:
-        options = startupoptions.split(":")
-        menuOption = options[0] if len(options) >= 1 else None
-        indexOption = options[1] if len(options) >= 2 else None
-        executeOption = options[2] if len(options) >= 3 else None
-    if testBuild:
-        menuOption, indexOption, executeOption, selectedChoice = getTestBuildChoices(
-            indexOption=indexOption,
-            executeOption=executeOption,
-            menuOption=menuOption,
-        )
-    elif downloadOnly:
-        menuOption, indexOption, executeOption, selectedChoice = getDownloadChoices(
-            defaultAnswer=defaultAnswer
-        )
-        intraday = userPassedArgs.intraday or configManager.isIntradayConfig()
-        filePrefix = "INTRADAY_" if intraday else ""
-        _, cache_file_name = Utility.tools.afterMarketStockDataExists(intraday)
-        Utility.tools.set_github_output(f"{filePrefix}DOWNLOAD_CACHE_FILE_NAME",cache_file_name)
-    return options, menuOption, indexOption, executeOption
-
-
-def handleScannerExecuteOption4(executeOption, options):
-    try:
-        # m2.find(str(executeOption))
-        if len(options) >= 4:
-            if str(options[3]).upper() == "D":
-                # Use a default value
-                daysForLowestVolume = 5
-            else:
-                daysForLowestVolume = int(options[3])
-        else:
-            daysForLowestVolume = int(
-                input(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + "\n[+] The Volume should be lowest since last how many candles? (Default = 5)"
-                ) or "5"
-            )
-    except ValueError as e:  # pragma: no cover
-        default_logger().debug(e, exc_info=True)
-        OutputControls().printOutput(colorText.END)
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + "[+] Error: Non-numeric value entered! Please try again!"
-            + colorText.END
-        )
-        input("Press <Enter> to continue...")
-        return
-    OutputControls().printOutput(colorText.END)
-    global nValueForMenu 
-    nValueForMenu = daysForLowestVolume
-    return daysForLowestVolume
-
-
-def handleSecondaryMenuChoices(
-    menuOption, testing=False, defaultAnswer=None, user=None
-):
-    global userPassedArgs
-    if menuOption == "H":
-        showSendHelpInfo(defaultAnswer, user)
-    elif menuOption == "U":
-        OTAUpdater.checkForUpdate(VERSION, skipDownload=testing)
-        if defaultAnswer is None:
-            input("Press <Enter> to continue...")
-    elif menuOption == "T":
-        if userPassedArgs is None or userPassedArgs.options is None:
-            selectedMenu = m0.find(menuOption)
-            m1.renderForMenu(selectedMenu=selectedMenu)
-            periodOption = input(
-                    colorText.BOLD + colorText.FAIL + "[+] Select option: "
-                ) or ('L' if configManager.period == '1y' else 'S')
-            OutputControls().printOutput(colorText.END, end="")
-            if periodOption is None or periodOption.upper() not in ["L","S"]:
-                return
-            Utility.tools.clearScreen(forceTop=True)
-            if periodOption.upper() in ["L","S"]:
-                selectedMenu = m1.find(periodOption)
-                m2.renderForMenu(selectedMenu=selectedMenu)
-                durationOption = input(
-                        colorText.BOLD + colorText.FAIL + "[+] Select option: "
-                    ) or "1"
-                OutputControls().printOutput(colorText.END, end="")
-                if durationOption is None or durationOption.upper() not in ["1","2","3","4","5"]:
-                    return
-                Utility.tools.clearScreen(forceTop=True)
-                if durationOption.upper() in ["1","2","3","4"]:
-                    selectedMenu = m2.find(durationOption)
-                    periodDurations = selectedMenu.menuText.split("(")[1].split(")")[0].split(", ")
-                    configManager.period = periodDurations[0]
-                    configManager.duration = periodDurations[1]
-                    configManager.setConfig(ConfigManager.parser, default=True, showFileCreatedText=False)
-                elif durationOption.upper() in ["5"]:
-                    configManager.setConfig(ConfigManager.parser, default=False, showFileCreatedText=True)
-                return
-        elif userPassedArgs is not None and userPassedArgs.options is not None:
-            options = userPassedArgs.options.split(":")
-            selectedMenu = m0.find(options[0])
-            m1.renderForMenu(selectedMenu=selectedMenu, asList=True)
-            selectedMenu = m1.find(options[1])
-            m2.renderForMenu(selectedMenu=selectedMenu)
-            if options[2] in ["1","2","3","4"]:
-                selectedMenu = m2.find(options[2])
-                periodDurations = selectedMenu.menuText.split("(")[1].split(")")[0].split(", ")
-                configManager.period = periodDurations[0]
-                configManager.duration = periodDurations[1]
-                configManager.setConfig(ConfigManager.parser, default=True, showFileCreatedText=False)
-            else:
-                toggleUserConfig()
-        else:
-            toggleUserConfig()
-    elif menuOption == "E":
-        configManager.setConfig(ConfigManager.parser)
-    elif menuOption == "Y":
-        showSendConfigInfo(defaultAnswer, user)
-    return
-
-def showSendConfigInfo(defaultAnswer=None, user=None):
-    configData = configManager.showConfigFile(defaultAnswer=('Y' if user is not None else defaultAnswer))
-    if user is not None:
-        sendMessageToTelegramChannel(message=Utility.tools.removeAllColorStyles(configData), user=user)
-
-def showSendHelpInfo(defaultAnswer=None, user=None):
-    helpData = Utility.tools.showDevInfo(defaultAnswer=('Y' if user is not None else defaultAnswer))
-    if user is not None:
-        sendMessageToTelegramChannel(message=Utility.tools.removeAllColorStyles(helpData), user=user)
-
-def initExecution(menuOption=None):
-    global selectedChoice, userPassedArgs
-    Utility.tools.clearScreen()
-    if (userPassedArgs is not None and userPassedArgs.pipedmenus is not None):
-        OutputControls().printOutput(
-        colorText.BOLD
-        + colorText.FAIL
-        + "[+] You chose: "
-        + f" (Piped Scan Mode) [{userPassedArgs.pipedmenus}]"
-        + colorText.END
-    )
-    m0.renderForMenu(selectedMenu=None)
-    try:
-        if menuOption is None:
-            if "PKDevTools_Default_Log_Level" in os.environ.keys():
-                from PKDevTools.classes import Archiver
-                log_file_path = os.path.join(Archiver.get_user_outputs_dir(), "pkscreener-logs.txt")
-                OutputControls().printOutput(colorText.FAIL + "\n    [+] Logs will be written to:"+colorText.END)
-                OutputControls().printOutput(colorText.GREEN + f"    [+] {log_file_path}"+colorText.END)
-                OutputControls().printOutput(colorText.FAIL + "    [+] If you need to share,run through the menus that are causing problems. At the end, open this folder, zip the log file to share at https://github.com/pkjmesra/PKScreener/issues .\n" + colorText.END)
-            menuOption = input(colorText.BOLD + colorText.FAIL + "[+] Select option: ")
-            OutputControls().printOutput(colorText.END, end="")
-        if menuOption == "" or menuOption is None:
-            menuOption = "X"
-        menuOption = menuOption.upper()
-        selectedMenu = m0.find(menuOption)
-        if selectedMenu is not None:
-            if selectedMenu.menuKey == "Z":
-                input(
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + "[+] Press <Enter> to Exit!"
-                    + colorText.END
-                )
-                sys.exit(0)
-            elif selectedMenu.menuKey in ["B", "C", "G", "H", "U", "T", "S", "E", "X", "Y", "M", "D", "I", "L"]:
-                Utility.tools.clearScreen(forceTop=True)
-                selectedChoice["0"] = selectedMenu.menuKey
-                return selectedMenu
-            elif selectedMenu.menuKey in ["P"]:
-                return selectedMenu
-    except KeyboardInterrupt:
-        raise KeyboardInterrupt
-    except Exception as e:  # pragma: no cover
-        default_logger().debug(e, exc_info=True)
-        showOptionErrorMessage()
-        return initExecution()
-
-    showOptionErrorMessage()
-    return initExecution()
-
-
-def initPostLevel0Execution(
-    menuOption=None, indexOption=None, executeOption=None, skip=[], retrial=False
-):
-    global newlyListedOnly, selectedChoice, userPassedArgs
-    Utility.tools.clearScreen()
-    if menuOption is None:
-        OutputControls().printOutput('You must choose an option from the previous menu! Defaulting to "X"...')
-        menuOption = "X"
-    OutputControls().printOutput(
-        colorText.BOLD
-        + colorText.FAIL
-        + "[+] You chose: "
-        + level0MenuDict[menuOption].strip() 
-        + (f" (Piped Scan Mode) [{userPassedArgs.pipedmenus}]" if (userPassedArgs is not None and userPassedArgs.pipedmenus is not None) else "")
-        + colorText.END
-    )
-    if indexOption is None:
-        selectedMenu = m0.find(menuOption)
-        m1.renderForMenu(selectedMenu=selectedMenu, skip=skip)
-    try:
-        if indexOption is None:
-            indexOption = input(
-                colorText.BOLD + colorText.FAIL + "[+] Select option: "
-            )
-            OutputControls().printOutput(colorText.END, end="")
-        if indexOption == "" or indexOption is None:
-            indexOption = int(configManager.defaultIndex)
-        # elif indexOption == 'W' or indexOption == 'w' or indexOption == 'N' or indexOption == 'n' or indexOption == 'E' or indexOption == 'e':
-        elif not str(indexOption).isnumeric():
-            indexOption = indexOption.upper()
-            if indexOption in ["M", "E", "N", "Z"]:
-                return indexOption, 0
-        else:
-            indexOption = int(indexOption)
-            if indexOption < 0 or indexOption > 15:
-                raise ValueError
-            elif indexOption == 13:
-                newlyListedOnly = True
-                indexOption = 12
-        if indexOption == 15:
-            from pkscreener.classes.MarketStatus import MarketStatus
-            MarketStatus().exchange = "^IXIC"
-        selectedChoice["1"] = str(indexOption)
-    except KeyboardInterrupt:
-        raise KeyboardInterrupt
-    except Exception as e:  # pragma: no cover
-        default_logger().debug(e, exc_info=True)
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + "\n[+] Please enter a valid numeric option & Try Again!"
-            + colorText.END
-        )
-        if not retrial:
-            sleep(2)
-            Utility.tools.clearScreen()
-            return initPostLevel0Execution(retrial=True)
-    return indexOption, executeOption
-
-
-def initPostLevel1Execution(indexOption, executeOption=None, skip=[], retrial=False):
-    global selectedChoice, userPassedArgs
-    if executeOption is None:
-        if indexOption is not None and indexOption != "W":
-            Utility.tools.clearScreen()
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] You chose: "
-                + level0MenuDict[selectedChoice["0"]].strip()
-                + " > "
-                + level1_X_MenuDict[selectedChoice["1"]].strip()
-                + (f" (Piped Scan Mode) [{userPassedArgs.pipedmenus}]" if (userPassedArgs is not None and userPassedArgs.pipedmenus is not None) else "")
-                + colorText.END
-            )
-            selectedMenu = m1.find(indexOption)
-            m2.renderForMenu(selectedMenu=selectedMenu, skip=skip)
-    try:
-        if indexOption is not None and indexOption != "W":
-            if executeOption is None:
-                executeOption = input(
-                    colorText.BOLD + colorText.FAIL + "[+] Select option: "
-                ) or "9"
-                OutputControls().printOutput(colorText.END, end="")
-            if executeOption == "":
-                executeOption = 1
-            if not str(executeOption).isnumeric():
-                executeOption = executeOption.upper()
-            else:
-                executeOption = int(executeOption)
-                if executeOption < 0 or executeOption > 44:
-                    raise ValueError
-        else:
-            executeOption = 0
-        selectedChoice["2"] = str(executeOption)
-    except KeyboardInterrupt:
-        raise KeyboardInterrupt
-    except Exception as e:  # pragma: no cover
-        default_logger().debug(e, exc_info=True)
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + "\n[+] Please enter a valid numeric option & Try Again!"
-            + colorText.END
-        )
-        if not retrial:
-            sleep(2)
-            Utility.tools.clearScreen()
-            return initPostLevel1Execution(indexOption, executeOption, retrial=True)
-    return indexOption, executeOption
-
-def labelDataForPrinting(screenResults, saveResults, configManager, volumeRatio,executeOption, reversalOption):
-    # Publish to gSheet with https://github.com/burnash/gspread
-    global menuChoiceHierarchy, userPassedArgs
-    try:
-        isTrading = PKDateUtilities.isTradingTime() and not PKDateUtilities.isTodayHoliday()[0]
-        if "RUNNER" not in os.environ.keys() and (isTrading or userPassedArgs.monitor or ("RSIi" in saveResults.columns)):
-            screenResults['RSI'] = screenResults['RSI'].astype(str) + "/" + screenResults['RSIi'].astype(str)
-            saveResults['RSI'] = saveResults['RSI'].astype(str) + "/" + saveResults['RSIi'].astype(str)
-            screenResults.rename(columns={"RSI": "RSI/i"},inplace=True)
-            saveResults.rename(columns={"RSI": "RSI/i"},inplace=True)
-        sortKey = ["Volume"] if "RSI" not in menuChoiceHierarchy else ("RSIi" if (isTrading or "RSIi" in saveResults.columns) else "RSI")
-        ascending = [False if "RSI" not in menuChoiceHierarchy else True]
-        if executeOption == 21:
-            if reversalOption in [3,5,6,7]:
-                sortKey = ["MFI"]
-                ascending = [reversalOption in [6,7]]
-            elif reversalOption in [8,9]:
-                sortKey = ["FVDiff"]
-                ascending = [reversalOption in [9]]
-        elif executeOption == 7:
-            if reversalOption in [3]:
-                sortKey = ["Volume","MA-Signal"]
-                ascending = [False, False]
-        elif executeOption == 23:
-            sortKey = ["bbands_ulr_ratio_max5"] if "bbands_ulr_ratio_max5" in screenResults.columns else ["Volume"]
-            ascending = [False]
-        elif executeOption == 27: # ATR Cross
-            sortKey = ["ATR"] if "ATR" in screenResults.columns else ["Volume"]
-            ascending = [False]
-        elif executeOption == 31: # DEEL Momentum
-            sortKey = ["Volume"]
-            ascending = [False]
-        try:
-            try:
-                screenResults[sortKey] = screenResults[sortKey].replace("", np.nan).replace(np.inf, np.nan).replace(-np.inf, np.nan).astype(float)
-            except:
-                pass
-            try:
-                saveResults[sortKey] = saveResults[sortKey].replace("", np.nan).replace(np.inf, np.nan).replace(-np.inf, np.nan).astype(float)
-            except:
-                pass
-            screenResults.sort_values(by=sortKey, ascending=ascending, inplace=True)
-            saveResults.sort_values(by=sortKey, ascending=ascending, inplace=True)
-        except Exception as e:
-            default_logger().debug(e, exc_info=True)
-            pass
-        columnsToBeDeleted = ["MFI","FVDiff","ConfDMADifference","bbands_ulr_ratio_max5", "RSIi"]
-        if userPassedArgs is not None and userPassedArgs.options is not None and userPassedArgs.options.upper().startswith("C"):
-            columnsToBeDeleted.append("FairValue")
-        if executeOption == 27: # ATR Cross
-            columnsToBeDeleted.append("Consol.")
-            screenResults['ATR'] = screenResults['ATR'].astype(str)
-            screenResults['ATR'] = colorText.GREEN + screenResults['ATR'] + colorText.END
-        for column in columnsToBeDeleted:
-            if column in saveResults.columns:
-                saveResults.drop(column, axis=1, inplace=True, errors="ignore")
-                screenResults.drop(column, axis=1, inplace=True, errors="ignore")
-        if "Stock" in screenResults.columns:
-            screenResults.set_index("Stock", inplace=True)
-        if "Stock" in saveResults.columns:
-            saveResults.set_index("Stock", inplace=True)
-        screenResults['Volume'] = screenResults['Volume'].astype(str)
-        saveResults['Volume'] = saveResults['Volume'].astype(str)
-        screenResults.loc[:, "Volume"] = screenResults.loc[:, "Volume"].apply(
-            lambda x: Utility.tools.formatRatio(float(x), volumeRatio) if len(str(x).strip()) > 0 else ''
-        )
-        saveResults.loc[:, "Volume"] = saveResults.loc[:, "Volume"].apply(
-            lambda x: str(x) + "x"
-        )
-        screenResults.rename(
-            columns={
-                "Trend": f"Trend({configManager.daysToLookback}Prds)",
-                "Breakout": f"Breakout({configManager.daysToLookback}Prds)",
-                # "Consol.": f"Consol.({configManager.daysToLookback}Prds)",
-            },
-            inplace=True,
-        )
-        saveResults.rename(
-            columns={
-                "Trend": f"Trend({configManager.daysToLookback}Prds)",
-                "Breakout": f"Breakout({configManager.daysToLookback}Prds)",
-                # "Consol.": f"Consol.({configManager.daysToLookback}Prds)",
-            },
-            inplace=True,
-        )
-    except Exception as e:  # pragma: no cover
-        default_logger().debug(e, exc_info=True)
-    return screenResults, saveResults
-
-def isInterrupted():
-    global keyboardInterruptEventFired
-    return keyboardInterruptEventFired
-
-def refreshStockData(startupoptions=None):
-    global consumers,stockDictPrimary, loadedStockData, listStockCodes, stockDictSecondary
-    options = startupoptions.replace("|","").split(" ")[0].replace(":i","")
-    loadedStockData = False
-    options, menuOption, indexOption, executeOption = getTopLevelMenuChoices(
-        options, False, False, defaultAnswer='Y'
-    )
-    listStockCodes = prepareStocksForScreening(testing=False, downloadOnly=False, listStockCodes=None,indexOption=indexOption)
-    stockDictPrimary,stockDictSecondary = loadDatabaseOrFetch(downloadOnly=False, listStockCodes=listStockCodes, menuOption=menuOption,indexOption=indexOption)
-    PKScanRunner.refreshDatabase(consumers,stockDictPrimary,stockDictSecondary)
-
-def closeWorkersAndExit():
-    global consumers, tasks_queue,userPassedArgs
-    if consumers is not None:
-        PKScanRunner.terminateAllWorkers(userPassedArgs=userPassedArgs,consumers=consumers, tasks_queue=tasks_queue, testing=userPassedArgs.testbuild)
-    
-# @tracelog
-def main(userArgs=None,optionalFinalOutcome_df=None):
-    global mp_manager, listStockCodes, screenResults, selectedChoice, defaultAnswer, menuChoiceHierarchy, screenCounter, screenResultsCounter, stockDictPrimary, stockDictSecondary, userPassedArgs, loadedStockData, keyboardInterruptEvent, loadCount, maLength, newlyListedOnly, keyboardInterruptEventFired,strategyFilter, elapsed_time, start_time
-    selectedChoice = {"0": "", "1": "", "2": "", "3": "", "4": ""}
-    elapsed_time = 0
-    start_time = 0
-    testing = False if userArgs is None else (userArgs.testbuild and userArgs.prodbuild)
-    testBuild = False if userArgs is None else (userArgs.testbuild and not testing)
-    downloadOnly = False if userArgs is None else userArgs.download
-    startupoptions = None if userArgs is None else userArgs.options
-    user = None if userArgs is None else userArgs.user
-    defaultAnswer = None if userArgs is None else userArgs.answerdefault
-    userPassedArgs = userArgs
-    options = []
-    strategyFilter=[]
-    if keyboardInterruptEventFired:
-        return None, None
-    screenCounter = multiprocessing.Value("i", 1)
-    screenResultsCounter = multiprocessing.Value("i", 0)
-    if mp_manager is None:
-        mp_manager = multiprocessing.Manager()
-        
-    if keyboardInterruptEvent is None and not keyboardInterruptEventFired:
-        keyboardInterruptEvent = mp_manager.Event()
-        mkt_monitor_dict = mp_manager.dict()
-        # Let's start monitoring the market monitor
-        startMarketMonitor(mkt_monitor_dict,keyboardInterruptEvent)
-        
-    keyboardInterruptEventFired = False
-    if stockDictPrimary is None:
-        stockDictPrimary = mp_manager.dict()
-        stockDictSecondary = mp_manager.dict()
-        loadCount = 0
-    endOfdayCandles = None
-    minRSI = 0
-    maxRSI = 100
-    insideBarToLookback = 7
-    respChartPattern = None
-    daysForLowestVolume = 30
-    backtestPeriod = 0
-    reversalOption = None
-    listStockCodes = None
-    if userPassedArgs.log:
-        default_logger().debug(f"User Passed args: {userPassedArgs}")
-    screenResults, saveResults = PKScanRunner.initDataframes()
-    options, menuOption, indexOption, executeOption = getTopLevelMenuChoices(
-        startupoptions, testBuild, downloadOnly, defaultAnswer=defaultAnswer
-    )
-    # Print Level 1 menu options
-    selectedMenu = initExecution(menuOption=menuOption)
-    menuOption = selectedMenu.menuKey
-    if menuOption in ["M", "D", "I", "L"]:
-        launcher = sys.argv[0]
-        launcher = f"python3.11 {launcher}" if launcher.endswith(".py") else launcher
-        if menuOption in ["M"]:
-            OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener in monitoring mode. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -m 'X'{colorText.END}\n{colorText.WARN}Press Ctrl + C to exit monitoring mode.{colorText.END}")
-            sleep(2)
-            os.system(f"{launcher} -a Y -m 'X'")
-        elif menuOption in ["D"]:
-            OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener to Download daily OHLC data. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -e -d{colorText.END}\n{colorText.WARN}Press Ctrl + C to exit at any time.{colorText.END}")
-            sleep(2)
-            os.system(f"{launcher} -a Y -e -d")
-        elif menuOption in ["I"]:
-            OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener to Download intraday OHLC data. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -e -d -i 1m{colorText.END}\n{colorText.WARN}Press Ctrl + C to exit at any time.{colorText.END}")
-            sleep(2)
-            os.system(f"{launcher} -a Y -e -d -i 1m")
-        elif menuOption in ["L"]:
-            OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener to collect logs. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -l{colorText.END}\n{colorText.WARN}Press Ctrl + C to exit at any time.{colorText.END}")
-            sleep(2)
-            os.system(f"{launcher} -a Y -l")
-        sys.exit(0)
-    if menuOption in ["P"]:
-        updateMenuChoiceHierarchy()
-        selectedMenu = m0.find(menuOption)
-        m1.renderForMenu(selectedMenu)
-        predefinedOption = input(colorText.BOLD + colorText.FAIL + "[+] Select option: ") or "1"
-        OutputControls().printOutput(colorText.END, end="")
-        if predefinedOption not in ["1","2","3"]:
-            return None, None
-        if predefinedOption == "1":
-            updateMenuChoiceHierarchy()
-            selectedMenu = m1.find(predefinedOption)
-            m2.renderForMenu(selectedMenu=selectedMenu)
-            selPredefinedOption = input(colorText.BOLD + colorText.FAIL + "[+] Select option: ") or "1"
-            OutputControls().printOutput(colorText.END, end="")
-            if selPredefinedOption in PREDEFINED_SCAN_MENU_KEYS:
-                scannerOption = PIPED_SCANNERS[selPredefinedOption]
-                updateMenuChoiceHierarchy()
-                if userPassedArgs.pipedmenus is not None:
-                    chosenOptions = scannerOption.split("-o ")[1]
-                    userPassedArgs.options = chosenOptions.replace("'","")
-                    return addOrRunPipedMenus()
-                launcher = sys.argv[0]
-                launcher = f"python3.11 {launcher}" if launcher.endswith(".py") else launcher
-                scannerOptionQuoted = scannerOption.replace("'",'"')
-                OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener with piped scanners. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} {scannerOptionQuoted}{colorText.END}")
-                sleep(2)
-                os.system(f"{launcher} {scannerOptionQuoted}")
-                OutputControls().printOutput(
-                        colorText.GREEN
-                        + f"[+] Finished running all piped scanners!"
-                        + colorText.END
-                    )
-                if defaultAnswer is None:
-                    input("Press <Enter> to exit...")
-                sys.exit(0)
-            else:
-                return None, None
-        elif predefinedOption == "2":
-            # User chose custom
-            menuOption = "X" # Let's have the user choose various scan options
-            selectedMenu = m0.find(menuOption)
-            selectedChoice["0"] = selectedMenu.menuKey
-            if userPassedArgs.pipedmenus is None:
-                userPassedArgs.pipedmenus = ""
-        elif predefinedOption == "3":
-            if userPassedArgs.pipedmenus is not None:
-                return addOrRunPipedMenus()
-    if menuOption in ["X", "T", "E", "Y", "U", "H", "C"]:
-        # Print Level 2 menu options
-        menuOption, indexOption, executeOption, selectedChoice = getScannerMenuChoices(
-            testBuild or testing,
-            downloadOnly,
-            startupoptions,
-            menuOption=menuOption,
-            indexOption=indexOption,
-            executeOption=executeOption,
-            defaultAnswer=defaultAnswer,
-            user=user,
-        )
-
-        if menuOption in ["H", "U", "T", "E", "Y"]:
-            Utility.tools.clearScreen(forceTop=True)
-            return None, None
-    elif menuOption in ["B", "G"]:
-        # Backtests
-        backtestPeriod = 0
-        if len(options) >= 2:
-            if str(indexOption).isnumeric():
-                backtestPeriod = int(indexOption)
-            if len(options) >= 4:
-                indexOption = executeOption
-                executeOption = options[3]
-            del options[1]  # Let's delete the backtestperiod from the provided options
-        indexOption, executeOption, backtestPeriod = takeBacktestInputs(
-            str(menuOption).upper(), indexOption, executeOption, backtestPeriod
-        )
-        backtestPeriod = backtestPeriod * configManager.backtestPeriodFactor
-    elif menuOption in ["S"]:
-        if len(options) >= 2:
-            userOption = options[1]
-        if defaultAnswer is None:
-            selectedMenu = m0.find(menuOption)
-            m1.strategyNames = PortfolioXRay.strategyNames()
-            m1.renderForMenu(selectedMenu=selectedMenu)
-            try:
-                userOption = input(
-                            colorText.BOLD + colorText.FAIL + "[+] Select option: "
-                        )
-                OutputControls().printOutput(colorText.END, end="")
-                if userOption == "":
-                    userOption = "37" # NoFilter
-                elif userOption == "38":
-                    userOption = input(
-                            colorText.BOLD + colorText.FAIL + "[+] Enter Exact Pattern name:"
-                        )
-                    OutputControls().printOutput(colorText.END, end="")
-                    if userOption == "":
-                        userOption = "37" # NoFilter
-                    else:
-                        strategyFilter.append(f"[P]{userOption}")
-                        userOption = "38"
-            except EOFError:  # pragma: no cover
-                userOption = "37"  # NoFilter
-                pass
-            except Exception as e:# pragma: no cover
-                default_logger().debug(e, exc_info=True)
-                pass
-        userOption = userOption.upper()
-        if userOption == "M":
-            Utility.tools.clearScreen(forceTop=True)
-            # Go back to the caller. It will show the console menu again.
-            return None, None
-        elif userOption == "Z":
-            handleExitRequest(userOption)
-            return None, None
-        
-        if userOption == "S":
-            OutputControls().printOutput(
-                colorText.GREEN
-                + "[+] Collecting all metrics for summarising..."
-                + colorText.END
-            )
-            # Enable showing/saving past strategy data
-            savedValue = configManager.showPastStrategyData
-            configManager.showPastStrategyData = True
-            df_all = PortfolioXRay.summariseAllStrategies()
-            if df_all is not None and len(df_all) > 0:
-                OutputControls().printOutput(
-                    colorText.miniTabulator().tabulate(
-                        df_all,
-                        headers="keys",
-                        tablefmt=colorText.No_Pad_GridFormat,
-                        showindex=False,
-                        maxcolwidths=Utility.tools.getMaxColumnWidths(df_all)
-                    ).encode("utf-8").decode(STD_ENCODING)
-                )
-                showBacktestResults(
-                    df_all, sortKey="Scanner", optionalName="InsightsSummary"
-                )
-            else:
-                OutputControls().printOutput("[!] Nothing to show here yet. Check back later.")
-            # reinstate whatever was the earlier saved value
-            configManager.showPastStrategyData = savedValue
-            if defaultAnswer is None:
-                input("Press <Enter> to continue...")
-            return None, None
-        else:
-            userOptions = userOption.split(",")
-            for usrOption in userOptions:
-                strategyFilter.append(m1.find(usrOption).menuText.strip())
-            menuOption, indexOption, executeOption, selectedChoice = getScannerMenuChoices(
-            testBuild or testing,
-            downloadOnly,
-            startupoptions,
-            menuOption="X",
-            indexOption=indexOption,
-            executeOption=executeOption,
-            defaultAnswer=defaultAnswer,
-            user=user,
-        )
-
-    else:
-        OutputControls().printOutput("Not implemented yet! Try selecting a different option.")
-        sleep(3)
-        return None, None
-
-    handleMenu_XBG(menuOption, indexOption, executeOption)
-    if indexOption == "M" or executeOption == "M":
-        Utility.tools.clearScreen(forceTop=True)
-        # Go back to the caller. It will show the console menu again.
-        return None, None
-    listStockCodes = handleRequestForSpecificStocks(options, indexOption)
-    handleExitRequest(executeOption)
-    if executeOption is None:
-        executeOption = 0
-    executeOption = int(executeOption)
-    volumeRatio = configManager.volumeRatio
-    if executeOption == 3:
-        userPassedArgs.maxdisplayresults = 2000 # force evaluate all stocks before getting the top results
-    if executeOption == 4:
-        daysForLowestVolume = handleScannerExecuteOption4(executeOption, options)
-    if executeOption == 5:
-        selectedMenu = m2.find(str(executeOption))
-        if len(options) >= 5:
-            if str(options[3]).isnumeric():
-                minRSI = int(options[3])
-                maxRSI = int(options[4])
-            elif str(options[3]).upper() == "D":
-                # Use a default value
-                minRSI = 60
-                maxRSI = 75
-        else:
-            minRSI, maxRSI = Utility.tools.promptRSIValues()
-        if not minRSI and not maxRSI:
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "\n[+] Error: Invalid values for RSI! Values should be in range of 0 to 100. Please try again!"
-                + colorText.END
-            )
-            input("PRess <Enter> to continue...")
-            return None, None
-    if executeOption == 6:
-        selectedMenu = m2.find(str(executeOption))
-        if len(options) >= 4:
-            reversalOption = int(options[3])
-            if reversalOption in [4, 6, 7, 10]:
-                if len(options) >= 5:
-                    if str(options[4]).isnumeric():
-                        maLength = int(options[4])
-                    elif str(options[4]).upper() == "D":
-                        maLength = 50 if reversalOption == 4 else (3 if reversalOption in [7] else (2 if reversalOption in [10] else 7))
-                elif defaultAnswer == "Y" and user is not None:
-                    # bot mode
-                    maLength = 50 if reversalOption == 4 else (3 if reversalOption == 7 else 7)
-                else:
-                    reversalOption, maLength = Utility.tools.promptReversalScreening(
-                        selectedMenu
-                    )
-        else:
-            reversalOption, maLength = Utility.tools.promptReversalScreening(
-                selectedMenu
-            )
-        if reversalOption is None or reversalOption == 0 or maLength == 0:
-            return None, None
-        else:
-            selectedChoice["3"] = str(reversalOption)
-            if str(reversalOption) in ["7", "10"]:
-                selectedChoice["4"] = str(maLength)
-    if executeOption == 7:
-        selectedMenu = m2.find(str(executeOption))
-        maLength = 0
-        if len(options) >= 4:
-            respChartPattern = int(options[3])
-            selectedChoice["3"] = options[3]
-            if respChartPattern in [1, 2, 3]:
-                if len(options) >= 5:
-                    if "".join(str(options[4]).split(".")).isdecimal():
-                        insideBarToLookback = float(options[4])
-                    elif str(options[4]).upper() == "D":
-                        insideBarToLookback = 7 if respChartPattern in [1, 2] else 0.02
-                    if len(options) >= 6:
-                        if str(options[5]).isnumeric():
-                            maLength = int(options[5])
-                        elif str(options[5]).upper() == "D":
-                            maLength = 1 # Conf. up
-                elif defaultAnswer == "Y" and user is not None:
-                    # bot mode
-                    insideBarToLookback = 7 if respChartPattern in [1, 2] else 0.02
-                    maLength = 1 if respChartPattern in [3] else 0
-                else:
-                    (
-                        respChartPattern,
-                        insideBarToLookback,
-                    ) = Utility.tools.promptChartPatterns(selectedMenu)
-                if maLength == 0:
-                    maLength = Utility.tools.promptChartPatternSubMenu(selectedMenu, respChartPattern)
-            elif respChartPattern in [0, 4, 5, 6, 7]:
-                insideBarToLookback = 0
-                if respChartPattern == 6:
-                    if len(options) >= 5:
-                        if str(options[4]).isnumeric():
-                            maLength = int(options[4])
-                        elif str(options[4]).upper() == "D":
-                            maLength = 1 # Bollinger Bands Squeeze-Buy
-                    elif defaultAnswer == "Y" and user is not None:
-                        # bot mode
-                        maLength = 4 # Bollinger Bands Squeeze- Any/All
-                    else:
-                        maLength = Utility.tools.promptChartPatternSubMenu(selectedMenu,respChartPattern)
-            else:
-                (
-                    respChartPattern,
-                    insideBarToLookback,
-                ) = Utility.tools.promptChartPatterns(selectedMenu)
-        else:
-            respChartPattern, insideBarToLookback = Utility.tools.promptChartPatterns(
-                selectedMenu
-            )
-            if maLength == 0 and respChartPattern in [1, 2, 3, 6]:
-                maLength = Utility.tools.promptChartPatternSubMenu(selectedMenu, respChartPattern)
-        if (
-            respChartPattern is None
-            or insideBarToLookback is None
-            or respChartPattern == 0
-            or (maLength == 0 and respChartPattern in [1, 2, 3, 6])
-        ):
-            return None, None
-        else:
-            selectedChoice["3"] = str(respChartPattern)
-            selectedChoice["4"] = str(insideBarToLookback) if (respChartPattern in [1, 2, 3] and (userPassedArgs is not None and userPassedArgs.pipedmenus is not None)) else str(maLength)
-            selectedChoice["5"] = str(maLength) if (respChartPattern in [1, 2, 3] and (userPassedArgs is not None and userPassedArgs.pipedmenus is not None)) else ""
-    if executeOption == 8:
-        if len(options) >= 5:
-            if "".join(str(options[3]).split(".")).isdecimal():
-                minRSI = int(options[3])
-            if "".join(str(options[4]).split(".")).isdecimal():
-                maxRSI = int(options[4])
-            if str(options[3]).upper() == "D":
-                minRSI = -150
-                maxRSI = 250
-        else:
-            minRSI, maxRSI = Utility.tools.promptCCIValues()
-        if not minRSI and not maxRSI:
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "\n[+] Error: Invalid values for CCI! Values should be in range of -300 to 500. Please try again!"
-                + colorText.END
-            )
-            input("Press <Enter> to continue...")
-            return None, None
-    if executeOption == 9:
-        if len(options) >= 4:
-            if str(options[3]).isnumeric():
-                volumeRatio = float(options[3])
-            elif str(options[3]).upper() == "D":
-                volumeRatio = configManager.volumeRatio
-        else:
-            volumeRatio = Utility.tools.promptVolumeMultiplier()
-        if volumeRatio <= 0:
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "\n[+] Error: Invalid values for Volume Ratio! Value should be a positive number. Please try again!"
-                + colorText.END
-            )
-            input("Press <Enter> to continue...")
-            return None, None
-        else:
-            configManager.volumeRatio = float(volumeRatio)
-    if executeOption == 12:
-        candleDuration = userPassedArgs.intraday if (userPassedArgs is not None and userPassedArgs.intraday is not None) else ("15m")
-        configManager.toggleConfig(candleDuration=candleDuration)
-        global nValueForMenu 
-        nValueForMenu = candleDuration
-    if executeOption == 21:
-        selectedMenu = m2.find(str(executeOption))
-        if len(options) >= 4:
-            popOption = int(options[3])
-            if popOption >= 0 and popOption <= 9:
-                pass
-        else:
-            popOption = Utility.tools.promptSubMenuOptions(selectedMenu)
-        if popOption is None or popOption == 0:
-            return None, None
-        else:
-            selectedChoice["3"] = str(popOption)
-        if popOption in [1,2,4]:
-            updateMenuChoiceHierarchy()
-            if popOption == 4:
-                screenResults = mstarFetcher.fetchMorningstarTopDividendsYieldStocks()
-            elif popOption in [1,2]:
-                screenResults = mstarFetcher.fetchMorningstarFundFavouriteStocks(
-                    "NoOfFunds" if popOption == 2 else "ChangeInShares"
-                )
-            if menuOption in ["X"]:
-                printNotifySaveScreenedResults(
-                    screenResults,
-                    screenResults,
-                    selectedChoice,
-                    menuChoiceHierarchy,
-                    False,
-                    None,
-                )
-                if defaultAnswer is None:
-                    input("Press <Enter> to continue...")
-                return None, None
-            else:
-                listStockCodes = ",".join(list(screenResults.index))
-        else:
-            userPassedArgs.maxdisplayresults = 2000 # force evaluate all stocks before getting the top results
-            reversalOption = popOption
-    if executeOption == 22:
-        selectedMenu = m2.find(str(executeOption))
-        if len(options) >= 4:
-            popOption = int(options[3])
-            if popOption >= 0 and popOption <= 3:
-                pass
-        else:
-            popOption = Utility.tools.promptSubMenuOptions(selectedMenu)
-        if popOption is None or popOption == 0:
-            return None, None
-        else:
-            selectedChoice["3"] = str(popOption)
-        updateMenuChoiceHierarchy()
-        screenResults = mstarFetcher.fetchMorningstarStocksPerformanceForExchange()
-        if menuOption in ["X"]:
-            printNotifySaveScreenedResults(
-                screenResults,
-                screenResults,
-                selectedChoice,
-                menuChoiceHierarchy,
-                False,
-                None,
-            )
-            if defaultAnswer is None:
-                input("Press <Enter> to continue...")
-            return None, None
-        else:
-            listStockCodes = ",".join(list(screenResults.index))
-    if executeOption == 26:
-        dividend_df, bonus_df, stockSplit_df = mstarFetcher.getCorporateActions()
-        ca_dfs = [dividend_df, bonus_df, stockSplit_df]
-        listStockCodes = []
-        for df in ca_dfs:
-            df = df[
-                df["Stock"].astype(str).str.contains("BSE:") == False
-            ]
-            listStockCodes.extend(list(df["Stock"]))
-    if executeOption == 30:
-        selectedMenu = m2.find(str(executeOption))
-        if len(options) >= 4:
-            if str(options[3]).isnumeric():
-                maLength = int(options[3])
-            elif str(options[3]).upper() == "D":
-                maLength = 1
-            else:
-                maLength = 1
-        elif len(options) >= 3:
-            maLength = 1 # By default buy option
-        else:
-            maLength = Utility.tools.promptSubMenuOptions(selectedMenu)
-        if maLength == 0:
-            return None, None
-        else:
-            selectedChoice["3"] = str(maLength)
-        if userPassedArgs.options is None:
-            Utility.tools.clearScreen(forceTop=True)
-            atrSensitivity = input(colorText.WARN + f"Enter the ATR Trailing Stop Sensitivity (Multiplier) value (Optimal:1, Current={configManager.atrTrailingStopSensitivity}):") or configManager.atrTrailingStopSensitivity
-            configManager.atrTrailingStopSensitivity = atrSensitivity
-            atrPeriod = input(colorText.WARN + f"Enter the ATR Period value (Optimal:10, Current={configManager.atrTrailingStopPeriod}):") or configManager.atrTrailingStopPeriod
-            configManager.atrTrailingStopPeriod = atrPeriod
-            atrEma = input(colorText.WARN + f"Enter the ATR EMA period (Optimal:200, Current={configManager.atrTrailingStopEMAPeriod}):") or configManager.atrTrailingStopEMAPeriod
-            configManager.atrTrailingStopEMAPeriod = atrEma
-            configManager.setConfig(ConfigManager.parser,default=True,showFileCreatedText=False)
-
-    if executeOption == 42:
-        Utility.tools.getLastScreenedResults(defaultAnswer)
-        return None, None
-    if executeOption >= MAX_SUPPORTED_MENU_OPTION and executeOption <= MAX_MENU_OPTION:
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + F"\n[+] Error: Option {MAX_SUPPORTED_MENU_OPTION} to {MAX_MENU_OPTION} Not implemented yet! Press <Enter> to continue."
-            + colorText.END
-        )
-        input("Press <Enter> to continue...")
-        return None, None
-    if (
-        not str(indexOption).isnumeric() and indexOption in ["W", "E", "M", "N", "Z"]
-    ) or (
-        str(indexOption).isnumeric()
-        and (int(indexOption) >= 0 and int(indexOption) < 16)
-    ):
-        configManager.getConfig(ConfigManager.parser)
-        try:
-            if indexOption == "W":
-                listStockCodes = fetcher.fetchWatchlist()
-                if listStockCodes is None:
-                    input(
-                        colorText.BOLD
-                        + colorText.FAIL
-                        + f"[+] Please create the watchlist.xlsx file in {os.getcwd()} and Restart the Program!"
-                        + colorText.END
-                    )
-                    sys.exit(0)
-            elif indexOption == "N":
-                os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
-                prediction, pText, sText = screener.getNiftyPrediction(
-                    df=fetcher.fetchLatestNiftyDaily(proxyServer=fetcher.proxyServer)
-                )
-                warningText = "\nNifty AI prediction works best if you request after market is closed. It may not be accurate while market is still open!" if "Open" in Utility.marketStatus() else ""
-                try:
-                    todayHoliday, todayOccassion = PKDateUtilities.isHoliday(PKDateUtilities.currentDateTime())
-                    nextWeekday = PKDateUtilities.nextWeekday()
-                    tomorrowHoliday,tomorrowOccassion = PKDateUtilities.isHoliday(nextWeekday)
-                    if todayHoliday:
-                        warningText = f"{warningText}\n\nMarket is closed today due to {todayOccassion}."
-                    if tomorrowHoliday:
-                        warningText = f"{warningText}\n\nMarket will be closed on {nextWeekday.strftime('%Y-%m-%d')} due to {tomorrowOccassion}."
-                except:
-                    pass
-                sendMessageToTelegramChannel(
-                    message=f"{Utility.tools.removeAllColorStyles(Utility.marketStatus())}\nNifty AI prediction for the Next Day: {pText}. {sText}.{warningText}",
-                    user=user,
-                )
-                if defaultAnswer is None:
-                    input("\nPress <Enter> to Continue...\n")
-                return None, None
-            elif indexOption == "M":
-                return None, None
-            elif indexOption == "Z":
-                input(
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + "[+] Press <Enter> to Exit!"
-                    + colorText.END
-                )
-                sys.exit(0)
-            elif indexOption == "E":
-                return handleMonitorFiveEMA()
-            else:
-                if str(menuOption).upper() == "C":
-                    stockDictPrimary,endOfdayCandles = PKMarketOpenCloseAnalyser.getStockDataForSimulation()
-                    if stockDictPrimary is None or endOfdayCandles is None:
-                        OutputControls().printOutput(f"Cannot proceed! Stock data is unavailable. Please check the error logs/messages !")
-                        return None, None
-                    if indexOption > 0:
-                        listStockCodes = sorted(list(filter(None,list(set(stockDictPrimary.keys())))))
-                listStockCodes = prepareStocksForScreening(testing, downloadOnly, listStockCodes, indexOption)
-        except urllib.error.URLError as e:
-            default_logger().debug(e, exc_info=True)
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "\n\n[+] Oops! It looks like you don't have an Internet connectivity at the moment!"
-                + colorText.END
-            )
-            input("Exiting now...")
-            sys.exit(0)
-        if userPassedArgs.options is None or len(userPassedArgs.options) == 0:
-            userPassedArgs.options = ""
-            for choice in selectedChoice.keys():
-                userPassedArgs.options = (f"{userPassedArgs.options}:" if len(userPassedArgs.options) > 0  else '') + f"{selectedChoice[choice]}"
-        if userPassedArgs.pipedmenus is not None:
-            return addOrRunPipedMenus()
-
-        if (menuOption in ["X", "B", "G", "S"] and not loadedStockData) or (
-            # not downloadOnly
-            # and not PKDateUtilities.isTradingTime()
-            # and 
-            configManager.cacheEnabled
-            and not loadedStockData
-            and not testing
-        ):
-            stockDictPrimary,stockDictSecondary = loadDatabaseOrFetch(downloadOnly, listStockCodes, menuOption, indexOption)
-            
-        loadCount = len(stockDictPrimary) if stockDictPrimary is not None else 0
-
-        if downloadOnly:
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.WARN
-                + "[+] Starting download.. Press Ctrl+C to stop!"
-            )
-            if not configManager.isIntradayConfig():
-                fetcher.saveAllNSEIndices()
-        if menuOption.upper() in ["B", "G"]:
-            OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + f"[+] A total of {configManager.backtestPeriod} trading periods' historical data will be considered for backtesting. You can change this in User Config."
-                )
-        samplingDuration, fillerPlaceHolder, actualHistoricalDuration = PKScanRunner.getScanDurationParameters(testing, menuOption)
-        totalStocksInReview = 0
-        savedStocksCount = 0
-        downloadedRecently = False
-        items = []
-        backtest_df = None
-        bar, spinner = Utility.tools.getProgressbarStyle()
-        # Lets begin from y days ago, evaluate from that date if the selected strategy had yielded any result
-        # and then keep coming to the next day (x-1) until we get to today (actualHistoricalDuration = 0)
-        OutputControls().printOutput(f"{colorText.GREEN}[+] Adding stocks to the queue...{colorText.END}")
-        with alive_bar(actualHistoricalDuration, bar=bar, spinner=spinner) as progressbar:
-            while actualHistoricalDuration >= 0:
-                daysInPast = PKScanRunner.getBacktestDaysForScan(userPassedArgs, backtestPeriod, menuOption, actualHistoricalDuration)
-                try:
-                    listStockCodes, savedStocksCount, pastDate = PKScanRunner.getStocksListForScan(userPassedArgs, menuOption, totalStocksInReview, downloadedRecently, daysInPast) if menuOption not in ["C"] else (listStockCodes, 0, "")
-                except KeyboardInterrupt:
-                    try:
-                        keyboardInterruptEvent.set()
-                        keyboardInterruptEventFired = True
-                        actualHistoricalDuration = -1
-                        break
-                    except KeyboardInterrupt:
-                        pass
-                    OutputControls().printOutput(
-                        colorText.BOLD
-                        + colorText.FAIL
-                        + "\n[+] Terminating Script, Please wait..."
-                        + colorText.END
-                    )
-                except Exception:
-                    pass
-                exchangeName = "NASDAQ" if (indexOption == 15 or (configManager.defaultIndex == 15 and indexOption == 0)) else "INDIA"
-                PKScanRunner.addStocksToItemList(userPassedArgs, testing, testBuild, newlyListedOnly, downloadOnly, minRSI, maxRSI, insideBarToLookback, respChartPattern, daysForLowestVolume, backtestPeriod, reversalOption, maLength, listStockCodes, menuOption,exchangeName,executeOption, volumeRatio, items, daysInPast)
-                if savedStocksCount > 0:
-                    progressbar.text(
-                        colorText.BOLD
-                        + colorText.GREEN
-                        + f"Total Stocks: {len(items)}. Added {savedStocksCount} to Stocks from {pastDate} saved from earlier..."
-                        + colorText.END
-                    )
-                fillerPlaceHolder = fillerPlaceHolder + 1
-                actualHistoricalDuration = samplingDuration - fillerPlaceHolder
-                if actualHistoricalDuration >= 0:
-                    progressbar()
-        sys.stdout.write(f"\x1b[1A") # Replace the download progress bar and start writing on the same line
-        if not keyboardInterruptEventFired:
-            global tasks_queue, results_queue, consumers, logging_queue
-            screenResults, saveResults, backtest_df, tasks_queue, results_queue, consumers,logging_queue = PKScanRunner.runScanWithParams(userPassedArgs,keyboardInterruptEvent,screenCounter,screenResultsCounter,stockDictPrimary,stockDictSecondary,testing, backtestPeriod, menuOption,executeOption, samplingDuration, items,screenResults, saveResults, backtest_df,scanningCb=runScanners,tasks_queue=tasks_queue, results_queue=results_queue, consumers=consumers,logging_queue=logging_queue)
-            if userPassedArgs is not None and (userPassedArgs.monitor is None and "|" not in userPassedArgs.options and not userPassedArgs.options.upper().startswith("C")):
-                tasks_queue = None
-                results_queue = None
-                consumers = None
-            if menuOption in ["C"]:
-                runOptionName = PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)
-                PKMarketOpenCloseAnalyser.runOpenCloseAnalysis(stockDictPrimary,endOfdayCandles,screenResults, saveResults,runOptionName=runOptionName,filteredListOfStocks=listStockCodes)
-            if downloadOnly and menuOption in ["X"]:
-                screener.getFreshMFIStatus(stock="LatestCheckedOnDate")
-                screener.getFairValue(stock="LatestCheckedOnDate", force=True)
-            if not downloadOnly and menuOption in ["X", "G", "C"]:
-                if menuOption == "G":
-                    userPassedArgs.backtestdaysago = backtestPeriod
-                if screenResults is not None and len(screenResults) > 0:
-                    screenResults, saveResults = labelDataForPrinting(
-                        screenResults, saveResults, configManager, volumeRatio, executeOption, reversalOption or respChartPattern
-                    )
-                    # ticker_list = list(saveResults.index)
-                    # marketCaps = fetcher.fetchAdditionalTickerInfo(ticker_list)
-                    # saveResults["MCapWt%"] = 0
-                    # numShares = []
-                    # for ticker in ticker_list:
-                    #     try:
-                    #         mCap = marketCaps.get(f"{ticker}.NS")
-                    #         mCap = round(mCap.get("marketCap"),0)
-                    #     except:
-                    #         mCap = 0
-                    #         pass
-                    #     saveResults.loc[ticker, 'MCapWt%'] = mCap
-                    # # Let's get the weighted no. of shares
-                    # marketCapSum = sum(saveResults["MCapWt%"])
-                    # for ticker in ticker_list:
-                    #     try:
-                    #         saveResults.loc[ticker, 'MCapWt%'] = int(round(saveResults.loc[ticker, 'MCapWt%']/marketCapSum,2)*100)
-                    #     except:
-                    #         saveResults.loc[ticker, 'MCapWt%'] = 0
-                    #         pass
-                    #     numShares.append(saveResults.loc[ticker, 'MCapWt%'])
-                    # screenResults["MCapWt%"] = numShares
-                if not newlyListedOnly and not configManager.showunknowntrends and screenResults is not None and len(screenResults) > 0:
-                    screenResults, saveResults = removeUnknowns(screenResults, saveResults)
-                    OutputControls().printOutput(colorText.FAIL + f"[+] Configuration to remove unknown cell values resulted into removing all rows!" + colorText.END)
-                if len(strategyFilter) > 0 and saveResults is not None and len(saveResults) > 0:
-                    # We'd need to apply additional filters for selected strategy
-                    df_screenResults = None
-                    cleanedUpSaveResults = PortfolioXRay.cleanupData(saveResults)
-                    for strFilter in strategyFilter:
-                        cleanedUpSaveResults = PortfolioXRay.strategyForKey(strFilter)(cleanedUpSaveResults)
-                        saveResults = saveResults[saveResults.index.isin(cleanedUpSaveResults.index.values)]
-                    for stk in saveResults.index.values:
-                        df_screenResults_filter = screenResults[screenResults.index.astype(str).str.contains(f"NSE%3A{stk}") == True]
-                        df_screenResults = pd.concat([df_screenResults, df_screenResults_filter], axis=0)
-                    if df_screenResults is None or len(df_screenResults) == 0:
-                        OutputControls().printOutput(colorText.FAIL + f"[+] Of the {len(screenResults) if screenResults is not None else 0} stocks, no results matching the selected strategies!" + colorText.END)
-                    screenResults = df_screenResults
-                if executeOption == 26:
-                    removedUnusedColumns(screenResults, saveResults, ["Date"],userArgs=userPassedArgs)
-                    screen_copy = screenResults.copy()
-                    screen_copy.reset_index(inplace=True)
-                    dividend_df = pd.merge(screen_copy, dividend_df, on='Stock')
-                    bonus_df = pd.merge(screen_copy, bonus_df, on='Stock')
-                    stockSplit_df = pd.merge(screen_copy, stockSplit_df, on='Stock')
-                    corp_dfs = [dividend_df, bonus_df, stockSplit_df]
-                    shareable_strings = []
-                    shouldSend = False
-                    for corp_df in corp_dfs:
-                        if corp_df is None:
-                            continue
-                        tab_results = ""
-                        if corp_df is not None and not corp_df.empty:
-                            corp_df.set_index("Stock", inplace=True)
-                            corp_df = corp_df[~corp_df.index.duplicated(keep='first')]
-                            tab_results = colorText.miniTabulator().tabulate(
-                                corp_df,
-                                headers="keys",
-                                tablefmt=colorText.No_Pad_GridFormat,
-                                # showindex = False,
-                                maxcolwidths=Utility.tools.getMaxColumnWidths(dividend_df)
-                            ).encode("utf-8").decode(STD_ENCODING)
-                            shouldSend = True
-                        shareable_strings.append(tab_results)
-                        OutputControls().printOutput(tab_results)
-                    if shouldSend:
-                        sendQuickScanResult(
-                            menuChoiceHierarchy,
-                            user,
-                            shareable_strings[0],
-                            Utility.tools.removeAllColorStyles(shareable_strings[0]),
-                            "NSE Stocks with dividends/bonus/splits soon",
-                            f"PKS_X_12_26_{PKDateUtilities.currentDateTime().strftime('%Y-%m-%d_%H:%M:%S')}",
-                            ".png",
-                            addendum=shareable_strings[1],
-                            addendumLabel="NSE Stocks giving bonus:",
-                            backtestSummary=shareable_strings[2],
-                            backtestDetail="",
-                            summaryLabel = "NSE Stocks with corporate action type stock split:",
-                            detailLabel = None,
-                            )
-                elif "|" not in userPassedArgs.options:
-                    try:
-                        printNotifySaveScreenedResults(
-                            screenResults,
-                            saveResults,
-                            selectedChoice,
-                            menuChoiceHierarchy,
-                            testing,
-                            user=user,
-                        )
-                    except Exception as e:
-                        default_logger().debug(e, exc_info=True)
-                        if userPassedArgs.log:
-                            import traceback
-                            traceback.print_exc()
-                        pass
-        if menuOption in ["X","C"] and userPassedArgs.monitor is None:
-            finishScreening(
-                downloadOnly,
-                testing,
-                stockDictPrimary,
-                configManager,
-                loadCount,
-                testBuild,
-                screenResults,
-                saveResults,
-                user,
-            )
-
-        if menuOption == "B" and backtest_df is not None and len(backtest_df) > 0:
-            Utility.tools.clearScreen()
-            # Let's do the portfolio calculation first
-            df_xray = prepareGroupedXRay(backtestPeriod, backtest_df)
-            summary_df, sorting, sortKeys = FinishBacktestDataCleanup(backtest_df, df_xray)
-            while sorting:
-                sorting = showSortedBacktestData(backtest_df, summary_df, sortKeys)
-            if defaultAnswer is None:
-                input("Press <Enter> to continue...")
-        elif menuOption == "B":
-            OutputControls().printOutput("Finished backtesting with no results to show!")
-        elif menuOption == "G":
-            if defaultAnswer is None:
-                input("Press <Enter> to continue...")
-    newlyListedOnly = False
-    # Change the config back to usual
-    resetConfigToDefault()
-    try:
-        creds = None
-        # Write into sheet only if it's the reglar scan alert trigger in the morning and evening
-        if 'ALERT_TRIGGER' in os.environ.keys() and os.environ["ALERT_TRIGGER"] == 'Y':
-            if "GSHEET_SERVICE_ACCOUNT_DEV" in os.environ.keys() and (userPassedArgs.backtestdaysago is None):# or userPassedArgs.log:
-                begin = time.time()
-                creds = os.environ.get("GSHEET_SERVICE_ACCOUNT_DEV")
-                OutputControls().printOutput(f"{colorText.GREEN}[+] Saving data to Google Spreadsheets now...{colorText.END}")
-                gClient = PKSpreadsheets(credentialDictStr=creds)
-                runOption = PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)
-                df = saveResults.copy()
-                df["LastTradeDate"], df["LastTradeTime"] = getLatestTradeDateTime(stockDictPrimary)
-                gClient.df_to_sheet(df=df,sheetName=runOption)
-                OutputControls().printOutput(f"{colorText.GREEN} => Done in {round(time.time()-begin,2)}s{colorText.END}")
-    except:
-        pass
-    if "RUNNER" not in os.environ.keys() and (userPassedArgs is None or (userPassedArgs is not None and (userPassedArgs.answerdefault is None or userPassedArgs.systemlaunched))):
-        prevOutput_results = saveResults.index if (saveResults is not None and not saveResults.empty) else []
-        hasFoundStocks = len(prevOutput_results) > 0 and (("|" not in userPassedArgs.options) if (userPassedArgs is not None and userPassedArgs.options is not None) else True)
-        if hasFoundStocks:
-            monitorOption = userPassedArgs.systemlaunched if (userPassedArgs is not None and isinstance(userPassedArgs.systemlaunched,str) and userPassedArgs.systemlaunched is not None) else (userPassedArgs.options if (userPassedArgs is not None and userPassedArgs.options is not None) else "")
-            if len(monitorOption) == 0:
-                for choice in selectedChoice.keys():
-                    monitorOption = (f"{monitorOption}:" if len(monitorOption) > 0  else '') + f"{selectedChoice[choice]}"
-            m0.renderPinnedMenu(substitutes=[monitorOption,len(prevOutput_results)])
-            pinOption = input(
-                    colorText.BOLD + colorText.FAIL + "[+] Select option: "
-                ) or 'M'
-            OutputControls().printOutput(colorText.END, end="")
-            if pinOption in ["1","2"]:
-                if pinOption in ["2"]:
-                    monitorOption = "X:0:0"
-                    prevOutput_results = ",".join(prevOutput_results)
-                    monitorOption = f"{monitorOption}:{prevOutput_results}"
-                launcher = sys.argv[0]
-                launcher = f"python3.11 {launcher}" if launcher.endswith(".py") else launcher
-                monitorOption = f'"{monitorOption}"'
-                scannerOptionQuoted = monitorOption.replace("'",'"')
-                OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener with pinned scan option. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -m {scannerOptionQuoted}{colorText.END}")
-                sleep(2)
-                os.system(f"{launcher} -a Y -m {scannerOptionQuoted}")
-
-    if userPassedArgs is not None:
-        if userPassedArgs.runintradayanalysis:
-            analysis_df = screenResults.copy()
-            analysis_df.reset_index(inplace=True)
-            if 'index' in analysis_df.columns:
-                analysis_df.drop('index', axis=1, inplace=True, errors="ignore")
-            if optionalFinalOutcome_df is None:
-                optionalFinalOutcome_df = analysis_df
-            else:
-                optionalFinalOutcome_df = pd.concat([optionalFinalOutcome_df, analysis_df], axis=0)
-            return optionalFinalOutcome_df, saveResults
-        else:
-            existingTitle = f"{userPassedArgs.pipedtitle}|" if userPassedArgs.pipedtitle is not None else ""
-            choiceSegments = menuChoiceHierarchy.split(">")
-            choiceSegments = f"{choiceSegments[-2]} > {choiceSegments[-1]}" if len(choiceSegments)>=4 else f"{choiceSegments[-1]}"
-            userPassedArgs.pipedtitle = f'{existingTitle}{choiceSegments}[{len(saveResults)}]'
-            return screenResults, saveResults
-
-def loadDatabaseOrFetch(downloadOnly, listStockCodes, menuOption, indexOption):
-    global stockDictPrimary,stockDictSecondary, configManager, defaultAnswer, userPassedArgs, loadedStockData
-    if menuOption not in ["C"]:
-        stockDictPrimary = Utility.tools.loadStockData(
-                    stockDictPrimary,
-                    configManager,
-                    downloadOnly=downloadOnly,
-                    defaultAnswer=defaultAnswer,
-                    forceLoad=(menuOption in ["X", "B", "G", "S"]),
-                    stockCodes = listStockCodes,
-                    exchangeSuffix = "" if (indexOption == 15 or (configManager.defaultIndex == 15 and indexOption == 0)) else ".NS"
-            )
-    if menuOption not in ["C"] and (userPassedArgs.monitor is not None or "|" in userPassedArgs.options) :#not configManager.isIntradayConfig() and configManager.calculatersiintraday:
-        candleDuration = (userPassedArgs.intraday if (userPassedArgs is not None and userPassedArgs.intraday is not None) else "1m")
-        configManager.toggleConfig(candleDuration=candleDuration,clearCache=False)
-        # We also need to load the intraday data to be able to calculate intraday RSI
-        stockDictSecondary = Utility.tools.loadStockData(
-                        stockDictSecondary,
-                        configManager,
-                        downloadOnly=downloadOnly,
-                        defaultAnswer=defaultAnswer,
-                        forceLoad=(menuOption in ["X", "B", "G", "S"]),
-                        stockCodes = listStockCodes,
-                        isIntraday=True,
-                        exchangeSuffix = "" if (indexOption == 15 or (configManager.defaultIndex == 15 and indexOption == 0)) else ".NS"
-                )
-        resetConfigToDefault()
-    loadedStockData = True
-    return stockDictPrimary, stockDictSecondary
-
-def getLatestTradeDateTime(stockDictPrimary):
-    stocks = list(stockDictPrimary.keys())
-    stock = stocks[0]
-    try:
-        lastTradeDate = PKDateUtilities.currentDateTime().strftime("%Y-%m-%d")
-        lastTradeTime_ist = PKDateUtilities.currentDateTime().strftime("%H:%M:%S")
-        df = pd.DataFrame(data=stockDictPrimary[stock]["data"],
-                        columns=stockDictPrimary[stock]["columns"],
-                        index=stockDictPrimary[stock]["index"])
-        ts = df.index[-1]
-        lastTraded = pd.to_datetime(ts, unit='s', utc=True) #.tz_convert("Asia/Kolkata")
-        lastTradeDate = lastTraded.strftime("%Y-%m-%d")
-        lastTradeTime = lastTraded.strftime("%H:%M:%S")
-        if lastTradeTime == "00:00:00":
-            lastTradeTime = lastTradeTime_ist
-    except:
-        pass
-    return lastTradeDate, lastTradeTime
-
-def FinishBacktestDataCleanup(backtest_df, df_xray):
-    showBacktestResults(df_xray, sortKey="Date", optionalName="Insights")
-    summary_df = backtestSummary(backtest_df)
-    backtest_df.loc[:, "Date"] = backtest_df.loc[:, "Date"].apply(
-                lambda x: x.replace("-", "/")
-            )
-    showBacktestResults(backtest_df)
-    showBacktestResults(summary_df, optionalName="Summary")
-    sorting = False if defaultAnswer is not None else True
-    sortKeys = {
-                "S": "Stock",
-                "D": "Date",
-                "1": "1-Pd",
-                "2": "2-Pd",
-                "3": "3-Pd",
-                "4": "4-Pd",
-                "5": "5-Pd",
-                "10": "10-Pd",
-                "15": "15-Pd",
-                "22": "22-Pd",
-                "30": "30-Pd",
-                "T": "Trend",
-                "V": "Volume",
-                "M": "MA-Signal",
-            }
-    if configManager.enablePortfolioCalculations:
-        if 'RUNNER' not in os.environ.keys():
-            task1 = PKTask("PortfolioLedger",long_running_fn=PortfolioCollection().getPortfoliosAsDataframe)
-            task2 = PKTask("PortfolioLedgerSnapshots",long_running_fn=PortfolioCollection().getLedgerSummaryAsDataframe)
-            tasksList = [task1,task2]
-            PKScheduler.scheduleTasks(tasksList=tasksList, label=f"Portfolio Calculations Report Export(Total={len(tasksList)})",timeout=600)
-        else:
-            for task in tasksList:
-                task.long_running_fn(*(task,))
-        for task in tasksList:
-            if task.result is not None:
-                showBacktestResults(task.result, sortKey=None, optionalName=task.taskName)
-    
-    return summary_df,sorting,sortKeys
-
-def addOrRunPipedMenus():
-    global userPassedArgs
-    # User must have selected menu "P" earlier
-    savedPipes = f"{userPassedArgs.pipedmenus}:>|" if len(userPassedArgs.pipedmenus) > 0 else ""
-    userPassedArgs.pipedmenus = f"{savedPipes}{userPassedArgs.options}:D:D:D:"
-    userPassedArgs.pipedmenus = userPassedArgs.pipedmenus.replace("::",":D:")
-    userPassedArgs.pipedmenus = f"{userPassedArgs.pipedmenus}{('i '+configManager.duration) if configManager.isIntradayConfig() else ''}"
-    updateMenuChoiceHierarchy()
-    OutputControls().printOutput(
-            colorText.GREEN
-            + f"[+] {len(userPassedArgs.pipedmenus.split('|'))} Scanners piped so far: {colorText.END}{colorText.WARN+userPassedArgs.pipedmenus+colorText.END}\n{colorText.GREEN}[+] Do you want to add any more scanners into the pipe?"
-            + colorText.END
-        )
-    shouldAddMoreIntoPipe = input(colorText.FAIL + "[+] Select [Y/N] (Default:N): " + colorText.END) or 'n'
-    if shouldAddMoreIntoPipe.lower() != 'y':
-        launcher = sys.argv[0]
-        launcher = f"python3.11 {launcher}" if launcher.endswith(".py") else launcher
-        monitorOption = f'"{userPassedArgs.pipedmenus}"'
-        scannerOptionQuoted = monitorOption.replace("'",'"').replace(":>",":D:D:D:>").replace("::",":")
-        OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener with piped scanners. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -e -o {scannerOptionQuoted}{colorText.END}")
-        sleep(2)
-        os.system(f"{launcher} --systemlaunched -a Y -e -o {scannerOptionQuoted}")
-        userPassedArgs.pipedmenus = None
-        OutputControls().printOutput(
-                colorText.GREEN
-                + f"[+] Finished running all piped scanners!"
-                + colorText.END
-            )
-        if defaultAnswer is None:
-            input("Press <Enter> to exit...")
-        sys.exit(0)
-    else:
-        userPassedArgs.options = None
-        return None, None
-    
-def prepareGroupedXRay(backtestPeriod, backtest_df):
-    df_grouped = backtest_df.groupby("Date")
-    userPassedArgs.backtestdaysago = backtestPeriod
-    df_xray = None
-    groupCounter = 0
-    tasksList=[]
-    for calcForDate, df_group in df_grouped:
-        groupCounter += 1
-        func_args = (df_group, userPassedArgs, calcForDate,f"Portfolio X-Ray | {calcForDate} | {groupCounter} of {len(df_grouped)}")
-        task = PKTask(f"Portfolio X-Ray | {calcForDate} | {groupCounter} of {len(df_grouped)}",
-                      long_running_fn=PortfolioXRay.performXRay,
-                      long_running_fn_args=func_args)
-        task.total = len(df_grouped)
-        tasksList.append(task)
-    if 'RUNNER' not in os.environ.keys():
-        # if configManager.enablePortfolioCalculations:
-        # On Github CI, we may run out of memory because of saving results in
-        # shared multiprocessing dict.
-        PKScheduler.scheduleTasks(tasksList,f"Portfolio X-Ray for ({len(df_grouped)})", showProgressBars=False,timeout=600)
-    else:
-        # On Github CI, let's run synchronously.
-        for task in tasksList:
-            task.long_running_fn(*(task,))
-    for task in tasksList:
-        p_df = task.result
-        if p_df is not None:
-            if df_xray is not None:
-                df_xray = pd.concat([df_xray, p_df.copy()], axis=0)
-            else:
-                df_xray = p_df.copy()
-            # Let's drop the columns no longer required for backtest report
-
-    removedUnusedColumns(None, backtest_df, ["Consol.", "Breakout", "RSI", "Pattern", "CCI"], userArgs=userPassedArgs)
-    df_xray = df_xray.replace(np.nan, "", regex=True)
-    df_xray = PortfolioXRay.xRaySummary(df_xray)
-    df_xray.loc[:, "Date"] = df_xray.loc[:, "Date"].apply(
-                lambda x: x.replace("-", "/")
-            )
-    
-    return df_xray
-
-def showSortedBacktestData(backtest_df, summary_df, sortKeys):
-    OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + "[+] Would you like to sort the results?"
-                    + colorText.END
-                )
-    OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.GREEN
-                    + "[+] Press :\n [+] s, v, t, m : sort by Stocks, Volume, Trend, MA-Signal\n [+] d : sort by date\n [+] 1,2,3...30 : sort by period\n [+] n : Exit sorting\n"
-                    + colorText.END
-                )
-    if defaultAnswer is None:
-        choice = input(
-                        colorText.BOLD + colorText.FAIL + "[+] Select option:"
-                    )
-        OutputControls().printOutput(colorText.END, end="")
-        if choice.upper() in sortKeys.keys():
-            Utility.tools.clearScreen()
-            showBacktestResults(backtest_df, sortKeys[choice.upper()])
-            showBacktestResults(summary_df, optionalName="Summary")
-        else:
-            sorting = False
-    else:
-        OutputControls().printOutput("Finished backtesting!")
-        sorting = False
-    return sorting
-
-def resetConfigToDefault():
-    global userPassedArgs
-    isIntraday = userPassedArgs is not None and userPassedArgs.intraday is not None
-    if configManager.isIntradayConfig() or isIntraday:
-        configManager.toggleConfig(candleDuration="1d", clearCache=False)
-    if userPassedArgs is not None and userPassedArgs.monitor is None:
-        if "PKDevTools_Default_Log_Level" in os.environ.keys():
-            if userPassedArgs is None or (userPassedArgs is not None and userPassedArgs.options is not None and "|" not in userPassedArgs.options):
-                del os.environ['PKDevTools_Default_Log_Level']
-        configManager.logsEnabled = False
-    configManager.setConfig(ConfigManager.parser,default=True,showFileCreatedText=False)
-
-def prepareStocksForScreening(testing, downloadOnly, listStockCodes, indexOption):
-    if not downloadOnly:
-        updateMenuChoiceHierarchy()
-    indexOption = int(indexOption)
-    if listStockCodes is None or len(listStockCodes) == 0:
-        if indexOption >= 0 and indexOption <= 14:
-            shouldSuppress = not OutputControls().enableMultipleLineOutput
-            with SuppressOutput(suppress_stderr=shouldSuppress, suppress_stdout=shouldSuppress):
-                listStockCodes = fetcher.fetchStockCodes(
-                                indexOption, stockCode=None
-                            )
-        elif indexOption == 15:
-            OutputControls().printOutput(colorText.BOLD + "[+] Getting Stock Codes From NASDAQ... ", end="")
-            nasdaq = PKNasdaqIndexFetcher(configManager)
-            listStockCodes = nasdaq.fetchNasdaqIndexConstituents()
-            if len(listStockCodes) > 10:
-                OutputControls().printOutput(
-                    colorText.GREEN
-                    + ("=> Done! Fetched %d stock codes." % len(listStockCodes))
-                    + colorText.END
-                )
-                if configManager.shuffleEnabled:
-                    random.shuffle(listStockCodes)
-                    OutputControls().printOutput(
-                        colorText.BLUE
-                        + "[+] Stock shuffling is active."
-                        + colorText.END
-                    )
-            else:
-                OutputControls().printOutput(
-                    colorText.FAIL
-                    + ("=> Failed! Could not fetch stock codes from NASDAQ!")
-                    + colorText.END
-                )
-        if (listStockCodes is None or len(listStockCodes) == 0) and testing:
-            listStockCodes = [TEST_STKCODE if indexOption < 15 else "AMD"]
-    if indexOption == 0:
-        selectedChoice["3"] = ".".join(listStockCodes)
-    if testing:
-        listStockCodes = [random.choice(listStockCodes)]
-    return listStockCodes
-
-def handleMonitorFiveEMA():
-    result_df = pd.DataFrame(
-                    columns=["Time", "Stock/Index", "Action", "SL", "Target", "R:R"]
-                )
-    last_signal = {}
-    first_scan = True
-    result_df = screener.monitorFiveEma(  # Dummy scan to avoid blank table on 1st scan
-                    fetcher=fetcher,
-                    result_df=result_df,
-                    last_signal=last_signal,
-                )
-    try:
-        while True:
-            Utility.tools.clearScreen()
-            last_result_len = len(result_df)
-            try:
-                result_df = screener.monitorFiveEma(
-                                fetcher=fetcher,
-                                result_df=result_df,
-                                last_signal=last_signal,
-                            )
-            except Exception as e:  # pragma: no cover
-                default_logger().debug(e, exc_info=True)
-                OutputControls().printOutput(
-                                colorText.BOLD
-                                + colorText.FAIL
-                                + "[+] There was an exception while monitoring 5-EMA"
-                                + "\n[+] If this continues to happen, please try and run with -l"
-                                + "\n[+] and collect all the logs, zip it and submit it to the developer."
-                                + "\n[+] For example:"
-                                + colorText.END
-                                + colorText.WARN
-                                + "pkscreener -l\n"
-                                + colorText.END
-                            )
-            OutputControls().printOutput(
-                            colorText.BOLD
-                            + colorText.WARN
-                            + "[+] 5-EMA : Live Intraday Scanner \t"
-                            + colorText.END
-                            + colorText.FAIL
-                            + f'Last Scanned: {datetime.now().strftime("%H:%M:%S")}\n'
-                            + colorText.END
-                        )
-            if result_df is not None and len(result_df) > 0:
-                OutputControls().printOutput(
-                                colorText.miniTabulator().tabulate(
-                                    result_df,
-                                    headers="keys",
-                                    tablefmt=colorText.No_Pad_GridFormat,
-                                    maxcolwidths=Utility.tools.getMaxColumnWidths(result_df)
-                                ).encode("utf-8").decode(STD_ENCODING)
-                            )
-            OutputControls().printOutput("\nPress Ctrl+C to exit.")
-            if result_df is not None and len(result_df) != last_result_len and not first_scan:
-                Utility.tools.alertSound(beeps=5)
-            sleep(60)
-            first_scan = False
-    except KeyboardInterrupt:
-        input("\nPress <Enter> to Continue...\n")
-        return
-
-def handleRequestForSpecificStocks(options, indexOption):
-    listStockCodes = []
-    strOptions = ""
-    if isinstance(options, list):
-        strOptions = ":".join(options).split(">")[0]
-    else:
-        strOptions = options.split(">")[0]
-    
-    if indexOption == 0:
-        if len(strOptions) >= 4:
-            strOptions = strOptions.replace(":D:",":").replace(">","")
-            providedOptions = strOptions.split(":")
-            for option in providedOptions:
-                if not "".join(str(option).split(".")).isdecimal() and len(option.strip()) > 1:
-                    listStockCodes = str(option.strip()).split(",")
-                    break
-    return listStockCodes
-
-def handleExitRequest(executeOption):
-    if executeOption == "Z":
-        input(
-            colorText.BOLD
-            + colorText.FAIL
-            + "[+] Press <Enter> to Exit!"
-            + colorText.END
-        )
-        sys.exit(0)
-
-def handleMenu_XBG(menuOption, indexOption, executeOption):
-    if menuOption in ["X", "B", "G","C"]:
-        selMenu = m0.find(menuOption)
-        m1.renderForMenu(selMenu, asList=True)
-        if indexOption is not None:
-            selMenu = m1.find(indexOption)
-            m2.renderForMenu(selMenu, asList=True)
-            if executeOption is not None:
-                selMenu = m2.find(executeOption)
-                m3.renderForMenu(selMenu, asList=True)
-
-
-def updateMenuChoiceHierarchy():
-    global userPassedArgs, selectedChoice, menuChoiceHierarchy
-    try:
-        menuChoiceHierarchy = f'{level0MenuDict[selectedChoice["0"]].strip()}>{level1_X_MenuDict[selectedChoice["1"]].strip()}>{level2_X_MenuDict[selectedChoice["2"]].strip()}'
-        if selectedChoice["2"] == "6":
-            menuChoiceHierarchy = (
-                menuChoiceHierarchy
-                + f'>{level3_X_Reversal_MenuDict[selectedChoice["3"]].strip()}'
-            )
-            if len(selectedChoice) >= 5 and selectedChoice["3"] in ["7","10"]:
-                menuChoiceHierarchy = (
-                menuChoiceHierarchy
-                + f'>{level4_X_Lorenzian_MenuDict[selectedChoice["4"]].strip()}'
-            )
-        elif selectedChoice["2"] in ["30"]:
-            if len(selectedChoice) >= 3:
-                menuChoiceHierarchy = (
-                menuChoiceHierarchy
-                + f'>{level4_X_Lorenzian_MenuDict[selectedChoice["3"]].strip()}'
-            )
-        elif selectedChoice["2"] == "7":
-            menuChoiceHierarchy = (
-                menuChoiceHierarchy
-                + f'>{level3_X_ChartPattern_MenuDict[selectedChoice["3"]].strip()}'
-            )
-            if len(selectedChoice) >= 5 and selectedChoice["3"] == "3":
-                menuChoiceHierarchy = (
-                menuChoiceHierarchy
-                + f'>{level4_X_ChartPattern_Confluence_MenuDict[selectedChoice["4"]].strip()}'
-            )
-            elif len(selectedChoice) >= 5 and selectedChoice["3"] == "6":
-                menuChoiceHierarchy = (
-                menuChoiceHierarchy
-                + f'>{level4_X_ChartPattern_BBands_SQZ_MenuDict[selectedChoice["4"]].strip()}'
-            )
-        elif selectedChoice["2"] == "21":
-            menuChoiceHierarchy = (
-                menuChoiceHierarchy
-                + f'>{level3_X_PopularStocks_MenuDict[selectedChoice["3"]].strip()}'
-            )
-        intraday = "(Intraday)" if (userPassedArgs is not None and userPassedArgs.intraday) or configManager.isIntradayConfig() else ""
-        menuChoiceHierarchy = f"{menuChoiceHierarchy}{intraday}"
-        global nValueForMenu
-        menuChoiceHierarchy = menuChoiceHierarchy.replace("N-",f"{nValueForMenu}-")
-    except:
-        pass
-    Utility.tools.clearScreen(forceTop=True)
-    OutputControls().printOutput(
-        colorText.BOLD
-        + colorText.FAIL
-        + "[+] You chose: "
-        + menuChoiceHierarchy
-        + (f" (Piped Scan Mode) [{userPassedArgs.pipedmenus}]" if (userPassedArgs is not None and userPassedArgs.pipedmenus is not None) else "")
-        + colorText.END
-    )
-    default_logger().info(menuChoiceHierarchy)
-    return menuChoiceHierarchy
-
-def printNotifySaveScreenedResults(
-    screenResults, saveResults, selectedChoice, menuChoiceHierarchy, testing, user=None
-):
-    global userPassedArgs, elapsed_time
-    if userPassedArgs.monitor is not None:
-        return
-    MAX_ALLOWED = (100 if userPassedArgs.maxdisplayresults is None else min(int(userPassedArgs.maxdisplayresults),100)) if not testing else 1
-    tabulated_backtest_summary = ""
-    tabulated_backtest_detail = ""
-    recordDate = PKDateUtilities.tradingDate().strftime('%Y-%m-%d') if (userPassedArgs.backtestdaysago is None) else (PKDateUtilities.nthPastTradingDateStringFromFutureDate(int(userPassedArgs.backtestdaysago)))
-    if user is None and userPassedArgs.user is not None:
-        user = userPassedArgs.user
-    Utility.tools.clearScreen(forceTop=True)
-    if screenResults is not None and len(screenResults) > 0:
-        screenResults = screenResults[~screenResults.index.duplicated(keep='first')]
-        saveResults = saveResults[~saveResults.index.duplicated(keep='first')]
-        if "Stock" in screenResults.columns:
-            screenResults.drop_duplicates(keep="first", inplace=True)
-        if "Stock" in saveResults.columns:
-            saveResults.drop_duplicates(keep="first", inplace=True)
-    
-    reportTitle = f"{userPassedArgs.pipedtitle}|" if userPassedArgs is not None and userPassedArgs.pipedtitle is not None else ""
-    OutputControls().printOutput(
-        colorText.BOLD
-        + colorText.FAIL
-        + f"[+] You chose: {reportTitle}{menuChoiceHierarchy}[{len(screenResults) if screenResults is not None and not screenResults.empty else 0}]"
-        + (f" (Piped Scan Mode) [{userPassedArgs.pipedmenus}]" if (userPassedArgs is not None and userPassedArgs.pipedmenus is not None) else "")
-        + colorText.END
-        , enableMultipleLineOutput=True
-    )
-    pngName = f'PKS_{PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)}_{PKDateUtilities.currentDateTime().strftime("%d-%m-%y_%H.%M.%S")}'
-    pngExtension = ".png"
-    eligible = is_token_telegram_configured()
-    targetDateG10k = prepareGrowthOf10kResults(saveResults, selectedChoice, menuChoiceHierarchy, testing, user, pngName, pngExtension, eligible)
-    if saveResults is not None and "Date" in saveResults.columns and len(saveResults) > 0:
-        recordDate = saveResults["Date"].iloc[0].replace("/","-")
-    summaryReturns = removedUnusedColumns(screenResults, saveResults, ["Date","Breakout","Resistance"],userArgs=userPassedArgs)
-
-    tabulated_results = ""
-    if screenResults is not None and len(screenResults) > 0:
-        tabulated_results = colorText.miniTabulator().tabulate(
-            screenResults, headers="keys", tablefmt=colorText.No_Pad_GridFormat,
-            maxcolwidths=Utility.tools.getMaxColumnWidths(screenResults)
-        ).encode("utf-8").decode(STD_ENCODING)
-    OutputControls().printOutput(f"{tabulated_results}\n", enableMultipleLineOutput=True)
-    _, reportNameInsights = getBacktestReportFilename(
-        sortKey="Date", optionalName="Insights"
-    )
-    strategy_df = PortfolioXRay.bestStrategiesFromSummaryForReport(reportNameInsights,includeLargestDatasets=True)
-    addendumLabel = (
-        "[+] Strategies that have best results in the past for this scan option (calculated with 1 stock each with matching strategy in the result):"
-    )
-    tabulated_strategy = ""
-    if strategy_df is not None and len(strategy_df) > 0:
-        tabulated_strategy = colorText.miniTabulator().tabulate(
-            strategy_df,
-            headers="keys",
-            tablefmt=colorText.No_Pad_GridFormat,
-            showindex=False,
-            maxcolwidths=Utility.tools.getMaxColumnWidths(strategy_df)
-        ).encode("utf-8").decode(STD_ENCODING)
-        OutputControls().printOutput(addendumLabel)
-        OutputControls().printOutput(tabulated_strategy)
-    if screenResults is not None and len(screenResults) >= 1:
-        choiceSegments = menuChoiceHierarchy.split(">")
-        choiceSegments = f"{choiceSegments[-2]} > {choiceSegments[-1]}" if len(choiceSegments)>=4 else f"{choiceSegments[-1]}"
-        pipedTitle = f"{userPassedArgs.pipedtitle}|" if userPassedArgs.pipedtitle is not None else ""
-        pipedTitle = f'| Piped Results: {pipedTitle}{choiceSegments}[{len(saveResults)}]' if len(pipedTitle) > 0 else ""
-        pipedTitle = pipedTitle.replace("[","<b>[").replace("]","]</b>")
-        title = f'<b>{reportTitle}{choiceSegments}</b>{"" if selectedChoice["0"] != "G" else " for Date:"+ targetDateG10k}'
-        if (
-            ("RUNNER" in os.environ.keys() and os.environ["RUNNER"] != "LOCAL_RUN_SCANNER")
-            or "PKDevTools_Default_Log_Level" in os.environ.keys()
-        ):
-            if eligible:
-                # There's no need to save data locally.
-                # This scan must have been triggered by github workflow by a user or scheduled job
-                # Let's just send the image result to telegram
-                screenResultsTrimmed = screenResults.copy()
-                saveResultsTrimmed = saveResults.copy()
-                # No point sending a photo with more than MAX_ALLOWED stocks.
-                warn_text = (
-                    f" but showing only {MAX_ALLOWED}. "
-                    if (len(saveResults) > MAX_ALLOWED)
-                    else ""
-                )
-                caption = f"{title}"
-                elapsed_text = f"<i>({len(saveResults)}{'+' if (len(saveResults) > MAX_ALLOWED) else ''} stocks found in {str(int(elapsed_time))} sec.){warn_text}</i>"
-                backtestExtension = "_backtest.png"
-                if len(screenResultsTrimmed) > MAX_ALLOWED:
-                    screenResultsTrimmed = screenResultsTrimmed.head(MAX_ALLOWED)
-                    saveResultsTrimmed = saveResultsTrimmed.head(MAX_ALLOWED)
-                    if saveResultsTrimmed is not None and len(saveResultsTrimmed) > 0:
-                        tabulated_results = colorText.miniTabulator().tabulate(
-                            screenResultsTrimmed,
-                            headers="keys",
-                            tablefmt=colorText.No_Pad_GridFormat,
-                            maxcolwidths=Utility.tools.getMaxColumnWidths(screenResultsTrimmed)
-                        ).encode("utf-8").decode(STD_ENCODING)
-                markdown_results = ""
-                if saveResultsTrimmed is not None and len(saveResultsTrimmed) > 0:
-                    markdown_results = colorText.miniTabulator().tabulate(
-                        saveResultsTrimmed,
-                        headers="keys",
-                        tablefmt=colorText.No_Pad_GridFormat,
-                        maxcolwidths=Utility.tools.getMaxColumnWidths(saveResultsTrimmed)
-                    ).encode("utf-8").decode(STD_ENCODING)
-                    caption_df = saveResultsTrimmed[['LTP','%Chng','Volume']].head(5)
-                    caption_df.loc[:, "LTP"] = caption_df.loc[:, "LTP"].apply(
-                        lambda x: str(int(round(float(x),0)))
-                    )
-                    caption_df.loc[:, "%Chng"] = caption_df.loc[:, "%Chng"].apply(
-                        lambda x: f'{int(round(float(x.replace("%","")),0))}%'
-                    )
-                    caption_df.loc[:, "Volume"] = caption_df.loc[:, "Volume"].apply(
-                        lambda x: f'{int(round(float(x.replace("x","")),0))}x' if (len(x.replace("x","").strip()) > 0 and not pd.isna(float(x.replace("x","")))) else ''
-                    )
-                    caption_df.rename(columns={"%Chng": "Ch%","Volume":"Vol"}, inplace=True)
-                    for col in caption_df.columns:
-                        caption_df[col] = caption_df[col].astype(str)
-                    caption_results = colorText.miniTabulator().tabulate(
-                        caption_df,
-                        headers="keys",
-                        tablefmt=colorText.No_Pad_GridFormat,
-                        maxcolwidths=[None,None,4,3]
-                    ).encode("utf-8").decode(STD_ENCODING).replace("-K-----S-----C-----R","-K-----S----C---R").replace("%  ","% ").replace("=K=====S=====C=====R","=K=====S====C===R").replace("Vol  |","Vol|").replace("x  ","x")
-                    caption_results = caption_results.replace("-E-----N-----E-----R","-E-----N----E---R").replace("=E=====N=====E=====R","=E=====N====E===R")
-                    caption = f"{caption}.Open attached image for more. Samples:<pre>{caption_results}</pre>{elapsed_text}{pipedTitle}" #<i>Author is <u><b>NOT</b> a SEBI registered financial advisor</u> and MUST NOT be deemed as one.</i>"
-                if not testing: # and not userPassedArgs.runintradayanalysis:
-                    sendQuickScanResult(
-                        f"{reportTitle}{menuChoiceHierarchy}",
-                        user,
-                        tabulated_results,
-                        markdown_results,
-                        caption,
-                        pngName,
-                        pngExtension,
-                        addendum=tabulated_strategy,
-                        addendumLabel=addendumLabel,
-                    )
-                    # Let's send the backtest results now only if the user requested 1-on-1 for scan.
-                    if user is not None:
-                        # Now let's try and send backtest results
-                        (
-                            tabulated_backtest_summary,
-                            tabulated_backtest_detail,
-                        ) = tabulateBacktestResults(
-                            saveResultsTrimmed, maxAllowed=MAX_ALLOWED, force=True
-                        )
-                        try:
-                            # import traceback
-                            Utility.tools.tableToImage(
-                                "",
-                                "",
-                                pngName + backtestExtension,
-                                menuChoiceHierarchy,
-                                backtestSummary=tabulated_backtest_summary,
-                                backtestDetail=tabulated_backtest_detail,
-                            )
-                            caption = f"Backtest data for stocks listed in <b>{title}</b> scan results. See more past backtest data at https://pkjmesra.github.io/PKScreener/BacktestReports.html"
-                            sendMessageToTelegramChannel(
-                                message=None,
-                                document_filePath=pngName + backtestExtension,
-                                caption=caption,
-                                user=user,
-                            )
-                            os.remove(pngName + backtestExtension)
-                        except Exception as e:  # pragma: no cover
-                            default_logger().debug(e, exc_info=True)
-                            pass
-                            # OutputControls().printOutput(e)
-                            # traceback.print_exc()
-                    else:
-                        tabulateBacktestResults(saveResults)
-            else:
-                tabulateBacktestResults(saveResults)
-        else:
-            tabulateBacktestResults(saveResults)
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.GREEN
-                + f"[+] Found {len(screenResults) if screenResults is not None else 0} Stocks in {str('{:.2f}'.format(elapsed_time))} sec. Showing only stocks that met the filter criteria in the filters section of user configuration{(' with portfolio returns:' + summaryReturns) if (len(summaryReturns) > 0) else ''}"
-                + colorText.END
-            )
-    elif user is not None:
-        sendMessageToTelegramChannel(
-            message=f"No scan results found for {menuChoiceHierarchy}", user=user
-        )
-    if not testing:
-        Utility.tools.setLastScreenedResults(screenResults, saveResults, f"{PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)}_{recordDate if recordDate is not None else ''}")
-
-def prepareGrowthOf10kResults(saveResults, selectedChoice, menuChoiceHierarchy, testing, user, pngName, pngExtension, eligible):
-    targetDateG10k = None
-    if selectedChoice["0"] == "G" or \
-        (userPassedArgs.backtestdaysago is not None and 
-         int(userPassedArgs.backtestdaysago) > 0 and 
-         "RUNNER" not in os.environ.keys()):
-        if saveResults is not None and len(saveResults) > 0:
-            df = PortfolioXRay.performXRay(saveResults, userPassedArgs,None, None)
-            targetDateG10k = saveResults["Date"].iloc[0]
-            if df is not None and len(df) > 0:
-                titleLabelG10k = f"For {userPassedArgs.backtestdaysago}-Period(s) from {targetDateG10k}, portfolio calculations in terms of Growth of 10k:"
-                g10kStyledTable = colorText.miniTabulator().tabulate(
-                    df,
-                    headers="keys",
-                    tablefmt=colorText.No_Pad_GridFormat,
-                    showindex=False,
-                    maxcolwidths=Utility.tools.getMaxColumnWidths(df)
-                ).encode("utf-8").decode(STD_ENCODING)
-                # Show only if the configuration dicttates showing strategy data
-                if configManager.showPastStrategyData:
-                    OutputControls().printOutput(f"\n\n{titleLabelG10k}\n")
-                    OutputControls().printOutput(g10kStyledTable)
-                g10kUnStyledTable = Utility.tools.removeAllColorStyles(g10kStyledTable)
-                if not testing and eligible:
-                    sendQuickScanResult(
-                        menuChoiceHierarchy,
-                        user,
-                        g10kStyledTable,
-                        g10kUnStyledTable,
-                        titleLabelG10k,
-                        pngName,
-                        pngExtension,
-                    )
-        elif user is not None and eligible:
-            sendMessageToTelegramChannel(
-                message=f"No scan results found for {menuChoiceHierarchy}", user=user
-            )
-            
-    return targetDateG10k
-
-
-def removedUnusedColumns(screenResults, saveResults, dropAdditionalColumns=[], userArgs=None):
-    periods = configManager.periodsRange
-    if userArgs is not None and userArgs.backtestdaysago is not None and int(userArgs.backtestdaysago) < 22:
-        dropAdditionalColumns.append("22-Pd %")
-    summaryReturns = "" #("w.r.t. " + saveResults["Date"].iloc[0]) if "Date" in saveResults.columns else ""
-    for period in periods:
-        if saveResults is not None:
-            # if f"LTP{period}" in saveResults.columns and "MCapWt%" in saveResults.columns:
-            #     pdLTP = saveResults[f"LTP{period}"].replace("", np.nan).replace(np.inf, np.nan).replace(-np.inf, np.nan).astype(float)
-            #     mktWeight = saveResults["MCapWt%"].replace("", np.nan).replace(np.inf, np.nan).replace(-np.inf, np.nan).astype(float)
-            #     ltp = saveResults[f"LTP"].replace("", np.nan).replace(np.inf, np.nan).replace(-np.inf, np.nan).astype(float)
-            #     pdReturn = round(100*(sum(pdLTP * mktWeight)-sum(ltp * mktWeight))/sum(ltp * mktWeight),1)
-            #               #round((sum(saveResults[f"LTP{period}"]) - sum(saveResults['LTP']))*100/sum(saveResults['LTP']),1)
-            #     if pdReturn > -500:
-            #         summaryReturns = f"{period}-Pd({pdReturn} %), {summaryReturns}"
-            saveResults.drop(f"LTP{period}", axis=1, inplace=True, errors="ignore")
-            saveResults.drop(f"Growth{period}", axis=1, inplace=True, errors="ignore")
-            # saveResults.drop(f"MCapWt%", axis=1, inplace=True, errors="ignore")
-            # screenResults.drop(f"MCapWt%", axis=1, inplace=True, errors="ignore")
-            if len(dropAdditionalColumns) > 0:
-                for col in dropAdditionalColumns:
-                    if col in saveResults.columns:
-                        saveResults.drop(col, axis=1, inplace=True, errors="ignore")
-        if screenResults is not None:
-            screenResults.drop(f"LTP{period}", axis=1, inplace=True, errors="ignore")
-            screenResults.drop(f"Growth{period}", axis=1, inplace=True, errors="ignore")
-            if len(dropAdditionalColumns) > 0:
-                for col in dropAdditionalColumns:
-                    if col in screenResults.columns:
-                        screenResults.drop(col, axis=1, inplace=True, errors="ignore")
-    return summaryReturns
-
-
-def tabulateBacktestResults(saveResults, maxAllowed=0, force=False):
-    if "PKDevTools_Default_Log_Level" not in os.environ.keys():
-        if ("RUNNER" not in os.environ.keys()) or ("RUNNER" in os.environ.keys() and not force):
-            return None, None
-    if not configManager.showPastStrategyData:
-        return None, None
-    tabulated_backtest_summary = ""
-    tabulated_backtest_detail = ""
-    summarydf, detaildf = getSummaryCorrectnessOfStrategy(saveResults)
-    if summarydf is not None and len(summarydf) > 0:
-        tabulated_backtest_summary = colorText.miniTabulator().tabulate(
-            summarydf,
-            headers="keys",
-            tablefmt=colorText.No_Pad_GridFormat,
-            showindex=False,
-            maxcolwidths=Utility.tools.getMaxColumnWidths(summarydf)
-        ).encode("utf-8").decode(STD_ENCODING)
-    if detaildf is not None and len(detaildf) > 0:
-        if maxAllowed != 0 and len(detaildf) > 2 * maxAllowed:
-            detaildf = detaildf.head(2 * maxAllowed)
-        tabulated_backtest_detail = colorText.miniTabulator().tabulate(
-            detaildf,
-            headers="keys",
-            tablefmt=colorText.No_Pad_GridFormat,
-            showindex=False,
-            maxcolwidths=Utility.tools.getMaxColumnWidths(detaildf)
-        ).encode("utf-8").decode(STD_ENCODING)
-    if tabulated_backtest_summary != "":
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + "\n[+] For chosen scan, summary of correctness from past: [Example, 70% of (100) under 1-Pd, means out of 100 stocks that were in the scan result in the past, 70% of them gained next day.)"
-            + colorText.END
-        )
-        OutputControls().printOutput(tabulated_backtest_summary)
-    if tabulated_backtest_detail != "":
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + "\n[+] 1 to 30 period gain/loss % on respective date for matching stocks from earlier predictions:[Example, 5% under 1-Pd, means the stock price actually gained 5% the next day from given date.]"
-            + colorText.END
-        )
-        OutputControls().printOutput(tabulated_backtest_detail)
-    return tabulated_backtest_summary, tabulated_backtest_detail
-
-
-def sendQuickScanResult(
-    menuChoiceHierarchy,
-    user,
-    tabulated_results,
-    markdown_results,
-    caption,
-    pngName,
-    pngExtension,
-    addendum=None,
-    addendumLabel=None,
-    backtestSummary="",
-    backtestDetail="",
-    summaryLabel = None,
-    detailLabel = None,
-    legendPrefixText = ""
-):
-    if "PKDevTools_Default_Log_Level" not in os.environ.keys():
-        if (("RUNNER" not in os.environ.keys()) or ("RUNNER" in os.environ.keys() and os.environ["RUNNER"] == "LOCAL_RUN_SCANNER")):
-            return
-    try:
-        Utility.tools.tableToImage(
-            markdown_results,
-            tabulated_results,
-            pngName + pngExtension,
-            menuChoiceHierarchy,
-            backtestSummary=backtestSummary,
-            backtestDetail=backtestDetail,
-            addendum=addendum,
-            addendumLabel=addendumLabel,
-            summaryLabel = summaryLabel,
-            detailLabel = detailLabel,
-            legendPrefixText = legendPrefixText
-        )
-        sendMessageToTelegramChannel(
-            message=None,
-            document_filePath=pngName + pngExtension,
-            caption=caption,
-            user=user,
-        )
-        os.remove(pngName + pngExtension)
-    except Exception as e:  # pragma: no cover
-        default_logger().debug(e, exc_info=True)
-        pass
-
-
-def reformatTable(summaryText, headerDict, colored_text, sorting=True):
-    if sorting:
-        tableText = "<!DOCTYPE html><html><head><script type='application/javascript' src='https://pkjmesra.github.io/PKScreener/pkscreener/classes/tableSorting.js' ></script><style type='text/css'>body, table {background-color: black; color: white;} table, th, td {border: 1px solid white;} th {cursor: pointer; color:white; text-decoration:underline;} .r {color:red;font-weight:bold;} .br {border-color:green;border-width:medium;} .w {color:white;font-weight:bold;} .g {color:lightgreen;font-weight:bold;} .y {color:yellow;} .bg {background-color:darkslategrey;} .bb {background-color:black;} input#searchReports { width: 220px; } table thead tr th { background-color: black; position: sticky; z-index: 100; top: 0; } </style></head><body><span style='color:white;' >"
-        colored_text = colored_text.replace(
-            "<table", f"{tableText}{summaryText}<br /><input type='text' id='searchReports' onkeyup='searchReportsByAny()' placeholder='Search for stock/scan reports..' title='Type in a name/ID'><table")
-        colored_text = colored_text.replace("<table ", "<table id='resultsTable' ")
-        colored_text = colored_text.replace('<tr style="text-align: right;">','<tr style="text-align: right;" class="header">')
-        for key in headerDict.keys():
-            if key > 0:
-                colored_text = colored_text.replace(
-                    headerDict[key], f"<th>{headerDict[key][4:]}"
-                )
-            else:
-                colored_text = colored_text.replace(
-                    headerDict[key], f"<th>Stock{headerDict[key][4:]}"
-                )
-    else:
-        colored_text = colored_text.replace('<table border="1" class="dataframe">', "")
-        colored_text = colored_text.replace("<tbody>", "")
-        colored_text = colored_text.replace("<tr>", "")
-        colored_text = colored_text.replace("</tr>", "")
-        colored_text = colored_text.replace("</tbody>", "")
-        colored_text = colored_text.replace("</table>", "")
-    colored_text = colored_text.replace(colorText.BOLD, "")
-    colored_text = colored_text.replace(f"{colorText.GREEN}", "<span class='g'>")
-    colored_text = colored_text.replace(f"{colorText.FAIL}", "<span class='r'>")
-    colored_text = colored_text.replace(f"{colorText.WARN}", "<span class='y'>")
-    colored_text = colored_text.replace(f"{colorText.WHITE}", "<span class='w'>")
-    colored_text = colored_text.replace("<td><span class='w'>","<td class='br'><span class='w'>")
-    colored_text = colored_text.replace(colorText.END, "</span>")
-    colored_text = colored_text.replace("\n", "")
-    if sorting:
-        colored_text = colored_text.replace("</table>", "</table></span></body></html>")
-    return colored_text
-
-
-def removeUnknowns(screenResults, saveResults):
-    for col in screenResults.keys():
-        screenResults = screenResults[
-            screenResults[col].astype(str).str.contains("Unknown") == False
-        ]
-    for col in saveResults.keys():
-        saveResults = saveResults[
-            saveResults[col].astype(str).str.contains("Unknown") == False
-        ]
-    return screenResults, saveResults
-
-# def apply_df_style(x):
-#     red = 'color: red'
-#     noColor = '' 
-#     green = 'color: green'
-#     #compare columns
-#     mask_green_bid = x['BidQty'] > x['AskQty']
-#     mask_red_bid = x['BidQty'] <= x['AskQty']
-#     mask_green_vwap = x['VWAP'] >= x['LTP']
-#     #DataFrame with same index and columns names as original filled empty strings
-#     df1 =  pd.DataFrame(noColor, index=x.index, columns=x.columns)
-#     #modify values of df1 column by boolean mask
-#     df1.loc[mask_green_bid, 'BidQty'] = green
-#     df1.loc[mask_red_bid, 'AskQty'] = red
-#     df1.loc[mask_green_vwap, 'VWAP'] = green
-#     return df1
-
-def runScanners(
-    menuOption,
-    items,
-    tasks_queue,
-    results_queue,
-    numStocks,
-    backtestPeriod,
-    iterations,
-    consumers,
-    screenResults,
-    saveResults,
-    backtest_df,
-    testing=False,
-):
-    global selectedChoice, userPassedArgs, elapsed_time, start_time,userPassedArgs
-    result = None
-    backtest_df = None
-    reviewDate = getReviewDate(userPassedArgs)
-    max_allowed = getMaxAllowedResultsCount(iterations, testing)
-    try:
-        originalNumberOfStocks = numStocks
-        iterations, numStocksPerIteration = getIterationsAndStockCounts(numStocks, iterations)
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.GREEN
-            + f"[+] For {reviewDate}, total Stocks under review: {numStocks} over {iterations} iterations..."
-            + colorText.END
-        )
-        if not userPassedArgs.download:
-            OutputControls().printOutput(colorText.WARN
-                + f"[+] Starting {'Stock' if menuOption not in ['C'] else 'Intraday'} {'Screening' if menuOption=='X' else ('Analysis' if menuOption == 'C' else 'Backtesting.')}. Press Ctrl+C to stop!"
-                + colorText.END
-            )
-        else:
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + f"[+] Download ONLY mode (OHLCV for period:{configManager.period}, candle-duration:{configManager.duration} )! Stocks will not be screened!"
-                + colorText.END
-            )
-        bar, spinner = Utility.tools.getProgressbarStyle()
-        with alive_bar(numStocks, bar=bar, spinner=spinner) as progressbar:
-            lstscreen = []
-            lstsave = []
-            result = None
-            backtest_df = None
-            start_time = time.time()
-
-            def processResultsCallback(resultItem, processedCount,result_df, *otherArgs):
-                global userPassedArgs
-                (menuOption, backtestPeriod, result, lstscreen, lstsave) = otherArgs
-                numStocks = processedCount
-                result = resultItem
-                backtest_df = processResults(menuOption, backtestPeriod, result, lstscreen, lstsave, result_df)
-                progressbar()
-                progressbar.text(
-                    colorText.BOLD
-                    + colorText.GREEN
-                    + f"{'Remaining' if userPassedArgs.download else ('Found' if menuOption in ['X'] else 'Analysed')} {len(lstscreen) if not userPassedArgs.download else processedCount} {'Stocks' if menuOption in ['X'] else 'Records'}"
-                    + colorText.END
-                )
-                if result is not None:
-                    if not userPassedArgs.monitor and len(lstscreen) > 0 and userPassedArgs is not None and userPassedArgs.options.split(":")[2] in ["29"]:
-                        scr_df = pd.DataFrame(lstscreen)
-                        existingColumns = ["Stock","%Chng","LTP","Volume"]
-                        newColumns = ["BidQty","AskQty","LwrCP","UprCP","VWAP","DayVola","Del(%)"]
-                        existingColumns.extend(newColumns)
-                        scr_df = scr_df[existingColumns]
-                        scr_df.sort_values(by=["Volume","BidQty"], ascending=False, inplace=True)
-                        tabulated_results = colorText.miniTabulator().tb.tabulate(
-                                scr_df,
-                                headers="keys",
-                                showindex=False,
-                                tablefmt=colorText.No_Pad_GridFormat,
-                                maxcolwidths=Utility.tools.getMaxColumnWidths(scr_df)
-                            )
-                        tableLength = 2*len(lstscreen)+5
-                        OutputControls().printOutput('\n'+tabulated_results)
-                        # Move the cursor up, back to the top because we want the progress bar to keep showing at the top
-                        sys.stdout.write(f"\x1b[{tableLength}A")  # cursor up one line
-                if keyboardInterruptEventFired:
-                    return False, backtest_df
-                return not ((testing and len(lstscreen) >= 1) or len(lstscreen) >= max_allowed), backtest_df
-            otherArgs = (menuOption, backtestPeriod, result, lstscreen, lstsave)
-            backtest_df, result =PKScanRunner.runScan(userPassedArgs,testing,numStocks,iterations,items,numStocksPerIteration,tasks_queue,results_queue,originalNumberOfStocks,backtest_df,*otherArgs,resultsReceivedCb=processResultsCallback)
-
-        OutputControls().printOutput(f"\x1b[{3 if OutputControls().enableMultipleLineOutput else 1}A")
-        if len(lstscreen) == 0 and userPassedArgs is not None and userPassedArgs.monitor is None:
-            OutputControls().printOutput("\x1b[2K") # Delete the progress bar line
-        elapsed_time = time.time() - start_time
-        if menuOption in ["X", "G", "C"]:
-            # create extension
-            screenResults = pd.DataFrame(lstscreen)
-            saveResults = pd.DataFrame(lstsave)
-
-    except KeyboardInterrupt:
-        try:
-            global keyboardInterruptEventFired
-            keyboardInterruptEvent.set()
-            keyboardInterruptEventFired = True
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "\n[+] Terminating Script, Please wait..."
-                + colorText.END
-            )
-            PKScanRunner.terminateAllWorkers(userPassedArgs=userPassedArgs,consumers=consumers, tasks_queue=tasks_queue,testing=testing)
-            logging.shutdown()
-        except KeyboardInterrupt:
-            pass
-    except Exception as e:
-        default_logger().debug(e, exc_info=True)
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + f"\nException:\n{e}\n[+] Terminating Script, Please wait..."
-            + colorText.END
-        )
-        PKScanRunner.terminateAllWorkers(userPassedArgs=userPassedArgs,consumers=consumers, tasks_queue=tasks_queue,testing=testing)
-        logging.shutdown()
-
-    if result is not None and len(result) >=3 and "Date" not in saveResults.columns:
-        temp_df = result[2].copy()
-        temp_df.reset_index(inplace=True)
-        temp_df = temp_df.tail(1)
-        temp_df.rename(columns={"index": "Date"}, inplace=True)
-        targetDate = (
-            temp_df["Date"].iloc[0]
-            if "Date" in temp_df.columns
-            else str(temp_df.iloc[:, 0][0])
-        )
-        saveResults["Date"] = str(targetDate).split(" ")[0]
-    return screenResults, saveResults, backtest_df
-
-        
-def processResults(menuOption, backtestPeriod, result, lstscreen, lstsave, backtest_df):
-    if result is not None:
-        lstscreen.append(result[0])
-        lstsave.append(result[1])
-        sampleDays = result[4]
-        if menuOption == "B":
-            backtest_df = updateBacktestResults(
-                            backtestPeriod,
-                            start_time,
-                            result,
-                            sampleDays,
-                            backtest_df,
-                        )
-            
-    return backtest_df
-
-def getReviewDate(userPassedArgs=None):
-    reviewDate = PKDateUtilities.tradingDate().strftime('%Y-%m-%d')
-    if userPassedArgs is not None and userPassedArgs.backtestdaysago is not None:
-        reviewDate = PKDateUtilities.nthPastTradingDateStringFromFutureDate(int(userPassedArgs.backtestdaysago))
-    return reviewDate
-
-def getMaxAllowedResultsCount(iterations, testing):
-    return iterations * (100 if userPassedArgs.maxdisplayresults is None else int(userPassedArgs.maxdisplayresults)) if not testing else 1
-
-def getIterationsAndStockCounts(numStocks, iterations):
-    if numStocks <= 2500:
-        return 1,numStocks
-    originalIterations = iterations
-        # If we put in more into the queue, it might cause the warnings from multiprocessing resource_tracker
-        # about semaphore leakages etc. This is, caused due to overallocating RAM.
-    idealNumStocksMaxPerIteration = 100
-    iterations = int(numStocks*iterations/idealNumStocksMaxPerIteration) + 1
-    numStocksPerIteration = int(numStocks/int(iterations))
-    if numStocksPerIteration < 10:
-        numStocksPerIteration = numStocks if (iterations == 1 or numStocks<= iterations) else int(numStocks/int(iterations))
-        iterations = originalIterations
-    if numStocksPerIteration > 500:
-        numStocksPerIteration = 500
-        iterations = int(numStocks/numStocksPerIteration) + 1
-    return iterations,numStocksPerIteration
-
-
-def updateBacktestResults(
-    backtestPeriod, start_time, result, sampleDays, backtest_df
-):
-    global elapsed_time
-    sellSignal = (
-        str(selectedChoice["2"]) in ["6", "7"] and str(selectedChoice["3"]) in ["2"]
-    ) or selectedChoice["2"] in ["15", "16", "19", "25"]
-    backtest_df = backtest(
-        result[3],
-        result[2],
-        result[1],
-        result[0],
-        backtestPeriod,
-        sampleDays,
-        backtest_df,
-        sellSignal,
-    )
-    elapsed_time = time.time() - start_time
-    return backtest_df
-
-
-def saveDownloadedData(downloadOnly, testing, stockDictPrimary, configManager, loadCount):
-    global userPassedArgs, keyboardInterruptEventFired
-    argsIntraday = userPassedArgs is not None and userPassedArgs.intraday is not None
-    intradayConfig = configManager.isIntradayConfig()
-    intraday = intradayConfig or argsIntraday
-    if not keyboardInterruptEventFired and (downloadOnly or (
-        configManager.cacheEnabled and not PKDateUtilities.isTradingTime() and not testing
-    )):
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.GREEN
-            + "[+] Caching Stock Data for future use, Please Wait... "
-            + colorText.END,
-            end="",
-        )
-        Utility.tools.saveStockData(stockDictPrimary, configManager, loadCount, intraday)
-        if downloadOnly:
-            cache_file = Utility.tools.saveStockData(stockDictPrimary, configManager, loadCount, intraday, downloadOnly=downloadOnly)
-            cacheFileSize = os.stat(cache_file).st_size if os.path.exists(cache_file) else 0
-            if cacheFileSize < 1024*1024*50:
-                try:
-                    from PKDevTools.classes import Archiver
-                    log_file_path = os.path.join(Archiver.get_user_outputs_dir(), "pkscreener-logs.txt")
-                    message=f"{cache_file} has size: {cacheFileSize}! Something is wrong!"
-                    if os.path.exists(log_file_path):
-                        sendMessageToTelegramChannel(caption=message,document_filePath=log_file_path, user="-1001785195297")
-                    else:
-                        sendMessageToTelegramChannel(message=message,user="-1001785195297")
-                except:
-                    pass
-                # Let's try again with logging
-                os.system(f"{sys.argv[0]} -a Y -e -l -d {'-i 1m' if configManager.isIntradayConfig() else ''}")
-    else:
-        OutputControls().printOutput(colorText.BOLD + colorText.GREEN + "[+] Skipped Saving!" + colorText.END)
-
-
-def saveNotifyResultsFile(
-    screenResults, saveResults, defaultAnswer, menuChoiceHierarchy, user=None
-):
-    global userPassedArgs, elapsed_time, selectedChoice
-    if user is None and userPassedArgs.user is not None:
-        user = userPassedArgs.user
-    caption = f'<b>{menuChoiceHierarchy.split(">")[-1]}</b>'
-    if screenResults is not None and len(screenResults) >= 1:
-        choices = PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)
-        filename = Utility.tools.promptSaveResults(choices,
-            saveResults, defaultAnswer=defaultAnswer
-        )
-        # if filename is not None:
-        #     sendMessageToTelegramChannel(
-        #         document_filePath=filename, caption=caption, user=user
-        #     )
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.WARN
-            + "[+] Notes:1.Trend calculation is based on 'daysToLookBack'. See configuration. 2.Reduce the console font size to fit all columns on screen."
-            + colorText.END
-        )
-        # try:
-        #     if filename is not None:
-        #         os.remove(filename)
-        # except Exception as e:  # pragma: no cover
-        #     default_logger().debug(e, exc_info=True)
-    if userPassedArgs.monitor is None:
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.GREEN
-            + f"[+] Screening Completed. Found {len(screenResults) if screenResults is not None else 0} results in {round(elapsed_time,2)} sec.! Press Enter to Continue.."
-            + colorText.END
-            , enableMultipleLineOutput=True
-        )
-        if defaultAnswer is None:
-            input("Press <Enter> to continue...")
-
-def sendGlobalMarketBarometer(userArgs=None):
-    from pkscreener.classes import Barometer
-    caption = "Global Market Barometer with India market Performance (top) and Valuation (bottom)"
-    gmbPath = Barometer.getGlobalMarketBarometerValuation()
-    try:
-        if gmbPath is not None:
-            sendMessageToTelegramChannel(
-                message=None,
-                photo_filePath=gmbPath,
-                caption=caption,
-                user=(userArgs.user if userArgs is not None else None),
-            )
-            os.remove(gmbPath)
-    except:
-        pass
-
-def sendMessageToTelegramChannel(
-    message=None, photo_filePath=None, document_filePath=None, caption=None, user=None
-):
-    global userPassedArgs, test_messages_queue
-    if test_messages_queue is not None:
-        test_messages_queue.append(f"message:{message}\ncaption:{caption}\nuser:{user}\ndocument:{document_filePath}")
-        if len(test_messages_queue) >10:
-            test_messages_queue.pop(0)
-    if user is None and userPassedArgs is not None and userPassedArgs.user is not None:
-        user = userPassedArgs.user
-    if user is not None and caption is not None:
-        caption = f"{caption.replace('&','n')}."
-    if message is not None:
-        try:
-            message = message.replace("&", "n").replace("<","*")
-            send_message(message, userID=user)
-        except Exception as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-    else:
-        message = ""
-    if photo_filePath is not None:
-        try:
-            if caption is not None:
-                caption = f"{caption.replace('&','n')}"
-            send_photo(photo_filePath, caption, userID=user)
-            # Breather for the telegram API to be able to send the heavy photo
-            sleep(2)
-        except Exception as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-    if document_filePath is not None:
-        try:
-            if caption is not None:
-                caption = f"{caption.replace('&','n')}"
-            send_document(document_filePath, caption, userID=user)
-            # Breather for the telegram API to be able to send the document
-            sleep(2)
-        except Exception as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-    if user is not None:
-        channel_userID="-1001785195297"
-        if user != channel_userID:
-            # Send an update to dev channel
-            send_message(
-                "Responded back to userId:{0} with {1}.{2}".format(user, caption, message),
-                userID="-1001785195297",
-            )
-
-
-def sendTestStatus(screenResults, label, user=None):
-    msg = "<b>SUCCESS</b>" if (screenResults is not None and len(screenResults) >= 1) else "<b>FAIL</b>"
-    sendMessageToTelegramChannel(
-        message=f"{msg}: Found {len(screenResults) if screenResults is not None else 0} Stocks for {label}", user=user
-    )
-
-
-def showBacktestResults(backtest_df, sortKey="Stock", optionalName="backtest_result"):
-    global menuChoiceHierarchy, selectedChoice, userPassedArgs, elapsed_time
-    pd.set_option("display.max_rows", 800)
-    # pd.set_option("display.max_columns", 20)
-    if backtest_df is None or backtest_df.empty or len(backtest_df) < 1:
-        return
-    backtest_df.drop_duplicates(inplace=True)
-    summaryText = f"Auto-generated in {round(elapsed_time,2)} sec. as of {PKDateUtilities.currentDateTime().strftime('%d-%m-%y %H:%M:%S IST')}\n{menuChoiceHierarchy.replace('Backtests','Growth of 10K' if optionalName=='Insights' else 'Backtests')}"
-    lastSummaryRow = None
-    if "Summary" not in optionalName:
-        if sortKey is not None and len(sortKey) > 0:
-            backtest_df.sort_values(by=[sortKey], ascending=False, inplace=True)
-    else:
-        lastRow = backtest_df.iloc[-1, :]
-        if lastRow.iloc[0] == "SUMMARY":
-            lastSummaryRow = pd.DataFrame(lastRow).transpose()
-            lastSummaryRow.set_index("Stock", inplace=True)
-            lastSummaryRow = lastSummaryRow.iloc[:, lastSummaryRow.columns != "Stock"]
-        if "Insights" in optionalName:
-            summaryText = f"{summaryText}\nActual returns at a portfolio level with 1-stock each based on selected scan-parameters:"
-        else:
-            summaryText = f"{summaryText}\nOverall Summary of (correctness of) Strategy Prediction Positive outcomes:"
-    tabulated_text = ""
-    if backtest_df is not None and len(backtest_df) > 0:
-        tabulated_text = colorText.miniTabulator().tabulate(
-            backtest_df,
-            headers="keys",
-            tablefmt=colorText.No_Pad_GridFormat,
-            showindex=False,
-            maxcolwidths=Utility.tools.getMaxColumnWidths(backtest_df)
-        ).encode("utf-8").decode(STD_ENCODING)
-    OutputControls().printOutput(colorText.FAIL + summaryText + colorText.END + "\n")
-    OutputControls().printOutput(tabulated_text + "\n")
-    choices, filename = getBacktestReportFilename(sortKey, optionalName)
-    headerDict = {0: "<th></th>"}
-    index = 1
-    for col in backtest_df.columns:
-        if col != "Stock":
-            headerDict[index] = f"<th>{col}</th>"
-            index += 1
-
-    colored_text = backtest_df.to_html(index=False)
-    summaryText = summaryText.replace("\n", "<br />")
-    if "Summary" in optionalName:
-       summaryText = f"{summaryText}<br /><input type='checkbox' id='chkActualNumbers' name='chkActualNumbers' value='0'><label for='chkActualNumbers'>Sort by actual numbers (Stocks + Date combinations of results. Higher the count, better the prediction reliability)</label><br>"
-    colored_text = reformatTable(summaryText, headerDict, colored_text, sorting=True)
-    # Delete any pre-existing backtesting report for the same parameters
-    filename = os.path.join(scanOutputDirectory(True), filename)
-    try:
-        os.remove(filename)
-    except Exception:# pragma: no cover
-        pass
-    finally:
-        colored_text = colored_text.encode('utf-8').decode(STD_ENCODING)
-        with open(filename, "w") as f:
-            f.write(colored_text)
-        Committer.execOSCommand(f"git add {filename} -f >/dev/null 2>&1")
-
-    if lastSummaryRow is not None:
-        oneline_text = lastSummaryRow.to_html(header=False, index=False)
-        oneline_text = reformatTable(
-            summaryText, headerDict, oneline_text, sorting=False
-        )
-        onelineSummaryFile = f"PKScreener_{choices}_OneLine_{optionalName}.html"
-        onelineSummaryFile = os.path.join(
-            scanOutputDirectory(True), onelineSummaryFile
-        )
-        try:
-            os.remove(onelineSummaryFile)
-        except Exception:# pragma: no cover
-            pass
-        finally:
-            oneline_text = f"{oneline_text}<td class='w'>{PKDateUtilities.currentDateTime().strftime('%Y/%m/%d')}</td><td class='w'>{round(elapsed_time,2)}</td>"
-            with open(onelineSummaryFile, "w") as f:
-                f.write(oneline_text)
-            Committer.execOSCommand(f"git add {onelineSummaryFile} -f >/dev/null 2>&1")
-
-def scanOutputDirectory(backtest=False):
-    dirName = 'actions-data-scan' if not backtest else "Backtest-Reports"
-    outputFolder = os.path.join(os.getcwd(),dirName)
-    if not os.path.isdir(outputFolder):
-        OutputControls().printOutput("Creating actions-data-scan directory now...")
-        os.makedirs(os.path.dirname(os.path.join(os.getcwd(),f"{dirName}{os.sep}")), exist_ok=True)
-    return outputFolder
-
-def getBacktestReportFilename(sortKey="Stock", optionalName="backtest_result"):
-    global userPassedArgs,selectedChoice
-    choices = PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)
-    filename = f"PKScreener_{choices}_{optionalName}_{sortKey if sortKey is not None else 'Default'}Sorted.html"
-    return choices, filename
-
-def showOptionErrorMessage():
-    OutputControls().printOutput(
-        colorText.BOLD
-        + colorText.FAIL
-        + "\n[+] Please enter a valid option & try Again!"
-        + colorText.END
-    )
-    sleep(2)
-    Utility.tools.clearScreen()
-
-def takeBacktestInputs(
-    menuOption=None, indexOption=None, executeOption=None, backtestPeriod=0
-):
-    g10k = '"Growth of 10k"'
-    OutputControls().printOutput(
-        colorText.BOLD
-        + colorText.GREEN
-        + f"[+] For {g10k if menuOption == 'G' else 'backtesting'}, you can choose from (1,2,3,4,5,10,15,22,30) or any other custom periods (< 1y)."
-    )
-    try:
-        if backtestPeriod == 0:
-            backtestPeriod = int(
-                input(
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + f"[+] Enter {g10k if menuOption == 'G' else 'backtesting'} period (Default is {15 if menuOption == 'G' else 30} [days]): "
-                )
-            )
-    except Exception as e:  # pragma: no cover
-        default_logger().debug(e, exc_info=True)
-    if backtestPeriod == 0:
-        backtestPeriod = 3 if menuOption == "G" else 30
-    indexOption, executeOption = initPostLevel0Execution(
-        menuOption=menuOption,
-        indexOption=indexOption,
-        executeOption=executeOption,
-        skip=["N", "E"],
-    )
-    indexOption, executeOption = initPostLevel1Execution(
-        indexOption=indexOption,
-        executeOption=executeOption,
-        skip=[
-            "0",
-            "29",
-            "42",
-        ],
-    )
-    return indexOption, executeOption, backtestPeriod
-
-def toggleUserConfig():
-    configManager.toggleConfig(
-        candleDuration="1d" if configManager.isIntradayConfig() else "1m"
-    )
-    OutputControls().printOutput(
-        colorText.BOLD
-        + colorText.GREEN
-        + "\nConfiguration toggled to duration: "
-        + str(configManager.duration)
-        + " and period: "
-        + str(configManager.period)
-        + colorText.END
-    )
-    input("\nPress <Enter> to Continue...\n")
-
-
-def userReportName(userMenuOptions):
-    global userPassedArgs
-    choices = ""
-    for choice in userMenuOptions:
-        if len(userMenuOptions[choice]) > 0:
-            if len(choices) > 0:
-                choices = f"{choices}_"
-            choices = f"{choices}{userMenuOptions[choice]}"
-    if choices.endswith("_"):
-        choices = choices[:-1]
-    choices = f"{choices}{'_i' if userPassedArgs.intraday else ''}"
-    return choices
+#!/usr/bin/python3
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+# Keep module imports prior to classes
+import os
+import random
+import warnings
+warnings.simplefilter("ignore", UserWarning,append=True)
+os.environ["PYTHONWARNINGS"]="ignore::UserWarning"
+os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
+import logging
+import multiprocessing
+import sys
+import time
+import urllib
+import warnings
+from datetime import datetime
+from time import sleep
+
+import numpy as np
+
+warnings.simplefilter("ignore", DeprecationWarning)
+warnings.simplefilter("ignore", FutureWarning)
+import pandas as pd
+from alive_progress import alive_bar
+from PKDevTools.classes.Committer import Committer
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.PKDateUtilities import PKDateUtilities
+from PKDevTools.classes.log import default_logger #, tracelog
+from PKDevTools.classes.SuppressOutput import SuppressOutput
+from PKDevTools.classes.Telegram import (
+    is_token_telegram_configured,
+    send_document,
+    send_message,
+    send_photo
+)
+from PKNSETools.morningstartools.PKMorningstarDataFetcher import morningstarDataFetcher
+from PKNSETools.Nasdaq.PKNasdaqIndex import PKNasdaqIndexFetcher
+from tabulate import tabulate
+
+import pkscreener.classes.ConfigManager as ConfigManager
+import pkscreener.classes.Fetcher as Fetcher
+import pkscreener.classes.ScreeningStatistics as ScreeningStatistics
+import pkscreener.classes.Utility as Utility
+from pkscreener.classes.Utility import STD_ENCODING
+from pkscreener.classes import VERSION, PortfolioXRay
+from pkscreener.classes.Backtest import backtest, backtestSummary
+from pkscreener.classes.PKSpreadsheets import PKSpreadsheets
+from PKDevTools.classes.OutputControls import OutputControls
+from pkscreener.classes.MenuOptions import (
+    level0MenuDict,
+    level1_X_MenuDict,
+    level2_X_MenuDict,
+    level3_X_ChartPattern_MenuDict,
+    level3_X_PopularStocks_MenuDict,
+    level3_X_Reversal_MenuDict,
+    level4_X_Lorenzian_MenuDict,
+    level4_X_ChartPattern_Confluence_MenuDict,
+    level4_X_ChartPattern_BBands_SQZ_MenuDict,
+    menus,
+    MAX_SUPPORTED_MENU_OPTION,
+    MAX_MENU_OPTION,
+    PIPED_SCANNERS,
+    PREDEFINED_SCAN_MENU_KEYS
+)
+from pkscreener.classes.OtaUpdater import OTAUpdater
+from pkscreener.classes.Portfolio import PortfolioCollection
+from pkscreener.classes.PKTask import PKTask
+from pkscreener.classes.PKScheduler import PKScheduler
+from pkscreener.classes.PKScanRunner import PKScanRunner
+from pkscreener.classes.PKMarketOpenCloseAnalyser import PKMarketOpenCloseAnalyser
+
+if __name__ == '__main__':
+    multiprocessing.freeze_support()
+# import dataframe_image as dfi
+# import df2img
+# Try Fixing bug with this symbol
+TEST_STKCODE = "SBIN"
+# Constants
+np.seterr(divide="ignore", invalid="ignore")
+
+# Variabls
+configManager = ConfigManager.tools()
+configManager.getConfig(ConfigManager.parser)
+defaultAnswer = None
+fetcher = Fetcher.screenerStockDataFetcher(configManager)
+mstarFetcher = morningstarDataFetcher(configManager)
+keyboardInterruptEvent = None
+keyboardInterruptEventFired=False
+loadCount = 0
+loadedStockData = False
+m0 = menus()
+m1 = menus()
+m2 = menus()
+m3 = menus()
+maLength = None
+nValueForMenu = 0
+menuChoiceHierarchy = ""
+newlyListedOnly = False
+screenCounter = None
+screener = ScreeningStatistics.ScreeningStatistics(configManager, default_logger())
+screenResults = None
+backtest_df = None
+screenResultsCounter = None
+selectedChoice = {"0": "", "1": "", "2": "", "3": "", "4": ""}
+stockDictPrimary = None
+stockDictSecondary = None
+userPassedArgs = None
+elapsed_time = 0
+start_time = 0
+test_messages_queue = []
+strategyFilter=[]
+listStockCodes = None
+tasks_queue = None
+results_queue = None
+consumers = None
+logging_queue = None
+mp_manager = None
+
+def startMarketMonitor(mp_dict,keyboardevent):
+    from PKDevTools.classes.NSEMarketStatus import NSEMarketStatus
+    NSEMarketStatus(mp_dict,keyboardevent).startMarketMonitor()
+
+def finishScreening(
+    downloadOnly,
+    testing,
+    stockDictPrimary,
+    configManager,
+    loadCount,
+    testBuild,
+    screenResults,
+    saveResults,
+    user=None,
+):
+    if "RUNNER" in os.environ.keys():
+        # There's no need to prompt the user to save xls report or to save data locally.
+        # This scan must have been triggered by github workflow by a user or scheduled job
+        return
+    global defaultAnswer, menuChoiceHierarchy, userPassedArgs, selectedChoice
+    saveDownloadedData(downloadOnly, testing, stockDictPrimary, configManager, loadCount)
+    if not testBuild and not downloadOnly and not testing:
+        saveNotifyResultsFile(
+            screenResults, saveResults, defaultAnswer, menuChoiceHierarchy, user=user
+        )
+
+
+def getDownloadChoices(defaultAnswer=None):
+    global userPassedArgs
+    argsIntraday = userPassedArgs is not None and userPassedArgs.intraday is not None
+    intradayConfig = configManager.isIntradayConfig()
+    intraday = intradayConfig or argsIntraday
+    exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday)
+    if exists:
+        shouldReplace = Utility.tools.promptFileExists(
+            cache_file=cache_file, defaultAnswer=defaultAnswer
+        )
+        if shouldReplace == "N":
+            OutputControls().printOutput(
+                cache_file
+                + colorText.END
+                + " already exists. Exiting as user chose not to replace it!"
+            )
+            sys.exit(0)
+        else:
+            pattern = f"{'intraday_' if intraday else ''}stock_data_*.pkl"
+            configManager.deleteFileWithPattern(pattern)
+    return "X", 12, 0, {"0": "X", "1": "12", "2": "0"}
+
+
+def getHistoricalDays(numStocks, testing):
+    # Generally it takes 40-50 stocks to be processed every second.
+    # We would like the backtest to finish withn 10 minutes (600 seconds).
+    # days = numStocks/40 per second
+    return (
+        2 if testing else configManager.backtestPeriod
+    )  # if numStocks <= 2000 else 120 # (5 if iterations < 5 else (100 if iterations > 100 else iterations))
+
+
+def getScannerMenuChoices(
+    testBuild=False,
+    downloadOnly=False,
+    startupoptions=None,
+    menuOption=None,
+    indexOption=None,
+    executeOption=None,
+    defaultAnswer=None,
+    user=None,
+):
+    global selectedChoice
+    executeOption = executeOption
+    menuOption = menuOption
+    indexOption = indexOption
+    try:
+        if menuOption is None:
+            selectedMenu = initExecution(menuOption=menuOption)
+            menuOption = selectedMenu.menuKey
+        if menuOption in ["H", "U", "T", "E", "Y"]:
+            handleSecondaryMenuChoices(
+                menuOption, testBuild, defaultAnswer=defaultAnswer, user=user
+            )
+            Utility.tools.clearScreen(forceTop=True)
+        elif menuOption in ["X","C"]:
+            indexOption, executeOption = initPostLevel0Execution(
+                menuOption=menuOption,
+                indexOption=indexOption,
+                executeOption=executeOption,
+            )
+            indexOption, executeOption = initPostLevel1Execution(
+                indexOption=indexOption, executeOption=executeOption
+            )
+    except KeyboardInterrupt:
+        input(
+            colorText.BOLD
+            + colorText.FAIL
+            + "[+] Press <Enter> to Exit!"
+            + colorText.END
+        )
+        sys.exit(0)
+    except Exception as e:  # pragma: no cover
+        default_logger().debug(e, exc_info=True)
+    return menuOption, indexOption, executeOption, selectedChoice
+
+
+def getSummaryCorrectnessOfStrategy(resultdf, summaryRequired=True):
+    summarydf = None
+    detaildf = None
+    try:
+        if resultdf is None or len(resultdf) == 0:
+            return None, None
+        results = resultdf.copy()
+        if summaryRequired:
+            _, reportNameSummary = getBacktestReportFilename(optionalName="Summary")
+            dfs = pd.read_html(
+                "https://pkjmesra.github.io/PKScreener/Backtest-Reports/{0}".format(
+                    reportNameSummary.replace("_X_", "_B_").replace("_G_", "_B_").replace("_S_", "_B_")
+                ),encoding="UTF-8", attrs = {'id': 'resultsTable'}
+            )
+        _, reportNameDetail = getBacktestReportFilename()
+        dfd = pd.read_html(
+            "https://pkjmesra.github.io/PKScreener/Backtest-Reports/{0}".format(
+                reportNameDetail.replace("_X_", "_B_").replace("_G_", "_B_").replace("_S_", "_B_")
+            ),encoding="UTF-8", attrs = {'id': 'resultsTable'}
+        )
+
+        if summaryRequired and dfs is not None and len(dfs) > 0:
+            df = dfs[0]
+            summarydf = df[df["Stock"] == "SUMMARY"]
+            for col in summarydf.columns:
+                summarydf.loc[:, col] = summarydf.loc[:, col].apply(
+                    lambda x: Utility.tools.getFormattedBacktestSummary(
+                        x, columnName=col
+                    )
+                )
+            summarydf = summarydf.replace(np.nan, "", regex=True)
+        if dfd is not None and len(dfd) > 0:
+            df = dfd[0]
+            results.reset_index(inplace=True)
+            detaildf = df[df["Stock"].isin(results["Stock"])]
+            for col in detaildf.columns:
+                detaildf.loc[:, col] = detaildf.loc[:, col].apply(
+                    lambda x: Utility.tools.getFormattedBacktestSummary(
+                        x, pnlStats=True, columnName=col
+                    )
+                )
+            detaildf = detaildf.replace(np.nan, "", regex=True)
+            detaildf.loc[:, "Volume"] = detaildf.loc[:, "Volume"].apply(
+                lambda x: Utility.tools.formatRatio(x, configManager.volumeRatio)
+            )
+            detaildf.sort_values(
+                ["Stock", "Date"], ascending=[True, False], inplace=True
+            )
+            detaildf.rename(
+                columns={
+                    "LTP": "LTP on Date",
+                },
+                inplace=True,
+            )
+    except urllib.error.HTTPError as e:
+        if "HTTP Error 404" in str(e):
+            pass
+        else:
+            default_logger().debug(e, exc_info=True)
+    except Exception as e:# pragma: no cover
+        default_logger().debug(e, exc_info=True)
+        pass
+    return summarydf, detaildf
+
+
+def getTestBuildChoices(indexOption=None, executeOption=None, menuOption=None):
+    if menuOption is not None:
+        return (
+            str(menuOption),
+            indexOption if indexOption is not None else 1,
+            executeOption if executeOption is not None else 0,
+            {
+                "0": str(menuOption),
+                "1": (str(indexOption) if indexOption is not None else 1),
+                "2": (str(executeOption) if executeOption is not None else 0),
+            },
+        )
+    return "X", 1, 0, {"0": "X", "1": "1", "2": "0"}
+
+
+def getTopLevelMenuChoices(startupoptions, testBuild, downloadOnly, defaultAnswer=None):
+    global selectedChoice, userPassedArgs
+    executeOption = None
+    menuOption = None
+    indexOption = None
+    options = []
+    if startupoptions is not None:
+        options = startupoptions.split(":")
+        menuOption = options[0] if len(options) >= 1 else None
+        indexOption = options[1] if len(options) >= 2 else None
+        executeOption = options[2] if len(options) >= 3 else None
+    if testBuild:
+        menuOption, indexOption, executeOption, selectedChoice = getTestBuildChoices(
+            indexOption=indexOption,
+            executeOption=executeOption,
+            menuOption=menuOption,
+        )
+    elif downloadOnly:
+        menuOption, indexOption, executeOption, selectedChoice = getDownloadChoices(
+            defaultAnswer=defaultAnswer
+        )
+        intraday = userPassedArgs.intraday or configManager.isIntradayConfig()
+        filePrefix = "INTRADAY_" if intraday else ""
+        _, cache_file_name = Utility.tools.afterMarketStockDataExists(intraday)
+        Utility.tools.set_github_output(f"{filePrefix}DOWNLOAD_CACHE_FILE_NAME",cache_file_name)
+    return options, menuOption, indexOption, executeOption
+
+
+def handleScannerExecuteOption4(executeOption, options):
+    try:
+        # m2.find(str(executeOption))
+        if len(options) >= 4:
+            if str(options[3]).upper() == "D":
+                # Use a default value
+                daysForLowestVolume = 5
+            else:
+                daysForLowestVolume = int(options[3])
+        else:
+            daysForLowestVolume = int(
+                input(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + "\n[+] The Volume should be lowest since last how many candles? (Default = 5)"
+                ) or "5"
+            )
+    except ValueError as e:  # pragma: no cover
+        default_logger().debug(e, exc_info=True)
+        OutputControls().printOutput(colorText.END)
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + "[+] Error: Non-numeric value entered! Please try again!"
+            + colorText.END
+        )
+        input("Press <Enter> to continue...")
+        return
+    OutputControls().printOutput(colorText.END)
+    global nValueForMenu 
+    nValueForMenu = daysForLowestVolume
+    return daysForLowestVolume
+
+
+def handleSecondaryMenuChoices(
+    menuOption, testing=False, defaultAnswer=None, user=None
+):
+    global userPassedArgs
+    if menuOption == "H":
+        showSendHelpInfo(defaultAnswer, user)
+    elif menuOption == "U":
+        OTAUpdater.checkForUpdate(VERSION, skipDownload=testing)
+        if defaultAnswer is None:
+            input("Press <Enter> to continue...")
+    elif menuOption == "T":
+        if userPassedArgs is None or userPassedArgs.options is None:
+            selectedMenu = m0.find(menuOption)
+            m1.renderForMenu(selectedMenu=selectedMenu)
+            periodOption = input(
+                    colorText.BOLD + colorText.FAIL + "[+] Select option: "
+                ) or ('L' if configManager.period == '1y' else 'S')
+            OutputControls().printOutput(colorText.END, end="")
+            if periodOption is None or periodOption.upper() not in ["L","S"]:
+                return
+            Utility.tools.clearScreen(forceTop=True)
+            if periodOption.upper() in ["L","S"]:
+                selectedMenu = m1.find(periodOption)
+                m2.renderForMenu(selectedMenu=selectedMenu)
+                durationOption = input(
+                        colorText.BOLD + colorText.FAIL + "[+] Select option: "
+                    ) or "1"
+                OutputControls().printOutput(colorText.END, end="")
+                if durationOption is None or durationOption.upper() not in ["1","2","3","4","5"]:
+                    return
+                Utility.tools.clearScreen(forceTop=True)
+                if durationOption.upper() in ["1","2","3","4"]:
+                    selectedMenu = m2.find(durationOption)
+                    periodDurations = selectedMenu.menuText.split("(")[1].split(")")[0].split(", ")
+                    configManager.period = periodDurations[0]
+                    configManager.duration = periodDurations[1]
+                    configManager.setConfig(ConfigManager.parser, default=True, showFileCreatedText=False)
+                elif durationOption.upper() in ["5"]:
+                    configManager.setConfig(ConfigManager.parser, default=False, showFileCreatedText=True)
+                return
+        elif userPassedArgs is not None and userPassedArgs.options is not None:
+            options = userPassedArgs.options.split(":")
+            selectedMenu = m0.find(options[0])
+            m1.renderForMenu(selectedMenu=selectedMenu, asList=True)
+            selectedMenu = m1.find(options[1])
+            m2.renderForMenu(selectedMenu=selectedMenu)
+            if options[2] in ["1","2","3","4"]:
+                selectedMenu = m2.find(options[2])
+                periodDurations = selectedMenu.menuText.split("(")[1].split(")")[0].split(", ")
+                configManager.period = periodDurations[0]
+                configManager.duration = periodDurations[1]
+                configManager.setConfig(ConfigManager.parser, default=True, showFileCreatedText=False)
+            else:
+                toggleUserConfig()
+        else:
+            toggleUserConfig()
+    elif menuOption == "E":
+        configManager.setConfig(ConfigManager.parser)
+    elif menuOption == "Y":
+        showSendConfigInfo(defaultAnswer, user)
+    return
+
+def showSendConfigInfo(defaultAnswer=None, user=None):
+    configData = configManager.showConfigFile(defaultAnswer=('Y' if user is not None else defaultAnswer))
+    if user is not None:
+        sendMessageToTelegramChannel(message=Utility.tools.removeAllColorStyles(configData), user=user)
+
+def showSendHelpInfo(defaultAnswer=None, user=None):
+    helpData = Utility.tools.showDevInfo(defaultAnswer=('Y' if user is not None else defaultAnswer))
+    if user is not None:
+        sendMessageToTelegramChannel(message=Utility.tools.removeAllColorStyles(helpData), user=user)
+
+def initExecution(menuOption=None):
+    global selectedChoice, userPassedArgs
+    Utility.tools.clearScreen()
+    if (userPassedArgs is not None and userPassedArgs.pipedmenus is not None):
+        OutputControls().printOutput(
+        colorText.BOLD
+        + colorText.FAIL
+        + "[+] You chose: "
+        + f" (Piped Scan Mode) [{userPassedArgs.pipedmenus}]"
+        + colorText.END
+    )
+    m0.renderForMenu(selectedMenu=None)
+    try:
+        if menuOption is None:
+            if "PKDevTools_Default_Log_Level" in os.environ.keys():
+                from PKDevTools.classes import Archiver
+                log_file_path = os.path.join(Archiver.get_user_outputs_dir(), "pkscreener-logs.txt")
+                OutputControls().printOutput(colorText.FAIL + "\n    [+] Logs will be written to:"+colorText.END)
+                OutputControls().printOutput(colorText.GREEN + f"    [+] {log_file_path}"+colorText.END)
+                OutputControls().printOutput(colorText.FAIL + "    [+] If you need to share,run through the menus that are causing problems. At the end, open this folder, zip the log file to share at https://github.com/pkjmesra/PKScreener/issues .\n" + colorText.END)
+            menuOption = input(colorText.BOLD + colorText.FAIL + "[+] Select option: ")
+            OutputControls().printOutput(colorText.END, end="")
+        if menuOption == "" or menuOption is None:
+            menuOption = "X"
+        menuOption = menuOption.upper()
+        selectedMenu = m0.find(menuOption)
+        if selectedMenu is not None:
+            if selectedMenu.menuKey == "Z":
+                input(
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + "[+] Press <Enter> to Exit!"
+                    + colorText.END
+                )
+                sys.exit(0)
+            elif selectedMenu.menuKey in ["B", "C", "G", "H", "U", "T", "S", "E", "X", "Y", "M", "D", "I", "L"]:
+                Utility.tools.clearScreen(forceTop=True)
+                selectedChoice["0"] = selectedMenu.menuKey
+                return selectedMenu
+            elif selectedMenu.menuKey in ["P"]:
+                return selectedMenu
+    except KeyboardInterrupt:
+        raise KeyboardInterrupt
+    except Exception as e:  # pragma: no cover
+        default_logger().debug(e, exc_info=True)
+        showOptionErrorMessage()
+        return initExecution()
+
+    showOptionErrorMessage()
+    return initExecution()
+
+
+def initPostLevel0Execution(
+    menuOption=None, indexOption=None, executeOption=None, skip=[], retrial=False
+):
+    global newlyListedOnly, selectedChoice, userPassedArgs
+    Utility.tools.clearScreen()
+    if menuOption is None:
+        OutputControls().printOutput('You must choose an option from the previous menu! Defaulting to "X"...')
+        menuOption = "X"
+    OutputControls().printOutput(
+        colorText.BOLD
+        + colorText.FAIL
+        + "[+] You chose: "
+        + level0MenuDict[menuOption].strip() 
+        + (f" (Piped Scan Mode) [{userPassedArgs.pipedmenus}]" if (userPassedArgs is not None and userPassedArgs.pipedmenus is not None) else "")
+        + colorText.END
+    )
+    if indexOption is None:
+        selectedMenu = m0.find(menuOption)
+        m1.renderForMenu(selectedMenu=selectedMenu, skip=skip)
+    try:
+        if indexOption is None:
+            indexOption = input(
+                colorText.BOLD + colorText.FAIL + "[+] Select option: "
+            )
+            OutputControls().printOutput(colorText.END, end="")
+        if indexOption == "" or indexOption is None:
+            indexOption = int(configManager.defaultIndex)
+        # elif indexOption == 'W' or indexOption == 'w' or indexOption == 'N' or indexOption == 'n' or indexOption == 'E' or indexOption == 'e':
+        elif not str(indexOption).isnumeric():
+            indexOption = indexOption.upper()
+            if indexOption in ["M", "E", "N", "Z"]:
+                return indexOption, 0
+        else:
+            indexOption = int(indexOption)
+            if indexOption < 0 or indexOption > 15:
+                raise ValueError
+            elif indexOption == 13:
+                newlyListedOnly = True
+                indexOption = 12
+        if indexOption == 15:
+            from pkscreener.classes.MarketStatus import MarketStatus
+            MarketStatus().exchange = "^IXIC"
+        selectedChoice["1"] = str(indexOption)
+    except KeyboardInterrupt:
+        raise KeyboardInterrupt
+    except Exception as e:  # pragma: no cover
+        default_logger().debug(e, exc_info=True)
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + "\n[+] Please enter a valid numeric option & Try Again!"
+            + colorText.END
+        )
+        if not retrial:
+            sleep(2)
+            Utility.tools.clearScreen()
+            return initPostLevel0Execution(retrial=True)
+    return indexOption, executeOption
+
+
+def initPostLevel1Execution(indexOption, executeOption=None, skip=[], retrial=False):
+    global selectedChoice, userPassedArgs
+    if executeOption is None:
+        if indexOption is not None and indexOption != "W":
+            Utility.tools.clearScreen()
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] You chose: "
+                + level0MenuDict[selectedChoice["0"]].strip()
+                + " > "
+                + level1_X_MenuDict[selectedChoice["1"]].strip()
+                + (f" (Piped Scan Mode) [{userPassedArgs.pipedmenus}]" if (userPassedArgs is not None and userPassedArgs.pipedmenus is not None) else "")
+                + colorText.END
+            )
+            selectedMenu = m1.find(indexOption)
+            m2.renderForMenu(selectedMenu=selectedMenu, skip=skip)
+    try:
+        if indexOption is not None and indexOption != "W":
+            if executeOption is None:
+                executeOption = input(
+                    colorText.BOLD + colorText.FAIL + "[+] Select option: "
+                ) or "9"
+                OutputControls().printOutput(colorText.END, end="")
+            if executeOption == "":
+                executeOption = 1
+            if not str(executeOption).isnumeric():
+                executeOption = executeOption.upper()
+            else:
+                executeOption = int(executeOption)
+                if executeOption < 0 or executeOption > 44:
+                    raise ValueError
+        else:
+            executeOption = 0
+        selectedChoice["2"] = str(executeOption)
+    except KeyboardInterrupt:
+        raise KeyboardInterrupt
+    except Exception as e:  # pragma: no cover
+        default_logger().debug(e, exc_info=True)
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + "\n[+] Please enter a valid numeric option & Try Again!"
+            + colorText.END
+        )
+        if not retrial:
+            sleep(2)
+            Utility.tools.clearScreen()
+            return initPostLevel1Execution(indexOption, executeOption, retrial=True)
+    return indexOption, executeOption
+
+def labelDataForPrinting(screenResults, saveResults, configManager, volumeRatio,executeOption, reversalOption):
+    # Publish to gSheet with https://github.com/burnash/gspread
+    global menuChoiceHierarchy, userPassedArgs
+    try:
+        isTrading = PKDateUtilities.isTradingTime() and not PKDateUtilities.isTodayHoliday()[0]
+        if "RUNNER" not in os.environ.keys() and (isTrading or userPassedArgs.monitor or ("RSIi" in saveResults.columns)):
+            screenResults['RSI'] = screenResults['RSI'].astype(str) + "/" + screenResults['RSIi'].astype(str)
+            saveResults['RSI'] = saveResults['RSI'].astype(str) + "/" + saveResults['RSIi'].astype(str)
+            screenResults.rename(columns={"RSI": "RSI/i"},inplace=True)
+            saveResults.rename(columns={"RSI": "RSI/i"},inplace=True)
+        sortKey = ["Volume"] if "RSI" not in menuChoiceHierarchy else ("RSIi" if (isTrading or "RSIi" in saveResults.columns) else "RSI")
+        ascending = [False if "RSI" not in menuChoiceHierarchy else True]
+        if executeOption == 21:
+            if reversalOption in [3,5,6,7]:
+                sortKey = ["MFI"]
+                ascending = [reversalOption in [6,7]]
+            elif reversalOption in [8,9]:
+                sortKey = ["FVDiff"]
+                ascending = [reversalOption in [9]]
+        elif executeOption == 7:
+            if reversalOption in [3]:
+                sortKey = ["Volume","MA-Signal"]
+                ascending = [False, False]
+        elif executeOption == 23:
+            sortKey = ["bbands_ulr_ratio_max5"] if "bbands_ulr_ratio_max5" in screenResults.columns else ["Volume"]
+            ascending = [False]
+        elif executeOption == 27: # ATR Cross
+            sortKey = ["ATR"] if "ATR" in screenResults.columns else ["Volume"]
+            ascending = [False]
+        elif executeOption == 31: # DEEL Momentum
+            sortKey = ["Volume"]
+            ascending = [False]
+        try:
+            try:
+                screenResults[sortKey] = screenResults[sortKey].replace("", np.nan).replace(np.inf, np.nan).replace(-np.inf, np.nan).astype(float)
+            except:
+                pass
+            try:
+                saveResults[sortKey] = saveResults[sortKey].replace("", np.nan).replace(np.inf, np.nan).replace(-np.inf, np.nan).astype(float)
+            except:
+                pass
+            screenResults.sort_values(by=sortKey, ascending=ascending, inplace=True)
+            saveResults.sort_values(by=sortKey, ascending=ascending, inplace=True)
+        except Exception as e:
+            default_logger().debug(e, exc_info=True)
+            pass
+        columnsToBeDeleted = ["MFI","FVDiff","ConfDMADifference","bbands_ulr_ratio_max5", "RSIi"]
+        if userPassedArgs is not None and userPassedArgs.options is not None and userPassedArgs.options.upper().startswith("C"):
+            columnsToBeDeleted.append("FairValue")
+        if executeOption == 27: # ATR Cross
+            columnsToBeDeleted.append("Consol.")
+            screenResults['ATR'] = screenResults['ATR'].astype(str)
+            screenResults['ATR'] = colorText.GREEN + screenResults['ATR'] + colorText.END
+        for column in columnsToBeDeleted:
+            if column in saveResults.columns:
+                saveResults.drop(column, axis=1, inplace=True, errors="ignore")
+                screenResults.drop(column, axis=1, inplace=True, errors="ignore")
+        if "Stock" in screenResults.columns:
+            screenResults.set_index("Stock", inplace=True)
+        if "Stock" in saveResults.columns:
+            saveResults.set_index("Stock", inplace=True)
+        screenResults['Volume'] = screenResults['Volume'].astype(str)
+        saveResults['Volume'] = saveResults['Volume'].astype(str)
+        screenResults.loc[:, "Volume"] = screenResults.loc[:, "Volume"].apply(
+            lambda x: Utility.tools.formatRatio(float(x), volumeRatio) if len(str(x).strip()) > 0 else ''
+        )
+        saveResults.loc[:, "Volume"] = saveResults.loc[:, "Volume"].apply(
+            lambda x: str(x) + "x"
+        )
+        screenResults.rename(
+            columns={
+                "Trend": f"Trend({configManager.daysToLookback}Prds)",
+                "Breakout": f"Breakout({configManager.daysToLookback}Prds)",
+                # "Consol.": f"Consol.({configManager.daysToLookback}Prds)",
+            },
+            inplace=True,
+        )
+        saveResults.rename(
+            columns={
+                "Trend": f"Trend({configManager.daysToLookback}Prds)",
+                "Breakout": f"Breakout({configManager.daysToLookback}Prds)",
+                # "Consol.": f"Consol.({configManager.daysToLookback}Prds)",
+            },
+            inplace=True,
+        )
+    except Exception as e:  # pragma: no cover
+        default_logger().debug(e, exc_info=True)
+    return screenResults, saveResults
+
+def isInterrupted():
+    global keyboardInterruptEventFired
+    return keyboardInterruptEventFired
+
+def refreshStockData(startupoptions=None):
+    global consumers,stockDictPrimary, loadedStockData, listStockCodes, stockDictSecondary
+    options = startupoptions.replace("|","").split(" ")[0].replace(":i","")
+    loadedStockData = False
+    options, menuOption, indexOption, executeOption = getTopLevelMenuChoices(
+        options, False, False, defaultAnswer='Y'
+    )
+    listStockCodes = prepareStocksForScreening(testing=False, downloadOnly=False, listStockCodes=None,indexOption=indexOption)
+    stockDictPrimary,stockDictSecondary = loadDatabaseOrFetch(downloadOnly=False, listStockCodes=listStockCodes, menuOption=menuOption,indexOption=indexOption)
+    PKScanRunner.refreshDatabase(consumers,stockDictPrimary,stockDictSecondary)
+
+def closeWorkersAndExit():
+    global consumers, tasks_queue,userPassedArgs
+    if consumers is not None:
+        PKScanRunner.terminateAllWorkers(userPassedArgs=userPassedArgs,consumers=consumers, tasks_queue=tasks_queue, testing=userPassedArgs.testbuild)
+    
+# @tracelog
+def main(userArgs=None,optionalFinalOutcome_df=None):
+    global mp_manager, listStockCodes, screenResults, selectedChoice, defaultAnswer, menuChoiceHierarchy, screenCounter, screenResultsCounter, stockDictPrimary, stockDictSecondary, userPassedArgs, loadedStockData, keyboardInterruptEvent, loadCount, maLength, newlyListedOnly, keyboardInterruptEventFired,strategyFilter, elapsed_time, start_time
+    selectedChoice = {"0": "", "1": "", "2": "", "3": "", "4": ""}
+    elapsed_time = 0
+    start_time = 0
+    testing = False if userArgs is None else (userArgs.testbuild and userArgs.prodbuild)
+    testBuild = False if userArgs is None else (userArgs.testbuild and not testing)
+    downloadOnly = False if userArgs is None else userArgs.download
+    startupoptions = None if userArgs is None else userArgs.options
+    user = None if userArgs is None else userArgs.user
+    defaultAnswer = None if userArgs is None else userArgs.answerdefault
+    userPassedArgs = userArgs
+    options = []
+    strategyFilter=[]
+    if keyboardInterruptEventFired:
+        return None, None
+    screenCounter = multiprocessing.Value("i", 1)
+    screenResultsCounter = multiprocessing.Value("i", 0)
+    if mp_manager is None:
+        mp_manager = multiprocessing.Manager()
+        
+    if keyboardInterruptEvent is None and not keyboardInterruptEventFired:
+        keyboardInterruptEvent = mp_manager.Event()
+        mkt_monitor_dict = mp_manager.dict()
+        # Let's start monitoring the market monitor
+        startMarketMonitor(mkt_monitor_dict,keyboardInterruptEvent)
+        
+    keyboardInterruptEventFired = False
+    if stockDictPrimary is None:
+        stockDictPrimary = mp_manager.dict()
+        stockDictSecondary = mp_manager.dict()
+        loadCount = 0
+    endOfdayCandles = None
+    minRSI = 0
+    maxRSI = 100
+    insideBarToLookback = 7
+    respChartPattern = None
+    daysForLowestVolume = 30
+    backtestPeriod = 0
+    reversalOption = None
+    listStockCodes = None
+    if userPassedArgs.log:
+        default_logger().debug(f"User Passed args: {userPassedArgs}")
+    screenResults, saveResults = PKScanRunner.initDataframes()
+    options, menuOption, indexOption, executeOption = getTopLevelMenuChoices(
+        startupoptions, testBuild, downloadOnly, defaultAnswer=defaultAnswer
+    )
+    # Print Level 1 menu options
+    selectedMenu = initExecution(menuOption=menuOption)
+    menuOption = selectedMenu.menuKey
+    if menuOption in ["M", "D", "I", "L"]:
+        launcher = sys.argv[0]
+        launcher = f"python3.11 {launcher}" if launcher.endswith(".py") else launcher
+        if menuOption in ["M"]:
+            OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener in monitoring mode. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -m 'X'{colorText.END}\n{colorText.WARN}Press Ctrl + C to exit monitoring mode.{colorText.END}")
+            sleep(2)
+            os.system(f"{launcher} -a Y -m 'X'")
+        elif menuOption in ["D"]:
+            OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener to Download daily OHLC data. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -e -d{colorText.END}\n{colorText.WARN}Press Ctrl + C to exit at any time.{colorText.END}")
+            sleep(2)
+            os.system(f"{launcher} -a Y -e -d")
+        elif menuOption in ["I"]:
+            OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener to Download intraday OHLC data. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -e -d -i 1m{colorText.END}\n{colorText.WARN}Press Ctrl + C to exit at any time.{colorText.END}")
+            sleep(2)
+            os.system(f"{launcher} -a Y -e -d -i 1m")
+        elif menuOption in ["L"]:
+            OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener to collect logs. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -l{colorText.END}\n{colorText.WARN}Press Ctrl + C to exit at any time.{colorText.END}")
+            sleep(2)
+            os.system(f"{launcher} -a Y -l")
+        sys.exit(0)
+    if menuOption in ["P"]:
+        updateMenuChoiceHierarchy()
+        selectedMenu = m0.find(menuOption)
+        m1.renderForMenu(selectedMenu)
+        predefinedOption = input(colorText.BOLD + colorText.FAIL + "[+] Select option: ") or "1"
+        OutputControls().printOutput(colorText.END, end="")
+        if predefinedOption not in ["1","2","3"]:
+            return None, None
+        if predefinedOption == "1":
+            updateMenuChoiceHierarchy()
+            selectedMenu = m1.find(predefinedOption)
+            m2.renderForMenu(selectedMenu=selectedMenu)
+            selPredefinedOption = input(colorText.BOLD + colorText.FAIL + "[+] Select option: ") or "1"
+            OutputControls().printOutput(colorText.END, end="")
+            if selPredefinedOption in PREDEFINED_SCAN_MENU_KEYS:
+                scannerOption = PIPED_SCANNERS[selPredefinedOption]
+                updateMenuChoiceHierarchy()
+                if userPassedArgs.pipedmenus is not None:
+                    chosenOptions = scannerOption.split("-o ")[1]
+                    userPassedArgs.options = chosenOptions.replace("'","")
+                    return addOrRunPipedMenus()
+                launcher = sys.argv[0]
+                launcher = f"python3.11 {launcher}" if launcher.endswith(".py") else launcher
+                scannerOptionQuoted = scannerOption.replace("'",'"')
+                OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener with piped scanners. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} {scannerOptionQuoted}{colorText.END}")
+                sleep(2)
+                os.system(f"{launcher} {scannerOptionQuoted}")
+                OutputControls().printOutput(
+                        colorText.GREEN
+                        + f"[+] Finished running all piped scanners!"
+                        + colorText.END
+                    )
+                if defaultAnswer is None:
+                    input("Press <Enter> to exit...")
+                sys.exit(0)
+            else:
+                return None, None
+        elif predefinedOption == "2":
+            # User chose custom
+            menuOption = "X" # Let's have the user choose various scan options
+            selectedMenu = m0.find(menuOption)
+            selectedChoice["0"] = selectedMenu.menuKey
+            if userPassedArgs.pipedmenus is None:
+                userPassedArgs.pipedmenus = ""
+        elif predefinedOption == "3":
+            if userPassedArgs.pipedmenus is not None:
+                return addOrRunPipedMenus()
+    if menuOption in ["X", "T", "E", "Y", "U", "H", "C"]:
+        # Print Level 2 menu options
+        menuOption, indexOption, executeOption, selectedChoice = getScannerMenuChoices(
+            testBuild or testing,
+            downloadOnly,
+            startupoptions,
+            menuOption=menuOption,
+            indexOption=indexOption,
+            executeOption=executeOption,
+            defaultAnswer=defaultAnswer,
+            user=user,
+        )
+
+        if menuOption in ["H", "U", "T", "E", "Y"]:
+            Utility.tools.clearScreen(forceTop=True)
+            return None, None
+    elif menuOption in ["B", "G"]:
+        # Backtests
+        backtestPeriod = 0
+        if len(options) >= 2:
+            if str(indexOption).isnumeric():
+                backtestPeriod = int(indexOption)
+            if len(options) >= 4:
+                indexOption = executeOption
+                executeOption = options[3]
+            del options[1]  # Let's delete the backtestperiod from the provided options
+        indexOption, executeOption, backtestPeriod = takeBacktestInputs(
+            str(menuOption).upper(), indexOption, executeOption, backtestPeriod
+        )
+        backtestPeriod = backtestPeriod * configManager.backtestPeriodFactor
+    elif menuOption in ["S"]:
+        if len(options) >= 2:
+            userOption = options[1]
+        if defaultAnswer is None:
+            selectedMenu = m0.find(menuOption)
+            m1.strategyNames = PortfolioXRay.strategyNames()
+            m1.renderForMenu(selectedMenu=selectedMenu)
+            try:
+                userOption = input(
+                            colorText.BOLD + colorText.FAIL + "[+] Select option: "
+                        )
+                OutputControls().printOutput(colorText.END, end="")
+                if userOption == "":
+                    userOption = "37" # NoFilter
+                elif userOption == "38":
+                    userOption = input(
+                            colorText.BOLD + colorText.FAIL + "[+] Enter Exact Pattern name:"
+                        )
+                    OutputControls().printOutput(colorText.END, end="")
+                    if userOption == "":
+                        userOption = "37" # NoFilter
+                    else:
+                        strategyFilter.append(f"[P]{userOption}")
+                        userOption = "38"
+            except EOFError:  # pragma: no cover
+                userOption = "37"  # NoFilter
+                pass
+            except Exception as e:# pragma: no cover
+                default_logger().debug(e, exc_info=True)
+                pass
+        userOption = userOption.upper()
+        if userOption == "M":
+            Utility.tools.clearScreen(forceTop=True)
+            # Go back to the caller. It will show the console menu again.
+            return None, None
+        elif userOption == "Z":
+            handleExitRequest(userOption)
+            return None, None
+        
+        if userOption == "S":
+            OutputControls().printOutput(
+                colorText.GREEN
+                + "[+] Collecting all metrics for summarising..."
+                + colorText.END
+            )
+            # Enable showing/saving past strategy data
+            savedValue = configManager.showPastStrategyData
+            configManager.showPastStrategyData = True
+            df_all = PortfolioXRay.summariseAllStrategies()
+            if df_all is not None and len(df_all) > 0:
+                OutputControls().printOutput(
+                    colorText.miniTabulator().tabulate(
+                        df_all,
+                        headers="keys",
+                        tablefmt=colorText.No_Pad_GridFormat,
+                        showindex=False,
+                        maxcolwidths=Utility.tools.getMaxColumnWidths(df_all)
+                    ).encode("utf-8").decode(STD_ENCODING)
+                )
+                showBacktestResults(
+                    df_all, sortKey="Scanner", optionalName="InsightsSummary"
+                )
+            else:
+                OutputControls().printOutput("[!] Nothing to show here yet. Check back later.")
+            # reinstate whatever was the earlier saved value
+            configManager.showPastStrategyData = savedValue
+            if defaultAnswer is None:
+                input("Press <Enter> to continue...")
+            return None, None
+        else:
+            userOptions = userOption.split(",")
+            for usrOption in userOptions:
+                strategyFilter.append(m1.find(usrOption).menuText.strip())
+            menuOption, indexOption, executeOption, selectedChoice = getScannerMenuChoices(
+            testBuild or testing,
+            downloadOnly,
+            startupoptions,
+            menuOption="X",
+            indexOption=indexOption,
+            executeOption=executeOption,
+            defaultAnswer=defaultAnswer,
+            user=user,
+        )
+
+    else:
+        OutputControls().printOutput("Not implemented yet! Try selecting a different option.")
+        sleep(3)
+        return None, None
+
+    handleMenu_XBG(menuOption, indexOption, executeOption)
+    if indexOption == "M" or executeOption == "M":
+        Utility.tools.clearScreen(forceTop=True)
+        # Go back to the caller. It will show the console menu again.
+        return None, None
+    listStockCodes = handleRequestForSpecificStocks(options, indexOption)
+    handleExitRequest(executeOption)
+    if executeOption is None:
+        executeOption = 0
+    executeOption = int(executeOption)
+    volumeRatio = configManager.volumeRatio
+    if executeOption == 3:
+        userPassedArgs.maxdisplayresults = 2000 # force evaluate all stocks before getting the top results
+    if executeOption == 4:
+        daysForLowestVolume = handleScannerExecuteOption4(executeOption, options)
+    if executeOption == 5:
+        selectedMenu = m2.find(str(executeOption))
+        if len(options) >= 5:
+            if str(options[3]).isnumeric():
+                minRSI = int(options[3])
+                maxRSI = int(options[4])
+            elif str(options[3]).upper() == "D":
+                # Use a default value
+                minRSI = 60
+                maxRSI = 75
+        else:
+            minRSI, maxRSI = Utility.tools.promptRSIValues()
+        if not minRSI and not maxRSI:
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "\n[+] Error: Invalid values for RSI! Values should be in range of 0 to 100. Please try again!"
+                + colorText.END
+            )
+            input("PRess <Enter> to continue...")
+            return None, None
+    if executeOption == 6:
+        selectedMenu = m2.find(str(executeOption))
+        if len(options) >= 4:
+            reversalOption = int(options[3])
+            if reversalOption in [4, 6, 7, 10]:
+                if len(options) >= 5:
+                    if str(options[4]).isnumeric():
+                        maLength = int(options[4])
+                    elif str(options[4]).upper() == "D":
+                        maLength = 50 if reversalOption == 4 else (3 if reversalOption in [7] else (2 if reversalOption in [10] else 7))
+                elif defaultAnswer == "Y" and user is not None:
+                    # bot mode
+                    maLength = 50 if reversalOption == 4 else (3 if reversalOption == 7 else 7)
+                else:
+                    reversalOption, maLength = Utility.tools.promptReversalScreening(
+                        selectedMenu
+                    )
+        else:
+            reversalOption, maLength = Utility.tools.promptReversalScreening(
+                selectedMenu
+            )
+        if reversalOption is None or reversalOption == 0 or maLength == 0:
+            return None, None
+        else:
+            selectedChoice["3"] = str(reversalOption)
+            if str(reversalOption) in ["7", "10"]:
+                selectedChoice["4"] = str(maLength)
+    if executeOption == 7:
+        selectedMenu = m2.find(str(executeOption))
+        maLength = 0
+        if len(options) >= 4:
+            respChartPattern = int(options[3])
+            selectedChoice["3"] = options[3]
+            if respChartPattern in [1, 2, 3]:
+                if len(options) >= 5:
+                    if "".join(str(options[4]).split(".")).isdecimal():
+                        insideBarToLookback = float(options[4])
+                    elif str(options[4]).upper() == "D":
+                        insideBarToLookback = 7 if respChartPattern in [1, 2] else 0.02
+                    if len(options) >= 6:
+                        if str(options[5]).isnumeric():
+                            maLength = int(options[5])
+                        elif str(options[5]).upper() == "D":
+                            maLength = 1 # Conf. up
+                elif defaultAnswer == "Y" and user is not None:
+                    # bot mode
+                    insideBarToLookback = 7 if respChartPattern in [1, 2] else 0.02
+                    maLength = 1 if respChartPattern in [3] else 0
+                else:
+                    (
+                        respChartPattern,
+                        insideBarToLookback,
+                    ) = Utility.tools.promptChartPatterns(selectedMenu)
+                if maLength == 0:
+                    maLength = Utility.tools.promptChartPatternSubMenu(selectedMenu, respChartPattern)
+            elif respChartPattern in [0, 4, 5, 6, 7]:
+                insideBarToLookback = 0
+                if respChartPattern == 6:
+                    if len(options) >= 5:
+                        if str(options[4]).isnumeric():
+                            maLength = int(options[4])
+                        elif str(options[4]).upper() == "D":
+                            maLength = 1 # Bollinger Bands Squeeze-Buy
+                    elif defaultAnswer == "Y" and user is not None:
+                        # bot mode
+                        maLength = 4 # Bollinger Bands Squeeze- Any/All
+                    else:
+                        maLength = Utility.tools.promptChartPatternSubMenu(selectedMenu,respChartPattern)
+            else:
+                (
+                    respChartPattern,
+                    insideBarToLookback,
+                ) = Utility.tools.promptChartPatterns(selectedMenu)
+        else:
+            respChartPattern, insideBarToLookback = Utility.tools.promptChartPatterns(
+                selectedMenu
+            )
+            if maLength == 0 and respChartPattern in [1, 2, 3, 6]:
+                maLength = Utility.tools.promptChartPatternSubMenu(selectedMenu, respChartPattern)
+        if (
+            respChartPattern is None
+            or insideBarToLookback is None
+            or respChartPattern == 0
+            or (maLength == 0 and respChartPattern in [1, 2, 3, 6])
+        ):
+            return None, None
+        else:
+            selectedChoice["3"] = str(respChartPattern)
+            selectedChoice["4"] = str(insideBarToLookback) if (respChartPattern in [1, 2, 3] and (userPassedArgs is not None and userPassedArgs.pipedmenus is not None)) else str(maLength)
+            selectedChoice["5"] = str(maLength) if (respChartPattern in [1, 2, 3] and (userPassedArgs is not None and userPassedArgs.pipedmenus is not None)) else ""
+    if executeOption == 8:
+        if len(options) >= 5:
+            if "".join(str(options[3]).split(".")).isdecimal():
+                minRSI = int(options[3])
+            if "".join(str(options[4]).split(".")).isdecimal():
+                maxRSI = int(options[4])
+            if str(options[3]).upper() == "D":
+                minRSI = -150
+                maxRSI = 250
+        else:
+            minRSI, maxRSI = Utility.tools.promptCCIValues()
+        if not minRSI and not maxRSI:
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "\n[+] Error: Invalid values for CCI! Values should be in range of -300 to 500. Please try again!"
+                + colorText.END
+            )
+            input("Press <Enter> to continue...")
+            return None, None
+    if executeOption == 9:
+        if len(options) >= 4:
+            if str(options[3]).isnumeric():
+                volumeRatio = float(options[3])
+            elif str(options[3]).upper() == "D":
+                volumeRatio = configManager.volumeRatio
+        else:
+            volumeRatio = Utility.tools.promptVolumeMultiplier()
+        if volumeRatio <= 0:
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "\n[+] Error: Invalid values for Volume Ratio! Value should be a positive number. Please try again!"
+                + colorText.END
+            )
+            input("Press <Enter> to continue...")
+            return None, None
+        else:
+            configManager.volumeRatio = float(volumeRatio)
+    if executeOption == 12:
+        candleDuration = userPassedArgs.intraday if (userPassedArgs is not None and userPassedArgs.intraday is not None) else ("15m")
+        configManager.toggleConfig(candleDuration=candleDuration)
+        global nValueForMenu 
+        nValueForMenu = candleDuration
+    if executeOption == 21:
+        selectedMenu = m2.find(str(executeOption))
+        if len(options) >= 4:
+            popOption = int(options[3])
+            if popOption >= 0 and popOption <= 9:
+                pass
+        else:
+            popOption = Utility.tools.promptSubMenuOptions(selectedMenu)
+        if popOption is None or popOption == 0:
+            return None, None
+        else:
+            selectedChoice["3"] = str(popOption)
+        if popOption in [1,2,4]:
+            updateMenuChoiceHierarchy()
+            if popOption == 4:
+                screenResults = mstarFetcher.fetchMorningstarTopDividendsYieldStocks()
+            elif popOption in [1,2]:
+                screenResults = mstarFetcher.fetchMorningstarFundFavouriteStocks(
+                    "NoOfFunds" if popOption == 2 else "ChangeInShares"
+                )
+            if menuOption in ["X"]:
+                printNotifySaveScreenedResults(
+                    screenResults,
+                    screenResults,
+                    selectedChoice,
+                    menuChoiceHierarchy,
+                    False,
+                    None,
+                )
+                if defaultAnswer is None:
+                    input("Press <Enter> to continue...")
+                return None, None
+            else:
+                listStockCodes = ",".join(list(screenResults.index))
+        else:
+            userPassedArgs.maxdisplayresults = 2000 # force evaluate all stocks before getting the top results
+            reversalOption = popOption
+    if executeOption == 22:
+        selectedMenu = m2.find(str(executeOption))
+        if len(options) >= 4:
+            popOption = int(options[3])
+            if popOption >= 0 and popOption <= 3:
+                pass
+        else:
+            popOption = Utility.tools.promptSubMenuOptions(selectedMenu)
+        if popOption is None or popOption == 0:
+            return None, None
+        else:
+            selectedChoice["3"] = str(popOption)
+        updateMenuChoiceHierarchy()
+        screenResults = mstarFetcher.fetchMorningstarStocksPerformanceForExchange()
+        if menuOption in ["X"]:
+            printNotifySaveScreenedResults(
+                screenResults,
+                screenResults,
+                selectedChoice,
+                menuChoiceHierarchy,
+                False,
+                None,
+            )
+            if defaultAnswer is None:
+                input("Press <Enter> to continue...")
+            return None, None
+        else:
+            listStockCodes = ",".join(list(screenResults.index))
+    if executeOption == 26:
+        dividend_df, bonus_df, stockSplit_df = mstarFetcher.getCorporateActions()
+        ca_dfs = [dividend_df, bonus_df, stockSplit_df]
+        listStockCodes = []
+        for df in ca_dfs:
+            df = df[
+                df["Stock"].astype(str).str.contains("BSE:") == False
+            ]
+            listStockCodes.extend(list(df["Stock"]))
+    if executeOption == 30:
+        selectedMenu = m2.find(str(executeOption))
+        if len(options) >= 4:
+            if str(options[3]).isnumeric():
+                maLength = int(options[3])
+            elif str(options[3]).upper() == "D":
+                maLength = 1
+            else:
+                maLength = 1
+        elif len(options) >= 3:
+            maLength = 1 # By default buy option
+        else:
+            maLength = Utility.tools.promptSubMenuOptions(selectedMenu)
+        if maLength == 0:
+            return None, None
+        else:
+            selectedChoice["3"] = str(maLength)
+        if userPassedArgs.options is None:
+            Utility.tools.clearScreen(forceTop=True)
+            atrSensitivity = input(colorText.WARN + f"Enter the ATR Trailing Stop Sensitivity (Multiplier) value (Optimal:1, Current={configManager.atrTrailingStopSensitivity}):") or configManager.atrTrailingStopSensitivity
+            configManager.atrTrailingStopSensitivity = atrSensitivity
+            atrPeriod = input(colorText.WARN + f"Enter the ATR Period value (Optimal:10, Current={configManager.atrTrailingStopPeriod}):") or configManager.atrTrailingStopPeriod
+            configManager.atrTrailingStopPeriod = atrPeriod
+            atrEma = input(colorText.WARN + f"Enter the ATR EMA period (Optimal:200, Current={configManager.atrTrailingStopEMAPeriod}):") or configManager.atrTrailingStopEMAPeriod
+            configManager.atrTrailingStopEMAPeriod = atrEma
+            configManager.setConfig(ConfigManager.parser,default=True,showFileCreatedText=False)
+
+    if executeOption == 42:
+        Utility.tools.getLastScreenedResults(defaultAnswer)
+        return None, None
+    if executeOption >= MAX_SUPPORTED_MENU_OPTION and executeOption <= MAX_MENU_OPTION:
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + F"\n[+] Error: Option {MAX_SUPPORTED_MENU_OPTION} to {MAX_MENU_OPTION} Not implemented yet! Press <Enter> to continue."
+            + colorText.END
+        )
+        input("Press <Enter> to continue...")
+        return None, None
+    if (
+        not str(indexOption).isnumeric() and indexOption in ["W", "E", "M", "N", "Z"]
+    ) or (
+        str(indexOption).isnumeric()
+        and (int(indexOption) >= 0 and int(indexOption) < 16)
+    ):
+        configManager.getConfig(ConfigManager.parser)
+        try:
+            if indexOption == "W":
+                listStockCodes = fetcher.fetchWatchlist()
+                if listStockCodes is None:
+                    input(
+                        colorText.BOLD
+                        + colorText.FAIL
+                        + f"[+] Please create the watchlist.xlsx file in {os.getcwd()} and Restart the Program!"
+                        + colorText.END
+                    )
+                    sys.exit(0)
+            elif indexOption == "N":
+                os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
+                prediction, pText, sText = screener.getNiftyPrediction(
+                    df=fetcher.fetchLatestNiftyDaily(proxyServer=fetcher.proxyServer)
+                )
+                warningText = "\nNifty AI prediction works best if you request after market is closed. It may not be accurate while market is still open!" if "Open" in Utility.marketStatus() else ""
+                try:
+                    todayHoliday, todayOccassion = PKDateUtilities.isHoliday(PKDateUtilities.currentDateTime())
+                    nextWeekday = PKDateUtilities.nextWeekday()
+                    tomorrowHoliday,tomorrowOccassion = PKDateUtilities.isHoliday(nextWeekday)
+                    if todayHoliday:
+                        warningText = f"{warningText}\n\nMarket is closed today due to {todayOccassion}."
+                    if tomorrowHoliday:
+                        warningText = f"{warningText}\n\nMarket will be closed on {nextWeekday.strftime('%Y-%m-%d')} due to {tomorrowOccassion}."
+                except:
+                    pass
+                sendMessageToTelegramChannel(
+                    message=f"{Utility.tools.removeAllColorStyles(Utility.marketStatus())}\nNifty AI prediction for the Next Day: {pText}. {sText}.{warningText}",
+                    user=user,
+                )
+                if defaultAnswer is None:
+                    input("\nPress <Enter> to Continue...\n")
+                return None, None
+            elif indexOption == "M":
+                return None, None
+            elif indexOption == "Z":
+                input(
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + "[+] Press <Enter> to Exit!"
+                    + colorText.END
+                )
+                sys.exit(0)
+            elif indexOption == "E":
+                return handleMonitorFiveEMA()
+            else:
+                if str(menuOption).upper() == "C":
+                    stockDictPrimary,endOfdayCandles = PKMarketOpenCloseAnalyser.getStockDataForSimulation()
+                    if stockDictPrimary is None or endOfdayCandles is None:
+                        OutputControls().printOutput(f"Cannot proceed! Stock data is unavailable. Please check the error logs/messages !")
+                        return None, None
+                    if indexOption > 0:
+                        listStockCodes = sorted(list(filter(None,list(set(stockDictPrimary.keys())))))
+                listStockCodes = prepareStocksForScreening(testing, downloadOnly, listStockCodes, indexOption)
+        except urllib.error.URLError as e:
+            default_logger().debug(e, exc_info=True)
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "\n\n[+] Oops! It looks like you don't have an Internet connectivity at the moment!"
+                + colorText.END
+            )
+            input("Exiting now...")
+            sys.exit(0)
+        if userPassedArgs.options is None or len(userPassedArgs.options) == 0:
+            userPassedArgs.options = ""
+            for choice in selectedChoice.keys():
+                userPassedArgs.options = (f"{userPassedArgs.options}:" if len(userPassedArgs.options) > 0  else '') + f"{selectedChoice[choice]}"
+        if userPassedArgs.pipedmenus is not None:
+            return addOrRunPipedMenus()
+
+        if (menuOption in ["X", "B", "G", "S"] and not loadedStockData) or (
+            # not downloadOnly
+            # and not PKDateUtilities.isTradingTime()
+            # and 
+            configManager.cacheEnabled
+            and not loadedStockData
+            and not testing
+        ):
+            stockDictPrimary,stockDictSecondary = loadDatabaseOrFetch(downloadOnly, listStockCodes, menuOption, indexOption)
+            
+        loadCount = len(stockDictPrimary) if stockDictPrimary is not None else 0
+
+        if downloadOnly:
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.WARN
+                + "[+] Starting download.. Press Ctrl+C to stop!"
+            )
+            if not configManager.isIntradayConfig():
+                fetcher.saveAllNSEIndices()
+        if menuOption.upper() in ["B", "G"]:
+            OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + f"[+] A total of {configManager.backtestPeriod} trading periods' historical data will be considered for backtesting. You can change this in User Config."
+                )
+        samplingDuration, fillerPlaceHolder, actualHistoricalDuration = PKScanRunner.getScanDurationParameters(testing, menuOption)
+        totalStocksInReview = 0
+        savedStocksCount = 0
+        downloadedRecently = False
+        items = []
+        backtest_df = None
+        bar, spinner = Utility.tools.getProgressbarStyle()
+        # Lets begin from y days ago, evaluate from that date if the selected strategy had yielded any result
+        # and then keep coming to the next day (x-1) until we get to today (actualHistoricalDuration = 0)
+        OutputControls().printOutput(f"{colorText.GREEN}[+] Adding stocks to the queue...{colorText.END}")
+        with alive_bar(actualHistoricalDuration, bar=bar, spinner=spinner) as progressbar:
+            while actualHistoricalDuration >= 0:
+                daysInPast = PKScanRunner.getBacktestDaysForScan(userPassedArgs, backtestPeriod, menuOption, actualHistoricalDuration)
+                try:
+                    listStockCodes, savedStocksCount, pastDate = PKScanRunner.getStocksListForScan(userPassedArgs, menuOption, totalStocksInReview, downloadedRecently, daysInPast) if menuOption not in ["C"] else (listStockCodes, 0, "")
+                except KeyboardInterrupt:
+                    try:
+                        keyboardInterruptEvent.set()
+                        keyboardInterruptEventFired = True
+                        actualHistoricalDuration = -1
+                        break
+                    except KeyboardInterrupt:
+                        pass
+                    OutputControls().printOutput(
+                        colorText.BOLD
+                        + colorText.FAIL
+                        + "\n[+] Terminating Script, Please wait..."
+                        + colorText.END
+                    )
+                except Exception:
+                    pass
+                exchangeName = "NASDAQ" if (indexOption == 15 or (configManager.defaultIndex == 15 and indexOption == 0)) else "INDIA"
+                PKScanRunner.addStocksToItemList(userPassedArgs, testing, testBuild, newlyListedOnly, downloadOnly, minRSI, maxRSI, insideBarToLookback, respChartPattern, daysForLowestVolume, backtestPeriod, reversalOption, maLength, listStockCodes, menuOption,exchangeName,executeOption, volumeRatio, items, daysInPast)
+                if savedStocksCount > 0:
+                    progressbar.text(
+                        colorText.BOLD
+                        + colorText.GREEN
+                        + f"Total Stocks: {len(items)}. Added {savedStocksCount} to Stocks from {pastDate} saved from earlier..."
+                        + colorText.END
+                    )
+                fillerPlaceHolder = fillerPlaceHolder + 1
+                actualHistoricalDuration = samplingDuration - fillerPlaceHolder
+                if actualHistoricalDuration >= 0:
+                    progressbar()
+        sys.stdout.write(f"\x1b[1A") # Replace the download progress bar and start writing on the same line
+        if not keyboardInterruptEventFired:
+            global tasks_queue, results_queue, consumers, logging_queue
+            screenResults, saveResults, backtest_df, tasks_queue, results_queue, consumers,logging_queue = PKScanRunner.runScanWithParams(userPassedArgs,keyboardInterruptEvent,screenCounter,screenResultsCounter,stockDictPrimary,stockDictSecondary,testing, backtestPeriod, menuOption,executeOption, samplingDuration, items,screenResults, saveResults, backtest_df,scanningCb=runScanners,tasks_queue=tasks_queue, results_queue=results_queue, consumers=consumers,logging_queue=logging_queue)
+            if userPassedArgs is not None and (userPassedArgs.monitor is None and "|" not in userPassedArgs.options and not userPassedArgs.options.upper().startswith("C")):
+                tasks_queue = None
+                results_queue = None
+                consumers = None
+            if menuOption in ["C"]:
+                runOptionName = PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)
+                PKMarketOpenCloseAnalyser.runOpenCloseAnalysis(stockDictPrimary,endOfdayCandles,screenResults, saveResults,runOptionName=runOptionName,filteredListOfStocks=listStockCodes)
+            if downloadOnly and menuOption in ["X"]:
+                screener.getFreshMFIStatus(stock="LatestCheckedOnDate")
+                screener.getFairValue(stock="LatestCheckedOnDate", force=True)
+            if not downloadOnly and menuOption in ["X", "G", "C"]:
+                if menuOption == "G":
+                    userPassedArgs.backtestdaysago = backtestPeriod
+                if screenResults is not None and len(screenResults) > 0:
+                    screenResults, saveResults = labelDataForPrinting(
+                        screenResults, saveResults, configManager, volumeRatio, executeOption, reversalOption or respChartPattern
+                    )
+                    # ticker_list = list(saveResults.index)
+                    # marketCaps = fetcher.fetchAdditionalTickerInfo(ticker_list)
+                    # saveResults["MCapWt%"] = 0
+                    # numShares = []
+                    # for ticker in ticker_list:
+                    #     try:
+                    #         mCap = marketCaps.get(f"{ticker}.NS")
+                    #         mCap = round(mCap.get("marketCap"),0)
+                    #     except:
+                    #         mCap = 0
+                    #         pass
+                    #     saveResults.loc[ticker, 'MCapWt%'] = mCap
+                    # # Let's get the weighted no. of shares
+                    # marketCapSum = sum(saveResults["MCapWt%"])
+                    # for ticker in ticker_list:
+                    #     try:
+                    #         saveResults.loc[ticker, 'MCapWt%'] = int(round(saveResults.loc[ticker, 'MCapWt%']/marketCapSum,2)*100)
+                    #     except:
+                    #         saveResults.loc[ticker, 'MCapWt%'] = 0
+                    #         pass
+                    #     numShares.append(saveResults.loc[ticker, 'MCapWt%'])
+                    # screenResults["MCapWt%"] = numShares
+                if not newlyListedOnly and not configManager.showunknowntrends and screenResults is not None and len(screenResults) > 0:
+                    screenResults, saveResults = removeUnknowns(screenResults, saveResults)
+                    OutputControls().printOutput(colorText.FAIL + f"[+] Configuration to remove unknown cell values resulted into removing all rows!" + colorText.END)
+                if len(strategyFilter) > 0 and saveResults is not None and len(saveResults) > 0:
+                    # We'd need to apply additional filters for selected strategy
+                    df_screenResults = None
+                    cleanedUpSaveResults = PortfolioXRay.cleanupData(saveResults)
+                    for strFilter in strategyFilter:
+                        cleanedUpSaveResults = PortfolioXRay.strategyForKey(strFilter)(cleanedUpSaveResults)
+                        saveResults = saveResults[saveResults.index.isin(cleanedUpSaveResults.index.values)]
+                    for stk in saveResults.index.values:
+                        df_screenResults_filter = screenResults[screenResults.index.astype(str).str.contains(f"NSE%3A{stk}") == True]
+                        df_screenResults = pd.concat([df_screenResults, df_screenResults_filter], axis=0)
+                    if df_screenResults is None or len(df_screenResults) == 0:
+                        OutputControls().printOutput(colorText.FAIL + f"[+] Of the {len(screenResults) if screenResults is not None else 0} stocks, no results matching the selected strategies!" + colorText.END)
+                    screenResults = df_screenResults
+                if executeOption == 26:
+                    removedUnusedColumns(screenResults, saveResults, ["Date"],userArgs=userPassedArgs)
+                    screen_copy = screenResults.copy()
+                    screen_copy.reset_index(inplace=True)
+                    dividend_df = pd.merge(screen_copy, dividend_df, on='Stock')
+                    bonus_df = pd.merge(screen_copy, bonus_df, on='Stock')
+                    stockSplit_df = pd.merge(screen_copy, stockSplit_df, on='Stock')
+                    corp_dfs = [dividend_df, bonus_df, stockSplit_df]
+                    shareable_strings = []
+                    shouldSend = False
+                    for corp_df in corp_dfs:
+                        if corp_df is None:
+                            continue
+                        tab_results = ""
+                        if corp_df is not None and not corp_df.empty:
+                            corp_df.set_index("Stock", inplace=True)
+                            corp_df = corp_df[~corp_df.index.duplicated(keep='first')]
+                            tab_results = colorText.miniTabulator().tabulate(
+                                corp_df,
+                                headers="keys",
+                                tablefmt=colorText.No_Pad_GridFormat,
+                                # showindex = False,
+                                maxcolwidths=Utility.tools.getMaxColumnWidths(dividend_df)
+                            ).encode("utf-8").decode(STD_ENCODING)
+                            shouldSend = True
+                        shareable_strings.append(tab_results)
+                        OutputControls().printOutput(tab_results)
+                    if shouldSend:
+                        sendQuickScanResult(
+                            menuChoiceHierarchy,
+                            user,
+                            shareable_strings[0],
+                            Utility.tools.removeAllColorStyles(shareable_strings[0]),
+                            "NSE Stocks with dividends/bonus/splits soon",
+                            f"PKS_X_12_26_{PKDateUtilities.currentDateTime().strftime('%Y-%m-%d_%H:%M:%S')}",
+                            ".png",
+                            addendum=shareable_strings[1],
+                            addendumLabel="NSE Stocks giving bonus:",
+                            backtestSummary=shareable_strings[2],
+                            backtestDetail="",
+                            summaryLabel = "NSE Stocks with corporate action type stock split:",
+                            detailLabel = None,
+                            )
+                elif "|" not in userPassedArgs.options:
+                    try:
+                        printNotifySaveScreenedResults(
+                            screenResults,
+                            saveResults,
+                            selectedChoice,
+                            menuChoiceHierarchy,
+                            testing,
+                            user=user,
+                        )
+                    except Exception as e:
+                        default_logger().debug(e, exc_info=True)
+                        if userPassedArgs.log:
+                            import traceback
+                            traceback.print_exc()
+                        pass
+        if menuOption in ["X","C"] and userPassedArgs.monitor is None:
+            finishScreening(
+                downloadOnly,
+                testing,
+                stockDictPrimary,
+                configManager,
+                loadCount,
+                testBuild,
+                screenResults,
+                saveResults,
+                user,
+            )
+
+        if menuOption == "B" and backtest_df is not None and len(backtest_df) > 0:
+            Utility.tools.clearScreen()
+            # Let's do the portfolio calculation first
+            df_xray = prepareGroupedXRay(backtestPeriod, backtest_df)
+            summary_df, sorting, sortKeys = FinishBacktestDataCleanup(backtest_df, df_xray)
+            while sorting:
+                sorting = showSortedBacktestData(backtest_df, summary_df, sortKeys)
+            if defaultAnswer is None:
+                input("Press <Enter> to continue...")
+        elif menuOption == "B":
+            OutputControls().printOutput("Finished backtesting with no results to show!")
+        elif menuOption == "G":
+            if defaultAnswer is None:
+                input("Press <Enter> to continue...")
+    newlyListedOnly = False
+    # Change the config back to usual
+    resetConfigToDefault()
+    try:
+        creds = None
+        # Write into sheet only if it's the reglar scan alert trigger in the morning and evening
+        if 'ALERT_TRIGGER' in os.environ.keys() and os.environ["ALERT_TRIGGER"] == 'Y':
+            if "GSHEET_SERVICE_ACCOUNT_DEV" in os.environ.keys() and (userPassedArgs.backtestdaysago is None):# or userPassedArgs.log:
+                begin = time.time()
+                creds = os.environ.get("GSHEET_SERVICE_ACCOUNT_DEV")
+                OutputControls().printOutput(f"{colorText.GREEN}[+] Saving data to Google Spreadsheets now...{colorText.END}")
+                gClient = PKSpreadsheets(credentialDictStr=creds)
+                runOption = PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)
+                df = saveResults.copy()
+                df["LastTradeDate"], df["LastTradeTime"] = getLatestTradeDateTime(stockDictPrimary)
+                gClient.df_to_sheet(df=df,sheetName=runOption)
+                OutputControls().printOutput(f"{colorText.GREEN} => Done in {round(time.time()-begin,2)}s{colorText.END}")
+    except:
+        pass
+    if "RUNNER" not in os.environ.keys() and (userPassedArgs is None or (userPassedArgs is not None and (userPassedArgs.answerdefault is None or userPassedArgs.systemlaunched))):
+        prevOutput_results = saveResults.index if (saveResults is not None and not saveResults.empty) else []
+        hasFoundStocks = len(prevOutput_results) > 0 and (("|" not in userPassedArgs.options) if (userPassedArgs is not None and userPassedArgs.options is not None) else True)
+        if hasFoundStocks:
+            monitorOption = userPassedArgs.systemlaunched if (userPassedArgs is not None and isinstance(userPassedArgs.systemlaunched,str) and userPassedArgs.systemlaunched is not None) else (userPassedArgs.options if (userPassedArgs is not None and userPassedArgs.options is not None) else "")
+            if len(monitorOption) == 0:
+                for choice in selectedChoice.keys():
+                    monitorOption = (f"{monitorOption}:" if len(monitorOption) > 0  else '') + f"{selectedChoice[choice]}"
+            m0.renderPinnedMenu(substitutes=[monitorOption,len(prevOutput_results)])
+            pinOption = input(
+                    colorText.BOLD + colorText.FAIL + "[+] Select option: "
+                ) or 'M'
+            OutputControls().printOutput(colorText.END, end="")
+            if pinOption in ["1","2"]:
+                if pinOption in ["2"]:
+                    monitorOption = "X:0:0"
+                    prevOutput_results = ",".join(prevOutput_results)
+                    monitorOption = f"{monitorOption}:{prevOutput_results}"
+                launcher = sys.argv[0]
+                launcher = f"python3.11 {launcher}" if launcher.endswith(".py") else launcher
+                monitorOption = f'"{monitorOption}"'
+                scannerOptionQuoted = monitorOption.replace("'",'"')
+                OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener with pinned scan option. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -m {scannerOptionQuoted}{colorText.END}")
+                sleep(2)
+                os.system(f"{launcher} -a Y -m {scannerOptionQuoted}")
+
+    if userPassedArgs is not None:
+        if userPassedArgs.runintradayanalysis:
+            analysis_df = screenResults.copy()
+            analysis_df.reset_index(inplace=True)
+            if 'index' in analysis_df.columns:
+                analysis_df.drop('index', axis=1, inplace=True, errors="ignore")
+            if optionalFinalOutcome_df is None:
+                optionalFinalOutcome_df = analysis_df
+            else:
+                optionalFinalOutcome_df = pd.concat([optionalFinalOutcome_df, analysis_df], axis=0)
+            return optionalFinalOutcome_df, saveResults
+        else:
+            existingTitle = f"{userPassedArgs.pipedtitle}|" if userPassedArgs.pipedtitle is not None else ""
+            choiceSegments = menuChoiceHierarchy.split(">")
+            choiceSegments = f"{choiceSegments[-2]} > {choiceSegments[-1]}" if len(choiceSegments)>=4 else f"{choiceSegments[-1]}"
+            userPassedArgs.pipedtitle = f'{existingTitle}{choiceSegments}[{len(saveResults)}]'
+            return screenResults, saveResults
+
+def loadDatabaseOrFetch(downloadOnly, listStockCodes, menuOption, indexOption):
+    global stockDictPrimary,stockDictSecondary, configManager, defaultAnswer, userPassedArgs, loadedStockData
+    if menuOption not in ["C"]:
+        stockDictPrimary = Utility.tools.loadStockData(
+                    stockDictPrimary,
+                    configManager,
+                    downloadOnly=downloadOnly,
+                    defaultAnswer=defaultAnswer,
+                    forceLoad=(menuOption in ["X", "B", "G", "S"]),
+                    stockCodes = listStockCodes,
+                    exchangeSuffix = "" if (indexOption == 15 or (configManager.defaultIndex == 15 and indexOption == 0)) else ".NS"
+            )
+    if menuOption not in ["C"] and (userPassedArgs.monitor is not None or "|" in userPassedArgs.options) :#not configManager.isIntradayConfig() and configManager.calculatersiintraday:
+        candleDuration = (userPassedArgs.intraday if (userPassedArgs is not None and userPassedArgs.intraday is not None) else "1m")
+        configManager.toggleConfig(candleDuration=candleDuration,clearCache=False)
+        # We also need to load the intraday data to be able to calculate intraday RSI
+        stockDictSecondary = Utility.tools.loadStockData(
+                        stockDictSecondary,
+                        configManager,
+                        downloadOnly=downloadOnly,
+                        defaultAnswer=defaultAnswer,
+                        forceLoad=(menuOption in ["X", "B", "G", "S"]),
+                        stockCodes = listStockCodes,
+                        isIntraday=True,
+                        exchangeSuffix = "" if (indexOption == 15 or (configManager.defaultIndex == 15 and indexOption == 0)) else ".NS"
+                )
+        resetConfigToDefault()
+    loadedStockData = True
+    return stockDictPrimary, stockDictSecondary
+
+def getLatestTradeDateTime(stockDictPrimary):
+    stocks = list(stockDictPrimary.keys())
+    stock = stocks[0]
+    try:
+        lastTradeDate = PKDateUtilities.currentDateTime().strftime("%Y-%m-%d")
+        lastTradeTime_ist = PKDateUtilities.currentDateTime().strftime("%H:%M:%S")
+        df = pd.DataFrame(data=stockDictPrimary[stock]["data"],
+                        columns=stockDictPrimary[stock]["columns"],
+                        index=stockDictPrimary[stock]["index"])
+        ts = df.index[-1]
+        lastTraded = pd.to_datetime(ts, unit='s', utc=True) #.tz_convert("Asia/Kolkata")
+        lastTradeDate = lastTraded.strftime("%Y-%m-%d")
+        lastTradeTime = lastTraded.strftime("%H:%M:%S")
+        if lastTradeTime == "00:00:00":
+            lastTradeTime = lastTradeTime_ist
+    except:
+        pass
+    return lastTradeDate, lastTradeTime
+
+def FinishBacktestDataCleanup(backtest_df, df_xray):
+    showBacktestResults(df_xray, sortKey="Date", optionalName="Insights")
+    summary_df = backtestSummary(backtest_df)
+    backtest_df.loc[:, "Date"] = backtest_df.loc[:, "Date"].apply(
+                lambda x: x.replace("-", "/")
+            )
+    showBacktestResults(backtest_df)
+    showBacktestResults(summary_df, optionalName="Summary")
+    sorting = False if defaultAnswer is not None else True
+    sortKeys = {
+                "S": "Stock",
+                "D": "Date",
+                "1": "1-Pd",
+                "2": "2-Pd",
+                "3": "3-Pd",
+                "4": "4-Pd",
+                "5": "5-Pd",
+                "10": "10-Pd",
+                "15": "15-Pd",
+                "22": "22-Pd",
+                "30": "30-Pd",
+                "T": "Trend",
+                "V": "Volume",
+                "M": "MA-Signal",
+            }
+    if configManager.enablePortfolioCalculations:
+        if 'RUNNER' not in os.environ.keys():
+            task1 = PKTask("PortfolioLedger",long_running_fn=PortfolioCollection().getPortfoliosAsDataframe)
+            task2 = PKTask("PortfolioLedgerSnapshots",long_running_fn=PortfolioCollection().getLedgerSummaryAsDataframe)
+            tasksList = [task1,task2]
+            PKScheduler.scheduleTasks(tasksList=tasksList, label=f"Portfolio Calculations Report Export(Total={len(tasksList)})",timeout=600)
+        else:
+            for task in tasksList:
+                task.long_running_fn(*(task,))
+        for task in tasksList:
+            if task.result is not None:
+                showBacktestResults(task.result, sortKey=None, optionalName=task.taskName)
+    
+    return summary_df,sorting,sortKeys
+
+def addOrRunPipedMenus():
+    global userPassedArgs
+    # User must have selected menu "P" earlier
+    savedPipes = f"{userPassedArgs.pipedmenus}:>|" if len(userPassedArgs.pipedmenus) > 0 else ""
+    userPassedArgs.pipedmenus = f"{savedPipes}{userPassedArgs.options}:D:D:D:"
+    userPassedArgs.pipedmenus = userPassedArgs.pipedmenus.replace("::",":D:")
+    userPassedArgs.pipedmenus = f"{userPassedArgs.pipedmenus}{('i '+configManager.duration) if configManager.isIntradayConfig() else ''}"
+    updateMenuChoiceHierarchy()
+    OutputControls().printOutput(
+            colorText.GREEN
+            + f"[+] {len(userPassedArgs.pipedmenus.split('|'))} Scanners piped so far: {colorText.END}{colorText.WARN+userPassedArgs.pipedmenus+colorText.END}\n{colorText.GREEN}[+] Do you want to add any more scanners into the pipe?"
+            + colorText.END
+        )
+    shouldAddMoreIntoPipe = input(colorText.FAIL + "[+] Select [Y/N] (Default:N): " + colorText.END) or 'n'
+    if shouldAddMoreIntoPipe.lower() != 'y':
+        launcher = sys.argv[0]
+        launcher = f"python3.11 {launcher}" if launcher.endswith(".py") else launcher
+        monitorOption = f'"{userPassedArgs.pipedmenus}"'
+        scannerOptionQuoted = monitorOption.replace("'",'"').replace(":>",":D:D:D:>").replace("::",":")
+        OutputControls().printOutput(f"{colorText.GREEN}Launching PKScreener with piped scanners. If it does not launch, please try with the following:{colorText.END}\n{colorText.FAIL}{launcher} -a Y -e -o {scannerOptionQuoted}{colorText.END}")
+        sleep(2)
+        os.system(f"{launcher} --systemlaunched -a Y -e -o {scannerOptionQuoted}")
+        userPassedArgs.pipedmenus = None
+        OutputControls().printOutput(
+                colorText.GREEN
+                + f"[+] Finished running all piped scanners!"
+                + colorText.END
+            )
+        if defaultAnswer is None:
+            input("Press <Enter> to exit...")
+        sys.exit(0)
+    else:
+        userPassedArgs.options = None
+        return None, None
+    
+def prepareGroupedXRay(backtestPeriod, backtest_df):
+    df_grouped = backtest_df.groupby("Date")
+    userPassedArgs.backtestdaysago = backtestPeriod
+    df_xray = None
+    groupCounter = 0
+    tasksList=[]
+    for calcForDate, df_group in df_grouped:
+        groupCounter += 1
+        func_args = (df_group, userPassedArgs, calcForDate,f"Portfolio X-Ray | {calcForDate} | {groupCounter} of {len(df_grouped)}")
+        task = PKTask(f"Portfolio X-Ray | {calcForDate} | {groupCounter} of {len(df_grouped)}",
+                      long_running_fn=PortfolioXRay.performXRay,
+                      long_running_fn_args=func_args)
+        task.total = len(df_grouped)
+        tasksList.append(task)
+    if 'RUNNER' not in os.environ.keys():
+        # if configManager.enablePortfolioCalculations:
+        # On Github CI, we may run out of memory because of saving results in
+        # shared multiprocessing dict.
+        PKScheduler.scheduleTasks(tasksList,f"Portfolio X-Ray for ({len(df_grouped)})", showProgressBars=False,timeout=600)
+    else:
+        # On Github CI, let's run synchronously.
+        for task in tasksList:
+            task.long_running_fn(*(task,))
+    for task in tasksList:
+        p_df = task.result
+        if p_df is not None:
+            if df_xray is not None:
+                df_xray = pd.concat([df_xray, p_df.copy()], axis=0)
+            else:
+                df_xray = p_df.copy()
+            # Let's drop the columns no longer required for backtest report
+
+    removedUnusedColumns(None, backtest_df, ["Consol.", "Breakout", "RSI", "Pattern", "CCI"], userArgs=userPassedArgs)
+    df_xray = df_xray.replace(np.nan, "", regex=True)
+    df_xray = PortfolioXRay.xRaySummary(df_xray)
+    df_xray.loc[:, "Date"] = df_xray.loc[:, "Date"].apply(
+                lambda x: x.replace("-", "/")
+            )
+    
+    return df_xray
+
+def showSortedBacktestData(backtest_df, summary_df, sortKeys):
+    OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + "[+] Would you like to sort the results?"
+                    + colorText.END
+                )
+    OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.GREEN
+                    + "[+] Press :\n [+] s, v, t, m : sort by Stocks, Volume, Trend, MA-Signal\n [+] d : sort by date\n [+] 1,2,3...30 : sort by period\n [+] n : Exit sorting\n"
+                    + colorText.END
+                )
+    if defaultAnswer is None:
+        choice = input(
+                        colorText.BOLD + colorText.FAIL + "[+] Select option:"
+                    )
+        OutputControls().printOutput(colorText.END, end="")
+        if choice.upper() in sortKeys.keys():
+            Utility.tools.clearScreen()
+            showBacktestResults(backtest_df, sortKeys[choice.upper()])
+            showBacktestResults(summary_df, optionalName="Summary")
+        else:
+            sorting = False
+    else:
+        OutputControls().printOutput("Finished backtesting!")
+        sorting = False
+    return sorting
+
+def resetConfigToDefault():
+    global userPassedArgs
+    isIntraday = userPassedArgs is not None and userPassedArgs.intraday is not None
+    if configManager.isIntradayConfig() or isIntraday:
+        configManager.toggleConfig(candleDuration="1d", clearCache=False)
+    if userPassedArgs is not None and userPassedArgs.monitor is None:
+        if "PKDevTools_Default_Log_Level" in os.environ.keys():
+            if userPassedArgs is None or (userPassedArgs is not None and userPassedArgs.options is not None and "|" not in userPassedArgs.options):
+                del os.environ['PKDevTools_Default_Log_Level']
+        configManager.logsEnabled = False
+    configManager.setConfig(ConfigManager.parser,default=True,showFileCreatedText=False)
+
+def prepareStocksForScreening(testing, downloadOnly, listStockCodes, indexOption):
+    if not downloadOnly:
+        updateMenuChoiceHierarchy()
+    indexOption = int(indexOption)
+    if listStockCodes is None or len(listStockCodes) == 0:
+        if indexOption >= 0 and indexOption <= 14:
+            shouldSuppress = not OutputControls().enableMultipleLineOutput
+            with SuppressOutput(suppress_stderr=shouldSuppress, suppress_stdout=shouldSuppress):
+                listStockCodes = fetcher.fetchStockCodes(
+                                indexOption, stockCode=None
+                            )
+        elif indexOption == 15:
+            OutputControls().printOutput(colorText.BOLD + "[+] Getting Stock Codes From NASDAQ... ", end="")
+            nasdaq = PKNasdaqIndexFetcher(configManager)
+            listStockCodes = nasdaq.fetchNasdaqIndexConstituents()
+            if len(listStockCodes) > 10:
+                OutputControls().printOutput(
+                    colorText.GREEN
+                    + ("=> Done! Fetched %d stock codes." % len(listStockCodes))
+                    + colorText.END
+                )
+                if configManager.shuffleEnabled:
+                    random.shuffle(listStockCodes)
+                    OutputControls().printOutput(
+                        colorText.BLUE
+                        + "[+] Stock shuffling is active."
+                        + colorText.END
+                    )
+            else:
+                OutputControls().printOutput(
+                    colorText.FAIL
+                    + ("=> Failed! Could not fetch stock codes from NASDAQ!")
+                    + colorText.END
+                )
+        if (listStockCodes is None or len(listStockCodes) == 0) and testing:
+            listStockCodes = [TEST_STKCODE if indexOption < 15 else "AMD"]
+    if indexOption == 0:
+        selectedChoice["3"] = ".".join(listStockCodes)
+    if testing:
+        listStockCodes = [random.choice(listStockCodes)]
+    return listStockCodes
+
+def handleMonitorFiveEMA():
+    result_df = pd.DataFrame(
+                    columns=["Time", "Stock/Index", "Action", "SL", "Target", "R:R"]
+                )
+    last_signal = {}
+    first_scan = True
+    result_df = screener.monitorFiveEma(  # Dummy scan to avoid blank table on 1st scan
+                    fetcher=fetcher,
+                    result_df=result_df,
+                    last_signal=last_signal,
+                )
+    try:
+        while True:
+            Utility.tools.clearScreen()
+            last_result_len = len(result_df)
+            try:
+                result_df = screener.monitorFiveEma(
+                                fetcher=fetcher,
+                                result_df=result_df,
+                                last_signal=last_signal,
+                            )
+            except Exception as e:  # pragma: no cover
+                default_logger().debug(e, exc_info=True)
+                OutputControls().printOutput(
+                                colorText.BOLD
+                                + colorText.FAIL
+                                + "[+] There was an exception while monitoring 5-EMA"
+                                + "\n[+] If this continues to happen, please try and run with -l"
+                                + "\n[+] and collect all the logs, zip it and submit it to the developer."
+                                + "\n[+] For example:"
+                                + colorText.END
+                                + colorText.WARN
+                                + "pkscreener -l\n"
+                                + colorText.END
+                            )
+            OutputControls().printOutput(
+                            colorText.BOLD
+                            + colorText.WARN
+                            + "[+] 5-EMA : Live Intraday Scanner \t"
+                            + colorText.END
+                            + colorText.FAIL
+                            + f'Last Scanned: {datetime.now().strftime("%H:%M:%S")}\n'
+                            + colorText.END
+                        )
+            if result_df is not None and len(result_df) > 0:
+                OutputControls().printOutput(
+                                colorText.miniTabulator().tabulate(
+                                    result_df,
+                                    headers="keys",
+                                    tablefmt=colorText.No_Pad_GridFormat,
+                                    maxcolwidths=Utility.tools.getMaxColumnWidths(result_df)
+                                ).encode("utf-8").decode(STD_ENCODING)
+                            )
+            OutputControls().printOutput("\nPress Ctrl+C to exit.")
+            if result_df is not None and len(result_df) != last_result_len and not first_scan:
+                Utility.tools.alertSound(beeps=5)
+            sleep(60)
+            first_scan = False
+    except KeyboardInterrupt:
+        input("\nPress <Enter> to Continue...\n")
+        return
+
+def handleRequestForSpecificStocks(options, indexOption):
+    listStockCodes = []
+    strOptions = ""
+    if isinstance(options, list):
+        strOptions = ":".join(options).split(">")[0]
+    else:
+        strOptions = options.split(">")[0]
+    
+    if indexOption == 0:
+        if len(strOptions) >= 4:
+            strOptions = strOptions.replace(":D:",":").replace(">","")
+            providedOptions = strOptions.split(":")
+            for option in providedOptions:
+                if not "".join(str(option).split(".")).isdecimal() and len(option.strip()) > 1:
+                    listStockCodes = str(option.strip()).split(",")
+                    break
+    return listStockCodes
+
+def handleExitRequest(executeOption):
+    if executeOption == "Z":
+        input(
+            colorText.BOLD
+            + colorText.FAIL
+            + "[+] Press <Enter> to Exit!"
+            + colorText.END
+        )
+        sys.exit(0)
+
+def handleMenu_XBG(menuOption, indexOption, executeOption):
+    if menuOption in ["X", "B", "G","C"]:
+        selMenu = m0.find(menuOption)
+        m1.renderForMenu(selMenu, asList=True)
+        if indexOption is not None:
+            selMenu = m1.find(indexOption)
+            m2.renderForMenu(selMenu, asList=True)
+            if executeOption is not None:
+                selMenu = m2.find(executeOption)
+                m3.renderForMenu(selMenu, asList=True)
+
+
+def updateMenuChoiceHierarchy():
+    global userPassedArgs, selectedChoice, menuChoiceHierarchy
+    try:
+        menuChoiceHierarchy = f'{level0MenuDict[selectedChoice["0"]].strip()}>{level1_X_MenuDict[selectedChoice["1"]].strip()}>{level2_X_MenuDict[selectedChoice["2"]].strip()}'
+        if selectedChoice["2"] == "6":
+            menuChoiceHierarchy = (
+                menuChoiceHierarchy
+                + f'>{level3_X_Reversal_MenuDict[selectedChoice["3"]].strip()}'
+            )
+            if len(selectedChoice) >= 5 and selectedChoice["3"] in ["7","10"]:
+                menuChoiceHierarchy = (
+                menuChoiceHierarchy
+                + f'>{level4_X_Lorenzian_MenuDict[selectedChoice["4"]].strip()}'
+            )
+        elif selectedChoice["2"] in ["30"]:
+            if len(selectedChoice) >= 3:
+                menuChoiceHierarchy = (
+                menuChoiceHierarchy
+                + f'>{level4_X_Lorenzian_MenuDict[selectedChoice["3"]].strip()}'
+            )
+        elif selectedChoice["2"] == "7":
+            menuChoiceHierarchy = (
+                menuChoiceHierarchy
+                + f'>{level3_X_ChartPattern_MenuDict[selectedChoice["3"]].strip()}'
+            )
+            if len(selectedChoice) >= 5 and selectedChoice["3"] == "3":
+                menuChoiceHierarchy = (
+                menuChoiceHierarchy
+                + f'>{level4_X_ChartPattern_Confluence_MenuDict[selectedChoice["4"]].strip()}'
+            )
+            elif len(selectedChoice) >= 5 and selectedChoice["3"] == "6":
+                menuChoiceHierarchy = (
+                menuChoiceHierarchy
+                + f'>{level4_X_ChartPattern_BBands_SQZ_MenuDict[selectedChoice["4"]].strip()}'
+            )
+        elif selectedChoice["2"] == "21":
+            menuChoiceHierarchy = (
+                menuChoiceHierarchy
+                + f'>{level3_X_PopularStocks_MenuDict[selectedChoice["3"]].strip()}'
+            )
+        intraday = "(Intraday)" if (userPassedArgs is not None and userPassedArgs.intraday) or configManager.isIntradayConfig() else ""
+        menuChoiceHierarchy = f"{menuChoiceHierarchy}{intraday}"
+        global nValueForMenu
+        menuChoiceHierarchy = menuChoiceHierarchy.replace("N-",f"{nValueForMenu}-")
+    except:
+        pass
+    Utility.tools.clearScreen(forceTop=True)
+    OutputControls().printOutput(
+        colorText.BOLD
+        + colorText.FAIL
+        + "[+] You chose: "
+        + menuChoiceHierarchy
+        + (f" (Piped Scan Mode) [{userPassedArgs.pipedmenus}]" if (userPassedArgs is not None and userPassedArgs.pipedmenus is not None) else "")
+        + colorText.END
+    )
+    default_logger().info(menuChoiceHierarchy)
+    return menuChoiceHierarchy
+
+def printNotifySaveScreenedResults(
+    screenResults, saveResults, selectedChoice, menuChoiceHierarchy, testing, user=None
+):
+    global userPassedArgs, elapsed_time
+    if userPassedArgs.monitor is not None:
+        return
+    MAX_ALLOWED = (100 if userPassedArgs.maxdisplayresults is None else min(int(userPassedArgs.maxdisplayresults),100)) if not testing else 1
+    tabulated_backtest_summary = ""
+    tabulated_backtest_detail = ""
+    recordDate = PKDateUtilities.tradingDate().strftime('%Y-%m-%d') if (userPassedArgs.backtestdaysago is None) else (PKDateUtilities.nthPastTradingDateStringFromFutureDate(int(userPassedArgs.backtestdaysago)))
+    if user is None and userPassedArgs.user is not None:
+        user = userPassedArgs.user
+    Utility.tools.clearScreen(forceTop=True)
+    if screenResults is not None and len(screenResults) > 0:
+        screenResults = screenResults[~screenResults.index.duplicated(keep='first')]
+        saveResults = saveResults[~saveResults.index.duplicated(keep='first')]
+        if "Stock" in screenResults.columns:
+            screenResults.drop_duplicates(keep="first", inplace=True)
+        if "Stock" in saveResults.columns:
+            saveResults.drop_duplicates(keep="first", inplace=True)
+    
+    reportTitle = f"{userPassedArgs.pipedtitle}|" if userPassedArgs is not None and userPassedArgs.pipedtitle is not None else ""
+    OutputControls().printOutput(
+        colorText.BOLD
+        + colorText.FAIL
+        + f"[+] You chose: {reportTitle}{menuChoiceHierarchy}[{len(screenResults) if screenResults is not None and not screenResults.empty else 0}]"
+        + (f" (Piped Scan Mode) [{userPassedArgs.pipedmenus}]" if (userPassedArgs is not None and userPassedArgs.pipedmenus is not None) else "")
+        + colorText.END
+        , enableMultipleLineOutput=True
+    )
+    pngName = f'PKS_{PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)}_{PKDateUtilities.currentDateTime().strftime("%d-%m-%y_%H.%M.%S")}'
+    pngExtension = ".png"
+    eligible = is_token_telegram_configured()
+    targetDateG10k = prepareGrowthOf10kResults(saveResults, selectedChoice, menuChoiceHierarchy, testing, user, pngName, pngExtension, eligible)
+    if saveResults is not None and "Date" in saveResults.columns and len(saveResults) > 0:
+        recordDate = saveResults["Date"].iloc[0].replace("/","-")
+    summaryReturns = removedUnusedColumns(screenResults, saveResults, ["Date","Breakout","Resistance"],userArgs=userPassedArgs)
+
+    tabulated_results = ""
+    if screenResults is not None and len(screenResults) > 0:
+        tabulated_results = colorText.miniTabulator().tabulate(
+            screenResults, headers="keys", tablefmt=colorText.No_Pad_GridFormat,
+            maxcolwidths=Utility.tools.getMaxColumnWidths(screenResults)
+        ).encode("utf-8").decode(STD_ENCODING)
+    OutputControls().printOutput(f"{tabulated_results}\n", enableMultipleLineOutput=True)
+    _, reportNameInsights = getBacktestReportFilename(
+        sortKey="Date", optionalName="Insights"
+    )
+    strategy_df = PortfolioXRay.bestStrategiesFromSummaryForReport(reportNameInsights,includeLargestDatasets=True)
+    addendumLabel = (
+        "[+] Strategies that have best results in the past for this scan option (calculated with 1 stock each with matching strategy in the result):"
+    )
+    tabulated_strategy = ""
+    if strategy_df is not None and len(strategy_df) > 0:
+        tabulated_strategy = colorText.miniTabulator().tabulate(
+            strategy_df,
+            headers="keys",
+            tablefmt=colorText.No_Pad_GridFormat,
+            showindex=False,
+            maxcolwidths=Utility.tools.getMaxColumnWidths(strategy_df)
+        ).encode("utf-8").decode(STD_ENCODING)
+        OutputControls().printOutput(addendumLabel)
+        OutputControls().printOutput(tabulated_strategy)
+    if screenResults is not None and len(screenResults) >= 1:
+        choiceSegments = menuChoiceHierarchy.split(">")
+        choiceSegments = f"{choiceSegments[-2]} > {choiceSegments[-1]}" if len(choiceSegments)>=4 else f"{choiceSegments[-1]}"
+        pipedTitle = f"{userPassedArgs.pipedtitle}|" if userPassedArgs.pipedtitle is not None else ""
+        pipedTitle = f'| Piped Results: {pipedTitle}{choiceSegments}[{len(saveResults)}]' if len(pipedTitle) > 0 else ""
+        pipedTitle = pipedTitle.replace("[","<b>[").replace("]","]</b>")
+        title = f'<b>{reportTitle}{choiceSegments}</b>{"" if selectedChoice["0"] != "G" else " for Date:"+ targetDateG10k}'
+        if (
+            ("RUNNER" in os.environ.keys() and os.environ["RUNNER"] != "LOCAL_RUN_SCANNER")
+            or "PKDevTools_Default_Log_Level" in os.environ.keys()
+        ):
+            if eligible:
+                # There's no need to save data locally.
+                # This scan must have been triggered by github workflow by a user or scheduled job
+                # Let's just send the image result to telegram
+                screenResultsTrimmed = screenResults.copy()
+                saveResultsTrimmed = saveResults.copy()
+                # No point sending a photo with more than MAX_ALLOWED stocks.
+                warn_text = (
+                    f" but showing only {MAX_ALLOWED}. "
+                    if (len(saveResults) > MAX_ALLOWED)
+                    else ""
+                )
+                caption = f"{title}"
+                elapsed_text = f"<i>({len(saveResults)}{'+' if (len(saveResults) > MAX_ALLOWED) else ''} stocks found in {str(int(elapsed_time))} sec.){warn_text}</i>"
+                backtestExtension = "_backtest.png"
+                if len(screenResultsTrimmed) > MAX_ALLOWED:
+                    screenResultsTrimmed = screenResultsTrimmed.head(MAX_ALLOWED)
+                    saveResultsTrimmed = saveResultsTrimmed.head(MAX_ALLOWED)
+                    if saveResultsTrimmed is not None and len(saveResultsTrimmed) > 0:
+                        tabulated_results = colorText.miniTabulator().tabulate(
+                            screenResultsTrimmed,
+                            headers="keys",
+                            tablefmt=colorText.No_Pad_GridFormat,
+                            maxcolwidths=Utility.tools.getMaxColumnWidths(screenResultsTrimmed)
+                        ).encode("utf-8").decode(STD_ENCODING)
+                markdown_results = ""
+                if saveResultsTrimmed is not None and len(saveResultsTrimmed) > 0:
+                    markdown_results = colorText.miniTabulator().tabulate(
+                        saveResultsTrimmed,
+                        headers="keys",
+                        tablefmt=colorText.No_Pad_GridFormat,
+                        maxcolwidths=Utility.tools.getMaxColumnWidths(saveResultsTrimmed)
+                    ).encode("utf-8").decode(STD_ENCODING)
+                    caption_df = saveResultsTrimmed[['LTP','%Chng','Volume']].head(5)
+                    caption_df.loc[:, "LTP"] = caption_df.loc[:, "LTP"].apply(
+                        lambda x: str(int(round(float(x),0)))
+                    )
+                    caption_df.loc[:, "%Chng"] = caption_df.loc[:, "%Chng"].apply(
+                        lambda x: f'{int(round(float(x.replace("%","")),0))}%'
+                    )
+                    caption_df.loc[:, "Volume"] = caption_df.loc[:, "Volume"].apply(
+                        lambda x: f'{int(round(float(x.replace("x","")),0))}x' if (len(x.replace("x","").strip()) > 0 and not pd.isna(float(x.replace("x","")))) else ''
+                    )
+                    caption_df.rename(columns={"%Chng": "Ch%","Volume":"Vol"}, inplace=True)
+                    for col in caption_df.columns:
+                        caption_df[col] = caption_df[col].astype(str)
+                    caption_results = colorText.miniTabulator().tabulate(
+                        caption_df,
+                        headers="keys",
+                        tablefmt=colorText.No_Pad_GridFormat,
+                        maxcolwidths=[None,None,4,3]
+                    ).encode("utf-8").decode(STD_ENCODING).replace("-K-----S-----C-----R","-K-----S----C---R").replace("%  ","% ").replace("=K=====S=====C=====R","=K=====S====C===R").replace("Vol  |","Vol|").replace("x  ","x")
+                    caption_results = caption_results.replace("-E-----N-----E-----R","-E-----N----E---R").replace("=E=====N=====E=====R","=E=====N====E===R")
+                    caption = f"{caption}.Open attached image for more. Samples:<pre>{caption_results}</pre>{elapsed_text}{pipedTitle}" #<i>Author is <u><b>NOT</b> a SEBI registered financial advisor</u> and MUST NOT be deemed as one.</i>"
+                if not testing: # and not userPassedArgs.runintradayanalysis:
+                    sendQuickScanResult(
+                        f"{reportTitle}{menuChoiceHierarchy}",
+                        user,
+                        tabulated_results,
+                        markdown_results,
+                        caption,
+                        pngName,
+                        pngExtension,
+                        addendum=tabulated_strategy,
+                        addendumLabel=addendumLabel,
+                    )
+                    # Let's send the backtest results now only if the user requested 1-on-1 for scan.
+                    if user is not None:
+                        # Now let's try and send backtest results
+                        (
+                            tabulated_backtest_summary,
+                            tabulated_backtest_detail,
+                        ) = tabulateBacktestResults(
+                            saveResultsTrimmed, maxAllowed=MAX_ALLOWED, force=True
+                        )
+                        try:
+                            # import traceback
+                            Utility.tools.tableToImage(
+                                "",
+                                "",
+                                pngName + backtestExtension,
+                                menuChoiceHierarchy,
+                                backtestSummary=tabulated_backtest_summary,
+                                backtestDetail=tabulated_backtest_detail,
+                            )
+                            caption = f"Backtest data for stocks listed in <b>{title}</b> scan results. See more past backtest data at https://pkjmesra.github.io/PKScreener/BacktestReports.html"
+                            sendMessageToTelegramChannel(
+                                message=None,
+                                document_filePath=pngName + backtestExtension,
+                                caption=caption,
+                                user=user,
+                            )
+                            os.remove(pngName + backtestExtension)
+                        except Exception as e:  # pragma: no cover
+                            default_logger().debug(e, exc_info=True)
+                            pass
+                            # OutputControls().printOutput(e)
+                            # traceback.print_exc()
+                    else:
+                        tabulateBacktestResults(saveResults)
+            else:
+                tabulateBacktestResults(saveResults)
+        else:
+            tabulateBacktestResults(saveResults)
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.GREEN
+                + f"[+] Found {len(screenResults) if screenResults is not None else 0} Stocks in {str('{:.2f}'.format(elapsed_time))} sec. Showing only stocks that met the filter criteria in the filters section of user configuration{(' with portfolio returns:' + summaryReturns) if (len(summaryReturns) > 0) else ''}"
+                + colorText.END
+            )
+    elif user is not None:
+        sendMessageToTelegramChannel(
+            message=f"No scan results found for {menuChoiceHierarchy}", user=user
+        )
+    if not testing:
+        Utility.tools.setLastScreenedResults(screenResults, saveResults, f"{PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)}_{recordDate if recordDate is not None else ''}")
+
+def prepareGrowthOf10kResults(saveResults, selectedChoice, menuChoiceHierarchy, testing, user, pngName, pngExtension, eligible):
+    targetDateG10k = None
+    if selectedChoice["0"] == "G" or \
+        (userPassedArgs.backtestdaysago is not None and 
+         int(userPassedArgs.backtestdaysago) > 0 and 
+         "RUNNER" not in os.environ.keys()):
+        if saveResults is not None and len(saveResults) > 0:
+            df = PortfolioXRay.performXRay(saveResults, userPassedArgs,None, None)
+            targetDateG10k = saveResults["Date"].iloc[0]
+            if df is not None and len(df) > 0:
+                titleLabelG10k = f"For {userPassedArgs.backtestdaysago}-Period(s) from {targetDateG10k}, portfolio calculations in terms of Growth of 10k:"
+                g10kStyledTable = colorText.miniTabulator().tabulate(
+                    df,
+                    headers="keys",
+                    tablefmt=colorText.No_Pad_GridFormat,
+                    showindex=False,
+                    maxcolwidths=Utility.tools.getMaxColumnWidths(df)
+                ).encode("utf-8").decode(STD_ENCODING)
+                # Show only if the configuration dicttates showing strategy data
+                if configManager.showPastStrategyData:
+                    OutputControls().printOutput(f"\n\n{titleLabelG10k}\n")
+                    OutputControls().printOutput(g10kStyledTable)
+                g10kUnStyledTable = Utility.tools.removeAllColorStyles(g10kStyledTable)
+                if not testing and eligible:
+                    sendQuickScanResult(
+                        menuChoiceHierarchy,
+                        user,
+                        g10kStyledTable,
+                        g10kUnStyledTable,
+                        titleLabelG10k,
+                        pngName,
+                        pngExtension,
+                    )
+        elif user is not None and eligible:
+            sendMessageToTelegramChannel(
+                message=f"No scan results found for {menuChoiceHierarchy}", user=user
+            )
+            
+    return targetDateG10k
+
+
+def removedUnusedColumns(screenResults, saveResults, dropAdditionalColumns=[], userArgs=None):
+    periods = configManager.periodsRange
+    if userArgs is not None and userArgs.backtestdaysago is not None and int(userArgs.backtestdaysago) < 22:
+        dropAdditionalColumns.append("22-Pd %")
+    summaryReturns = "" #("w.r.t. " + saveResults["Date"].iloc[0]) if "Date" in saveResults.columns else ""
+    for period in periods:
+        if saveResults is not None:
+            # if f"LTP{period}" in saveResults.columns and "MCapWt%" in saveResults.columns:
+            #     pdLTP = saveResults[f"LTP{period}"].replace("", np.nan).replace(np.inf, np.nan).replace(-np.inf, np.nan).astype(float)
+            #     mktWeight = saveResults["MCapWt%"].replace("", np.nan).replace(np.inf, np.nan).replace(-np.inf, np.nan).astype(float)
+            #     ltp = saveResults[f"LTP"].replace("", np.nan).replace(np.inf, np.nan).replace(-np.inf, np.nan).astype(float)
+            #     pdReturn = round(100*(sum(pdLTP * mktWeight)-sum(ltp * mktWeight))/sum(ltp * mktWeight),1)
+            #               #round((sum(saveResults[f"LTP{period}"]) - sum(saveResults['LTP']))*100/sum(saveResults['LTP']),1)
+            #     if pdReturn > -500:
+            #         summaryReturns = f"{period}-Pd({pdReturn} %), {summaryReturns}"
+            saveResults.drop(f"LTP{period}", axis=1, inplace=True, errors="ignore")
+            saveResults.drop(f"Growth{period}", axis=1, inplace=True, errors="ignore")
+            # saveResults.drop(f"MCapWt%", axis=1, inplace=True, errors="ignore")
+            # screenResults.drop(f"MCapWt%", axis=1, inplace=True, errors="ignore")
+            if len(dropAdditionalColumns) > 0:
+                for col in dropAdditionalColumns:
+                    if col in saveResults.columns:
+                        saveResults.drop(col, axis=1, inplace=True, errors="ignore")
+        if screenResults is not None:
+            screenResults.drop(f"LTP{period}", axis=1, inplace=True, errors="ignore")
+            screenResults.drop(f"Growth{period}", axis=1, inplace=True, errors="ignore")
+            if len(dropAdditionalColumns) > 0:
+                for col in dropAdditionalColumns:
+                    if col in screenResults.columns:
+                        screenResults.drop(col, axis=1, inplace=True, errors="ignore")
+    return summaryReturns
+
+
+def tabulateBacktestResults(saveResults, maxAllowed=0, force=False):
+    if "PKDevTools_Default_Log_Level" not in os.environ.keys():
+        if ("RUNNER" not in os.environ.keys()) or ("RUNNER" in os.environ.keys() and not force):
+            return None, None
+    if not configManager.showPastStrategyData:
+        return None, None
+    tabulated_backtest_summary = ""
+    tabulated_backtest_detail = ""
+    summarydf, detaildf = getSummaryCorrectnessOfStrategy(saveResults)
+    if summarydf is not None and len(summarydf) > 0:
+        tabulated_backtest_summary = colorText.miniTabulator().tabulate(
+            summarydf,
+            headers="keys",
+            tablefmt=colorText.No_Pad_GridFormat,
+            showindex=False,
+            maxcolwidths=Utility.tools.getMaxColumnWidths(summarydf)
+        ).encode("utf-8").decode(STD_ENCODING)
+    if detaildf is not None and len(detaildf) > 0:
+        if maxAllowed != 0 and len(detaildf) > 2 * maxAllowed:
+            detaildf = detaildf.head(2 * maxAllowed)
+        tabulated_backtest_detail = colorText.miniTabulator().tabulate(
+            detaildf,
+            headers="keys",
+            tablefmt=colorText.No_Pad_GridFormat,
+            showindex=False,
+            maxcolwidths=Utility.tools.getMaxColumnWidths(detaildf)
+        ).encode("utf-8").decode(STD_ENCODING)
+    if tabulated_backtest_summary != "":
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + "\n[+] For chosen scan, summary of correctness from past: [Example, 70% of (100) under 1-Pd, means out of 100 stocks that were in the scan result in the past, 70% of them gained next day.)"
+            + colorText.END
+        )
+        OutputControls().printOutput(tabulated_backtest_summary)
+    if tabulated_backtest_detail != "":
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + "\n[+] 1 to 30 period gain/loss % on respective date for matching stocks from earlier predictions:[Example, 5% under 1-Pd, means the stock price actually gained 5% the next day from given date.]"
+            + colorText.END
+        )
+        OutputControls().printOutput(tabulated_backtest_detail)
+    return tabulated_backtest_summary, tabulated_backtest_detail
+
+
+def sendQuickScanResult(
+    menuChoiceHierarchy,
+    user,
+    tabulated_results,
+    markdown_results,
+    caption,
+    pngName,
+    pngExtension,
+    addendum=None,
+    addendumLabel=None,
+    backtestSummary="",
+    backtestDetail="",
+    summaryLabel = None,
+    detailLabel = None,
+    legendPrefixText = ""
+):
+    if "PKDevTools_Default_Log_Level" not in os.environ.keys():
+        if (("RUNNER" not in os.environ.keys()) or ("RUNNER" in os.environ.keys() and os.environ["RUNNER"] == "LOCAL_RUN_SCANNER")):
+            return
+    try:
+        Utility.tools.tableToImage(
+            markdown_results,
+            tabulated_results,
+            pngName + pngExtension,
+            menuChoiceHierarchy,
+            backtestSummary=backtestSummary,
+            backtestDetail=backtestDetail,
+            addendum=addendum,
+            addendumLabel=addendumLabel,
+            summaryLabel = summaryLabel,
+            detailLabel = detailLabel,
+            legendPrefixText = legendPrefixText
+        )
+        sendMessageToTelegramChannel(
+            message=None,
+            document_filePath=pngName + pngExtension,
+            caption=caption,
+            user=user,
+        )
+        os.remove(pngName + pngExtension)
+    except Exception as e:  # pragma: no cover
+        default_logger().debug(e, exc_info=True)
+        pass
+
+
+def reformatTable(summaryText, headerDict, colored_text, sorting=True):
+    if sorting:
+        tableText = "<!DOCTYPE html><html><head><script type='application/javascript' src='https://pkjmesra.github.io/PKScreener/pkscreener/classes/tableSorting.js' ></script><style type='text/css'>body, table {background-color: black; color: white;} table, th, td {border: 1px solid white;} th {cursor: pointer; color:white; text-decoration:underline;} .r {color:red;font-weight:bold;} .br {border-color:green;border-width:medium;} .w {color:white;font-weight:bold;} .g {color:lightgreen;font-weight:bold;} .y {color:yellow;} .bg {background-color:darkslategrey;} .bb {background-color:black;} input#searchReports { width: 220px; } table thead tr th { background-color: black; position: sticky; z-index: 100; top: 0; } </style></head><body><span style='color:white;' >"
+        colored_text = colored_text.replace(
+            "<table", f"{tableText}{summaryText}<br /><input type='text' id='searchReports' onkeyup='searchReportsByAny()' placeholder='Search for stock/scan reports..' title='Type in a name/ID'><table")
+        colored_text = colored_text.replace("<table ", "<table id='resultsTable' ")
+        colored_text = colored_text.replace('<tr style="text-align: right;">','<tr style="text-align: right;" class="header">')
+        for key in headerDict.keys():
+            if key > 0:
+                colored_text = colored_text.replace(
+                    headerDict[key], f"<th>{headerDict[key][4:]}"
+                )
+            else:
+                colored_text = colored_text.replace(
+                    headerDict[key], f"<th>Stock{headerDict[key][4:]}"
+                )
+    else:
+        colored_text = colored_text.replace('<table border="1" class="dataframe">', "")
+        colored_text = colored_text.replace("<tbody>", "")
+        colored_text = colored_text.replace("<tr>", "")
+        colored_text = colored_text.replace("</tr>", "")
+        colored_text = colored_text.replace("</tbody>", "")
+        colored_text = colored_text.replace("</table>", "")
+    colored_text = colored_text.replace(colorText.BOLD, "")
+    colored_text = colored_text.replace(f"{colorText.GREEN}", "<span class='g'>")
+    colored_text = colored_text.replace(f"{colorText.FAIL}", "<span class='r'>")
+    colored_text = colored_text.replace(f"{colorText.WARN}", "<span class='y'>")
+    colored_text = colored_text.replace(f"{colorText.WHITE}", "<span class='w'>")
+    colored_text = colored_text.replace("<td><span class='w'>","<td class='br'><span class='w'>")
+    colored_text = colored_text.replace(colorText.END, "</span>")
+    colored_text = colored_text.replace("\n", "")
+    if sorting:
+        colored_text = colored_text.replace("</table>", "</table></span></body></html>")
+    return colored_text
+
+
+def removeUnknowns(screenResults, saveResults):
+    for col in screenResults.keys():
+        screenResults = screenResults[
+            screenResults[col].astype(str).str.contains("Unknown") == False
+        ]
+    for col in saveResults.keys():
+        saveResults = saveResults[
+            saveResults[col].astype(str).str.contains("Unknown") == False
+        ]
+    return screenResults, saveResults
+
+# def apply_df_style(x):
+#     red = 'color: red'
+#     noColor = '' 
+#     green = 'color: green'
+#     #compare columns
+#     mask_green_bid = x['BidQty'] > x['AskQty']
+#     mask_red_bid = x['BidQty'] <= x['AskQty']
+#     mask_green_vwap = x['VWAP'] >= x['LTP']
+#     #DataFrame with same index and columns names as original filled empty strings
+#     df1 =  pd.DataFrame(noColor, index=x.index, columns=x.columns)
+#     #modify values of df1 column by boolean mask
+#     df1.loc[mask_green_bid, 'BidQty'] = green
+#     df1.loc[mask_red_bid, 'AskQty'] = red
+#     df1.loc[mask_green_vwap, 'VWAP'] = green
+#     return df1
+
+def runScanners(
+    menuOption,
+    items,
+    tasks_queue,
+    results_queue,
+    numStocks,
+    backtestPeriod,
+    iterations,
+    consumers,
+    screenResults,
+    saveResults,
+    backtest_df,
+    testing=False,
+):
+    global selectedChoice, userPassedArgs, elapsed_time, start_time,userPassedArgs
+    result = None
+    backtest_df = None
+    reviewDate = getReviewDate(userPassedArgs)
+    max_allowed = getMaxAllowedResultsCount(iterations, testing)
+    try:
+        originalNumberOfStocks = numStocks
+        iterations, numStocksPerIteration = getIterationsAndStockCounts(numStocks, iterations)
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.GREEN
+            + f"[+] For {reviewDate}, total Stocks under review: {numStocks} over {iterations} iterations..."
+            + colorText.END
+        )
+        if not userPassedArgs.download:
+            OutputControls().printOutput(colorText.WARN
+                + f"[+] Starting {'Stock' if menuOption not in ['C'] else 'Intraday'} {'Screening' if menuOption=='X' else ('Analysis' if menuOption == 'C' else 'Backtesting.')}. Press Ctrl+C to stop!"
+                + colorText.END
+            )
+        else:
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + f"[+] Download ONLY mode (OHLCV for period:{configManager.period}, candle-duration:{configManager.duration} )! Stocks will not be screened!"
+                + colorText.END
+            )
+        bar, spinner = Utility.tools.getProgressbarStyle()
+        with alive_bar(numStocks, bar=bar, spinner=spinner) as progressbar:
+            lstscreen = []
+            lstsave = []
+            result = None
+            backtest_df = None
+            start_time = time.time()
+
+            def processResultsCallback(resultItem, processedCount,result_df, *otherArgs):
+                global userPassedArgs
+                (menuOption, backtestPeriod, result, lstscreen, lstsave) = otherArgs
+                numStocks = processedCount
+                result = resultItem
+                backtest_df = processResults(menuOption, backtestPeriod, result, lstscreen, lstsave, result_df)
+                progressbar()
+                progressbar.text(
+                    colorText.BOLD
+                    + colorText.GREEN
+                    + f"{'Remaining' if userPassedArgs.download else ('Found' if menuOption in ['X'] else 'Analysed')} {len(lstscreen) if not userPassedArgs.download else processedCount} {'Stocks' if menuOption in ['X'] else 'Records'}"
+                    + colorText.END
+                )
+                if result is not None:
+                    if not userPassedArgs.monitor and len(lstscreen) > 0 and userPassedArgs is not None and userPassedArgs.options.split(":")[2] in ["29"]:
+                        scr_df = pd.DataFrame(lstscreen)
+                        existingColumns = ["Stock","%Chng","LTP","Volume"]
+                        newColumns = ["BidQty","AskQty","LwrCP","UprCP","VWAP","DayVola","Del(%)"]
+                        existingColumns.extend(newColumns)
+                        scr_df = scr_df[existingColumns]
+                        scr_df.sort_values(by=["Volume","BidQty"], ascending=False, inplace=True)
+                        tabulated_results = colorText.miniTabulator().tb.tabulate(
+                                scr_df,
+                                headers="keys",
+                                showindex=False,
+                                tablefmt=colorText.No_Pad_GridFormat,
+                                maxcolwidths=Utility.tools.getMaxColumnWidths(scr_df)
+                            )
+                        tableLength = 2*len(lstscreen)+5
+                        OutputControls().printOutput('\n'+tabulated_results)
+                        # Move the cursor up, back to the top because we want the progress bar to keep showing at the top
+                        sys.stdout.write(f"\x1b[{tableLength}A")  # cursor up one line
+                if keyboardInterruptEventFired:
+                    return False, backtest_df
+                return not ((testing and len(lstscreen) >= 1) or len(lstscreen) >= max_allowed), backtest_df
+            otherArgs = (menuOption, backtestPeriod, result, lstscreen, lstsave)
+            backtest_df, result =PKScanRunner.runScan(userPassedArgs,testing,numStocks,iterations,items,numStocksPerIteration,tasks_queue,results_queue,originalNumberOfStocks,backtest_df,*otherArgs,resultsReceivedCb=processResultsCallback)
+
+        OutputControls().printOutput(f"\x1b[{3 if OutputControls().enableMultipleLineOutput else 1}A")
+        if len(lstscreen) == 0 and userPassedArgs is not None and userPassedArgs.monitor is None:
+            OutputControls().printOutput("\x1b[2K") # Delete the progress bar line
+        elapsed_time = time.time() - start_time
+        if menuOption in ["X", "G", "C"]:
+            # create extension
+            screenResults = pd.DataFrame(lstscreen)
+            saveResults = pd.DataFrame(lstsave)
+
+    except KeyboardInterrupt:
+        try:
+            global keyboardInterruptEventFired
+            keyboardInterruptEvent.set()
+            keyboardInterruptEventFired = True
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "\n[+] Terminating Script, Please wait..."
+                + colorText.END
+            )
+            PKScanRunner.terminateAllWorkers(userPassedArgs=userPassedArgs,consumers=consumers, tasks_queue=tasks_queue,testing=testing)
+            logging.shutdown()
+        except KeyboardInterrupt:
+            pass
+    except Exception as e:
+        default_logger().debug(e, exc_info=True)
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + f"\nException:\n{e}\n[+] Terminating Script, Please wait..."
+            + colorText.END
+        )
+        PKScanRunner.terminateAllWorkers(userPassedArgs=userPassedArgs,consumers=consumers, tasks_queue=tasks_queue,testing=testing)
+        logging.shutdown()
+
+    if result is not None and len(result) >=3 and "Date" not in saveResults.columns:
+        temp_df = result[2].copy()
+        temp_df.reset_index(inplace=True)
+        temp_df = temp_df.tail(1)
+        temp_df.rename(columns={"index": "Date"}, inplace=True)
+        targetDate = (
+            temp_df["Date"].iloc[0]
+            if "Date" in temp_df.columns
+            else str(temp_df.iloc[:, 0][0])
+        )
+        saveResults["Date"] = str(targetDate).split(" ")[0]
+    return screenResults, saveResults, backtest_df
+
+        
+def processResults(menuOption, backtestPeriod, result, lstscreen, lstsave, backtest_df):
+    if result is not None:
+        lstscreen.append(result[0])
+        lstsave.append(result[1])
+        sampleDays = result[4]
+        if menuOption == "B":
+            backtest_df = updateBacktestResults(
+                            backtestPeriod,
+                            start_time,
+                            result,
+                            sampleDays,
+                            backtest_df,
+                        )
+            
+    return backtest_df
+
+def getReviewDate(userPassedArgs=None):
+    reviewDate = PKDateUtilities.tradingDate().strftime('%Y-%m-%d')
+    if userPassedArgs is not None and userPassedArgs.backtestdaysago is not None:
+        reviewDate = PKDateUtilities.nthPastTradingDateStringFromFutureDate(int(userPassedArgs.backtestdaysago))
+    return reviewDate
+
+def getMaxAllowedResultsCount(iterations, testing):
+    return iterations * (100 if userPassedArgs.maxdisplayresults is None else int(userPassedArgs.maxdisplayresults)) if not testing else 1
+
+def getIterationsAndStockCounts(numStocks, iterations):
+    if numStocks <= 2500:
+        return 1,numStocks
+    originalIterations = iterations
+        # If we put in more into the queue, it might cause the warnings from multiprocessing resource_tracker
+        # about semaphore leakages etc. This is, caused due to overallocating RAM.
+    idealNumStocksMaxPerIteration = 100
+    iterations = int(numStocks*iterations/idealNumStocksMaxPerIteration) + 1
+    numStocksPerIteration = int(numStocks/int(iterations))
+    if numStocksPerIteration < 10:
+        numStocksPerIteration = numStocks if (iterations == 1 or numStocks<= iterations) else int(numStocks/int(iterations))
+        iterations = originalIterations
+    if numStocksPerIteration > 500:
+        numStocksPerIteration = 500
+        iterations = int(numStocks/numStocksPerIteration) + 1
+    return iterations,numStocksPerIteration
+
+
+def updateBacktestResults(
+    backtestPeriod, start_time, result, sampleDays, backtest_df
+):
+    global elapsed_time
+    sellSignal = (
+        str(selectedChoice["2"]) in ["6", "7"] and str(selectedChoice["3"]) in ["2"]
+    ) or selectedChoice["2"] in ["15", "16", "19", "25"]
+    backtest_df = backtest(
+        result[3],
+        result[2],
+        result[1],
+        result[0],
+        backtestPeriod,
+        sampleDays,
+        backtest_df,
+        sellSignal,
+    )
+    elapsed_time = time.time() - start_time
+    return backtest_df
+
+
+def saveDownloadedData(downloadOnly, testing, stockDictPrimary, configManager, loadCount):
+    global userPassedArgs, keyboardInterruptEventFired
+    argsIntraday = userPassedArgs is not None and userPassedArgs.intraday is not None
+    intradayConfig = configManager.isIntradayConfig()
+    intraday = intradayConfig or argsIntraday
+    if not keyboardInterruptEventFired and (downloadOnly or (
+        configManager.cacheEnabled and not PKDateUtilities.isTradingTime() and not testing
+    )):
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.GREEN
+            + "[+] Caching Stock Data for future use, Please Wait... "
+            + colorText.END,
+            end="",
+        )
+        Utility.tools.saveStockData(stockDictPrimary, configManager, loadCount, intraday)
+        if downloadOnly:
+            cache_file = Utility.tools.saveStockData(stockDictPrimary, configManager, loadCount, intraday, downloadOnly=downloadOnly)
+            cacheFileSize = os.stat(cache_file).st_size if os.path.exists(cache_file) else 0
+            if cacheFileSize < 1024*1024*50:
+                try:
+                    from PKDevTools.classes import Archiver
+                    log_file_path = os.path.join(Archiver.get_user_outputs_dir(), "pkscreener-logs.txt")
+                    message=f"{cache_file} has size: {cacheFileSize}! Something is wrong!"
+                    if os.path.exists(log_file_path):
+                        sendMessageToTelegramChannel(caption=message,document_filePath=log_file_path, user="-1001785195297")
+                    else:
+                        sendMessageToTelegramChannel(message=message,user="-1001785195297")
+                except:
+                    pass
+                # Let's try again with logging
+                os.system(f"{sys.argv[0]} -a Y -e -l -d {'-i 1m' if configManager.isIntradayConfig() else ''}")
+    else:
+        OutputControls().printOutput(colorText.BOLD + colorText.GREEN + "[+] Skipped Saving!" + colorText.END)
+
+
+def saveNotifyResultsFile(
+    screenResults, saveResults, defaultAnswer, menuChoiceHierarchy, user=None
+):
+    global userPassedArgs, elapsed_time, selectedChoice
+    if user is None and userPassedArgs.user is not None:
+        user = userPassedArgs.user
+    caption = f'<b>{menuChoiceHierarchy.split(">")[-1]}</b>'
+    if screenResults is not None and len(screenResults) >= 1:
+        choices = PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)
+        filename = Utility.tools.promptSaveResults(choices,
+            saveResults, defaultAnswer=defaultAnswer
+        )
+        # if filename is not None:
+        #     sendMessageToTelegramChannel(
+        #         document_filePath=filename, caption=caption, user=user
+        #     )
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.WARN
+            + "[+] Notes:1.Trend calculation is based on 'daysToLookBack'. See configuration. 2.Reduce the console font size to fit all columns on screen."
+            + colorText.END
+        )
+        # try:
+        #     if filename is not None:
+        #         os.remove(filename)
+        # except Exception as e:  # pragma: no cover
+        #     default_logger().debug(e, exc_info=True)
+    if userPassedArgs.monitor is None:
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.GREEN
+            + f"[+] Screening Completed. Found {len(screenResults) if screenResults is not None else 0} results in {round(elapsed_time,2)} sec.! Press Enter to Continue.."
+            + colorText.END
+            , enableMultipleLineOutput=True
+        )
+        if defaultAnswer is None:
+            input("Press <Enter> to continue...")
+
+def sendGlobalMarketBarometer(userArgs=None):
+    from pkscreener.classes import Barometer
+    caption = "Global Market Barometer with India market Performance (top) and Valuation (bottom)"
+    gmbPath = Barometer.getGlobalMarketBarometerValuation()
+    try:
+        if gmbPath is not None:
+            sendMessageToTelegramChannel(
+                message=None,
+                photo_filePath=gmbPath,
+                caption=caption,
+                user=(userArgs.user if userArgs is not None else None),
+            )
+            os.remove(gmbPath)
+    except:
+        pass
+
+def sendMessageToTelegramChannel(
+    message=None, photo_filePath=None, document_filePath=None, caption=None, user=None
+):
+    global userPassedArgs, test_messages_queue
+    if test_messages_queue is not None:
+        test_messages_queue.append(f"message:{message}\ncaption:{caption}\nuser:{user}\ndocument:{document_filePath}")
+        if len(test_messages_queue) >10:
+            test_messages_queue.pop(0)
+    if user is None and userPassedArgs is not None and userPassedArgs.user is not None:
+        user = userPassedArgs.user
+    if user is not None and caption is not None:
+        caption = f"{caption.replace('&','n')}."
+    if message is not None:
+        try:
+            message = message.replace("&", "n").replace("<","*")
+            send_message(message, userID=user)
+        except Exception as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+    else:
+        message = ""
+    if photo_filePath is not None:
+        try:
+            if caption is not None:
+                caption = f"{caption.replace('&','n')}"
+            send_photo(photo_filePath, caption, userID=user)
+            # Breather for the telegram API to be able to send the heavy photo
+            sleep(2)
+        except Exception as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+    if document_filePath is not None:
+        try:
+            if caption is not None:
+                caption = f"{caption.replace('&','n')}"
+            send_document(document_filePath, caption, userID=user)
+            # Breather for the telegram API to be able to send the document
+            sleep(2)
+        except Exception as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+    if user is not None:
+        channel_userID="-1001785195297"
+        if user != channel_userID:
+            # Send an update to dev channel
+            send_message(
+                "Responded back to userId:{0} with {1}.{2}".format(user, caption, message),
+                userID="-1001785195297",
+            )
+
+
+def sendTestStatus(screenResults, label, user=None):
+    msg = "<b>SUCCESS</b>" if (screenResults is not None and len(screenResults) >= 1) else "<b>FAIL</b>"
+    sendMessageToTelegramChannel(
+        message=f"{msg}: Found {len(screenResults) if screenResults is not None else 0} Stocks for {label}", user=user
+    )
+
+
+def showBacktestResults(backtest_df, sortKey="Stock", optionalName="backtest_result"):
+    global menuChoiceHierarchy, selectedChoice, userPassedArgs, elapsed_time
+    pd.set_option("display.max_rows", 800)
+    # pd.set_option("display.max_columns", 20)
+    if backtest_df is None or backtest_df.empty or len(backtest_df) < 1:
+        return
+    backtest_df.drop_duplicates(inplace=True)
+    summaryText = f"Auto-generated in {round(elapsed_time,2)} sec. as of {PKDateUtilities.currentDateTime().strftime('%d-%m-%y %H:%M:%S IST')}\n{menuChoiceHierarchy.replace('Backtests','Growth of 10K' if optionalName=='Insights' else 'Backtests')}"
+    lastSummaryRow = None
+    if "Summary" not in optionalName:
+        if sortKey is not None and len(sortKey) > 0:
+            backtest_df.sort_values(by=[sortKey], ascending=False, inplace=True)
+    else:
+        lastRow = backtest_df.iloc[-1, :]
+        if lastRow.iloc[0] == "SUMMARY":
+            lastSummaryRow = pd.DataFrame(lastRow).transpose()
+            lastSummaryRow.set_index("Stock", inplace=True)
+            lastSummaryRow = lastSummaryRow.iloc[:, lastSummaryRow.columns != "Stock"]
+        if "Insights" in optionalName:
+            summaryText = f"{summaryText}\nActual returns at a portfolio level with 1-stock each based on selected scan-parameters:"
+        else:
+            summaryText = f"{summaryText}\nOverall Summary of (correctness of) Strategy Prediction Positive outcomes:"
+    tabulated_text = ""
+    if backtest_df is not None and len(backtest_df) > 0:
+        tabulated_text = colorText.miniTabulator().tabulate(
+            backtest_df,
+            headers="keys",
+            tablefmt=colorText.No_Pad_GridFormat,
+            showindex=False,
+            maxcolwidths=Utility.tools.getMaxColumnWidths(backtest_df)
+        ).encode("utf-8").decode(STD_ENCODING)
+    OutputControls().printOutput(colorText.FAIL + summaryText + colorText.END + "\n")
+    OutputControls().printOutput(tabulated_text + "\n")
+    choices, filename = getBacktestReportFilename(sortKey, optionalName)
+    headerDict = {0: "<th></th>"}
+    index = 1
+    for col in backtest_df.columns:
+        if col != "Stock":
+            headerDict[index] = f"<th>{col}</th>"
+            index += 1
+
+    colored_text = backtest_df.to_html(index=False)
+    summaryText = summaryText.replace("\n", "<br />")
+    if "Summary" in optionalName:
+       summaryText = f"{summaryText}<br /><input type='checkbox' id='chkActualNumbers' name='chkActualNumbers' value='0'><label for='chkActualNumbers'>Sort by actual numbers (Stocks + Date combinations of results. Higher the count, better the prediction reliability)</label><br>"
+    colored_text = reformatTable(summaryText, headerDict, colored_text, sorting=True)
+    # Delete any pre-existing backtesting report for the same parameters
+    filename = os.path.join(scanOutputDirectory(True), filename)
+    try:
+        os.remove(filename)
+    except Exception:# pragma: no cover
+        pass
+    finally:
+        colored_text = colored_text.encode('utf-8').decode(STD_ENCODING)
+        with open(filename, "w") as f:
+            f.write(colored_text)
+        Committer.execOSCommand(f"git add {filename} -f >/dev/null 2>&1")
+
+    if lastSummaryRow is not None:
+        oneline_text = lastSummaryRow.to_html(header=False, index=False)
+        oneline_text = reformatTable(
+            summaryText, headerDict, oneline_text, sorting=False
+        )
+        onelineSummaryFile = f"PKScreener_{choices}_OneLine_{optionalName}.html"
+        onelineSummaryFile = os.path.join(
+            scanOutputDirectory(True), onelineSummaryFile
+        )
+        try:
+            os.remove(onelineSummaryFile)
+        except Exception:# pragma: no cover
+            pass
+        finally:
+            oneline_text = f"{oneline_text}<td class='w'>{PKDateUtilities.currentDateTime().strftime('%Y/%m/%d')}</td><td class='w'>{round(elapsed_time,2)}</td>"
+            with open(onelineSummaryFile, "w") as f:
+                f.write(oneline_text)
+            Committer.execOSCommand(f"git add {onelineSummaryFile} -f >/dev/null 2>&1")
+
+def scanOutputDirectory(backtest=False):
+    dirName = 'actions-data-scan' if not backtest else "Backtest-Reports"
+    outputFolder = os.path.join(os.getcwd(),dirName)
+    if not os.path.isdir(outputFolder):
+        OutputControls().printOutput("Creating actions-data-scan directory now...")
+        os.makedirs(os.path.dirname(os.path.join(os.getcwd(),f"{dirName}{os.sep}")), exist_ok=True)
+    return outputFolder
+
+def getBacktestReportFilename(sortKey="Stock", optionalName="backtest_result"):
+    global userPassedArgs,selectedChoice
+    choices = PKScanRunner.getFormattedChoices(userPassedArgs,selectedChoice)
+    filename = f"PKScreener_{choices}_{optionalName}_{sortKey if sortKey is not None else 'Default'}Sorted.html"
+    return choices, filename
+
+def showOptionErrorMessage():
+    OutputControls().printOutput(
+        colorText.BOLD
+        + colorText.FAIL
+        + "\n[+] Please enter a valid option & try Again!"
+        + colorText.END
+    )
+    sleep(2)
+    Utility.tools.clearScreen()
+
+def takeBacktestInputs(
+    menuOption=None, indexOption=None, executeOption=None, backtestPeriod=0
+):
+    g10k = '"Growth of 10k"'
+    OutputControls().printOutput(
+        colorText.BOLD
+        + colorText.GREEN
+        + f"[+] For {g10k if menuOption == 'G' else 'backtesting'}, you can choose from (1,2,3,4,5,10,15,22,30) or any other custom periods (< 1y)."
+    )
+    try:
+        if backtestPeriod == 0:
+            backtestPeriod = int(
+                input(
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + f"[+] Enter {g10k if menuOption == 'G' else 'backtesting'} period (Default is {15 if menuOption == 'G' else 30} [days]): "
+                )
+            )
+    except Exception as e:  # pragma: no cover
+        default_logger().debug(e, exc_info=True)
+    if backtestPeriod == 0:
+        backtestPeriod = 3 if menuOption == "G" else 30
+    indexOption, executeOption = initPostLevel0Execution(
+        menuOption=menuOption,
+        indexOption=indexOption,
+        executeOption=executeOption,
+        skip=["N", "E"],
+    )
+    indexOption, executeOption = initPostLevel1Execution(
+        indexOption=indexOption,
+        executeOption=executeOption,
+        skip=[
+            "0",
+            "29",
+            "42",
+        ],
+    )
+    return indexOption, executeOption, backtestPeriod
+
+def toggleUserConfig():
+    configManager.toggleConfig(
+        candleDuration="1d" if configManager.isIntradayConfig() else "1m"
+    )
+    OutputControls().printOutput(
+        colorText.BOLD
+        + colorText.GREEN
+        + "\nConfiguration toggled to duration: "
+        + str(configManager.duration)
+        + " and period: "
+        + str(configManager.period)
+        + colorText.END
+    )
+    input("\nPress <Enter> to Continue...\n")
+
+
+def userReportName(userMenuOptions):
+    global userPassedArgs
+    choices = ""
+    for choice in userMenuOptions:
+        if len(userMenuOptions[choice]) > 0:
+            if len(choices) > 0:
+                choices = f"{choices}_"
+            choices = f"{choices}{userMenuOptions[choice]}"
+    if choices.endswith("_"):
+        choices = choices[:-1]
+    choices = f"{choices}{'_i' if userPassedArgs.intraday else ''}"
+    return choices
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreener.ini` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreener.ini`

 * *Files 19% similar despite different names*

```diff
@@ -1,69 +1,66 @@
-00000000: 5b63 6f6e 6669 675d 0d0a 6174 7274 7261  [config]..atrtra
-00000010: 696c 696e 6773 746f 7065 6d61 7065 7269  ilingstopemaperi
-00000020: 6f64 203d 2032 3030 0d0a 6174 7274 7261  od = 200..atrtra
-00000030: 696c 696e 6773 746f 7070 6572 696f 6420  ilingstopperiod 
-00000040: 3d20 3130 0d0a 6174 7274 7261 696c 696e  = 10..atrtrailin
-00000050: 6773 746f 7073 656e 7369 7469 7669 7479  gstopsensitivity
-00000060: 203d 2031 2e30 0d0a 6261 636b 7465 7374   = 1.0..backtest
-00000070: 7065 7269 6f64 203d 2031 3230 0d0a 6261  period = 120..ba
-00000080: 636b 7465 7374 7065 7269 6f64 6661 6374  cktestperiodfact
-00000090: 6f72 203d 2031 0d0a 6361 6368 6573 746f  or = 1..cachesto
-000000a0: 636b 6461 7461 203d 2079 0d0a 6361 6c63  ckdata = y..calc
-000000b0: 756c 6174 6572 7369 696e 7472 6164 6179  ulatersiintraday
-000000c0: 203d 206e 0d0a 6461 7973 746f 6c6f 6f6b   = n..daystolook
-000000d0: 6261 636b 203d 2032 320d 0a64 6566 6175  back = 22..defau
-000000e0: 6c74 696e 6465 7820 3d20 3132 0d0a 6465  ltindex = 12..de
-000000f0: 6661 756c 746d 6f6e 6974 6f72 6f70 7469  faultmonitoropti
-00000100: 6f6e 7320 3d20 583a 3132 3a39 3a32 2e35  ons = X:12:9:2.5
-00000110: 3a7e 583a 3132 3a32 383a 7e58 3a31 323a  :~X:12:28:~X:12:
-00000120: 3233 3a7e 7c7b 317d 583a 303a 3233 3a3e  23:~|{1}X:0:23:>
-00000130: 7c58 3a30 3a32 373a 3e7c 583a 303a 3331  |X:0:27:>|X:0:31
-00000140: 3a7e 7c7b 327d 583a 303a 3331 3a7e 7c7b  :~|{2}X:0:31:~|{
-00000150: 337d 583a 303a 3237 3a7e 583a 3132 3a37  3}X:0:27:~X:12:7
-00000160: 3a33 3a2e 3031 3a31 3a7e 7c7b 357d 583a  :3:.01:1:~|{5}X:
-00000170: 303a 353a 303a 3430 3a7e 583a 3132 3a37  0:5:0:40:~X:12:7
-00000180: 3a36 3a31 3a7e 583a 3132 3a31 313a 7e58  :6:1:~X:12:11:~X
-00000190: 3a31 323a 3132 3a69 2035 6d7e 583a 3132  :12:12:i 5m~X:12
-000001a0: 3a31 373a 7e58 3a31 323a 3234 3a7e 583a  :17:~X:12:24:~X:
-000001b0: 3132 3a36 3a37 3a31 3a7e 583a 3132 3a36  12:6:7:1:~X:12:6
-000001c0: 3a33 3a7e 583a 3132 3a36 3a38 3a7e 583a  :3:~X:12:6:8:~X:
-000001d0: 3132 3a36 3a39 3a7e 583a 3132 3a36 3a31  12:6:9:~X:12:6:1
-000001e0: 303a 313a 7e58 3a31 323a 373a 333a 2e30  0:1:~X:12:7:3:.0
-000001f0: 323a 313a 7e58 3a31 323a 3133 3a69 2031  2:1:~X:12:13:i 1
-00000200: 6d7e 583a 3132 3a32 3a7e 7c7b 317d 583a  m~X:12:2:~|{1}X:
-00000210: 303a 3239 3a0d 0a64 7572 6174 696f 6e20  0:29:..duration 
-00000220: 3d20 3164 0d0a 656e 6162 6c65 706f 7274  = 1d..enableport
-00000230: 666f 6c69 6f63 616c 6375 6c61 7469 6f6e  foliocalculation
-00000240: 7320 3d20 6e0d 0a67 656e 6572 616c 7469  s = n..generalti
-00000250: 6d65 6f75 7420 3d20 322e 300d 0a6c 6f67  meout = 2.0..log
-00000260: 7365 6e61 626c 6564 203d 206e 0d0a 6c6f  senabled = n..lo
-00000270: 6e67 7469 6d65 6f75 7420 3d20 342e 300d  ngtimeout = 4.0.
-00000280: 0a6d 6178 6261 636b 7465 7374 7769 6e64  .maxbacktestwind
-00000290: 6f77 203d 2033 300d 0a6d 6178 6461 7368  ow = 30..maxdash
-000002a0: 626f 6172 6477 6964 6765 7473 7065 7272  boardwidgetsperr
-000002b0: 6f77 203d 2035 0d0a 6d61 786e 6574 776f  ow = 5..maxnetwo
-000002c0: 726b 7265 7472 7963 6f75 6e74 203d 2031  rkretrycount = 1
-000002d0: 300d 0a6d 6178 6e75 6d72 6573 756c 7472  0..maxnumresultr
-000002e0: 6f77 7369 6e6d 6f6e 6974 6f72 203d 2033  owsinmonitor = 3
-000002f0: 0d0a 6d6f 726e 696e 6761 6e61 6c79 7369  ..morninganalysi
-00000300: 7363 616e 646c 656e 756d 6265 7220 3d20  scandlenumber = 
-00000310: 3235 0d0a 6d6f 726e 696e 6761 6e61 6c79  25..morninganaly
-00000320: 7369 7363 616e 646c 6564 7572 6174 696f  siscandleduratio
-00000330: 6e20 3d20 316d 0d0a 6f6e 6c79 7374 6167  n = 1m..onlystag
-00000340: 6574 776f 7374 6f63 6b73 203d 2079 0d0a  etwostocks = y..
-00000350: 7065 7269 6f64 203d 2031 790d 0a73 686f  period = 1y..sho
-00000360: 7770 6173 7473 7472 6174 6567 7964 6174  wpaststrategydat
-00000370: 6120 3d20 6e0d 0a73 686f 7775 6e6b 6e6f  a = n..showunkno
-00000380: 776e 7472 656e 6473 203d 2079 0d0a 7368  wntrends = y..sh
-00000390: 7566 666c 6520 3d20 790d 0a75 7365 656d  uffle = y..useem
-000003a0: 6120 3d20 6e0d 0a0d 0a5b 6669 6c74 6572  a = n....[filter
-000003b0: 735d 0d0a 636f 6e73 6f6c 6964 6174 696f  s]..consolidatio
-000003c0: 6e70 6572 6365 6e74 6167 6520 3d20 3130  npercentage = 10
-000003d0: 2e30 0d0a 6d61 7870 7269 6365 203d 2035  .0..maxprice = 5
-000003e0: 3030 3030 2e30 0d0a 6d69 6e69 6d75 6d63  0000.0..minimumc
-000003f0: 6861 6e67 6570 6572 6365 6e74 6167 6520  hangepercentage 
-00000400: 3d20 302e 300d 0a6d 696e 696d 756d 766f  = 0.0..minimumvo
-00000410: 6c75 6d65 203d 2031 3030 3030 0d0a 6d69  lume = 10000..mi
-00000420: 6e70 7269 6365 203d 2032 302e 300d 0a76  nprice = 20.0..v
-00000430: 6f6c 756d 6572 6174 696f 203d 2032 2e35  olumeratio = 2.5
-00000440: 0d0a 0d0a                                ....
+00000000: 5b63 6f6e 6669 675d 0a61 7472 7472 6169  [config].atrtrai
+00000010: 6c69 6e67 7374 6f70 656d 6170 6572 696f  lingstopemaperio
+00000020: 6420 3d20 3230 300a 6174 7274 7261 696c  d = 200.atrtrail
+00000030: 696e 6773 746f 7070 6572 696f 6420 3d20  ingstopperiod = 
+00000040: 3130 0a61 7472 7472 6169 6c69 6e67 7374  10.atrtrailingst
+00000050: 6f70 7365 6e73 6974 6976 6974 7920 3d20  opsensitivity = 
+00000060: 312e 300a 6261 636b 7465 7374 7065 7269  1.0.backtestperi
+00000070: 6f64 203d 2031 3230 0a62 6163 6b74 6573  od = 120.backtes
+00000080: 7470 6572 696f 6466 6163 746f 7220 3d20  tperiodfactor = 
+00000090: 310a 6361 6368 6573 746f 636b 6461 7461  1.cachestockdata
+000000a0: 203d 2079 0a63 616c 6375 6c61 7465 7273   = y.calculaters
+000000b0: 6969 6e74 7261 6461 7920 3d20 6e0a 6461  iintraday = n.da
+000000c0: 7973 746f 6c6f 6f6b 6261 636b 203d 2032  ystolookback = 2
+000000d0: 320a 6465 6661 756c 7469 6e64 6578 203d  2.defaultindex =
+000000e0: 2031 320a 6465 6661 756c 746d 6f6e 6974   12.defaultmonit
+000000f0: 6f72 6f70 7469 6f6e 7320 3d20 583a 3132  oroptions = X:12
+00000100: 3a39 3a32 2e35 3a7e 583a 3132 3a32 383a  :9:2.5:~X:12:28:
+00000110: 7e58 3a31 323a 3233 3a7e 7c7b 317d 583a  ~X:12:23:~|{1}X:
+00000120: 303a 3233 3a3e 7c58 3a30 3a32 373a 3e7c  0:23:>|X:0:27:>|
+00000130: 583a 303a 3331 3a7e 7c7b 327d 583a 303a  X:0:31:~|{2}X:0:
+00000140: 3331 3a7e 7c7b 337d 583a 303a 3237 3a7e  31:~|{3}X:0:27:~
+00000150: 583a 3132 3a37 3a33 3a2e 3031 3a31 3a7e  X:12:7:3:.01:1:~
+00000160: 7c7b 357d 583a 303a 353a 303a 3430 3a7e  |{5}X:0:5:0:40:~
+00000170: 583a 3132 3a37 3a36 3a31 3a7e 583a 3132  X:12:7:6:1:~X:12
+00000180: 3a31 313a 7e58 3a31 323a 3132 3a69 2035  :11:~X:12:12:i 5
+00000190: 6d7e 583a 3132 3a31 373a 7e58 3a31 323a  m~X:12:17:~X:12:
+000001a0: 3234 3a7e 583a 3132 3a36 3a37 3a31 3a7e  24:~X:12:6:7:1:~
+000001b0: 583a 3132 3a36 3a33 3a7e 583a 3132 3a36  X:12:6:3:~X:12:6
+000001c0: 3a38 3a7e 583a 3132 3a36 3a39 3a7e 583a  :8:~X:12:6:9:~X:
+000001d0: 3132 3a36 3a31 303a 313a 7e58 3a31 323a  12:6:10:1:~X:12:
+000001e0: 373a 333a 2e30 323a 313a 7e58 3a31 323a  7:3:.02:1:~X:12:
+000001f0: 3133 3a69 2031 6d7e 583a 3132 3a32 3a7e  13:i 1m~X:12:2:~
+00000200: 7c7b 317d 583a 303a 3239 3a0a 6475 7261  |{1}X:0:29:.dura
+00000210: 7469 6f6e 203d 2031 640a 656e 6162 6c65  tion = 1d.enable
+00000220: 706f 7274 666f 6c69 6f63 616c 6375 6c61  portfoliocalcula
+00000230: 7469 6f6e 7320 3d20 6e0a 6765 6e65 7261  tions = n.genera
+00000240: 6c74 696d 656f 7574 203d 2032 2e30 0a6c  ltimeout = 2.0.l
+00000250: 6f67 7365 6e61 626c 6564 203d 206e 0a6c  ogsenabled = n.l
+00000260: 6f6e 6774 696d 656f 7574 203d 2034 2e30  ongtimeout = 4.0
+00000270: 0a6d 6178 6261 636b 7465 7374 7769 6e64  .maxbacktestwind
+00000280: 6f77 203d 2033 300a 6d61 7864 6173 6862  ow = 30.maxdashb
+00000290: 6f61 7264 7769 6467 6574 7370 6572 726f  oardwidgetsperro
+000002a0: 7720 3d20 350a 6d61 786e 6574 776f 726b  w = 5.maxnetwork
+000002b0: 7265 7472 7963 6f75 6e74 203d 2031 300a  retrycount = 10.
+000002c0: 6d61 786e 756d 7265 7375 6c74 726f 7773  maxnumresultrows
+000002d0: 696e 6d6f 6e69 746f 7220 3d20 330a 6d6f  inmonitor = 3.mo
+000002e0: 726e 696e 6761 6e61 6c79 7369 7363 616e  rninganalysiscan
+000002f0: 646c 656e 756d 6265 7220 3d20 3235 0a6d  dlenumber = 25.m
+00000300: 6f72 6e69 6e67 616e 616c 7973 6973 6361  orninganalysisca
+00000310: 6e64 6c65 6475 7261 7469 6f6e 203d 2031  ndleduration = 1
+00000320: 6d0a 6f6e 6c79 7374 6167 6574 776f 7374  m.onlystagetwost
+00000330: 6f63 6b73 203d 2079 0a70 6572 696f 6420  ocks = y.period 
+00000340: 3d20 3179 0a73 686f 7770 6173 7473 7472  = 1y.showpaststr
+00000350: 6174 6567 7964 6174 6120 3d20 6e0a 7368  ategydata = n.sh
+00000360: 6f77 756e 6b6e 6f77 6e74 7265 6e64 7320  owunknowntrends 
+00000370: 3d20 790a 7368 7566 666c 6520 3d20 790a  = y.shuffle = y.
+00000380: 7573 6565 6d61 203d 206e 0a0a 5b66 696c  useema = n..[fil
+00000390: 7465 7273 5d0a 636f 6e73 6f6c 6964 6174  ters].consolidat
+000003a0: 696f 6e70 6572 6365 6e74 6167 6520 3d20  ionpercentage = 
+000003b0: 3130 2e30 0a6d 6178 7072 6963 6520 3d20  10.0.maxprice = 
+000003c0: 3530 3030 302e 300a 6d69 6e69 6d75 6d63  50000.0.minimumc
+000003d0: 6861 6e67 6570 6572 6365 6e74 6167 6520  hangepercentage 
+000003e0: 3d20 302e 300a 6d69 6e69 6d75 6d76 6f6c  = 0.0.minimumvol
+000003f0: 756d 6520 3d20 3130 3030 300a 6d69 6e70  ume = 10000.minp
+00000400: 7269 6365 203d 2032 302e 300a 766f 6c75  rice = 20.0.volu
+00000410: 6d65 7261 7469 6f20 3d20 322e 350a 0a    meratio = 2.5..
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreenerbot.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreenerbot.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,1196 +1,1196 @@
-#!/usr/bin/env python
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-# pylint: disable=unused-argument, wrong-import-position
-# This program is dedicated to the public domain under the CC0 license.
-
-"""Simple inline keyboard bot with multiple CallbackQueryHandlers.
-
-This Bot uses the Application class to handle the bot.
-First, a few callback functions are defined as callback query handler. Then, those functions are
-passed to the Application and registered at their respective places.
-Then, the bot is started and runs until we press Ctrl-C on the command line.
-Usage:
-Example of a bot that uses inline keyboard that has multiple CallbackQueryHandlers arranged in a
-ConversationHandler.
-Send /start to initiate the conversation.
-Press Ctrl-C on the command line to stop the bot.
-"""
-import os
-import html
-import json
-import logging
-import re
-import sys
-import threading
-try:
-    import thread
-except ImportError:
-    import _thread as thread
-
-import traceback
-from datetime import datetime
-from time import sleep
-from telegram import __version__ as TG_VER
-from telegram.constants import ParseMode
-
-start_time = datetime.now()
-MINUTES_2_IN_SECONDS = 120
-OWNER_USER = "Itsonlypk"
-
-from PKDevTools.classes.Telegram import get_secrets
-from PKDevTools.classes.PKDateUtilities import PKDateUtilities
-from PKDevTools.classes.ColorText import colorText
-from pkscreener.classes.MenuOptions import MenuRenderStyle, menu, menus
-from pkscreener.classes.WorkflowManager import run_workflow
-from pkscreener.globals import showSendConfigInfo, showSendHelpInfo
-import pkscreener.classes.ConfigManager as ConfigManager
-
-monitor_proc = None
-configManager = ConfigManager.tools()
-bot_available=True
-
-try:
-    from telegram import __version_info__
-except ImportError:
-    __version_info__ = (0, 0, 0, 0, 0)  # type: ignore[assignment]
-
-if __version_info__ < (20, 0, 0, "alpha", 1):
-    raise RuntimeError(
-        f"This example is not compatible with your current PTB version {TG_VER}. To view the "
-        f"{TG_VER} version of this example, "
-        f"visit https://docs.python-telegram-bot.org/en/v{TG_VER}/examples.html"
-    )
-from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
-from telegram.ext import (
-    Application,
-    CallbackQueryHandler,
-    CommandHandler,
-    ContextTypes,
-    ConversationHandler,
-    MessageHandler,
-    filters,
-    CallbackContext
-)
-
-# Enable logging
-logging.basicConfig(
-    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
-)
-# set higher logging level for httpx to avoid all GET and POST requests being logged
-logging.getLogger("httpx").setLevel(logging.WARNING)
-
-logger = logging.getLogger(__name__)
-
-# Stages
-START_ROUTES, END_ROUTES = range(2)
-# Callback data
-ONE, TWO, THREE, FOUR = range(4)
-
-m0 = menus()
-m1 = menus()
-m2 = menus()
-m3 = menus()
-int_timer = None
-
-TOP_LEVEL_SCANNER_MENUS = ["X", "B", "MI","DV"]
-TOP_LEVEL_SCANNER_SKIP_MENUS = ["M", "S", "G", "C", "P", "T", "D", "I", "E", "U", "L", "Z"]
-INDEX_SKIP_MENUS = ["W","E","M","Z","0","2","3","4","6","7","9","10","13"]
-SCANNER_SKIP_MENUS_1_TO_6 = ["0","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","42","M","Z"]
-SCANNER_SKIP_MENUS_7_TO_12 = ["0","1","2","3","4","5","6","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","42","M","Z"]
-SCANNER_SKIP_MENUS_13_TO_18 = ["0","1","2","3","4","5","6","7","8","9","10","11","12","19","20","21","22","23","24","25","26","27","28","29","30","31","32","42","M","Z"]
-SCANNER_SKIP_MENUS_19_TO_25 = ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","22","26","27","28","29","30","31","32","42","M","Z"]
-SCANNER_SKIP_MENUS_26_TO_31 = ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","32","42","M","Z"]
-SCANNER_MENUS_WITH_NO_SUBMENUS = ["1","2","3","10","11","12","13","14","15","16","17","18","19","20","21","23","24","25","26","27","28","29","30","31","32"]
-SCANNER_MENUS_WITH_SUBMENU_SUPPORT = ["6", "7", "21"]
-
-INDEX_COMMANDS_SKIP_MENUS_SCANNER = ["W", "E", "M", "Z"]
-INDEX_COMMANDS_SKIP_MENUS_BACKTEST = ["W", "E", "M", "Z", "N", "0", "15"]
-UNSUPPORTED_COMMAND_MENUS =["22","42","M","Z"]
-SUPPORTED_COMMAND_MENUS = ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32"]
-
-def initializeIntradayTimer():
-    try:
-        if (not PKDateUtilities.isTodayHoliday()[0]):
-            now = PKDateUtilities.currentDateTime()
-            marketStartTime = PKDateUtilities.currentDateTime(simulate=True,hour=9,minute=15)
-            morning745am = PKDateUtilities.currentDateTime(simulate=True,hour=7,minute=45)
-            if now < marketStartTime and now >= morning745am: # Telegram bot might keep running beyond an hour. So let's start watching around 7:45AM
-                difference = (marketStartTime - now).total_seconds() + 1
-                global int_timer
-                int_timer = threading.Timer(difference, launchIntradayMonitor, args=[])
-                int_timer.start()
-            elif now >= marketStartTime:
-                launchIntradayMonitor()
-    except:
-        launchIntradayMonitor()
-        pass
-
-async def start(update: Update, context: ContextTypes.DEFAULT_TYPE, updatedResults=None, monitorIndex=0,chosenBotMenuOption="") -> int:
-    """Send message on `/start`."""
-    global bot_available
-    updateCarrier = None
-    if update is None:
-        return
-    else:
-        if update.callback_query is not None:
-            updateCarrier = update.callback_query
-        if update.message is not None:
-            updateCarrier = update.message
-        if updateCarrier is None:
-            return
-    # Get user that sent /start and log his name
-    user = updateCarrier.from_user
-    logger.info("User %s started the conversation.", user.first_name)
-    if not bot_available:
-        updatedResults = "Apologies! The @nse_pkscreener_bot is NOT available for the time being! We are working with our host GitHub and other data source providers to sort out pending invoices and restore the services soon! Thanks for your patience and support! "
-    # Build InlineKeyboard where each button has a displayed text
-    # and a string as callback_data
-    # The keyboard is a list of button rows, where each row is in turn
-    # a list (hence `[[...]]`).
-    if bot_available:
-        mns = m0.renderForMenu(asList=True)
-        if (PKDateUtilities.isTradingTime() and not PKDateUtilities.isTodayHoliday()[0]) or ("PKDevTools_Default_Log_Level" in os.environ.keys()) or sys.argv[0].endswith(".py"):
-            mns.append(menu().create(f"MI_{monitorIndex}", "Int. Monitor", 2))
-        if user.username == OWNER_USER:
-            mns.append(menu().create(f"DV_0", ("Enbl" if not configManager.logsEnabled else "Dsbl"), 2))
-
-        inlineMenus = []
-        for mnu in mns:
-            if mnu.menuKey[0:2] in TOP_LEVEL_SCANNER_MENUS:
-                inlineMenus.append(
-                    InlineKeyboardButton(
-                        mnu.menuText.split("(")[0],
-                        callback_data="C" + str(mnu.menuKey),
-                    )
-                )
-        keyboard = [inlineMenus]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        cmds = m0.renderForMenu(
-            selectedMenu=None,
-            skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
-            asList=True,
-            renderStyle=MenuRenderStyle.STANDALONE,
-        )
-    else:
-        reply_markup = None
-
-    if updatedResults is None:
-        cmdText = ""
-        for cmd in cmds:
-            cmdText = f"{cmdText}\n\n{cmd.commandTextKey()} for {cmd.commandTextLabel()}"
-        menuText = f"Welcome {user.first_name}, {(user.username)}! Please choose a menu option by selecting a button from below.\n\nYou can also explore a wide variety of all other scanners by typing in \n{cmdText}\n\n OR just use the buttons below to choose."
-    else:
-        chosenBotMenuOption = f"{chosenBotMenuOption}\nInt. Monitor. MonitorIndex:{monitorIndex}\n{updatedResults}"
-        menuText = updatedResults
-    # Send message with text and appended InlineKeyboard
-    if update.callback_query is not None:
-        await sendUpdatedMenu(
-            menuText=menuText, update=update, context=context, reply_markup=reply_markup, replaceWhiteSpaces=(updatedResults is None)
-        )
-    elif update.message is not None:
-        await update.message.reply_text(
-            menuText,
-            reply_markup=reply_markup,
-        )
-    await context.bot.send_message(
-        chat_id=int(f"-{Channel_Id}"),
-        text=f"Name: {user.first_name}, Username:@{user.username} with ID: {str(user.id)} started using the bot!\n{chosenBotMenuOption}",
-        parse_mode=ParseMode.HTML,
-    )
-    # Tell ConversationHandler that we're in state `FIRST` now
-    return START_ROUTES
-
-def removeMonitorFile():
-    from PKDevTools.classes import Archiver
-    configManager.getConfig(ConfigManager.parser)
-    filePath = os.path.join(Archiver.get_user_outputs_dir(), "monitor_outputs")
-    index = 0
-    while index < configManager.maxDashboardWidgetsPerRow*configManager.maxNumResultRowsInMonitor:
-        try:
-            os.remove(f"{filePath}_{index}.txt")
-        except:
-            pass
-        index += 1
-
-def launchIntradayMonitor():
-    from PKDevTools.classes import Archiver
-    global int_timer
-    if int_timer is not None:
-        int_timer.cancel()
-    filePath = os.path.join(Archiver.get_user_outputs_dir(), "monitor_outputs")
-    result_outputs = ""
-    if (PKDateUtilities.isTradingTime() and not PKDateUtilities.isTodayHoliday()[0]) or ("PKDevTools_Default_Log_Level" in os.environ.keys() or sys.argv[0].endswith(".py")):
-        result_outputs = "Starting up the monitor for this hour. Please try again after 30-40 seconds."
-    else:
-        result_outputs = f"{PKDateUtilities.currentDateTime()}\nIntraday Monitor is available only during the NSE trading hours! Please try during the next trading session."
-        try:
-            removeMonitorFile()
-        except:
-            pass
-        return result_outputs, filePath
-
-    appLogsEnabled = ("PKDevTools_Default_Log_Level" in os.environ.keys() or sys.argv[0].endswith(".py"))
-    # User wants an Int. Monitor
-    launcher = "/home/runner/work/PKScreener/PKScreener/pkscreenercli.bin" if "MONITORING_BOT_RUNNER" in os.environ.keys() else "pkscreener"
-    launcher = f"python3.11 {launcher}" if launcher.endswith(".py") else launcher
-    
-    try:
-        from subprocess import Popen
-        global monitor_proc
-        if monitor_proc is None or monitor_proc.poll() is not None: # Process finished from an earlier launch
-            # Let's remove the old file(s) so that the new app can begin to run
-            # If we don't remove, it might just exit assuming that there's another instance
-            # already running.
-            removeMonitorFile()
-            appArgs = [f"{launcher}","-a","Y","-m","X","--telegram",]
-            if appLogsEnabled:
-                appArgs.append("-l")
-            else:
-                appArgs.append("-p")
-            monitor_proc = Popen(appArgs)
-            logger.info(f"{launcher} -a Y -m 'X' -p --telegram launched")
-        else:
-            result_outputs = "Monitor is running, but the results are being prepared. Try again in next few seconds."
-            logger.info(f"{launcher} -a Y -m 'X' -p --telegram already running")
-    except Exception as e:
-        result_outputs = "Hmm...It looks like you caught us taking a break! Try again later :-)"
-        logger.info(f"{launcher} -a Y -m 'X' -p --telegram could not be launched")
-        logger.info(e)
-        pass
-    return result_outputs, filePath
-
-async def XDevModeHandler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    """Show new choice of buttons"""
-    query = update.callback_query
-    data = query.data.upper().replace("CX", "X").replace("CB", "B").replace("CG", "G").replace("CMI", "MI").replace("CDV","DV")
-    if data[0:2] not in TOP_LEVEL_SCANNER_MENUS:
-        return start(update, context)
-    if data.startswith("DV"):
-        # Dev Mode
-        devModeIndex = int(data.split("_")[1])
-        if devModeIndex == 0:
-            if "PKDevTools_Default_Log_Level" in os.environ.keys():
-                del os.environ['PKDevTools_Default_Log_Level']
-                configManager.maxNumResultRowsInMonitor = 2
-                configManager.logsEnabled = False
-            else:
-                # Switch config file
-                configManager.maxNumResultRowsInMonitor = 3
-                configManager.logsEnabled = True
-                os.environ["PKDevTools_Default_Log_Level"] = str(logging.INFO)
-            configManager.setConfig(ConfigManager.parser, default=True, showFileCreatedText=False)
-            chosenBotMenuOption = configManager.showConfigFile(defaultAnswer='Y')
-            if monitor_proc is not None:
-                try:
-                    monitor_proc.kill()
-                except:
-                    pass
-            
-            launchIntradayMonitor()
-            await start(update, context,chosenBotMenuOption=chosenBotMenuOption)
-    return START_ROUTES
-
-async def XScanners(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    """Show new choice of buttons"""
-    query = update.callback_query
-    data = query.data.upper().replace("CX", "X").replace("CB", "B").replace("CG", "G").replace("CMI", "MI")
-    if data[0:2] not in TOP_LEVEL_SCANNER_MENUS:
-        return start(update, context)
-    global bot_available
-    if not bot_available:
-        await start(update, context)
-        return START_ROUTES
-    if data.startswith("MI"):
-        monitorIndex = int(data.split("_")[1])
-        result_outputs, filePath = launchIntradayMonitor()
-        filePath = f"{filePath}_{monitorIndex}.txt"
-        monitorIndex += 1
-        if monitorIndex >= configManager.maxDashboardWidgetsPerRow*configManager.maxNumResultRowsInMonitor:
-            monitorIndex = 0
-        try:
-            if os.path.exists(filePath):
-                f = open(filePath, "r")
-                result_outputs = f.read()
-                f.close()
-            await start(update, context, updatedResults=result_outputs,monitorIndex=monitorIndex)
-            return START_ROUTES
-        except Exception as e:
-            result_outputs = "Hmm...It looks like you caught us taking a break! Try again later :-)\nCycleTime shows how much it's taking us to download latest data and then perform each cycle of analysis for all configured scanners. We may be downloading the latest data right now."
-            logger.info(e)
-            logger.info(f"Could not read {filePath}")
-            await start(update, context, updatedResults=result_outputs,monitorIndex=monitorIndex)
-            return START_ROUTES
-
-    midSkip = "1" if data == "X" else "N"
-    skipMenus = [midSkip]
-    skipMenus.extend(INDEX_SKIP_MENUS)
-    menuText = (
-        m1.renderForMenu(
-            m0.find(data),
-            skip=skipMenus,
-            renderStyle=MenuRenderStyle.STANDALONE,
-        )
-        .replace("     ", "")
-        .replace("    ", "")
-        .replace("\t", "")
-        .replace(colorText.FAIL,"").replace(colorText.END,"")
-    )
-    menuText = menuText + "\n\nH > Home"
-    mns = m1.renderForMenu(
-        m0.find(data),
-        skip=skipMenus,
-        asList=True,
-    )
-    mns.append(menu().create("H", "Home", 2))
-    inlineMenus = []
-    await query.answer()
-    for mnu in mns:
-        inlineMenus.append(
-            InlineKeyboardButton(
-                mnu.menuKey, callback_data=str(f"{query.data}_{mnu.menuKey}")
-            )
-        )
-    keyboard = [inlineMenus]
-    reply_markup = InlineKeyboardMarkup(keyboard)
-    if query.message.text == menuText:
-        menuText = f"{PKDateUtilities.currentDateTime()}:\n{menuText}"
-    await query.edit_message_text(text=menuText, reply_markup=reply_markup)
-    return START_ROUTES
-
-
-async def Level2(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    """Show new choice of buttons"""
-    inlineMenus = []
-    menuText = "Hmm...It looks like you caught us taking a break! Try again later :-)"
-    mns = []
-    query = update.callback_query
-    await query.answer()
-    preSelection = (
-        query.data.upper().replace("CX", "X").replace("CB", "B").replace("CG", "G")
-    )
-    selection = preSelection.split("_")
-    preSelection = f"{selection[0]}_{selection[1]}"
-    if (selection[0].upper() not in TOP_LEVEL_SCANNER_MENUS):
-        await start(update, context)
-        return START_ROUTES
-    global bot_available
-    if not bot_available:
-        await start(update, context)
-        return START_ROUTES
-    if selection[len(selection)-1].upper() == "H":
-        await start(update, context)
-        return START_ROUTES
-    if len(selection) == 2 or (len(selection) == 3 and selection[2] == "P"):
-        if str(selection[1]).isnumeric():
-            # It's only level 2
-            menuText = m2.renderForMenu(
-                m1.find(selection[1]),
-                skip=SCANNER_SKIP_MENUS_1_TO_6,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            menuText = menuText + "\n\nN > More options"
-            menuText = menuText + "\nH > Home"
-            mns = m2.renderForMenu(
-                m1.find(selection[1]),
-                skip=SCANNER_SKIP_MENUS_1_TO_6,
-                asList=True,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            mns.append(menu().create("N", "More Options", 2))
-            mns.append(menu().create("H", "Home", 2))
-        elif selection[1] == "N":
-            selection.extend(["", ""])
-    elif len(selection) == 3:
-        if selection[2] == "N":
-            menuText = m2.renderForMenu(
-                m1.find(selection[1]),
-                skip=SCANNER_SKIP_MENUS_7_TO_12,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            menuText = menuText + "\n\nM > More Options"
-            menuText = menuText + "\nH > Home"
-            mns = m2.renderForMenu(
-                m1.find(selection[1]),
-                skip=SCANNER_SKIP_MENUS_7_TO_12,
-                asList=True,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            mns.append(menu().create("M", "More Options", 2))
-            mns.append(menu().create("H", "Home", 2))
-        elif selection[2] == "M":
-            menuText = m2.renderForMenu(
-                m1.find(selection[1]),
-                skip=SCANNER_SKIP_MENUS_13_TO_18,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            menuText = menuText + "\n\n>> More Options"
-            menuText = menuText + "\nH > Home"
-            mns = m2.renderForMenu(
-                m1.find(selection[1]),
-                skip=SCANNER_SKIP_MENUS_13_TO_18,
-                asList=True,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            mns.append(menu().create(">>", "More Options", 2))
-            mns.append(menu().create("H", "Home", 2))
-        elif selection[2] == ">>":
-            menuText = m2.renderForMenu(
-                m1.find(selection[1]),
-                skip=SCANNER_SKIP_MENUS_19_TO_25,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            menuText = menuText + "\n\nR > More Options"
-            menuText = menuText + "\nH > Home"
-            mns = m2.renderForMenu(
-                m1.find(selection[1]),
-                skip=SCANNER_SKIP_MENUS_19_TO_25,
-                asList=True,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            mns.append(menu().create("R", "More Options", 2))
-            mns.append(menu().create("H", "Home", 2))
-        elif selection[2] == "R":
-            menuText = m2.renderForMenu(
-                m1.find(selection[1]),
-                skip=SCANNER_SKIP_MENUS_26_TO_31,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            menuText = menuText + "\n\nH > Home"
-            mns = m2.renderForMenu(
-                m1.find(selection[1]),
-                skip=SCANNER_SKIP_MENUS_26_TO_31,
-                asList=True,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            mns.append(menu().create("H", "Home", 2))
-        elif str(selection[2]).isnumeric():
-            preSelection = f"{selection[0]}_{selection[1]}_{selection[2]}"
-            if selection[2] in SCANNER_MENUS_WITH_SUBMENU_SUPPORT:
-                menuText = m3.renderForMenu(
-                    m2.find(selection[2]),
-                    renderStyle=MenuRenderStyle.STANDALONE,
-                    skip=["0"],
-                )
-                mns = m3.renderForMenu(
-                    m2.find(selection[2]),
-                    asList=True,
-                    renderStyle=MenuRenderStyle.STANDALONE,
-                    skip=["0"],
-                )
-            else:
-                if selection[2] == "4":  # Last N days
-                    selection.extend(["D", ""])
-                elif selection[2] == "5":  # RSI range
-                    selection.extend(["D", "D"])
-                elif selection[2] == "8":  # CCI range
-                    selection.extend(["D", "D"])
-                elif selection[2] == "9":  # Vol gainer ratio
-                    selection.extend(["D", ""])
-                elif selection[2] in SCANNER_MENUS_WITH_NO_SUBMENUS:  # Vol gainer ratio
-                    selection.extend(["", ""])
-    elif len(selection) == 4:
-        preSelection = (
-            query.data.upper().replace("CX", "X").replace("CB", "B").replace("CG", "G")
-        )
-    optionChoices = ""
-    if len(selection) <= 3 and mns is not None:
-        for mnu in mns:
-            inlineMenus.append(
-                InlineKeyboardButton(
-                    mnu.menuKey,
-                    callback_data="C" + str(f"{preSelection}_{mnu.menuKey}"),
-                )
-            )
-        keyboard = [inlineMenus]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-    elif len(selection) >= 4:
-        optionChoices = (
-            f"{selection[0]} > {selection[1]} > {selection[2]} > {selection[3]}"
-        )
-        expectedTime = f"{'10 to 15' if '> 15' in optionChoices else '1 to 2'}"
-        menuText = f"Thank you for choosing {optionChoices}. You will receive the notification/results in about {expectedTime} minutes. It generally takes 1-2 minutes for NSE (2000+) stocks and 10-15 minutes for NASDAQ (7300+).\n\nPKScreener is free and will always remain so for everyone. Consider donating to help cover the basic server costs:\n\nUPI (India): 8007162973@APL \n\nor\nhttps://github.com/sponsors/pkjmesra?frequency=one-time&sponsor=pkjmesra"
-
-        reply_markup = default_markup(inlineMenus)
-        options = ":".join(selection)
-        await launchScreener(
-            options=options,
-            user=query.from_user,
-            context=context,
-            optionChoices=optionChoices,
-            update=update,
-        )
-    try:
-        if optionChoices != "":
-            await context.bot.send_message(
-                chat_id=int(f"-{Channel_Id}"),
-                text=f"Name: <b>{query.from_user.first_name}</b>, Username:@{query.from_user.username} with ID: <b>@{str(query.from_user.id)}</b> submitted scan request <b>{optionChoices}</b> to the bot!",
-                parse_mode=ParseMode.HTML,
-            )
-    except Exception:# pragma: no cover
-        await start(update, context)
-    if not str(optionChoices.upper()).startswith("B"):
-        await sendUpdatedMenu(
-            menuText=menuText, update=update, context=context, reply_markup=reply_markup
-        )
-    return START_ROUTES
-
-def default_markup(inlineMenus):
-    mns = m0.renderForMenu(asList=True)
-    for mnu in mns:
-        if mnu.menuKey in TOP_LEVEL_SCANNER_MENUS:
-            inlineMenus.append(
-                    InlineKeyboardButton(
-                        mnu.menuText.split("(")[0],
-                        callback_data="C" + str(mnu.menuKey),
-                    )
-                )
-    keyboard = [inlineMenus]
-    reply_markup = InlineKeyboardMarkup(keyboard)
-    return reply_markup
-
-
-async def sendUpdatedMenu(menuText, update: Update, context, reply_markup, replaceWhiteSpaces=True):
-    try:
-        if update.callback_query.message.text == menuText:
-            menuText = f"{PKDateUtilities.currentDateTime()}:\n{menuText}"
-        await update.callback_query.edit_message_text(
-            text=menuText.replace("     ", "").replace("    ", "").replace("\t", "").replace(colorText.FAIL,"").replace(colorText.END,"") if replaceWhiteSpaces else menuText,
-            parse_mode="HTML",
-            reply_markup=reply_markup,
-        )
-    except Exception as e:# pragma: no cover
-        logger.log(e)
-        await start(update, context)
-
-
-async def launchScreener(options, user, context, optionChoices, update):
-    try:
-        if str(optionChoices.upper()).startswith("B"):
-            optionChoices = optionChoices.replace(" ", "").replace(">", "_").replace(":","_").replace("_D","")
-            while optionChoices.endswith("_"):
-                optionChoices = optionChoices[:-1]
-            if str(optionChoices).split("_")[2] == "6" and str(optionChoices).split("_")[3] == "7":
-                optionChoices = f"{optionChoices}_3" # Lorenzian Any/All
-            responseText = f"Thank you for choosing {optionChoices}!\n\nHere are the results:\n\nInsights: https://pkjmesra.github.io/PKScreener/Backtest-Reports/PKScreener_{optionChoices}_Insights_DateSorted.html"
-            responseText = f"{responseText}\n\nSummary: https://pkjmesra.github.io/PKScreener/Backtest-Reports/PKScreener_{optionChoices}_Summary_StockSorted.html"
-            responseText = f"{responseText}\n\nStock-wise: https://pkjmesra.github.io/PKScreener/Backtest-Reports/PKScreener_{optionChoices}_backtest_result_StockSorted.html"
-            responseText = f"{responseText}\n\nOther Reports: https://pkjmesra.github.io/PKScreener/BacktestReports.html"
-            if update is not None and update.message is not None:
-                await update.message.reply_text(responseText)
-            else:
-                await update.callback_query.edit_message_text(
-                    text=responseText,
-                    reply_markup=default_markup([]),
-                )
-            await shareUpdateWithChannel(
-                update=update, context=context, optionChoices=optionChoices
-            )
-            # run_workflow(optionChoices, str(user.id), str(options.upper()))
-        elif str(optionChoices.upper()).startswith("X"):
-            optionChoices = optionChoices.replace(" ", "").replace(">", "_")
-            while optionChoices.endswith("_"):
-                optionChoices = optionChoices[:-1]
-            run_workflow(
-                optionChoices, str(user.id), str(options.upper()), workflowType="X"
-            )
-        elif str(optionChoices.upper()).startswith("G"):
-            optionChoices = optionChoices.replace(" ", "").replace(">", "_")
-            while optionChoices.endswith("_"):
-                optionChoices = optionChoices[:-1]
-            options = options.upper().replace("G", "G:3").replace("::", ":D:D:D")
-            run_workflow(
-                optionChoices, str(user.id), str(options.upper()), workflowType="G"
-            )
-            # Popen(
-            #     [
-            #         "pkscreener",
-            #         "-a",
-            #         "Y",
-            #         "-e",
-            #         "-p",
-            #         "-o",
-            #         str(options.upper()),
-            #         "-u",
-            #         str(user.id),
-            #     ]
-            # )
-    except Exception as e:
-        import traceback
-        traceback.print_exc()
-        print(e)
-        await start(update, context)
-
-
-async def BBacktests(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    """Show new choice of buttons"""
-    query = update.callback_query
-    await query.answer()
-    keyboard = [
-        [
-            InlineKeyboardButton("Try Scanners", callback_data=str("CX")),
-            # InlineKeyboardButton("Growth of 10k", callback_data=str("CG")),
-        ]
-    ]
-    reply_markup = InlineKeyboardMarkup(keyboard)
-    await query.edit_message_text(
-        text="Backtesting NOT implemented yet in this Bot!\n\n\nYou can use backtesting by downloading the software from https://github.com/pkjmesra/PKScreener/",
-        reply_markup=reply_markup,
-    )
-    return START_ROUTES
-
-
-async def end(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
-    """Returns `ConversationHandler.END`, which tells the
-    ConversationHandler that the conversation is over.
-    """
-    query = update.callback_query
-    await query.answer()
-    await query.edit_message_text(
-        text="See https://github.com/pkjmesra/PKScreener/ for more details or join https://t.me/PKScreener. \n\n\nSee you next time!"
-    )
-    return ConversationHandler.END
-
-
-# This can be your own ID, or one for a developer group/channel.
-# You can use the /start command of this bot to see your chat id.
-chat_idADMIN = 123456789
-Channel_Id = 12345678
-GROUP_CHAT_ID = 1001907892864
-
-
-async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
-    """Log the error and send a telegram message to notify the developer."""
-    # Log the error before we do anything else, so we can see it even if something breaks.
-    logger.error("Exception while handling an update:", exc_info=context.error)
-
-    # traceback.format_exception returns the usual python message about an exception, but as a
-    # list of strings rather than a single string, so we have to join them together.
-    tb_list = traceback.format_exception(
-        None, context.error, context.error.__traceback__
-    )
-    tb_string = "".join(tb_list)
-    global start_time
-    timeSinceStarted = datetime.now() - start_time
-    if (
-        "telegram.error.Conflict" in tb_string
-    ):  # A newer 2nd instance was registered. We should politely shutdown.
-        if (
-            timeSinceStarted.total_seconds() >= MINUTES_2_IN_SECONDS
-        ):  # shutdown only if we have been running for over 5 minutes
-            print(
-                f"Stopping due to conflict after running for {timeSinceStarted.total_seconds()/60} minutes."
-            )
-            try:
-                global int_timer
-                if int_timer is not None:
-                    int_timer.cancel()
-            except:
-                pass
-            try:
-                context.application.stop()
-                sys.exit(0)
-            except RuntimeError:
-                context.application.shutdown()
-            sys.exit(0)
-        else:
-            print("Other instance running!")
-            # context.application.run_polling(allowed_updates=Update.ALL_TYPES)
-    # Build the message with some markup and additional information about what happened.
-    # You might need to add some logic to deal with messages longer than the 4096 character limit.
-    update_str = update.to_dict() if isinstance(update, Update) else str(update)
-    message = (
-        f"An exception was raised while handling an update\n"
-        f"<pre>update = {html.escape(json.dumps(update_str, indent=2, ensure_ascii=False))}"
-        "</pre>\n\n"
-        f"<pre>context.chat_data = {html.escape(str(context.chat_data))}</pre>\n\n"
-        f"<pre>context.user_data = {html.escape(str(context.user_data))}</pre>\n\n"
-        f"<pre>{html.escape(tb_string)}</pre>"
-    )
-
-    try:
-        # Finally, send the message
-        if "telegram.error.Conflict" not in message:
-            await context.bot.send_message(
-                chat_id=int(f"-{Channel_Id}"), text=message, parse_mode=ParseMode.HTML
-            )
-    except Exception:# pragma: no cover
-        try:
-            if "telegram.error.Conflict" not in tb_string:
-                await context.bot.send_message(
-                    chat_id=int(f"-{Channel_Id}"),
-                    text=tb_string,
-                    parse_mode=ParseMode.HTML,
-                )
-        except Exception:# pragma: no cover
-            print(tb_string)
-
-
-async def command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
-    if _shouldAvoidResponse(update):
-        return
-    msg = update.effective_message
-    m = re.match("\s*/([0-9a-zA-Z_-]+)\s*(.*)", msg.text)
-    cmd = m.group(1).lower()
-    args = [arg for arg in re.split("\s+", m.group(2)) if len(arg)]
-    if cmd.startswith("cx_") or cmd.startswith("cb_") or cmd.startswith("cg_"):
-        await Level2(update=update, context=context)
-        return START_ROUTES
-    if cmd.startswith("cx") or cmd.startswith("cb") or cmd.startswith("cg"):
-        await XScanners(update=update, context=context)
-        return START_ROUTES
-    if cmd.startswith("cz"):
-        await end(update=update, context=context)
-        return END_ROUTES
-
-    if cmd == "start":
-        await start(update=update, context=context)
-        return START_ROUTES
-    if cmd == "help":
-        await help_command(update=update, context=context)
-        return START_ROUTES
-    if cmd.upper() in TOP_LEVEL_SCANNER_MENUS:
-        await shareUpdateWithChannel(update=update, context=context)
-        m0.renderForMenu(
-            selectedMenu=None,
-            skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
-            renderStyle=MenuRenderStyle.STANDALONE,
-        )
-        selectedMenu = m0.find(cmd.upper())
-        cmdText = ""
-        cmds = m1.renderForMenu(
-            selectedMenu=selectedMenu,
-            skip=(INDEX_COMMANDS_SKIP_MENUS_SCANNER  if cmd in ["x"] else INDEX_COMMANDS_SKIP_MENUS_BACKTEST),
-            asList=True,
-            renderStyle=MenuRenderStyle.STANDALONE,
-        )
-        for cmd in cmds:
-            if cmd in ["N", "0"]:
-                continue
-            cmdText = (
-                f"{cmdText}\n\n{cmd.commandTextKey()} for {cmd.commandTextLabel()}"
-            )
-        if cmd in ["x"]:
-            cmdText = f"{cmdText}\n\nFor option 0 <Screen stocks by the stock name>, please type in the command in the following format\n/X_0 SBIN\n or \n/X_0_0 SBIN\nand hit send where SBIN is the NSE stock code.For multiple stocks, you can type in \n/X_0 SBIN,ICICIBANK,OtherStocks\nYou can put in any number of stocks separated by space or comma(,)."
-        """Send a message when the command /help is issued."""
-        await update.message.reply_text(f"Choose an option:\n{cmdText}")
-        return START_ROUTES
-
-    if update.message is None:
-        await help_command(update=update, context=context)
-        return START_ROUTES
-    if "x_0" in cmd or "x_0_0" in cmd or "b_0" in cmd or "g_0" in cmd:
-        await shareUpdateWithChannel(update=update, context=context)
-        shouldScan = False
-        if len(args) > 0:
-            shouldScan = True
-            selection = [
-                cmd.split("_")[0].upper(),
-                "0",
-                "0",
-                f"{','.join(args)}".replace(" ", ""),
-            ]
-        if shouldScan:
-            options = ":".join(selection)
-            await launchScreener(
-                options=options,
-                user=update.message.from_user,
-                context=context,
-                optionChoices=cmd.upper(),
-                update=update,
-            )
-            await sendRequestSubmitted(cmd.upper(), update=update, context=context)
-            return START_ROUTES
-        else:
-            if cmd in ["x"]:
-                cmdText = "For option 0 <Screen stocks by the stock name>, please type in the command in the following format\n/X_0 SBIN or /X_0_0 SBIN and hit send where SBIN is the NSE stock code.For multiple stocks, you can type in /X_0 SBIN,ICICIBANK,OtherStocks . You can put in any number of stocks separated by space or comma(,)."
-            """Send a message when the command /help is issued."""
-            await update.message.reply_text(f"Choose an option:\n{cmdText}")
-            return START_ROUTES
-
-    if "x_" in cmd or "b_" in cmd or "g_" in cmd:
-        await shareUpdateWithChannel(update=update, context=context)
-        selection = cmd.split("_")
-        if len(selection) == 2:
-            m0.renderForMenu(
-                selectedMenu=None,
-                skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            selectedMenu = m0.find(selection[0].upper())
-            m1.renderForMenu(
-                selectedMenu=selectedMenu,
-                skip=(
-                    INDEX_COMMANDS_SKIP_MENUS_SCANNER
-                    if "x_" in cmd
-                    else INDEX_COMMANDS_SKIP_MENUS_BACKTEST
-                ),
-                asList=True,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            selectedMenu = m1.find(selection[1].upper())
-            if "x_" in cmd and selectedMenu.menuKey == "N":  # Nifty prediction
-                options = ":".join(selection)
-                await launchScreener(
-                    options=options,
-                    user=update.message.from_user,
-                    context=context,
-                    optionChoices=cmd.upper(),
-                    update=update,
-                )
-                await sendRequestSubmitted(cmd.upper(), update=update, context=context)
-                return START_ROUTES
-            elif (
-                "x_" in cmd and selectedMenu.menuKey == "0"
-            ):  # a specific stock by name
-                cmdText = "For option 0 <Screen stocks by the stock name>, please type in the command in the following format\n/X_0 SBIN or /X_0_0 SBIN and hit send where SBIN is the NSE stock code.For multiple stocks, you can type in /X_0 SBIN,ICICIBANK,OtherStocks. You can put in any number of stocks separated by space or comma(,)."
-                """Send a message when the command /help is issued."""
-                await update.message.reply_text(f"Choose an option:\n{cmdText}")
-                return START_ROUTES
-            cmds = m2.renderForMenu(
-                selectedMenu=selectedMenu,
-                skip=UNSUPPORTED_COMMAND_MENUS,
-                asList=True,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            cmdText = ""
-            for cmd in cmds:
-                cmdText = (
-                    f"{cmdText}\n\n{cmd.commandTextKey()} for {cmd.commandTextLabel()}"
-                )
-            await update.message.reply_text(f"Choose an option:\n{cmdText}")
-            return START_ROUTES
-        elif len(selection) == 3:
-            m0.renderForMenu(
-                selectedMenu=None,
-                skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            selectedMenu = m0.find(selection[0].upper())
-            m1.renderForMenu(
-                selectedMenu=selectedMenu,
-                skip=(
-                    INDEX_COMMANDS_SKIP_MENUS_SCANNER
-                    if "x_" in cmd
-                    else INDEX_COMMANDS_SKIP_MENUS_BACKTEST
-                ),
-                asList=True,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            selectedMenu = m1.find(selection[1].upper())
-            m2.renderForMenu(
-                selectedMenu=selectedMenu,
-                skip=UNSUPPORTED_COMMAND_MENUS,
-                asList=True,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            if selection[2] in SCANNER_MENUS_WITH_SUBMENU_SUPPORT:
-                selectedMenu = m2.find(selection[2].upper())
-                cmds = m3.renderForMenu(
-                    selectedMenu=selectedMenu,
-                    asList=True,
-                    renderStyle=MenuRenderStyle.STANDALONE,
-                    skip=["0"],
-                )
-                cmdText = ""
-                for cmd in cmds:
-                    cmdText = f"{cmdText}\n\n{cmd.commandTextKey()} for {cmd.commandTextLabel()}"
-                await update.message.reply_text(f"Choose an option:\n{cmdText}")
-                return START_ROUTES
-            else:
-                if selection[2] == "4":  # Last N days
-                    selection.extend(["D", ""])
-                elif selection[2] == "5":  # RSI range
-                    selection.extend(["D", "D"])
-                elif selection[2] == "8":  # CCI range
-                    selection.extend(["D", "D"])
-                elif selection[2] == "9":  # Vol gainer ratio
-                    selection.extend(["D", ""])
-                elif selection[2] in SUPPORTED_COMMAND_MENUS:
-                    selection.extend(["", ""])
-        if len(selection) >= 4:
-            options = ":".join(selection)
-            await launchScreener(
-                options=options,
-                user=update.message.from_user,
-                context=context,
-                optionChoices=cmd.upper(),
-                update=update,
-            )
-            await sendRequestSubmitted(cmd.upper(), update=update, context=context)
-            return START_ROUTES
-    if cmd == "y" or cmd == "h":
-        await shareUpdateWithChannel(update=update, context=context)
-        if cmd == "y":
-            showSendConfigInfo(defaultAnswer='Y',user=str(update.message.from_user.id))
-        elif cmd == "h":
-            showSendHelpInfo(defaultAnswer='Y',user=str(update.message.from_user.id))
-        # await launchScreener(
-        #     options=f"{cmd.upper()}:",
-        #     user=update.message.from_user,
-        #     context=context,
-        #     optionChoices=cmd.upper(),
-        #     update=update,
-        # )
-        # await sendRequestSubmitted(cmd.upper(), update=update, context=context)
-        return START_ROUTES
-    await update.message.reply_text(f"{cmd.upper()} : Not implemented yet!")
-    await help_command(update=update, context=context)
-
-
-async def sendRequestSubmitted(optionChoices, update, context):
-    menuText = f"Thank you for choosing {optionChoices}. You will receive the notification/results in about 5 minutes! \n\nConsider donating to help keep this project going:\nUPI: 8007162973@APL \nor\nhttps://github.com/sponsors/pkjmesra?frequency=one-time&sponsor=pkjmesra"
-    await update.message.reply_text(menuText)
-    await help_command(update=update, context=context)
-    await shareUpdateWithChannel(
-        update=update, context=context, optionChoices=optionChoices
-    )
-
-
-async def shareUpdateWithChannel(update, context, optionChoices=""):
-    query = update.message or update.callback_query
-    message = f"Name: <b>{query.from_user.first_name}</b>, Username:@{query.from_user.username} with ID: <b>@{str(query.from_user.id)}</b> began using ({optionChoices}) the bot!"
-    await context.bot.send_message(
-        chat_id=int(f"-{Channel_Id}"), text=message, parse_mode=ParseMode.HTML
-    )
-
-
-async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
-    if _shouldAvoidResponse(update):
-        return
-    global bot_available
-    if not bot_available:
-        await start(update, context)
-        return START_ROUTES
-    cmds = m0.renderForMenu(
-        selectedMenu=None,
-        skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
-        asList=True,
-        renderStyle=MenuRenderStyle.STANDALONE,
-    )
-    cmdText = ""
-    for cmd in cmds:
-        cmdText = f"{cmdText}\n\n{cmd.commandTextKey()} for {cmd.commandTextLabel()}"
-    reply_markup = default_markup([])
-    
-    """Send a message when the command /help is issued."""
-    if update is not None and update.message is not None:
-        await update.message.reply_text(
-            f"You can begin by typing in /start and hit send!\n\nOR\n\nChoose an option:\n{cmdText}",
-            reply_markup=reply_markup
-        )  #  \n\nThis bot restarts every hour starting at 5:30am IST until 10:30pm IST to keep it running on free servers. If it does not respond, please try again in a minutes to avoid the restart duration!
-        query = update.message
-        message = f"Name: <b>{query.from_user.first_name}</b>, Username:@{query.from_user.username} with ID: <b>@{str(query.from_user.id)}</b> began using the bot!"
-        await context.bot.send_message(
-            chat_id=int(f"-{Channel_Id}"), text=message, parse_mode=ParseMode.HTML
-        )
-
-
-def _shouldAvoidResponse(update):
-    sentFrom = []
-    if update.callback_query is not None:
-        sentFrom.append(abs(update.callback_query.from_user.id))
-    if update.message is not None and update.message.from_user is not None:
-        sentFrom.append(abs(update.message.from_user.id))
-        if update.message.from_user.username is not None:
-            sentFrom.append(update.message.from_user.username)
-    if update.channel_post is not None:
-        if update.channel_post.chat is not None:
-            sentFrom.append(abs(update.channel_post.chat.id))
-            if update.channel_post.chat.username is not None:
-                sentFrom.append(update.channel_post.chat.username)
-        if update.channel_post.sender_chat is not None:
-            sentFrom.append(abs(update.channel_post.sender_chat.id))
-            sentFrom.append(update.channel_post.sender_chat.username)
-    if update.edited_channel_post is not None:
-        sentFrom.append(abs(update.edited_channel_post.sender_chat.id))
-
-    if (
-        abs(int(Channel_Id)) in sentFrom
-        or abs(int(GROUP_CHAT_ID)) in sentFrom
-        or "GroupAnonymousBot" in sentFrom
-        or "PKScreener" in sentFrom
-        or "PKScreeners" in sentFrom
-    ):
-        # We want to avoid sending any help message back to channel
-        # or group in response to our own messages
-        return True
-    return False
-
-
-def addCommandsForMenuItems(application):
-    cmds0 = m0.renderForMenu(
-        selectedMenu=None,
-        skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
-        asList=True,
-        renderStyle=MenuRenderStyle.STANDALONE,
-    )
-    for mnu0 in cmds0:
-        p0 = mnu0.menuKey.upper()
-        application.add_handler(CommandHandler(p0, command_handler))
-        selectedMenu = m0.find(p0)
-        cmds1 = m1.renderForMenu(
-            selectedMenu=selectedMenu,
-            skip=(
-                INDEX_COMMANDS_SKIP_MENUS_SCANNER if p0 == "X" else INDEX_COMMANDS_SKIP_MENUS_BACKTEST
-            ),
-            asList=True,
-            renderStyle=MenuRenderStyle.STANDALONE,
-        )
-        for mnu1 in cmds1:
-            p1 = mnu1.menuKey.upper()
-            if p1 in ["N", "0"]:
-                if p1 in ["N"]:
-                    application.add_handler(
-                        CommandHandler(f"{p0}_{p1}", command_handler)
-                    )
-                continue
-            application.add_handler(CommandHandler(f"{p0}_{p1}", command_handler))
-            selectedMenu = m1.find(p1)
-            cmds2 = m2.renderForMenu(
-                selectedMenu=selectedMenu,
-                skip=UNSUPPORTED_COMMAND_MENUS,
-                asList=True,
-                renderStyle=MenuRenderStyle.STANDALONE,
-            )
-            for mnu2 in cmds2:
-                p2 = mnu2.menuKey.upper()
-                application.add_handler(
-                    CommandHandler(f"{p0}_{p1}_{p2}", command_handler)
-                )
-                if p2 in SCANNER_MENUS_WITH_SUBMENU_SUPPORT:
-                    selectedMenu = m2.find(p2)
-                    cmds3 = m3.renderForMenu(
-                        selectedMenu=selectedMenu,
-                        asList=True,
-                        renderStyle=MenuRenderStyle.STANDALONE,
-                        skip=["0"],
-                    )
-                    for mnu3 in cmds3:
-                        p3 = mnu3.menuKey.upper()
-                        application.add_handler(
-                            CommandHandler(f"{p0}_{p1}_{p2}_{p3}", command_handler)
-                        )
-
-# def send_stuff(context: CallbackContext):
-#   job = context.job
-
-#   keyboard = [ 
-#     [   
-#         InlineKeyboardButton("NEVER", callback_data="NEVER"),
-#         InlineKeyboardButton("UNLIKELY", callback_data="UNLIKELY")
-#     ],  
-#     [   
-#         InlineKeyboardButton("MEH", callback_data="MEH"),
-#         InlineKeyboardButton("MAYBE", callback_data="MAYBE")
-#     ],  
-#     [   
-#         InlineKeyboardButton("YES", callback_data="YES"),
-#         InlineKeyboardButton("ABSOLUTELY", callback_data="ABSOLUTELY")
-#     ],  
-#     [   
-#         InlineKeyboardButton("RATHER NOT SAY", callback_data="UNKNOWN")
-#     ]   
-#   ]
-
-#   reply_markup = InlineKeyboardMarkup(keyboard)
-
-#   context.bot.send_photo(job.context, photo=open(PATH+thefile, 'rb'))
-#   # return values of send_message are saved in the 'msg' var
-#   msg = context.bot.send_message(job.context, text='RATE', reply_markup=reply_markup)
-
-#   # the following job is created every time the send_stuff function is called
-#   context.job_queue.run_once(
-#     callback=cleanup,
-#     when=5,
-#     context=msg,
-#     name='cleanup'
-#   )
-
-# # the function called by the job
-# def cleanup(context: CallbackContext):
-#   job = context.job
-
-#   context.bot.edit_message_text(
-#     chat_id=job.context.chat.id,
-#     text='NO ANSWER PROVIDED',
-#     message_id=job.context.message_id
-#   )
-
-
-def runpkscreenerbot(availability=True) -> None:
-    """Run the bot."""
-    # Create the Application and pass it your bot's token.
-    global chat_idADMIN, Channel_Id, bot_available
-    bot_available = availability
-    Channel_Id, TOKEN, chat_idADMIN, GITHUB_TOKEN = get_secrets()
-    # TOKEN = '1234567'
-    # Channel_Id = 1001785195297
-    application = Application.builder().token(TOKEN).build()
-    # Setup conversation handler with the states FIRST and SECOND
-    # Use the pattern parameter to pass CallbackQueries with specific
-    # data pattern to the corresponding handlers.
-    # ^ means "start of line/string"
-    # $ means "end of line/string"
-    # So ^ABC$ will only allow 'ABC'
-    conv_handler = ConversationHandler(
-        entry_points=[CommandHandler("start", start)],
-        states={
-            START_ROUTES: [
-                CallbackQueryHandler(XScanners, pattern="^" + str("CX") + "$"),
-                CallbackQueryHandler(XScanners, pattern="^" + str("CB") + "$"),
-                CallbackQueryHandler(XScanners, pattern="^" + str("CMI_")),
-                CallbackQueryHandler(XDevModeHandler, pattern="^" + str("CDV_")),
-                # CallbackQueryHandler(XScanners, pattern="^" + str("CG") + "$"),
-                CallbackQueryHandler(Level2, pattern="^" + str("CX_")),
-                CallbackQueryHandler(Level2, pattern="^" + str("CB_")),
-                # CallbackQueryHandler(Level2, pattern="^" + str("CG_")),
-                CallbackQueryHandler(end, pattern="^" + str("CZ") + "$"),
-                CallbackQueryHandler(start, pattern="^"),
-            ],
-            END_ROUTES: [],
-        },
-        fallbacks=[CommandHandler("start", start)],
-    )
-    application.add_handler(CommandHandler("help", help_command))
-    application.add_handler(
-        MessageHandler(filters.TEXT & ~filters.COMMAND, help_command)
-    )
-    # application.add_handler(MessageHandler(filters.TEXT & filters.COMMAND, command_handler))
-    # application.add_handler(MessageHandler(filters.COMMAND, command_handler))
-    # Add ConversationHandler to application that will be used for handling updates
-    addCommandsForMenuItems(application)
-    application.add_handler(conv_handler)
-    # ...and the error handler
-    application.add_error_handler(error_handler)
-    if bot_available:
-        # Run the intraday monitor
-        initializeIntradayTimer()
-    # Run the bot until the user presses Ctrl-C
-    application.run_polling(allowed_updates=Update.ALL_TYPES)
-
-
-if __name__ == "__main__":
-    runpkscreenerbot()
+#!/usr/bin/env python
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+# pylint: disable=unused-argument, wrong-import-position
+# This program is dedicated to the public domain under the CC0 license.
+
+"""Simple inline keyboard bot with multiple CallbackQueryHandlers.
+
+This Bot uses the Application class to handle the bot.
+First, a few callback functions are defined as callback query handler. Then, those functions are
+passed to the Application and registered at their respective places.
+Then, the bot is started and runs until we press Ctrl-C on the command line.
+Usage:
+Example of a bot that uses inline keyboard that has multiple CallbackQueryHandlers arranged in a
+ConversationHandler.
+Send /start to initiate the conversation.
+Press Ctrl-C on the command line to stop the bot.
+"""
+import os
+import html
+import json
+import logging
+import re
+import sys
+import threading
+try:
+    import thread
+except ImportError:
+    import _thread as thread
+
+import traceback
+from datetime import datetime
+from time import sleep
+from telegram import __version__ as TG_VER
+from telegram.constants import ParseMode
+
+start_time = datetime.now()
+MINUTES_2_IN_SECONDS = 120
+OWNER_USER = "Itsonlypk"
+
+from PKDevTools.classes.Telegram import get_secrets
+from PKDevTools.classes.PKDateUtilities import PKDateUtilities
+from PKDevTools.classes.ColorText import colorText
+from pkscreener.classes.MenuOptions import MenuRenderStyle, menu, menus
+from pkscreener.classes.WorkflowManager import run_workflow
+from pkscreener.globals import showSendConfigInfo, showSendHelpInfo
+import pkscreener.classes.ConfigManager as ConfigManager
+
+monitor_proc = None
+configManager = ConfigManager.tools()
+bot_available=True
+
+try:
+    from telegram import __version_info__
+except ImportError:
+    __version_info__ = (0, 0, 0, 0, 0)  # type: ignore[assignment]
+
+if __version_info__ < (20, 0, 0, "alpha", 1):
+    raise RuntimeError(
+        f"This example is not compatible with your current PTB version {TG_VER}. To view the "
+        f"{TG_VER} version of this example, "
+        f"visit https://docs.python-telegram-bot.org/en/v{TG_VER}/examples.html"
+    )
+from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
+from telegram.ext import (
+    Application,
+    CallbackQueryHandler,
+    CommandHandler,
+    ContextTypes,
+    ConversationHandler,
+    MessageHandler,
+    filters,
+    CallbackContext
+)
+
+# Enable logging
+logging.basicConfig(
+    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
+)
+# set higher logging level for httpx to avoid all GET and POST requests being logged
+logging.getLogger("httpx").setLevel(logging.WARNING)
+
+logger = logging.getLogger(__name__)
+
+# Stages
+START_ROUTES, END_ROUTES = range(2)
+# Callback data
+ONE, TWO, THREE, FOUR = range(4)
+
+m0 = menus()
+m1 = menus()
+m2 = menus()
+m3 = menus()
+int_timer = None
+
+TOP_LEVEL_SCANNER_MENUS = ["X", "B", "MI","DV"]
+TOP_LEVEL_SCANNER_SKIP_MENUS = ["M", "S", "G", "C", "P", "T", "D", "I", "E", "U", "L", "Z"]
+INDEX_SKIP_MENUS = ["W","E","M","Z","0","2","3","4","6","7","9","10","13"]
+SCANNER_SKIP_MENUS_1_TO_6 = ["0","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","42","M","Z"]
+SCANNER_SKIP_MENUS_7_TO_12 = ["0","1","2","3","4","5","6","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","42","M","Z"]
+SCANNER_SKIP_MENUS_13_TO_18 = ["0","1","2","3","4","5","6","7","8","9","10","11","12","19","20","21","22","23","24","25","26","27","28","29","30","31","32","42","M","Z"]
+SCANNER_SKIP_MENUS_19_TO_25 = ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","22","26","27","28","29","30","31","32","42","M","Z"]
+SCANNER_SKIP_MENUS_26_TO_31 = ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","32","42","M","Z"]
+SCANNER_MENUS_WITH_NO_SUBMENUS = ["1","2","3","10","11","12","13","14","15","16","17","18","19","20","21","23","24","25","26","27","28","29","30","31","32"]
+SCANNER_MENUS_WITH_SUBMENU_SUPPORT = ["6", "7", "21"]
+
+INDEX_COMMANDS_SKIP_MENUS_SCANNER = ["W", "E", "M", "Z"]
+INDEX_COMMANDS_SKIP_MENUS_BACKTEST = ["W", "E", "M", "Z", "N", "0", "15"]
+UNSUPPORTED_COMMAND_MENUS =["22","42","M","Z"]
+SUPPORTED_COMMAND_MENUS = ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32"]
+
+def initializeIntradayTimer():
+    try:
+        if (not PKDateUtilities.isTodayHoliday()[0]):
+            now = PKDateUtilities.currentDateTime()
+            marketStartTime = PKDateUtilities.currentDateTime(simulate=True,hour=9,minute=15)
+            morning745am = PKDateUtilities.currentDateTime(simulate=True,hour=7,minute=45)
+            if now < marketStartTime and now >= morning745am: # Telegram bot might keep running beyond an hour. So let's start watching around 7:45AM
+                difference = (marketStartTime - now).total_seconds() + 1
+                global int_timer
+                int_timer = threading.Timer(difference, launchIntradayMonitor, args=[])
+                int_timer.start()
+            elif now >= marketStartTime:
+                launchIntradayMonitor()
+    except:
+        launchIntradayMonitor()
+        pass
+
+async def start(update: Update, context: ContextTypes.DEFAULT_TYPE, updatedResults=None, monitorIndex=0,chosenBotMenuOption="") -> int:
+    """Send message on `/start`."""
+    global bot_available
+    updateCarrier = None
+    if update is None:
+        return
+    else:
+        if update.callback_query is not None:
+            updateCarrier = update.callback_query
+        if update.message is not None:
+            updateCarrier = update.message
+        if updateCarrier is None:
+            return
+    # Get user that sent /start and log his name
+    user = updateCarrier.from_user
+    logger.info("User %s started the conversation.", user.first_name)
+    if not bot_available:
+        updatedResults = "Apologies! The @nse_pkscreener_bot is NOT available for the time being! We are working with our host GitHub and other data source providers to sort out pending invoices and restore the services soon! Thanks for your patience and support! "
+    # Build InlineKeyboard where each button has a displayed text
+    # and a string as callback_data
+    # The keyboard is a list of button rows, where each row is in turn
+    # a list (hence `[[...]]`).
+    if bot_available:
+        mns = m0.renderForMenu(asList=True)
+        if (PKDateUtilities.isTradingTime() and not PKDateUtilities.isTodayHoliday()[0]) or ("PKDevTools_Default_Log_Level" in os.environ.keys()) or sys.argv[0].endswith(".py"):
+            mns.append(menu().create(f"MI_{monitorIndex}", "Int. Monitor", 2))
+        if user.username == OWNER_USER:
+            mns.append(menu().create(f"DV_0", ("Enbl" if not configManager.logsEnabled else "Dsbl"), 2))
+
+        inlineMenus = []
+        for mnu in mns:
+            if mnu.menuKey[0:2] in TOP_LEVEL_SCANNER_MENUS:
+                inlineMenus.append(
+                    InlineKeyboardButton(
+                        mnu.menuText.split("(")[0],
+                        callback_data="C" + str(mnu.menuKey),
+                    )
+                )
+        keyboard = [inlineMenus]
+        reply_markup = InlineKeyboardMarkup(keyboard)
+        cmds = m0.renderForMenu(
+            selectedMenu=None,
+            skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
+            asList=True,
+            renderStyle=MenuRenderStyle.STANDALONE,
+        )
+    else:
+        reply_markup = None
+
+    if updatedResults is None:
+        cmdText = ""
+        for cmd in cmds:
+            cmdText = f"{cmdText}\n\n{cmd.commandTextKey()} for {cmd.commandTextLabel()}"
+        menuText = f"Welcome {user.first_name}, {(user.username)}! Please choose a menu option by selecting a button from below.\n\nYou can also explore a wide variety of all other scanners by typing in \n{cmdText}\n\n OR just use the buttons below to choose."
+    else:
+        chosenBotMenuOption = f"{chosenBotMenuOption}\nInt. Monitor. MonitorIndex:{monitorIndex}\n{updatedResults}"
+        menuText = updatedResults
+    # Send message with text and appended InlineKeyboard
+    if update.callback_query is not None:
+        await sendUpdatedMenu(
+            menuText=menuText, update=update, context=context, reply_markup=reply_markup, replaceWhiteSpaces=(updatedResults is None)
+        )
+    elif update.message is not None:
+        await update.message.reply_text(
+            menuText,
+            reply_markup=reply_markup,
+        )
+    await context.bot.send_message(
+        chat_id=int(f"-{Channel_Id}"),
+        text=f"Name: {user.first_name}, Username:@{user.username} with ID: {str(user.id)} started using the bot!\n{chosenBotMenuOption}",
+        parse_mode=ParseMode.HTML,
+    )
+    # Tell ConversationHandler that we're in state `FIRST` now
+    return START_ROUTES
+
+def removeMonitorFile():
+    from PKDevTools.classes import Archiver
+    configManager.getConfig(ConfigManager.parser)
+    filePath = os.path.join(Archiver.get_user_outputs_dir(), "monitor_outputs")
+    index = 0
+    while index < configManager.maxDashboardWidgetsPerRow*configManager.maxNumResultRowsInMonitor:
+        try:
+            os.remove(f"{filePath}_{index}.txt")
+        except:
+            pass
+        index += 1
+
+def launchIntradayMonitor():
+    from PKDevTools.classes import Archiver
+    global int_timer
+    if int_timer is not None:
+        int_timer.cancel()
+    filePath = os.path.join(Archiver.get_user_outputs_dir(), "monitor_outputs")
+    result_outputs = ""
+    if (PKDateUtilities.isTradingTime() and not PKDateUtilities.isTodayHoliday()[0]) or ("PKDevTools_Default_Log_Level" in os.environ.keys() or sys.argv[0].endswith(".py")):
+        result_outputs = "Starting up the monitor for this hour. Please try again after 30-40 seconds."
+    else:
+        result_outputs = f"{PKDateUtilities.currentDateTime()}\nIntraday Monitor is available only during the NSE trading hours! Please try during the next trading session."
+        try:
+            removeMonitorFile()
+        except:
+            pass
+        return result_outputs, filePath
+
+    appLogsEnabled = ("PKDevTools_Default_Log_Level" in os.environ.keys() or sys.argv[0].endswith(".py"))
+    # User wants an Int. Monitor
+    launcher = "/home/runner/work/PKScreener/PKScreener/pkscreenercli.bin" if "MONITORING_BOT_RUNNER" in os.environ.keys() else "pkscreener"
+    launcher = f"python3.11 {launcher}" if launcher.endswith(".py") else launcher
+    
+    try:
+        from subprocess import Popen
+        global monitor_proc
+        if monitor_proc is None or monitor_proc.poll() is not None: # Process finished from an earlier launch
+            # Let's remove the old file(s) so that the new app can begin to run
+            # If we don't remove, it might just exit assuming that there's another instance
+            # already running.
+            removeMonitorFile()
+            appArgs = [f"{launcher}","-a","Y","-m","X","--telegram",]
+            if appLogsEnabled:
+                appArgs.append("-l")
+            else:
+                appArgs.append("-p")
+            monitor_proc = Popen(appArgs)
+            logger.info(f"{launcher} -a Y -m 'X' -p --telegram launched")
+        else:
+            result_outputs = "Monitor is running, but the results are being prepared. Try again in next few seconds."
+            logger.info(f"{launcher} -a Y -m 'X' -p --telegram already running")
+    except Exception as e:
+        result_outputs = "Hmm...It looks like you caught us taking a break! Try again later :-)"
+        logger.info(f"{launcher} -a Y -m 'X' -p --telegram could not be launched")
+        logger.info(e)
+        pass
+    return result_outputs, filePath
+
+async def XDevModeHandler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    """Show new choice of buttons"""
+    query = update.callback_query
+    data = query.data.upper().replace("CX", "X").replace("CB", "B").replace("CG", "G").replace("CMI", "MI").replace("CDV","DV")
+    if data[0:2] not in TOP_LEVEL_SCANNER_MENUS:
+        return start(update, context)
+    if data.startswith("DV"):
+        # Dev Mode
+        devModeIndex = int(data.split("_")[1])
+        if devModeIndex == 0:
+            if "PKDevTools_Default_Log_Level" in os.environ.keys():
+                del os.environ['PKDevTools_Default_Log_Level']
+                configManager.maxNumResultRowsInMonitor = 2
+                configManager.logsEnabled = False
+            else:
+                # Switch config file
+                configManager.maxNumResultRowsInMonitor = 3
+                configManager.logsEnabled = True
+                os.environ["PKDevTools_Default_Log_Level"] = str(logging.INFO)
+            configManager.setConfig(ConfigManager.parser, default=True, showFileCreatedText=False)
+            chosenBotMenuOption = configManager.showConfigFile(defaultAnswer='Y')
+            if monitor_proc is not None:
+                try:
+                    monitor_proc.kill()
+                except:
+                    pass
+            
+            launchIntradayMonitor()
+            await start(update, context,chosenBotMenuOption=chosenBotMenuOption)
+    return START_ROUTES
+
+async def XScanners(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    """Show new choice of buttons"""
+    query = update.callback_query
+    data = query.data.upper().replace("CX", "X").replace("CB", "B").replace("CG", "G").replace("CMI", "MI")
+    if data[0:2] not in TOP_LEVEL_SCANNER_MENUS:
+        return start(update, context)
+    global bot_available
+    if not bot_available:
+        await start(update, context)
+        return START_ROUTES
+    if data.startswith("MI"):
+        monitorIndex = int(data.split("_")[1])
+        result_outputs, filePath = launchIntradayMonitor()
+        filePath = f"{filePath}_{monitorIndex}.txt"
+        monitorIndex += 1
+        if monitorIndex >= configManager.maxDashboardWidgetsPerRow*configManager.maxNumResultRowsInMonitor:
+            monitorIndex = 0
+        try:
+            if os.path.exists(filePath):
+                f = open(filePath, "r")
+                result_outputs = f.read()
+                f.close()
+            await start(update, context, updatedResults=result_outputs,monitorIndex=monitorIndex)
+            return START_ROUTES
+        except Exception as e:
+            result_outputs = "Hmm...It looks like you caught us taking a break! Try again later :-)\nCycleTime shows how much it's taking us to download latest data and then perform each cycle of analysis for all configured scanners. We may be downloading the latest data right now."
+            logger.info(e)
+            logger.info(f"Could not read {filePath}")
+            await start(update, context, updatedResults=result_outputs,monitorIndex=monitorIndex)
+            return START_ROUTES
+
+    midSkip = "1" if data == "X" else "N"
+    skipMenus = [midSkip]
+    skipMenus.extend(INDEX_SKIP_MENUS)
+    menuText = (
+        m1.renderForMenu(
+            m0.find(data),
+            skip=skipMenus,
+            renderStyle=MenuRenderStyle.STANDALONE,
+        )
+        .replace("     ", "")
+        .replace("    ", "")
+        .replace("\t", "")
+        .replace(colorText.FAIL,"").replace(colorText.END,"")
+    )
+    menuText = menuText + "\n\nH > Home"
+    mns = m1.renderForMenu(
+        m0.find(data),
+        skip=skipMenus,
+        asList=True,
+    )
+    mns.append(menu().create("H", "Home", 2))
+    inlineMenus = []
+    await query.answer()
+    for mnu in mns:
+        inlineMenus.append(
+            InlineKeyboardButton(
+                mnu.menuKey, callback_data=str(f"{query.data}_{mnu.menuKey}")
+            )
+        )
+    keyboard = [inlineMenus]
+    reply_markup = InlineKeyboardMarkup(keyboard)
+    if query.message.text == menuText:
+        menuText = f"{PKDateUtilities.currentDateTime()}:\n{menuText}"
+    await query.edit_message_text(text=menuText, reply_markup=reply_markup)
+    return START_ROUTES
+
+
+async def Level2(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    """Show new choice of buttons"""
+    inlineMenus = []
+    menuText = "Hmm...It looks like you caught us taking a break! Try again later :-)"
+    mns = []
+    query = update.callback_query
+    await query.answer()
+    preSelection = (
+        query.data.upper().replace("CX", "X").replace("CB", "B").replace("CG", "G")
+    )
+    selection = preSelection.split("_")
+    preSelection = f"{selection[0]}_{selection[1]}"
+    if (selection[0].upper() not in TOP_LEVEL_SCANNER_MENUS):
+        await start(update, context)
+        return START_ROUTES
+    global bot_available
+    if not bot_available:
+        await start(update, context)
+        return START_ROUTES
+    if selection[len(selection)-1].upper() == "H":
+        await start(update, context)
+        return START_ROUTES
+    if len(selection) == 2 or (len(selection) == 3 and selection[2] == "P"):
+        if str(selection[1]).isnumeric():
+            # It's only level 2
+            menuText = m2.renderForMenu(
+                m1.find(selection[1]),
+                skip=SCANNER_SKIP_MENUS_1_TO_6,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            menuText = menuText + "\n\nN > More options"
+            menuText = menuText + "\nH > Home"
+            mns = m2.renderForMenu(
+                m1.find(selection[1]),
+                skip=SCANNER_SKIP_MENUS_1_TO_6,
+                asList=True,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            mns.append(menu().create("N", "More Options", 2))
+            mns.append(menu().create("H", "Home", 2))
+        elif selection[1] == "N":
+            selection.extend(["", ""])
+    elif len(selection) == 3:
+        if selection[2] == "N":
+            menuText = m2.renderForMenu(
+                m1.find(selection[1]),
+                skip=SCANNER_SKIP_MENUS_7_TO_12,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            menuText = menuText + "\n\nM > More Options"
+            menuText = menuText + "\nH > Home"
+            mns = m2.renderForMenu(
+                m1.find(selection[1]),
+                skip=SCANNER_SKIP_MENUS_7_TO_12,
+                asList=True,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            mns.append(menu().create("M", "More Options", 2))
+            mns.append(menu().create("H", "Home", 2))
+        elif selection[2] == "M":
+            menuText = m2.renderForMenu(
+                m1.find(selection[1]),
+                skip=SCANNER_SKIP_MENUS_13_TO_18,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            menuText = menuText + "\n\n>> More Options"
+            menuText = menuText + "\nH > Home"
+            mns = m2.renderForMenu(
+                m1.find(selection[1]),
+                skip=SCANNER_SKIP_MENUS_13_TO_18,
+                asList=True,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            mns.append(menu().create(">>", "More Options", 2))
+            mns.append(menu().create("H", "Home", 2))
+        elif selection[2] == ">>":
+            menuText = m2.renderForMenu(
+                m1.find(selection[1]),
+                skip=SCANNER_SKIP_MENUS_19_TO_25,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            menuText = menuText + "\n\nR > More Options"
+            menuText = menuText + "\nH > Home"
+            mns = m2.renderForMenu(
+                m1.find(selection[1]),
+                skip=SCANNER_SKIP_MENUS_19_TO_25,
+                asList=True,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            mns.append(menu().create("R", "More Options", 2))
+            mns.append(menu().create("H", "Home", 2))
+        elif selection[2] == "R":
+            menuText = m2.renderForMenu(
+                m1.find(selection[1]),
+                skip=SCANNER_SKIP_MENUS_26_TO_31,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            menuText = menuText + "\n\nH > Home"
+            mns = m2.renderForMenu(
+                m1.find(selection[1]),
+                skip=SCANNER_SKIP_MENUS_26_TO_31,
+                asList=True,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            mns.append(menu().create("H", "Home", 2))
+        elif str(selection[2]).isnumeric():
+            preSelection = f"{selection[0]}_{selection[1]}_{selection[2]}"
+            if selection[2] in SCANNER_MENUS_WITH_SUBMENU_SUPPORT:
+                menuText = m3.renderForMenu(
+                    m2.find(selection[2]),
+                    renderStyle=MenuRenderStyle.STANDALONE,
+                    skip=["0"],
+                )
+                mns = m3.renderForMenu(
+                    m2.find(selection[2]),
+                    asList=True,
+                    renderStyle=MenuRenderStyle.STANDALONE,
+                    skip=["0"],
+                )
+            else:
+                if selection[2] == "4":  # Last N days
+                    selection.extend(["D", ""])
+                elif selection[2] == "5":  # RSI range
+                    selection.extend(["D", "D"])
+                elif selection[2] == "8":  # CCI range
+                    selection.extend(["D", "D"])
+                elif selection[2] == "9":  # Vol gainer ratio
+                    selection.extend(["D", ""])
+                elif selection[2] in SCANNER_MENUS_WITH_NO_SUBMENUS:  # Vol gainer ratio
+                    selection.extend(["", ""])
+    elif len(selection) == 4:
+        preSelection = (
+            query.data.upper().replace("CX", "X").replace("CB", "B").replace("CG", "G")
+        )
+    optionChoices = ""
+    if len(selection) <= 3 and mns is not None:
+        for mnu in mns:
+            inlineMenus.append(
+                InlineKeyboardButton(
+                    mnu.menuKey,
+                    callback_data="C" + str(f"{preSelection}_{mnu.menuKey}"),
+                )
+            )
+        keyboard = [inlineMenus]
+        reply_markup = InlineKeyboardMarkup(keyboard)
+    elif len(selection) >= 4:
+        optionChoices = (
+            f"{selection[0]} > {selection[1]} > {selection[2]} > {selection[3]}"
+        )
+        expectedTime = f"{'10 to 15' if '> 15' in optionChoices else '1 to 2'}"
+        menuText = f"Thank you for choosing {optionChoices}. You will receive the notification/results in about {expectedTime} minutes. It generally takes 1-2 minutes for NSE (2000+) stocks and 10-15 minutes for NASDAQ (7300+).\n\nPKScreener is free and will always remain so for everyone. Consider donating to help cover the basic server costs:\n\nUPI (India): 8007162973@APL \n\nor\nhttps://github.com/sponsors/pkjmesra?frequency=one-time&sponsor=pkjmesra"
+
+        reply_markup = default_markup(inlineMenus)
+        options = ":".join(selection)
+        await launchScreener(
+            options=options,
+            user=query.from_user,
+            context=context,
+            optionChoices=optionChoices,
+            update=update,
+        )
+    try:
+        if optionChoices != "":
+            await context.bot.send_message(
+                chat_id=int(f"-{Channel_Id}"),
+                text=f"Name: <b>{query.from_user.first_name}</b>, Username:@{query.from_user.username} with ID: <b>@{str(query.from_user.id)}</b> submitted scan request <b>{optionChoices}</b> to the bot!",
+                parse_mode=ParseMode.HTML,
+            )
+    except Exception:# pragma: no cover
+        await start(update, context)
+    if not str(optionChoices.upper()).startswith("B"):
+        await sendUpdatedMenu(
+            menuText=menuText, update=update, context=context, reply_markup=reply_markup
+        )
+    return START_ROUTES
+
+def default_markup(inlineMenus):
+    mns = m0.renderForMenu(asList=True)
+    for mnu in mns:
+        if mnu.menuKey in TOP_LEVEL_SCANNER_MENUS:
+            inlineMenus.append(
+                    InlineKeyboardButton(
+                        mnu.menuText.split("(")[0],
+                        callback_data="C" + str(mnu.menuKey),
+                    )
+                )
+    keyboard = [inlineMenus]
+    reply_markup = InlineKeyboardMarkup(keyboard)
+    return reply_markup
+
+
+async def sendUpdatedMenu(menuText, update: Update, context, reply_markup, replaceWhiteSpaces=True):
+    try:
+        if update.callback_query.message.text == menuText:
+            menuText = f"{PKDateUtilities.currentDateTime()}:\n{menuText}"
+        await update.callback_query.edit_message_text(
+            text=menuText.replace("     ", "").replace("    ", "").replace("\t", "").replace(colorText.FAIL,"").replace(colorText.END,"") if replaceWhiteSpaces else menuText,
+            parse_mode="HTML",
+            reply_markup=reply_markup,
+        )
+    except Exception as e:# pragma: no cover
+        logger.log(e)
+        await start(update, context)
+
+
+async def launchScreener(options, user, context, optionChoices, update):
+    try:
+        if str(optionChoices.upper()).startswith("B"):
+            optionChoices = optionChoices.replace(" ", "").replace(">", "_").replace(":","_").replace("_D","")
+            while optionChoices.endswith("_"):
+                optionChoices = optionChoices[:-1]
+            if str(optionChoices).split("_")[2] == "6" and str(optionChoices).split("_")[3] == "7":
+                optionChoices = f"{optionChoices}_3" # Lorenzian Any/All
+            responseText = f"Thank you for choosing {optionChoices}!\n\nHere are the results:\n\nInsights: https://pkjmesra.github.io/PKScreener/Backtest-Reports/PKScreener_{optionChoices}_Insights_DateSorted.html"
+            responseText = f"{responseText}\n\nSummary: https://pkjmesra.github.io/PKScreener/Backtest-Reports/PKScreener_{optionChoices}_Summary_StockSorted.html"
+            responseText = f"{responseText}\n\nStock-wise: https://pkjmesra.github.io/PKScreener/Backtest-Reports/PKScreener_{optionChoices}_backtest_result_StockSorted.html"
+            responseText = f"{responseText}\n\nOther Reports: https://pkjmesra.github.io/PKScreener/BacktestReports.html"
+            if update is not None and update.message is not None:
+                await update.message.reply_text(responseText)
+            else:
+                await update.callback_query.edit_message_text(
+                    text=responseText,
+                    reply_markup=default_markup([]),
+                )
+            await shareUpdateWithChannel(
+                update=update, context=context, optionChoices=optionChoices
+            )
+            # run_workflow(optionChoices, str(user.id), str(options.upper()))
+        elif str(optionChoices.upper()).startswith("X"):
+            optionChoices = optionChoices.replace(" ", "").replace(">", "_")
+            while optionChoices.endswith("_"):
+                optionChoices = optionChoices[:-1]
+            run_workflow(
+                optionChoices, str(user.id), str(options.upper()), workflowType="X"
+            )
+        elif str(optionChoices.upper()).startswith("G"):
+            optionChoices = optionChoices.replace(" ", "").replace(">", "_")
+            while optionChoices.endswith("_"):
+                optionChoices = optionChoices[:-1]
+            options = options.upper().replace("G", "G:3").replace("::", ":D:D:D")
+            run_workflow(
+                optionChoices, str(user.id), str(options.upper()), workflowType="G"
+            )
+            # Popen(
+            #     [
+            #         "pkscreener",
+            #         "-a",
+            #         "Y",
+            #         "-e",
+            #         "-p",
+            #         "-o",
+            #         str(options.upper()),
+            #         "-u",
+            #         str(user.id),
+            #     ]
+            # )
+    except Exception as e:
+        import traceback
+        traceback.print_exc()
+        print(e)
+        await start(update, context)
+
+
+async def BBacktests(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    """Show new choice of buttons"""
+    query = update.callback_query
+    await query.answer()
+    keyboard = [
+        [
+            InlineKeyboardButton("Try Scanners", callback_data=str("CX")),
+            # InlineKeyboardButton("Growth of 10k", callback_data=str("CG")),
+        ]
+    ]
+    reply_markup = InlineKeyboardMarkup(keyboard)
+    await query.edit_message_text(
+        text="Backtesting NOT implemented yet in this Bot!\n\n\nYou can use backtesting by downloading the software from https://github.com/pkjmesra/PKScreener/",
+        reply_markup=reply_markup,
+    )
+    return START_ROUTES
+
+
+async def end(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
+    """Returns `ConversationHandler.END`, which tells the
+    ConversationHandler that the conversation is over.
+    """
+    query = update.callback_query
+    await query.answer()
+    await query.edit_message_text(
+        text="See https://github.com/pkjmesra/PKScreener/ for more details or join https://t.me/PKScreener. \n\n\nSee you next time!"
+    )
+    return ConversationHandler.END
+
+
+# This can be your own ID, or one for a developer group/channel.
+# You can use the /start command of this bot to see your chat id.
+chat_idADMIN = 123456789
+Channel_Id = 12345678
+GROUP_CHAT_ID = 1001907892864
+
+
+async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
+    """Log the error and send a telegram message to notify the developer."""
+    # Log the error before we do anything else, so we can see it even if something breaks.
+    logger.error("Exception while handling an update:", exc_info=context.error)
+
+    # traceback.format_exception returns the usual python message about an exception, but as a
+    # list of strings rather than a single string, so we have to join them together.
+    tb_list = traceback.format_exception(
+        None, context.error, context.error.__traceback__
+    )
+    tb_string = "".join(tb_list)
+    global start_time
+    timeSinceStarted = datetime.now() - start_time
+    if (
+        "telegram.error.Conflict" in tb_string
+    ):  # A newer 2nd instance was registered. We should politely shutdown.
+        if (
+            timeSinceStarted.total_seconds() >= MINUTES_2_IN_SECONDS
+        ):  # shutdown only if we have been running for over 5 minutes
+            print(
+                f"Stopping due to conflict after running for {timeSinceStarted.total_seconds()/60} minutes."
+            )
+            try:
+                global int_timer
+                if int_timer is not None:
+                    int_timer.cancel()
+            except:
+                pass
+            try:
+                context.application.stop()
+                sys.exit(0)
+            except RuntimeError:
+                context.application.shutdown()
+            sys.exit(0)
+        else:
+            print("Other instance running!")
+            # context.application.run_polling(allowed_updates=Update.ALL_TYPES)
+    # Build the message with some markup and additional information about what happened.
+    # You might need to add some logic to deal with messages longer than the 4096 character limit.
+    update_str = update.to_dict() if isinstance(update, Update) else str(update)
+    message = (
+        f"An exception was raised while handling an update\n"
+        f"<pre>update = {html.escape(json.dumps(update_str, indent=2, ensure_ascii=False))}"
+        "</pre>\n\n"
+        f"<pre>context.chat_data = {html.escape(str(context.chat_data))}</pre>\n\n"
+        f"<pre>context.user_data = {html.escape(str(context.user_data))}</pre>\n\n"
+        f"<pre>{html.escape(tb_string)}</pre>"
+    )
+
+    try:
+        # Finally, send the message
+        if "telegram.error.Conflict" not in message:
+            await context.bot.send_message(
+                chat_id=int(f"-{Channel_Id}"), text=message, parse_mode=ParseMode.HTML
+            )
+    except Exception:# pragma: no cover
+        try:
+            if "telegram.error.Conflict" not in tb_string:
+                await context.bot.send_message(
+                    chat_id=int(f"-{Channel_Id}"),
+                    text=tb_string,
+                    parse_mode=ParseMode.HTML,
+                )
+        except Exception:# pragma: no cover
+            print(tb_string)
+
+
+async def command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
+    if _shouldAvoidResponse(update):
+        return
+    msg = update.effective_message
+    m = re.match("\s*/([0-9a-zA-Z_-]+)\s*(.*)", msg.text)
+    cmd = m.group(1).lower()
+    args = [arg for arg in re.split("\s+", m.group(2)) if len(arg)]
+    if cmd.startswith("cx_") or cmd.startswith("cb_") or cmd.startswith("cg_"):
+        await Level2(update=update, context=context)
+        return START_ROUTES
+    if cmd.startswith("cx") or cmd.startswith("cb") or cmd.startswith("cg"):
+        await XScanners(update=update, context=context)
+        return START_ROUTES
+    if cmd.startswith("cz"):
+        await end(update=update, context=context)
+        return END_ROUTES
+
+    if cmd == "start":
+        await start(update=update, context=context)
+        return START_ROUTES
+    if cmd == "help":
+        await help_command(update=update, context=context)
+        return START_ROUTES
+    if cmd.upper() in TOP_LEVEL_SCANNER_MENUS:
+        await shareUpdateWithChannel(update=update, context=context)
+        m0.renderForMenu(
+            selectedMenu=None,
+            skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
+            renderStyle=MenuRenderStyle.STANDALONE,
+        )
+        selectedMenu = m0.find(cmd.upper())
+        cmdText = ""
+        cmds = m1.renderForMenu(
+            selectedMenu=selectedMenu,
+            skip=(INDEX_COMMANDS_SKIP_MENUS_SCANNER  if cmd in ["x"] else INDEX_COMMANDS_SKIP_MENUS_BACKTEST),
+            asList=True,
+            renderStyle=MenuRenderStyle.STANDALONE,
+        )
+        for cmd in cmds:
+            if cmd in ["N", "0"]:
+                continue
+            cmdText = (
+                f"{cmdText}\n\n{cmd.commandTextKey()} for {cmd.commandTextLabel()}"
+            )
+        if cmd in ["x"]:
+            cmdText = f"{cmdText}\n\nFor option 0 <Screen stocks by the stock name>, please type in the command in the following format\n/X_0 SBIN\n or \n/X_0_0 SBIN\nand hit send where SBIN is the NSE stock code.For multiple stocks, you can type in \n/X_0 SBIN,ICICIBANK,OtherStocks\nYou can put in any number of stocks separated by space or comma(,)."
+        """Send a message when the command /help is issued."""
+        await update.message.reply_text(f"Choose an option:\n{cmdText}")
+        return START_ROUTES
+
+    if update.message is None:
+        await help_command(update=update, context=context)
+        return START_ROUTES
+    if "x_0" in cmd or "x_0_0" in cmd or "b_0" in cmd or "g_0" in cmd:
+        await shareUpdateWithChannel(update=update, context=context)
+        shouldScan = False
+        if len(args) > 0:
+            shouldScan = True
+            selection = [
+                cmd.split("_")[0].upper(),
+                "0",
+                "0",
+                f"{','.join(args)}".replace(" ", ""),
+            ]
+        if shouldScan:
+            options = ":".join(selection)
+            await launchScreener(
+                options=options,
+                user=update.message.from_user,
+                context=context,
+                optionChoices=cmd.upper(),
+                update=update,
+            )
+            await sendRequestSubmitted(cmd.upper(), update=update, context=context)
+            return START_ROUTES
+        else:
+            if cmd in ["x"]:
+                cmdText = "For option 0 <Screen stocks by the stock name>, please type in the command in the following format\n/X_0 SBIN or /X_0_0 SBIN and hit send where SBIN is the NSE stock code.For multiple stocks, you can type in /X_0 SBIN,ICICIBANK,OtherStocks . You can put in any number of stocks separated by space or comma(,)."
+            """Send a message when the command /help is issued."""
+            await update.message.reply_text(f"Choose an option:\n{cmdText}")
+            return START_ROUTES
+
+    if "x_" in cmd or "b_" in cmd or "g_" in cmd:
+        await shareUpdateWithChannel(update=update, context=context)
+        selection = cmd.split("_")
+        if len(selection) == 2:
+            m0.renderForMenu(
+                selectedMenu=None,
+                skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            selectedMenu = m0.find(selection[0].upper())
+            m1.renderForMenu(
+                selectedMenu=selectedMenu,
+                skip=(
+                    INDEX_COMMANDS_SKIP_MENUS_SCANNER
+                    if "x_" in cmd
+                    else INDEX_COMMANDS_SKIP_MENUS_BACKTEST
+                ),
+                asList=True,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            selectedMenu = m1.find(selection[1].upper())
+            if "x_" in cmd and selectedMenu.menuKey == "N":  # Nifty prediction
+                options = ":".join(selection)
+                await launchScreener(
+                    options=options,
+                    user=update.message.from_user,
+                    context=context,
+                    optionChoices=cmd.upper(),
+                    update=update,
+                )
+                await sendRequestSubmitted(cmd.upper(), update=update, context=context)
+                return START_ROUTES
+            elif (
+                "x_" in cmd and selectedMenu.menuKey == "0"
+            ):  # a specific stock by name
+                cmdText = "For option 0 <Screen stocks by the stock name>, please type in the command in the following format\n/X_0 SBIN or /X_0_0 SBIN and hit send where SBIN is the NSE stock code.For multiple stocks, you can type in /X_0 SBIN,ICICIBANK,OtherStocks. You can put in any number of stocks separated by space or comma(,)."
+                """Send a message when the command /help is issued."""
+                await update.message.reply_text(f"Choose an option:\n{cmdText}")
+                return START_ROUTES
+            cmds = m2.renderForMenu(
+                selectedMenu=selectedMenu,
+                skip=UNSUPPORTED_COMMAND_MENUS,
+                asList=True,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            cmdText = ""
+            for cmd in cmds:
+                cmdText = (
+                    f"{cmdText}\n\n{cmd.commandTextKey()} for {cmd.commandTextLabel()}"
+                )
+            await update.message.reply_text(f"Choose an option:\n{cmdText}")
+            return START_ROUTES
+        elif len(selection) == 3:
+            m0.renderForMenu(
+                selectedMenu=None,
+                skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            selectedMenu = m0.find(selection[0].upper())
+            m1.renderForMenu(
+                selectedMenu=selectedMenu,
+                skip=(
+                    INDEX_COMMANDS_SKIP_MENUS_SCANNER
+                    if "x_" in cmd
+                    else INDEX_COMMANDS_SKIP_MENUS_BACKTEST
+                ),
+                asList=True,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            selectedMenu = m1.find(selection[1].upper())
+            m2.renderForMenu(
+                selectedMenu=selectedMenu,
+                skip=UNSUPPORTED_COMMAND_MENUS,
+                asList=True,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            if selection[2] in SCANNER_MENUS_WITH_SUBMENU_SUPPORT:
+                selectedMenu = m2.find(selection[2].upper())
+                cmds = m3.renderForMenu(
+                    selectedMenu=selectedMenu,
+                    asList=True,
+                    renderStyle=MenuRenderStyle.STANDALONE,
+                    skip=["0"],
+                )
+                cmdText = ""
+                for cmd in cmds:
+                    cmdText = f"{cmdText}\n\n{cmd.commandTextKey()} for {cmd.commandTextLabel()}"
+                await update.message.reply_text(f"Choose an option:\n{cmdText}")
+                return START_ROUTES
+            else:
+                if selection[2] == "4":  # Last N days
+                    selection.extend(["D", ""])
+                elif selection[2] == "5":  # RSI range
+                    selection.extend(["D", "D"])
+                elif selection[2] == "8":  # CCI range
+                    selection.extend(["D", "D"])
+                elif selection[2] == "9":  # Vol gainer ratio
+                    selection.extend(["D", ""])
+                elif selection[2] in SUPPORTED_COMMAND_MENUS:
+                    selection.extend(["", ""])
+        if len(selection) >= 4:
+            options = ":".join(selection)
+            await launchScreener(
+                options=options,
+                user=update.message.from_user,
+                context=context,
+                optionChoices=cmd.upper(),
+                update=update,
+            )
+            await sendRequestSubmitted(cmd.upper(), update=update, context=context)
+            return START_ROUTES
+    if cmd == "y" or cmd == "h":
+        await shareUpdateWithChannel(update=update, context=context)
+        if cmd == "y":
+            showSendConfigInfo(defaultAnswer='Y',user=str(update.message.from_user.id))
+        elif cmd == "h":
+            showSendHelpInfo(defaultAnswer='Y',user=str(update.message.from_user.id))
+        # await launchScreener(
+        #     options=f"{cmd.upper()}:",
+        #     user=update.message.from_user,
+        #     context=context,
+        #     optionChoices=cmd.upper(),
+        #     update=update,
+        # )
+        # await sendRequestSubmitted(cmd.upper(), update=update, context=context)
+        return START_ROUTES
+    await update.message.reply_text(f"{cmd.upper()} : Not implemented yet!")
+    await help_command(update=update, context=context)
+
+
+async def sendRequestSubmitted(optionChoices, update, context):
+    menuText = f"Thank you for choosing {optionChoices}. You will receive the notification/results in about 5 minutes! \n\nConsider donating to help keep this project going:\nUPI: 8007162973@APL \nor\nhttps://github.com/sponsors/pkjmesra?frequency=one-time&sponsor=pkjmesra"
+    await update.message.reply_text(menuText)
+    await help_command(update=update, context=context)
+    await shareUpdateWithChannel(
+        update=update, context=context, optionChoices=optionChoices
+    )
+
+
+async def shareUpdateWithChannel(update, context, optionChoices=""):
+    query = update.message or update.callback_query
+    message = f"Name: <b>{query.from_user.first_name}</b>, Username:@{query.from_user.username} with ID: <b>@{str(query.from_user.id)}</b> began using ({optionChoices}) the bot!"
+    await context.bot.send_message(
+        chat_id=int(f"-{Channel_Id}"), text=message, parse_mode=ParseMode.HTML
+    )
+
+
+async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
+    if _shouldAvoidResponse(update):
+        return
+    global bot_available
+    if not bot_available:
+        await start(update, context)
+        return START_ROUTES
+    cmds = m0.renderForMenu(
+        selectedMenu=None,
+        skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
+        asList=True,
+        renderStyle=MenuRenderStyle.STANDALONE,
+    )
+    cmdText = ""
+    for cmd in cmds:
+        cmdText = f"{cmdText}\n\n{cmd.commandTextKey()} for {cmd.commandTextLabel()}"
+    reply_markup = default_markup([])
+    
+    """Send a message when the command /help is issued."""
+    if update is not None and update.message is not None:
+        await update.message.reply_text(
+            f"You can begin by typing in /start and hit send!\n\nOR\n\nChoose an option:\n{cmdText}",
+            reply_markup=reply_markup
+        )  #  \n\nThis bot restarts every hour starting at 5:30am IST until 10:30pm IST to keep it running on free servers. If it does not respond, please try again in a minutes to avoid the restart duration!
+        query = update.message
+        message = f"Name: <b>{query.from_user.first_name}</b>, Username:@{query.from_user.username} with ID: <b>@{str(query.from_user.id)}</b> began using the bot!"
+        await context.bot.send_message(
+            chat_id=int(f"-{Channel_Id}"), text=message, parse_mode=ParseMode.HTML
+        )
+
+
+def _shouldAvoidResponse(update):
+    sentFrom = []
+    if update.callback_query is not None:
+        sentFrom.append(abs(update.callback_query.from_user.id))
+    if update.message is not None and update.message.from_user is not None:
+        sentFrom.append(abs(update.message.from_user.id))
+        if update.message.from_user.username is not None:
+            sentFrom.append(update.message.from_user.username)
+    if update.channel_post is not None:
+        if update.channel_post.chat is not None:
+            sentFrom.append(abs(update.channel_post.chat.id))
+            if update.channel_post.chat.username is not None:
+                sentFrom.append(update.channel_post.chat.username)
+        if update.channel_post.sender_chat is not None:
+            sentFrom.append(abs(update.channel_post.sender_chat.id))
+            sentFrom.append(update.channel_post.sender_chat.username)
+    if update.edited_channel_post is not None:
+        sentFrom.append(abs(update.edited_channel_post.sender_chat.id))
+
+    if (
+        abs(int(Channel_Id)) in sentFrom
+        or abs(int(GROUP_CHAT_ID)) in sentFrom
+        or "GroupAnonymousBot" in sentFrom
+        or "PKScreener" in sentFrom
+        or "PKScreeners" in sentFrom
+    ):
+        # We want to avoid sending any help message back to channel
+        # or group in response to our own messages
+        return True
+    return False
+
+
+def addCommandsForMenuItems(application):
+    cmds0 = m0.renderForMenu(
+        selectedMenu=None,
+        skip=TOP_LEVEL_SCANNER_SKIP_MENUS,
+        asList=True,
+        renderStyle=MenuRenderStyle.STANDALONE,
+    )
+    for mnu0 in cmds0:
+        p0 = mnu0.menuKey.upper()
+        application.add_handler(CommandHandler(p0, command_handler))
+        selectedMenu = m0.find(p0)
+        cmds1 = m1.renderForMenu(
+            selectedMenu=selectedMenu,
+            skip=(
+                INDEX_COMMANDS_SKIP_MENUS_SCANNER if p0 == "X" else INDEX_COMMANDS_SKIP_MENUS_BACKTEST
+            ),
+            asList=True,
+            renderStyle=MenuRenderStyle.STANDALONE,
+        )
+        for mnu1 in cmds1:
+            p1 = mnu1.menuKey.upper()
+            if p1 in ["N", "0"]:
+                if p1 in ["N"]:
+                    application.add_handler(
+                        CommandHandler(f"{p0}_{p1}", command_handler)
+                    )
+                continue
+            application.add_handler(CommandHandler(f"{p0}_{p1}", command_handler))
+            selectedMenu = m1.find(p1)
+            cmds2 = m2.renderForMenu(
+                selectedMenu=selectedMenu,
+                skip=UNSUPPORTED_COMMAND_MENUS,
+                asList=True,
+                renderStyle=MenuRenderStyle.STANDALONE,
+            )
+            for mnu2 in cmds2:
+                p2 = mnu2.menuKey.upper()
+                application.add_handler(
+                    CommandHandler(f"{p0}_{p1}_{p2}", command_handler)
+                )
+                if p2 in SCANNER_MENUS_WITH_SUBMENU_SUPPORT:
+                    selectedMenu = m2.find(p2)
+                    cmds3 = m3.renderForMenu(
+                        selectedMenu=selectedMenu,
+                        asList=True,
+                        renderStyle=MenuRenderStyle.STANDALONE,
+                        skip=["0"],
+                    )
+                    for mnu3 in cmds3:
+                        p3 = mnu3.menuKey.upper()
+                        application.add_handler(
+                            CommandHandler(f"{p0}_{p1}_{p2}_{p3}", command_handler)
+                        )
+
+# def send_stuff(context: CallbackContext):
+#   job = context.job
+
+#   keyboard = [ 
+#     [   
+#         InlineKeyboardButton("NEVER", callback_data="NEVER"),
+#         InlineKeyboardButton("UNLIKELY", callback_data="UNLIKELY")
+#     ],  
+#     [   
+#         InlineKeyboardButton("MEH", callback_data="MEH"),
+#         InlineKeyboardButton("MAYBE", callback_data="MAYBE")
+#     ],  
+#     [   
+#         InlineKeyboardButton("YES", callback_data="YES"),
+#         InlineKeyboardButton("ABSOLUTELY", callback_data="ABSOLUTELY")
+#     ],  
+#     [   
+#         InlineKeyboardButton("RATHER NOT SAY", callback_data="UNKNOWN")
+#     ]   
+#   ]
+
+#   reply_markup = InlineKeyboardMarkup(keyboard)
+
+#   context.bot.send_photo(job.context, photo=open(PATH+thefile, 'rb'))
+#   # return values of send_message are saved in the 'msg' var
+#   msg = context.bot.send_message(job.context, text='RATE', reply_markup=reply_markup)
+
+#   # the following job is created every time the send_stuff function is called
+#   context.job_queue.run_once(
+#     callback=cleanup,
+#     when=5,
+#     context=msg,
+#     name='cleanup'
+#   )
+
+# # the function called by the job
+# def cleanup(context: CallbackContext):
+#   job = context.job
+
+#   context.bot.edit_message_text(
+#     chat_id=job.context.chat.id,
+#     text='NO ANSWER PROVIDED',
+#     message_id=job.context.message_id
+#   )
+
+
+def runpkscreenerbot(availability=True) -> None:
+    """Run the bot."""
+    # Create the Application and pass it your bot's token.
+    global chat_idADMIN, Channel_Id, bot_available
+    bot_available = availability
+    Channel_Id, TOKEN, chat_idADMIN, GITHUB_TOKEN = get_secrets()
+    # TOKEN = '1234567'
+    # Channel_Id = 1001785195297
+    application = Application.builder().token(TOKEN).build()
+    # Setup conversation handler with the states FIRST and SECOND
+    # Use the pattern parameter to pass CallbackQueries with specific
+    # data pattern to the corresponding handlers.
+    # ^ means "start of line/string"
+    # $ means "end of line/string"
+    # So ^ABC$ will only allow 'ABC'
+    conv_handler = ConversationHandler(
+        entry_points=[CommandHandler("start", start)],
+        states={
+            START_ROUTES: [
+                CallbackQueryHandler(XScanners, pattern="^" + str("CX") + "$"),
+                CallbackQueryHandler(XScanners, pattern="^" + str("CB") + "$"),
+                CallbackQueryHandler(XScanners, pattern="^" + str("CMI_")),
+                CallbackQueryHandler(XDevModeHandler, pattern="^" + str("CDV_")),
+                # CallbackQueryHandler(XScanners, pattern="^" + str("CG") + "$"),
+                CallbackQueryHandler(Level2, pattern="^" + str("CX_")),
+                CallbackQueryHandler(Level2, pattern="^" + str("CB_")),
+                # CallbackQueryHandler(Level2, pattern="^" + str("CG_")),
+                CallbackQueryHandler(end, pattern="^" + str("CZ") + "$"),
+                CallbackQueryHandler(start, pattern="^"),
+            ],
+            END_ROUTES: [],
+        },
+        fallbacks=[CommandHandler("start", start)],
+    )
+    application.add_handler(CommandHandler("help", help_command))
+    application.add_handler(
+        MessageHandler(filters.TEXT & ~filters.COMMAND, help_command)
+    )
+    # application.add_handler(MessageHandler(filters.TEXT & filters.COMMAND, command_handler))
+    # application.add_handler(MessageHandler(filters.COMMAND, command_handler))
+    # Add ConversationHandler to application that will be used for handling updates
+    addCommandsForMenuItems(application)
+    application.add_handler(conv_handler)
+    # ...and the error handler
+    application.add_error_handler(error_handler)
+    if bot_available:
+        # Run the intraday monitor
+        initializeIntradayTimer()
+    # Run the bot until the user presses Ctrl-C
+    application.run_polling(allowed_updates=Update.ALL_TYPES)
+
+
+if __name__ == "__main__":
+    runpkscreenerbot()
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreenercli.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreenercli.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,813 +1,813 @@
-#!/usr/bin/python3
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-# Pyinstaller compile Windows: pyinstaller --onefile --icon=screenshots\icon.ico pkscreener\pkscreenercli.py  --hidden-import cmath --hidden-import talib.stream --hidden-import numpy --hidden-import pandas --hidden-import alive-progress
-# Pyinstaller compile Linux  : pyinstaller --onefile --icon=screenshots/icon.ico pkscreener/pkscreenercli.py  --hidden-import cmath --hidden-import talib.stream --hidden-import numpy --hidden-import pandas --hidden-import alive-progress
-import warnings
-warnings.simplefilter("ignore", UserWarning,append=True)
-import argparse
-import builtins
-import logging
-import json
-import traceback
-import datetime
-# Keep module imports prior to classes
-import os
-import sys
-import tempfile
-os.environ["PYTHONWARNINGS"]="ignore::UserWarning"
-import multiprocessing
-
-sys.path.append(os.path.dirname(os.path.abspath(__file__)))
-
-try:
-    logging.getLogger("tensorflow").setLevel(logging.ERROR)
-except Exception:# pragma: no cover
-    pass
-
-from time import sleep
-import time
-
-from PKDevTools.classes import log as log
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.log import default_logger
-from PKDevTools.classes.PKDateUtilities import PKDateUtilities
-from pkscreener import Imports
-from PKDevTools.classes.OutputControls import OutputControls
-from pkscreener.classes.MarketMonitor import MarketMonitor
-import pkscreener.classes.ConfigManager as ConfigManager
-
-if __name__ == '__main__':
-    multiprocessing.freeze_support()
-os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
-os.environ["AUTOGRAPH_VERBOSITY"] = "0"
-
-printenabled=False
-originalStdOut=None
-original__stdout=None
-cron_runs=0
-
-def decorator(func):
-    def new_func(*args, **kwargs):
-        if printenabled:
-            try:
-                func(*args,**kwargs)
-            except Exception as e:# pragma: no cover
-                default_logger().debug(e, exc_info=True)
-                pass
-
-    return new_func
-
-
-# print = decorator(print) # current file
-def disableSysOut(input=True, disable=True):
-    global printenabled
-    printenabled = not disable
-    if disable:
-        global originalStdOut, original__stdout
-        if originalStdOut is None:
-            builtins.print = decorator(builtins.print)  # all files
-            if input:
-                builtins.input = decorator(builtins.input)  # all files
-            originalStdOut = sys.stdout
-            original__stdout = sys.__stdout__
-        sys.stdout = open(os.devnull, "w")
-        sys.__stdout__ = open(os.devnull, "w")
-    else:
-        try:
-            sys.stdout.close()
-            sys.__stdout__.close()
-        except Exception as e:# pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            pass
-        sys.stdout = originalStdOut
-        sys.__stdout__ = original__stdout
-
-# Argument Parsing for test purpose
-argParser = argparse.ArgumentParser()
-argParser.add_argument(
-    "-a",
-    "--answerdefault",
-    help="Pass default answer to questions/choices in the application. Example Y, N",
-    required=False,
-)
-argParser.add_argument(
-    "--backtestdaysago",
-    help="Run scanner for -b days ago from today.",
-    required=False,
-)
-argParser.add_argument(
-    "--barometer",
-    action="store_true",
-    help="Send global market barometer to telegram channel or a user",
-    required=False,
-)
-argParser.add_argument(
-    "--bot",
-    action="store_true",
-    help="Run only in telegram bot mode",
-    required=False,
-)
-argParser.add_argument(
-    "--botavailable",
-    action="store_true",
-    help="Enforce whether bot is going to be available or not.",
-    required=False,
-)
-argParser.add_argument(
-    "-c",
-    "--croninterval",
-    help="Pass interval in seconds to wait before the program is run again with same parameters",
-    required=False,
-)
-argParser.add_argument(
-    "-d",
-    "--download",
-    action="store_true",
-    help="Only download Stock data in .pkl file (No analysis will be run)",
-    required=False,
-)
-argParser.add_argument(
-    "-e",
-    "--exit",
-    action="store_true",
-    help="Exit right after executing just once",
-    required=False,
-)
-argParser.add_argument(
-    "--forceBacktestsForZeroResultDays",
-    help="Force run the backtests even for those days when we already have zero results saved in the repo",
-    action=argparse.BooleanOptionalAction,
-)
-argParser.add_argument(
-    "-i",
-    "--intraday",
-    help="Use Intraday configurations and use the candlestick duration that is passed. Acceptable values 1m, 5m, 10m, 15m, 1h etc.",
-    required=False,
-)
-argParser.add_argument(
-    "-m",
-    "--monitor",
-    help="Monitor for intraday scanners and their results.",
-    nargs='?',
-    const='X',
-    type=str,
-    required=False,
-)
-argParser.add_argument(
-    "--maxdisplayresults",
-    help="Maximum number of results to display.",
-    required=False,
-)
-argParser.add_argument(
-    "--maxprice",
-    help="Maximum Price for the stock to be considered.",
-    required=False,
-)
-argParser.add_argument(
-    "--minprice",
-    help="Minimum Price for the stock to be considered.",
-    required=False,
-)
-argParser.add_argument(
-    "-o",
-    "--options",
-    help="Pass selected options in the <MainMenu>:<SubMenu>:<SubMenu>:etc. format. For example: ./pkscreenercli.py -a Y -o X:12:10 -e will run the screener with answer Y as default choice to questions and scan with menu choices: Scanners > Nifty (All Stocks) > Closing at least 2%% up since last 3 day",
-    required=False,
-)
-argParser.add_argument(
-    "-p",
-    "--prodbuild",
-    action="store_true",
-    help="Run in production-build mode",
-    required=False,
-)
-argParser.add_argument(
-    "--runintradayanalysis",
-    action="store_true",
-    help="Run analysis for morning vs EoD LTP values",
-    required=False,
-)
-argParser.add_argument(
-    "--simulate",
-    type=json.loads, # '{"isTrading":true,"currentDateTime":"2024-04-29 09:35:38"}'
-    help="Simulate various conditions",
-    required=False,
-)
-argParser.add_argument(
-    "--singlethread",
-    action="store_true",
-    help="Run analysis for debugging purposes in a single process, single threaded environment",
-    required=False,
-)
-argParser.add_argument(
-    "--systemlaunched",
-    action="store_true",
-    help="Indicator to show that this is a system launched screener, using os.system",
-    required=False,
-)
-argParser.add_argument(
-    "-t",
-    "--testbuild",
-    action="store_true",
-    help="Run in test-build mode",
-    required=False,
-)
-argParser.add_argument(
-    "--telegram",
-    action="store_true",
-    help="Run with an assumption that this instance is launched via telegram bot",
-    required=False,
-)
-argParser.add_argument(
-    "-u",
-    "--user",
-    help="Telegram user ID to whom the results must be sent.",
-    required=False,
-)
-argParser.add_argument(
-    "-l",
-    "--log",
-    action="store_true",
-    help="Run with full logging enabled",
-    required=False,
-)
-argParser.add_argument("-v", action="store_true")  # Dummy Arg for pytest -v
-argParser.add_argument(
-    "--pipedtitle",
-    help="Piped Titles",
-    required=False,
-)
-argParser.add_argument(
-    "--pipedmenus",
-    help="Piped Menus",
-    required=False,
-)
-argsv = argParser.parse_known_args()
-args = argsv[0]
-# if sys.argv[0].endswith(".py"):
-#     args.monitor = 'X'
-#     args.answerdefault = 'Y'
-results = None
-resultStocks = None
-plainResults = None
-start_time = None
-dbTimestamp = None
-elapsed_time = None
-configManager = ConfigManager.tools()
-
-def exitGracefully():
-    from PKDevTools.classes import Archiver
-    from pkscreener.globals import resetConfigToDefault
-    filePath = os.path.join(Archiver.get_user_outputs_dir(), "monitor_outputs")
-    index = 0
-    while index < configManager.maxDashboardWidgetsPerRow*configManager.maxNumResultRowsInMonitor:
-        try:
-            os.remove(f"{filePath}_{index}.txt")
-        except:
-            pass
-        index += 1
-
-    argsv = argParser.parse_known_args()
-    args = argsv[0]
-    if args is not None and args.options is not None and not args.options.upper().startswith("T"):
-        resetConfigToDefault()
-        
-    if "PKDevTools_Default_Log_Level" in os.environ.keys():
-        if args is None or (args is not None and args.options is not None and "|" not in args.options):
-            del os.environ['PKDevTools_Default_Log_Level']
-    configManager.logsEnabled = False
-    configManager.setConfig(ConfigManager.parser,default=True,showFileCreatedText=False)
-
-def logFilePath():
-    try:
-        from PKDevTools.classes import Archiver
-
-        filePath = os.path.join(Archiver.get_user_outputs_dir(), "pkscreener-logs.txt")
-        f = open(filePath, "w")
-        f.write("Logger file for pkscreener!")
-        f.close()
-    except Exception:# pragma: no cover
-        filePath = os.path.join(tempfile.gettempdir(), "pkscreener-logs.txt")
-    return filePath
-
-
-def setupLogger(shouldLog=False, trace=False):
-    if not shouldLog:
-        del os.environ['PKDevTools_Default_Log_Level']
-        return
-    log_file_path = logFilePath()
-
-    if os.path.exists(log_file_path):
-        try:
-            os.remove(log_file_path)
-        except Exception:# pragma: no cover
-            pass
-    OutputControls().printOutput(colorText.FAIL + "\n[+] Logs will be written to:"+colorText.END)
-    OutputControls().printOutput(colorText.GREEN + f"[+] {log_file_path}"+colorText.END)
-    OutputControls().printOutput(colorText.FAIL + "[+] If you need to share, open this folder, copy and zip the log file to share.\n" + colorText.END)
-    # logger = multiprocessing.log_to_stderr(log.logging.DEBUG)
-    log.setup_custom_logger(
-        "pkscreener",
-        log.logging.DEBUG,
-        trace=trace,
-        log_file_path=log_file_path,
-        filter=None,
-    )
-    os.environ["PKDevTools_Default_Log_Level"] = str(log.logging.DEBUG)
-
-def warnAboutDependencies():
-    if not Imports["talib"]:
-        OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] TA-Lib is not installed. Looking for pandas_ta."
-                + colorText.END
-            )
-        sleep(1)
-        if Imports["pandas_ta"]:
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.GREEN
-                + "[+] Found and falling back on pandas_ta.\n[+] For full coverage(candle patterns), you may wish to read the README file in PKScreener repo : https://github.com/pkjmesra/PKScreener \n[+] or follow instructions from\n[+] https://github.com/ta-lib/ta-lib-python"
-                + colorText.END
-            )
-            sleep(1)
-        else:
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] Neither ta-lib nor pandas_ta was located. You need at least one of them to continue! \n[+] Please follow instructions from README file under PKScreener repo: https://github.com/pkjmesra/PKScreener"
-                + colorText.END
-            )
-            input("Press any key to try anyway...")
-    
-def runApplication():
-    from pkscreener.globals import main, sendQuickScanResult,sendMessageToTelegramChannel, sendGlobalMarketBarometer, updateMenuChoiceHierarchy, isInterrupted, refreshStockData, closeWorkersAndExit
-    # From a previous call to main with args, it may have been mutated.
-    # Let's stock to the original args passed by user
-    try:
-        savedPipedArgs = None
-        savedPipedArgs = args.pipedmenus if args is not None and args.pipedmenus is not None else None
-    except:
-        pass
-    argsv = argParser.parse_known_args()
-    args = argsv[0]
-    if args.systemlaunched:
-        args.systemlaunched = args.options
-    
-    # if sys.argv[0].endswith(".py"):
-    #     args.monitor = 'X'
-    #     args.answerdefault = 'Y'
-    args.pipedmenus = savedPipedArgs
-    if args.options is not None:
-        args.options = args.options.replace("::",":")
-    if args.runintradayanalysis:
-        from pkscreener.classes.MenuOptions import menus
-        runOptions = menus.allMenus(topLevel="C", index=12)
-        optionalFinalOutcome_df = None
-        import pkscreener.classes.Utility as Utility
-        import pandas as pd
-        # Delete any existing data from the previous run.
-        configManager.deleteFileWithPattern(pattern="stock_data_*.pkl")
-        for runOption in runOptions:
-            args.options = runOption
-            try:
-                optionalFinalOutcome_df,_ = main(userArgs=args,optionalFinalOutcome_df=optionalFinalOutcome_df)
-                if "EoDDiff" not in optionalFinalOutcome_df.columns:
-                    # Somehow the file must have been corrupted. Let's re-download
-                    configManager.deleteFileWithPattern(pattern="stock_data_*.pkl")
-                    configManager.deleteFileWithPattern(pattern="intraday_stock_data_*.pkl")
-                if isInterrupted():
-                    break
-            except Exception as e:
-                OutputControls().printOutput(e)
-                if args.log:
-                    traceback.print_exc()
-        if optionalFinalOutcome_df is not None:
-            final_df = None
-            optionalFinalOutcome_df.drop('FairValue', axis=1, inplace=True, errors="ignore")
-            df_grouped = optionalFinalOutcome_df.groupby("Stock")
-            for stock, df_group in df_grouped:
-                if stock == "PORTFOLIO":
-                    if final_df is None:
-                        final_df = df_group[["Pattern","LTP","SqrOffLTP","SqrOffDiff","EoDLTP","EoDDiff","DayHigh","DayHighDiff"]]
-                    else:
-                        final_df = pd.concat([final_df, df_group[["Pattern","LTP","SqrOffLTP","SqrOffDiff","EoDLTP","EoDDiff","DayHigh","DayHighDiff"]]], axis=0)
-            final_df.rename(
-                columns={
-                    "LTP": "Morning Portfolio",
-                    "SqrOffLTP": "SqrOff Portfolio",
-                    "EoDLTP": "EoD Portfolio",
-                    },
-                    inplace=True,
-                )
-            mark_down = colorText.miniTabulator().tabulate(
-                                final_df,
-                                headers="keys",
-                                tablefmt=colorText.No_Pad_GridFormat,
-                                showindex = False
-                            ).encode("utf-8").decode(Utility.STD_ENCODING)
-            OutputControls().printOutput(mark_down)
-            sendQuickScanResult(menuChoiceHierarchy="IntradayAnalysis",
-                                user="-1001785195297",
-                                tabulated_results=mark_down,
-                                markdown_results=mark_down,
-                                caption="IntradayAnalysis - Morning alert vs Market Close",
-                                pngName= f"PKS_IA_{PKDateUtilities.currentDateTime().strftime('%Y-%m-%d_%H:%M:%S')}",
-                                pngExtension= ".png"
-                                )
-    else:
-        if args.barometer:
-            sendGlobalMarketBarometer(userArgs=args)
-        else:
-            global results, resultStocks, plainResults, dbTimestamp, elapsed_time, start_time
-            monitorOption_org = ""
-            # args.monitor = configManager.defaultMonitorOptions
-            if args.monitor:
-                configManager.getConfig(ConfigManager.parser)
-                args.answerdefault = args.answerdefault or 'Y'
-                if MarketMonitor().monitorIndex == 0:
-                    dbTimestamp = PKDateUtilities.currentDateTime().strftime("%H:%M:%S")
-                    elapsed_time = 0
-                    if start_time is None:
-                        start_time = time.time()
-                    else:
-                        elapsed_time = round(time.time() - start_time,2)
-                        start_time = time.time()
-                monitorOption_org = MarketMonitor().currentMonitorOption()
-                monitorOption = monitorOption_org
-                monitorOption = checkIntradayComponent(args, monitorOption)
-                if monitorOption.startswith("|"):
-                    monitorOption = monitorOption[1:]
-                    monitorOptions = monitorOption.split(":")
-                    if monitorOptions[1] != "0":
-                        monitorOptions[1] = "0"
-                        monitorOption = ":".join(monitorOptions)
-                    # We need to pipe the output from previous run into the next one
-                    if monitorOption.startswith("{") and "}" in monitorOption:
-                        srcIndex = monitorOption.split("}")[0].split("{")[-1]
-                        monitorOption="".join(monitorOption.split("}")[1:])
-                        try:
-                            srcIndex = int(srcIndex)
-                            # Let's get the previously saved result for the monitor
-                            savedStocks = MarketMonitor().monitorResultStocks[str(srcIndex)]
-                            innerPipes = monitorOption.split("|")
-                            nextPipe = innerPipes[0]
-                            nextMonitor = nextPipe.split(">")[0]
-                            innerPipes[0] = f"{nextMonitor}:{savedStocks}"
-                            monitorOption = ":>|".join(innerPipes)
-                            monitorOption = monitorOption.replace("::",":").replace(":>:>",":>")
-                            # monitorOption = f"{monitorOption}:{savedStocks}:"
-                        except:
-                            # Probably wrong (non-integer) index passed. Let's continue anyway
-                            pass
-                    elif resultStocks is not None:
-                        resultStocks = ",".join(resultStocks)
-                        monitorOption = f"{monitorOption}:{resultStocks}"
-                args.options = monitorOption.replace("::",":")
-                # (previousCandleDuration != configManager.duration) or 
-                if (MarketMonitor().monitorIndex == 1 and args.options is not None and plainResults is not None):
-                    # Load the stock data afresh for each cycle
-                    refreshStockData(args.options)
-            try:
-                results = None
-                plainResults = None
-                resultStocks = None
-                results, plainResults = main(userArgs=args)
-                if args.pipedmenus is not None:
-                    while args.pipedmenus is not None:
-                        results, plainResults = main(userArgs=args)
-                    sys.exit(0)
-                if isInterrupted():
-                    closeWorkersAndExit()
-                    exitGracefully()
-                    sys.exit(0)
-                runPipedScans = True
-                while runPipedScans:
-                    runPipedScans = pipeResults(plainResults,args)
-                    if runPipedScans:
-                        results, plainResults = main(userArgs=args)
-                    else:
-                        if args is not None and args.pipedtitle is not None and "|" in args.pipedtitle:
-                            OutputControls().printOutput(
-                                    colorText.WARN
-                                    + f"[+] Pipe Results Found: {args.pipedtitle}. {'Reduce number of piped scans if no stocks could be found.' if '[0]' in args.pipedtitle else ''}"
-                                    + colorText.END
-                                )
-                            if args.answerdefault is None:
-                                input("Press <Enter> to continue...")
-            except SystemExit:
-                closeWorkersAndExit()
-                exitGracefully()
-                sys.exit(0)
-            except Exception as e:
-                default_logger().debug(e, exc_info=True)
-                # Probably user cancelled an operation by choosing a cancel sub-menu somewhere
-                pass
-            if plainResults is not None and not plainResults.empty:
-                try:
-                    plainResults.set_index("Stock", inplace=True)
-                except:
-                    pass
-                try:
-                    results.set_index("Stock", inplace=True)
-                except:
-                    pass
-                plainResults = plainResults[~plainResults.index.duplicated(keep='first')]
-                results = results[~results.index.duplicated(keep='first')]
-                resultStocks = plainResults.index
-            if args.monitor is not None:
-                MarketMonitor().saveMonitorResultStocks(plainResults)
-                if results is not None and len(monitorOption_org) > 0:
-                    chosenMenu = args.pipedtitle if args.pipedtitle is not None else updateMenuChoiceHierarchy()
-                    MarketMonitor().refresh(screen_df=results,screenOptions=monitorOption_org, chosenMenu=chosenMenu[:120],dbTimestamp=f"{dbTimestamp} | CycleTime:{elapsed_time}s",telegram=args.telegram)
-
-def checkIntradayComponent(args, monitorOption):
-    lastComponent = monitorOption.split(":")[-1]
-                # previousCandleDuration = configManager.duration
-    if "i" in lastComponent:
-                    # We need to switch to intraday scan
-        monitorOption = monitorOption.replace(lastComponent,"")
-        args.intraday = lastComponent.replace("i","").strip()
-        configManager.toggleConfig(candleDuration=args.intraday, clearCache=False)
-        # args.options = f"{monitorOption}:{args.options[len(lastComponent):]}"
-    else:
-                    # We need to switch to daily scan
-        args.intraday = None
-        configManager.toggleConfig(candleDuration='1d', clearCache=False)
-    return monitorOption
-
-
-def pipeResults(prevOutput,args):
-    nextOnes = args.options.split(">")
-    hasFoundStocks = False
-    if len(nextOnes) > 1:
-        monitorOption = nextOnes[1]
-        if len(monitorOption) == 0:
-            return False
-        lastComponent = monitorOption.split(":")[-1]
-        if "i" in lastComponent:
-            # We need to switch to intraday scan
-            monitorOption = monitorOption.replace(lastComponent,"")
-            args.intraday = lastComponent.replace("i","").strip()
-            configManager.toggleConfig(candleDuration=args.intraday, clearCache=False)
-        else:
-            # We need to switch to daily scan
-            args.intraday = None
-            configManager.toggleConfig(candleDuration='1d', clearCache=False)
-        if monitorOption.startswith("|"):
-            monitorOption = monitorOption.replace("|","")
-            monitorOptions = monitorOption.split(":")
-            if monitorOptions[1] != "0":
-                monitorOptions[1] = "0"
-                monitorOption = ":".join(monitorOptions)
-            # We need to pipe the output from previous run into the next one
-            if prevOutput is not None and not prevOutput.empty:
-                try:
-                    prevOutput.set_index("Stock", inplace=True)
-                except:
-                    pass
-                prevOutput_results = prevOutput[~prevOutput.index.duplicated(keep='first')]
-                prevOutput_results = prevOutput_results.index
-                hasFoundStocks = len(prevOutput_results) > 0
-                prevOutput_results = ",".join(prevOutput_results)
-                monitorOption = monitorOption.replace(":D:",":")
-                monitorOption = f"{monitorOption}:{prevOutput_results}"
-        args.options = monitorOption.replace("::",":")
-        args.options = args.options + ":D:>" + ":D:>".join(nextOnes[2:])
-        args.options = args.options.replace("::",":")
-        return True and hasFoundStocks
-    return False
-
-def pkscreenercli():
-    global originalStdOut
-    if sys.platform.startswith("darwin"):
-        try:
-            multiprocessing.set_start_method("fork")
-        except RuntimeError as e:# pragma: no cover
-            if "RUNNER" not in os.environ.keys() and ('PKDevTools_Default_Log_Level' in os.environ.keys() and os.environ["PKDevTools_Default_Log_Level"] != str(log.logging.NOTSET)):
-                OutputControls().printOutput(
-                    "[+] RuntimeError with 'multiprocessing'.\n[+] Please contact the Developer, if this does not work!"
-                )
-                OutputControls().printOutput(e)
-                traceback.print_exc()
-            pass
-
-    OutputControls(enableMultipleLineOutput=(args.monitor is None)).printOutput("",end="\r")
-    
-    configManager.getConfig(ConfigManager.parser)
-    import atexit
-    atexit.register(exitGracefully)
-    # configManager.restartRequestsCache()
-    # args.monitor = configManager.defaultMonitorOptions
-    if args.monitor is not None:
-        MarketMonitor(monitors=args.monitor.split("~") if len(args.monitor)>5 else configManager.defaultMonitorOptions.split("~"),
-                      maxNumResultsPerRow=configManager.maxDashboardWidgetsPerRow,
-                      maxNumColsInEachResult=6,
-                      maxNumRowsInEachResult=10,
-                      maxNumResultRowsInMonitor=configManager.maxNumResultRowsInMonitor)
-
-    if args.log or configManager.logsEnabled:
-        setupLogger(shouldLog=True, trace=args.testbuild)
-        if not args.prodbuild and args.answerdefault is None:
-            input("Press <Enter> to continue...")
-    else:
-        if "PKDevTools_Default_Log_Level" in os.environ.keys():
-            del os.environ['PKDevTools_Default_Log_Level']
-            # os.environ["PKDevTools_Default_Log_Level"] = str(log.logging.NOTSET)
-    if args.simulate:
-        os.environ["simulation"] = json.dumps(args.simulate)
-    elif "simulation" in os.environ.keys():
-        del os.environ['simulation']
-    # Import other dependency here because if we import them at the top
-    # multiprocessing behaves in unpredictable ways
-    import pkscreener.classes.Utility as Utility
-
-    configManager.default_logger = default_logger()
-    if originalStdOut is None:
-        # Clear only if this is the first time it's being called from some
-        # loop within workflowtriggers.
-        Utility.tools.clearScreen(userArgs=args, clearAlways=True)
-    warnAboutDependencies()
-    if args.prodbuild:
-        disableSysOut()
-
-    if not configManager.checkConfigFile():
-        configManager.setConfig(
-            ConfigManager.parser, default=True, showFileCreatedText=False
-        )
-    if args.systemlaunched:
-        args.systemlaunched = args.options
-        
-    if args.telegram:
-        # Launched by bot for intraday monitor?
-        if (PKDateUtilities.isTradingTime() and not PKDateUtilities.isTodayHoliday()[0]) or ("PKDevTools_Default_Log_Level" in os.environ.keys()):
-            from PKDevTools.classes import Archiver
-            filePath = os.path.join(Archiver.get_user_outputs_dir(), "monitor_outputs_1.txt")
-            if os.path.exists(filePath):
-                default_logger().info("monitor_outputs_1.txt already exists! This means an instance may already be running. Exiting now...")
-                # Since the file exists, it means, there is another instance running
-                sys.exit(0)
-        else:
-            # It should have been launched only during the trading hours
-            default_logger().info("--telegram option must be launched ONLY during NSE trading hours. Exiting now...")
-            sys.exit(0)
-    # Check and see if we're running only the telegram bot
-    if args.bot:
-        from pkscreener import pkscreenerbot
-        pkscreenerbot.runpkscreenerbot(availability=args.botavailable)
-        return
-    
-    if args.intraday:
-        configManager.toggleConfig(candleDuration=args.intraday, clearCache=False)
-    else:
-        configManager.toggleConfig(candleDuration='1d', clearCache=False)
-    if args.options is not None:
-        if str(args.options) == "0":
-            # Must be from unit tests to be able to break out of loops via eventing
-            args.options = None
-        args.options = args.options.replace("::",":")
-    
-    if args.maxprice:
-        configManager.maxLTP = args.maxprice
-        configManager.setConfig(ConfigManager.parser, default=True, showFileCreatedText=False)
-    if args.minprice:
-        configManager.minLTP = args.minprice
-        configManager.setConfig(ConfigManager.parser, default=True, showFileCreatedText=False)
-    if args.testbuild and not args.prodbuild:
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + "[+] Started in TestBuild mode!"
-            + colorText.END
-        )
-        runApplication()
-    elif args.download:
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + "[+] Download ONLY mode! Stocks will not be screened!"
-            + colorText.END
-        )
-        if args.intraday is None:
-            configManager.toggleConfig(candleDuration="1d", clearCache=False)
-        runApplication()
-        from pkscreener.globals import closeWorkersAndExit
-        closeWorkersAndExit()
-        exitGracefully()
-        sys.exit(0)
-    else:
-        runApplicationForScreening()
-
-def runLoopOnScheduleOrStdApplication(hasCronInterval):
-    if hasCronInterval:
-        scheduleNextRun()
-    else:
-        runApplication()
-
-def runApplicationForScreening():
-    from pkscreener.globals import closeWorkersAndExit
-    try:
-        hasCronInterval = args.croninterval is not None and str(args.croninterval).isnumeric()
-        shouldBreak = (args.exit and not hasCronInterval)or args.user is not None or args.testbuild
-        runLoopOnScheduleOrStdApplication(hasCronInterval)
-        while True:
-            if shouldBreak:
-                break
-            runLoopOnScheduleOrStdApplication(hasCronInterval)
-        if args.v:
-            disableSysOut(disable=False)
-            return
-        closeWorkersAndExit()
-        exitGracefully()
-        sys.exit(0)
-    except SystemExit:
-        closeWorkersAndExit()
-        exitGracefully()
-        sys.exit(0)
-    except (RuntimeError, Exception) as e:  # pragma: no cover
-        default_logger().debug(e, exc_info=True)
-        if args.prodbuild:
-            disableSysOut(disable=False)
-        OutputControls().printOutput(
-            f"{e}\n[+] An error occurred! Please run with '-l' option to collect the logs.\n[+] For example, 'pkscreener -l' and then contact the developer!"
-        )
-        if "RUNNER" in os.environ.keys() or ('PKDevTools_Default_Log_Level' in os.environ.keys() and os.environ["PKDevTools_Default_Log_Level"] != str(log.logging.NOTSET)):
-            traceback.print_exc()
-        if args.v:
-            disableSysOut(disable=False)
-            return
-        closeWorkersAndExit()
-        exitGracefully()
-        sys.exit(0)
-
-
-def scheduleNextRun():
-    sleepUntilNextExecution = not PKDateUtilities.isTradingTime()
-    while sleepUntilNextExecution:
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + (
-                "SecondsAfterClosingTime[%d] SecondsBeforeMarketOpen [%d]. Next run at [%s]"
-                % (
-                    int(PKDateUtilities.secondsAfterCloseTime()),
-                    int(PKDateUtilities.secondsBeforeOpenTime()),
-                    str(
-                        PKDateUtilities.nextRunAtDateTime(
-                            bufferSeconds=3600,
-                            cronWaitSeconds=int(args.croninterval),
-                        )
-                    ),
-                )
-            )
-            + colorText.END
-        )
-        if (PKDateUtilities.secondsAfterCloseTime() >= 3600) and (
-            PKDateUtilities.secondsAfterCloseTime() <= (3600 + 1.5 * int(args.croninterval))
-        ):
-            sleepUntilNextExecution = False
-        if (PKDateUtilities.secondsBeforeOpenTime() <= -3600) and (
-            PKDateUtilities.secondsBeforeOpenTime() >= (-3600 - 1.5 * int(args.croninterval))
-        ):
-            sleepUntilNextExecution = False
-        sleep(int(args.croninterval))
-    global cron_runs
-    if cron_runs > 0:
-        OutputControls().printOutput(
-            colorText.BOLD + colorText.GREEN + f'=> Going to fetch again in {int(args.croninterval)} sec. at {(PKDateUtilities.currentDateTime() + datetime.timedelta(seconds=120)).strftime("%Y-%m-%d %H:%M:%S")} IST...' + colorText.END,
-            end="\r",
-            flush=True,
-        )
-        sleep(int(args.croninterval) if not args.testbuild else 3)
-    runApplication()
-    cron_runs += 1
-
-if __name__ == "__main__":
-    try:
-        pkscreenercli()
-    except KeyboardInterrupt:
-        sys.exit(0)
+#!/usr/bin/python3
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+# Pyinstaller compile Windows: pyinstaller --onefile --icon=screenshots\icon.ico pkscreener\pkscreenercli.py  --hidden-import cmath --hidden-import talib.stream --hidden-import numpy --hidden-import pandas --hidden-import alive-progress
+# Pyinstaller compile Linux  : pyinstaller --onefile --icon=screenshots/icon.ico pkscreener/pkscreenercli.py  --hidden-import cmath --hidden-import talib.stream --hidden-import numpy --hidden-import pandas --hidden-import alive-progress
+import warnings
+warnings.simplefilter("ignore", UserWarning,append=True)
+import argparse
+import builtins
+import logging
+import json
+import traceback
+import datetime
+# Keep module imports prior to classes
+import os
+import sys
+import tempfile
+os.environ["PYTHONWARNINGS"]="ignore::UserWarning"
+import multiprocessing
+
+sys.path.append(os.path.dirname(os.path.abspath(__file__)))
+
+try:
+    logging.getLogger("tensorflow").setLevel(logging.ERROR)
+except Exception:# pragma: no cover
+    pass
+
+from time import sleep
+import time
+
+from PKDevTools.classes import log as log
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.log import default_logger
+from PKDevTools.classes.PKDateUtilities import PKDateUtilities
+from pkscreener import Imports
+from PKDevTools.classes.OutputControls import OutputControls
+from pkscreener.classes.MarketMonitor import MarketMonitor
+import pkscreener.classes.ConfigManager as ConfigManager
+
+if __name__ == '__main__':
+    multiprocessing.freeze_support()
+os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
+os.environ["AUTOGRAPH_VERBOSITY"] = "0"
+
+printenabled=False
+originalStdOut=None
+original__stdout=None
+cron_runs=0
+
+def decorator(func):
+    def new_func(*args, **kwargs):
+        if printenabled:
+            try:
+                func(*args,**kwargs)
+            except Exception as e:# pragma: no cover
+                default_logger().debug(e, exc_info=True)
+                pass
+
+    return new_func
+
+
+# print = decorator(print) # current file
+def disableSysOut(input=True, disable=True):
+    global printenabled
+    printenabled = not disable
+    if disable:
+        global originalStdOut, original__stdout
+        if originalStdOut is None:
+            builtins.print = decorator(builtins.print)  # all files
+            if input:
+                builtins.input = decorator(builtins.input)  # all files
+            originalStdOut = sys.stdout
+            original__stdout = sys.__stdout__
+        sys.stdout = open(os.devnull, "w")
+        sys.__stdout__ = open(os.devnull, "w")
+    else:
+        try:
+            sys.stdout.close()
+            sys.__stdout__.close()
+        except Exception as e:# pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            pass
+        sys.stdout = originalStdOut
+        sys.__stdout__ = original__stdout
+
+# Argument Parsing for test purpose
+argParser = argparse.ArgumentParser()
+argParser.add_argument(
+    "-a",
+    "--answerdefault",
+    help="Pass default answer to questions/choices in the application. Example Y, N",
+    required=False,
+)
+argParser.add_argument(
+    "--backtestdaysago",
+    help="Run scanner for -b days ago from today.",
+    required=False,
+)
+argParser.add_argument(
+    "--barometer",
+    action="store_true",
+    help="Send global market barometer to telegram channel or a user",
+    required=False,
+)
+argParser.add_argument(
+    "--bot",
+    action="store_true",
+    help="Run only in telegram bot mode",
+    required=False,
+)
+argParser.add_argument(
+    "--botavailable",
+    action="store_true",
+    help="Enforce whether bot is going to be available or not.",
+    required=False,
+)
+argParser.add_argument(
+    "-c",
+    "--croninterval",
+    help="Pass interval in seconds to wait before the program is run again with same parameters",
+    required=False,
+)
+argParser.add_argument(
+    "-d",
+    "--download",
+    action="store_true",
+    help="Only download Stock data in .pkl file (No analysis will be run)",
+    required=False,
+)
+argParser.add_argument(
+    "-e",
+    "--exit",
+    action="store_true",
+    help="Exit right after executing just once",
+    required=False,
+)
+argParser.add_argument(
+    "--forceBacktestsForZeroResultDays",
+    help="Force run the backtests even for those days when we already have zero results saved in the repo",
+    action=argparse.BooleanOptionalAction,
+)
+argParser.add_argument(
+    "-i",
+    "--intraday",
+    help="Use Intraday configurations and use the candlestick duration that is passed. Acceptable values 1m, 5m, 10m, 15m, 1h etc.",
+    required=False,
+)
+argParser.add_argument(
+    "-m",
+    "--monitor",
+    help="Monitor for intraday scanners and their results.",
+    nargs='?',
+    const='X',
+    type=str,
+    required=False,
+)
+argParser.add_argument(
+    "--maxdisplayresults",
+    help="Maximum number of results to display.",
+    required=False,
+)
+argParser.add_argument(
+    "--maxprice",
+    help="Maximum Price for the stock to be considered.",
+    required=False,
+)
+argParser.add_argument(
+    "--minprice",
+    help="Minimum Price for the stock to be considered.",
+    required=False,
+)
+argParser.add_argument(
+    "-o",
+    "--options",
+    help="Pass selected options in the <MainMenu>:<SubMenu>:<SubMenu>:etc. format. For example: ./pkscreenercli.py -a Y -o X:12:10 -e will run the screener with answer Y as default choice to questions and scan with menu choices: Scanners > Nifty (All Stocks) > Closing at least 2%% up since last 3 day",
+    required=False,
+)
+argParser.add_argument(
+    "-p",
+    "--prodbuild",
+    action="store_true",
+    help="Run in production-build mode",
+    required=False,
+)
+argParser.add_argument(
+    "--runintradayanalysis",
+    action="store_true",
+    help="Run analysis for morning vs EoD LTP values",
+    required=False,
+)
+argParser.add_argument(
+    "--simulate",
+    type=json.loads, # '{"isTrading":true,"currentDateTime":"2024-04-29 09:35:38"}'
+    help="Simulate various conditions",
+    required=False,
+)
+argParser.add_argument(
+    "--singlethread",
+    action="store_true",
+    help="Run analysis for debugging purposes in a single process, single threaded environment",
+    required=False,
+)
+argParser.add_argument(
+    "--systemlaunched",
+    action="store_true",
+    help="Indicator to show that this is a system launched screener, using os.system",
+    required=False,
+)
+argParser.add_argument(
+    "-t",
+    "--testbuild",
+    action="store_true",
+    help="Run in test-build mode",
+    required=False,
+)
+argParser.add_argument(
+    "--telegram",
+    action="store_true",
+    help="Run with an assumption that this instance is launched via telegram bot",
+    required=False,
+)
+argParser.add_argument(
+    "-u",
+    "--user",
+    help="Telegram user ID to whom the results must be sent.",
+    required=False,
+)
+argParser.add_argument(
+    "-l",
+    "--log",
+    action="store_true",
+    help="Run with full logging enabled",
+    required=False,
+)
+argParser.add_argument("-v", action="store_true")  # Dummy Arg for pytest -v
+argParser.add_argument(
+    "--pipedtitle",
+    help="Piped Titles",
+    required=False,
+)
+argParser.add_argument(
+    "--pipedmenus",
+    help="Piped Menus",
+    required=False,
+)
+argsv = argParser.parse_known_args()
+args = argsv[0]
+# if sys.argv[0].endswith(".py"):
+#     args.monitor = 'X'
+#     args.answerdefault = 'Y'
+results = None
+resultStocks = None
+plainResults = None
+start_time = None
+dbTimestamp = None
+elapsed_time = None
+configManager = ConfigManager.tools()
+
+def exitGracefully():
+    from PKDevTools.classes import Archiver
+    from pkscreener.globals import resetConfigToDefault
+    filePath = os.path.join(Archiver.get_user_outputs_dir(), "monitor_outputs")
+    index = 0
+    while index < configManager.maxDashboardWidgetsPerRow*configManager.maxNumResultRowsInMonitor:
+        try:
+            os.remove(f"{filePath}_{index}.txt")
+        except:
+            pass
+        index += 1
+
+    argsv = argParser.parse_known_args()
+    args = argsv[0]
+    if args is not None and args.options is not None and not args.options.upper().startswith("T"):
+        resetConfigToDefault()
+        
+    if "PKDevTools_Default_Log_Level" in os.environ.keys():
+        if args is None or (args is not None and args.options is not None and "|" not in args.options):
+            del os.environ['PKDevTools_Default_Log_Level']
+    configManager.logsEnabled = False
+    configManager.setConfig(ConfigManager.parser,default=True,showFileCreatedText=False)
+
+def logFilePath():
+    try:
+        from PKDevTools.classes import Archiver
+
+        filePath = os.path.join(Archiver.get_user_outputs_dir(), "pkscreener-logs.txt")
+        f = open(filePath, "w")
+        f.write("Logger file for pkscreener!")
+        f.close()
+    except Exception:# pragma: no cover
+        filePath = os.path.join(tempfile.gettempdir(), "pkscreener-logs.txt")
+    return filePath
+
+
+def setupLogger(shouldLog=False, trace=False):
+    if not shouldLog:
+        del os.environ['PKDevTools_Default_Log_Level']
+        return
+    log_file_path = logFilePath()
+
+    if os.path.exists(log_file_path):
+        try:
+            os.remove(log_file_path)
+        except Exception:# pragma: no cover
+            pass
+    OutputControls().printOutput(colorText.FAIL + "\n[+] Logs will be written to:"+colorText.END)
+    OutputControls().printOutput(colorText.GREEN + f"[+] {log_file_path}"+colorText.END)
+    OutputControls().printOutput(colorText.FAIL + "[+] If you need to share, open this folder, copy and zip the log file to share.\n" + colorText.END)
+    # logger = multiprocessing.log_to_stderr(log.logging.DEBUG)
+    log.setup_custom_logger(
+        "pkscreener",
+        log.logging.DEBUG,
+        trace=trace,
+        log_file_path=log_file_path,
+        filter=None,
+    )
+    os.environ["PKDevTools_Default_Log_Level"] = str(log.logging.DEBUG)
+
+def warnAboutDependencies():
+    if not Imports["talib"]:
+        OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] TA-Lib is not installed. Looking for pandas_ta."
+                + colorText.END
+            )
+        sleep(1)
+        if Imports["pandas_ta"]:
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.GREEN
+                + "[+] Found and falling back on pandas_ta.\n[+] For full coverage(candle patterns), you may wish to read the README file in PKScreener repo : https://github.com/pkjmesra/PKScreener \n[+] or follow instructions from\n[+] https://github.com/ta-lib/ta-lib-python"
+                + colorText.END
+            )
+            sleep(1)
+        else:
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] Neither ta-lib nor pandas_ta was located. You need at least one of them to continue! \n[+] Please follow instructions from README file under PKScreener repo: https://github.com/pkjmesra/PKScreener"
+                + colorText.END
+            )
+            input("Press any key to try anyway...")
+    
+def runApplication():
+    from pkscreener.globals import main, sendQuickScanResult,sendMessageToTelegramChannel, sendGlobalMarketBarometer, updateMenuChoiceHierarchy, isInterrupted, refreshStockData, closeWorkersAndExit
+    # From a previous call to main with args, it may have been mutated.
+    # Let's stock to the original args passed by user
+    try:
+        savedPipedArgs = None
+        savedPipedArgs = args.pipedmenus if args is not None and args.pipedmenus is not None else None
+    except:
+        pass
+    argsv = argParser.parse_known_args()
+    args = argsv[0]
+    if args.systemlaunched:
+        args.systemlaunched = args.options
+    
+    # if sys.argv[0].endswith(".py"):
+    #     args.monitor = 'X'
+    #     args.answerdefault = 'Y'
+    args.pipedmenus = savedPipedArgs
+    if args.options is not None:
+        args.options = args.options.replace("::",":")
+    if args.runintradayanalysis:
+        from pkscreener.classes.MenuOptions import menus
+        runOptions = menus.allMenus(topLevel="C", index=12)
+        optionalFinalOutcome_df = None
+        import pkscreener.classes.Utility as Utility
+        import pandas as pd
+        # Delete any existing data from the previous run.
+        configManager.deleteFileWithPattern(pattern="stock_data_*.pkl")
+        for runOption in runOptions:
+            args.options = runOption
+            try:
+                optionalFinalOutcome_df,_ = main(userArgs=args,optionalFinalOutcome_df=optionalFinalOutcome_df)
+                if "EoDDiff" not in optionalFinalOutcome_df.columns:
+                    # Somehow the file must have been corrupted. Let's re-download
+                    configManager.deleteFileWithPattern(pattern="stock_data_*.pkl")
+                    configManager.deleteFileWithPattern(pattern="intraday_stock_data_*.pkl")
+                if isInterrupted():
+                    break
+            except Exception as e:
+                OutputControls().printOutput(e)
+                if args.log:
+                    traceback.print_exc()
+        if optionalFinalOutcome_df is not None:
+            final_df = None
+            optionalFinalOutcome_df.drop('FairValue', axis=1, inplace=True, errors="ignore")
+            df_grouped = optionalFinalOutcome_df.groupby("Stock")
+            for stock, df_group in df_grouped:
+                if stock == "PORTFOLIO":
+                    if final_df is None:
+                        final_df = df_group[["Pattern","LTP","SqrOffLTP","SqrOffDiff","EoDLTP","EoDDiff","DayHigh","DayHighDiff"]]
+                    else:
+                        final_df = pd.concat([final_df, df_group[["Pattern","LTP","SqrOffLTP","SqrOffDiff","EoDLTP","EoDDiff","DayHigh","DayHighDiff"]]], axis=0)
+            final_df.rename(
+                columns={
+                    "LTP": "Morning Portfolio",
+                    "SqrOffLTP": "SqrOff Portfolio",
+                    "EoDLTP": "EoD Portfolio",
+                    },
+                    inplace=True,
+                )
+            mark_down = colorText.miniTabulator().tabulate(
+                                final_df,
+                                headers="keys",
+                                tablefmt=colorText.No_Pad_GridFormat,
+                                showindex = False
+                            ).encode("utf-8").decode(Utility.STD_ENCODING)
+            OutputControls().printOutput(mark_down)
+            sendQuickScanResult(menuChoiceHierarchy="IntradayAnalysis",
+                                user="-1001785195297",
+                                tabulated_results=mark_down,
+                                markdown_results=mark_down,
+                                caption="IntradayAnalysis - Morning alert vs Market Close",
+                                pngName= f"PKS_IA_{PKDateUtilities.currentDateTime().strftime('%Y-%m-%d_%H:%M:%S')}",
+                                pngExtension= ".png"
+                                )
+    else:
+        if args.barometer:
+            sendGlobalMarketBarometer(userArgs=args)
+        else:
+            global results, resultStocks, plainResults, dbTimestamp, elapsed_time, start_time
+            monitorOption_org = ""
+            # args.monitor = configManager.defaultMonitorOptions
+            if args.monitor:
+                configManager.getConfig(ConfigManager.parser)
+                args.answerdefault = args.answerdefault or 'Y'
+                if MarketMonitor().monitorIndex == 0:
+                    dbTimestamp = PKDateUtilities.currentDateTime().strftime("%H:%M:%S")
+                    elapsed_time = 0
+                    if start_time is None:
+                        start_time = time.time()
+                    else:
+                        elapsed_time = round(time.time() - start_time,2)
+                        start_time = time.time()
+                monitorOption_org = MarketMonitor().currentMonitorOption()
+                monitorOption = monitorOption_org
+                monitorOption = checkIntradayComponent(args, monitorOption)
+                if monitorOption.startswith("|"):
+                    monitorOption = monitorOption[1:]
+                    monitorOptions = monitorOption.split(":")
+                    if monitorOptions[1] != "0":
+                        monitorOptions[1] = "0"
+                        monitorOption = ":".join(monitorOptions)
+                    # We need to pipe the output from previous run into the next one
+                    if monitorOption.startswith("{") and "}" in monitorOption:
+                        srcIndex = monitorOption.split("}")[0].split("{")[-1]
+                        monitorOption="".join(monitorOption.split("}")[1:])
+                        try:
+                            srcIndex = int(srcIndex)
+                            # Let's get the previously saved result for the monitor
+                            savedStocks = MarketMonitor().monitorResultStocks[str(srcIndex)]
+                            innerPipes = monitorOption.split("|")
+                            nextPipe = innerPipes[0]
+                            nextMonitor = nextPipe.split(">")[0]
+                            innerPipes[0] = f"{nextMonitor}:{savedStocks}"
+                            monitorOption = ":>|".join(innerPipes)
+                            monitorOption = monitorOption.replace("::",":").replace(":>:>",":>")
+                            # monitorOption = f"{monitorOption}:{savedStocks}:"
+                        except:
+                            # Probably wrong (non-integer) index passed. Let's continue anyway
+                            pass
+                    elif resultStocks is not None:
+                        resultStocks = ",".join(resultStocks)
+                        monitorOption = f"{monitorOption}:{resultStocks}"
+                args.options = monitorOption.replace("::",":")
+                # (previousCandleDuration != configManager.duration) or 
+                if (MarketMonitor().monitorIndex == 1 and args.options is not None and plainResults is not None):
+                    # Load the stock data afresh for each cycle
+                    refreshStockData(args.options)
+            try:
+                results = None
+                plainResults = None
+                resultStocks = None
+                results, plainResults = main(userArgs=args)
+                if args.pipedmenus is not None:
+                    while args.pipedmenus is not None:
+                        results, plainResults = main(userArgs=args)
+                    sys.exit(0)
+                if isInterrupted():
+                    closeWorkersAndExit()
+                    exitGracefully()
+                    sys.exit(0)
+                runPipedScans = True
+                while runPipedScans:
+                    runPipedScans = pipeResults(plainResults,args)
+                    if runPipedScans:
+                        results, plainResults = main(userArgs=args)
+                    else:
+                        if args is not None and args.pipedtitle is not None and "|" in args.pipedtitle:
+                            OutputControls().printOutput(
+                                    colorText.WARN
+                                    + f"[+] Pipe Results Found: {args.pipedtitle}. {'Reduce number of piped scans if no stocks could be found.' if '[0]' in args.pipedtitle else ''}"
+                                    + colorText.END
+                                )
+                            if args.answerdefault is None:
+                                input("Press <Enter> to continue...")
+            except SystemExit:
+                closeWorkersAndExit()
+                exitGracefully()
+                sys.exit(0)
+            except Exception as e:
+                default_logger().debug(e, exc_info=True)
+                # Probably user cancelled an operation by choosing a cancel sub-menu somewhere
+                pass
+            if plainResults is not None and not plainResults.empty:
+                try:
+                    plainResults.set_index("Stock", inplace=True)
+                except:
+                    pass
+                try:
+                    results.set_index("Stock", inplace=True)
+                except:
+                    pass
+                plainResults = plainResults[~plainResults.index.duplicated(keep='first')]
+                results = results[~results.index.duplicated(keep='first')]
+                resultStocks = plainResults.index
+            if args.monitor is not None:
+                MarketMonitor().saveMonitorResultStocks(plainResults)
+                if results is not None and len(monitorOption_org) > 0:
+                    chosenMenu = args.pipedtitle if args.pipedtitle is not None else updateMenuChoiceHierarchy()
+                    MarketMonitor().refresh(screen_df=results,screenOptions=monitorOption_org, chosenMenu=chosenMenu[:120],dbTimestamp=f"{dbTimestamp} | CycleTime:{elapsed_time}s",telegram=args.telegram)
+
+def checkIntradayComponent(args, monitorOption):
+    lastComponent = monitorOption.split(":")[-1]
+                # previousCandleDuration = configManager.duration
+    if "i" in lastComponent:
+                    # We need to switch to intraday scan
+        monitorOption = monitorOption.replace(lastComponent,"")
+        args.intraday = lastComponent.replace("i","").strip()
+        configManager.toggleConfig(candleDuration=args.intraday, clearCache=False)
+        # args.options = f"{monitorOption}:{args.options[len(lastComponent):]}"
+    else:
+                    # We need to switch to daily scan
+        args.intraday = None
+        configManager.toggleConfig(candleDuration='1d', clearCache=False)
+    return monitorOption
+
+
+def pipeResults(prevOutput,args):
+    nextOnes = args.options.split(">")
+    hasFoundStocks = False
+    if len(nextOnes) > 1:
+        monitorOption = nextOnes[1]
+        if len(monitorOption) == 0:
+            return False
+        lastComponent = monitorOption.split(":")[-1]
+        if "i" in lastComponent:
+            # We need to switch to intraday scan
+            monitorOption = monitorOption.replace(lastComponent,"")
+            args.intraday = lastComponent.replace("i","").strip()
+            configManager.toggleConfig(candleDuration=args.intraday, clearCache=False)
+        else:
+            # We need to switch to daily scan
+            args.intraday = None
+            configManager.toggleConfig(candleDuration='1d', clearCache=False)
+        if monitorOption.startswith("|"):
+            monitorOption = monitorOption.replace("|","")
+            monitorOptions = monitorOption.split(":")
+            if monitorOptions[1] != "0":
+                monitorOptions[1] = "0"
+                monitorOption = ":".join(monitorOptions)
+            # We need to pipe the output from previous run into the next one
+            if prevOutput is not None and not prevOutput.empty:
+                try:
+                    prevOutput.set_index("Stock", inplace=True)
+                except:
+                    pass
+                prevOutput_results = prevOutput[~prevOutput.index.duplicated(keep='first')]
+                prevOutput_results = prevOutput_results.index
+                hasFoundStocks = len(prevOutput_results) > 0
+                prevOutput_results = ",".join(prevOutput_results)
+                monitorOption = monitorOption.replace(":D:",":")
+                monitorOption = f"{monitorOption}:{prevOutput_results}"
+        args.options = monitorOption.replace("::",":")
+        args.options = args.options + ":D:>" + ":D:>".join(nextOnes[2:])
+        args.options = args.options.replace("::",":")
+        return True and hasFoundStocks
+    return False
+
+def pkscreenercli():
+    global originalStdOut
+    if sys.platform.startswith("darwin"):
+        try:
+            multiprocessing.set_start_method("fork")
+        except RuntimeError as e:# pragma: no cover
+            if "RUNNER" not in os.environ.keys() and ('PKDevTools_Default_Log_Level' in os.environ.keys() and os.environ["PKDevTools_Default_Log_Level"] != str(log.logging.NOTSET)):
+                OutputControls().printOutput(
+                    "[+] RuntimeError with 'multiprocessing'.\n[+] Please contact the Developer, if this does not work!"
+                )
+                OutputControls().printOutput(e)
+                traceback.print_exc()
+            pass
+
+    OutputControls(enableMultipleLineOutput=(args.monitor is None)).printOutput("",end="\r")
+    
+    configManager.getConfig(ConfigManager.parser)
+    import atexit
+    atexit.register(exitGracefully)
+    # configManager.restartRequestsCache()
+    # args.monitor = configManager.defaultMonitorOptions
+    if args.monitor is not None:
+        MarketMonitor(monitors=args.monitor.split("~") if len(args.monitor)>5 else configManager.defaultMonitorOptions.split("~"),
+                      maxNumResultsPerRow=configManager.maxDashboardWidgetsPerRow,
+                      maxNumColsInEachResult=6,
+                      maxNumRowsInEachResult=10,
+                      maxNumResultRowsInMonitor=configManager.maxNumResultRowsInMonitor)
+
+    if args.log or configManager.logsEnabled:
+        setupLogger(shouldLog=True, trace=args.testbuild)
+        if not args.prodbuild and args.answerdefault is None:
+            input("Press <Enter> to continue...")
+    else:
+        if "PKDevTools_Default_Log_Level" in os.environ.keys():
+            del os.environ['PKDevTools_Default_Log_Level']
+            # os.environ["PKDevTools_Default_Log_Level"] = str(log.logging.NOTSET)
+    if args.simulate:
+        os.environ["simulation"] = json.dumps(args.simulate)
+    elif "simulation" in os.environ.keys():
+        del os.environ['simulation']
+    # Import other dependency here because if we import them at the top
+    # multiprocessing behaves in unpredictable ways
+    import pkscreener.classes.Utility as Utility
+
+    configManager.default_logger = default_logger()
+    if originalStdOut is None:
+        # Clear only if this is the first time it's being called from some
+        # loop within workflowtriggers.
+        Utility.tools.clearScreen(userArgs=args, clearAlways=True)
+    warnAboutDependencies()
+    if args.prodbuild:
+        disableSysOut()
+
+    if not configManager.checkConfigFile():
+        configManager.setConfig(
+            ConfigManager.parser, default=True, showFileCreatedText=False
+        )
+    if args.systemlaunched:
+        args.systemlaunched = args.options
+        
+    if args.telegram:
+        # Launched by bot for intraday monitor?
+        if (PKDateUtilities.isTradingTime() and not PKDateUtilities.isTodayHoliday()[0]) or ("PKDevTools_Default_Log_Level" in os.environ.keys()):
+            from PKDevTools.classes import Archiver
+            filePath = os.path.join(Archiver.get_user_outputs_dir(), "monitor_outputs_1.txt")
+            if os.path.exists(filePath):
+                default_logger().info("monitor_outputs_1.txt already exists! This means an instance may already be running. Exiting now...")
+                # Since the file exists, it means, there is another instance running
+                sys.exit(0)
+        else:
+            # It should have been launched only during the trading hours
+            default_logger().info("--telegram option must be launched ONLY during NSE trading hours. Exiting now...")
+            sys.exit(0)
+    # Check and see if we're running only the telegram bot
+    if args.bot:
+        from pkscreener import pkscreenerbot
+        pkscreenerbot.runpkscreenerbot(availability=args.botavailable)
+        return
+    
+    if args.intraday:
+        configManager.toggleConfig(candleDuration=args.intraday, clearCache=False)
+    else:
+        configManager.toggleConfig(candleDuration='1d', clearCache=False)
+    if args.options is not None:
+        if str(args.options) == "0":
+            # Must be from unit tests to be able to break out of loops via eventing
+            args.options = None
+        args.options = args.options.replace("::",":")
+    
+    if args.maxprice:
+        configManager.maxLTP = args.maxprice
+        configManager.setConfig(ConfigManager.parser, default=True, showFileCreatedText=False)
+    if args.minprice:
+        configManager.minLTP = args.minprice
+        configManager.setConfig(ConfigManager.parser, default=True, showFileCreatedText=False)
+    if args.testbuild and not args.prodbuild:
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + "[+] Started in TestBuild mode!"
+            + colorText.END
+        )
+        runApplication()
+    elif args.download:
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + "[+] Download ONLY mode! Stocks will not be screened!"
+            + colorText.END
+        )
+        if args.intraday is None:
+            configManager.toggleConfig(candleDuration="1d", clearCache=False)
+        runApplication()
+        from pkscreener.globals import closeWorkersAndExit
+        closeWorkersAndExit()
+        exitGracefully()
+        sys.exit(0)
+    else:
+        runApplicationForScreening()
+
+def runLoopOnScheduleOrStdApplication(hasCronInterval):
+    if hasCronInterval:
+        scheduleNextRun()
+    else:
+        runApplication()
+
+def runApplicationForScreening():
+    from pkscreener.globals import closeWorkersAndExit
+    try:
+        hasCronInterval = args.croninterval is not None and str(args.croninterval).isnumeric()
+        shouldBreak = (args.exit and not hasCronInterval)or args.user is not None or args.testbuild
+        runLoopOnScheduleOrStdApplication(hasCronInterval)
+        while True:
+            if shouldBreak:
+                break
+            runLoopOnScheduleOrStdApplication(hasCronInterval)
+        if args.v:
+            disableSysOut(disable=False)
+            return
+        closeWorkersAndExit()
+        exitGracefully()
+        sys.exit(0)
+    except SystemExit:
+        closeWorkersAndExit()
+        exitGracefully()
+        sys.exit(0)
+    except (RuntimeError, Exception) as e:  # pragma: no cover
+        default_logger().debug(e, exc_info=True)
+        if args.prodbuild:
+            disableSysOut(disable=False)
+        OutputControls().printOutput(
+            f"{e}\n[+] An error occurred! Please run with '-l' option to collect the logs.\n[+] For example, 'pkscreener -l' and then contact the developer!"
+        )
+        if "RUNNER" in os.environ.keys() or ('PKDevTools_Default_Log_Level' in os.environ.keys() and os.environ["PKDevTools_Default_Log_Level"] != str(log.logging.NOTSET)):
+            traceback.print_exc()
+        if args.v:
+            disableSysOut(disable=False)
+            return
+        closeWorkersAndExit()
+        exitGracefully()
+        sys.exit(0)
+
+
+def scheduleNextRun():
+    sleepUntilNextExecution = not PKDateUtilities.isTradingTime()
+    while sleepUntilNextExecution:
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + (
+                "SecondsAfterClosingTime[%d] SecondsBeforeMarketOpen [%d]. Next run at [%s]"
+                % (
+                    int(PKDateUtilities.secondsAfterCloseTime()),
+                    int(PKDateUtilities.secondsBeforeOpenTime()),
+                    str(
+                        PKDateUtilities.nextRunAtDateTime(
+                            bufferSeconds=3600,
+                            cronWaitSeconds=int(args.croninterval),
+                        )
+                    ),
+                )
+            )
+            + colorText.END
+        )
+        if (PKDateUtilities.secondsAfterCloseTime() >= 3600) and (
+            PKDateUtilities.secondsAfterCloseTime() <= (3600 + 1.5 * int(args.croninterval))
+        ):
+            sleepUntilNextExecution = False
+        if (PKDateUtilities.secondsBeforeOpenTime() <= -3600) and (
+            PKDateUtilities.secondsBeforeOpenTime() >= (-3600 - 1.5 * int(args.croninterval))
+        ):
+            sleepUntilNextExecution = False
+        sleep(int(args.croninterval))
+    global cron_runs
+    if cron_runs > 0:
+        OutputControls().printOutput(
+            colorText.BOLD + colorText.GREEN + f'=> Going to fetch again in {int(args.croninterval)} sec. at {(PKDateUtilities.currentDateTime() + datetime.timedelta(seconds=120)).strftime("%Y-%m-%d %H:%M:%S")} IST...' + colorText.END,
+            end="\r",
+            flush=True,
+        )
+        sleep(int(args.croninterval) if not args.testbuild else 3)
+    runApplication()
+    cron_runs += 1
+
+if __name__ == "__main__":
+    try:
+        pkscreenercli()
+    except KeyboardInterrupt:
+        sys.exit(0)
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ArtTexts.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ArtTexts.py`

 * *Ordering differences only*

 * *Files 4% similar despite different names*

```diff
@@ -1,130 +1,130 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-# Doh, Collosol, Roman, Univers, Electronic
-artText_Doh = """
-PPPPPPPPPPPPPPPPP   KKKKKKKKK    KKKKKKK   SSSSSSSSSSSSSSS                                                                                                                                         TM
-UPI:8007162973@APL  K:::::::K    K:::::K SS:::::::::::::::S
-P::::::PPPPPP:::::P K:::::::K    K:::::KS:::::SSSSSS::::::S
-PP:::::P     P:::::PK:::::::K   K::::::KS:::::S     SSSSSSS
-  P::::P     P:::::P K::::::K  K:::::K  S:::::S                ccccccccccccccccrrrrr   rrrrrrrrr       eeeeeeeeeeee        eeeeeeeeeeee    nnnn  nnnnnnnn        eeeeeeeeeeee    rrrrr   rrrrrrrrr
-  P::::P     P:::::P  K:::::K K:::::K   S:::::S              cc::::MADE:::::::cr::::rrr::WITH::::r    ee::::LOVE::::ee    ee:::::IN:::::ee  n:::nn:INDIA:nn    ee::::::::::::ee  r::::rrr:::::::::r
-  P::::PPPPPP:::::P   K::::::K:::::K     S::::SSSS          c:::::::::::::::::cr:::::::::::::::::r  e::::::eeeee:::::ee e::::::eeeee:::::een::::::::::::::nn  e::::::eeeee:::::eer::::PKJMESRA::::r
-  P:::::::::::::PP    K:::::::::::K       SS::::::SSSSS    c:::::::cccccc:::::crr::::::rrrrr::::::re::::::e     e:::::ee::::::e     e:::::enn:::::::::::::::ne::::::e     e:::::err::::::rrrrr::::::r
-  P::::PPPPPPPPP      K:::::::::::K         SSS::::::::SS  c::::::c     ccccccc r:::::r     r:::::re:::::::eeeee::::::ee:::::::eeeee::::::e  n:::::nnnn:::::ne:::::::eeeee::::::e r:::::r     r:::::r
-  P::::P              K::::::K:::::K           SSSSSS::::S c:::::c              r:::::r     rrrrrrre:::::::::::::::::e e:::::::::::::::::e   n::::n    n::::ne:::::::::::::::::e  r:::::r     rrrrrrr
-  P::::P              K:::::K K:::::K               S:::::Sc:::::c              r:::::r            e::::::eeeeeeeeeee  e::::::eeeeeeeeeee    n::::n    n::::ne::::::eeeeeeeeeee   r:::::r
-  P::::P              K:::::K  K:::::K              S:::::Sc::::::c     ccccccc r:::::r            e:::::::e           e:::::::e             n::::n    n::::ne:::::::e            r:::::r
-PP::::::PP            K:::::K   K::::::KSSSSSSS     S:::::Sc:::::::cccccc:::::c r:::::r            e::::::::e          e::::::::e            n::::n    n::::ne::::::::e           r:::::r
-P::::::::P            K:::::K    K:::::KS::::::SSSSSS:::::S c:::::::::::::::::c r:::::r             e::::::::eeeeeeee   e::::::::eeeeeeee    n::::n    n::::n e::::::::eeeeeeee   r:::::r
-P::::::::P            K:::::K    K:::::KS:::::::::::::::S    cc:::::::::::::::c r:::::r              ee:::::::::::::e    ee:::::::::::::e    n::::n    n::::n  ee:::::::::::::e   r:::::r
-PPPPPPPPPP            KKKKKKK    KKKKKKK SSSSSSSSSSSSSSS       cccccccccccccccc rrrrrrr                eeeeeeeeeeeeee      eeeeeeeeeeeeee    nnnnnn    nnnnnn    eeeeeeeeeeeeee   rrrrrrr
-"""
-artText_Collosol = """
-8888888b.  888    d8P   .d8888b.                                                            TM
-888   Y88b 888   d8P   d88P  Y88b
-888    888 888  d8P    Y88b. 
-888   d88P 888d88K      "Y888b.    .d8888b 888d888  .d88b.   .d88b.  88888b.   .d88b.  888d888
-8888888P"  8888888b        "Y88b. d88P"    888P"   d8P  Y8b d8P  Y8b 888 "88b d8P  Y8b 888P"
-888        888  Y88b         "888 888      888     88888888 88888888 888  888 88888888 888
-888        888   Y88b  Y88b  d88P Y88b.    888     Y8b.     Y8b.     888  888 Y8b.     888
-888        888    Y88b  "Y8888P"   "Y8888P 888      "Y8888   "Y8888  888  888  "Y8888  888
-"""
-
-artText_Roman="""
-ooooooooo.   oooo    oooo  .oooooo..o                                                                    TM
-`888   `Y88. `888   .8P'  d8P'    `Y8 
- 888   .d88'  888  d8'    Y88bo.       .ooooo.  oooo d8b  .ooooo.   .ooooo.  ooo. .oo.    .ooooo.  oooo d8b
- 888ooo88P'   88888[       `"Y8888o.  d88' `"Y8 `888""8P d88' `88b d88' `88b `888P"Y88b  d88' `88b `888""8P
- 888          888`88b.         `"Y88b 888        888     888ooo888 888ooo888  888   888  888ooo888  888
- 888          888  `88b.  oo     .d8P 888   .o8  888     888    .o 888    .o  888   888  888    .o  888
-o888o        o888o  o888o 8""88888P'  `Y8bod8P' d888b    `Y8bod8P' `Y8bod8P' o888o o888o `Y8bod8P' d888b
-"""
-artText_Electronic="""
-                      TM
-        
-      
-                                                                       
-               
-                
-                
-                                                                       
-                            
-                               
-                                                   
- """
-artText_Epic="""
- _______ _       _______ _______ _______ _______ _______ _       _______ _______TM 
-(  ____ | \    /(  ____ (  ____ (  ____ (  ____ (  ____ ( (    /(  ____ (  ____ )
-| (    )|  \  / | (    \| (    \| (    )| (    \| (    \|  \  ( | (    \| (    )|
-| (____)|  (_/ /| (_____| |     | (____)| (__   | (__   |   \ | | (__   | (____)|
-|  _____|   _ ( (_____  | |     |     __|  __)  |  __)  | (\ \) |  __)  |     __)
-| (     |  ( \ \      ) | |     | (\ (  | (     | (     | | \   | (     | (\ (   
-| )     |  /  \ /\____) | (____/| ) \ \_| (____/| (____/| )  \  | (____/| ) \ \__
-|/      |_/    \\_______(_______|/   \__(_______(_______|/    )_(_______|/   \__/
-"""
-artText_Isometric3="""
-      ___      ___         ___         ___         ___         ___         ___         ___         ___         ___  TM 
-     /  /\    /__/|       /  /\       /  /\       /  /\       /  /\       /  /\       /__/\       /  /\       /  /\    
-    /  /::\  |  |:|      /  /:/_     /  /:/      /  /::\     /  /:/_     /  /:/_      \  \:\     /  /:/_     /  /::\   
-   /  /:/\:\ |  |:|     /  /:/ /\   /  /:/      /  /:/\:\   /  /:/ /\   /  /:/ /\      \  \:\   /  /:/ /\   /  /:/\:\  
-  /  /:/~/:__|  |:|    /  /:/ /::\ /  /:/  ___ /  /:/~/:/  /  /:/ /:/_ /  /:/ /:/_ _____\__\:\ /  /:/ /:/_ /  /:/~/:/  
- /__/:/ /:/__/\_|:|___/__/:/ /:/\:/__/:/  /  //__/:/ /:/__/__/:/ /:/ //__/:/ /:/ //__/::::::::/__/:/ /:/ //__/:/ /:/___
- \  \:\/:/\  \:\/:::::\  \:\/:/~/:\  \:\ /  /:\  \:\/:::::\  \:\/:/ /:\  \:\/:/ /:\  \:\~~\~~\\  \:\/:/ /:\  \:\/::::::/ 
-  \  \::/  \  \::/~~~~ \  \::/ /:/ \  \:\  /:/ \  \::/~~~~ \  \::/ /:/ \  \::/ /:/ \  \:\  ~~~ \  \::/ /:/ \  \::/~~~~/  
-   \  \:\   \  \:\      \__\/ /:/   \  \:\/:/   \  \:\      \  \:\/:/   \  \:\/:/   \  \:\      \  \:\/:/   \  \:\     
-    \  \:\   \  \:\       /__/:/     \  \::/     \  \:\      \  \::/     \  \::/     \  \:\      \  \::/     \  \:\    
-     \__\/    \__\/       \__\/       \__\/       \__\/       \__\/       \__\/       \__\/       \__\/       \__\/    
-"""
-artText_FlowerPower="""
-.-------..--.   .--.    .-'''-.    _______  .-------.       .-''-.     .-''-. ,---.   .--.   .-''-. .-------. TM  
-\  _(`)_ |  | _/  /    / _     \  /   __  \ |  _ _   \    .'_ _   \  .'_ _   \|    \  |  | .'_ _   \|  _ _   \    
-| (_ o._)| (`' ) /    (`' )/`--' | ,_/  \__)| ( ' )  |   / ( ` )   '/ ( ` )   |  ,  \ |  |/ ( ` )   | ( ' )  |    
-|  (_,_) |(_ ()_)    (_ o _).  ,-./  )      |(_ o _) /  . (_ o _)  . (_ o _)  |  |\_ \|  . (_ o _)  |(_ o _) /    
-|   '-.-'| (_,_)   __ (_,_). '.\  '_ '`)    | (_,_).' __|  (_,_)___|  (_,_)___|  _( )_\  |  (_,_)___| (_,_).' __  
-|   |    |  |\ \  |  .---.  \  :> (_)  )  __|  |\ \  |  '  \   .---'  \   .---| (_ o _)  '  \   .---|  |\ \  |  | 
-|   |    |  | \ `'   \    `-'  (  .  .-'_/  |  | \ `'   /\  `-'    /\  `-'    |  (_,_)\  |\  `-'    |  | \ `'   / 
-/   )    |  |  \    / \       / `-'`-'     /|  |  \    /  \       /  \       /|  |    |  | \       /|  |  \    /  
-`---'    `--'   `'-'   `-...-'    `._____.' ''-'   `'-'    `'-..-'    `'-..-' '--'    '--'  `'-..-' ''-'   `'-'   
-"""
-artText_Impossible="""
-         _         _           _            _            _          _           _           _            _           _   TM 
-        /\ \      /\_\        / /\        /\ \          /\ \       /\ \        /\ \        /\ \     _   /\ \        /\ \    
-       /  \ \    / / /  _    / /  \      /  \ \        /  \ \     /  \ \      /  \ \      /  \ \   /\_\/  \ \      /  \ \   
-      / /\ \ \  / / /  /\_\ / / /\ \__  / /\ \ \      / /\ \ \   / /\ \ \    / /\ \ \    / /\ \ \_/ / / /\ \ \    / /\ \ \  
-     / / /\ \_\/ / /__/ / // / /\ \___\/ / /\ \ \    / / /\ \_\ / / /\ \_\  / / /\ \_\  / / /\ \___/ / / /\ \_\  / / /\ \_\ 
-    / / /_/ / / /\_____/ / \ \ \ \/___/ / /  \ \_\  / / /_/ / // /_/_ \/_/ / /_/_ \/_/ / / /  \/____/ /_/_ \/_/ / / /_/ / / 
-   / / /__\/ / /\_______/   \ \ \    / / /    \/_/ / / /__\/ // /____/\   / /____/\   / / /    / / / /____/\   / / /__\/ /  
-  / / /_____/ / /\ \ \  _    \ \ \  / / /         / / /_____// /\____\/  / /\____\/  / / /    / / / /\____\/  / / /_____/   
- / / /     / / /  \ \ \/_/\__/ / / / / /________ / / /\ \ \ / / /______ / / /______ / / /    / / / / /______ / / /\ \ \     
-/ / /     / / /    \ \ \ \/___/ / / / /_________/ / /  \ \ / / /_______/ / /_______/ / /    / / / / /_______/ / /  \ \ \    
-\/_/      \/_/      \_\_\_____\/  \/____________\/_/    \_\\/__________\/__________\/_/     \/_/\/__________\/_/    \_\/    
-"""
-import random
-
-def getArtText():
-    artTexts = [artText_Doh,artText_Collosol,artText_Roman,artText_Electronic,artText_Epic,artText_Isometric3,artText_FlowerPower,artText_Impossible]
-    artTexts.extend(artTexts)
-    random.shuffle(artTexts)
-    return random.choice(artTexts)
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+# Doh, Collosol, Roman, Univers, Electronic
+artText_Doh = """
+PPPPPPPPPPPPPPPPP   KKKKKKKKK    KKKKKKK   SSSSSSSSSSSSSSS                                                                                                                                         TM
+UPI:8007162973@APL  K:::::::K    K:::::K SS:::::::::::::::S
+P::::::PPPPPP:::::P K:::::::K    K:::::KS:::::SSSSSS::::::S
+PP:::::P     P:::::PK:::::::K   K::::::KS:::::S     SSSSSSS
+  P::::P     P:::::P K::::::K  K:::::K  S:::::S                ccccccccccccccccrrrrr   rrrrrrrrr       eeeeeeeeeeee        eeeeeeeeeeee    nnnn  nnnnnnnn        eeeeeeeeeeee    rrrrr   rrrrrrrrr
+  P::::P     P:::::P  K:::::K K:::::K   S:::::S              cc::::MADE:::::::cr::::rrr::WITH::::r    ee::::LOVE::::ee    ee:::::IN:::::ee  n:::nn:INDIA:nn    ee::::::::::::ee  r::::rrr:::::::::r
+  P::::PPPPPP:::::P   K::::::K:::::K     S::::SSSS          c:::::::::::::::::cr:::::::::::::::::r  e::::::eeeee:::::ee e::::::eeeee:::::een::::::::::::::nn  e::::::eeeee:::::eer::::PKJMESRA::::r
+  P:::::::::::::PP    K:::::::::::K       SS::::::SSSSS    c:::::::cccccc:::::crr::::::rrrrr::::::re::::::e     e:::::ee::::::e     e:::::enn:::::::::::::::ne::::::e     e:::::err::::::rrrrr::::::r
+  P::::PPPPPPPPP      K:::::::::::K         SSS::::::::SS  c::::::c     ccccccc r:::::r     r:::::re:::::::eeeee::::::ee:::::::eeeee::::::e  n:::::nnnn:::::ne:::::::eeeee::::::e r:::::r     r:::::r
+  P::::P              K::::::K:::::K           SSSSSS::::S c:::::c              r:::::r     rrrrrrre:::::::::::::::::e e:::::::::::::::::e   n::::n    n::::ne:::::::::::::::::e  r:::::r     rrrrrrr
+  P::::P              K:::::K K:::::K               S:::::Sc:::::c              r:::::r            e::::::eeeeeeeeeee  e::::::eeeeeeeeeee    n::::n    n::::ne::::::eeeeeeeeeee   r:::::r
+  P::::P              K:::::K  K:::::K              S:::::Sc::::::c     ccccccc r:::::r            e:::::::e           e:::::::e             n::::n    n::::ne:::::::e            r:::::r
+PP::::::PP            K:::::K   K::::::KSSSSSSS     S:::::Sc:::::::cccccc:::::c r:::::r            e::::::::e          e::::::::e            n::::n    n::::ne::::::::e           r:::::r
+P::::::::P            K:::::K    K:::::KS::::::SSSSSS:::::S c:::::::::::::::::c r:::::r             e::::::::eeeeeeee   e::::::::eeeeeeee    n::::n    n::::n e::::::::eeeeeeee   r:::::r
+P::::::::P            K:::::K    K:::::KS:::::::::::::::S    cc:::::::::::::::c r:::::r              ee:::::::::::::e    ee:::::::::::::e    n::::n    n::::n  ee:::::::::::::e   r:::::r
+PPPPPPPPPP            KKKKKKK    KKKKKKK SSSSSSSSSSSSSSS       cccccccccccccccc rrrrrrr                eeeeeeeeeeeeee      eeeeeeeeeeeeee    nnnnnn    nnnnnn    eeeeeeeeeeeeee   rrrrrrr
+"""
+artText_Collosol = """
+8888888b.  888    d8P   .d8888b.                                                            TM
+888   Y88b 888   d8P   d88P  Y88b
+888    888 888  d8P    Y88b. 
+888   d88P 888d88K      "Y888b.    .d8888b 888d888  .d88b.   .d88b.  88888b.   .d88b.  888d888
+8888888P"  8888888b        "Y88b. d88P"    888P"   d8P  Y8b d8P  Y8b 888 "88b d8P  Y8b 888P"
+888        888  Y88b         "888 888      888     88888888 88888888 888  888 88888888 888
+888        888   Y88b  Y88b  d88P Y88b.    888     Y8b.     Y8b.     888  888 Y8b.     888
+888        888    Y88b  "Y8888P"   "Y8888P 888      "Y8888   "Y8888  888  888  "Y8888  888
+"""
+
+artText_Roman="""
+ooooooooo.   oooo    oooo  .oooooo..o                                                                    TM
+`888   `Y88. `888   .8P'  d8P'    `Y8 
+ 888   .d88'  888  d8'    Y88bo.       .ooooo.  oooo d8b  .ooooo.   .ooooo.  ooo. .oo.    .ooooo.  oooo d8b
+ 888ooo88P'   88888[       `"Y8888o.  d88' `"Y8 `888""8P d88' `88b d88' `88b `888P"Y88b  d88' `88b `888""8P
+ 888          888`88b.         `"Y88b 888        888     888ooo888 888ooo888  888   888  888ooo888  888
+ 888          888  `88b.  oo     .d8P 888   .o8  888     888    .o 888    .o  888   888  888    .o  888
+o888o        o888o  o888o 8""88888P'  `Y8bod8P' d888b    `Y8bod8P' `Y8bod8P' o888o o888o `Y8bod8P' d888b
+"""
+artText_Electronic="""
+                      TM
+        
+      
+                                                                       
+               
+                
+                
+                                                                       
+                            
+                               
+                                                   
+ """
+artText_Epic="""
+ _______ _       _______ _______ _______ _______ _______ _       _______ _______TM 
+(  ____ | \    /(  ____ (  ____ (  ____ (  ____ (  ____ ( (    /(  ____ (  ____ )
+| (    )|  \  / | (    \| (    \| (    )| (    \| (    \|  \  ( | (    \| (    )|
+| (____)|  (_/ /| (_____| |     | (____)| (__   | (__   |   \ | | (__   | (____)|
+|  _____|   _ ( (_____  | |     |     __|  __)  |  __)  | (\ \) |  __)  |     __)
+| (     |  ( \ \      ) | |     | (\ (  | (     | (     | | \   | (     | (\ (   
+| )     |  /  \ /\____) | (____/| ) \ \_| (____/| (____/| )  \  | (____/| ) \ \__
+|/      |_/    \\_______(_______|/   \__(_______(_______|/    )_(_______|/   \__/
+"""
+artText_Isometric3="""
+      ___      ___         ___         ___         ___         ___         ___         ___         ___         ___  TM 
+     /  /\    /__/|       /  /\       /  /\       /  /\       /  /\       /  /\       /__/\       /  /\       /  /\    
+    /  /::\  |  |:|      /  /:/_     /  /:/      /  /::\     /  /:/_     /  /:/_      \  \:\     /  /:/_     /  /::\   
+   /  /:/\:\ |  |:|     /  /:/ /\   /  /:/      /  /:/\:\   /  /:/ /\   /  /:/ /\      \  \:\   /  /:/ /\   /  /:/\:\  
+  /  /:/~/:__|  |:|    /  /:/ /::\ /  /:/  ___ /  /:/~/:/  /  /:/ /:/_ /  /:/ /:/_ _____\__\:\ /  /:/ /:/_ /  /:/~/:/  
+ /__/:/ /:/__/\_|:|___/__/:/ /:/\:/__/:/  /  //__/:/ /:/__/__/:/ /:/ //__/:/ /:/ //__/::::::::/__/:/ /:/ //__/:/ /:/___
+ \  \:\/:/\  \:\/:::::\  \:\/:/~/:\  \:\ /  /:\  \:\/:::::\  \:\/:/ /:\  \:\/:/ /:\  \:\~~\~~\\  \:\/:/ /:\  \:\/::::::/ 
+  \  \::/  \  \::/~~~~ \  \::/ /:/ \  \:\  /:/ \  \::/~~~~ \  \::/ /:/ \  \::/ /:/ \  \:\  ~~~ \  \::/ /:/ \  \::/~~~~/  
+   \  \:\   \  \:\      \__\/ /:/   \  \:\/:/   \  \:\      \  \:\/:/   \  \:\/:/   \  \:\      \  \:\/:/   \  \:\     
+    \  \:\   \  \:\       /__/:/     \  \::/     \  \:\      \  \::/     \  \::/     \  \:\      \  \::/     \  \:\    
+     \__\/    \__\/       \__\/       \__\/       \__\/       \__\/       \__\/       \__\/       \__\/       \__\/    
+"""
+artText_FlowerPower="""
+.-------..--.   .--.    .-'''-.    _______  .-------.       .-''-.     .-''-. ,---.   .--.   .-''-. .-------. TM  
+\  _(`)_ |  | _/  /    / _     \  /   __  \ |  _ _   \    .'_ _   \  .'_ _   \|    \  |  | .'_ _   \|  _ _   \    
+| (_ o._)| (`' ) /    (`' )/`--' | ,_/  \__)| ( ' )  |   / ( ` )   '/ ( ` )   |  ,  \ |  |/ ( ` )   | ( ' )  |    
+|  (_,_) |(_ ()_)    (_ o _).  ,-./  )      |(_ o _) /  . (_ o _)  . (_ o _)  |  |\_ \|  . (_ o _)  |(_ o _) /    
+|   '-.-'| (_,_)   __ (_,_). '.\  '_ '`)    | (_,_).' __|  (_,_)___|  (_,_)___|  _( )_\  |  (_,_)___| (_,_).' __  
+|   |    |  |\ \  |  .---.  \  :> (_)  )  __|  |\ \  |  '  \   .---'  \   .---| (_ o _)  '  \   .---|  |\ \  |  | 
+|   |    |  | \ `'   \    `-'  (  .  .-'_/  |  | \ `'   /\  `-'    /\  `-'    |  (_,_)\  |\  `-'    |  | \ `'   / 
+/   )    |  |  \    / \       / `-'`-'     /|  |  \    /  \       /  \       /|  |    |  | \       /|  |  \    /  
+`---'    `--'   `'-'   `-...-'    `._____.' ''-'   `'-'    `'-..-'    `'-..-' '--'    '--'  `'-..-' ''-'   `'-'   
+"""
+artText_Impossible="""
+         _         _           _            _            _          _           _           _            _           _   TM 
+        /\ \      /\_\        / /\        /\ \          /\ \       /\ \        /\ \        /\ \     _   /\ \        /\ \    
+       /  \ \    / / /  _    / /  \      /  \ \        /  \ \     /  \ \      /  \ \      /  \ \   /\_\/  \ \      /  \ \   
+      / /\ \ \  / / /  /\_\ / / /\ \__  / /\ \ \      / /\ \ \   / /\ \ \    / /\ \ \    / /\ \ \_/ / / /\ \ \    / /\ \ \  
+     / / /\ \_\/ / /__/ / // / /\ \___\/ / /\ \ \    / / /\ \_\ / / /\ \_\  / / /\ \_\  / / /\ \___/ / / /\ \_\  / / /\ \_\ 
+    / / /_/ / / /\_____/ / \ \ \ \/___/ / /  \ \_\  / / /_/ / // /_/_ \/_/ / /_/_ \/_/ / / /  \/____/ /_/_ \/_/ / / /_/ / / 
+   / / /__\/ / /\_______/   \ \ \    / / /    \/_/ / / /__\/ // /____/\   / /____/\   / / /    / / / /____/\   / / /__\/ /  
+  / / /_____/ / /\ \ \  _    \ \ \  / / /         / / /_____// /\____\/  / /\____\/  / / /    / / / /\____\/  / / /_____/   
+ / / /     / / /  \ \ \/_/\__/ / / / / /________ / / /\ \ \ / / /______ / / /______ / / /    / / / / /______ / / /\ \ \     
+/ / /     / / /    \ \ \ \/___/ / / / /_________/ / /  \ \ / / /_______/ / /_______/ / /    / / / / /_______/ / /  \ \ \    
+\/_/      \/_/      \_\_\_____\/  \/____________\/_/    \_\\/__________\/__________\/_/     \/_/\/__________\/_/    \_\/    
+"""
+import random
+
+def getArtText():
+    artTexts = [artText_Doh,artText_Collosol,artText_Roman,artText_Electronic,artText_Epic,artText_Isometric3,artText_FlowerPower,artText_Impossible]
+    artTexts.extend(artTexts)
+    random.shuffle(artTexts)
+    return random.choice(artTexts)
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Backtest.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Backtest.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,248 +1,248 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import warnings
-
-warnings.simplefilter("ignore", DeprecationWarning)
-warnings.simplefilter("ignore", FutureWarning)
-import pandas as pd
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.PKDateUtilities import PKDateUtilities
-from PKDevTools.classes.log import default_logger
-from pkscreener.classes import Utility
-from pkscreener.classes.ConfigManager import parser, tools
-
-configManager = tools()
-configManager.getConfig(parser)
-
-
-def backtest(
-    stock,
-    data,
-    saveDict=None,
-    screenedDict=None,
-    periods=30,
-    sampleDays=configManager.backtestPeriod,
-    backTestedData=None,
-    sellSignal=False,
-):
-    if stock == "" or data is None:
-        default_logger().debug(f"No data/stock {(stock)} received for backtesting!")
-        return
-    if screenedDict is None or len(screenedDict) == 0:
-        default_logger().debug(f"{(stock)}No backtesting strategy or screened dictionary received!")
-        return
-    calcPeriods = configManager.periodsRange
-    allStockBacktestData = []
-    # Take the data based on which the result set for a strategy may have been arrived at
-    # The results must have been arrived at with data based on configManager.backtestPeriod -sampleDays
-    # but we also need the periods days to be able to calculate the next few days' returns
-    # s1    d0
-    # s1    d1
-    # s1    d2  <----------------On this day the recommendation was made
-    # s1    d3  ^
-    #   ....    |
-    # s1    dn  |----------------We need to make calculations upto 30 day period from d2
-    previous_recent = data.head(
-        1
-    )  # This is the row which has the date for which the recommendation is valid
-    if len(previous_recent) <= 0:
-        return backTestedData
-    data = data.head(max(calcPeriods) + 1)
-    # Let's check the returns for the given strategy over a period ranging from 1 period to 30 periods.
-    # columns=['Stock', 'Date', 'Volume', 'Trend', 'MA-Signal', 'LTP', '52Wk H',
-    #          '52Wk L', '1-Pd', '2-Pd', '3-Pd', '4-Pd', '5-Pd', '10-Pd', '15-Pd',
-    #          '22-Pd', '30-Pd', 'Consol.', 'Breakout', 'RSI', 'Pattern', 'CCI',
-    #          'LTP1', 'Growth1', 'LTP2', 'Growth2', 'LTP3', 'Growth3', 'LTP4',
-    #          'Growth4', 'LTP5', 'Growth5', 'LTP10', 'Growth10', 'LTP15', 'Growth15',
-    #          'LTP22', 'Growth22', 'LTP30', 'Growth30']
-    
-    # incoming = list(saveDict.keys())
-    # for prd in calcPeriods:
-    #     colNames = [f"LTP{prd}",f"Growth{prd}",f"{prd}-Pd"]
-    #     if colNames[0] not in incoming:
-    #         for col in colNames:
-    #             columns.remove(col)
-    # if backTestedData is None:
-    #     backTestedData = pd.DataFrame(columns=columns)
-    # df = pd.DataFrame([screenedDict],columns=columns)
-    # df[f"LTP{prd}"] = saveDict[f"LTP{prd}"]
-    # df[f"Growth{prd}"] = saveDict[f"Growth{prd}"]
-    columns=[
-                "Stock",
-                "Date",
-                "Volume",
-                "Trend",
-                "MA-Signal",
-                "LTP",
-                "52Wk H",
-                "52Wk L"
-            ]
-    backTestedStock = {
-        "Stock": "",
-        "Date": "",
-        "Volume": "",
-        "Trend": "",
-        "MA-Signal": "",
-        "LTP": "",
-        "52Wk H": "",
-        "52Wk L": ""
-    }
-    for prd in calcPeriods:
-        columns.append(f"{prd}-Pd")
-        backTestedStock[f"{prd}-Pd"] = ""
-    if backTestedData is None:
-        backTestedData = pd.DataFrame(columns=columns)
-    backTestedStock["Stock"] = stock
-    backTestedStock["Date"] = saveDict["Date"]
-    backTestedStock["Consol."] = screenedDict["Consol."]
-    backTestedStock["Breakout"] = screenedDict["Breakout"]
-    backTestedStock["MA-Signal"] = screenedDict["MA-Signal"]
-    backTestedStock["Volume"] = screenedDict["Volume"]
-    backTestedStock["LTP"] = screenedDict["LTP"]
-    backTestedStock["52Wk H"] = screenedDict["52Wk H"]
-    backTestedStock["52Wk L"] = screenedDict["52Wk L"]
-    backTestedStock["RSI"] = screenedDict["RSI"]
-    backTestedStock["Trend"] = screenedDict["Trend"]
-    backTestedStock["Pattern"] = screenedDict["Pattern"]
-    backTestedStock["CCI"] = screenedDict["CCI"]
-    for prd in calcPeriods:
-        try:
-            backTestedStock[f"{abs(prd)}-Pd"] = ""
-            backTestedStock[f"LTP{prd}"] = ""
-            backTestedStock[f"Growth{prd}"] = ""
-            rolling_pct = data["Close"].pct_change(periods=prd) * 100
-            pct_change = rolling_pct.iloc[prd]
-            if not sellSignal:
-                colored_pct = colorText.GREEN if pct_change >= 0 else colorText.FAIL
-            else:
-                colored_pct = colorText.FAIL if pct_change >= 0 else colorText.GREEN
-            backTestedStock[f"{abs(prd)}-Pd"] = (
-                colored_pct + "%.2f%%" % pct_change + colorText.END
-            )
-        except Exception:# pragma: no cover
-            pass
-        # Let's capture the portfolio data, if available
-        try:
-            backTestedStock[f"LTP{prd}"] = saveDict[f"LTP{prd}"]
-            backTestedStock[f"Growth{prd}"] = saveDict[f"Growth{prd}"]
-        except Exception:# pragma: no cover
-            pass
-        # else:
-        #     del backTestedStock[f"{abs(prd)}-Pd"]
-        #     try:
-        #         backTestedData = backTestedData.drop(f"{abs(prd)}-Pd", axis=1)
-        #     except Exception:
-        #         continue
-    allStockBacktestData.append(backTestedStock)
-    df = pd.DataFrame(allStockBacktestData)  # , columns=backTestedData.columns)
-    try:
-        backTestedData = pd.concat([backTestedData, df])
-    except Exception:# pragma: no cover
-        pass
-    return backTestedData
-
-
-def backtestSummary(df):
-    summary = {}
-    overall = {}
-    summaryList = []
-    net_positives = 0
-    net_negatives = 0
-    if df is None:
-        return
-    df.drop_duplicates(inplace=True)
-    df_grouped = df.groupby("Stock")
-    for col in df.keys():
-        if str(col).endswith("-Pd"):
-            overall[col] = [0, 0]
-    # iterate over each group of stock rows
-    for stock_name, df_group in df_grouped:
-        # for row_index, row in df_group.iterrows():
-        group_positives = 0
-        group_negatives = 0
-        summary["Stock"] = stock_name
-        for col in df_group.keys():
-            if str(col).endswith("-Pd"):
-                col_positives = (
-                    df_group[col]
-                    .astype(str)
-                    .str.count(colorText.GREEN.replace("[", "\["))
-                    .sum()
-                )
-                col_negatives = (
-                    df_group[col]
-                    .astype(str)
-                    .str.count(colorText.FAIL.replace("[", "\["))
-                    .sum()
-                )
-                group_positives += col_positives
-                group_negatives += col_negatives
-                overall[col] = [
-                    overall[col][0] + col_positives,
-                    overall[col][1] + col_negatives,
-                ]
-                overAllPeriodPrediction = (
-                    col_positives * 100 / (col_positives + col_negatives)
-                )
-                if col_positives + col_negatives == 0:
-                    summary[col] = "-"
-                else:
-                    summary[
-                        col
-                    ] = f"{Utility.tools.formattedBacktestOutput(overAllPeriodPrediction)} of ({col_positives+col_negatives})"
-        overAllRowPrediction = (
-            group_positives * 100 / (group_positives + group_negatives)
-        )
-        if group_positives + group_negatives == 0:
-            summary["Overall"] = "-"
-        else:
-            summary[
-                "Overall"
-            ] = f"{Utility.tools.formattedBacktestOutput(overAllRowPrediction)} of ({group_positives+group_negatives})"
-        summaryList.append(summary)
-        summary = {}
-        net_positives += group_positives
-        net_negatives += group_negatives
-
-    # Now prepare overall summary
-    summary["Stock"] = "SUMMARY"
-    for col in overall.keys():
-        col_positives = overall[col][0]
-        col_negatives = overall[col][1]
-        if col_positives + col_negatives == 0:
-            summary[col] = "-"
-        else:
-            summary[
-                col
-            ] = f"{Utility.tools.formattedBacktestOutput((col_positives*100/(col_positives+col_negatives)))} of ({col_positives+col_negatives})"
-    if net_positives + net_negatives == 0:
-        summary["Overall"] = "-"
-    else:
-        summary[
-            "Overall"
-        ] = f"{Utility.tools.formattedBacktestOutput(net_positives*100/(net_positives+net_negatives))} of ({net_positives+net_negatives})"
-    summaryList.append(summary)
-    summary_df = pd.DataFrame(summaryList, columns=summary.keys())
-    return summary_df
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import warnings
+
+warnings.simplefilter("ignore", DeprecationWarning)
+warnings.simplefilter("ignore", FutureWarning)
+import pandas as pd
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.PKDateUtilities import PKDateUtilities
+from PKDevTools.classes.log import default_logger
+from pkscreener.classes import Utility
+from pkscreener.classes.ConfigManager import parser, tools
+
+configManager = tools()
+configManager.getConfig(parser)
+
+
+def backtest(
+    stock,
+    data,
+    saveDict=None,
+    screenedDict=None,
+    periods=30,
+    sampleDays=configManager.backtestPeriod,
+    backTestedData=None,
+    sellSignal=False,
+):
+    if stock == "" or data is None:
+        default_logger().debug(f"No data/stock {(stock)} received for backtesting!")
+        return
+    if screenedDict is None or len(screenedDict) == 0:
+        default_logger().debug(f"{(stock)}No backtesting strategy or screened dictionary received!")
+        return
+    calcPeriods = configManager.periodsRange
+    allStockBacktestData = []
+    # Take the data based on which the result set for a strategy may have been arrived at
+    # The results must have been arrived at with data based on configManager.backtestPeriod -sampleDays
+    # but we also need the periods days to be able to calculate the next few days' returns
+    # s1    d0
+    # s1    d1
+    # s1    d2  <----------------On this day the recommendation was made
+    # s1    d3  ^
+    #   ....    |
+    # s1    dn  |----------------We need to make calculations upto 30 day period from d2
+    previous_recent = data.head(
+        1
+    )  # This is the row which has the date for which the recommendation is valid
+    if len(previous_recent) <= 0:
+        return backTestedData
+    data = data.head(max(calcPeriods) + 1)
+    # Let's check the returns for the given strategy over a period ranging from 1 period to 30 periods.
+    # columns=['Stock', 'Date', 'Volume', 'Trend', 'MA-Signal', 'LTP', '52Wk H',
+    #          '52Wk L', '1-Pd', '2-Pd', '3-Pd', '4-Pd', '5-Pd', '10-Pd', '15-Pd',
+    #          '22-Pd', '30-Pd', 'Consol.', 'Breakout', 'RSI', 'Pattern', 'CCI',
+    #          'LTP1', 'Growth1', 'LTP2', 'Growth2', 'LTP3', 'Growth3', 'LTP4',
+    #          'Growth4', 'LTP5', 'Growth5', 'LTP10', 'Growth10', 'LTP15', 'Growth15',
+    #          'LTP22', 'Growth22', 'LTP30', 'Growth30']
+    
+    # incoming = list(saveDict.keys())
+    # for prd in calcPeriods:
+    #     colNames = [f"LTP{prd}",f"Growth{prd}",f"{prd}-Pd"]
+    #     if colNames[0] not in incoming:
+    #         for col in colNames:
+    #             columns.remove(col)
+    # if backTestedData is None:
+    #     backTestedData = pd.DataFrame(columns=columns)
+    # df = pd.DataFrame([screenedDict],columns=columns)
+    # df[f"LTP{prd}"] = saveDict[f"LTP{prd}"]
+    # df[f"Growth{prd}"] = saveDict[f"Growth{prd}"]
+    columns=[
+                "Stock",
+                "Date",
+                "Volume",
+                "Trend",
+                "MA-Signal",
+                "LTP",
+                "52Wk H",
+                "52Wk L"
+            ]
+    backTestedStock = {
+        "Stock": "",
+        "Date": "",
+        "Volume": "",
+        "Trend": "",
+        "MA-Signal": "",
+        "LTP": "",
+        "52Wk H": "",
+        "52Wk L": ""
+    }
+    for prd in calcPeriods:
+        columns.append(f"{prd}-Pd")
+        backTestedStock[f"{prd}-Pd"] = ""
+    if backTestedData is None:
+        backTestedData = pd.DataFrame(columns=columns)
+    backTestedStock["Stock"] = stock
+    backTestedStock["Date"] = saveDict["Date"]
+    backTestedStock["Consol."] = screenedDict["Consol."]
+    backTestedStock["Breakout"] = screenedDict["Breakout"]
+    backTestedStock["MA-Signal"] = screenedDict["MA-Signal"]
+    backTestedStock["Volume"] = screenedDict["Volume"]
+    backTestedStock["LTP"] = screenedDict["LTP"]
+    backTestedStock["52Wk H"] = screenedDict["52Wk H"]
+    backTestedStock["52Wk L"] = screenedDict["52Wk L"]
+    backTestedStock["RSI"] = screenedDict["RSI"]
+    backTestedStock["Trend"] = screenedDict["Trend"]
+    backTestedStock["Pattern"] = screenedDict["Pattern"]
+    backTestedStock["CCI"] = screenedDict["CCI"]
+    for prd in calcPeriods:
+        try:
+            backTestedStock[f"{abs(prd)}-Pd"] = ""
+            backTestedStock[f"LTP{prd}"] = ""
+            backTestedStock[f"Growth{prd}"] = ""
+            rolling_pct = data["Close"].pct_change(periods=prd) * 100
+            pct_change = rolling_pct.iloc[prd]
+            if not sellSignal:
+                colored_pct = colorText.GREEN if pct_change >= 0 else colorText.FAIL
+            else:
+                colored_pct = colorText.FAIL if pct_change >= 0 else colorText.GREEN
+            backTestedStock[f"{abs(prd)}-Pd"] = (
+                colored_pct + "%.2f%%" % pct_change + colorText.END
+            )
+        except Exception:# pragma: no cover
+            pass
+        # Let's capture the portfolio data, if available
+        try:
+            backTestedStock[f"LTP{prd}"] = saveDict[f"LTP{prd}"]
+            backTestedStock[f"Growth{prd}"] = saveDict[f"Growth{prd}"]
+        except Exception:# pragma: no cover
+            pass
+        # else:
+        #     del backTestedStock[f"{abs(prd)}-Pd"]
+        #     try:
+        #         backTestedData = backTestedData.drop(f"{abs(prd)}-Pd", axis=1)
+        #     except Exception:
+        #         continue
+    allStockBacktestData.append(backTestedStock)
+    df = pd.DataFrame(allStockBacktestData)  # , columns=backTestedData.columns)
+    try:
+        backTestedData = pd.concat([backTestedData, df])
+    except Exception:# pragma: no cover
+        pass
+    return backTestedData
+
+
+def backtestSummary(df):
+    summary = {}
+    overall = {}
+    summaryList = []
+    net_positives = 0
+    net_negatives = 0
+    if df is None:
+        return
+    df.drop_duplicates(inplace=True)
+    df_grouped = df.groupby("Stock")
+    for col in df.keys():
+        if str(col).endswith("-Pd"):
+            overall[col] = [0, 0]
+    # iterate over each group of stock rows
+    for stock_name, df_group in df_grouped:
+        # for row_index, row in df_group.iterrows():
+        group_positives = 0
+        group_negatives = 0
+        summary["Stock"] = stock_name
+        for col in df_group.keys():
+            if str(col).endswith("-Pd"):
+                col_positives = (
+                    df_group[col]
+                    .astype(str)
+                    .str.count(colorText.GREEN.replace("[", "\["))
+                    .sum()
+                )
+                col_negatives = (
+                    df_group[col]
+                    .astype(str)
+                    .str.count(colorText.FAIL.replace("[", "\["))
+                    .sum()
+                )
+                group_positives += col_positives
+                group_negatives += col_negatives
+                overall[col] = [
+                    overall[col][0] + col_positives,
+                    overall[col][1] + col_negatives,
+                ]
+                overAllPeriodPrediction = (
+                    col_positives * 100 / (col_positives + col_negatives)
+                )
+                if col_positives + col_negatives == 0:
+                    summary[col] = "-"
+                else:
+                    summary[
+                        col
+                    ] = f"{Utility.tools.formattedBacktestOutput(overAllPeriodPrediction)} of ({col_positives+col_negatives})"
+        overAllRowPrediction = (
+            group_positives * 100 / (group_positives + group_negatives)
+        )
+        if group_positives + group_negatives == 0:
+            summary["Overall"] = "-"
+        else:
+            summary[
+                "Overall"
+            ] = f"{Utility.tools.formattedBacktestOutput(overAllRowPrediction)} of ({group_positives+group_negatives})"
+        summaryList.append(summary)
+        summary = {}
+        net_positives += group_positives
+        net_negatives += group_negatives
+
+    # Now prepare overall summary
+    summary["Stock"] = "SUMMARY"
+    for col in overall.keys():
+        col_positives = overall[col][0]
+        col_negatives = overall[col][1]
+        if col_positives + col_negatives == 0:
+            summary[col] = "-"
+        else:
+            summary[
+                col
+            ] = f"{Utility.tools.formattedBacktestOutput((col_positives*100/(col_positives+col_negatives)))} of ({col_positives+col_negatives})"
+    if net_positives + net_negatives == 0:
+        summary["Overall"] = "-"
+    else:
+        summary[
+            "Overall"
+        ] = f"{Utility.tools.formattedBacktestOutput(net_positives*100/(net_positives+net_negatives))} of ({net_positives+net_negatives})"
+    summaryList.append(summary)
+    summary_df = pd.DataFrame(summaryList, columns=summary.keys())
+    return summary_df
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Barometer.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Barometer.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,104 +1,104 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-
-import asyncio
-import os
-import datetime
-from PIL import Image,ImageDraw,ImageFont
-try:
-    from pyppeteer import launch
-except:
-    pass
-from PKDevTools.classes import Archiver
-from pkscreener.classes import Utility
-from pkscreener.classes.MarketStatus import MarketStatus
-
-async def getScreenshotsForGlobalMarketBarometer():
-    # https://scrapeops.io/python-web-scraping-playbook/python-pyppeteer/#how-to-click-on-buttons-with-pyppeteer
-    folderPath = Archiver.get_user_outputs_dir()
-    browser = await launch()
-    page = await browser.newPage()
-    await page.goto('https://www.morningstar.com/markets/global-market-view',timeout=10000, waitUntil=['load','domcontentloaded','networkidle0'])
-    # Get the latest date for which this GMB is being loaded
-    dateElement = await page.querySelector(selector='.date-label')
-    date = await page.evaluate('(dateElement) => dateElement.textContent', dateElement)
-    await page.waitFor(selectorOrFunctionOrTimeout=2000)
-    # Show the india hover tooltip. If you don't do this, the screenshot if only 50% of the map
-    await page.hover(selector='.country-India')
-    hoverElement = await page.querySelector(selector='.mbc-chart-tooltip-container')
-    await page.evaluate('(hoverElement) => hoverElement.innerHTML=hoverElement.innerHTML.replaceAll("Morningstar","").replaceAll("GR INR","Performance")', hoverElement)
-
-    # Hide the india tooltip. This will force the map to appear properly for screenshot
-    # await page.hover(selector='.date-label')
-    # Take the screenshot
-    await page.screenshot({'path': os.path.join(folderPath,'gmbstat.png'), 'clip': {"x":50,"y":440,"width":710,"height":460}})
-
-    # Let's find the valuation of the market
-    btnValuation = await page.querySelector(selector='button#valuation')
-    await page.evaluate('(btnValuation) => btnValuation.click()', btnValuation)
-    await page.waitForSelector(selector='.country-India')
-    await page.waitFor(selectorOrFunctionOrTimeout=2000)
-    await page.hover(selector='.country-India')
-    await page.evaluate('(hoverElement) => hoverElement.innerHTML=hoverElement.innerHTML.replaceAll("Morningstar","").replaceAll("GR INR","Valuation")', hoverElement)
-    await page.screenshot({'path': os.path.join(folderPath,'gmbvaluation.png'), 'clip': {"x":45,"y":420,"width":710,"height":450}})
-    await browser.close()
-
-def getGlobalMarketBarometerValuation():
-    try:
-        asyncio.get_event_loop().run_until_complete(getScreenshotsForGlobalMarketBarometer())
-    except:
-        pass
-    folderPath = Archiver.get_user_outputs_dir()
-    gmbPath = None
-    try:
-        gapHeight = 65
-        bgColor = (0,0,0)
-        fontPath = Utility.tools.setupReportFont()
-        artfont = ImageFont.truetype(fontPath, 12)
-        gmbPerformance = Image.open(os.path.join(folderPath,'gmbstat.png')) # 710 x 460
-        gmbValuation = Image.open(os.path.join(folderPath,'gmbvaluation.png')) # 710 x 450
-        gmbPerf_size = gmbPerformance.size
-        gmbValue_size = gmbValuation.size
-        # watermark = Utility.tools.getWatermarkImage(gmbPerformance)
-        gmbPerformance = Utility.tools.addQuickWatermark(gmbPerformance, dataSrc="Morningstar, Inc")
-        gmbValuation = Utility.tools.addQuickWatermark(gmbValuation, dataSrc="Morningstar, Inc")
-        gmbCombined = Image.new('RGB',(gmbPerf_size[0], gmbPerf_size[1]+gmbValue_size[1]+gapHeight), bgColor)
-        gmbCombined.paste(gmbPerformance,(0,0))
-        draw = ImageDraw.Draw(gmbCombined)
-        # artwork
-        nseMarketStatus = MarketStatus().getMarketStatus(exchangeSymbol="^NSEI",namedOnly=True)
-        bseMarketStatus = MarketStatus().getMarketStatus(exchangeSymbol="^BSESN",namedOnly=True)
-        nasdaqMarketStatus = MarketStatus().getMarketStatus(exchangeSymbol="^IXIC")
-        repoText = f'https://GitHub.com/pkjmesra/pkscreener/ |  {datetime.date.today().year} pkjmesra | https://t.me/PKScreener\n{nseMarketStatus}\n{bseMarketStatus}\n{nasdaqMarketStatus}'
-        draw.text((5, gmbPerf_size[1]+5), Utility.tools.removeAllColorStyles(repoText), font=artfont, fill="lightgreen")
-        gmbCombined.paste(gmbValuation,(0,gmbPerf_size[1]+gapHeight))
-        gmbCombined.save(os.path.join(folderPath,"gmb.png"),"PNG")
-        gmbPath = os.path.join(folderPath,"gmb.png")
-        # gmbCombined.show()
-    except: #Exception as e:
-        # print(e)
-        pass
-    return gmbPath
-
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+
+import asyncio
+import os
+import datetime
+from PIL import Image,ImageDraw,ImageFont
+try:
+    from pyppeteer import launch
+except:
+    pass
+from PKDevTools.classes import Archiver
+from pkscreener.classes import Utility
+from pkscreener.classes.MarketStatus import MarketStatus
+
+async def getScreenshotsForGlobalMarketBarometer():
+    # https://scrapeops.io/python-web-scraping-playbook/python-pyppeteer/#how-to-click-on-buttons-with-pyppeteer
+    folderPath = Archiver.get_user_outputs_dir()
+    browser = await launch()
+    page = await browser.newPage()
+    await page.goto('https://www.morningstar.com/markets/global-market-view',timeout=10000, waitUntil=['load','domcontentloaded','networkidle0'])
+    # Get the latest date for which this GMB is being loaded
+    dateElement = await page.querySelector(selector='.date-label')
+    date = await page.evaluate('(dateElement) => dateElement.textContent', dateElement)
+    await page.waitFor(selectorOrFunctionOrTimeout=2000)
+    # Show the india hover tooltip. If you don't do this, the screenshot if only 50% of the map
+    await page.hover(selector='.country-India')
+    hoverElement = await page.querySelector(selector='.mbc-chart-tooltip-container')
+    await page.evaluate('(hoverElement) => hoverElement.innerHTML=hoverElement.innerHTML.replaceAll("Morningstar","").replaceAll("GR INR","Performance")', hoverElement)
+
+    # Hide the india tooltip. This will force the map to appear properly for screenshot
+    # await page.hover(selector='.date-label')
+    # Take the screenshot
+    await page.screenshot({'path': os.path.join(folderPath,'gmbstat.png'), 'clip': {"x":50,"y":440,"width":710,"height":460}})
+
+    # Let's find the valuation of the market
+    btnValuation = await page.querySelector(selector='button#valuation')
+    await page.evaluate('(btnValuation) => btnValuation.click()', btnValuation)
+    await page.waitForSelector(selector='.country-India')
+    await page.waitFor(selectorOrFunctionOrTimeout=2000)
+    await page.hover(selector='.country-India')
+    await page.evaluate('(hoverElement) => hoverElement.innerHTML=hoverElement.innerHTML.replaceAll("Morningstar","").replaceAll("GR INR","Valuation")', hoverElement)
+    await page.screenshot({'path': os.path.join(folderPath,'gmbvaluation.png'), 'clip': {"x":45,"y":420,"width":710,"height":450}})
+    await browser.close()
+
+def getGlobalMarketBarometerValuation():
+    try:
+        asyncio.get_event_loop().run_until_complete(getScreenshotsForGlobalMarketBarometer())
+    except:
+        pass
+    folderPath = Archiver.get_user_outputs_dir()
+    gmbPath = None
+    try:
+        gapHeight = 65
+        bgColor = (0,0,0)
+        fontPath = Utility.tools.setupReportFont()
+        artfont = ImageFont.truetype(fontPath, 12)
+        gmbPerformance = Image.open(os.path.join(folderPath,'gmbstat.png')) # 710 x 460
+        gmbValuation = Image.open(os.path.join(folderPath,'gmbvaluation.png')) # 710 x 450
+        gmbPerf_size = gmbPerformance.size
+        gmbValue_size = gmbValuation.size
+        # watermark = Utility.tools.getWatermarkImage(gmbPerformance)
+        gmbPerformance = Utility.tools.addQuickWatermark(gmbPerformance, dataSrc="Morningstar, Inc")
+        gmbValuation = Utility.tools.addQuickWatermark(gmbValuation, dataSrc="Morningstar, Inc")
+        gmbCombined = Image.new('RGB',(gmbPerf_size[0], gmbPerf_size[1]+gmbValue_size[1]+gapHeight), bgColor)
+        gmbCombined.paste(gmbPerformance,(0,0))
+        draw = ImageDraw.Draw(gmbCombined)
+        # artwork
+        nseMarketStatus = MarketStatus().getMarketStatus(exchangeSymbol="^NSEI",namedOnly=True)
+        bseMarketStatus = MarketStatus().getMarketStatus(exchangeSymbol="^BSESN",namedOnly=True)
+        nasdaqMarketStatus = MarketStatus().getMarketStatus(exchangeSymbol="^IXIC")
+        repoText = f'https://GitHub.com/pkjmesra/pkscreener/ |  {datetime.date.today().year} pkjmesra | https://t.me/PKScreener\n{nseMarketStatus}\n{bseMarketStatus}\n{nasdaqMarketStatus}'
+        draw.text((5, gmbPerf_size[1]+5), Utility.tools.removeAllColorStyles(repoText), font=artfont, fill="lightgreen")
+        gmbCombined.paste(gmbValuation,(0,gmbPerf_size[1]+gapHeight))
+        gmbCombined.save(os.path.join(folderPath,"gmb.png"),"PNG")
+        gmbPath = os.path.join(folderPath,"gmb.png")
+        # gmbCombined.show()
+    except: #Exception as e:
+        # print(e)
+        pass
+    return gmbPath
+
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/CandlePatterns.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/CandlePatterns.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,347 +1,347 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-
-from PKDevTools.classes.ColorText import colorText
-
-from pkscreener.classes.Pktalib import pktalib
-# from PKDevTools.classes.log import measure_time
-
-class CandlePatterns:
-    reversalPatternsBullish = [
-        "Morning Star",
-        "Morning Doji Star",
-        "3 Inside Up",
-        "Hammer",
-        "3 White Soldiers",
-        "Bullish Engulfing",
-        "Dragonfly Doji",
-        "Supply Drought",
-        "Demand Rise",
-    ]
-    reversalPatternsBearish = [
-        "Evening Star",
-        "Evening Doji Star",
-        "3 Inside Down",
-        "Inverted Hammer",
-        "Hanging Man",
-        "3 Black Crows",
-        "Bearish Engulfing",
-        "Shooting Star",
-        "Gravestone Doji",
-    ]
-
-    def __init__(self):
-        pass
-
-    def findCurrentSavedValue(self, screenDict, saveDict, key):
-        existingScreen = screenDict.get(key)
-        existingSave = saveDict.get(key)
-        existingScreen = f"{existingScreen}, " if (existingScreen is not None and len(existingScreen) > 0) else ""
-        existingSave = f"{existingSave}, " if (existingSave is not None and len(existingSave) > 0) else ""
-        return existingScreen, existingSave
-
-    #@measure_time
-    # Find candle-stick patterns
-    # Arrange if statements with max priority from top to bottom
-    def findPattern(self, data, dict, saveDict):
-        data = data.head(4)
-        data = data[::-1]
-        hasCandleStickPattern = False
-        if "Pattern" not in saveDict.keys():
-            saveDict["Pattern"] = ""
-            dict["Pattern"] = ""
-        # Only 'doji' and 'inside' is internally implemented by pandas_ta.
-        # Otherwise, for the rest of the candle patterns, they also need
-        # TA-Lib.
-        check = pktalib.CDLDOJI(data["Open"], data["High"], data["Low"], data["Close"])
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + colorText.BOLD + f"Doji" + colorText.END 
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Doji"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLMORNINGSTAR(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.GREEN + f"Morning Star" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Morning Star"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLMORNINGDOJISTAR(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.GREEN + f"Morning Doji Star" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Morning Doji Star"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLEVENINGSTAR(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.FAIL + f"Evening Star" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Evening Star"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLEVENINGDOJISTAR(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.FAIL + f"Evening Doji Star" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Evening Doji Star"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLLADDERBOTTOM(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            if check.tail(1).item() > 0:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD + colorText.GREEN + f"Bullish Ladder Bottom" + colorText.END 
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bullish Ladder Bottom"
-            else:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD + colorText.FAIL + f"Bearish Ladder Bottom" + colorText.END 
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bearish Ladder Bottom"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDL3LINESTRIKE(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            if check.tail(1).item() > 0:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD + colorText.GREEN + f"3 Line Strike" + colorText.END 
-                )
-            else:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD + colorText.FAIL + f"3 Line Strike" + colorText.END 
-                )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Line Strike"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDL3BLACKCROWS(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.FAIL + f"3 Black Crows" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Black Crows"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDL3INSIDE(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            if check.tail(1).item() > 0:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD + colorText.GREEN + f"3 Inside Up" + colorText.END 
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Outside Up"
-            else:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD + colorText.FAIL + f"3 Inside Down" + colorText.END 
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Inside Down"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDL3OUTSIDE(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            if check.tail(1).item() > 0:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD + colorText.GREEN + f"3 Outside Up" + colorText.END 
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Outside Up"
-            else:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD + colorText.FAIL + f"3 Outside Down" + colorText.END 
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Outside Down"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDL3WHITESOLDIERS(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.GREEN + f"3 White Soldiers" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 White Soldiers"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLHARAMI(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            if check.tail(1).item() > 0:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD + colorText.GREEN + f"Bullish Harami" + colorText.END 
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bullish Harami"
-            else:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD + colorText.FAIL + f"Bearish Harami" + colorText.END 
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bearish Harami"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLHARAMICROSS(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            if check.tail(1).item() > 0:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD
-                    + colorText.GREEN
-                    + f"Bullish Harami Cross" 
-                    + colorText.END
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bullish Harami Cross"
-            else:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + f"Bearish Harami Cross" 
-                    + colorText.END
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bearish Harami Cross"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLMARUBOZU(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            if check.tail(1).item() > 0:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD
-                    + colorText.GREEN
-                    + f"Bullish Marubozu" 
-                    + colorText.END
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bullish Marubozu"
-            else:
-                dict["Pattern"] = (
-                    colorText.BOLD + colorText.FAIL + f"Bearish Marubozu" + colorText.END 
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bearish Marubozu"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLHANGINGMAN(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.FAIL + f"Hanging Man" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Hanging Man"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLHAMMER(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.GREEN + f"Hammer" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Hammer"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLINVERTEDHAMMER(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.GREEN + f"Inverted Hammer" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Inverted Hammer"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLSHOOTINGSTAR(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.FAIL + f"Shooting Star" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Shooting Star"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLDRAGONFLYDOJI(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.GREEN + f"Dragonfly Doji" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Dragonfly Doji"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLGRAVESTONEDOJI(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                colorText.BOLD + colorText.FAIL + f"Gravestone Doji" + colorText.END 
-            )
-            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Gravestone Doji"
-            hasCandleStickPattern = True
-
-        check = pktalib.CDLENGULFING(
-            data["Open"], data["High"], data["Low"], data["Close"]
-        )
-        if check is not None and check.tail(1).item() != 0:
-            if check.tail(1).item() > 0:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD
-                    + colorText.GREEN
-                    + f"Bullish Engulfing" 
-                    + colorText.END
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bullish Engulfing"
-            else:
-                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + f"Bearish Engulfing" 
-                    + colorText.END
-                )
-                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bearish Engulfing"
-            hasCandleStickPattern = True
-        if hasCandleStickPattern:
-            return True
-        return False
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+
+from PKDevTools.classes.ColorText import colorText
+
+from pkscreener.classes.Pktalib import pktalib
+# from PKDevTools.classes.log import measure_time
+
+class CandlePatterns:
+    reversalPatternsBullish = [
+        "Morning Star",
+        "Morning Doji Star",
+        "3 Inside Up",
+        "Hammer",
+        "3 White Soldiers",
+        "Bullish Engulfing",
+        "Dragonfly Doji",
+        "Supply Drought",
+        "Demand Rise",
+    ]
+    reversalPatternsBearish = [
+        "Evening Star",
+        "Evening Doji Star",
+        "3 Inside Down",
+        "Inverted Hammer",
+        "Hanging Man",
+        "3 Black Crows",
+        "Bearish Engulfing",
+        "Shooting Star",
+        "Gravestone Doji",
+    ]
+
+    def __init__(self):
+        pass
+
+    def findCurrentSavedValue(self, screenDict, saveDict, key):
+        existingScreen = screenDict.get(key)
+        existingSave = saveDict.get(key)
+        existingScreen = f"{existingScreen}, " if (existingScreen is not None and len(existingScreen) > 0) else ""
+        existingSave = f"{existingSave}, " if (existingSave is not None and len(existingSave) > 0) else ""
+        return existingScreen, existingSave
+
+    #@measure_time
+    # Find candle-stick patterns
+    # Arrange if statements with max priority from top to bottom
+    def findPattern(self, data, dict, saveDict):
+        data = data.head(4)
+        data = data[::-1]
+        hasCandleStickPattern = False
+        if "Pattern" not in saveDict.keys():
+            saveDict["Pattern"] = ""
+            dict["Pattern"] = ""
+        # Only 'doji' and 'inside' is internally implemented by pandas_ta.
+        # Otherwise, for the rest of the candle patterns, they also need
+        # TA-Lib.
+        check = pktalib.CDLDOJI(data["Open"], data["High"], data["Low"], data["Close"])
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + colorText.BOLD + f"Doji" + colorText.END 
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Doji"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLMORNINGSTAR(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.GREEN + f"Morning Star" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Morning Star"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLMORNINGDOJISTAR(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.GREEN + f"Morning Doji Star" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Morning Doji Star"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLEVENINGSTAR(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.FAIL + f"Evening Star" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Evening Star"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLEVENINGDOJISTAR(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.FAIL + f"Evening Doji Star" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Evening Doji Star"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLLADDERBOTTOM(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            if check.tail(1).item() > 0:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD + colorText.GREEN + f"Bullish Ladder Bottom" + colorText.END 
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bullish Ladder Bottom"
+            else:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD + colorText.FAIL + f"Bearish Ladder Bottom" + colorText.END 
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bearish Ladder Bottom"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDL3LINESTRIKE(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            if check.tail(1).item() > 0:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD + colorText.GREEN + f"3 Line Strike" + colorText.END 
+                )
+            else:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD + colorText.FAIL + f"3 Line Strike" + colorText.END 
+                )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Line Strike"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDL3BLACKCROWS(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.FAIL + f"3 Black Crows" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Black Crows"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDL3INSIDE(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            if check.tail(1).item() > 0:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD + colorText.GREEN + f"3 Inside Up" + colorText.END 
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Outside Up"
+            else:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD + colorText.FAIL + f"3 Inside Down" + colorText.END 
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Inside Down"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDL3OUTSIDE(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            if check.tail(1).item() > 0:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD + colorText.GREEN + f"3 Outside Up" + colorText.END 
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Outside Up"
+            else:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD + colorText.FAIL + f"3 Outside Down" + colorText.END 
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 Outside Down"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDL3WHITESOLDIERS(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.GREEN + f"3 White Soldiers" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"3 White Soldiers"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLHARAMI(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            if check.tail(1).item() > 0:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD + colorText.GREEN + f"Bullish Harami" + colorText.END 
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bullish Harami"
+            else:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD + colorText.FAIL + f"Bearish Harami" + colorText.END 
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bearish Harami"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLHARAMICROSS(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            if check.tail(1).item() > 0:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD
+                    + colorText.GREEN
+                    + f"Bullish Harami Cross" 
+                    + colorText.END
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bullish Harami Cross"
+            else:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + f"Bearish Harami Cross" 
+                    + colorText.END
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bearish Harami Cross"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLMARUBOZU(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            if check.tail(1).item() > 0:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD
+                    + colorText.GREEN
+                    + f"Bullish Marubozu" 
+                    + colorText.END
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bullish Marubozu"
+            else:
+                dict["Pattern"] = (
+                    colorText.BOLD + colorText.FAIL + f"Bearish Marubozu" + colorText.END 
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bearish Marubozu"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLHANGINGMAN(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.FAIL + f"Hanging Man" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Hanging Man"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLHAMMER(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.GREEN + f"Hammer" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Hammer"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLINVERTEDHAMMER(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.GREEN + f"Inverted Hammer" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Inverted Hammer"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLSHOOTINGSTAR(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.FAIL + f"Shooting Star" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Shooting Star"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLDRAGONFLYDOJI(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.GREEN + f"Dragonfly Doji" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Dragonfly Doji"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLGRAVESTONEDOJI(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                colorText.BOLD + colorText.FAIL + f"Gravestone Doji" + colorText.END 
+            )
+            saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Gravestone Doji"
+            hasCandleStickPattern = True
+
+        check = pktalib.CDLENGULFING(
+            data["Open"], data["High"], data["Low"], data["Close"]
+        )
+        if check is not None and check.tail(1).item() != 0:
+            if check.tail(1).item() > 0:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD
+                    + colorText.GREEN
+                    + f"Bullish Engulfing" 
+                    + colorText.END
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bullish Engulfing"
+            else:
+                dict["Pattern"] = (self.findCurrentSavedValue(dict,saveDict,"Pattern")[0] + 
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + f"Bearish Engulfing" 
+                    + colorText.END
+                )
+                saveDict["Pattern"] = self.findCurrentSavedValue(dict,saveDict,"Pattern")[1] +  f"Bearish Engulfing"
+            hasCandleStickPattern = True
+        if hasCandleStickPattern:
+            return True
+        return False
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ConfigManager.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ConfigManager.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,600 +1,600 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-
-import configparser
-import glob
-import os
-import sys
-
-from PKDevTools.classes import Archiver
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.log import default_logger
-from PKDevTools.classes.Singleton import SingletonType, SingletonMixin
-from PKDevTools.classes.OutputControls import OutputControls
-parser = configparser.ConfigParser(strict=False)
-
-# Default attributes for Downloading Cache from Git repo
-default_period = "1y"
-default_duration = "1d"
-default_timeout = 2
-
-
-# This Class manages read/write of user configuration
-class tools(SingletonMixin, metaclass=SingletonType):
-    def __init__(self):
-        super(tools, self).__init__()
-        self.consolidationPercentage = 10
-        self.volumeRatio = 2.5
-        self.minLTP = 20.0
-        self.maxLTP = 50000
-        self.period = "1y"
-        self.duration = "1d"
-        self.shuffleEnabled = True
-        self.cacheEnabled = True
-        self.stageTwo = True
-        self.useEMA = False
-        self.showunknowntrends = True
-        self.enablePortfolioCalculations = False
-        self.logsEnabled = False
-        self.generalTimeout = 2
-        self.defaultIndex = 12
-        self.longTimeout = 4
-        self.maxNetworkRetryCount = 10
-        self.backtestPeriod = 120
-        self.maxBacktestWindow = 30
-        self.minVolume = 10000
-        self.morninganalysiscandlenumber = 25 # 9:40am IST, since market opens at 9:15am IST
-        self.morninganalysiscandleduration = '1m'
-        self.logger = None
-        self.showPastStrategyData = False
-        self.atrTrailingStopSensitivity = 1
-        self.atrTrailingStopPeriod = 10
-        self.atrTrailingStopEMAPeriod = 200
-        # This determines how many days apart the backtest calculations are run.
-        # For example, for weekly backtest calculations, set this to 5 (5 days = 1 week)
-        # For fortnightly, set this to 10 and so on (10 trading sessions = 2 weeks)
-        self.backtestPeriodFactor = 1
-        self.maxDashboardWidgetsPerRow = 5
-        self.maxNumResultRowsInMonitor = 3
-        self.calculatersiintraday = False
-        self.defaultMonitorOptions = "X:12:9:2.5~X:12:23~X:12:28~X:12:31~|{1}X:0:23:>|X:0:27:>|X:0:31:~|{2}X:0:31:~|{3}X:0:27:~X:12:7:3:.01:1~|{5}X:0:5:0:40:~X:12:7:6:1~X:12:11:~X:12:12:i 5m~X:12:17~X:12:24~X:12:6:7:1~X:12:6:3~X:12:6:8~X:12:6:9~X:12:6:10:1~X:12:7:3:.02:1~X:12:13:i 1m~X:12:2~|{1}X:0:29:"
-        self.minimumChangePercentage = 0
-        self.daysToLookback = 22 * self.backtestPeriodFactor  # 1 month
-        self.periods = [1,2,3,4,5,10,15,22,30]
-        if self.maxBacktestWindow > self.periods[-1]:
-            self.periods.extend(self.maxBacktestWindow)
-
-    @property
-    def periodsRange(self):
-        self._periodsRange = []
-        if self.maxBacktestWindow > self.periods[-1]:
-            self.periods.extend(self.maxBacktestWindow)
-        for prd in self.periods:
-            self._periodsRange.append(prd*self.backtestPeriodFactor)
-        return self._periodsRange
-
-    @property
-    def effectiveDaysToLookback(self):
-        return self.daysToLookback* self.backtestPeriodFactor
-    
-    @property
-    def default_logger(self):
-        return self.logger if self.logger is not None else default_logger()
-
-    @default_logger.setter
-    def default_logger(self, logger):
-        self.logger = logger
-
-    def deleteFileWithPattern(self, pattern=None, excludeFile=None, rootDir=None, recursive=False):
-        if pattern is None:
-            pattern = (
-                f"{'intraday_' if self.isIntradayConfig() else ''}stock_data_*.pkl"
-            )
-        if rootDir is None:
-            rootDir = [Archiver.get_user_outputs_dir(),Archiver.get_user_outputs_dir().replace("results","actions-data-download")]
-        else:
-            rootDir = [rootDir]
-        for dir in rootDir:
-            for f in glob.glob(pattern, root_dir=dir, recursive=recursive):
-                if excludeFile is not None:
-                    if not f.endswith(excludeFile):
-                        try:
-                            os.remove(f if os.sep in f else os.path.join(dir,f))
-                        except Exception as e:
-                            self.default_logger.debug(e, exc_info=True)
-                            pass
-                else:
-                    try:
-                        os.remove(f if os.sep in f else os.path.join(dir,f))
-                    except Exception as e:
-                        self.default_logger.debug(e, exc_info=True)
-                        pass
-
-    # Handle user input and save config
-
-    def setConfig(self, parser, default=False, showFileCreatedText=True):
-        if default:
-            try:
-                parser.remove_section("config")
-                parser.remove_section("filters")
-            except Exception as e:  # pragma: no cover
-                self.default_logger.debug(e, exc_info=True)
-                pass
-            parser.add_section("config")
-            parser.add_section("filters")
-            parser.set("config", "atrtrailingstopemaperiod", str(self.atrTrailingStopEMAPeriod))
-            parser.set("config", "atrtrailingstopperiod", str(self.atrTrailingStopPeriod))
-            parser.set("config", "atrtrailingstopsensitivity", str(self.atrTrailingStopSensitivity))
-            parser.set("config", "backtestPeriod", str(self.backtestPeriod))
-            parser.set("config", "backtestPeriodFactor", str(self.backtestPeriodFactor))
-            parser.set("config", "cacheStockData", "y" if self.cacheEnabled else "n")
-            parser.set("config", "calculatersiintraday", "y" if self.calculatersiintraday else "n")
-            parser.set("config", "daysToLookback", str(self.daysToLookback))
-            parser.set("config", "defaultIndex", str(self.defaultIndex))
-            parser.set("config", "defaultMonitorOptions", str(self.defaultMonitorOptions))
-            parser.set("config", "duration", self.duration)
-            parser.set("config", "enablePortfolioCalculations", "y" if self.enablePortfolioCalculations else "n")
-            parser.set("config", "generalTimeout", str(self.generalTimeout))
-            parser.set("config", "logsEnabled", "y" if (self.logsEnabled or "PKDevTools_Default_Log_Level" in os.environ.keys()) else "n")
-            parser.set("config", "longTimeout", str(self.longTimeout))
-            parser.set("config", "maxBacktestWindow", str(self.maxBacktestWindow))
-            parser.set("config", "maxDashboardWidgetsPerRow", str(self.maxDashboardWidgetsPerRow))
-            parser.set("config", "maxNetworkRetryCount", str(self.maxNetworkRetryCount))
-            parser.set("config", "maxNumResultRowsInMonitor", str(self.maxNumResultRowsInMonitor))
-            parser.set("config", "morninganalysiscandlenumber", str(self.morninganalysiscandlenumber))
-            parser.set("config", "morninganalysiscandleduration", self.morninganalysiscandleduration)
-            parser.set("config", "onlyStageTwoStocks", "y" if self.stageTwo else "n")
-            parser.set("config", "period", self.period)
-            parser.set("config", "showPastStrategyData", "y" if self.showPastStrategyData else "n")
-            parser.set("config", "showunknowntrends", "y" if self.showunknowntrends else "n")
-            parser.set("config", "shuffle", "y" if self.shuffleEnabled else "n")
-            parser.set("config", "useEMA", "y" if self.useEMA else "n")
-
-            parser.set("filters", "consolidationPercentage", str(self.consolidationPercentage))
-            parser.set("filters", "maxPrice", str(self.maxLTP))
-            parser.set("filters", "minimumChangePercentage", str(self.minimumChangePercentage))
-            parser.set("filters", "minimumVolume", str(self.minVolume))
-            parser.set("filters", "minPrice", str(self.minLTP))
-            parser.set("filters", "volumeRatio", str(self.volumeRatio))
-
-            try:
-                fp = open("pkscreener.ini", "w")
-                parser.write(fp)
-                fp.close()
-                if showFileCreatedText:
-                    OutputControls().printOutput(
-                        colorText.BOLD
-                        + colorText.GREEN
-                        + "[+] Default configuration generated as user configuration is not found!"
-                        + colorText.END
-                    )
-                    input("Press <Enter> to continue...")
-                    return
-            except IOError as e:  # pragma: no cover
-                self.default_logger.debug(e, exc_info=True)
-                OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + "[+] Failed to save user config. Exiting.."
-                    + colorText.END
-                )
-                input("Press <Enter> to continue...")
-                sys.exit(1)
-        else:
-            parser = configparser.ConfigParser(strict=False)
-            parser.add_section("config")
-            parser.add_section("filters")
-            OutputControls().printOutput("")
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.GREEN
-                + "[+] PKScreener User Configuration:"
-                + colorText.END
-            )
-            try:
-                self.period = input(
-                    f"[+] Valid periods: 1d,5d,1mo,3mo,6mo,1y,2y,5y,10y,ytd,max\n[+] Enter number of days for which stock data to be downloaded (Days).(Optimal = 1y, Current: {colorText.FAIL}{self.period}{colorText.END}): "
-                ) or self.period
-                self.daysToLookback = input(
-                    f"[+] Number of recent trading periods (TimeFrame) to screen for Breakout/Consolidation (Days)(Optimal = 22, Current: {colorText.FAIL}{self.daysToLookback}{colorText.END}): "
-                ) or self.daysToLookback
-                self.duration = input(
-                    f"[+] Valid intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo\n[+] Enter Duration of each candle (Days)(Optimal = 1, Current: {colorText.FAIL}{self.duration}{colorText.END}): "
-                ) or self.duration
-                self.minLTP = input(
-                    f"[+] Minimum Price of Stock to Buy (in RS)(Optimal = 20, Current: {colorText.FAIL}{self.minLTP}{colorText.END}): "
-                ) or self.minLTP
-                self.maxLTP = input(
-                    f"[+] Maximum Price of Stock to Buy (in RS)(Optimal = 50000, Current: {colorText.FAIL}{self.maxLTP}{colorText.END}): "
-                ) or self.maxLTP
-                self.volumeRatio = input(
-                    f"[+] How many times the volume should be more than average for the breakout? (Number)(Optimal = 2.5, Current: {colorText.FAIL}{self.volumeRatio}{colorText.END}): "
-                ) or self.volumeRatio
-                self.consolidationPercentage = input(
-                    f"[+] How much % the price should be in range, to consider it as consolidation? (Number)(Optimal = 10, Current: {colorText.FAIL}{self.consolidationPercentage}{colorText.END}): "
-                ) or self.consolidationPercentage
-                self.shuffle = str(
-                    input(
-                        f"[+] Shuffle stocks rather than screening alphabetically? (Y/N, Current: {colorText.FAIL}{'y' if self.shuffleEnabled else 'n'}{colorText.END}): "
-                    ) or ('y' if self.shuffleEnabled else 'n')
-                ).lower()
-                self.cacheStockData = str(
-                    input(
-                        f"[+] Enable High-Performance and Data-Saver mode? (This uses little bit more CPU but performs High Performance Screening) (Y/N, Current: {colorText.FAIL}{('y' if self.cacheEnabled else 'n')}{colorText.END}): "
-                    ) or ('y' if self.cacheEnabled else 'n')
-                ).lower()
-                self.stageTwoPrompt = str(
-                    input(
-                        f"[+] Screen only for Stage-2 stocks?\n(What are the stages? => https://www.investopedia.com/articles/trading/08/stock-cycle-trend-price.asp)\n(Y/N, Current: {colorText.FAIL}{'y' if self.stageTwo else 'n'}{colorText.END}): "
-                    ) or ('y' if self.stageTwo else 'n')
-                ).lower()
-                self.useEmaPrompt = str(
-                    input(
-                        f"[+] Use EMA instead of SMA? (EMA is good for Short-term & SMA for Mid/Long-term trades)[Y/N, Current: {colorText.FAIL}{'y' if self.useEMA else 'n'}{colorText.END}]: "
-                    ) or ('y' if self.useEMA else 'n')
-                ).lower()
-                self.showunknowntrendsPrompt = str(
-                    input(
-                        f"[+] Show even those results where trends are not known[Y/N] (Recommended Y, Current: {colorText.FAIL}{'y' if self.showunknowntrends else 'n'}{colorText.END}): "
-                    ) or ('y' if self.showunknowntrends else 'n')
-                ).lower()
-                self.logsEnabledPrompt = str(
-                    input(
-                        f"[+] Enable Viewing logs? You can enable if you are having problems.[Y/N, Current: {colorText.FAIL}{'y' if self.logsEnabled else 'n'}{colorText.END}]: "
-                    ) or ('y' if self.logsEnabled else 'n')
-                ).lower()
-                self.enablePortfolioCalculations = str(
-                    input(
-                        f"[+] Enable calculating portfolio values? [Y/N, Current: {colorText.FAIL}{'y' if self.enablePortfolioCalculations else 'n'}{colorText.END}]: "
-                    ) or ('y' if self.enablePortfolioCalculations else 'n')
-                ).lower()
-                self.showPastStrategyData = str(
-                    input(
-                        f"[+] Enable showing past strategy data? [Y/N, Current: {colorText.FAIL}{'y' if self.showPastStrategyData else 'n'}{colorText.END}]: "
-                    ) or ('y' if self.showPastStrategyData else 'n')
-                ).lower()
-                self.calculatersiintraday = str(
-                    input(
-                        f"[+] Calculate intraday RSI during trading hours? [Y/N, Current: {colorText.FAIL}{'y' if self.calculatersiintraday else 'n'}{colorText.END}]: "
-                    ) or ('y' if self.calculatersiintraday else 'n')
-                ).lower()
-                self.generalTimeout = input(
-                    f"[+] General network timeout (in seconds)(Optimal = 2 for good networks, Current: {colorText.FAIL}{self.generalTimeout}{colorText.END}): "
-                ) or self.generalTimeout
-                self.longTimeout = input(
-                    f"[+] Long network timeout for heavier downloads(in seconds)(Optimal = 4 for good networks, Current: {colorText.FAIL}{self.longTimeout}{colorText.END}): "
-                ) or self.longTimeout
-                self.maxNetworkRetryCount = input(
-                    f"[+] Maximum number of retries in case of network timeout(in seconds)(Optimal = 10 for slow networks, Current: {colorText.FAIL}{self.maxNetworkRetryCount}{colorText.END}): "
-                ) or self.maxNetworkRetryCount
-                self.defaultIndex = input(
-                    f"[+] Default Index(NSE=12, NASDAQ=15, Current: {colorText.FAIL}{self.defaultIndex}{colorText.END}): "
-                ) or self.defaultIndex
-                self.backtestPeriod = input(
-                    f"[+] Number of days in the past for backtesting(in days)(Optimal = 30, Current: {colorText.FAIL}{self.backtestPeriod}{colorText.END}): "
-                ) or self.backtestPeriod
-                self.maxBacktestWindow = input(
-                    f"[+] Number of days to show the results for backtesting(in days)(Optimal = 1 to 30, Current: {colorText.FAIL}{self.maxBacktestWindow}{colorText.END}): "
-                ) or self.maxBacktestWindow
-                self.morninganalysiscandlenumber = input(
-                    f"[+] Candle number since the market open time(Optimal = 15 to 60, Current: {colorText.FAIL}{self.morninganalysiscandlenumber}{colorText.END}): "
-                ) or self.morninganalysiscandlenumber
-                self.morninganalysiscandleduration = input(
-                    f"[+] Valid intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo\n[+] Enter Duration of each candle (minutes)(Optimal = 1 to 5, Current: {colorText.FAIL}{self.morninganalysiscandleduration}{colorText.END}): "
-                ) or self.morninganalysiscandleduration
-                self.minVolume = input(
-                    f"[+] Minimum per day traded volume of any stock (number)(Optimal = 100000, Current: {colorText.FAIL}{self.minVolume}{colorText.END}): "
-                ) or self.minVolume
-                self.backtestPeriodFactor = input(
-                    f"[+] Factor for backtest periods. If you choose 5, 1-Pd would mean 5-Pd returns. (number)(Optimal = 1, Current: {colorText.FAIL}{self.backtestPeriodFactor}{colorText.END}): "
-                ) or self.backtestPeriodFactor
-                self.minimumChangePercentage = input(
-                    f"[+] Minimun change in stock price (in percentage). (number)(Optimal = 0, Current: {colorText.FAIL}{self.minimumChangePercentage}{colorText.END}): "
-                ) or self.minimumChangePercentage
-                self.atrTrailingStopPeriod = input(
-                    f"[+] ATR Trailing Stop Periods. (number)(Optimal = 10, Current: {colorText.FAIL}{self.atrTrailingStopPeriod}{colorText.END}): "
-                ) or self.atrTrailingStopPeriod
-                self.atrTrailingStopSensitivity = input(
-                    f"[+] ATR Trailing Stop Sensitivity. (number)(Optimal = 1, Current: {colorText.FAIL}{self.atrTrailingStopSensitivity}{colorText.END}): "
-                ) or self.atrTrailingStopSensitivity
-                self.atrTrailingStopEMAPeriod = input(
-                    f"[+] ATR Trailing Stop EMA Period. (number)(Optimal = 1 to 200, Current: {colorText.FAIL}{self.atrTrailingStopEMAPeriod}{colorText.END}): "
-                ) or self.atrTrailingStopEMAPeriod
-            except Exception as e:
-                default_logger().debug(e,exc_info=True)
-                from time import sleep
-                OutputControls().printOutput(colorText.FAIL + "Could not save configuration! Please check!" + colorText.END)
-                sleep(3)
-                pass
-            try:
-                parser.set("config", "atrtrailingstopemaperiod", str(self.atrTrailingStopEMAPeriod))
-                parser.set("config", "atrtrailingstopperiod", str(self.atrTrailingStopPeriod))
-                parser.set("config", "atrtrailingstopsensitivity", str(self.atrTrailingStopSensitivity))
-                parser.set("config", "backtestPeriod", str(self.backtestPeriod))
-                parser.set("config", "backtestPeriodFactor", str(self.backtestPeriodFactor))
-                parser.set("config", "cacheStockData", str(self.cacheStockData))
-                parser.set("config", "calculatersiintraday", str(self.calculatersiintraday))
-                parser.set("config", "daysToLookback", str(self.daysToLookback))
-                parser.set("config", "defaultIndex", str(self.defaultIndex))
-                parser.set("config", "defaultMonitorOptions", str(self.defaultMonitorOptions))
-                if self.duration:
-                    endDuration = str(self.duration)[-1].lower()
-                    endDuration = "d" if endDuration not in ["m","h","d","k","o"] else ""
-                parser.set("config", "duration", str(self.duration + endDuration))
-                parser.set("config", "enablePortfolioCalculations", str(self.enablePortfolioCalculations))
-                parser.set("config", "generalTimeout", str(self.generalTimeout))
-                parser.set("config", "logsEnabled", str(self.logsEnabledPrompt))
-                parser.set("config", "longTimeout", str(self.longTimeout))
-                parser.set("config", "maxBacktestWindow", str(self.maxBacktestWindow))
-                parser.set("config", "maxDashboardWidgetsPerRow", str(self.maxDashboardWidgetsPerRow))
-                parser.set("config", "maxNetworkRetryCount", str(self.maxNetworkRetryCount))
-                parser.set("config", "maxNumResultRowsInMonitor", str(self.maxNumResultRowsInMonitor))
-                if self.morninganalysiscandleduration:
-                    endMDuration = str(self.morninganalysiscandleduration)[-1].lower()
-                    endMDuration = "d" if endMDuration not in ["m","h","d","k","o"] else ""
-                parser.set("config", "morninganalysiscandleduration", str(self.morninganalysiscandleduration + endMDuration))
-                parser.set("config", "morninganalysiscandlenumber", str(self.morninganalysiscandlenumber))
-                parser.set("config", "onlyStageTwoStocks", str(self.stageTwoPrompt))
-                if self.period:
-                    endPeriod = str(self.period)[-1].lower()
-                    endPeriod = "d" if endPeriod not in ["d","o","y","x"] else ""
-                parser.set("config", "period", str(self.period + endPeriod))
-                parser.set("config", "showPastStrategyData", str(self.showPastStrategyData))
-                parser.set("config", "showunknowntrends", str(self.showunknowntrendsPrompt))
-                parser.set("config", "shuffle", str(self.shuffle))
-                parser.set("config", "useEMA", str(self.useEmaPrompt))
-
-                parser.set("filters", "consolidationPercentage", str(self.consolidationPercentage))
-                parser.set("filters", "maxPrice", str(self.maxLTP))
-                parser.set("filters", "minimumChangePercentage", str(self.minimumChangePercentage))
-                parser.set("filters", "minimumVolume", str(self.minVolume))
-                parser.set("filters", "minPrice", str(self.minLTP))
-                parser.set("filters", "volumeRatio", str(self.volumeRatio))
-
-            except Exception as e:
-                default_logger().debug(e,exc_info=True)
-                from time import sleep
-                OutputControls().printOutput(colorText.FAIL + "Could not save configuration! Please check!" + colorText.END)
-                sleep(3)
-                pass
-
-            # delete stock data due to config change
-            self.deleteFileWithPattern()
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] Cached Stock Data Deleted."
-                + colorText.END
-            )
-
-            try:
-                fp = open("pkscreener.ini", "w")
-                parser.write(fp)
-                fp.close()
-                self.getConfig(parser=parser)
-                OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.GREEN
-                    + "[+] User configuration saved."
-                    + colorText.END
-                )
-                input("Press <Enter> to continue...")
-                return
-            except IOError as e:  # pragma: no cover
-                self.default_logger.debug(e, exc_info=True)
-                OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + "[+] Failed to save user config. Exiting.."
-                    + colorText.END
-                )
-                input("Press <Enter> to continue...")
-                sys.exit(1)
-
-    # Load user config from file
-    def getConfig(self, parser):
-        if len(parser.read("pkscreener.ini")):
-            try:
-                self.duration = parser.get("config", "duration")
-                self.period = parser.get("config", "period")
-                self.minLTP = float(parser.get("filters", "minprice"))
-                self.maxLTP = float(parser.get("filters", "maxprice"))
-                self.volumeRatio = float(parser.get("filters", "volumeRatio"))
-                self.consolidationPercentage = float(
-                    parser.get("filters", "consolidationPercentage")
-                )
-                self.daysToLookback = int(parser.get("config", "daysToLookback"))
-                self.shuffleEnabled = (
-                    True
-                    if "n" not in str(parser.get("config", "shuffle")).lower()
-                    else False
-                )
-                self.cacheEnabled = (
-                    True
-                    if "n" not in str(parser.get("config", "cachestockdata")).lower()
-                    else False
-                )
-                self.stageTwo = (
-                    True
-                    if "n"
-                    not in str(parser.get("config", "onlyStageTwoStocks")).lower()
-                    else False
-                )
-                self.useEMA = (
-                    False
-                    if "y" not in str(parser.get("config", "useEMA")).lower()
-                    else True
-                )
-                self.showunknowntrends = (
-                    False
-                    if "y" not in str(parser.get("config", "showunknowntrends")).lower()
-                    else True
-                )
-                self.logsEnabled = (
-                    False
-                    if "y" not in str(parser.get("config", "logsEnabled")).lower()
-                    else True
-                )
-                self.enablePortfolioCalculations = (
-                    False
-                    if "y" not in str(parser.get("config", "enablePortfolioCalculations")).lower()
-                    else True
-                )
-                self.showPastStrategyData = (
-                    False
-                    if "y" not in str(parser.get("config", "showPastStrategyData")).lower()
-                    else True
-                )
-                self.calculatersiintraday = (
-                    False
-                    if "y" not in str(parser.get("config", "calculatersiintraday")).lower()
-                    else True
-                )
-                self.atrTrailingStopEMAPeriod = int(parser.get("config", "atrtrailingstopemaperiod"))
-                self.atrTrailingStopPeriod = int(parser.get("config", "atrtrailingstopperiod"))
-                self.atrTrailingStopSensitivity = float(parser.get("config", "atrtrailingstopsensitivity"))
-                self.generalTimeout = float(parser.get("config", "generalTimeout"))
-                self.defaultIndex = int(parser.get("config", "defaultIndex"))
-                self.longTimeout = float(parser.get("config", "longTimeout"))
-                self.maxNetworkRetryCount = int(
-                    parser.get("config", "maxNetworkRetryCount")
-                )
-                self.backtestPeriod = int(parser.get("config", "backtestPeriod"))
-                self.maxBacktestWindow = int(parser.get("config", "maxBacktestWindow"))
-                self.morninganalysiscandlenumber = int(parser.get("config", "morninganalysiscandlenumber"))
-                self.morninganalysiscandleduration = parser.get("config", "morninganalysiscandleduration")
-                self.minVolume = int(parser.get("filters", "minimumVolume"))
-                self.minimumChangePercentage = float(parser.get("filters", "minimumchangepercentage"))
-                self.backtestPeriodFactor = int(parser.get("config", "backtestPeriodFactor"))
-                self.defaultMonitorOptions = str(parser.get("config", "defaultMonitorOptions"))
-                self.maxDashboardWidgetsPerRow = int(parser.get("config", "maxDashboardWidgetsPerRow"))
-                self.maxNumResultRowsInMonitor = int(parser.get("config", "maxNumResultRowsInMonitor"))
-            except configparser.NoOptionError as e:# pragma: no cover
-                self.default_logger.debug(e, exc_info=True)
-                # input(colorText.BOLD + colorText.FAIL +
-                #       '[+] pkscreener requires user configuration again. Press enter to continue..' + colorText.END)
-                parser.remove_section("config")
-                parser.remove_section("filters")
-                self.setConfig(parser, default=True, showFileCreatedText=False)
-            except Exception as e:  # pragma: no cover
-                self.default_logger.debug(e, exc_info=True)
-                # input(colorText.BOLD + colorText.FAIL +
-                #       '[+] pkscreener requires user configuration again. Press enter to continue..' + colorText.END)
-                parser.remove_section("config")
-                parser.remove_section("filters")
-                self.setConfig(parser, default=True, showFileCreatedText=False)
-        else:
-            self.setConfig(parser, default=True, showFileCreatedText=False)
-
-    # Toggle the duration and period for use in intraday and swing trading
-    def toggleConfig(self, candleDuration, clearCache=True):
-        if candleDuration is None:
-            candleDuration = self.duration.lower()
-        self.getConfig(parser)
-        if candleDuration[-1] in ["d"]:
-            self.period = "1y"
-            self.cacheEnabled = True
-        if candleDuration[-1] in ["m", "h"] and not self.isIntradayConfig():
-            self.period = "1d"
-            self.cacheEnabled = True
-        if self.isIntradayConfig():
-            self.duration = candleDuration if candleDuration[-1] in ["m", "h"] else "1m"
-            candleType = candleDuration.replace("m","").replace("h","")
-            if candleDuration[-1] in ["m"]:
-                lookback = int(60/int(candleType)) * 6 # 6 hours
-            elif candleDuration[-1] in ["h"]:
-                lookback = (int(24/int(candleType)) + 1 )*2 #  at least 24 hours
-            self.daysToLookback = lookback  # At least the past 6 to 24 hours
-        else:
-            self.duration = candleDuration if candleDuration[-1] == "d" else "1d"
-            self.daysToLookback = 22  # At least the past 1.5 month
-        self.setConfig(parser, default=True, showFileCreatedText=False)
-        if clearCache:
-            # Delete any cached *.pkl data
-            self.deleteFileWithPattern()
-            # Delete any cached session data
-            self.restartRequestsCache()
-
-    def restartRequestsCache(self):
-        import requests_cache
-        try:
-            if requests_cache.is_installed():
-                requests_cache.clear()
-                requests_cache.uninstall_cache()
-            cache_file = os.path.join(
-                    Archiver.get_user_outputs_dir(), "PKDevTools_cache.sqlite")
-            if os.path.isfile(cache_file):
-                os.remove(cache_file)
-            self.deleteFileWithPattern("*_cache.sqlite")
-            requests_cache.install_cache(
-                cache_name=f"{Archiver.get_user_outputs_dir().split(os.sep)[-1]}{os.sep}PKDevTools_cache",
-                db_path=os.path.join(
-                    Archiver.get_user_outputs_dir(), "PKDevTools_cache.sqlite"
-                ),
-            )
-        except Exception as e:  # pragma: no cover
-            self.default_logger.debug(e, exc_info=True)
-
-    def isIntradayConfig(self):
-        return self.period == "1d"
-
-    # Print config file
-    def showConfigFile(self, defaultAnswer=None):
-        try:
-            prompt = "[+] PKScreener User Configuration:"
-            f = open("pkscreener.ini", "r")
-            OutputControls().printOutput(colorText.BOLD + colorText.GREEN + prompt + colorText.END)
-            configData = f.read()
-            f.close()
-            OutputControls().printOutput("\n" + configData)
-            if defaultAnswer is None:
-                input("Press <Enter> to continue...")
-            return f"{prompt}\n{configData}"
-        except Exception as e:  # pragma: no cover
-            self.default_logger.debug(e, exc_info=True)
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] User Configuration not found!"
-                + colorText.END
-            )
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.WARN
-                + "[+] Configure the limits to continue."
-                + colorText.END
-            )
-            self.setConfig(parser, default=True, showFileCreatedText=False)
-
-    # Check if config file exists
-    def checkConfigFile(self):
-        try:
-            f = open("pkscreener.ini", "r")
-            f.close()
-            self.getConfig(parser)
-            return True
-        except FileNotFoundError as e:  # pragma: no cover
-            self.default_logger.debug(e, exc_info=True)
-            self.setConfig(parser, default=True, showFileCreatedText=False)
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+
+import configparser
+import glob
+import os
+import sys
+
+from PKDevTools.classes import Archiver
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.log import default_logger
+from PKDevTools.classes.Singleton import SingletonType, SingletonMixin
+from PKDevTools.classes.OutputControls import OutputControls
+parser = configparser.ConfigParser(strict=False)
+
+# Default attributes for Downloading Cache from Git repo
+default_period = "1y"
+default_duration = "1d"
+default_timeout = 2
+
+
+# This Class manages read/write of user configuration
+class tools(SingletonMixin, metaclass=SingletonType):
+    def __init__(self):
+        super(tools, self).__init__()
+        self.consolidationPercentage = 10
+        self.volumeRatio = 2.5
+        self.minLTP = 20.0
+        self.maxLTP = 50000
+        self.period = "1y"
+        self.duration = "1d"
+        self.shuffleEnabled = True
+        self.cacheEnabled = True
+        self.stageTwo = True
+        self.useEMA = False
+        self.showunknowntrends = True
+        self.enablePortfolioCalculations = False
+        self.logsEnabled = False
+        self.generalTimeout = 2
+        self.defaultIndex = 12
+        self.longTimeout = 4
+        self.maxNetworkRetryCount = 10
+        self.backtestPeriod = 120
+        self.maxBacktestWindow = 30
+        self.minVolume = 10000
+        self.morninganalysiscandlenumber = 25 # 9:40am IST, since market opens at 9:15am IST
+        self.morninganalysiscandleduration = '1m'
+        self.logger = None
+        self.showPastStrategyData = False
+        self.atrTrailingStopSensitivity = 1
+        self.atrTrailingStopPeriod = 10
+        self.atrTrailingStopEMAPeriod = 200
+        # This determines how many days apart the backtest calculations are run.
+        # For example, for weekly backtest calculations, set this to 5 (5 days = 1 week)
+        # For fortnightly, set this to 10 and so on (10 trading sessions = 2 weeks)
+        self.backtestPeriodFactor = 1
+        self.maxDashboardWidgetsPerRow = 5
+        self.maxNumResultRowsInMonitor = 3
+        self.calculatersiintraday = False
+        self.defaultMonitorOptions = "X:12:9:2.5~X:12:23~X:12:28~X:12:31~|{1}X:0:23:>|X:0:27:>|X:0:31:~|{2}X:0:31:~|{3}X:0:27:~X:12:7:3:.01:1~|{5}X:0:5:0:40:~X:12:7:6:1~X:12:11:~X:12:12:i 5m~X:12:17~X:12:24~X:12:6:7:1~X:12:6:3~X:12:6:8~X:12:6:9~X:12:6:10:1~X:12:7:3:.02:1~X:12:13:i 1m~X:12:2~|{1}X:0:29:"
+        self.minimumChangePercentage = 0
+        self.daysToLookback = 22 * self.backtestPeriodFactor  # 1 month
+        self.periods = [1,2,3,4,5,10,15,22,30]
+        if self.maxBacktestWindow > self.periods[-1]:
+            self.periods.extend(self.maxBacktestWindow)
+
+    @property
+    def periodsRange(self):
+        self._periodsRange = []
+        if self.maxBacktestWindow > self.periods[-1]:
+            self.periods.extend(self.maxBacktestWindow)
+        for prd in self.periods:
+            self._periodsRange.append(prd*self.backtestPeriodFactor)
+        return self._periodsRange
+
+    @property
+    def effectiveDaysToLookback(self):
+        return self.daysToLookback* self.backtestPeriodFactor
+    
+    @property
+    def default_logger(self):
+        return self.logger if self.logger is not None else default_logger()
+
+    @default_logger.setter
+    def default_logger(self, logger):
+        self.logger = logger
+
+    def deleteFileWithPattern(self, pattern=None, excludeFile=None, rootDir=None, recursive=False):
+        if pattern is None:
+            pattern = (
+                f"{'intraday_' if self.isIntradayConfig() else ''}stock_data_*.pkl"
+            )
+        if rootDir is None:
+            rootDir = [Archiver.get_user_outputs_dir(),Archiver.get_user_outputs_dir().replace("results","actions-data-download")]
+        else:
+            rootDir = [rootDir]
+        for dir in rootDir:
+            for f in glob.glob(pattern, root_dir=dir, recursive=recursive):
+                if excludeFile is not None:
+                    if not f.endswith(excludeFile):
+                        try:
+                            os.remove(f if os.sep in f else os.path.join(dir,f))
+                        except Exception as e:
+                            self.default_logger.debug(e, exc_info=True)
+                            pass
+                else:
+                    try:
+                        os.remove(f if os.sep in f else os.path.join(dir,f))
+                    except Exception as e:
+                        self.default_logger.debug(e, exc_info=True)
+                        pass
+
+    # Handle user input and save config
+
+    def setConfig(self, parser, default=False, showFileCreatedText=True):
+        if default:
+            try:
+                parser.remove_section("config")
+                parser.remove_section("filters")
+            except Exception as e:  # pragma: no cover
+                self.default_logger.debug(e, exc_info=True)
+                pass
+            parser.add_section("config")
+            parser.add_section("filters")
+            parser.set("config", "atrtrailingstopemaperiod", str(self.atrTrailingStopEMAPeriod))
+            parser.set("config", "atrtrailingstopperiod", str(self.atrTrailingStopPeriod))
+            parser.set("config", "atrtrailingstopsensitivity", str(self.atrTrailingStopSensitivity))
+            parser.set("config", "backtestPeriod", str(self.backtestPeriod))
+            parser.set("config", "backtestPeriodFactor", str(self.backtestPeriodFactor))
+            parser.set("config", "cacheStockData", "y" if self.cacheEnabled else "n")
+            parser.set("config", "calculatersiintraday", "y" if self.calculatersiintraday else "n")
+            parser.set("config", "daysToLookback", str(self.daysToLookback))
+            parser.set("config", "defaultIndex", str(self.defaultIndex))
+            parser.set("config", "defaultMonitorOptions", str(self.defaultMonitorOptions))
+            parser.set("config", "duration", self.duration)
+            parser.set("config", "enablePortfolioCalculations", "y" if self.enablePortfolioCalculations else "n")
+            parser.set("config", "generalTimeout", str(self.generalTimeout))
+            parser.set("config", "logsEnabled", "y" if (self.logsEnabled or "PKDevTools_Default_Log_Level" in os.environ.keys()) else "n")
+            parser.set("config", "longTimeout", str(self.longTimeout))
+            parser.set("config", "maxBacktestWindow", str(self.maxBacktestWindow))
+            parser.set("config", "maxDashboardWidgetsPerRow", str(self.maxDashboardWidgetsPerRow))
+            parser.set("config", "maxNetworkRetryCount", str(self.maxNetworkRetryCount))
+            parser.set("config", "maxNumResultRowsInMonitor", str(self.maxNumResultRowsInMonitor))
+            parser.set("config", "morninganalysiscandlenumber", str(self.morninganalysiscandlenumber))
+            parser.set("config", "morninganalysiscandleduration", self.morninganalysiscandleduration)
+            parser.set("config", "onlyStageTwoStocks", "y" if self.stageTwo else "n")
+            parser.set("config", "period", self.period)
+            parser.set("config", "showPastStrategyData", "y" if self.showPastStrategyData else "n")
+            parser.set("config", "showunknowntrends", "y" if self.showunknowntrends else "n")
+            parser.set("config", "shuffle", "y" if self.shuffleEnabled else "n")
+            parser.set("config", "useEMA", "y" if self.useEMA else "n")
+
+            parser.set("filters", "consolidationPercentage", str(self.consolidationPercentage))
+            parser.set("filters", "maxPrice", str(self.maxLTP))
+            parser.set("filters", "minimumChangePercentage", str(self.minimumChangePercentage))
+            parser.set("filters", "minimumVolume", str(self.minVolume))
+            parser.set("filters", "minPrice", str(self.minLTP))
+            parser.set("filters", "volumeRatio", str(self.volumeRatio))
+
+            try:
+                fp = open("pkscreener.ini", "w")
+                parser.write(fp)
+                fp.close()
+                if showFileCreatedText:
+                    OutputControls().printOutput(
+                        colorText.BOLD
+                        + colorText.GREEN
+                        + "[+] Default configuration generated as user configuration is not found!"
+                        + colorText.END
+                    )
+                    input("Press <Enter> to continue...")
+                    return
+            except IOError as e:  # pragma: no cover
+                self.default_logger.debug(e, exc_info=True)
+                OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + "[+] Failed to save user config. Exiting.."
+                    + colorText.END
+                )
+                input("Press <Enter> to continue...")
+                sys.exit(1)
+        else:
+            parser = configparser.ConfigParser(strict=False)
+            parser.add_section("config")
+            parser.add_section("filters")
+            OutputControls().printOutput("")
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.GREEN
+                + "[+] PKScreener User Configuration:"
+                + colorText.END
+            )
+            try:
+                self.period = input(
+                    f"[+] Valid periods: 1d,5d,1mo,3mo,6mo,1y,2y,5y,10y,ytd,max\n[+] Enter number of days for which stock data to be downloaded (Days).(Optimal = 1y, Current: {colorText.FAIL}{self.period}{colorText.END}): "
+                ) or self.period
+                self.daysToLookback = input(
+                    f"[+] Number of recent trading periods (TimeFrame) to screen for Breakout/Consolidation (Days)(Optimal = 22, Current: {colorText.FAIL}{self.daysToLookback}{colorText.END}): "
+                ) or self.daysToLookback
+                self.duration = input(
+                    f"[+] Valid intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo\n[+] Enter Duration of each candle (Days)(Optimal = 1, Current: {colorText.FAIL}{self.duration}{colorText.END}): "
+                ) or self.duration
+                self.minLTP = input(
+                    f"[+] Minimum Price of Stock to Buy (in RS)(Optimal = 20, Current: {colorText.FAIL}{self.minLTP}{colorText.END}): "
+                ) or self.minLTP
+                self.maxLTP = input(
+                    f"[+] Maximum Price of Stock to Buy (in RS)(Optimal = 50000, Current: {colorText.FAIL}{self.maxLTP}{colorText.END}): "
+                ) or self.maxLTP
+                self.volumeRatio = input(
+                    f"[+] How many times the volume should be more than average for the breakout? (Number)(Optimal = 2.5, Current: {colorText.FAIL}{self.volumeRatio}{colorText.END}): "
+                ) or self.volumeRatio
+                self.consolidationPercentage = input(
+                    f"[+] How much % the price should be in range, to consider it as consolidation? (Number)(Optimal = 10, Current: {colorText.FAIL}{self.consolidationPercentage}{colorText.END}): "
+                ) or self.consolidationPercentage
+                self.shuffle = str(
+                    input(
+                        f"[+] Shuffle stocks rather than screening alphabetically? (Y/N, Current: {colorText.FAIL}{'y' if self.shuffleEnabled else 'n'}{colorText.END}): "
+                    ) or ('y' if self.shuffleEnabled else 'n')
+                ).lower()
+                self.cacheStockData = str(
+                    input(
+                        f"[+] Enable High-Performance and Data-Saver mode? (This uses little bit more CPU but performs High Performance Screening) (Y/N, Current: {colorText.FAIL}{('y' if self.cacheEnabled else 'n')}{colorText.END}): "
+                    ) or ('y' if self.cacheEnabled else 'n')
+                ).lower()
+                self.stageTwoPrompt = str(
+                    input(
+                        f"[+] Screen only for Stage-2 stocks?\n(What are the stages? => https://www.investopedia.com/articles/trading/08/stock-cycle-trend-price.asp)\n(Y/N, Current: {colorText.FAIL}{'y' if self.stageTwo else 'n'}{colorText.END}): "
+                    ) or ('y' if self.stageTwo else 'n')
+                ).lower()
+                self.useEmaPrompt = str(
+                    input(
+                        f"[+] Use EMA instead of SMA? (EMA is good for Short-term & SMA for Mid/Long-term trades)[Y/N, Current: {colorText.FAIL}{'y' if self.useEMA else 'n'}{colorText.END}]: "
+                    ) or ('y' if self.useEMA else 'n')
+                ).lower()
+                self.showunknowntrendsPrompt = str(
+                    input(
+                        f"[+] Show even those results where trends are not known[Y/N] (Recommended Y, Current: {colorText.FAIL}{'y' if self.showunknowntrends else 'n'}{colorText.END}): "
+                    ) or ('y' if self.showunknowntrends else 'n')
+                ).lower()
+                self.logsEnabledPrompt = str(
+                    input(
+                        f"[+] Enable Viewing logs? You can enable if you are having problems.[Y/N, Current: {colorText.FAIL}{'y' if self.logsEnabled else 'n'}{colorText.END}]: "
+                    ) or ('y' if self.logsEnabled else 'n')
+                ).lower()
+                self.enablePortfolioCalculations = str(
+                    input(
+                        f"[+] Enable calculating portfolio values? [Y/N, Current: {colorText.FAIL}{'y' if self.enablePortfolioCalculations else 'n'}{colorText.END}]: "
+                    ) or ('y' if self.enablePortfolioCalculations else 'n')
+                ).lower()
+                self.showPastStrategyData = str(
+                    input(
+                        f"[+] Enable showing past strategy data? [Y/N, Current: {colorText.FAIL}{'y' if self.showPastStrategyData else 'n'}{colorText.END}]: "
+                    ) or ('y' if self.showPastStrategyData else 'n')
+                ).lower()
+                self.calculatersiintraday = str(
+                    input(
+                        f"[+] Calculate intraday RSI during trading hours? [Y/N, Current: {colorText.FAIL}{'y' if self.calculatersiintraday else 'n'}{colorText.END}]: "
+                    ) or ('y' if self.calculatersiintraday else 'n')
+                ).lower()
+                self.generalTimeout = input(
+                    f"[+] General network timeout (in seconds)(Optimal = 2 for good networks, Current: {colorText.FAIL}{self.generalTimeout}{colorText.END}): "
+                ) or self.generalTimeout
+                self.longTimeout = input(
+                    f"[+] Long network timeout for heavier downloads(in seconds)(Optimal = 4 for good networks, Current: {colorText.FAIL}{self.longTimeout}{colorText.END}): "
+                ) or self.longTimeout
+                self.maxNetworkRetryCount = input(
+                    f"[+] Maximum number of retries in case of network timeout(in seconds)(Optimal = 10 for slow networks, Current: {colorText.FAIL}{self.maxNetworkRetryCount}{colorText.END}): "
+                ) or self.maxNetworkRetryCount
+                self.defaultIndex = input(
+                    f"[+] Default Index(NSE=12, NASDAQ=15, Current: {colorText.FAIL}{self.defaultIndex}{colorText.END}): "
+                ) or self.defaultIndex
+                self.backtestPeriod = input(
+                    f"[+] Number of days in the past for backtesting(in days)(Optimal = 30, Current: {colorText.FAIL}{self.backtestPeriod}{colorText.END}): "
+                ) or self.backtestPeriod
+                self.maxBacktestWindow = input(
+                    f"[+] Number of days to show the results for backtesting(in days)(Optimal = 1 to 30, Current: {colorText.FAIL}{self.maxBacktestWindow}{colorText.END}): "
+                ) or self.maxBacktestWindow
+                self.morninganalysiscandlenumber = input(
+                    f"[+] Candle number since the market open time(Optimal = 15 to 60, Current: {colorText.FAIL}{self.morninganalysiscandlenumber}{colorText.END}): "
+                ) or self.morninganalysiscandlenumber
+                self.morninganalysiscandleduration = input(
+                    f"[+] Valid intervals: 1m,2m,5m,15m,30m,60m,90m,1h,1d,5d,1wk,1mo,3mo\n[+] Enter Duration of each candle (minutes)(Optimal = 1 to 5, Current: {colorText.FAIL}{self.morninganalysiscandleduration}{colorText.END}): "
+                ) or self.morninganalysiscandleduration
+                self.minVolume = input(
+                    f"[+] Minimum per day traded volume of any stock (number)(Optimal = 100000, Current: {colorText.FAIL}{self.minVolume}{colorText.END}): "
+                ) or self.minVolume
+                self.backtestPeriodFactor = input(
+                    f"[+] Factor for backtest periods. If you choose 5, 1-Pd would mean 5-Pd returns. (number)(Optimal = 1, Current: {colorText.FAIL}{self.backtestPeriodFactor}{colorText.END}): "
+                ) or self.backtestPeriodFactor
+                self.minimumChangePercentage = input(
+                    f"[+] Minimun change in stock price (in percentage). (number)(Optimal = 0, Current: {colorText.FAIL}{self.minimumChangePercentage}{colorText.END}): "
+                ) or self.minimumChangePercentage
+                self.atrTrailingStopPeriod = input(
+                    f"[+] ATR Trailing Stop Periods. (number)(Optimal = 10, Current: {colorText.FAIL}{self.atrTrailingStopPeriod}{colorText.END}): "
+                ) or self.atrTrailingStopPeriod
+                self.atrTrailingStopSensitivity = input(
+                    f"[+] ATR Trailing Stop Sensitivity. (number)(Optimal = 1, Current: {colorText.FAIL}{self.atrTrailingStopSensitivity}{colorText.END}): "
+                ) or self.atrTrailingStopSensitivity
+                self.atrTrailingStopEMAPeriod = input(
+                    f"[+] ATR Trailing Stop EMA Period. (number)(Optimal = 1 to 200, Current: {colorText.FAIL}{self.atrTrailingStopEMAPeriod}{colorText.END}): "
+                ) or self.atrTrailingStopEMAPeriod
+            except Exception as e:
+                default_logger().debug(e,exc_info=True)
+                from time import sleep
+                OutputControls().printOutput(colorText.FAIL + "Could not save configuration! Please check!" + colorText.END)
+                sleep(3)
+                pass
+            try:
+                parser.set("config", "atrtrailingstopemaperiod", str(self.atrTrailingStopEMAPeriod))
+                parser.set("config", "atrtrailingstopperiod", str(self.atrTrailingStopPeriod))
+                parser.set("config", "atrtrailingstopsensitivity", str(self.atrTrailingStopSensitivity))
+                parser.set("config", "backtestPeriod", str(self.backtestPeriod))
+                parser.set("config", "backtestPeriodFactor", str(self.backtestPeriodFactor))
+                parser.set("config", "cacheStockData", str(self.cacheStockData))
+                parser.set("config", "calculatersiintraday", str(self.calculatersiintraday))
+                parser.set("config", "daysToLookback", str(self.daysToLookback))
+                parser.set("config", "defaultIndex", str(self.defaultIndex))
+                parser.set("config", "defaultMonitorOptions", str(self.defaultMonitorOptions))
+                if self.duration:
+                    endDuration = str(self.duration)[-1].lower()
+                    endDuration = "d" if endDuration not in ["m","h","d","k","o"] else ""
+                parser.set("config", "duration", str(self.duration + endDuration))
+                parser.set("config", "enablePortfolioCalculations", str(self.enablePortfolioCalculations))
+                parser.set("config", "generalTimeout", str(self.generalTimeout))
+                parser.set("config", "logsEnabled", str(self.logsEnabledPrompt))
+                parser.set("config", "longTimeout", str(self.longTimeout))
+                parser.set("config", "maxBacktestWindow", str(self.maxBacktestWindow))
+                parser.set("config", "maxDashboardWidgetsPerRow", str(self.maxDashboardWidgetsPerRow))
+                parser.set("config", "maxNetworkRetryCount", str(self.maxNetworkRetryCount))
+                parser.set("config", "maxNumResultRowsInMonitor", str(self.maxNumResultRowsInMonitor))
+                if self.morninganalysiscandleduration:
+                    endMDuration = str(self.morninganalysiscandleduration)[-1].lower()
+                    endMDuration = "d" if endMDuration not in ["m","h","d","k","o"] else ""
+                parser.set("config", "morninganalysiscandleduration", str(self.morninganalysiscandleduration + endMDuration))
+                parser.set("config", "morninganalysiscandlenumber", str(self.morninganalysiscandlenumber))
+                parser.set("config", "onlyStageTwoStocks", str(self.stageTwoPrompt))
+                if self.period:
+                    endPeriod = str(self.period)[-1].lower()
+                    endPeriod = "d" if endPeriod not in ["d","o","y","x"] else ""
+                parser.set("config", "period", str(self.period + endPeriod))
+                parser.set("config", "showPastStrategyData", str(self.showPastStrategyData))
+                parser.set("config", "showunknowntrends", str(self.showunknowntrendsPrompt))
+                parser.set("config", "shuffle", str(self.shuffle))
+                parser.set("config", "useEMA", str(self.useEmaPrompt))
+
+                parser.set("filters", "consolidationPercentage", str(self.consolidationPercentage))
+                parser.set("filters", "maxPrice", str(self.maxLTP))
+                parser.set("filters", "minimumChangePercentage", str(self.minimumChangePercentage))
+                parser.set("filters", "minimumVolume", str(self.minVolume))
+                parser.set("filters", "minPrice", str(self.minLTP))
+                parser.set("filters", "volumeRatio", str(self.volumeRatio))
+
+            except Exception as e:
+                default_logger().debug(e,exc_info=True)
+                from time import sleep
+                OutputControls().printOutput(colorText.FAIL + "Could not save configuration! Please check!" + colorText.END)
+                sleep(3)
+                pass
+
+            # delete stock data due to config change
+            self.deleteFileWithPattern()
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] Cached Stock Data Deleted."
+                + colorText.END
+            )
+
+            try:
+                fp = open("pkscreener.ini", "w")
+                parser.write(fp)
+                fp.close()
+                self.getConfig(parser=parser)
+                OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.GREEN
+                    + "[+] User configuration saved."
+                    + colorText.END
+                )
+                input("Press <Enter> to continue...")
+                return
+            except IOError as e:  # pragma: no cover
+                self.default_logger.debug(e, exc_info=True)
+                OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + "[+] Failed to save user config. Exiting.."
+                    + colorText.END
+                )
+                input("Press <Enter> to continue...")
+                sys.exit(1)
+
+    # Load user config from file
+    def getConfig(self, parser):
+        if len(parser.read("pkscreener.ini")):
+            try:
+                self.duration = parser.get("config", "duration")
+                self.period = parser.get("config", "period")
+                self.minLTP = float(parser.get("filters", "minprice"))
+                self.maxLTP = float(parser.get("filters", "maxprice"))
+                self.volumeRatio = float(parser.get("filters", "volumeRatio"))
+                self.consolidationPercentage = float(
+                    parser.get("filters", "consolidationPercentage")
+                )
+                self.daysToLookback = int(parser.get("config", "daysToLookback"))
+                self.shuffleEnabled = (
+                    True
+                    if "n" not in str(parser.get("config", "shuffle")).lower()
+                    else False
+                )
+                self.cacheEnabled = (
+                    True
+                    if "n" not in str(parser.get("config", "cachestockdata")).lower()
+                    else False
+                )
+                self.stageTwo = (
+                    True
+                    if "n"
+                    not in str(parser.get("config", "onlyStageTwoStocks")).lower()
+                    else False
+                )
+                self.useEMA = (
+                    False
+                    if "y" not in str(parser.get("config", "useEMA")).lower()
+                    else True
+                )
+                self.showunknowntrends = (
+                    False
+                    if "y" not in str(parser.get("config", "showunknowntrends")).lower()
+                    else True
+                )
+                self.logsEnabled = (
+                    False
+                    if "y" not in str(parser.get("config", "logsEnabled")).lower()
+                    else True
+                )
+                self.enablePortfolioCalculations = (
+                    False
+                    if "y" not in str(parser.get("config", "enablePortfolioCalculations")).lower()
+                    else True
+                )
+                self.showPastStrategyData = (
+                    False
+                    if "y" not in str(parser.get("config", "showPastStrategyData")).lower()
+                    else True
+                )
+                self.calculatersiintraday = (
+                    False
+                    if "y" not in str(parser.get("config", "calculatersiintraday")).lower()
+                    else True
+                )
+                self.atrTrailingStopEMAPeriod = int(parser.get("config", "atrtrailingstopemaperiod"))
+                self.atrTrailingStopPeriod = int(parser.get("config", "atrtrailingstopperiod"))
+                self.atrTrailingStopSensitivity = float(parser.get("config", "atrtrailingstopsensitivity"))
+                self.generalTimeout = float(parser.get("config", "generalTimeout"))
+                self.defaultIndex = int(parser.get("config", "defaultIndex"))
+                self.longTimeout = float(parser.get("config", "longTimeout"))
+                self.maxNetworkRetryCount = int(
+                    parser.get("config", "maxNetworkRetryCount")
+                )
+                self.backtestPeriod = int(parser.get("config", "backtestPeriod"))
+                self.maxBacktestWindow = int(parser.get("config", "maxBacktestWindow"))
+                self.morninganalysiscandlenumber = int(parser.get("config", "morninganalysiscandlenumber"))
+                self.morninganalysiscandleduration = parser.get("config", "morninganalysiscandleduration")
+                self.minVolume = int(parser.get("filters", "minimumVolume"))
+                self.minimumChangePercentage = float(parser.get("filters", "minimumchangepercentage"))
+                self.backtestPeriodFactor = int(parser.get("config", "backtestPeriodFactor"))
+                self.defaultMonitorOptions = str(parser.get("config", "defaultMonitorOptions"))
+                self.maxDashboardWidgetsPerRow = int(parser.get("config", "maxDashboardWidgetsPerRow"))
+                self.maxNumResultRowsInMonitor = int(parser.get("config", "maxNumResultRowsInMonitor"))
+            except configparser.NoOptionError as e:# pragma: no cover
+                self.default_logger.debug(e, exc_info=True)
+                # input(colorText.BOLD + colorText.FAIL +
+                #       '[+] pkscreener requires user configuration again. Press enter to continue..' + colorText.END)
+                parser.remove_section("config")
+                parser.remove_section("filters")
+                self.setConfig(parser, default=True, showFileCreatedText=False)
+            except Exception as e:  # pragma: no cover
+                self.default_logger.debug(e, exc_info=True)
+                # input(colorText.BOLD + colorText.FAIL +
+                #       '[+] pkscreener requires user configuration again. Press enter to continue..' + colorText.END)
+                parser.remove_section("config")
+                parser.remove_section("filters")
+                self.setConfig(parser, default=True, showFileCreatedText=False)
+        else:
+            self.setConfig(parser, default=True, showFileCreatedText=False)
+
+    # Toggle the duration and period for use in intraday and swing trading
+    def toggleConfig(self, candleDuration, clearCache=True):
+        if candleDuration is None:
+            candleDuration = self.duration.lower()
+        self.getConfig(parser)
+        if candleDuration[-1] in ["d"]:
+            self.period = "1y"
+            self.cacheEnabled = True
+        if candleDuration[-1] in ["m", "h"] and not self.isIntradayConfig():
+            self.period = "1d"
+            self.cacheEnabled = True
+        if self.isIntradayConfig():
+            self.duration = candleDuration if candleDuration[-1] in ["m", "h"] else "1m"
+            candleType = candleDuration.replace("m","").replace("h","")
+            if candleDuration[-1] in ["m"]:
+                lookback = int(60/int(candleType)) * 6 # 6 hours
+            elif candleDuration[-1] in ["h"]:
+                lookback = (int(24/int(candleType)) + 1 )*2 #  at least 24 hours
+            self.daysToLookback = lookback  # At least the past 6 to 24 hours
+        else:
+            self.duration = candleDuration if candleDuration[-1] == "d" else "1d"
+            self.daysToLookback = 22  # At least the past 1.5 month
+        self.setConfig(parser, default=True, showFileCreatedText=False)
+        if clearCache:
+            # Delete any cached *.pkl data
+            self.deleteFileWithPattern()
+            # Delete any cached session data
+            self.restartRequestsCache()
+
+    def restartRequestsCache(self):
+        import requests_cache
+        try:
+            if requests_cache.is_installed():
+                requests_cache.clear()
+                requests_cache.uninstall_cache()
+            cache_file = os.path.join(
+                    Archiver.get_user_outputs_dir(), "PKDevTools_cache.sqlite")
+            if os.path.isfile(cache_file):
+                os.remove(cache_file)
+            self.deleteFileWithPattern("*_cache.sqlite")
+            requests_cache.install_cache(
+                cache_name=f"{Archiver.get_user_outputs_dir().split(os.sep)[-1]}{os.sep}PKDevTools_cache",
+                db_path=os.path.join(
+                    Archiver.get_user_outputs_dir(), "PKDevTools_cache.sqlite"
+                ),
+            )
+        except Exception as e:  # pragma: no cover
+            self.default_logger.debug(e, exc_info=True)
+
+    def isIntradayConfig(self):
+        return self.period == "1d"
+
+    # Print config file
+    def showConfigFile(self, defaultAnswer=None):
+        try:
+            prompt = "[+] PKScreener User Configuration:"
+            f = open("pkscreener.ini", "r")
+            OutputControls().printOutput(colorText.BOLD + colorText.GREEN + prompt + colorText.END)
+            configData = f.read()
+            f.close()
+            OutputControls().printOutput("\n" + configData)
+            if defaultAnswer is None:
+                input("Press <Enter> to continue...")
+            return f"{prompt}\n{configData}"
+        except Exception as e:  # pragma: no cover
+            self.default_logger.debug(e, exc_info=True)
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] User Configuration not found!"
+                + colorText.END
+            )
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.WARN
+                + "[+] Configure the limits to continue."
+                + colorText.END
+            )
+            self.setConfig(parser, default=True, showFileCreatedText=False)
+
+    # Check if config file exists
+    def checkConfigFile(self):
+        try:
+            f = open("pkscreener.ini", "r")
+            f.close()
+            self.getConfig(parser)
+            return True
+        except FileNotFoundError as e:  # pragma: no cover
+            self.default_logger.debug(e, exc_info=True)
+            self.setConfig(parser, default=True, showFileCreatedText=False)
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MarketMonitor.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MarketMonitor.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,244 +1,244 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import os
-import sys
-import pandas as pd
-import numpy as np
-from time import sleep
-from PKDevTools.classes.Singleton import SingletonType, SingletonMixin
-from PKDevTools.classes.OutputControls import OutputControls
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes import Archiver
-from PKDevTools.classes.SuppressOutput import SuppressOutput
-from PKDevTools.classes.log import default_logger
-
-class MarketMonitor(SingletonMixin, metaclass=SingletonType):
-    def __init__(self,monitors=[], maxNumResultsPerRow=3,maxNumColsInEachResult=6,maxNumRowsInEachResult=10,maxNumResultRowsInMonitor=2):
-        super(MarketMonitor, self).__init__()
-        if monitors is not None and len(monitors) > 0:
-            
-            self.monitors = monitors[:maxNumResultRowsInMonitor*maxNumResultsPerRow]
-            self.monitorIndex = 0
-            self.monitorPositions = {}
-            self.monitorResultStocks = {}
-            # self.monitorNames = {}
-            # We are going to present the dataframes in a 3x3 matrix with limited set of columns
-            rowIndex = 0
-            colIndex = 0
-            self.maxNumResultRowsInMonitor = maxNumResultRowsInMonitor
-            self.maxNumRowsInEachResult = maxNumRowsInEachResult
-            self.maxNumColsInEachResult = maxNumColsInEachResult
-            self.maxNumResultsPerRow = maxNumResultsPerRow
-            maxColIndex = self.maxNumColsInEachResult * self.maxNumResultsPerRow - 1
-            self.lines = 0
-            for monitorKey in self.monitors:
-                self.monitorPositions[monitorKey] = [rowIndex,colIndex]
-                # self.monitorNames[monitorKey] = ""
-                colIndex += self.maxNumColsInEachResult
-                if colIndex > maxColIndex:
-                    colIndex = 0
-                    rowIndex += self.maxNumRowsInEachResult
-            columns = []
-            colNameIndex = 0
-            maxColIndex = min(maxColIndex,len(self.monitorPositions)*self.maxNumColsInEachResult -1)
-            while colNameIndex <= maxColIndex:
-                columns.append(f"A{colNameIndex +1}")
-                colNameIndex += 1
-            self.monitor_df = pd.DataFrame(columns=columns)
-            self.isPinnedSingleMonitorMode = len(self.monitorPositions.keys()) == 1
-
-    def currentMonitorOption(self):
-        try:
-            option = None
-            maxIndex = len(self.monitors) -1
-            option = str(self.monitors[self.monitorIndex:self.monitorIndex+1][0])
-            self.monitorIndex += 1
-            if self.monitorIndex > maxIndex:
-                self.monitorIndex = 0
-        except:
-            pass
-        return option
-
-    def saveMonitorResultStocks(self, results_df):
-        if results_df is None or results_df.empty:
-            prevOutput_results = "NONE"
-        else:
-            prevOutput_results = results_df[~results_df.index.duplicated(keep='first')]
-            prevOutput_results = prevOutput_results.index
-            # # Maybe the index is an int ?
-            # prevOutput_results = [str(stock) for stock in prevOutput_results]
-            prevOutput_results = ",".join(prevOutput_results)
-        self.monitorResultStocks[str(self.monitorIndex)] = prevOutput_results
-
-    def refresh(self, screen_df:pd.DataFrame=None, screenOptions=None, chosenMenu=None, dbTimestamp="", telegram=False):
-        highlightRows = []
-        highlightCols = []
-        if screen_df is None or screen_df.empty or screenOptions is None:
-            return
-        screen_monitor_df = screen_df.copy()
-        monitorPosition = self.monitorPositions.get(screenOptions)
-
-        from pkscreener.classes import Utility
-
-        if self.isPinnedSingleMonitorMode:
-            screen_monitor_df = screen_monitor_df[screen_monitor_df.columns[:14]]
-            self.monitor_df = screen_monitor_df
-        else:
-            screen_monitor_df.reset_index(inplace=True)
-            screen_monitor_df = screen_monitor_df[["Stock", "LTP", "%Chng","52Wk H","RSI/i" if "RSI/i" in screen_monitor_df.columns else "RSI","Volume"]].head(self.maxNumRowsInEachResult-1)
-            # Import Utility here since Utility has dependency on PKScheduler which in turn has dependency on 
-            # multiprocessing, which behaves erratically if imported at the top.
-            screen_monitor_df.loc[:, "%Chng"] = screen_monitor_df.loc[:, "%Chng"].apply(
-                        lambda x: Utility.tools.roundOff(str(x).split("% (")[0] + colorText.END,0)
-                    )
-            screen_monitor_df.loc[:, "52Wk H"] = screen_monitor_df.loc[:, "52Wk H"].apply(
-                lambda x: Utility.tools.roundOff(x,0)
-            )
-            screen_monitor_df.loc[:, "Volume"] = screen_monitor_df.loc[:, "Volume"].apply(
-                lambda x: Utility.tools.roundOff(x,0)
-            )
-            screen_monitor_df.rename(columns={"%Chng": "Ch%","Volume":"Vol","52Wk H":"52WkH", "RSI":"RSI/i"}, inplace=True)
-            telegram_df = self.updateDataFrameForTelegramMode(telegram, screen_monitor_df)
-        
-        
-        if monitorPosition is not None:
-            startRowIndex, startColIndex = monitorPosition
-            if not self.monitor_df.empty:
-                for _ in range(self.lines):
-                    sys.stdout.write("\x1b[1A")  # cursor up one line
-                    sys.stdout.write("\x1b[2K")  # delete the last line
-            if not self.isPinnedSingleMonitorMode:
-                firstColIndex = startColIndex
-                rowIndex = 0
-                colIndex = 0
-                highlightRows = [startRowIndex]
-                highlightCols = []
-                while rowIndex <= len(screen_monitor_df):
-                    for col in screen_monitor_df.columns:
-                        if rowIndex == 0:
-                            # Column names to be repeated for each refresh in respective headers
-                            cleanedScreenOptions = screenOptions.replace(":D","")
-                            if cleanedScreenOptions.startswith("|"):
-                                cleanedScreenOptions = cleanedScreenOptions.replace("|","")
-                                pipedFrom = ""
-                                if cleanedScreenOptions.startswith("{"):
-                                    pipedFrom = cleanedScreenOptions.split("}")[0] + "}:"
-                                cleanedScreenOptions = pipedFrom + ":".join(cleanedScreenOptions.split(":")[2:])
-                                cleanedScreenOptions = cleanedScreenOptions.replace(">X:0:","")
-                            widgetHeader = ":".join(cleanedScreenOptions.split(":")[:4])
-                            if "i " in screenOptions:
-                                widgetHeader = f'{":".join(widgetHeader.split(":")[:3])}:i:{cleanedScreenOptions.split("i ")[-1]}'
-                            self.monitor_df.loc[startRowIndex,[f"A{startColIndex+1}"]] = colorText.BOLD+colorText.HEAD+(widgetHeader if startColIndex==firstColIndex else col)+colorText.END
-                            highlightCols.append(startColIndex)
-                        else:
-                            self.monitor_df.loc[startRowIndex, [f"A{startColIndex+1}"]] = screen_monitor_df.iloc[rowIndex-1,colIndex]
-                            colIndex += 1
-                        startColIndex += 1
-                    _, startColIndex= monitorPosition
-                    rowIndex += 1
-                    colIndex = 0
-                    highlightRows.append(startRowIndex+1)
-                    startRowIndex += 1
-
-        self.monitor_df = self.monitor_df.replace(np.nan, "-", regex=True)
-        # self.monitorNames[screenOptions] = f"(Dashboard) > {chosenMenu}"
-        latestScanMenuOption = f"[+] {dbTimestamp} (Dashboard) > " + f"{chosenMenu} [{screenOptions}]"
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + latestScanMenuOption[:200]
-            + colorText.END
-            , enableMultipleLineOutput=True
-        )
-        tabulated_results = colorText.miniTabulator().tabulate(
-            self.monitor_df, tablefmt=colorText.No_Pad_GridFormat,
-            headers="keys" if self.isPinnedSingleMonitorMode else (),
-            highlightCharacter=colorText.HEAD+"="+colorText.END,
-            showindex=self.isPinnedSingleMonitorMode,
-            highlightedRows=highlightRows,
-            highlightedColumns=highlightCols,
-            maxcolwidths=Utility.tools.getMaxColumnWidths(self.monitor_df)
-        )
-        self.lines = len(tabulated_results.splitlines()) + 1 # 1 for the progress bar at the bottom and 1 for the chosenMenu option
-        OutputControls().printOutput(tabulated_results, enableMultipleLineOutput=True)
-        
-        if not self.isPinnedSingleMonitorMode:
-            if telegram:
-                self.updateIfRunningInTelegramBotMode(screenOptions, chosenMenu, dbTimestamp, telegram, telegram_df)
-        else:
-            sleep(30)
-
-    def updateDataFrameForTelegramMode(self, telegram, screen_monitor_df):
-        telegram_df = None
-        if telegram:
-            telegram_df = screen_monitor_df[["Stock", "LTP", "Ch%", "Vol"]]
-            try:
-                telegram_df.loc[:, "Stock"] = telegram_df.loc[:, "Stock"].apply(
-                    lambda x: x.split('\x1b')[3].replace('\\','') if 'http' in x else x
-                )
-                cols = ["LTP", "Ch%", "Vol"]
-                for col in cols:
-                    telegram_df.loc[:, col] = telegram_df.loc[:, col].apply(
-                        lambda x: x.replace(colorText.FAIL,"").replace(colorText.GREEN,"").replace(colorText.WARN,"").replace(colorText.BOLD,"").replace(colorText.END,"")
-                    )
-                telegram_df.loc[:, "LTP"] = telegram_df.loc[:, "LTP"].apply(
-                    lambda x: str(int(round(float(x),0)))
-                )
-                telegram_df.loc[:, "Ch%"] = telegram_df.loc[:, "Ch%"].apply(
-                    lambda x: f'{int(round(float(x.replace("%","")),0))}%'
-                )
-                telegram_df.loc[:, "Vol"] = telegram_df.loc[:, "Vol"].apply(
-                    lambda x: f'{int(round(float(x.replace("x","")),0))}x'
-                )
-                with SuppressOutput(suppress_stderr=True, suppress_stdout=True):
-                    for col in telegram_df.columns:
-                        telegram_df[col] = telegram_df[col].astype(str)
-            except:
-                pass
-        return telegram_df
-
-    def updateIfRunningInTelegramBotMode(self, screenOptions, chosenMenu, dbTimestamp, telegram, telegram_df):
-        if telegram and telegram_df is not None:
-            STD_ENCODING=sys.stdout.encoding if sys.stdout is not None else 'utf-8'
-            
-            telegram_df_tabulated = colorText.miniTabulator().tabulate(
-                            telegram_df,
-                            headers="keys",
-                            tablefmt=colorText.No_Pad_GridFormat,
-                            showindex=False,
-                            maxcolwidths=[None,None,4,3]
-                        ).encode("utf-8").decode(STD_ENCODING).replace("-K-----S-----C-----R","-K-----S----C---R").replace("%  ","% ").replace("=K=====S=====C=====R","=K=====S====C===R").replace("Vol  |","Vol|").replace("x  ","x")
-            telegram_df_tabulated = telegram_df_tabulated.replace("-E-----N-----E-----R","-E-----N----E---R").replace("=E=====N=====E=====R","=E=====N====E===R")
-            choiceSegments = chosenMenu.split(">")
-            chosenMenu = f"{choiceSegments[-2]}>{choiceSegments[-1]}" if (len(choiceSegments)>=4 or len(choiceSegments[-1]) <= 10) else f"{choiceSegments[-1]}"
-            result_output = f"Latest data as of:{dbTimestamp}\n<b>{chosenMenu}</b> [{screenOptions}]\n<pre>{telegram_df_tabulated}</pre>"
-            try:
-                filePath = os.path.join(Archiver.get_user_outputs_dir(), f"monitor_outputs_{self.monitorIndex}.txt")
-                f = open(filePath, "w")
-                f.write(result_output)
-                f.close()
-            except:
-                pass
-
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import os
+import sys
+import pandas as pd
+import numpy as np
+from time import sleep
+from PKDevTools.classes.Singleton import SingletonType, SingletonMixin
+from PKDevTools.classes.OutputControls import OutputControls
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes import Archiver
+from PKDevTools.classes.SuppressOutput import SuppressOutput
+from PKDevTools.classes.log import default_logger
+
+class MarketMonitor(SingletonMixin, metaclass=SingletonType):
+    def __init__(self,monitors=[], maxNumResultsPerRow=3,maxNumColsInEachResult=6,maxNumRowsInEachResult=10,maxNumResultRowsInMonitor=2):
+        super(MarketMonitor, self).__init__()
+        if monitors is not None and len(monitors) > 0:
+            
+            self.monitors = monitors[:maxNumResultRowsInMonitor*maxNumResultsPerRow]
+            self.monitorIndex = 0
+            self.monitorPositions = {}
+            self.monitorResultStocks = {}
+            # self.monitorNames = {}
+            # We are going to present the dataframes in a 3x3 matrix with limited set of columns
+            rowIndex = 0
+            colIndex = 0
+            self.maxNumResultRowsInMonitor = maxNumResultRowsInMonitor
+            self.maxNumRowsInEachResult = maxNumRowsInEachResult
+            self.maxNumColsInEachResult = maxNumColsInEachResult
+            self.maxNumResultsPerRow = maxNumResultsPerRow
+            maxColIndex = self.maxNumColsInEachResult * self.maxNumResultsPerRow - 1
+            self.lines = 0
+            for monitorKey in self.monitors:
+                self.monitorPositions[monitorKey] = [rowIndex,colIndex]
+                # self.monitorNames[monitorKey] = ""
+                colIndex += self.maxNumColsInEachResult
+                if colIndex > maxColIndex:
+                    colIndex = 0
+                    rowIndex += self.maxNumRowsInEachResult
+            columns = []
+            colNameIndex = 0
+            maxColIndex = min(maxColIndex,len(self.monitorPositions)*self.maxNumColsInEachResult -1)
+            while colNameIndex <= maxColIndex:
+                columns.append(f"A{colNameIndex +1}")
+                colNameIndex += 1
+            self.monitor_df = pd.DataFrame(columns=columns)
+            self.isPinnedSingleMonitorMode = len(self.monitorPositions.keys()) == 1
+
+    def currentMonitorOption(self):
+        try:
+            option = None
+            maxIndex = len(self.monitors) -1
+            option = str(self.monitors[self.monitorIndex:self.monitorIndex+1][0])
+            self.monitorIndex += 1
+            if self.monitorIndex > maxIndex:
+                self.monitorIndex = 0
+        except:
+            pass
+        return option
+
+    def saveMonitorResultStocks(self, results_df):
+        if results_df is None or results_df.empty:
+            prevOutput_results = "NONE"
+        else:
+            prevOutput_results = results_df[~results_df.index.duplicated(keep='first')]
+            prevOutput_results = prevOutput_results.index
+            # # Maybe the index is an int ?
+            # prevOutput_results = [str(stock) for stock in prevOutput_results]
+            prevOutput_results = ",".join(prevOutput_results)
+        self.monitorResultStocks[str(self.monitorIndex)] = prevOutput_results
+
+    def refresh(self, screen_df:pd.DataFrame=None, screenOptions=None, chosenMenu=None, dbTimestamp="", telegram=False):
+        highlightRows = []
+        highlightCols = []
+        if screen_df is None or screen_df.empty or screenOptions is None:
+            return
+        screen_monitor_df = screen_df.copy()
+        monitorPosition = self.monitorPositions.get(screenOptions)
+
+        from pkscreener.classes import Utility
+
+        if self.isPinnedSingleMonitorMode:
+            screen_monitor_df = screen_monitor_df[screen_monitor_df.columns[:14]]
+            self.monitor_df = screen_monitor_df
+        else:
+            screen_monitor_df.reset_index(inplace=True)
+            screen_monitor_df = screen_monitor_df[["Stock", "LTP", "%Chng","52Wk H","RSI/i" if "RSI/i" in screen_monitor_df.columns else "RSI","Volume"]].head(self.maxNumRowsInEachResult-1)
+            # Import Utility here since Utility has dependency on PKScheduler which in turn has dependency on 
+            # multiprocessing, which behaves erratically if imported at the top.
+            screen_monitor_df.loc[:, "%Chng"] = screen_monitor_df.loc[:, "%Chng"].apply(
+                        lambda x: Utility.tools.roundOff(str(x).split("% (")[0] + colorText.END,0)
+                    )
+            screen_monitor_df.loc[:, "52Wk H"] = screen_monitor_df.loc[:, "52Wk H"].apply(
+                lambda x: Utility.tools.roundOff(x,0)
+            )
+            screen_monitor_df.loc[:, "Volume"] = screen_monitor_df.loc[:, "Volume"].apply(
+                lambda x: Utility.tools.roundOff(x,0)
+            )
+            screen_monitor_df.rename(columns={"%Chng": "Ch%","Volume":"Vol","52Wk H":"52WkH", "RSI":"RSI/i"}, inplace=True)
+            telegram_df = self.updateDataFrameForTelegramMode(telegram, screen_monitor_df)
+        
+        
+        if monitorPosition is not None:
+            startRowIndex, startColIndex = monitorPosition
+            if not self.monitor_df.empty:
+                for _ in range(self.lines):
+                    sys.stdout.write("\x1b[1A")  # cursor up one line
+                    sys.stdout.write("\x1b[2K")  # delete the last line
+            if not self.isPinnedSingleMonitorMode:
+                firstColIndex = startColIndex
+                rowIndex = 0
+                colIndex = 0
+                highlightRows = [startRowIndex]
+                highlightCols = []
+                while rowIndex <= len(screen_monitor_df):
+                    for col in screen_monitor_df.columns:
+                        if rowIndex == 0:
+                            # Column names to be repeated for each refresh in respective headers
+                            cleanedScreenOptions = screenOptions.replace(":D","")
+                            if cleanedScreenOptions.startswith("|"):
+                                cleanedScreenOptions = cleanedScreenOptions.replace("|","")
+                                pipedFrom = ""
+                                if cleanedScreenOptions.startswith("{"):
+                                    pipedFrom = cleanedScreenOptions.split("}")[0] + "}:"
+                                cleanedScreenOptions = pipedFrom + ":".join(cleanedScreenOptions.split(":")[2:])
+                                cleanedScreenOptions = cleanedScreenOptions.replace(">X:0:","")
+                            widgetHeader = ":".join(cleanedScreenOptions.split(":")[:4])
+                            if "i " in screenOptions:
+                                widgetHeader = f'{":".join(widgetHeader.split(":")[:3])}:i:{cleanedScreenOptions.split("i ")[-1]}'
+                            self.monitor_df.loc[startRowIndex,[f"A{startColIndex+1}"]] = colorText.BOLD+colorText.HEAD+(widgetHeader if startColIndex==firstColIndex else col)+colorText.END
+                            highlightCols.append(startColIndex)
+                        else:
+                            self.monitor_df.loc[startRowIndex, [f"A{startColIndex+1}"]] = screen_monitor_df.iloc[rowIndex-1,colIndex]
+                            colIndex += 1
+                        startColIndex += 1
+                    _, startColIndex= monitorPosition
+                    rowIndex += 1
+                    colIndex = 0
+                    highlightRows.append(startRowIndex+1)
+                    startRowIndex += 1
+
+        self.monitor_df = self.monitor_df.replace(np.nan, "-", regex=True)
+        # self.monitorNames[screenOptions] = f"(Dashboard) > {chosenMenu}"
+        latestScanMenuOption = f"[+] {dbTimestamp} (Dashboard) > " + f"{chosenMenu} [{screenOptions}]"
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + latestScanMenuOption[:200]
+            + colorText.END
+            , enableMultipleLineOutput=True
+        )
+        tabulated_results = colorText.miniTabulator().tabulate(
+            self.monitor_df, tablefmt=colorText.No_Pad_GridFormat,
+            headers="keys" if self.isPinnedSingleMonitorMode else (),
+            highlightCharacter=colorText.HEAD+"="+colorText.END,
+            showindex=self.isPinnedSingleMonitorMode,
+            highlightedRows=highlightRows,
+            highlightedColumns=highlightCols,
+            maxcolwidths=Utility.tools.getMaxColumnWidths(self.monitor_df)
+        )
+        self.lines = len(tabulated_results.splitlines()) + 1 # 1 for the progress bar at the bottom and 1 for the chosenMenu option
+        OutputControls().printOutput(tabulated_results, enableMultipleLineOutput=True)
+        
+        if not self.isPinnedSingleMonitorMode:
+            if telegram:
+                self.updateIfRunningInTelegramBotMode(screenOptions, chosenMenu, dbTimestamp, telegram, telegram_df)
+        else:
+            sleep(30)
+
+    def updateDataFrameForTelegramMode(self, telegram, screen_monitor_df):
+        telegram_df = None
+        if telegram:
+            telegram_df = screen_monitor_df[["Stock", "LTP", "Ch%", "Vol"]]
+            try:
+                telegram_df.loc[:, "Stock"] = telegram_df.loc[:, "Stock"].apply(
+                    lambda x: x.split('\x1b')[3].replace('\\','') if 'http' in x else x
+                )
+                cols = ["LTP", "Ch%", "Vol"]
+                for col in cols:
+                    telegram_df.loc[:, col] = telegram_df.loc[:, col].apply(
+                        lambda x: x.replace(colorText.FAIL,"").replace(colorText.GREEN,"").replace(colorText.WARN,"").replace(colorText.BOLD,"").replace(colorText.END,"")
+                    )
+                telegram_df.loc[:, "LTP"] = telegram_df.loc[:, "LTP"].apply(
+                    lambda x: str(int(round(float(x),0)))
+                )
+                telegram_df.loc[:, "Ch%"] = telegram_df.loc[:, "Ch%"].apply(
+                    lambda x: f'{int(round(float(x.replace("%","")),0))}%'
+                )
+                telegram_df.loc[:, "Vol"] = telegram_df.loc[:, "Vol"].apply(
+                    lambda x: f'{int(round(float(x.replace("x","")),0))}x'
+                )
+                with SuppressOutput(suppress_stderr=True, suppress_stdout=True):
+                    for col in telegram_df.columns:
+                        telegram_df[col] = telegram_df[col].astype(str)
+            except:
+                pass
+        return telegram_df
+
+    def updateIfRunningInTelegramBotMode(self, screenOptions, chosenMenu, dbTimestamp, telegram, telegram_df):
+        if telegram and telegram_df is not None:
+            STD_ENCODING=sys.stdout.encoding if sys.stdout is not None else 'utf-8'
+            
+            telegram_df_tabulated = colorText.miniTabulator().tabulate(
+                            telegram_df,
+                            headers="keys",
+                            tablefmt=colorText.No_Pad_GridFormat,
+                            showindex=False,
+                            maxcolwidths=[None,None,4,3]
+                        ).encode("utf-8").decode(STD_ENCODING).replace("-K-----S-----C-----R","-K-----S----C---R").replace("%  ","% ").replace("=K=====S=====C=====R","=K=====S====C===R").replace("Vol  |","Vol|").replace("x  ","x")
+            telegram_df_tabulated = telegram_df_tabulated.replace("-E-----N-----E-----R","-E-----N----E---R").replace("=E=====N=====E=====R","=E=====N====E===R")
+            choiceSegments = chosenMenu.split(">")
+            chosenMenu = f"{choiceSegments[-2]}>{choiceSegments[-1]}" if (len(choiceSegments)>=4 or len(choiceSegments[-1]) <= 10) else f"{choiceSegments[-1]}"
+            result_output = f"Latest data as of:{dbTimestamp}\n<b>{chosenMenu}</b> [{screenOptions}]\n<pre>{telegram_df_tabulated}</pre>"
+            try:
+                filePath = os.path.join(Archiver.get_user_outputs_dir(), f"monitor_outputs_{self.monitorIndex}.txt")
+                f = open(filePath, "w")
+                f.write(result_output)
+                f.close()
+            except:
+                pass
+
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MarketStatus.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MarketStatus.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,82 +1,82 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import os
-from PKNSETools.PKNSEStockDataFetcher import nseStockDataFetcher
-from PKDevTools.classes.Singleton import SingletonType, SingletonMixin
-from PKDevTools.classes.log import default_logger
-from PKDevTools.classes.SuppressOutput import SuppressOutput
-from PKDevTools.classes import log as log
-
-class MarketStatus(SingletonMixin, metaclass=SingletonType):
-    nseFetcher = nseStockDataFetcher()
-    def __init__(self):
-        super(MarketStatus, self).__init__()
-
-    @property
-    def exchange(self):
-        if "exchange" in self.attributes.keys():
-            return self.attributes["exchange"]
-        else:
-            return "^NSEI"
-    
-    @exchange.setter
-    def exchange(self, exchangeKey):
-        if self.exchange != exchangeKey:
-            self.marketStatus = self.getMarketStatus(exchangeSymbol=exchangeKey)
-        self.attributes["exchange"] = exchangeKey
-
-    @property
-    def marketStatus(self):
-        if "marketStatus" in self.attributes.keys():
-            return self.attributes["marketStatus"]
-        else:
-            # self.attributes["lock"] = "" # We don't need threading lock here
-            self.marketStatus = ""
-            return self.marketStatus
-    
-    @marketStatus.setter
-    def marketStatus(self, status):
-        self.attributes["marketStatus"] = status
-
-    def getMarketStatus(self, progress=None, task_id=0, exchangeSymbol="^NSEI",namedOnly=False):
-        lngStatus = ""
-        try:
-            suppressLogs = True
-            if "PKDevTools_Default_Log_Level" in os.environ.keys():
-                suppressLogs = os.environ["PKDevTools_Default_Log_Level"] == str(log.logging.NOTSET)
-            with SuppressOutput(suppress_stdout=suppressLogs, suppress_stderr=suppressLogs):
-                if progress:
-                    progress[task_id] = {"progress": 0, "total": 1}
-                _,lngStatus,_ = MarketStatus.nseFetcher.capitalMarketStatus(exchange=exchangeSymbol)
-                if exchangeSymbol in ["^NSEI","^BSESN"] and not namedOnly:
-                    _,bseStatus,_ = MarketStatus.nseFetcher.capitalMarketStatus(exchange="^BSESN")
-                    lngStatus = f"{lngStatus} | {bseStatus}"
-            if progress:
-                progress[task_id] = {"progress": 1, "total": 1}
-        except Exception as e:# pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            pass
-        self.marketStatus = lngStatus
-        return lngStatus
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import os
+from PKNSETools.PKNSEStockDataFetcher import nseStockDataFetcher
+from PKDevTools.classes.Singleton import SingletonType, SingletonMixin
+from PKDevTools.classes.log import default_logger
+from PKDevTools.classes.SuppressOutput import SuppressOutput
+from PKDevTools.classes import log as log
+
+class MarketStatus(SingletonMixin, metaclass=SingletonType):
+    nseFetcher = nseStockDataFetcher()
+    def __init__(self):
+        super(MarketStatus, self).__init__()
+
+    @property
+    def exchange(self):
+        if "exchange" in self.attributes.keys():
+            return self.attributes["exchange"]
+        else:
+            return "^NSEI"
+    
+    @exchange.setter
+    def exchange(self, exchangeKey):
+        if self.exchange != exchangeKey:
+            self.marketStatus = self.getMarketStatus(exchangeSymbol=exchangeKey)
+        self.attributes["exchange"] = exchangeKey
+
+    @property
+    def marketStatus(self):
+        if "marketStatus" in self.attributes.keys():
+            return self.attributes["marketStatus"]
+        else:
+            # self.attributes["lock"] = "" # We don't need threading lock here
+            self.marketStatus = ""
+            return self.marketStatus
+    
+    @marketStatus.setter
+    def marketStatus(self, status):
+        self.attributes["marketStatus"] = status
+
+    def getMarketStatus(self, progress=None, task_id=0, exchangeSymbol="^NSEI",namedOnly=False):
+        lngStatus = ""
+        try:
+            suppressLogs = True
+            if "PKDevTools_Default_Log_Level" in os.environ.keys():
+                suppressLogs = os.environ["PKDevTools_Default_Log_Level"] == str(log.logging.NOTSET)
+            with SuppressOutput(suppress_stdout=suppressLogs, suppress_stderr=suppressLogs):
+                if progress:
+                    progress[task_id] = {"progress": 0, "total": 1}
+                _,lngStatus,_ = MarketStatus.nseFetcher.capitalMarketStatus(exchange=exchangeSymbol)
+                if exchangeSymbol in ["^NSEI","^BSESN"] and not namedOnly:
+                    _,bseStatus,_ = MarketStatus.nseFetcher.capitalMarketStatus(exchange="^BSESN")
+                    lngStatus = f"{lngStatus} | {bseStatus}"
+            if progress:
+                progress[task_id] = {"progress": 1, "total": 1}
+        except Exception as e:# pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            pass
+        self.marketStatus = lngStatus
+        return lngStatus
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/OtaUpdater.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/OtaUpdater.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,302 +1,302 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-
-import os
-import platform
-import subprocess
-import sys
-from datetime import timedelta
-
-from PKDevTools.classes import Archiver
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.log import default_logger
-from PKDevTools.classes.OutputControls import OutputControls
-
-import pkscreener.classes.ConfigManager as ConfigManager
-import pkscreener.classes.Fetcher as Fetcher
-from pkscreener.classes import VERSION
-
-class OTAUpdater:
-    developmentVersion = "d"
-    _configManager = ConfigManager.tools()
-    _tools = Fetcher.screenerStockDataFetcher(_configManager)
-    configManager = _configManager
-    fetcher = _tools
-
-    # Download and replace exe through other process for Windows
-    def updateForWindows(url):
-        if url is None or len(url) == 0:
-            return
-        batFile = (
-            """@echo off
-color a
-echo [+] pkscreener Software Updater!
-echo [+] Downloading Software Update...
-echo [+] This may take some time as per your Internet Speed, Please Wait...
-curl -o pkscreenercli.exe -L """
-            + url
-            + """
-echo [+] Newly downloaded file saved in %cd%
-echo [+] Software Update Completed! Run'pkscreenercli.exe' again as usual to continue..
-pause
-del updater.bat & exit
-        """
-        )
-        f = open("updater.bat", "w")
-        f.write(batFile)
-        f.close()
-        subprocess.Popen("start updater.bat", shell=True)
-        sys.exit(0)
-
-    # Download and replace bin through other process for Linux
-    def updateForLinux(url):
-        if url is None or len(url) == 0:
-            return
-        bashFile = (
-            """#!/bin/bash
-echo ""
-echo "[+] Starting PKScreener updater, Please Wait..."
-sleep 3
-echo "[+] pkscreener Software Updater!"
-echo "[+] Downloading Software Update..."
-echo "[+] This may take some time as per your Internet Speed, Please Wait..."
-wget -q """
-            + url
-            + """ -O pkscreenercli.bin
-echo "[+] Newly downloaded file saved in $(pwd)"
-chmod +x pkscreenercli.bin
-echo "[+] Update Completed! Run 'pkscreenercli.bin' again as usual to continue.."
-rm updater.sh
-        """
-        )
-        f = open("updater.sh", "w")
-        f.write(bashFile)
-        f.close()
-        subprocess.Popen("bash updater.sh", shell=True)
-        sys.exit(0)
-
-        # Download and replace run through other process for Mac
-
-    def updateForMac(url):
-        if url is None or len(url) == 0:
-            return
-        bashFile = (
-            """#!/bin/bash
-echo ""
-echo "[+] Starting PKScreener updater, Please Wait..."
-sleep 3
-echo "[+] pkscreener Software Updater!"
-echo "[+] Downloading Software Update..."
-echo "[+] This may take some time as per your Internet Speed, Please Wait..."
-curl -o pkscreenercli.run -L """
-            + url
-            + """
-echo "[+] Newly downloaded file saved in $(pwd)"
-chmod +x pkscreenercli.run
-echo "[+] Update Completed! Run 'pkscreenercli.run' again as usual to continue.."
-rm updater.sh
-        """
-        )
-        f = open("updater.sh", "w")
-        f.write(bashFile)
-        f.close()
-        subprocess.Popen("bash updater.sh", shell=True)
-        sys.exit(0)
-
-    # Parse changelog from release.md
-    def showWhatsNew():
-        url = "https://raw.githubusercontent.com/pkjmesra/PKScreener/main/pkscreener/release.md"
-        md = OTAUpdater.fetcher.fetchURL(url)
-        txt = md.text
-        txt = txt.split("New?")[1]
-        txt = txt.split("## Older Releases")[0]
-        txt = txt.replace("* ", "- ").replace("`", "").strip()
-        return txt + "\n"
-
-    def get_latest_release_info():
-        resp = OTAUpdater.fetcher.fetchURL(
-            "https://api.github.com/repos/pkjmesra/PKScreener/releases/latest"
-        )
-        if "Windows" in platform.system():
-            OTAUpdater.checkForUpdate.url = resp.json()["assets"][1][
-                "browser_download_url"
-            ]
-            size = int(resp.json()["assets"][1]["size"] / (1024 * 1024))
-        elif "Darwin" in platform.system():
-            OTAUpdater.checkForUpdate.url = resp.json()["assets"][2][
-                "browser_download_url"
-            ]
-            size = int(resp.json()["assets"][2]["size"] / (1024 * 1024))
-        else:
-            OTAUpdater.checkForUpdate.url = resp.json()["assets"][0][
-                "browser_download_url"
-            ]
-            size = int(resp.json()["assets"][0]["size"] / (1024 * 1024))
-        return resp, size
-
-    # Check for update and download if available
-    def checkForUpdate(VERSION=VERSION, skipDownload=False):
-        OTAUpdater.checkForUpdate.url = None
-        resp = None
-        updateType = "minor"
-        try:
-            now_components = str(VERSION).split(".")
-            now_major_minor = ".".join([now_components[0], now_components[1]])
-            now = float(now_major_minor)
-            resp, size = OTAUpdater.get_latest_release_info()
-            tag = resp.json()["tag_name"]
-            version_components = tag.split(".")
-            major_minor = ".".join([version_components[0], version_components[1]])
-            last_release = float(major_minor)
-            prod_update = False
-            if last_release > now:
-                updateType = "major"
-                prod_update = True
-            elif last_release == now and (
-                len(now_components) < len(version_components)
-            ):
-                # Must be the weekly update over the last major.minor update
-                prod_update = True
-            elif last_release == now and (
-                len(now_components) == len(version_components)
-            ):
-                if float(now_components[2]) < float(version_components[2]):
-                    prod_update = True
-                elif float(now_components[2]) == float(version_components[2]):
-                    if float(now_components[3]) < float(version_components[3]):
-                        prod_update = True
-            if prod_update:
-                if skipDownload:
-                    OutputControls().printOutput(
-                        colorText.BOLD
-                        + colorText.GREEN
-                        + f"    [+] A {updateType} software update (v{tag} [{size} MB]) is available. Check out with the menu option U."
-                        + colorText.END
-                    )
-                    return
-                OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + "[+] What's New in this Update?\n"
-                    + colorText.END
-                    + colorText.GREEN
-                    + OTAUpdater.showWhatsNew()
-                    + colorText.END
-                )
-                try:
-                    action = input(
-                            colorText.BOLD
-                            + colorText.FAIL
-                            + (
-                                f"\n[+] New {updateType} Software update (v%s) available. Download Now (Size: %dMB)? [Y/N]: "
-                                % (str(tag), size)
-                            )
-                        ) or "y"
-                except EOFError: # user pressed enter
-                    action = "y"
-                    pass
-                if action is not None and action.lower() == "y":
-                    try:
-                        if "Windows" in platform.system():
-                            OTAUpdater.updateForWindows(OTAUpdater.checkForUpdate.url)
-                        elif "Darwin" in platform.system():
-                            OTAUpdater.updateForMac(OTAUpdater.checkForUpdate.url)
-                        else:
-                            OTAUpdater.updateForLinux(OTAUpdater.checkForUpdate.url)
-                    except Exception as e:  # pragma: no cover
-                        default_logger().debug(e, exc_info=True)
-                        OutputControls().printOutput(
-                            colorText.BOLD
-                            + colorText.WARN
-                            + "[+] Error occured while updating!"
-                            + colorText.END
-                        )
-                        raise (e)
-            elif not prod_update and not skipDownload:
-                if tag.lower() == VERSION.lower():
-                    OutputControls().printOutput(
-                        colorText.BOLD
-                        + colorText.GREEN
-                        + (
-                            "[+] No new update available. You have the latest version (v%s) !"
-                            % VERSION
-                        )
-                        + colorText.END
-                    )
-                else:
-                    if float(now_components[0]) > float(version_components[0]) or \
-                        float(now_components[1]) > float(version_components[1]) or \
-                        float(now_components[2]) > float(version_components[2]) or \
-                        float(now_components[3]) > float(version_components[3]):
-                        OutputControls().printOutput(
-                            colorText.BOLD
-                            + colorText.FAIL
-                            + (f"[+] This version (v{VERSION}) is in Development! Thanks for trying out!")
-                            + colorText.END
-                        )
-                        return OTAUpdater.developmentVersion
-                    else:
-                        OutputControls().printOutput(
-                        colorText.BOLD
-                        + colorText.GREEN
-                        + (
-                            "[+] No new update available. You have the latest version (v%s) !"
-                            % VERSION
-                        )
-                        + colorText.END
-                    )
-        except Exception as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            if OTAUpdater.checkForUpdate.url is not None:
-                OutputControls().printOutput(e)
-                OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.BLUE
-                    + (
-                        "[+] Download update manually from %s\n"
-                        % OTAUpdater.checkForUpdate.url
-                    )
-                    + colorText.END
-                )
-            else:
-                OTAUpdater.checkForUpdate.url = (
-                    "[+] No exe/bin/run file as an update available!"
-                )
-            if resp is not None and resp.json()["message"] == "Not Found":
-                OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + OTAUpdater.checkForUpdate.url
-                    + colorText.END
-                )
-            if not skipDownload:
-                OutputControls().printOutput(e)
-                OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + "[+] Failure while checking update!"
-                    + colorText.END
-                )
-        return
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+
+import os
+import platform
+import subprocess
+import sys
+from datetime import timedelta
+
+from PKDevTools.classes import Archiver
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.log import default_logger
+from PKDevTools.classes.OutputControls import OutputControls
+
+import pkscreener.classes.ConfigManager as ConfigManager
+import pkscreener.classes.Fetcher as Fetcher
+from pkscreener.classes import VERSION
+
+class OTAUpdater:
+    developmentVersion = "d"
+    _configManager = ConfigManager.tools()
+    _tools = Fetcher.screenerStockDataFetcher(_configManager)
+    configManager = _configManager
+    fetcher = _tools
+
+    # Download and replace exe through other process for Windows
+    def updateForWindows(url):
+        if url is None or len(url) == 0:
+            return
+        batFile = (
+            """@echo off
+color a
+echo [+] pkscreener Software Updater!
+echo [+] Downloading Software Update...
+echo [+] This may take some time as per your Internet Speed, Please Wait...
+curl -o pkscreenercli.exe -L """
+            + url
+            + """
+echo [+] Newly downloaded file saved in %cd%
+echo [+] Software Update Completed! Run'pkscreenercli.exe' again as usual to continue..
+pause
+del updater.bat & exit
+        """
+        )
+        f = open("updater.bat", "w")
+        f.write(batFile)
+        f.close()
+        subprocess.Popen("start updater.bat", shell=True)
+        sys.exit(0)
+
+    # Download and replace bin through other process for Linux
+    def updateForLinux(url):
+        if url is None or len(url) == 0:
+            return
+        bashFile = (
+            """#!/bin/bash
+echo ""
+echo "[+] Starting PKScreener updater, Please Wait..."
+sleep 3
+echo "[+] pkscreener Software Updater!"
+echo "[+] Downloading Software Update..."
+echo "[+] This may take some time as per your Internet Speed, Please Wait..."
+wget -q """
+            + url
+            + """ -O pkscreenercli.bin
+echo "[+] Newly downloaded file saved in $(pwd)"
+chmod +x pkscreenercli.bin
+echo "[+] Update Completed! Run 'pkscreenercli.bin' again as usual to continue.."
+rm updater.sh
+        """
+        )
+        f = open("updater.sh", "w")
+        f.write(bashFile)
+        f.close()
+        subprocess.Popen("bash updater.sh", shell=True)
+        sys.exit(0)
+
+        # Download and replace run through other process for Mac
+
+    def updateForMac(url):
+        if url is None or len(url) == 0:
+            return
+        bashFile = (
+            """#!/bin/bash
+echo ""
+echo "[+] Starting PKScreener updater, Please Wait..."
+sleep 3
+echo "[+] pkscreener Software Updater!"
+echo "[+] Downloading Software Update..."
+echo "[+] This may take some time as per your Internet Speed, Please Wait..."
+curl -o pkscreenercli.run -L """
+            + url
+            + """
+echo "[+] Newly downloaded file saved in $(pwd)"
+chmod +x pkscreenercli.run
+echo "[+] Update Completed! Run 'pkscreenercli.run' again as usual to continue.."
+rm updater.sh
+        """
+        )
+        f = open("updater.sh", "w")
+        f.write(bashFile)
+        f.close()
+        subprocess.Popen("bash updater.sh", shell=True)
+        sys.exit(0)
+
+    # Parse changelog from release.md
+    def showWhatsNew():
+        url = "https://raw.githubusercontent.com/pkjmesra/PKScreener/main/pkscreener/release.md"
+        md = OTAUpdater.fetcher.fetchURL(url)
+        txt = md.text
+        txt = txt.split("New?")[1]
+        txt = txt.split("## Older Releases")[0]
+        txt = txt.replace("* ", "- ").replace("`", "").strip()
+        return txt + "\n"
+
+    def get_latest_release_info():
+        resp = OTAUpdater.fetcher.fetchURL(
+            "https://api.github.com/repos/pkjmesra/PKScreener/releases/latest"
+        )
+        if "Windows" in platform.system():
+            OTAUpdater.checkForUpdate.url = resp.json()["assets"][1][
+                "browser_download_url"
+            ]
+            size = int(resp.json()["assets"][1]["size"] / (1024 * 1024))
+        elif "Darwin" in platform.system():
+            OTAUpdater.checkForUpdate.url = resp.json()["assets"][2][
+                "browser_download_url"
+            ]
+            size = int(resp.json()["assets"][2]["size"] / (1024 * 1024))
+        else:
+            OTAUpdater.checkForUpdate.url = resp.json()["assets"][0][
+                "browser_download_url"
+            ]
+            size = int(resp.json()["assets"][0]["size"] / (1024 * 1024))
+        return resp, size
+
+    # Check for update and download if available
+    def checkForUpdate(VERSION=VERSION, skipDownload=False):
+        OTAUpdater.checkForUpdate.url = None
+        resp = None
+        updateType = "minor"
+        try:
+            now_components = str(VERSION).split(".")
+            now_major_minor = ".".join([now_components[0], now_components[1]])
+            now = float(now_major_minor)
+            resp, size = OTAUpdater.get_latest_release_info()
+            tag = resp.json()["tag_name"]
+            version_components = tag.split(".")
+            major_minor = ".".join([version_components[0], version_components[1]])
+            last_release = float(major_minor)
+            prod_update = False
+            if last_release > now:
+                updateType = "major"
+                prod_update = True
+            elif last_release == now and (
+                len(now_components) < len(version_components)
+            ):
+                # Must be the weekly update over the last major.minor update
+                prod_update = True
+            elif last_release == now and (
+                len(now_components) == len(version_components)
+            ):
+                if float(now_components[2]) < float(version_components[2]):
+                    prod_update = True
+                elif float(now_components[2]) == float(version_components[2]):
+                    if float(now_components[3]) < float(version_components[3]):
+                        prod_update = True
+            if prod_update:
+                if skipDownload:
+                    OutputControls().printOutput(
+                        colorText.BOLD
+                        + colorText.GREEN
+                        + f"    [+] A {updateType} software update (v{tag} [{size} MB]) is available. Check out with the menu option U."
+                        + colorText.END
+                    )
+                    return
+                OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + "[+] What's New in this Update?\n"
+                    + colorText.END
+                    + colorText.GREEN
+                    + OTAUpdater.showWhatsNew()
+                    + colorText.END
+                )
+                try:
+                    action = input(
+                            colorText.BOLD
+                            + colorText.FAIL
+                            + (
+                                f"\n[+] New {updateType} Software update (v%s) available. Download Now (Size: %dMB)? [Y/N]: "
+                                % (str(tag), size)
+                            )
+                        ) or "y"
+                except EOFError: # user pressed enter
+                    action = "y"
+                    pass
+                if action is not None and action.lower() == "y":
+                    try:
+                        if "Windows" in platform.system():
+                            OTAUpdater.updateForWindows(OTAUpdater.checkForUpdate.url)
+                        elif "Darwin" in platform.system():
+                            OTAUpdater.updateForMac(OTAUpdater.checkForUpdate.url)
+                        else:
+                            OTAUpdater.updateForLinux(OTAUpdater.checkForUpdate.url)
+                    except Exception as e:  # pragma: no cover
+                        default_logger().debug(e, exc_info=True)
+                        OutputControls().printOutput(
+                            colorText.BOLD
+                            + colorText.WARN
+                            + "[+] Error occured while updating!"
+                            + colorText.END
+                        )
+                        raise (e)
+            elif not prod_update and not skipDownload:
+                if tag.lower() == VERSION.lower():
+                    OutputControls().printOutput(
+                        colorText.BOLD
+                        + colorText.GREEN
+                        + (
+                            "[+] No new update available. You have the latest version (v%s) !"
+                            % VERSION
+                        )
+                        + colorText.END
+                    )
+                else:
+                    if float(now_components[0]) > float(version_components[0]) or \
+                        float(now_components[1]) > float(version_components[1]) or \
+                        float(now_components[2]) > float(version_components[2]) or \
+                        float(now_components[3]) > float(version_components[3]):
+                        OutputControls().printOutput(
+                            colorText.BOLD
+                            + colorText.FAIL
+                            + (f"[+] This version (v{VERSION}) is in Development! Thanks for trying out!")
+                            + colorText.END
+                        )
+                        return OTAUpdater.developmentVersion
+                    else:
+                        OutputControls().printOutput(
+                        colorText.BOLD
+                        + colorText.GREEN
+                        + (
+                            "[+] No new update available. You have the latest version (v%s) !"
+                            % VERSION
+                        )
+                        + colorText.END
+                    )
+        except Exception as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            if OTAUpdater.checkForUpdate.url is not None:
+                OutputControls().printOutput(e)
+                OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.BLUE
+                    + (
+                        "[+] Download update manually from %s\n"
+                        % OTAUpdater.checkForUpdate.url
+                    )
+                    + colorText.END
+                )
+            else:
+                OTAUpdater.checkForUpdate.url = (
+                    "[+] No exe/bin/run file as an update available!"
+                )
+            if resp is not None and resp.json()["message"] == "Not Found":
+                OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + OTAUpdater.checkForUpdate.url
+                    + colorText.END
+                )
+            if not skipDownload:
+                OutputControls().printOutput(e)
+                OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + "[+] Failure while checking update!"
+                    + colorText.END
+                )
+        return
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKMarketOpenCloseAnalyser.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKMarketOpenCloseAnalyser.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,400 +1,400 @@
-#!/usr/bin/env python
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import copy
-import datetime
-import shutil
-import sys
-import os
-import numpy as np
-import pandas as pd
-import pkscreener.classes.Utility as Utility
-from pkscreener.classes.ConfigManager import parser, tools
-from pkscreener.classes.ScreeningStatistics import ScreeningStatistics
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes import Archiver
-from PKDevTools.classes.Singleton import SingletonType, SingletonMixin
-from PKDevTools.classes.PKPickler import PKPicklerDB
-from PKDevTools.classes.PKDateUtilities import PKDateUtilities
-from PKDevTools.classes.log import default_logger
-from PKDevTools.classes.OutputControls import OutputControls
-
-STD_ENCODING=sys.stdout.encoding if sys.stdout is not None else 'utf-8'
-
-class PKDailyStockDataDB(SingletonMixin, metaclass=SingletonType):
-    def __init__(self,fileName=None):
-        super(PKDailyStockDataDB, self).__init__()
-        self.pickler = PKPicklerDB(fileName=fileName)
-
-    def searchCache(self, ticker:str=None, name:str=None):
-        return self.pickler.searchCache(ticker=ticker, name=name)
-    
-    def saveCache(self, ticker:str=None, name:str=None, stockDict:dict=None):
-        self.pickler.saveCache(ticker=ticker, name=name, stockDict=stockDict)
-
-class PKIntradayStockDataDB(SingletonMixin, metaclass=SingletonType):
-    def __init__(self,fileName=None):
-        super(PKIntradayStockDataDB, self).__init__()
-        self.pickler = PKPicklerDB(fileName=fileName)
-
-    def searchCache(self, ticker:str=None, name:str=None):
-        return self.pickler.searchCache(ticker=ticker, name=name)
-    
-    def saveCache(self, ticker:str=None, name:str=None, stockDict:dict=None):
-        self.pickler.saveCache(ticker=ticker, name=name, stockDict=stockDict)
-
-
-class PKMarketOpenCloseAnalyser:
-    configManager = tools()
-    configManager.getConfig(parser)
-    updatedCandleData = None
-    allDailyCandles = None
-    allIntradayCandles = None
-    def getStockDataForSimulation():
-        int_exists, int_cache_file = PKMarketOpenCloseAnalyser.ensureIntradayStockDataExists()
-        daily_exists, daily_cache_file = PKMarketOpenCloseAnalyser.ensureDailyStockDataExists()
-        updatedCandleData = PKMarketOpenCloseAnalyser.updatedCandleData
-        allDailyCandles = PKMarketOpenCloseAnalyser.allDailyCandles
-        if  (int_exists and daily_exists) and (updatedCandleData is None or allDailyCandles is None):
-            allDailyCandles = PKMarketOpenCloseAnalyser.getLatestDailyCandleData(daily_cache_file)
-            morningIntradayCandle = PKMarketOpenCloseAnalyser.getIntradayCandleFromMorning(int_cache_file)
-            updatedCandleData = PKMarketOpenCloseAnalyser.combineDailyStockDataWithMorningSimulation(allDailyCandles,morningIntradayCandle)
-            # PKMarketOpenCloseAnalyser.updatedCandleData = updatedCandleData
-            # PKMarketOpenCloseAnalyser.allDailyCandles = allDailyCandles
-            Utility.tools.saveStockData(updatedCandleData,PKMarketOpenCloseAnalyser.configManager,1,False,False, True)
-        return updatedCandleData, allDailyCandles
-
-    def runOpenCloseAnalysis(updatedCandleData,allDailyCandles,screen_df,save_df,runOptionName=None,filteredListOfStocks=[]):
-        # stockListFromMorningTrade,morningIntraday_df = PKMarketOpenCloseAnalyser.simulateMorningTrade(updatedCandleData)
-        # latest_daily_df = PKMarketOpenCloseAnalyser.runScanForStocksFromMorningTrade(stockListFromMorningTrade,allDailyCandles)
-        try:
-            PKMarketOpenCloseAnalyser.diffMorningCandleDataWithLatestDailyCandleData(screen_df,save_df, updatedCandleData, allDailyCandles,runOptionName=runOptionName,filteredListOfStocks=filteredListOfStocks)
-        except:
-            pass
-        Utility.tools.saveStockData(allDailyCandles,PKMarketOpenCloseAnalyser.configManager,1,False,False, True)
-
-    def ensureIntradayStockDataExists():
-        # Ensure that the intraday_stock_data_<date>.pkl file exists
-        exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday=True)
-        copyFilePath = os.path.join(Archiver.get_user_outputs_dir(), f"copy_{cache_file}")
-        srcFilePath = os.path.join(Archiver.get_user_outputs_dir(), cache_file)
-        srcFileSize = os.stat(srcFilePath).st_size if os.path.exists(srcFilePath) else 0
-        if exists and srcFileSize < 1024*1024*50:
-             # File less than 30MB ? Must have been corrupted
-            try:
-                os.remove(srcFilePath)
-                exists = False
-            except:
-                pass
-        if not exists:
-            savedPeriod = PKMarketOpenCloseAnalyser.configManager.period
-            savedDuration = PKMarketOpenCloseAnalyser.configManager.duration
-            PKMarketOpenCloseAnalyser.configManager.period = "1d"
-            PKMarketOpenCloseAnalyser.configManager.duration = "1m"
-            OutputControls().printOutput(f"[+] {colorText.FAIL}{cache_file}{colorText.END} not found under {Archiver.get_user_outputs_dir()} !")
-            OutputControls().printOutput(f"[+] {colorText.GREEN}Trying to download {cache_file}{colorText.END}. Please wait ...")
-            Utility.tools.loadStockData({},PKMarketOpenCloseAnalyser.configManager,False,'Y',False,False,None,isIntraday=True)
-            exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday=True)
-            if not exists:
-                OutputControls().printOutput(f"[+] {colorText.FAIL}{cache_file}{colorText.END} not found under {Archiver.get_user_outputs_dir()} !")
-                OutputControls().printOutput(f"[+] Please run {colorText.FAIL}pkscreener{colorText.END}{colorText.GREEN} -a Y -e -d -i 1m{colorText.END} and then run this menu option again.")
-                input("Press any key to continue...")
-            PKMarketOpenCloseAnalyser.configManager.period = savedPeriod
-            PKMarketOpenCloseAnalyser.configManager.duration = savedDuration
-        try:
-            if os.path.exists(copyFilePath) and exists:
-                shutil.copy(copyFilePath,srcFilePath) # copy is the saved source of truth
-            if not os.path.exists(copyFilePath) and exists: # Let's make a copy of the original one
-                shutil.copy(srcFilePath,copyFilePath)
-        except:
-            pass
-        return exists, cache_file
-
-    def ensureDailyStockDataExists():
-        # Ensure that the stock_data_<date>.pkl file exists
-        exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday=False)
-        copyFilePath = os.path.join(Archiver.get_user_outputs_dir(), f"copy_{cache_file}")
-        srcFilePath = os.path.join(Archiver.get_user_outputs_dir(), cache_file)
-        srcFileSize = os.stat(srcFilePath).st_size if os.path.exists(srcFilePath) else 0
-        if exists and srcFileSize < 1024*1024*50:
-             # File less than 30MB ? Must have been corrupted
-            try:
-                os.remove(srcFilePath)
-                exists = False
-            except:
-                pass
-        if not exists:
-            OutputControls().printOutput(f"[+] {colorText.FAIL}{cache_file}{colorText.END} not found under {Archiver.get_user_outputs_dir()} !")
-        # We should download a fresh copy anyways because we may have altered the existing copy in
-        # the previous run. -- !!!! Not required if we saved at the end of last operation !!!!
-            OutputControls().printOutput(f"[+] {colorText.GREEN}Trying to download {cache_file}{colorText.END}. Please wait ...")
-            Utility.tools.loadStockData({},PKMarketOpenCloseAnalyser.configManager,False,'Y',False,False,None,isIntraday=False,forceRedownload=True)
-            exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday=False)
-            if not exists:
-                OutputControls().printOutput(f"[+] {colorText.FAIL}{cache_file}{colorText.END} not found under {Archiver.get_user_outputs_dir()} !")
-                OutputControls().printOutput(f"[+] Please run {colorText.FAIL}pkscreener{colorText.END}{colorText.GREEN} -a Y -e -d{colorText.END} and then run this menu option again.")
-                input("Press any key to continue...")
-        try:
-            if os.path.exists(copyFilePath) and exists:
-                shutil.copy(copyFilePath,srcFilePath) # copy is the saved source of truth
-            if not os.path.exists(copyFilePath) and exists: # Let's make a copy of the original one
-                shutil.copy(srcFilePath,copyFilePath)
-        except:
-            pass
-        return exists, cache_file
-    
-    def simulateMorningTrade(updatedCandleData):
-        # 1. For each stock, remove the latest daily data for today from stock_data_<date>.pkl
-        # 2. For each stock, only take the configManager.morninganalysiscandlenumber data rows
-        #    and combine them as one candle - open for the earliest candle and close for the last candle,
-        #    low and high will be the lowest and highest for in-between candles. Volume should be combined
-        #    for all.
-        # 3. For each stock, replace the row from #1 above with the candle data from #2 above.
-        # 4. Run scan and find stocks under each (selected) scan category as if the scan was
-        #    running in the morning. 
-        # 5. Compare the stock prices from #4 with the removed row from #1 and show the diff.
-        stockListFromMorningTrade = []
-        morningIntraday_df = None
-        return stockListFromMorningTrade, morningIntraday_df
-    
-    def getLatestDailyCandleData(daily_cache_file):
-        allDailyCandles = None
-        dailyDB = PKDailyStockDataDB(fileName=daily_cache_file)
-        allDailyCandles = dailyDB.pickler.pickler.unpickle(fileName=dailyDB.pickler.fileName)
-        # latestDailyCandle = {}
-        # stocks = list(allDailyCandles.keys())
-        # for stock in stocks:
-        #     try:
-        #         df = pd.DataFrame(data=[allDailyCandles[stock]["data"][-1]],
-        #                       columns=allDailyCandles[stock]["columns"],
-        #                       index=[allDailyCandles[stock]["index"][-1]])
-        #         latestDailyCandle[stock] = df.to_dict("split")
-        #     except:
-        #         continue
-        return allDailyCandles
-    
-    def getIntradayCandleFromMorning(int_cache_file=None,candle1MinuteNumberSinceMarketStarted=0):
-        if candle1MinuteNumberSinceMarketStarted <= 0:
-            candle1MinuteNumberSinceMarketStarted = PKMarketOpenCloseAnalyser.configManager.morninganalysiscandlenumber
-        morningIntradayCandle = None
-        intradayDB = PKIntradayStockDataDB(fileName=int_cache_file)
-        allDailyIntradayCandles = intradayDB.pickler.pickler.unpickle(fileName=intradayDB.pickler.fileName)
-        PKMarketOpenCloseAnalyser.allIntradayCandles = allDailyIntradayCandles
-        morningIntradayCandle = {}
-        stocks = list(allDailyIntradayCandles.keys())
-        numOfCandles = PKMarketOpenCloseAnalyser.configManager.morninganalysiscandlenumber
-        duration = PKMarketOpenCloseAnalyser.configManager.morninganalysiscandleduration
-        numOfCandles = numOfCandles * int(duration.replace("m",""))
-        for stock in stocks:
-            try:
-                # Let's get the saved data from the DB. Then we need to only
-                # get those candles which are earlier than 9:57AM which is
-                # the time when the morning alerts collect data for generating alerts
-                # We'd then combine the data from 9:15 to 9:57 as a single candle of 
-                # OHLCV and replace the last daily candle with this one candle to
-                # simulate the scan outcome from morning.
-                df = pd.DataFrame(data=allDailyIntradayCandles[stock]["data"],
-                                columns=allDailyIntradayCandles[stock]["columns"],
-                                index=allDailyIntradayCandles[stock]["index"])
-                df = df.head(numOfCandles)
-                try:
-                    df = df[df.index <=  pd.to_datetime(f'{PKDateUtilities.tradingDate().strftime(f"%Y-%m-%d")} 09:{15+candle1MinuteNumberSinceMarketStarted}:00+05:30').to_datetime64()]
-                except:
-                    df = df[df.index <=  pd.to_datetime(f'{PKDateUtilities.tradingDate().strftime(f"%Y-%m-%d")} 09:{15+candle1MinuteNumberSinceMarketStarted}:00+05:30', utc=True)]
-                    pass
-                if df is not None and len(df) > 0:
-                    combinedCandle = {"Open":PKMarketOpenCloseAnalyser.getMorningOpen(df), "High":max(df["High"]), 
-                                    "Low":min(df["Low"]),"Close":PKMarketOpenCloseAnalyser.getMorningClose(df),
-                                    "Adj Close":df["Adj Close"][-1],"Volume":sum(df["Volume"])}
-                    tradingDate = df.index[-1] #PKDateUtilities.tradingDate()
-                    timestamp = datetime.datetime.strptime(tradingDate.strftime("%Y-%m-%d %H:%M:%S"),"%Y-%m-%d %H:%M:%S")
-                    df = pd.DataFrame([combinedCandle], columns=df.columns, index=[timestamp])
-                    morningIntradayCandle[stock] = df.to_dict("split")
-            except Exception as e:
-                OutputControls().printOutput(f"{stock}:    {e}")
-                continue
-        return morningIntradayCandle
-
-    def getMorningOpen(df):
-        open = df["Open"][0]
-        index = 0
-        while open is np.nan and index < len(df):
-            open = df["Open"][index + 1]
-            index += 1
-        return open
-    
-    def getMorningClose(df):
-        close = df["Close"][-1]
-        index = len(df)
-        while close is np.nan and index >= 0:
-            close = df["Close"][index - 1]
-            index -= 1
-        return close
-    
-    def combineDailyStockDataWithMorningSimulation(allDailyCandles,morningIntradayCandle):
-        mutableAllDailyCandles = copy.deepcopy(allDailyCandles)
-        stocks = list(mutableAllDailyCandles.keys())
-        intradayStocks = list(morningIntradayCandle.keys())
-        priceDict = {}
-        listPriceDict = []
-        for stock in stocks:
-            try:
-                priceDict = {}
-                if stock in intradayStocks:
-                    morningPrice = round(morningIntradayCandle[stock]["data"][0][3],2)
-                    closePrice = round(mutableAllDailyCandles[stock]["data"][-1][3],2)
-                    priceDict["Stock"] = stock
-                    priceDict["Morning"] = morningPrice
-                    priceDict["EoD"] = closePrice
-                    listPriceDict.append(priceDict)
-                    # We basically need to replace today's candle with a single candle that has data from market open to the time
-                    # when we are taking as reference point in the morning. This is how it would have looked when running the scan 
-                    # in the morning hours.
-                    mutableAllDailyCandles[stock]["data"] = mutableAllDailyCandles[stock]["data"][:-1] + [morningIntradayCandle[stock]["data"][0]]
-                    mutableAllDailyCandles[stock]["index"] = mutableAllDailyCandles[stock]["index"][:-1] + morningIntradayCandle[stock]["index"]
-                else:
-                    # We should ideally have all stocks from intraday and eod matching,
-                    # but for whatever reason, if we don't have the stock, we should skip those
-                    # stocks from analysis
-                    del mutableAllDailyCandles[stock]
-            except:
-                del mutableAllDailyCandles[stock]
-                if 'PKDevTools_Default_Log_Level' in os.environ.keys():
-                    intradayChange = colorText.miniTabulator().tabulate(
-                                        pd.DataFrame(listPriceDict),
-                                        headers="keys",
-                                        tablefmt=colorText.No_Pad_GridFormat,
-                                        showindex=False
-                                    ).encode("utf-8").decode(STD_ENCODING)
-                    default_logger().debug(intradayChange)
-                continue
-        return mutableAllDailyCandles
-
-    def runScanForStocksFromMorningTrade(stockListFromMorningTrade,dailyCandleData):
-        latest_daily_df = None
-        return latest_daily_df
-
-    def diffMorningCandleDataWithLatestDailyCandleData(screen_df,save_df, updatedCandleData, allDailyCandles,runOptionName=None,filteredListOfStocks=[]):
-        save_df.reset_index(inplace=True)
-        screen_df.reset_index(inplace=True)
-        save_df.drop(f"index", axis=1, inplace=True, errors="ignore")
-        screen_df.drop(f"index", axis=1, inplace=True, errors="ignore")
-        stocks = save_df["Stock"]
-        eodLTPs = []
-        dayHighLTPs = []
-        morningTimestamps = []
-        morningAlertLTPs = []
-        sellTimestamps = []
-        dayHighTimestamps = []
-        sellLTPs = []
-        eodDiffs = []
-        dayHighDiffs = []
-        sqrOffDiffs = []
-        index = 0
-        scrStats = ScreeningStatistics(PKMarketOpenCloseAnalyser.configManager, default_logger())
-        for stock in stocks:
-            try:
-                # Open, High, Low, Close, Adj Close, Volume. We need the 3rd index item: Close.
-                dayHighLTP = allDailyCandles[stock]["data"][-1][1]
-                endOfDayLTP = allDailyCandles[stock]["data"][-1][3]
-                savedMorningLTP = updatedCandleData[stock]["data"][-1][3]
-                morningLTP = savedMorningLTP if pd.notna(savedMorningLTP) else round(save_df["LTP"][index],2)
-                morningTime = updatedCandleData[stock]["index"][-1].strftime("%H:%M")
-                morningTimestamps.append(morningTime)
-                morningCandles = PKMarketOpenCloseAnalyser.allIntradayCandles
-                df = pd.DataFrame(data=morningCandles[stock]["data"],
-                                columns=morningCandles[stock]["columns"],
-                                index=morningCandles[stock]["index"])
-                # try:
-                #     # Let's only consider those candles that are after the alert issue-time in the mornings
-                #     df = df[df.index >=  pd.to_datetime(f'{PKDateUtilities.tradingDate().strftime(f"%Y-%m-%d")} 09:{15+PKMarketOpenCloseAnalyser.configManager.morninganalysiscandlenumber}:00+05:30').to_datetime64()]
-                # except:
-                #     df = df[df.index >=  pd.to_datetime(f'{PKDateUtilities.tradingDate().strftime(f"%Y-%m-%d")} 09:{15+PKMarketOpenCloseAnalyser.configManager.morninganalysiscandlenumber}:00+05:30', utc=True)]
-                #     pass
-                ts, row = scrStats.findMACDCrossover(df=df,
-                                           afterTimestamp=updatedCandleData[stock]["index"][-1],
-                                           nthCrossover=1,
-                                           upDirection=True)
-                highTS, highRow = scrStats.findIntradayHighCrossover(df=df)
-                dayHighLTP = dayHighLTP if pd.notna(dayHighLTP) else highRow["High"][-1]
-                sellTimestamps.append(ts.strftime("%H:%M"))
-                dayHighTimestamps.append(highTS.strftime("%H:%M"))
-                sellLTPs.append(row["High"][-1])
-                eodLTPs.append(round(endOfDayLTP,2))
-                dayHighLTPs.append(round(dayHighLTP,2))
-                eodDiffs.append(round(endOfDayLTP - morningLTP,2))
-                dayHighDiffs.append(round(dayHighLTP - morningLTP,2))
-                sqrOffDiffs.append(round(row["High"][-1] - morningLTP,2))
-                morningAlertLTPs.append(str(int(round(morningLTP,0))))
-                index += 1
-            except:
-                eodLTPs.append("0")
-                eodDiffs.append("0")
-                dayHighLTPs.append("0")
-                dayHighDiffs.append("0")
-                continue
-        diffColumns = ["LTP@Alert", "AlertTime", "SqrOff", "SqrOffLTP", "SqrOffDiff","DayHighTime","DayHigh","DayHighDiff", "EoDLTP", "EoDDiff"]
-        diffValues = [morningAlertLTPs, morningTimestamps, sellTimestamps, sellLTPs, sqrOffDiffs,dayHighTimestamps,dayHighLTPs, dayHighDiffs,eodLTPs, eodDiffs]
-        for col in diffColumns:
-            save_df[col] = diffValues[diffColumns.index(col)]
-            screen_df.loc[:, col] = save_df.loc[:, col].apply(
-                lambda x: x if col in ["LTP@Alert","AlertTime", "SqrOff", "SqrOffLTP", "EoDLTP","DayHigh","DayHighTime"] else ((colorText.GREEN if x >= 0 else colorText.FAIL) + str(x) + colorText.END)
-            )
-
-        columns = save_df.columns
-        lastIndex = len(save_df)
-        for col in columns:
-            if col in ["Stock", "Pattern", "LTP", "SqrOffLTP","SqrOffDiff","DayHigh","DayHighDiff", "EoDLTP", "EoDDiff", "%Chng"]:
-                if col == "Stock":
-                    save_df.loc[lastIndex,col] = "PORTFOLIO"
-                elif col == "Pattern":
-                    save_df.loc[lastIndex,col] = runOptionName if runOptionName is not None else ""
-                elif col in ["LTP", "SqrOffLTP","SqrOffDiff", "EoDLTP", "EoDDiff","DayHigh","DayHighDiff"]:
-                    save_df.loc[lastIndex,col] = round(sum(save_df[col].dropna(inplace=False).astype(float)),2)
-                elif col == "%Chng":
-                    ltpSum = sum(save_df["LTP"].dropna(inplace=False).astype(float))
-                    change_pct = sum(save_df["EoDDiff"].dropna(inplace=False).astype(float))*100/ltpSum
-                    save_df.loc[lastIndex,col] = f"{round(2*change_pct,2)}%" # when summing above for LTP, the total of LTP gets summed up too. Hence *2 here.
-            else:
-                save_df.loc[lastIndex,col] = ""
-            screen_df.loc[lastIndex,col] = save_df.loc[lastIndex,col]
-        eodDiff = save_df.loc[lastIndex,"EoDDiff"]
-        sqrOffDiff = save_df.loc[lastIndex,"SqrOffDiff"]
-        dayHighDiff = save_df.loc[lastIndex,"DayHighDiff"]
-        save_df.loc[lastIndex,"EoDDiff"] = str(eodDiff) + f'({round(100*2*eodDiff/ltpSum,2)}%)'
-        save_df.loc[lastIndex,"SqrOffDiff"] = str(sqrOffDiff) + f'({round(100*2*sqrOffDiff/ltpSum,2)}%)'
-        save_df.loc[lastIndex,"DayHighDiff"] = str(dayHighDiff) + f'({round(100*2*dayHighDiff/ltpSum,2)}%)'
-        screen_df.loc[lastIndex,"EoDDiff"] = (colorText.GREEN if eodDiff >= 0 else colorText.FAIL) + save_df.loc[lastIndex,"EoDDiff"] + colorText.END
-        screen_df.loc[lastIndex,"SqrOffDiff"] = (colorText.GREEN if sqrOffDiff >= 0 else colorText.FAIL) + save_df.loc[lastIndex,"SqrOffDiff"] + colorText.END
-        screen_df.loc[lastIndex,"DayHighDiff"] = (colorText.GREEN if dayHighDiff >= 0 else colorText.FAIL) + save_df.loc[lastIndex,"DayHighDiff"] + colorText.END
-        save_df.set_index("Stock", inplace=True)
-        screen_df.set_index("Stock", inplace=True)
-        PKMarketOpenCloseAnalyser.allIntradayCandles = None
-        screen_df.replace(np.nan, "", regex=True)
-        save_df.replace(np.nan, "", regex=True)
-        if 'index' in save_df.columns:
-            save_df.drop('index', axis=1, inplace=True, errors="ignore")
-        if 'index' in screen_df.columns:
-            screen_df.drop('index', axis=1, inplace=True, errors="ignore")
+#!/usr/bin/env python
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import copy
+import datetime
+import shutil
+import sys
+import os
+import numpy as np
+import pandas as pd
+import pkscreener.classes.Utility as Utility
+from pkscreener.classes.ConfigManager import parser, tools
+from pkscreener.classes.ScreeningStatistics import ScreeningStatistics
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes import Archiver
+from PKDevTools.classes.Singleton import SingletonType, SingletonMixin
+from PKDevTools.classes.PKPickler import PKPicklerDB
+from PKDevTools.classes.PKDateUtilities import PKDateUtilities
+from PKDevTools.classes.log import default_logger
+from PKDevTools.classes.OutputControls import OutputControls
+
+STD_ENCODING=sys.stdout.encoding if sys.stdout is not None else 'utf-8'
+
+class PKDailyStockDataDB(SingletonMixin, metaclass=SingletonType):
+    def __init__(self,fileName=None):
+        super(PKDailyStockDataDB, self).__init__()
+        self.pickler = PKPicklerDB(fileName=fileName)
+
+    def searchCache(self, ticker:str=None, name:str=None):
+        return self.pickler.searchCache(ticker=ticker, name=name)
+    
+    def saveCache(self, ticker:str=None, name:str=None, stockDict:dict=None):
+        self.pickler.saveCache(ticker=ticker, name=name, stockDict=stockDict)
+
+class PKIntradayStockDataDB(SingletonMixin, metaclass=SingletonType):
+    def __init__(self,fileName=None):
+        super(PKIntradayStockDataDB, self).__init__()
+        self.pickler = PKPicklerDB(fileName=fileName)
+
+    def searchCache(self, ticker:str=None, name:str=None):
+        return self.pickler.searchCache(ticker=ticker, name=name)
+    
+    def saveCache(self, ticker:str=None, name:str=None, stockDict:dict=None):
+        self.pickler.saveCache(ticker=ticker, name=name, stockDict=stockDict)
+
+
+class PKMarketOpenCloseAnalyser:
+    configManager = tools()
+    configManager.getConfig(parser)
+    updatedCandleData = None
+    allDailyCandles = None
+    allIntradayCandles = None
+    def getStockDataForSimulation():
+        int_exists, int_cache_file = PKMarketOpenCloseAnalyser.ensureIntradayStockDataExists()
+        daily_exists, daily_cache_file = PKMarketOpenCloseAnalyser.ensureDailyStockDataExists()
+        updatedCandleData = PKMarketOpenCloseAnalyser.updatedCandleData
+        allDailyCandles = PKMarketOpenCloseAnalyser.allDailyCandles
+        if  (int_exists and daily_exists) and (updatedCandleData is None or allDailyCandles is None):
+            allDailyCandles = PKMarketOpenCloseAnalyser.getLatestDailyCandleData(daily_cache_file)
+            morningIntradayCandle = PKMarketOpenCloseAnalyser.getIntradayCandleFromMorning(int_cache_file)
+            updatedCandleData = PKMarketOpenCloseAnalyser.combineDailyStockDataWithMorningSimulation(allDailyCandles,morningIntradayCandle)
+            # PKMarketOpenCloseAnalyser.updatedCandleData = updatedCandleData
+            # PKMarketOpenCloseAnalyser.allDailyCandles = allDailyCandles
+            Utility.tools.saveStockData(updatedCandleData,PKMarketOpenCloseAnalyser.configManager,1,False,False, True)
+        return updatedCandleData, allDailyCandles
+
+    def runOpenCloseAnalysis(updatedCandleData,allDailyCandles,screen_df,save_df,runOptionName=None,filteredListOfStocks=[]):
+        # stockListFromMorningTrade,morningIntraday_df = PKMarketOpenCloseAnalyser.simulateMorningTrade(updatedCandleData)
+        # latest_daily_df = PKMarketOpenCloseAnalyser.runScanForStocksFromMorningTrade(stockListFromMorningTrade,allDailyCandles)
+        try:
+            PKMarketOpenCloseAnalyser.diffMorningCandleDataWithLatestDailyCandleData(screen_df,save_df, updatedCandleData, allDailyCandles,runOptionName=runOptionName,filteredListOfStocks=filteredListOfStocks)
+        except:
+            pass
+        Utility.tools.saveStockData(allDailyCandles,PKMarketOpenCloseAnalyser.configManager,1,False,False, True)
+
+    def ensureIntradayStockDataExists():
+        # Ensure that the intraday_stock_data_<date>.pkl file exists
+        exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday=True)
+        copyFilePath = os.path.join(Archiver.get_user_outputs_dir(), f"copy_{cache_file}")
+        srcFilePath = os.path.join(Archiver.get_user_outputs_dir(), cache_file)
+        srcFileSize = os.stat(srcFilePath).st_size if os.path.exists(srcFilePath) else 0
+        if exists and srcFileSize < 1024*1024*50:
+             # File less than 30MB ? Must have been corrupted
+            try:
+                os.remove(srcFilePath)
+                exists = False
+            except:
+                pass
+        if not exists:
+            savedPeriod = PKMarketOpenCloseAnalyser.configManager.period
+            savedDuration = PKMarketOpenCloseAnalyser.configManager.duration
+            PKMarketOpenCloseAnalyser.configManager.period = "1d"
+            PKMarketOpenCloseAnalyser.configManager.duration = "1m"
+            OutputControls().printOutput(f"[+] {colorText.FAIL}{cache_file}{colorText.END} not found under {Archiver.get_user_outputs_dir()} !")
+            OutputControls().printOutput(f"[+] {colorText.GREEN}Trying to download {cache_file}{colorText.END}. Please wait ...")
+            Utility.tools.loadStockData({},PKMarketOpenCloseAnalyser.configManager,False,'Y',False,False,None,isIntraday=True)
+            exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday=True)
+            if not exists:
+                OutputControls().printOutput(f"[+] {colorText.FAIL}{cache_file}{colorText.END} not found under {Archiver.get_user_outputs_dir()} !")
+                OutputControls().printOutput(f"[+] Please run {colorText.FAIL}pkscreener{colorText.END}{colorText.GREEN} -a Y -e -d -i 1m{colorText.END} and then run this menu option again.")
+                input("Press any key to continue...")
+            PKMarketOpenCloseAnalyser.configManager.period = savedPeriod
+            PKMarketOpenCloseAnalyser.configManager.duration = savedDuration
+        try:
+            if os.path.exists(copyFilePath) and exists:
+                shutil.copy(copyFilePath,srcFilePath) # copy is the saved source of truth
+            if not os.path.exists(copyFilePath) and exists: # Let's make a copy of the original one
+                shutil.copy(srcFilePath,copyFilePath)
+        except:
+            pass
+        return exists, cache_file
+
+    def ensureDailyStockDataExists():
+        # Ensure that the stock_data_<date>.pkl file exists
+        exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday=False)
+        copyFilePath = os.path.join(Archiver.get_user_outputs_dir(), f"copy_{cache_file}")
+        srcFilePath = os.path.join(Archiver.get_user_outputs_dir(), cache_file)
+        srcFileSize = os.stat(srcFilePath).st_size if os.path.exists(srcFilePath) else 0
+        if exists and srcFileSize < 1024*1024*50:
+             # File less than 30MB ? Must have been corrupted
+            try:
+                os.remove(srcFilePath)
+                exists = False
+            except:
+                pass
+        if not exists:
+            OutputControls().printOutput(f"[+] {colorText.FAIL}{cache_file}{colorText.END} not found under {Archiver.get_user_outputs_dir()} !")
+        # We should download a fresh copy anyways because we may have altered the existing copy in
+        # the previous run. -- !!!! Not required if we saved at the end of last operation !!!!
+            OutputControls().printOutput(f"[+] {colorText.GREEN}Trying to download {cache_file}{colorText.END}. Please wait ...")
+            Utility.tools.loadStockData({},PKMarketOpenCloseAnalyser.configManager,False,'Y',False,False,None,isIntraday=False,forceRedownload=True)
+            exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday=False)
+            if not exists:
+                OutputControls().printOutput(f"[+] {colorText.FAIL}{cache_file}{colorText.END} not found under {Archiver.get_user_outputs_dir()} !")
+                OutputControls().printOutput(f"[+] Please run {colorText.FAIL}pkscreener{colorText.END}{colorText.GREEN} -a Y -e -d{colorText.END} and then run this menu option again.")
+                input("Press any key to continue...")
+        try:
+            if os.path.exists(copyFilePath) and exists:
+                shutil.copy(copyFilePath,srcFilePath) # copy is the saved source of truth
+            if not os.path.exists(copyFilePath) and exists: # Let's make a copy of the original one
+                shutil.copy(srcFilePath,copyFilePath)
+        except:
+            pass
+        return exists, cache_file
+    
+    def simulateMorningTrade(updatedCandleData):
+        # 1. For each stock, remove the latest daily data for today from stock_data_<date>.pkl
+        # 2. For each stock, only take the configManager.morninganalysiscandlenumber data rows
+        #    and combine them as one candle - open for the earliest candle and close for the last candle,
+        #    low and high will be the lowest and highest for in-between candles. Volume should be combined
+        #    for all.
+        # 3. For each stock, replace the row from #1 above with the candle data from #2 above.
+        # 4. Run scan and find stocks under each (selected) scan category as if the scan was
+        #    running in the morning. 
+        # 5. Compare the stock prices from #4 with the removed row from #1 and show the diff.
+        stockListFromMorningTrade = []
+        morningIntraday_df = None
+        return stockListFromMorningTrade, morningIntraday_df
+    
+    def getLatestDailyCandleData(daily_cache_file):
+        allDailyCandles = None
+        dailyDB = PKDailyStockDataDB(fileName=daily_cache_file)
+        allDailyCandles = dailyDB.pickler.pickler.unpickle(fileName=dailyDB.pickler.fileName)
+        # latestDailyCandle = {}
+        # stocks = list(allDailyCandles.keys())
+        # for stock in stocks:
+        #     try:
+        #         df = pd.DataFrame(data=[allDailyCandles[stock]["data"][-1]],
+        #                       columns=allDailyCandles[stock]["columns"],
+        #                       index=[allDailyCandles[stock]["index"][-1]])
+        #         latestDailyCandle[stock] = df.to_dict("split")
+        #     except:
+        #         continue
+        return allDailyCandles
+    
+    def getIntradayCandleFromMorning(int_cache_file=None,candle1MinuteNumberSinceMarketStarted=0):
+        if candle1MinuteNumberSinceMarketStarted <= 0:
+            candle1MinuteNumberSinceMarketStarted = PKMarketOpenCloseAnalyser.configManager.morninganalysiscandlenumber
+        morningIntradayCandle = None
+        intradayDB = PKIntradayStockDataDB(fileName=int_cache_file)
+        allDailyIntradayCandles = intradayDB.pickler.pickler.unpickle(fileName=intradayDB.pickler.fileName)
+        PKMarketOpenCloseAnalyser.allIntradayCandles = allDailyIntradayCandles
+        morningIntradayCandle = {}
+        stocks = list(allDailyIntradayCandles.keys())
+        numOfCandles = PKMarketOpenCloseAnalyser.configManager.morninganalysiscandlenumber
+        duration = PKMarketOpenCloseAnalyser.configManager.morninganalysiscandleduration
+        numOfCandles = numOfCandles * int(duration.replace("m",""))
+        for stock in stocks:
+            try:
+                # Let's get the saved data from the DB. Then we need to only
+                # get those candles which are earlier than 9:57AM which is
+                # the time when the morning alerts collect data for generating alerts
+                # We'd then combine the data from 9:15 to 9:57 as a single candle of 
+                # OHLCV and replace the last daily candle with this one candle to
+                # simulate the scan outcome from morning.
+                df = pd.DataFrame(data=allDailyIntradayCandles[stock]["data"],
+                                columns=allDailyIntradayCandles[stock]["columns"],
+                                index=allDailyIntradayCandles[stock]["index"])
+                df = df.head(numOfCandles)
+                try:
+                    df = df[df.index <=  pd.to_datetime(f'{PKDateUtilities.tradingDate().strftime(f"%Y-%m-%d")} 09:{15+candle1MinuteNumberSinceMarketStarted}:00+05:30').to_datetime64()]
+                except:
+                    df = df[df.index <=  pd.to_datetime(f'{PKDateUtilities.tradingDate().strftime(f"%Y-%m-%d")} 09:{15+candle1MinuteNumberSinceMarketStarted}:00+05:30', utc=True)]
+                    pass
+                if df is not None and len(df) > 0:
+                    combinedCandle = {"Open":PKMarketOpenCloseAnalyser.getMorningOpen(df), "High":max(df["High"]), 
+                                    "Low":min(df["Low"]),"Close":PKMarketOpenCloseAnalyser.getMorningClose(df),
+                                    "Adj Close":df["Adj Close"][-1],"Volume":sum(df["Volume"])}
+                    tradingDate = df.index[-1] #PKDateUtilities.tradingDate()
+                    timestamp = datetime.datetime.strptime(tradingDate.strftime("%Y-%m-%d %H:%M:%S"),"%Y-%m-%d %H:%M:%S")
+                    df = pd.DataFrame([combinedCandle], columns=df.columns, index=[timestamp])
+                    morningIntradayCandle[stock] = df.to_dict("split")
+            except Exception as e:
+                OutputControls().printOutput(f"{stock}:    {e}")
+                continue
+        return morningIntradayCandle
+
+    def getMorningOpen(df):
+        open = df["Open"][0]
+        index = 0
+        while open is np.nan and index < len(df):
+            open = df["Open"][index + 1]
+            index += 1
+        return open
+    
+    def getMorningClose(df):
+        close = df["Close"][-1]
+        index = len(df)
+        while close is np.nan and index >= 0:
+            close = df["Close"][index - 1]
+            index -= 1
+        return close
+    
+    def combineDailyStockDataWithMorningSimulation(allDailyCandles,morningIntradayCandle):
+        mutableAllDailyCandles = copy.deepcopy(allDailyCandles)
+        stocks = list(mutableAllDailyCandles.keys())
+        intradayStocks = list(morningIntradayCandle.keys())
+        priceDict = {}
+        listPriceDict = []
+        for stock in stocks:
+            try:
+                priceDict = {}
+                if stock in intradayStocks:
+                    morningPrice = round(morningIntradayCandle[stock]["data"][0][3],2)
+                    closePrice = round(mutableAllDailyCandles[stock]["data"][-1][3],2)
+                    priceDict["Stock"] = stock
+                    priceDict["Morning"] = morningPrice
+                    priceDict["EoD"] = closePrice
+                    listPriceDict.append(priceDict)
+                    # We basically need to replace today's candle with a single candle that has data from market open to the time
+                    # when we are taking as reference point in the morning. This is how it would have looked when running the scan 
+                    # in the morning hours.
+                    mutableAllDailyCandles[stock]["data"] = mutableAllDailyCandles[stock]["data"][:-1] + [morningIntradayCandle[stock]["data"][0]]
+                    mutableAllDailyCandles[stock]["index"] = mutableAllDailyCandles[stock]["index"][:-1] + morningIntradayCandle[stock]["index"]
+                else:
+                    # We should ideally have all stocks from intraday and eod matching,
+                    # but for whatever reason, if we don't have the stock, we should skip those
+                    # stocks from analysis
+                    del mutableAllDailyCandles[stock]
+            except:
+                del mutableAllDailyCandles[stock]
+                if 'PKDevTools_Default_Log_Level' in os.environ.keys():
+                    intradayChange = colorText.miniTabulator().tabulate(
+                                        pd.DataFrame(listPriceDict),
+                                        headers="keys",
+                                        tablefmt=colorText.No_Pad_GridFormat,
+                                        showindex=False
+                                    ).encode("utf-8").decode(STD_ENCODING)
+                    default_logger().debug(intradayChange)
+                continue
+        return mutableAllDailyCandles
+
+    def runScanForStocksFromMorningTrade(stockListFromMorningTrade,dailyCandleData):
+        latest_daily_df = None
+        return latest_daily_df
+
+    def diffMorningCandleDataWithLatestDailyCandleData(screen_df,save_df, updatedCandleData, allDailyCandles,runOptionName=None,filteredListOfStocks=[]):
+        save_df.reset_index(inplace=True)
+        screen_df.reset_index(inplace=True)
+        save_df.drop(f"index", axis=1, inplace=True, errors="ignore")
+        screen_df.drop(f"index", axis=1, inplace=True, errors="ignore")
+        stocks = save_df["Stock"]
+        eodLTPs = []
+        dayHighLTPs = []
+        morningTimestamps = []
+        morningAlertLTPs = []
+        sellTimestamps = []
+        dayHighTimestamps = []
+        sellLTPs = []
+        eodDiffs = []
+        dayHighDiffs = []
+        sqrOffDiffs = []
+        index = 0
+        scrStats = ScreeningStatistics(PKMarketOpenCloseAnalyser.configManager, default_logger())
+        for stock in stocks:
+            try:
+                # Open, High, Low, Close, Adj Close, Volume. We need the 3rd index item: Close.
+                dayHighLTP = allDailyCandles[stock]["data"][-1][1]
+                endOfDayLTP = allDailyCandles[stock]["data"][-1][3]
+                savedMorningLTP = updatedCandleData[stock]["data"][-1][3]
+                morningLTP = savedMorningLTP if pd.notna(savedMorningLTP) else round(save_df["LTP"][index],2)
+                morningTime = updatedCandleData[stock]["index"][-1].strftime("%H:%M")
+                morningTimestamps.append(morningTime)
+                morningCandles = PKMarketOpenCloseAnalyser.allIntradayCandles
+                df = pd.DataFrame(data=morningCandles[stock]["data"],
+                                columns=morningCandles[stock]["columns"],
+                                index=morningCandles[stock]["index"])
+                # try:
+                #     # Let's only consider those candles that are after the alert issue-time in the mornings
+                #     df = df[df.index >=  pd.to_datetime(f'{PKDateUtilities.tradingDate().strftime(f"%Y-%m-%d")} 09:{15+PKMarketOpenCloseAnalyser.configManager.morninganalysiscandlenumber}:00+05:30').to_datetime64()]
+                # except:
+                #     df = df[df.index >=  pd.to_datetime(f'{PKDateUtilities.tradingDate().strftime(f"%Y-%m-%d")} 09:{15+PKMarketOpenCloseAnalyser.configManager.morninganalysiscandlenumber}:00+05:30', utc=True)]
+                #     pass
+                ts, row = scrStats.findMACDCrossover(df=df,
+                                           afterTimestamp=updatedCandleData[stock]["index"][-1],
+                                           nthCrossover=1,
+                                           upDirection=True)
+                highTS, highRow = scrStats.findIntradayHighCrossover(df=df)
+                dayHighLTP = dayHighLTP if pd.notna(dayHighLTP) else highRow["High"][-1]
+                sellTimestamps.append(ts.strftime("%H:%M"))
+                dayHighTimestamps.append(highTS.strftime("%H:%M"))
+                sellLTPs.append(row["High"][-1])
+                eodLTPs.append(round(endOfDayLTP,2))
+                dayHighLTPs.append(round(dayHighLTP,2))
+                eodDiffs.append(round(endOfDayLTP - morningLTP,2))
+                dayHighDiffs.append(round(dayHighLTP - morningLTP,2))
+                sqrOffDiffs.append(round(row["High"][-1] - morningLTP,2))
+                morningAlertLTPs.append(str(int(round(morningLTP,0))))
+                index += 1
+            except:
+                eodLTPs.append("0")
+                eodDiffs.append("0")
+                dayHighLTPs.append("0")
+                dayHighDiffs.append("0")
+                continue
+        diffColumns = ["LTP@Alert", "AlertTime", "SqrOff", "SqrOffLTP", "SqrOffDiff","DayHighTime","DayHigh","DayHighDiff", "EoDLTP", "EoDDiff"]
+        diffValues = [morningAlertLTPs, morningTimestamps, sellTimestamps, sellLTPs, sqrOffDiffs,dayHighTimestamps,dayHighLTPs, dayHighDiffs,eodLTPs, eodDiffs]
+        for col in diffColumns:
+            save_df[col] = diffValues[diffColumns.index(col)]
+            screen_df.loc[:, col] = save_df.loc[:, col].apply(
+                lambda x: x if col in ["LTP@Alert","AlertTime", "SqrOff", "SqrOffLTP", "EoDLTP","DayHigh","DayHighTime"] else ((colorText.GREEN if x >= 0 else colorText.FAIL) + str(x) + colorText.END)
+            )
+
+        columns = save_df.columns
+        lastIndex = len(save_df)
+        for col in columns:
+            if col in ["Stock", "Pattern", "LTP", "SqrOffLTP","SqrOffDiff","DayHigh","DayHighDiff", "EoDLTP", "EoDDiff", "%Chng"]:
+                if col == "Stock":
+                    save_df.loc[lastIndex,col] = "PORTFOLIO"
+                elif col == "Pattern":
+                    save_df.loc[lastIndex,col] = runOptionName if runOptionName is not None else ""
+                elif col in ["LTP", "SqrOffLTP","SqrOffDiff", "EoDLTP", "EoDDiff","DayHigh","DayHighDiff"]:
+                    save_df.loc[lastIndex,col] = round(sum(save_df[col].dropna(inplace=False).astype(float)),2)
+                elif col == "%Chng":
+                    ltpSum = sum(save_df["LTP"].dropna(inplace=False).astype(float))
+                    change_pct = sum(save_df["EoDDiff"].dropna(inplace=False).astype(float))*100/ltpSum
+                    save_df.loc[lastIndex,col] = f"{round(2*change_pct,2)}%" # when summing above for LTP, the total of LTP gets summed up too. Hence *2 here.
+            else:
+                save_df.loc[lastIndex,col] = ""
+            screen_df.loc[lastIndex,col] = save_df.loc[lastIndex,col]
+        eodDiff = save_df.loc[lastIndex,"EoDDiff"]
+        sqrOffDiff = save_df.loc[lastIndex,"SqrOffDiff"]
+        dayHighDiff = save_df.loc[lastIndex,"DayHighDiff"]
+        save_df.loc[lastIndex,"EoDDiff"] = str(eodDiff) + f'({round(100*2*eodDiff/ltpSum,2)}%)'
+        save_df.loc[lastIndex,"SqrOffDiff"] = str(sqrOffDiff) + f'({round(100*2*sqrOffDiff/ltpSum,2)}%)'
+        save_df.loc[lastIndex,"DayHighDiff"] = str(dayHighDiff) + f'({round(100*2*dayHighDiff/ltpSum,2)}%)'
+        screen_df.loc[lastIndex,"EoDDiff"] = (colorText.GREEN if eodDiff >= 0 else colorText.FAIL) + save_df.loc[lastIndex,"EoDDiff"] + colorText.END
+        screen_df.loc[lastIndex,"SqrOffDiff"] = (colorText.GREEN if sqrOffDiff >= 0 else colorText.FAIL) + save_df.loc[lastIndex,"SqrOffDiff"] + colorText.END
+        screen_df.loc[lastIndex,"DayHighDiff"] = (colorText.GREEN if dayHighDiff >= 0 else colorText.FAIL) + save_df.loc[lastIndex,"DayHighDiff"] + colorText.END
+        save_df.set_index("Stock", inplace=True)
+        screen_df.set_index("Stock", inplace=True)
+        PKMarketOpenCloseAnalyser.allIntradayCandles = None
+        screen_df.replace(np.nan, "", regex=True)
+        save_df.replace(np.nan, "", regex=True)
+        if 'index' in save_df.columns:
+            save_df.drop('index', axis=1, inplace=True, errors="ignore")
+        if 'index' in screen_df.columns:
+            screen_df.drop('index', axis=1, inplace=True, errors="ignore")
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScanRunner.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScanRunner.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,462 +1,462 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import os
-import sys
-import time
-import pandas as pd
-import multiprocessing
-from time import sleep
-
-from PKDevTools.classes import Archiver
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.PKDateUtilities import PKDateUtilities
-from PKDevTools.classes.log import default_logger
-from PKDevTools.classes.PKGitFolderDownloader import downloadFolder
-from PKDevTools.classes.PKMultiProcessorClient import PKMultiProcessorClient
-from PKDevTools.classes.multiprocessing_logging import LogQueueReader
-from PKDevTools.classes.SuppressOutput import SuppressOutput
-from PKDevTools.classes.FunctionTimeouts import exit_after
-
-from pkscreener.classes.StockScreener import StockScreener
-from pkscreener.classes.CandlePatterns import CandlePatterns
-from pkscreener.classes.ConfigManager import parser, tools
-from PKDevTools.classes.OutputControls import OutputControls
-from PKNSETools.PKIntraDay import Intra_Day
-import pkscreener.classes.Fetcher as Fetcher
-import pkscreener.classes.ScreeningStatistics as ScreeningStatistics
-import pkscreener.classes.Utility as Utility
-
-class PKScanRunner:
-    configManager = tools()
-    configManager.getConfig(parser)
-    fetcher = Fetcher.screenerStockDataFetcher(configManager)
-    candlePatterns = CandlePatterns()
-    tasks_queue = None
-    results_queue = None
-    scr = None
-    consumers = None
-
-    def initDataframes():
-        screenResults = pd.DataFrame(
-            columns=[
-                "Stock",
-                "Consol.",
-                "Breakout",
-                "LTP",
-                "52Wk H",
-                "52Wk L",
-                "%Chng",
-                "Volume",
-                "MA-Signal",
-                "RSI",
-                "RSIi",
-                "Trend",
-                "Pattern",
-                "CCI",
-            ]
-        )
-        saveResults = pd.DataFrame(
-            columns=[
-                "Stock",
-                "Consol.",
-                "Breakout",
-                "LTP",
-                "52Wk H",
-                "52Wk L",
-                "%Chng",
-                "Volume",
-                "MA-Signal",
-                "RSI",
-                "RSIi",
-                "Trend",
-                "Pattern",
-                "CCI",
-            ]
-        )
-        return screenResults, saveResults
-
-    def initQueues(minimumCount=0,userPassedArgs=None):
-        tasks_queue = multiprocessing.JoinableQueue()
-        results_queue = multiprocessing.Queue()
-        logging_queue = multiprocessing.Queue()
-
-        totalConsumers = 1 if (userPassedArgs is not None and userPassedArgs.singlethread) else min(minimumCount, multiprocessing.cpu_count())
-        if totalConsumers == 1:
-            totalConsumers = 2  # This is required for single core machine
-        # if PKScanRunner.configManager.cacheEnabled is True and multiprocessing.cpu_count() > 2:
-        #     totalConsumers -= 1
-        return tasks_queue, results_queue, totalConsumers, logging_queue
-
-    def populateQueues(items, tasks_queue, exit=False,userPassedArgs=None):
-        # default_logger().debug(f"Unfinished items in task_queue: {tasks_queue.qsize()}")
-        for item in items:
-            tasks_queue.put(item)
-        mayBePiped = userPassedArgs is not None and (userPassedArgs.monitor is not None or "|" in userPassedArgs.options)
-        if exit and not mayBePiped:
-            # Append exit signal for each process indicated by None
-            for _ in range(multiprocessing.cpu_count()):
-                tasks_queue.put(None)
-
-
-    def getScanDurationParameters(testing, menuOption):
-        # Number of days from past, including the backtest duration chosen by the user
-        # that we will need to consider to evaluate the data. If the user choses 10-period
-        # backtesting, we will need to have the past 6-months or whatever is returned by
-        # x = getHistoricalDays and 10 days of recent data. So total rows to consider
-        # will be x + 10 days.
-        samplingDuration = (3 if testing else PKScanRunner.configManager.backtestPeriod+1) if menuOption.upper() in ["B"] else 2
-        fillerPlaceHolder = 1 if menuOption in ["B"] else 2
-        actualHistoricalDuration = (samplingDuration - fillerPlaceHolder)
-        return samplingDuration,fillerPlaceHolder,actualHistoricalDuration
-
-    def addStocksToItemList(userArgs, testing, testBuild, newlyListedOnly, downloadOnly, minRSI, maxRSI, insideBarToLookback, respChartPattern, daysForLowestVolume, backtestPeriod, reversalOption, maLength, listStockCodes, menuOption, exchangeName,executeOption, volumeRatio, items, daysInPast):
-        moreItems = [
-                        (
-                            menuOption,
-                            exchangeName,
-                            executeOption,
-                            reversalOption,
-                            maLength,
-                            daysForLowestVolume,
-                            minRSI,
-                            maxRSI,
-                            respChartPattern,
-                            insideBarToLookback,
-                            len(listStockCodes),
-                            PKScanRunner.configManager.cacheEnabled,
-                            stock,
-                            newlyListedOnly,
-                            downloadOnly,
-                            volumeRatio,
-                            testBuild,
-                            userArgs,
-                            daysInPast,
-                            (
-                                backtestPeriod
-                                if menuOption == "B"
-                                else PKScanRunner.configManager.effectiveDaysToLookback
-                            ),
-                            default_logger().level,
-                            (menuOption in ["B", "G", "X", "S","C"])
-                            or (userArgs.backtestdaysago is not None),
-                            # assumption is that fetcher.fetchStockData would be
-                            # mocked to avoid calling yf.download again and again
-                            PKScanRunner.fetcher.fetchStockData() if testing else None,
-                        )
-                        for stock in listStockCodes
-                    ]
-        items.extend(moreItems)
-
-    def getStocksListForScan(userArgs, menuOption, totalStocksInReview, downloadedRecently, daysInPast):
-        savedStocksCount = 0
-        pastDate, savedListResp = PKScanRunner.downloadSavedResults(daysInPast,downloadedRecently=downloadedRecently)
-        downloadedRecently = True
-        if savedListResp is not None and len(savedListResp) > 0:
-            savedListStockCodes = savedListResp
-            savedStocksCount = len(savedListStockCodes)
-            if savedStocksCount > 0:
-                listStockCodes = savedListStockCodes
-                totalStocksInReview += savedStocksCount
-            else:
-                if menuOption in ["B"] and not userArgs.forceBacktestsForZeroResultDays:
-                                    # We have a zero length result saved in repo.
-                                    # Likely we didn't have any stock in the result output. So why run the scan again?
-                    listStockCodes = savedListStockCodes
-                totalStocksInReview += len(listStockCodes)
-        else:
-            totalStocksInReview += len(listStockCodes)
-        return listStockCodes,savedStocksCount,pastDate
-
-    def getBacktestDaysForScan(userArgs, backtestPeriod, menuOption, actualHistoricalDuration):
-        daysInPast = (
-                                actualHistoricalDuration
-                                if (menuOption == "B")
-                                else (
-                                    (backtestPeriod)
-                                    if (menuOption == "G")
-                                    else (
-                                        0
-                                        if (userArgs.backtestdaysago is None)
-                                        else (int(userArgs.backtestdaysago))
-                                    )
-                                )
-                            )
-                
-        return daysInPast
-    
-    def downloadSavedResults(daysInPast,downloadedRecently=False):
-        pastDate = PKDateUtilities.nthPastTradingDateStringFromFutureDate(daysInPast)
-        filePrefix = PKScanRunner.getFormattedChoices().replace("B","X").replace("G","X").replace("S","X")
-        # url = f"https://raw.github.com/pkjmesra/PKScreener/actions-data-download/actions-data-scan/{filePrefix}_{pastDate}.txt"
-        # savedListResp = fetcher.fetchURL(url)
-        localPath = Archiver.get_user_outputs_dir()
-        downloadedPath = os.path.join(localPath,"PKScreener","actions-data-scan")
-        if not downloadedRecently:
-            downloadedPath = downloadFolder(localPath=localPath,
-                                            repoPath="pkjmesra/PKScreener",
-                                            branchName="actions-data-download",
-                                            folderName="actions-data-scan")
-        items = []
-        savedList = []
-        fileName = os.path.join(downloadedPath,f"{filePrefix}_{pastDate}.txt")
-        if os.path.isfile(fileName):
-            #File already exists.
-            with open(fileName, 'r') as fe:
-                stocks = fe.read()
-                items = stocks.replace("\n","").replace("\"","").split(",")
-                savedList = sorted(list(filter(None,list(set(items)))))
-        return pastDate,savedList
-    
-    def getFormattedChoices(userArgs, selectedChoice):
-        isIntraday = PKScanRunner.configManager.isIntradayConfig() or (
-            userArgs.intraday is not None
-        )
-        choices = ""
-        for choice in selectedChoice:
-            choiceOption = selectedChoice[choice]
-            if len(choiceOption) > 0 and ("," not in choiceOption and "." not in choiceOption):
-                if len(choices) > 0:
-                    choices = f"{choices}_"
-                choices = f"{choices}{choiceOption}"
-        if choices.endswith("_"):
-            choices = choices[:-1]
-        choices = f"{choices}{'_i' if isIntraday else ''}"
-        return choices
-
-    def refreshDatabase(consumers,stockDictPrimary,stockDictSecondary):
-        for worker in consumers:
-            worker.objectDictionaryPrimary = stockDictPrimary
-            worker.objectDictionarySecondary = stockDictSecondary
-            worker.refreshDatabase = True
-            
-    def runScanWithParams(userPassedArgs,keyboardInterruptEvent,screenCounter,screenResultsCounter,stockDictPrimary,stockDictSecondary,testing, backtestPeriod, menuOption, executeOption, samplingDuration, items,screenResults, saveResults, backtest_df,scanningCb,tasks_queue, results_queue, consumers,logging_queue):
-        if tasks_queue is None or results_queue is None or consumers is None:
-            tasks_queue, results_queue, consumers,logging_queue = PKScanRunner.prepareToRunScan(menuOption,keyboardInterruptEvent,screenCounter, screenResultsCounter, stockDictPrimary,stockDictSecondary, items,executeOption,userPassedArgs)
-            try:
-                if logging_queue is not None:
-                    log_queue_reader = LogQueueReader(logging_queue)
-                    log_queue_reader.start()
-            except:
-                pass
-        # if executeOption == 29: # Intraday Bid/Ask, for which we need to fetch data from NSE instead of yahoo
-        #     intradayFetcher = Intra_Day("SBINEQN") # This will initialise the cookies etc.
-        #     for consumer in consumers:
-        #         consumer.intradayNSEFetcher = intradayFetcher
-        # else:
-        #     # Restart the workers because the run method may have exited from a previous run
-        #     PKScanRunner.startWorkers(consumers)
-        PKScanRunner.tasks_queue = tasks_queue
-        PKScanRunner.results_queue = results_queue
-        PKScanRunner.consumers = consumers
-        screenResults, saveResults, backtest_df = scanningCb(
-                    menuOption,
-                    items,
-                    PKScanRunner.tasks_queue,
-                    PKScanRunner.results_queue,
-                    len(items),
-                    backtestPeriod,
-                    samplingDuration - 1,
-                    PKScanRunner.consumers,
-                    screenResults,
-                    saveResults,
-                    backtest_df,
-                    testing=testing,
-                )
-
-        OutputControls().printOutput(colorText.END)
-        if userPassedArgs is not None and (userPassedArgs.monitor is None and "|" not in userPassedArgs.options) and not userPassedArgs.options.upper().startswith("C"):
-            # Don't terminate the multiprocessing clients if we're 
-            # going to pipe the results from an earlier run
-            # or we're running in monitoring mode
-            PKScanRunner.terminateAllWorkers(userPassedArgs,consumers, tasks_queue, testing)
-        else:
-            for worker in consumers:
-                worker.paused = True
-                worker._clear()
-        return screenResults, saveResults,backtest_df,tasks_queue, results_queue, consumers, logging_queue
-
-    @exit_after(180) # Should not remain stuck starting the multiprocessing clients beyond this time
-    def prepareToRunScan(menuOption,keyboardInterruptEvent, screenCounter, screenResultsCounter, stockDictPrimary,stockDictSecondary, items, executeOption,userPassedArgs):
-        tasks_queue, results_queue, totalConsumers, logging_queue = PKScanRunner.initQueues(len(items),userPassedArgs)
-        scr = ScreeningStatistics.ScreeningStatistics(PKScanRunner.configManager, default_logger())
-        exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday=PKScanRunner.configManager.isIntradayConfig())
-        sec_cache_file = cache_file if "intraday_" in cache_file else f"intraday_{cache_file}"
-        consumers = [
-                    PKMultiProcessorClient(
-                        StockScreener().screenStocks,
-                        tasks_queue,
-                        results_queue,
-                        logging_queue,
-                        screenCounter,
-                        screenResultsCounter,
-                        # stockDictPrimary,
-                        # stockDictSecondary,
-                        (stockDictPrimary if menuOption not in ["C"] else None),
-                        (stockDictSecondary if menuOption not in ["C"] else None),
-                        PKScanRunner.fetcher.proxyServer,
-                        keyboardInterruptEvent,
-                        default_logger(),
-                        PKScanRunner.fetcher,
-                        PKScanRunner.configManager,
-                        PKScanRunner.candlePatterns,
-                        scr,
-                        # None,
-                        # None
-                        (cache_file if (exists and menuOption in ["C"]) else None),
-                        (sec_cache_file if (exists and menuOption in ["C"]) else None),
-                    )
-                    for _ in range(totalConsumers)
-                ]
-        # if executeOption == 29: # Intraday Bid/Ask, for which we need to fetch data from NSE instead of yahoo
-        try:
-            intradayFetcher = None
-            intradayFetcher = Intra_Day("SBINEQN") # This will initialise the cookies etc.
-        except:
-            pass
-        for consumer in consumers:
-            consumer.intradayNSEFetcher = intradayFetcher
-        PKScanRunner.startWorkers(consumers)
-        return tasks_queue,results_queue,consumers,logging_queue
-
-    @exit_after(120) # Should not remain stuck starting the multiprocessing clients beyond this time
-    def startWorkers(consumers):
-        try:
-            from pytest_cov.embed import cleanup_on_signal, cleanup_on_sigterm
-        except ImportError:
-            pass
-        else:
-            if sys.platform.startswith("win"):
-                import signal
-
-                cleanup_on_signal(signal.SIGBREAK)
-            else:
-                cleanup_on_sigterm()
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + f"[+] Using Period:{PKScanRunner.configManager.period} and Duration:{PKScanRunner.configManager.duration} for scan! You can change this in user config."
-            + colorText.END
-        )
-        start_time = time.time()
-        for worker in consumers:
-            sys.stdout.write(f"{round(time.time() - start_time)}.")
-            worker.daemon = True
-            worker.start()
-        OutputControls().printOutput(f"Started all workers in {round(time.time() - start_time,4)}s")
-        if OutputControls().enableMultipleLineOutput:
-            sys.stdout.write("\x1b[1A") # Move cursor up to hide the starting times we printed above
-
-    def terminateAllWorkers(userPassedArgs,consumers, tasks_queue, testing=False):
-        shouldSuppress = (userPassedArgs is None) or (userPassedArgs is not None and not userPassedArgs.log)
-        with SuppressOutput(suppress_stderr=shouldSuppress, suppress_stdout=shouldSuppress):
-            # Exit all processes. Without this, it threw error in next screening session
-            for worker in consumers:
-                try:
-                    if testing: # pragma: no cover
-                        if sys.platform.startswith("win"):
-                            import signal
-
-                            signal.signal(signal.SIGBREAK, PKScanRunner.shutdown)
-                            sleep(1)
-                        # worker.join()  # necessary so that the Process exists before the test suite exits (thus coverage is collected)
-                    # else:
-                    # try:
-                        # while worker.is_alive():
-                    worker.terminate()
-                    default_logger().debug("Worker terminated!")
-                    # except:
-                    #     continue
-                except OSError as e: # pragma: no cover
-                    default_logger().debug(e, exc_info=True)
-                    # if e.winerror == 5:
-                    continue
-
-            # Flush the queue so depending processes will end
-            while True:
-                try:
-                    _ = tasks_queue.get(False)
-                except Exception as e:  # pragma: no cover
-                    # default_logger().debug(e, exc_info=True)
-                    break
-        PKScanRunner.tasks_queue = None
-        PKScanRunner.results_queue = None
-        PKScanRunner.scr = None
-        PKScanRunner.consumers = None
-
-    def shutdown(frame, signum):
-        OutputControls().printOutput("Shutting down for test coverage")
-
-    # @exit_after(60)
-    def runScan(userPassedArgs,testing,numStocks,iterations,items,numStocksPerIteration,tasks_queue,results_queue,originalNumberOfStocks,backtest_df, *otherArgs,resultsReceivedCb=None):
-        queueCounter = 0
-        counter = 0
-        shouldContinue = True
-        lastNonNoneResult = None
-        while numStocks:
-            if counter == 0 and numStocks > 0:
-                if queueCounter < int(iterations):
-                    PKScanRunner.populateQueues(
-                        items[
-                            numStocksPerIteration
-                            * queueCounter : numStocksPerIteration
-                            * (queueCounter + 1)
-                        ],
-                        tasks_queue,
-                        (queueCounter + 1 == int(iterations)) and ((queueCounter + 1)*int(iterations) == originalNumberOfStocks),
-                        userPassedArgs
-                    )
-                else:
-                    PKScanRunner.populateQueues(
-                        items[
-                            numStocksPerIteration
-                            * queueCounter :
-                        ],
-                        tasks_queue,
-                        True,
-                        userPassedArgs
-                    )
-            numStocks -= 1
-            result = results_queue.get()
-            if result is not None:
-                lastNonNoneResult = result
-            
-            if resultsReceivedCb is not None:
-                shouldContinue, backtest_df = resultsReceivedCb(result, numStocks, backtest_df,*otherArgs)
-            counter += 1
-            # If it's being run under unit testing, let's wrap up if we find at least 1
-            # stock or if we've already tried screening through 5% of the list.
-            if (not shouldContinue) or (testing and counter >= int(numStocksPerIteration * 0.05)):
-                if PKScanRunner.consumers is not None:
-                    consumers = PKScanRunner.consumers
-                    for worker in consumers:
-                        worker.paused = True
-                        worker._clear()
-                break
-            # Add to the queue when we're through 75% of the previously added items already
-            if counter >= numStocksPerIteration: #int(numStocksPerIteration * 0.75):
-                queueCounter += 1
-                counter = 0
-        
-        return backtest_df, lastNonNoneResult
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import os
+import sys
+import time
+import pandas as pd
+import multiprocessing
+from time import sleep
+
+from PKDevTools.classes import Archiver
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.PKDateUtilities import PKDateUtilities
+from PKDevTools.classes.log import default_logger
+from PKDevTools.classes.PKGitFolderDownloader import downloadFolder
+from PKDevTools.classes.PKMultiProcessorClient import PKMultiProcessorClient
+from PKDevTools.classes.multiprocessing_logging import LogQueueReader
+from PKDevTools.classes.SuppressOutput import SuppressOutput
+from PKDevTools.classes.FunctionTimeouts import exit_after
+
+from pkscreener.classes.StockScreener import StockScreener
+from pkscreener.classes.CandlePatterns import CandlePatterns
+from pkscreener.classes.ConfigManager import parser, tools
+from PKDevTools.classes.OutputControls import OutputControls
+from PKNSETools.PKIntraDay import Intra_Day
+import pkscreener.classes.Fetcher as Fetcher
+import pkscreener.classes.ScreeningStatistics as ScreeningStatistics
+import pkscreener.classes.Utility as Utility
+
+class PKScanRunner:
+    configManager = tools()
+    configManager.getConfig(parser)
+    fetcher = Fetcher.screenerStockDataFetcher(configManager)
+    candlePatterns = CandlePatterns()
+    tasks_queue = None
+    results_queue = None
+    scr = None
+    consumers = None
+
+    def initDataframes():
+        screenResults = pd.DataFrame(
+            columns=[
+                "Stock",
+                "Consol.",
+                "Breakout",
+                "LTP",
+                "52Wk H",
+                "52Wk L",
+                "%Chng",
+                "Volume",
+                "MA-Signal",
+                "RSI",
+                "RSIi",
+                "Trend",
+                "Pattern",
+                "CCI",
+            ]
+        )
+        saveResults = pd.DataFrame(
+            columns=[
+                "Stock",
+                "Consol.",
+                "Breakout",
+                "LTP",
+                "52Wk H",
+                "52Wk L",
+                "%Chng",
+                "Volume",
+                "MA-Signal",
+                "RSI",
+                "RSIi",
+                "Trend",
+                "Pattern",
+                "CCI",
+            ]
+        )
+        return screenResults, saveResults
+
+    def initQueues(minimumCount=0,userPassedArgs=None):
+        tasks_queue = multiprocessing.JoinableQueue()
+        results_queue = multiprocessing.Queue()
+        logging_queue = multiprocessing.Queue()
+
+        totalConsumers = 1 if (userPassedArgs is not None and userPassedArgs.singlethread) else min(minimumCount, multiprocessing.cpu_count())
+        if totalConsumers == 1:
+            totalConsumers = 2  # This is required for single core machine
+        # if PKScanRunner.configManager.cacheEnabled is True and multiprocessing.cpu_count() > 2:
+        #     totalConsumers -= 1
+        return tasks_queue, results_queue, totalConsumers, logging_queue
+
+    def populateQueues(items, tasks_queue, exit=False,userPassedArgs=None):
+        # default_logger().debug(f"Unfinished items in task_queue: {tasks_queue.qsize()}")
+        for item in items:
+            tasks_queue.put(item)
+        mayBePiped = userPassedArgs is not None and (userPassedArgs.monitor is not None or "|" in userPassedArgs.options)
+        if exit and not mayBePiped:
+            # Append exit signal for each process indicated by None
+            for _ in range(multiprocessing.cpu_count()):
+                tasks_queue.put(None)
+
+
+    def getScanDurationParameters(testing, menuOption):
+        # Number of days from past, including the backtest duration chosen by the user
+        # that we will need to consider to evaluate the data. If the user choses 10-period
+        # backtesting, we will need to have the past 6-months or whatever is returned by
+        # x = getHistoricalDays and 10 days of recent data. So total rows to consider
+        # will be x + 10 days.
+        samplingDuration = (3 if testing else PKScanRunner.configManager.backtestPeriod+1) if menuOption.upper() in ["B"] else 2
+        fillerPlaceHolder = 1 if menuOption in ["B"] else 2
+        actualHistoricalDuration = (samplingDuration - fillerPlaceHolder)
+        return samplingDuration,fillerPlaceHolder,actualHistoricalDuration
+
+    def addStocksToItemList(userArgs, testing, testBuild, newlyListedOnly, downloadOnly, minRSI, maxRSI, insideBarToLookback, respChartPattern, daysForLowestVolume, backtestPeriod, reversalOption, maLength, listStockCodes, menuOption, exchangeName,executeOption, volumeRatio, items, daysInPast):
+        moreItems = [
+                        (
+                            menuOption,
+                            exchangeName,
+                            executeOption,
+                            reversalOption,
+                            maLength,
+                            daysForLowestVolume,
+                            minRSI,
+                            maxRSI,
+                            respChartPattern,
+                            insideBarToLookback,
+                            len(listStockCodes),
+                            PKScanRunner.configManager.cacheEnabled,
+                            stock,
+                            newlyListedOnly,
+                            downloadOnly,
+                            volumeRatio,
+                            testBuild,
+                            userArgs,
+                            daysInPast,
+                            (
+                                backtestPeriod
+                                if menuOption == "B"
+                                else PKScanRunner.configManager.effectiveDaysToLookback
+                            ),
+                            default_logger().level,
+                            (menuOption in ["B", "G", "X", "S","C"])
+                            or (userArgs.backtestdaysago is not None),
+                            # assumption is that fetcher.fetchStockData would be
+                            # mocked to avoid calling yf.download again and again
+                            PKScanRunner.fetcher.fetchStockData() if testing else None,
+                        )
+                        for stock in listStockCodes
+                    ]
+        items.extend(moreItems)
+
+    def getStocksListForScan(userArgs, menuOption, totalStocksInReview, downloadedRecently, daysInPast):
+        savedStocksCount = 0
+        pastDate, savedListResp = PKScanRunner.downloadSavedResults(daysInPast,downloadedRecently=downloadedRecently)
+        downloadedRecently = True
+        if savedListResp is not None and len(savedListResp) > 0:
+            savedListStockCodes = savedListResp
+            savedStocksCount = len(savedListStockCodes)
+            if savedStocksCount > 0:
+                listStockCodes = savedListStockCodes
+                totalStocksInReview += savedStocksCount
+            else:
+                if menuOption in ["B"] and not userArgs.forceBacktestsForZeroResultDays:
+                                    # We have a zero length result saved in repo.
+                                    # Likely we didn't have any stock in the result output. So why run the scan again?
+                    listStockCodes = savedListStockCodes
+                totalStocksInReview += len(listStockCodes)
+        else:
+            totalStocksInReview += len(listStockCodes)
+        return listStockCodes,savedStocksCount,pastDate
+
+    def getBacktestDaysForScan(userArgs, backtestPeriod, menuOption, actualHistoricalDuration):
+        daysInPast = (
+                                actualHistoricalDuration
+                                if (menuOption == "B")
+                                else (
+                                    (backtestPeriod)
+                                    if (menuOption == "G")
+                                    else (
+                                        0
+                                        if (userArgs.backtestdaysago is None)
+                                        else (int(userArgs.backtestdaysago))
+                                    )
+                                )
+                            )
+                
+        return daysInPast
+    
+    def downloadSavedResults(daysInPast,downloadedRecently=False):
+        pastDate = PKDateUtilities.nthPastTradingDateStringFromFutureDate(daysInPast)
+        filePrefix = PKScanRunner.getFormattedChoices().replace("B","X").replace("G","X").replace("S","X")
+        # url = f"https://raw.github.com/pkjmesra/PKScreener/actions-data-download/actions-data-scan/{filePrefix}_{pastDate}.txt"
+        # savedListResp = fetcher.fetchURL(url)
+        localPath = Archiver.get_user_outputs_dir()
+        downloadedPath = os.path.join(localPath,"PKScreener","actions-data-scan")
+        if not downloadedRecently:
+            downloadedPath = downloadFolder(localPath=localPath,
+                                            repoPath="pkjmesra/PKScreener",
+                                            branchName="actions-data-download",
+                                            folderName="actions-data-scan")
+        items = []
+        savedList = []
+        fileName = os.path.join(downloadedPath,f"{filePrefix}_{pastDate}.txt")
+        if os.path.isfile(fileName):
+            #File already exists.
+            with open(fileName, 'r') as fe:
+                stocks = fe.read()
+                items = stocks.replace("\n","").replace("\"","").split(",")
+                savedList = sorted(list(filter(None,list(set(items)))))
+        return pastDate,savedList
+    
+    def getFormattedChoices(userArgs, selectedChoice):
+        isIntraday = PKScanRunner.configManager.isIntradayConfig() or (
+            userArgs.intraday is not None
+        )
+        choices = ""
+        for choice in selectedChoice:
+            choiceOption = selectedChoice[choice]
+            if len(choiceOption) > 0 and ("," not in choiceOption and "." not in choiceOption):
+                if len(choices) > 0:
+                    choices = f"{choices}_"
+                choices = f"{choices}{choiceOption}"
+        if choices.endswith("_"):
+            choices = choices[:-1]
+        choices = f"{choices}{'_i' if isIntraday else ''}"
+        return choices
+
+    def refreshDatabase(consumers,stockDictPrimary,stockDictSecondary):
+        for worker in consumers:
+            worker.objectDictionaryPrimary = stockDictPrimary
+            worker.objectDictionarySecondary = stockDictSecondary
+            worker.refreshDatabase = True
+            
+    def runScanWithParams(userPassedArgs,keyboardInterruptEvent,screenCounter,screenResultsCounter,stockDictPrimary,stockDictSecondary,testing, backtestPeriod, menuOption, executeOption, samplingDuration, items,screenResults, saveResults, backtest_df,scanningCb,tasks_queue, results_queue, consumers,logging_queue):
+        if tasks_queue is None or results_queue is None or consumers is None:
+            tasks_queue, results_queue, consumers,logging_queue = PKScanRunner.prepareToRunScan(menuOption,keyboardInterruptEvent,screenCounter, screenResultsCounter, stockDictPrimary,stockDictSecondary, items,executeOption,userPassedArgs)
+            try:
+                if logging_queue is not None:
+                    log_queue_reader = LogQueueReader(logging_queue)
+                    log_queue_reader.start()
+            except:
+                pass
+        # if executeOption == 29: # Intraday Bid/Ask, for which we need to fetch data from NSE instead of yahoo
+        #     intradayFetcher = Intra_Day("SBINEQN") # This will initialise the cookies etc.
+        #     for consumer in consumers:
+        #         consumer.intradayNSEFetcher = intradayFetcher
+        # else:
+        #     # Restart the workers because the run method may have exited from a previous run
+        #     PKScanRunner.startWorkers(consumers)
+        PKScanRunner.tasks_queue = tasks_queue
+        PKScanRunner.results_queue = results_queue
+        PKScanRunner.consumers = consumers
+        screenResults, saveResults, backtest_df = scanningCb(
+                    menuOption,
+                    items,
+                    PKScanRunner.tasks_queue,
+                    PKScanRunner.results_queue,
+                    len(items),
+                    backtestPeriod,
+                    samplingDuration - 1,
+                    PKScanRunner.consumers,
+                    screenResults,
+                    saveResults,
+                    backtest_df,
+                    testing=testing,
+                )
+
+        OutputControls().printOutput(colorText.END)
+        if userPassedArgs is not None and (userPassedArgs.monitor is None and "|" not in userPassedArgs.options) and not userPassedArgs.options.upper().startswith("C"):
+            # Don't terminate the multiprocessing clients if we're 
+            # going to pipe the results from an earlier run
+            # or we're running in monitoring mode
+            PKScanRunner.terminateAllWorkers(userPassedArgs,consumers, tasks_queue, testing)
+        else:
+            for worker in consumers:
+                worker.paused = True
+                worker._clear()
+        return screenResults, saveResults,backtest_df,tasks_queue, results_queue, consumers, logging_queue
+
+    @exit_after(180) # Should not remain stuck starting the multiprocessing clients beyond this time
+    def prepareToRunScan(menuOption,keyboardInterruptEvent, screenCounter, screenResultsCounter, stockDictPrimary,stockDictSecondary, items, executeOption,userPassedArgs):
+        tasks_queue, results_queue, totalConsumers, logging_queue = PKScanRunner.initQueues(len(items),userPassedArgs)
+        scr = ScreeningStatistics.ScreeningStatistics(PKScanRunner.configManager, default_logger())
+        exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday=PKScanRunner.configManager.isIntradayConfig())
+        sec_cache_file = cache_file if "intraday_" in cache_file else f"intraday_{cache_file}"
+        consumers = [
+                    PKMultiProcessorClient(
+                        StockScreener().screenStocks,
+                        tasks_queue,
+                        results_queue,
+                        logging_queue,
+                        screenCounter,
+                        screenResultsCounter,
+                        # stockDictPrimary,
+                        # stockDictSecondary,
+                        (stockDictPrimary if menuOption not in ["C"] else None),
+                        (stockDictSecondary if menuOption not in ["C"] else None),
+                        PKScanRunner.fetcher.proxyServer,
+                        keyboardInterruptEvent,
+                        default_logger(),
+                        PKScanRunner.fetcher,
+                        PKScanRunner.configManager,
+                        PKScanRunner.candlePatterns,
+                        scr,
+                        # None,
+                        # None
+                        (cache_file if (exists and menuOption in ["C"]) else None),
+                        (sec_cache_file if (exists and menuOption in ["C"]) else None),
+                    )
+                    for _ in range(totalConsumers)
+                ]
+        # if executeOption == 29: # Intraday Bid/Ask, for which we need to fetch data from NSE instead of yahoo
+        try:
+            intradayFetcher = None
+            intradayFetcher = Intra_Day("SBINEQN") # This will initialise the cookies etc.
+        except:
+            pass
+        for consumer in consumers:
+            consumer.intradayNSEFetcher = intradayFetcher
+        PKScanRunner.startWorkers(consumers)
+        return tasks_queue,results_queue,consumers,logging_queue
+
+    @exit_after(120) # Should not remain stuck starting the multiprocessing clients beyond this time
+    def startWorkers(consumers):
+        try:
+            from pytest_cov.embed import cleanup_on_signal, cleanup_on_sigterm
+        except ImportError:
+            pass
+        else:
+            if sys.platform.startswith("win"):
+                import signal
+
+                cleanup_on_signal(signal.SIGBREAK)
+            else:
+                cleanup_on_sigterm()
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + f"[+] Using Period:{PKScanRunner.configManager.period} and Duration:{PKScanRunner.configManager.duration} for scan! You can change this in user config."
+            + colorText.END
+        )
+        start_time = time.time()
+        for worker in consumers:
+            sys.stdout.write(f"{round(time.time() - start_time)}.")
+            worker.daemon = True
+            worker.start()
+        OutputControls().printOutput(f"Started all workers in {round(time.time() - start_time,4)}s")
+        if OutputControls().enableMultipleLineOutput:
+            sys.stdout.write("\x1b[1A") # Move cursor up to hide the starting times we printed above
+
+    def terminateAllWorkers(userPassedArgs,consumers, tasks_queue, testing=False):
+        shouldSuppress = (userPassedArgs is None) or (userPassedArgs is not None and not userPassedArgs.log)
+        with SuppressOutput(suppress_stderr=shouldSuppress, suppress_stdout=shouldSuppress):
+            # Exit all processes. Without this, it threw error in next screening session
+            for worker in consumers:
+                try:
+                    if testing: # pragma: no cover
+                        if sys.platform.startswith("win"):
+                            import signal
+
+                            signal.signal(signal.SIGBREAK, PKScanRunner.shutdown)
+                            sleep(1)
+                        # worker.join()  # necessary so that the Process exists before the test suite exits (thus coverage is collected)
+                    # else:
+                    # try:
+                        # while worker.is_alive():
+                    worker.terminate()
+                    default_logger().debug("Worker terminated!")
+                    # except:
+                    #     continue
+                except OSError as e: # pragma: no cover
+                    default_logger().debug(e, exc_info=True)
+                    # if e.winerror == 5:
+                    continue
+
+            # Flush the queue so depending processes will end
+            while True:
+                try:
+                    _ = tasks_queue.get(False)
+                except Exception as e:  # pragma: no cover
+                    # default_logger().debug(e, exc_info=True)
+                    break
+        PKScanRunner.tasks_queue = None
+        PKScanRunner.results_queue = None
+        PKScanRunner.scr = None
+        PKScanRunner.consumers = None
+
+    def shutdown(frame, signum):
+        OutputControls().printOutput("Shutting down for test coverage")
+
+    # @exit_after(60)
+    def runScan(userPassedArgs,testing,numStocks,iterations,items,numStocksPerIteration,tasks_queue,results_queue,originalNumberOfStocks,backtest_df, *otherArgs,resultsReceivedCb=None):
+        queueCounter = 0
+        counter = 0
+        shouldContinue = True
+        lastNonNoneResult = None
+        while numStocks:
+            if counter == 0 and numStocks > 0:
+                if queueCounter < int(iterations):
+                    PKScanRunner.populateQueues(
+                        items[
+                            numStocksPerIteration
+                            * queueCounter : numStocksPerIteration
+                            * (queueCounter + 1)
+                        ],
+                        tasks_queue,
+                        (queueCounter + 1 == int(iterations)) and ((queueCounter + 1)*int(iterations) == originalNumberOfStocks),
+                        userPassedArgs
+                    )
+                else:
+                    PKScanRunner.populateQueues(
+                        items[
+                            numStocksPerIteration
+                            * queueCounter :
+                        ],
+                        tasks_queue,
+                        True,
+                        userPassedArgs
+                    )
+            numStocks -= 1
+            result = results_queue.get()
+            if result is not None:
+                lastNonNoneResult = result
+            
+            if resultsReceivedCb is not None:
+                shouldContinue, backtest_df = resultsReceivedCb(result, numStocks, backtest_df,*otherArgs)
+            counter += 1
+            # If it's being run under unit testing, let's wrap up if we find at least 1
+            # stock or if we've already tried screening through 5% of the list.
+            if (not shouldContinue) or (testing and counter >= int(numStocksPerIteration * 0.05)):
+                if PKScanRunner.consumers is not None:
+                    consumers = PKScanRunner.consumers
+                    for worker in consumers:
+                        worker.paused = True
+                        worker._clear()
+                break
+            # Add to the queue when we're through 75% of the previously added items already
+            if counter >= numStocksPerIteration: #int(numStocksPerIteration * 0.75):
+                queueCounter += 1
+                counter = 0
+        
+        return backtest_df, lastNonNoneResult
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScheduledTaskProgress.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScheduledTaskProgress.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-from pkscreener.classes.PKScheduler import progressUpdater
-class PKScheduledTaskProgress:
-    def __init__(self):
-        self.tasksDict = {}
-    
-    def updateProgress(self,taskId):
-        task = self.tasksDict.get(taskId)
-        if task is not None:
-            task.progressStatusDict[taskId] = {"progress": task.progress, "total": task.total}
-            if progressUpdater is not None:
-                progressUpdater.refresh()
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+from pkscreener.classes.PKScheduler import progressUpdater
+class PKScheduledTaskProgress:
+    def __init__(self):
+        self.tasksDict = {}
+    
+    def updateProgress(self,taskId):
+        task = self.tasksDict.get(taskId)
+        if task is not None:
+            task.progressStatusDict[taskId] = {"progress": task.progress, "total": task.total}
+            if progressUpdater is not None:
+                progressUpdater.refresh()
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScheduler.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScheduler.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,171 +1,171 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import warnings
-import os
-import sys
-import time
-# from PKDevTools.classes.OutputControls import OutputControls
-warnings.simplefilter("ignore", UserWarning,append=True)
-os.environ["PYTHONWARNINGS"]="ignore::UserWarning"
-
-def init_pool_processes(the_lock):
-    '''Initialize each process with a global variable lock.
-    '''
-    global lock
-    lock = the_lock
-
-import multiprocessing
-from multiprocessing import Lock
-
-# from time import sleep
-from concurrent.futures import ProcessPoolExecutor
-from rich.progress import Progress, BarColumn, TimeRemainingColumn, TimeElapsedColumn
-from rich.console import Console
-from rich.control import Control
-from rich.segment import ControlType
-from pkscreener.classes.PKTask import PKTask
-
-if __name__ == '__main__':
-    multiprocessing.freeze_support()
-
-# def long_running_fn(*args, **kwargs):
-#     len_of_task = random.randint(3, 20000)  # take some random length of time
-#     task = args[0]
-#     progress = task.progressStatusDict
-#     task_id = task.taskId
-#     for n in range(0, len_of_task):
-#         # sleep(1)  # sleep for a bit to simulate work
-#         progress[task_id] = {"progress": n + 1, "total": len_of_task}
-#     # if task is not None:
-#     #     progress[task_id] = task.progress_fn(task_id)
-#     # else:
-#     #     progress[task_id] = {"progress": 100, "total": 100}
-
-progressUpdater=None
-class PKScheduler():
-    def scheduleTasks(tasksList=[], label:str=None, showProgressBars=False,submitTaskAsArgs=True, timeout=6, minAcceptableCompletionPercentage=100):
-        n_workers = multiprocessing.cpu_count() - 1  # set this to the number of cores you have on your machine
-        global progressUpdater
-        console = Console()
-        with Progress(
-                "[progress.description]{task.description}",
-                BarColumn(),
-                "[progress.percentage]{task.percentage:>3.0f}%",
-                TimeRemainingColumn(),
-                TimeElapsedColumn(),
-                auto_refresh = True,
-                refresh_per_second=100,  # bit slower updates if we keep it to 1
-                console=console
-            ) as progress:
-            progressUpdater = progress
-            if len(tasksList) == 0:
-                raise ValueError("No tasks in the tasksList!")
-            for task in tasksList:
-                if not isinstance(task, PKTask):
-                    raise ValueError("Each task in the tasksList must be of type PKTask!")
-            futures = []  # keep track of the jobs
-            with multiprocessing.Manager() as manager:
-                # this is the key - we share some state between our 
-                # main process and our worker functions
-                _progress = manager.dict()
-                _results = manager.dict()
-                console.control(Control(*((ControlType.CURSOR_UP,1),))) # Cursor up 1 lines f"\x1b[{param}A"
-                # sys.stdout.write("\x1b[2K")  # delete the last line
-                overall_progress_task = progress.add_task(f"[green]{label if label is not None else 'Pending jobs progress:'}")
-
-                lock = Lock()
-                with ProcessPoolExecutor(max_workers=n_workers,
-                                         initializer=init_pool_processes,
-                                         initargs=(lock,)) as executor:
-                    for task in tasksList:  # iterate over the jobs we need to run
-                        # set visible false so we don't have a lot of bars all at once:
-                        task_id = progress.add_task(f"Task :{task.taskName}", visible=showProgressBars)
-                        task.taskId = task_id
-                        task.progressStatusDict = _progress
-                        task.resultsDict = _results
-                        futures.append(executor.submit(task.long_running_fn, task if submitTaskAsArgs else task.long_running_fn_args))
-
-                    # monitor the progress:
-                    start_time = time.time()
-                    while (((n_finished := sum([future.done() for future in futures])) < len(futures)) and ((time.time() - start_time) < timeout)):
-                        progress.update(
-                            overall_progress_task,
-                            completed=n_finished,
-                            total=len(futures),
-                            visible=n_finished < len(futures)
-                        )
-                        # OutputControls().printOutput(f"{n_finished} of {len(futures)}")
-                        # We've reached a state where the caller may not want to wait any further
-                        if n_finished*100/len(futures) >= minAcceptableCompletionPercentage:
-                            break
-                        for task_id, update_data in _progress.items():
-                            for task in tasksList:
-                                if task.taskId == task_id:
-                                    task.result = task.resultsDict.get(task_id)
-                            latest = update_data["progress"]
-                            total = update_data["total"]
-                            # update the progress bar for this task:
-                            progress.update(
-                                task_id,
-                                completed=latest,
-                                total=total,
-                                visible=(latest < total) and showProgressBars,
-                            )
-                            lock.acquire()
-                            progress.refresh()
-                            lock.release()
-                    # sleep(0.1)
-                    progress.update(
-                            overall_progress_task,
-                            completed=1,
-                            total=1,
-                            visible=False
-                        )
-                    for task_id, update_data in _progress.items():
-                        # update the progress bar for this task:
-                        progress.update(
-                            task_id,
-                            completed=1,
-                            total=1,
-                            visible=False,
-                        )
-                    lock.acquire()
-                    progress.refresh()
-                    # raise any errors:
-                    # for future in futures:
-                    #     future.result()
-                    lock.release()
-
-# if __name__ == "__main__":
-#     scheduleTasks([PKTask("Task 1",long_running_fn,),
-#                 PKTask("Task 2",long_running_fn),
-#                 PKTask("Task 3",long_running_fn),
-#                 PKTask("Task 4",long_running_fn),
-#                 PKTask("Task 5",long_running_fn),
-#                 PKTask("Task 6",long_running_fn),
-#                 PKTask("Task 7",long_running_fn),
-#                 PKTask("Task 8",long_running_fn),
-#                 PKTask("Task 9",long_running_fn),
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import warnings
+import os
+import sys
+import time
+# from PKDevTools.classes.OutputControls import OutputControls
+warnings.simplefilter("ignore", UserWarning,append=True)
+os.environ["PYTHONWARNINGS"]="ignore::UserWarning"
+
+def init_pool_processes(the_lock):
+    '''Initialize each process with a global variable lock.
+    '''
+    global lock
+    lock = the_lock
+
+import multiprocessing
+from multiprocessing import Lock
+
+# from time import sleep
+from concurrent.futures import ProcessPoolExecutor
+from rich.progress import Progress, BarColumn, TimeRemainingColumn, TimeElapsedColumn
+from rich.console import Console
+from rich.control import Control
+from rich.segment import ControlType
+from pkscreener.classes.PKTask import PKTask
+
+if __name__ == '__main__':
+    multiprocessing.freeze_support()
+
+# def long_running_fn(*args, **kwargs):
+#     len_of_task = random.randint(3, 20000)  # take some random length of time
+#     task = args[0]
+#     progress = task.progressStatusDict
+#     task_id = task.taskId
+#     for n in range(0, len_of_task):
+#         # sleep(1)  # sleep for a bit to simulate work
+#         progress[task_id] = {"progress": n + 1, "total": len_of_task}
+#     # if task is not None:
+#     #     progress[task_id] = task.progress_fn(task_id)
+#     # else:
+#     #     progress[task_id] = {"progress": 100, "total": 100}
+
+progressUpdater=None
+class PKScheduler():
+    def scheduleTasks(tasksList=[], label:str=None, showProgressBars=False,submitTaskAsArgs=True, timeout=6, minAcceptableCompletionPercentage=100):
+        n_workers = multiprocessing.cpu_count() - 1  # set this to the number of cores you have on your machine
+        global progressUpdater
+        console = Console()
+        with Progress(
+                "[progress.description]{task.description}",
+                BarColumn(),
+                "[progress.percentage]{task.percentage:>3.0f}%",
+                TimeRemainingColumn(),
+                TimeElapsedColumn(),
+                auto_refresh = True,
+                refresh_per_second=100,  # bit slower updates if we keep it to 1
+                console=console
+            ) as progress:
+            progressUpdater = progress
+            if len(tasksList) == 0:
+                raise ValueError("No tasks in the tasksList!")
+            for task in tasksList:
+                if not isinstance(task, PKTask):
+                    raise ValueError("Each task in the tasksList must be of type PKTask!")
+            futures = []  # keep track of the jobs
+            with multiprocessing.Manager() as manager:
+                # this is the key - we share some state between our 
+                # main process and our worker functions
+                _progress = manager.dict()
+                _results = manager.dict()
+                console.control(Control(*((ControlType.CURSOR_UP,1),))) # Cursor up 1 lines f"\x1b[{param}A"
+                # sys.stdout.write("\x1b[2K")  # delete the last line
+                overall_progress_task = progress.add_task(f"[green]{label if label is not None else 'Pending jobs progress:'}")
+
+                lock = Lock()
+                with ProcessPoolExecutor(max_workers=n_workers,
+                                         initializer=init_pool_processes,
+                                         initargs=(lock,)) as executor:
+                    for task in tasksList:  # iterate over the jobs we need to run
+                        # set visible false so we don't have a lot of bars all at once:
+                        task_id = progress.add_task(f"Task :{task.taskName}", visible=showProgressBars)
+                        task.taskId = task_id
+                        task.progressStatusDict = _progress
+                        task.resultsDict = _results
+                        futures.append(executor.submit(task.long_running_fn, task if submitTaskAsArgs else task.long_running_fn_args))
+
+                    # monitor the progress:
+                    start_time = time.time()
+                    while (((n_finished := sum([future.done() for future in futures])) < len(futures)) and ((time.time() - start_time) < timeout)):
+                        progress.update(
+                            overall_progress_task,
+                            completed=n_finished,
+                            total=len(futures),
+                            visible=n_finished < len(futures)
+                        )
+                        # OutputControls().printOutput(f"{n_finished} of {len(futures)}")
+                        # We've reached a state where the caller may not want to wait any further
+                        if n_finished*100/len(futures) >= minAcceptableCompletionPercentage:
+                            break
+                        for task_id, update_data in _progress.items():
+                            for task in tasksList:
+                                if task.taskId == task_id:
+                                    task.result = task.resultsDict.get(task_id)
+                            latest = update_data["progress"]
+                            total = update_data["total"]
+                            # update the progress bar for this task:
+                            progress.update(
+                                task_id,
+                                completed=latest,
+                                total=total,
+                                visible=(latest < total) and showProgressBars,
+                            )
+                            lock.acquire()
+                            progress.refresh()
+                            lock.release()
+                    # sleep(0.1)
+                    progress.update(
+                            overall_progress_task,
+                            completed=1,
+                            total=1,
+                            visible=False
+                        )
+                    for task_id, update_data in _progress.items():
+                        # update the progress bar for this task:
+                        progress.update(
+                            task_id,
+                            completed=1,
+                            total=1,
+                            visible=False,
+                        )
+                    lock.acquire()
+                    progress.refresh()
+                    # raise any errors:
+                    # for future in futures:
+                    #     future.result()
+                    lock.release()
+
+# if __name__ == "__main__":
+#     scheduleTasks([PKTask("Task 1",long_running_fn,),
+#                 PKTask("Task 2",long_running_fn),
+#                 PKTask("Task 3",long_running_fn),
+#                 PKTask("Task 4",long_running_fn),
+#                 PKTask("Task 5",long_running_fn),
+#                 PKTask("Task 6",long_running_fn),
+#                 PKTask("Task 7",long_running_fn),
+#                 PKTask("Task 8",long_running_fn),
+#                 PKTask("Task 9",long_running_fn),
 #                 PKTask("Task 10",long_running_fn)])
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKSpreadsheets.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKSpreadsheets.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,168 +1,168 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import datetime
-import pytz
-import gspread_pandas as gp
-from google.oauth2.service_account import Credentials as ServiceAccountCredentials
-import json
-import os
-
-class PKSpreadsheets:
-
-    def __init__(self,credentialFilePath=None,credentialDictStr=None) -> None:
-        self.gClient = None
-        self.credentialFilePath = credentialFilePath
-        self.credentialDictStr = credentialDictStr
-        self.credentials = None
-        self.authCredentials = None
-
-    def login(self):
-        if self.credentialFilePath is not None:
-            with open(self.credentialFilePath) as f:
-                self.credentials = json.load(f)
-        elif self.credentialDictStr is not None:
-            self.credentials = json.loads(self.credentialDictStr)
-        else:
-            if "GSHEET_SERVICE_ACCOUNT_DEV" in os.environ.keys():
-                self.credentials = json.load(os.environ["GSHEET_SERVICE_ACCOUNT_DEV"])
-        if self.credentials is None:
-            raise ValueError("Credentials cannot be empty!")
-        
-        DEFAULT_SCOPES =[
-            'https://www.googleapis.com/auth/spreadsheets',
-            'https://www.googleapis.com/auth/drive'
-        ]
-        self.authCredentials = ServiceAccountCredentials.from_service_account_info(
-            info=self.credentials,
-            scopes=DEFAULT_SCOPES,
-        )
-        self.gClient = gp.Client(creds=self.authCredentials,config=self.credentials,load_dirs=False) #gspread.service_account_from_dict(self.credentials)
-
-    def listFolders(self):
-        return self.gClient._get_dirs()
-    
-    def getFolder(self,path="/"):
-        dirs = self.listFolders()
-        # 'id': '0AEHslrN6p5ejUk9PVA'
-        # 'name': 'My Drive'
-        # 'path': '/'
-        folder = None
-        if path != "/":
-            for dir in dirs:
-                if dir["path"] == path:
-                    folder = dir
-                    break
-        else:
-            for dir in dirs:
-                if dir["path"] == "/":
-                    folder = dir
-        return folder
-    
-    def listWorkbooks(self,path="/", folderId=None):
-        if folderId is None:
-            folder = self.getFolder(path=path)
-            if folder is not None:
-                folderId = folder["id"]
-        existingWorkbooks = None
-        if folderId is not None:
-            existingWorkbooks = self.gClient.list_spreadsheet_files_in_folder(folder_id=folderId)
-        return existingWorkbooks
-
-    def getWorkbookByName(self,workbookName=None, atPath="/", folderId=None) -> gp.Spread:
-        existingWorkbooks = self.listWorkbooks(path=atPath,folderId=folderId)
-        workbookOutcome = None
-        for workbook in existingWorkbooks:
-            if workbook["name"] == workbookName:
-                workbookOutcome = self.gClient.open_by_key(workbook["id"])
-                break
-        return gp.Spread(workbookOutcome.id, client=self.gClient, creds=self.authCredentials, config=self.credentials) if workbookOutcome is not None else None
-    
-    def createFolder(self, path="/"):
-        if path == "/":
-            raise ValueError("Cannot create the root folder! Supply a path value, e.g., /Parent/Child/")
-        return self.gClient.create_folder(path=path)
-
-    def createWorkbook(self, workbookName=None, atFolderPath="/"):
-        if self.gClient is None:
-            raise Exception("You must login first using login() method!")
-        if workbookName is None:
-            raise ValueError("workbookName cannot be empty!")
-        workbookOutcome = None
-        # 'id': '0AEHslrN6p5ejUk9PVA'
-        # 'name': 'My Drive'
-        # 'path': '/'
-        folder = self.getFolder(path=atFolderPath)
-        if folder is not None:
-            folderId = folder["id"]
-            workbookOutcome = self.getWorkbookByName(workbookName=workbookName,atPath=atFolderPath,folderId=folderId)
-        else:
-            folderInfo = self.createFolder(path=atFolderPath)
-            folderId = folderInfo["id"]
-        if workbookOutcome is None:
-            workbookOutcome = self.gClient.create(title=workbookName,folder_id=folderId)
-            # 'id':'18ijLL0uGSYTeRYFb8aQNzJc4m7lCH61T2T8wtpfodSk'
-            # 'title':'PKScreener'
-            # 'locale':'en_US'
-            # 'autoRecalc':'ON_CHANGE'
-            # 'timeZone':'Etc/GMT'
-            # 'defaultFormat':{'backgroundColor': {'red': 1, 'green': 1, 'blue': 1}, 'padding': {'top': 2, 'right': 3, 'bottom': 2, 'left': 3}, 'verticalAlignment': 'BOTTOM', 'wrapStrategy': 'OVERFLOW_CELL', 'textFormat': {'foregroundColor': {}, 'fontFamily': 'arial,sans,sans-serif', 'fontSize': 10, 'bold': False, 'italic': False, 'strikethrough': False, 'underline': False, 'foregroundColorStyle': {...}}, 'backgroundColorStyle': {'rgbColor': {...}}}
-            # 'spreadsheetTheme':{'primaryFontFamily': 'Arial', 'themeColors': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}]}
-            # 'name':'PKScreener'
-            # 'createdTime':'2024-03-07T19:40:58.328Z'
-            # 'modifiedTime':'2024-03-07T19:40:58.412Z'
-            workbookOutcome.share('pkscreener.in@gmail.com', perm_type='user', role='writer', notify=False)
-            permissions = workbookOutcome.list_permissions()
-            for permission in permissions:
-                if permission["emailAddress"] == "pkscreener.in@gmail.com" and permission["role"] == "writer":
-                    workbookOutcome.transfer_ownership(permission_id=permission["id"])
-                    break
-        return gp.Spread(workbookOutcome.id, client=self.gClient, creds=self.authCredentials, config=self.credentials) if workbookOutcome is not None else None
-
-    def addWorksheet(self,worksheetName=None,workbook:gp.Spread=None):
-        assert workbook is not None
-        assert worksheetName is not None
-        workbook.open_sheet(sheet=worksheetName, create=True)
-        return workbook.sheet if workbook.sheet.title == worksheetName else None
-    
-    def findSheet(self, worksheetName=None,workbook:gp.Spread=None):
-        return workbook.find_sheet(sheet=worksheetName)
-    
-    def df_to_sheet(self,df=None,sheetName=None,folderName="PKScreener",workbookName="PKScreener"):
-        self.login()
-        valueAddColumns = ["EntryDate", "EntryTime", "ScanLabel"]
-        today = datetime.datetime.now(pytz.timezone("Asia/Kolkata"))
-        date = today.date().strftime("%Y-%m-%d")
-        time = today.strftime("%H:%M:%S")
-        for col in valueAddColumns:
-            if col not in df.columns:
-                df[col] = date if col == valueAddColumns[0] else (time if col == valueAddColumns[1] else sheetName)
-        workbook = self.getWorkbookByName(workbookName=workbookName,atPath=folderName)
-        sheet = self.addWorksheet(worksheetName=sheetName,workbook=workbook)
-        currentMaxRow = sheet.row_count
-        currentMaxCol = sheet.col_count
-        currentMaxRow = currentMaxRow + 1 if currentMaxRow > 1 else currentMaxRow
-        sheet.resize(len(df)+ currentMaxRow, max(len(df.columns),currentMaxCol))
-        workbook.df_to_sheet(df=df, start=(currentMaxRow,1), freeze_headers=False, freeze_index=True,sheet=sheet)
-        sheet.freeze(rows=1, cols=1)
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import datetime
+import pytz
+import gspread_pandas as gp
+from google.oauth2.service_account import Credentials as ServiceAccountCredentials
+import json
+import os
+
+class PKSpreadsheets:
+
+    def __init__(self,credentialFilePath=None,credentialDictStr=None) -> None:
+        self.gClient = None
+        self.credentialFilePath = credentialFilePath
+        self.credentialDictStr = credentialDictStr
+        self.credentials = None
+        self.authCredentials = None
+
+    def login(self):
+        if self.credentialFilePath is not None:
+            with open(self.credentialFilePath) as f:
+                self.credentials = json.load(f)
+        elif self.credentialDictStr is not None:
+            self.credentials = json.loads(self.credentialDictStr)
+        else:
+            if "GSHEET_SERVICE_ACCOUNT_DEV" in os.environ.keys():
+                self.credentials = json.load(os.environ["GSHEET_SERVICE_ACCOUNT_DEV"])
+        if self.credentials is None:
+            raise ValueError("Credentials cannot be empty!")
+        
+        DEFAULT_SCOPES =[
+            'https://www.googleapis.com/auth/spreadsheets',
+            'https://www.googleapis.com/auth/drive'
+        ]
+        self.authCredentials = ServiceAccountCredentials.from_service_account_info(
+            info=self.credentials,
+            scopes=DEFAULT_SCOPES,
+        )
+        self.gClient = gp.Client(creds=self.authCredentials,config=self.credentials,load_dirs=False) #gspread.service_account_from_dict(self.credentials)
+
+    def listFolders(self):
+        return self.gClient._get_dirs()
+    
+    def getFolder(self,path="/"):
+        dirs = self.listFolders()
+        # 'id': '0AEHslrN6p5ejUk9PVA'
+        # 'name': 'My Drive'
+        # 'path': '/'
+        folder = None
+        if path != "/":
+            for dir in dirs:
+                if dir["path"] == path:
+                    folder = dir
+                    break
+        else:
+            for dir in dirs:
+                if dir["path"] == "/":
+                    folder = dir
+        return folder
+    
+    def listWorkbooks(self,path="/", folderId=None):
+        if folderId is None:
+            folder = self.getFolder(path=path)
+            if folder is not None:
+                folderId = folder["id"]
+        existingWorkbooks = None
+        if folderId is not None:
+            existingWorkbooks = self.gClient.list_spreadsheet_files_in_folder(folder_id=folderId)
+        return existingWorkbooks
+
+    def getWorkbookByName(self,workbookName=None, atPath="/", folderId=None) -> gp.Spread:
+        existingWorkbooks = self.listWorkbooks(path=atPath,folderId=folderId)
+        workbookOutcome = None
+        for workbook in existingWorkbooks:
+            if workbook["name"] == workbookName:
+                workbookOutcome = self.gClient.open_by_key(workbook["id"])
+                break
+        return gp.Spread(workbookOutcome.id, client=self.gClient, creds=self.authCredentials, config=self.credentials) if workbookOutcome is not None else None
+    
+    def createFolder(self, path="/"):
+        if path == "/":
+            raise ValueError("Cannot create the root folder! Supply a path value, e.g., /Parent/Child/")
+        return self.gClient.create_folder(path=path)
+
+    def createWorkbook(self, workbookName=None, atFolderPath="/"):
+        if self.gClient is None:
+            raise Exception("You must login first using login() method!")
+        if workbookName is None:
+            raise ValueError("workbookName cannot be empty!")
+        workbookOutcome = None
+        # 'id': '0AEHslrN6p5ejUk9PVA'
+        # 'name': 'My Drive'
+        # 'path': '/'
+        folder = self.getFolder(path=atFolderPath)
+        if folder is not None:
+            folderId = folder["id"]
+            workbookOutcome = self.getWorkbookByName(workbookName=workbookName,atPath=atFolderPath,folderId=folderId)
+        else:
+            folderInfo = self.createFolder(path=atFolderPath)
+            folderId = folderInfo["id"]
+        if workbookOutcome is None:
+            workbookOutcome = self.gClient.create(title=workbookName,folder_id=folderId)
+            # 'id':'18ijLL0uGSYTeRYFb8aQNzJc4m7lCH61T2T8wtpfodSk'
+            # 'title':'PKScreener'
+            # 'locale':'en_US'
+            # 'autoRecalc':'ON_CHANGE'
+            # 'timeZone':'Etc/GMT'
+            # 'defaultFormat':{'backgroundColor': {'red': 1, 'green': 1, 'blue': 1}, 'padding': {'top': 2, 'right': 3, 'bottom': 2, 'left': 3}, 'verticalAlignment': 'BOTTOM', 'wrapStrategy': 'OVERFLOW_CELL', 'textFormat': {'foregroundColor': {}, 'fontFamily': 'arial,sans,sans-serif', 'fontSize': 10, 'bold': False, 'italic': False, 'strikethrough': False, 'underline': False, 'foregroundColorStyle': {...}}, 'backgroundColorStyle': {'rgbColor': {...}}}
+            # 'spreadsheetTheme':{'primaryFontFamily': 'Arial', 'themeColors': [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}]}
+            # 'name':'PKScreener'
+            # 'createdTime':'2024-03-07T19:40:58.328Z'
+            # 'modifiedTime':'2024-03-07T19:40:58.412Z'
+            workbookOutcome.share('pkscreener.in@gmail.com', perm_type='user', role='writer', notify=False)
+            permissions = workbookOutcome.list_permissions()
+            for permission in permissions:
+                if permission["emailAddress"] == "pkscreener.in@gmail.com" and permission["role"] == "writer":
+                    workbookOutcome.transfer_ownership(permission_id=permission["id"])
+                    break
+        return gp.Spread(workbookOutcome.id, client=self.gClient, creds=self.authCredentials, config=self.credentials) if workbookOutcome is not None else None
+
+    def addWorksheet(self,worksheetName=None,workbook:gp.Spread=None):
+        assert workbook is not None
+        assert worksheetName is not None
+        workbook.open_sheet(sheet=worksheetName, create=True)
+        return workbook.sheet if workbook.sheet.title == worksheetName else None
+    
+    def findSheet(self, worksheetName=None,workbook:gp.Spread=None):
+        return workbook.find_sheet(sheet=worksheetName)
+    
+    def df_to_sheet(self,df=None,sheetName=None,folderName="PKScreener",workbookName="PKScreener"):
+        self.login()
+        valueAddColumns = ["EntryDate", "EntryTime", "ScanLabel"]
+        today = datetime.datetime.now(pytz.timezone("Asia/Kolkata"))
+        date = today.date().strftime("%Y-%m-%d")
+        time = today.strftime("%H:%M:%S")
+        for col in valueAddColumns:
+            if col not in df.columns:
+                df[col] = date if col == valueAddColumns[0] else (time if col == valueAddColumns[1] else sheetName)
+        workbook = self.getWorkbookByName(workbookName=workbookName,atPath=folderName)
+        sheet = self.addWorksheet(worksheetName=sheetName,workbook=workbook)
+        currentMaxRow = sheet.row_count
+        currentMaxCol = sheet.col_count
+        currentMaxRow = currentMaxRow + 1 if currentMaxRow > 1 else currentMaxRow
+        sheet.resize(len(df)+ currentMaxRow, max(len(df.columns),currentMaxCol))
+        workbook.df_to_sheet(df=df, start=(currentMaxRow,1), freeze_headers=False, freeze_index=True,sheet=sheet)
+        sheet.freeze(rows=1, cols=1)
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKTask.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKTask.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,41 +1,41 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-class PKTask:
-    def __init__(self, taskName=None, long_running_fn=None, long_running_fn_args=None, progress_fn=None):
-        if taskName is None or taskName == "":
-            raise ValueError("taskName cannot be None or empty string!")
-        if long_running_fn is None:
-            raise ValueError("long_running_fn cannot be None!")
-        self.taskName = taskName
-        self.progressStatusDict = None
-        self.taskId = 0
-        self.progress = 0
-        self.total = 0
-        self.long_running_fn = long_running_fn
-        self.long_running_fn_args = long_running_fn_args
-        self.progress_fn = progress_fn
-        self.resultsDict = None
-        self.result = None
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+class PKTask:
+    def __init__(self, taskName=None, long_running_fn=None, long_running_fn_args=None, progress_fn=None):
+        if taskName is None or taskName == "":
+            raise ValueError("taskName cannot be None or empty string!")
+        if long_running_fn is None:
+            raise ValueError("long_running_fn cannot be None!")
+        self.taskName = taskName
+        self.progressStatusDict = None
+        self.taskId = 0
+        self.progress = 0
+        self.total = 0
+        self.long_running_fn = long_running_fn
+        self.long_running_fn_args = long_running_fn_args
+        self.progress_fn = progress_fn
+        self.resultsDict = None
+        self.result = None
         self.userData = None
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Pktalib.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Pktalib.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,477 +1,477 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import warnings
-from time import sleep
-
-import numpy as np
-
-warnings.simplefilter("ignore", DeprecationWarning)
-warnings.simplefilter("ignore", FutureWarning)
-import pandas as pd
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.OutputControls import OutputControls
-
-from pkscreener import Imports
-
-if Imports["talib"]:
-    try:
-        import talib
-    except:
-        OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] 'TA-Lib' library is not installed. For best results, please install 'TA-Lib'! You may wish to follow instructions from\n[+] https://github.com/pkjmesra/PKScreener/"
-                + colorText.END
-            )
-        try:
-            import pandas_ta as talib
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] TA-Lib is not installed. Falling back on pandas_ta.\n[+] For full coverage(candle patterns), you may wish to follow instructions from\n[+] https://github.com/ta-lib/ta-lib-python"
-                + colorText.END
-            )
-        except:
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] pandas_ta is not installed. Falling back on pandas_ta also failed.\n[+] For full coverage(candle patterns), you may wish to follow instructions from\n[+] https://github.com/ta-lib/ta-lib-python"
-                + colorText.END
-            )
-            pass
-        pass
-else:
-    try:
-        import pandas_ta as talib
-        OutputControls().printOutput(
-            colorText.BOLD
-            + colorText.FAIL
-            + "[+] TA-Lib is not installed. Falling back on pandas_ta.\n[+] For full coverage(candle patterns), you may wish to follow instructions from\n[+] https://github.com/ta-lib/ta-lib-python"
-            + colorText.END
-        )
-        sleep(3)
-    except Exception:  # pragma: no cover
-        # default_logger().debug(e, exc_info=True)
-        import talib
-
-
-class pktalib:
-    @classmethod
-    def BBANDS(self, close, timeperiod,std=2, mamode=0):
-        try:
-            return talib.bbands(close, timeperiod)
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.BBANDS(close, timeperiod, std, std, mamode)
-        
-    @classmethod
-    def EMA(self, close, timeperiod):
-        try:
-            return talib.ema(close, timeperiod)
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.EMA(close, timeperiod)
-
-    @classmethod
-    def KeltnersChannel(self, high, low, close, timeperiod=20):
-        try:
-            low_kel = None
-            upp_kel = None
-            tr = pktalib.TRUERANGE(high, low, close)
-            atr = pktalib.ATR(high, low, close, timeperiod=timeperiod)
-            sma = pktalib.SMA(close=close, timeperiod=timeperiod)
-            low_kel = sma - atr * 1.5
-            upp_kel = sma + atr * 1.5
-            return low_kel, upp_kel
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return low_kel, upp_kel
-        
-    @classmethod
-    def SMA(self, close, timeperiod):
-        try:
-            return talib.sma(close, timeperiod)
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.SMA(close, timeperiod)
-
-    @classmethod
-    def ATR(self, high, low, close, timeperiod=14):
-        try:
-            return talib.atr(high, low, close, length= timeperiod)
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.ATR(high, low, close, timeperiod=timeperiod)
-        
-    @classmethod
-    def TRUERANGE(self, high, low, close):
-        try:
-            return talib.true_range(high, low, close)
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.TRANGE(high, low, close)
-
-    @classmethod
-    def MA(self, close, timeperiod):
-        try:
-            return talib.ma(close, timeperiod)
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.MA(close, timeperiod)
-
-    @classmethod
-    def MACD(self, close, fast, slow, signal):
-        try:
-            # import pandas_ta as talib
-            return talib.macd(close, fast, slow, signal, talib=Imports["talib"])
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.MACD(close, fast, slow, signal)
-
-    @classmethod
-    def MFI(self, high, low, close,volume, timeperiod=14):
-        try:
-            return talib.mfi(high, low, close,volume, length= timeperiod)
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.MFI(high, low, close,volume, timeperiod=timeperiod)
-
-    @classmethod
-    def RSI(self, close, timeperiod):
-        try:
-            return talib.rsi(close, timeperiod)
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.RSI(close, timeperiod)
-
-    @classmethod
-    def CCI(self, high, low, close, timeperiod):
-        try:
-            return talib.cci(high, low, close, timeperiod)
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CCI(high, low, close, timeperiod)
-
-    @classmethod
-    def Aroon(self, high, low, timeperiod):
-        try:
-            return talib.aroon(high, low, timeperiod)
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            aroon_down, aroon_up = talib.AROON(high, low, timeperiod)
-            aroon_up.name = f"AROONU_{timeperiod}"
-            aroon_down.name = f"AROOND_{timeperiod}"
-            data = {
-                aroon_down.name: aroon_down,
-                aroon_up.name: aroon_up,
-            }
-            return pd.DataFrame(data)
-
-    @classmethod
-    def STOCHF(self, high, low, close, fastk_period, fastd_period, fastd_matype):
-        fastk, fastd = talib.STOCHF(high,
-                            low,
-                            close,
-                            fastk_period, 
-                            fastd_period,
-                            fastd_matype)
-        return fastk, fastd
-    
-    @classmethod
-    def STOCHRSI(self, close, timeperiod, fastk_period, fastd_period, fastd_matype):
-        try:
-            _name = "STOCHRSI"
-            _props = f"_{timeperiod}_{timeperiod}_{fastk_period}_{fastd_period}"
-            stochrsi_kname = f"{_name}k{_props}"
-            stochrsi_dname = f"{_name}d{_props}"
-            df = talib.stochrsi(
-                close,
-                length=timeperiod,
-                rsi_length=timeperiod,
-                k=fastk_period,
-                d=fastd_period,
-                mamode=fastd_matype,
-            )
-            return df[stochrsi_kname], df[stochrsi_dname]
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.STOCHRSI(
-                close.values, timeperiod, fastk_period, fastd_period, fastd_matype
-            )
-
-    @classmethod
-    def ichimoku(
-        self, df, tenkan=None, kijun=None, senkou=None, include_chikou=True, offset=None
-    ):
-        import pandas_ta as ta
-
-        ichimokudf, spandf = ta.ichimoku(
-            df["high"], df["low"], df["close"], tenkan, kijun, senkou, False, 26
-        )
-        return ichimokudf
-
-    @classmethod
-    def supertrend(self, df, length=7, multiplier=3):
-        import pandas_ta as ta
-
-        sti = ta.supertrend(
-            df["High"], df["Low"], df["Close"], length=length, multiplier=multiplier
-        )
-        # trend, direction, long, short
-        # SUPERT_7_3.0  SUPERTd_7_3.0  SUPERTl_7_3.0  SUPERTs_7_3.0
-        return sti if sti is not None else {'SUPERT_7_3.0':np.nan}
-
-    @classmethod
-    def psar(self, high, low, acceleration=0.02, maximum=0.2):
-        psar = talib.SAR(high, low, acceleration=acceleration, maximum=maximum)
-        return psar
-
-    @classmethod
-    def CDLMORNINGSTAR(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "morningstar")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLMORNINGSTAR(open, high, low, close)
-
-    @classmethod
-    def CDLMORNINGDOJISTAR(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "morningdojistar")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLMORNINGDOJISTAR(open, high, low, close)
-
-    @classmethod
-    def CDLEVENINGSTAR(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "eveningstar")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLEVENINGSTAR(open, high, low, close)
-
-    @classmethod
-    def CDLEVENINGDOJISTAR(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "eveningdojistar")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLEVENINGDOJISTAR(open, high, low, close)
-
-    @classmethod
-    def CDLLADDERBOTTOM(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "ladderbottom")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLLADDERBOTTOM(open, high, low, close)
-
-    @classmethod
-    def CDL3LINESTRIKE(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "3linestrike")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDL3LINESTRIKE(open, high, low, close)
-
-    @classmethod
-    def CDL3BLACKCROWS(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "3blackcrows")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDL3BLACKCROWS(open, high, low, close)
-
-    @classmethod
-    def CDL3INSIDE(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "3inside")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDL3INSIDE(open, high, low, close)
-
-    @classmethod
-    def CDL3OUTSIDE(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "3outside")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDL3OUTSIDE(open, high, low, close)
-
-    @classmethod
-    def CDL3WHITESOLDIERS(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "3whitesoldiers")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDL3WHITESOLDIERS(open, high, low, close)
-
-    @classmethod
-    def CDLHARAMI(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "harami")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLHARAMI(open, high, low, close)
-
-    @classmethod
-    def CDLHARAMICROSS(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "haramicross")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLHARAMICROSS(open, high, low, close)
-
-    @classmethod
-    def CDLMARUBOZU(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "marubozu")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLMARUBOZU(open, high, low, close)
-
-    @classmethod
-    def CDLHANGINGMAN(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "hangingman")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLHANGINGMAN(open, high, low, close)
-
-    @classmethod
-    def CDLHAMMER(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "hammer")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLHAMMER(open, high, low, close)
-
-    @classmethod
-    def CDLINVERTEDHAMMER(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "invertedhammer")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLINVERTEDHAMMER(open, high, low, close)
-
-    @classmethod
-    def CDLSHOOTINGSTAR(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "shootingstar")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLSHOOTINGSTAR(open, high, low, close)
-
-    @classmethod
-    def CDLDRAGONFLYDOJI(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "dragonflydoji")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLDRAGONFLYDOJI(open, high, low, close)
-
-    @classmethod
-    def CDLGRAVESTONEDOJI(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "gravestonedoji")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLGRAVESTONEDOJI(open, high, low, close)
-
-    @classmethod
-    def CDLDOJI(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "doji")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLDOJI(open, high, low, close)
-
-    @classmethod
-    def CDLENGULFING(self, open, high, low, close):
-        try:
-            return talib.cdl_pattern(open, high, low, close, "engulfing")
-        except Exception:  # pragma: no cover
-            # default_logger().debug(e, exc_info=True)
-            return talib.CDLENGULFING(open, high, low, close)
-
-    @classmethod
-    def argrelextrema(self, data, comparator, axis=0, order=1, mode="clip"):
-        """
-        Calculate the relative extrema of `data`.
-
-        Relative extrema are calculated by finding locations where
-        ``comparator(data[n], data[n+1:n+order+1])`` is True.
-
-        Parameters
-        ----------
-        data : ndarray
-            Array in which to find the relative extrema.
-        comparator : callable
-            Function to use to compare two data points.
-            Should take two arrays as arguments.
-        axis : int, optional
-            Axis over which to select from `data`. Default is 0.
-        order : int, optional
-            How many points on each side to use for the comparison
-            to consider ``comparator(n,n+x)`` to be True.
-        mode : str, optional
-            How the edges of the vector are treated. 'wrap' (wrap around) or
-            'clip' (treat overflow as the same as the last (or first) element).
-            Default 'clip'. See numpy.take.
-
-        Returns
-        -------
-        extrema : ndarray
-            Boolean array of the same shape as `data` that is True at an extrema,
-            False otherwise.
-
-        See also
-        --------
-        argrelmax, argrelmin
-
-        Examples
-        --------
-        >>> import numpy as np
-        >>> testdata = np.array([1,2,3,2,1])
-        >>> _boolrelextrema(testdata, np.greater, axis=0)
-        array([False, False,  True, False, False], dtype=bool)
-
-        """
-        if (int(order) != order) or (order < 1):
-            raise ValueError("Order must be an int >= 1")
-
-        datalen = data.shape[axis]
-        locs = np.arange(0, datalen)
-
-        results = np.ones(data.shape, dtype=bool)
-        main = data.take(locs, axis=axis, mode=mode)
-        for shift in range(1, order + 1):
-            plus = data.take(locs + shift, axis=axis, mode=mode)
-            minus = data.take(locs - shift, axis=axis, mode=mode)
-            results &= comparator(main, plus)
-            results &= comparator(main, minus)
-            if ~results.any():
-                return results
-        return np.nonzero(results)
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import warnings
+from time import sleep
+
+import numpy as np
+
+warnings.simplefilter("ignore", DeprecationWarning)
+warnings.simplefilter("ignore", FutureWarning)
+import pandas as pd
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.OutputControls import OutputControls
+
+from pkscreener import Imports
+
+if Imports["talib"]:
+    try:
+        import talib
+    except:
+        OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] 'TA-Lib' library is not installed. For best results, please install 'TA-Lib'! You may wish to follow instructions from\n[+] https://github.com/pkjmesra/PKScreener/"
+                + colorText.END
+            )
+        try:
+            import pandas_ta as talib
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] TA-Lib is not installed. Falling back on pandas_ta.\n[+] For full coverage(candle patterns), you may wish to follow instructions from\n[+] https://github.com/ta-lib/ta-lib-python"
+                + colorText.END
+            )
+        except:
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] pandas_ta is not installed. Falling back on pandas_ta also failed.\n[+] For full coverage(candle patterns), you may wish to follow instructions from\n[+] https://github.com/ta-lib/ta-lib-python"
+                + colorText.END
+            )
+            pass
+        pass
+else:
+    try:
+        import pandas_ta as talib
+        OutputControls().printOutput(
+            colorText.BOLD
+            + colorText.FAIL
+            + "[+] TA-Lib is not installed. Falling back on pandas_ta.\n[+] For full coverage(candle patterns), you may wish to follow instructions from\n[+] https://github.com/ta-lib/ta-lib-python"
+            + colorText.END
+        )
+        sleep(3)
+    except Exception:  # pragma: no cover
+        # default_logger().debug(e, exc_info=True)
+        import talib
+
+
+class pktalib:
+    @classmethod
+    def BBANDS(self, close, timeperiod,std=2, mamode=0):
+        try:
+            return talib.bbands(close, timeperiod)
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.BBANDS(close, timeperiod, std, std, mamode)
+        
+    @classmethod
+    def EMA(self, close, timeperiod):
+        try:
+            return talib.ema(close, timeperiod)
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.EMA(close, timeperiod)
+
+    @classmethod
+    def KeltnersChannel(self, high, low, close, timeperiod=20):
+        try:
+            low_kel = None
+            upp_kel = None
+            tr = pktalib.TRUERANGE(high, low, close)
+            atr = pktalib.ATR(high, low, close, timeperiod=timeperiod)
+            sma = pktalib.SMA(close=close, timeperiod=timeperiod)
+            low_kel = sma - atr * 1.5
+            upp_kel = sma + atr * 1.5
+            return low_kel, upp_kel
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return low_kel, upp_kel
+        
+    @classmethod
+    def SMA(self, close, timeperiod):
+        try:
+            return talib.sma(close, timeperiod)
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.SMA(close, timeperiod)
+
+    @classmethod
+    def ATR(self, high, low, close, timeperiod=14):
+        try:
+            return talib.atr(high, low, close, length= timeperiod)
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.ATR(high, low, close, timeperiod=timeperiod)
+        
+    @classmethod
+    def TRUERANGE(self, high, low, close):
+        try:
+            return talib.true_range(high, low, close)
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.TRANGE(high, low, close)
+
+    @classmethod
+    def MA(self, close, timeperiod):
+        try:
+            return talib.ma(close, timeperiod)
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.MA(close, timeperiod)
+
+    @classmethod
+    def MACD(self, close, fast, slow, signal):
+        try:
+            # import pandas_ta as talib
+            return talib.macd(close, fast, slow, signal, talib=Imports["talib"])
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.MACD(close, fast, slow, signal)
+
+    @classmethod
+    def MFI(self, high, low, close,volume, timeperiod=14):
+        try:
+            return talib.mfi(high, low, close,volume, length= timeperiod)
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.MFI(high, low, close,volume, timeperiod=timeperiod)
+
+    @classmethod
+    def RSI(self, close, timeperiod):
+        try:
+            return talib.rsi(close, timeperiod)
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.RSI(close, timeperiod)
+
+    @classmethod
+    def CCI(self, high, low, close, timeperiod):
+        try:
+            return talib.cci(high, low, close, timeperiod)
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CCI(high, low, close, timeperiod)
+
+    @classmethod
+    def Aroon(self, high, low, timeperiod):
+        try:
+            return talib.aroon(high, low, timeperiod)
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            aroon_down, aroon_up = talib.AROON(high, low, timeperiod)
+            aroon_up.name = f"AROONU_{timeperiod}"
+            aroon_down.name = f"AROOND_{timeperiod}"
+            data = {
+                aroon_down.name: aroon_down,
+                aroon_up.name: aroon_up,
+            }
+            return pd.DataFrame(data)
+
+    @classmethod
+    def STOCHF(self, high, low, close, fastk_period, fastd_period, fastd_matype):
+        fastk, fastd = talib.STOCHF(high,
+                            low,
+                            close,
+                            fastk_period, 
+                            fastd_period,
+                            fastd_matype)
+        return fastk, fastd
+    
+    @classmethod
+    def STOCHRSI(self, close, timeperiod, fastk_period, fastd_period, fastd_matype):
+        try:
+            _name = "STOCHRSI"
+            _props = f"_{timeperiod}_{timeperiod}_{fastk_period}_{fastd_period}"
+            stochrsi_kname = f"{_name}k{_props}"
+            stochrsi_dname = f"{_name}d{_props}"
+            df = talib.stochrsi(
+                close,
+                length=timeperiod,
+                rsi_length=timeperiod,
+                k=fastk_period,
+                d=fastd_period,
+                mamode=fastd_matype,
+            )
+            return df[stochrsi_kname], df[stochrsi_dname]
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.STOCHRSI(
+                close.values, timeperiod, fastk_period, fastd_period, fastd_matype
+            )
+
+    @classmethod
+    def ichimoku(
+        self, df, tenkan=None, kijun=None, senkou=None, include_chikou=True, offset=None
+    ):
+        import pandas_ta as ta
+
+        ichimokudf, spandf = ta.ichimoku(
+            df["high"], df["low"], df["close"], tenkan, kijun, senkou, False, 26
+        )
+        return ichimokudf
+
+    @classmethod
+    def supertrend(self, df, length=7, multiplier=3):
+        import pandas_ta as ta
+
+        sti = ta.supertrend(
+            df["High"], df["Low"], df["Close"], length=length, multiplier=multiplier
+        )
+        # trend, direction, long, short
+        # SUPERT_7_3.0  SUPERTd_7_3.0  SUPERTl_7_3.0  SUPERTs_7_3.0
+        return sti if sti is not None else {'SUPERT_7_3.0':np.nan}
+
+    @classmethod
+    def psar(self, high, low, acceleration=0.02, maximum=0.2):
+        psar = talib.SAR(high, low, acceleration=acceleration, maximum=maximum)
+        return psar
+
+    @classmethod
+    def CDLMORNINGSTAR(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "morningstar")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLMORNINGSTAR(open, high, low, close)
+
+    @classmethod
+    def CDLMORNINGDOJISTAR(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "morningdojistar")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLMORNINGDOJISTAR(open, high, low, close)
+
+    @classmethod
+    def CDLEVENINGSTAR(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "eveningstar")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLEVENINGSTAR(open, high, low, close)
+
+    @classmethod
+    def CDLEVENINGDOJISTAR(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "eveningdojistar")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLEVENINGDOJISTAR(open, high, low, close)
+
+    @classmethod
+    def CDLLADDERBOTTOM(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "ladderbottom")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLLADDERBOTTOM(open, high, low, close)
+
+    @classmethod
+    def CDL3LINESTRIKE(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "3linestrike")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDL3LINESTRIKE(open, high, low, close)
+
+    @classmethod
+    def CDL3BLACKCROWS(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "3blackcrows")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDL3BLACKCROWS(open, high, low, close)
+
+    @classmethod
+    def CDL3INSIDE(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "3inside")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDL3INSIDE(open, high, low, close)
+
+    @classmethod
+    def CDL3OUTSIDE(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "3outside")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDL3OUTSIDE(open, high, low, close)
+
+    @classmethod
+    def CDL3WHITESOLDIERS(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "3whitesoldiers")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDL3WHITESOLDIERS(open, high, low, close)
+
+    @classmethod
+    def CDLHARAMI(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "harami")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLHARAMI(open, high, low, close)
+
+    @classmethod
+    def CDLHARAMICROSS(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "haramicross")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLHARAMICROSS(open, high, low, close)
+
+    @classmethod
+    def CDLMARUBOZU(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "marubozu")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLMARUBOZU(open, high, low, close)
+
+    @classmethod
+    def CDLHANGINGMAN(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "hangingman")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLHANGINGMAN(open, high, low, close)
+
+    @classmethod
+    def CDLHAMMER(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "hammer")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLHAMMER(open, high, low, close)
+
+    @classmethod
+    def CDLINVERTEDHAMMER(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "invertedhammer")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLINVERTEDHAMMER(open, high, low, close)
+
+    @classmethod
+    def CDLSHOOTINGSTAR(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "shootingstar")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLSHOOTINGSTAR(open, high, low, close)
+
+    @classmethod
+    def CDLDRAGONFLYDOJI(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "dragonflydoji")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLDRAGONFLYDOJI(open, high, low, close)
+
+    @classmethod
+    def CDLGRAVESTONEDOJI(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "gravestonedoji")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLGRAVESTONEDOJI(open, high, low, close)
+
+    @classmethod
+    def CDLDOJI(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "doji")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLDOJI(open, high, low, close)
+
+    @classmethod
+    def CDLENGULFING(self, open, high, low, close):
+        try:
+            return talib.cdl_pattern(open, high, low, close, "engulfing")
+        except Exception:  # pragma: no cover
+            # default_logger().debug(e, exc_info=True)
+            return talib.CDLENGULFING(open, high, low, close)
+
+    @classmethod
+    def argrelextrema(self, data, comparator, axis=0, order=1, mode="clip"):
+        """
+        Calculate the relative extrema of `data`.
+
+        Relative extrema are calculated by finding locations where
+        ``comparator(data[n], data[n+1:n+order+1])`` is True.
+
+        Parameters
+        ----------
+        data : ndarray
+            Array in which to find the relative extrema.
+        comparator : callable
+            Function to use to compare two data points.
+            Should take two arrays as arguments.
+        axis : int, optional
+            Axis over which to select from `data`. Default is 0.
+        order : int, optional
+            How many points on each side to use for the comparison
+            to consider ``comparator(n,n+x)`` to be True.
+        mode : str, optional
+            How the edges of the vector are treated. 'wrap' (wrap around) or
+            'clip' (treat overflow as the same as the last (or first) element).
+            Default 'clip'. See numpy.take.
+
+        Returns
+        -------
+        extrema : ndarray
+            Boolean array of the same shape as `data` that is True at an extrema,
+            False otherwise.
+
+        See also
+        --------
+        argrelmax, argrelmin
+
+        Examples
+        --------
+        >>> import numpy as np
+        >>> testdata = np.array([1,2,3,2,1])
+        >>> _boolrelextrema(testdata, np.greater, axis=0)
+        array([False, False,  True, False, False], dtype=bool)
+
+        """
+        if (int(order) != order) or (order < 1):
+            raise ValueError("Order must be an int >= 1")
+
+        datalen = data.shape[axis]
+        locs = np.arange(0, datalen)
+
+        results = np.ones(data.shape, dtype=bool)
+        main = data.take(locs, axis=axis, mode=mode)
+        for shift in range(1, order + 1):
+            plus = data.take(locs + shift, axis=axis, mode=mode)
+            minus = data.take(locs - shift, axis=axis, mode=mode)
+            results &= comparator(main, plus)
+            results &= comparator(main, minus)
+            if ~results.any():
+                return results
+        return np.nonzero(results)
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Portfolio.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Portfolio.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,301 +1,301 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import pandas as pd
-import numpy as np
-from PKDevTools.classes.PKDateUtilities import PKDateUtilities
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.Singleton import SingletonType, SingletonMixin
-from pkscreener.classes.PKScheduledTaskProgress import PKScheduledTaskProgress
-from pkscreener.classes.PKTask import PKTask
-
-class PortfolioSecurity:
-    def __init__(self, ticker):
-        self.name = ticker
-        self.ltp = 0
-        self.quantity = 0
-        self.date = None
-        self.growth = 0
-    
-    @property
-    def action(self):
-        return (colorText.GREEN + "[Buy]"+ colorText.END) if self.quantity > 0 else ((colorText.FAIL + "[Sell]"+ colorText.END) if self.quantity < 0 else (colorText.WARN + "[Hold]"+ colorText.END))
-    
-    @property
-    def investment(self):
-        return self.ltp * self.quantity
-    
-    @property
-    def description(self):
-        return {"Date": self.date or PKDateUtilities.currentDateTime().strftime("%Y-%m-%d"),
-                "Name": self.name, "LTP": self.ltp, "Quantity": self.quantity, 
-                "Action": self.action, "Investment": self.investment, "RunningTotal": 0, 
-                "Growth": self.growth, "Profits" : 0}
-
-class Portfolio(PKScheduledTaskProgress):
-    def __init__(self, name):
-        super(Portfolio, self).__init__()
-        self.name = name
-        self._initialValue = 0
-        self._currentValue = 0
-        self.ledger = {}
-        self.securities = {}
-    
-    @property
-    def descriptionAsDataframe(self):
-        portfolio_df = None
-        for date, ledgerEntries in self.ledger.items():
-            firstLedgerEntry = ledgerEntries[0]
-            if portfolio_df is None:
-                portfolio_df = pd.DataFrame(ledgerEntries,columns=firstLedgerEntry.keys())
-            else:
-                newEntries_df = pd.DataFrame(ledgerEntries,columns=firstLedgerEntry.keys())
-                portfolio_df = pd.concat([portfolio_df,newEntries_df], axis=0)
-        if portfolio_df is not None:
-            portfolio_df["RunningTotal"] = portfolio_df[['Investment']].cumsum()
-            portfolio_df["Profits"] = portfolio_df[['Growth']].cumsum()
-        return portfolio_df
-    
-    def updatePortfolioFromXRayDataFrame(self,df:pd.DataFrame, periods:list,task:PKTask=None):
-        if task is not None:
-            taskId = task.taskId
-            if taskId > 0:
-                self.tasksDict[taskId] = task
-        xray_df = df.copy()
-        df_grouped = xray_df.groupby("Stock")
-        periodCounter = -1
-        task.progress = 0
-        for period in periods:
-            periodCounter += 1
-            if f"LTP{period}" not in xray_df.columns:
-                continue
-            for stock, df_group in df_grouped:
-                df_group["LTP"] = df_group["LTP"].astype(float).fillna(0)
-                df_group[f"LTP{period}"] = df_group[f"LTP{period}"].astype(float).fillna(0)
-                df_group[f"Growth{period}"] = df_group[f"Growth{period}"].astype(float).fillna(0)
-                if df_group.iloc[0][f"LTP{period}"] == 0 or df_group.iloc[0][f"LTP"] == 0:
-                    continue
-                task.total = len(periods) * len(df_grouped)
-                task.progress += 1
-                self.updateProgress(task.taskId)
-                security = PortfolioSecurity(stock)
-                security.ltp = df_group.iloc[0]["LTP"] if not self.hasSecurity(stock) else df_group.iloc[0][f"LTP{period}"]
-                previousPeriod = periods[periodCounter-1]
-                try:
-                    priceRise = round(df_group.iloc[0][f"LTP{period}"] - df_group.iloc[0]["LTP" if periodCounter == 0 else f"LTP{previousPeriod}"],2)
-                    growth = df_group.iloc[0][f"Growth{period}"]
-                    security.date = df_group.iloc[0]["Date"] if periodCounter == 0 else PKDateUtilities.nextTradingDate(df_group.iloc[0]["Date"], days=period).strftime("%Y-%m-%d")
-                    if self.hasSecurity(stock):
-                        # This security was already added earlier and exists in the portfolio
-                        security.quantity = 1 if priceRise >= 0 else -1
-                        if priceRise < 0:
-                            security.growth = priceRise * abs(security.quantity)
-                            self.removeSecurity(security=security)
-                        else:
-                            security.quantity = 0 # This is not an actual buy
-                            security.growth = priceRise
-                            security.ltp = df_group.iloc[0][f"LTP{period}"]
-                            self.addSecurity(security=security)
-                    else:
-                        # This security was never added earlier. The very fact it exists under this
-                        # outcome dataframe, we need to take losses and then remove it from portfolio
-                        security.quantity = 1
-                        security.growth = 0 # First day of trade
-                        security.date = df_group.iloc[0]["Date"]
-                        security.ltp = df_group.iloc[0]["LTP"]
-                        self.addSecurity(security=security)
-                        if priceRise < 0:
-                            security.date = PKDateUtilities.nextTradingDate(df_group.iloc[0]["Date"], days=period).strftime("%Y-%m-%d")
-                            security.ltp = df_group.iloc[0][f"LTP{period}"]
-                            security.quantity = -1
-                            security.growth = priceRise * abs(security.quantity)
-                            self.removeSecurity(security=security)
-                except:
-                    pass
-                    continue
-        task.progress = task.total
-        self.updateProgress(task.taskId)
-
-    @property
-    def profit(self):
-        sorted_ledger_dates = sorted(self.ledger.items(), key=lambda kv: kv[0])
-        bought = 0
-        sold = 0
-        for date, ledgerEntries in sorted_ledger_dates:
-            for securityDict in ledgerEntries:
-                if securityDict["Quantity"] > 0 and date == securityDict["Date"]:
-                    bought += securityDict["LTP"] * securityDict["Quantity"]
-                elif securityDict["Quantity"] < 0 and date == securityDict["Date"]:
-                    sold += securityDict["LTP"] * securityDict["Quantity"]
-        return round(abs(sold) - bought,2) if (sold != 0 and bought != 0) else 0
-        
-    @property
-    def initialValue(self):
-        if self._initialValue != 0:
-            return self._initialValue
-        sorted_ledger_dates = sorted(self.ledger.items(), key=lambda kv: kv[0])
-        initialLedgerEntries = sorted_ledger_dates[1][0]
-        initialValue = 0
-        for securityDict in initialLedgerEntries:
-            initialValue += securityDict["LTP"] * securityDict["Quantity"]
-        self._initialValue = initialValue
-        return initialValue
-
-    @property
-    def currentValue(self):
-        if self._currentValue != 0:
-            return round(self._currentValue,2)
-        sorted_ledger_dates = sorted(self.ledger.items(), key=lambda kv: kv[0])
-        currentValue = 0
-        for date,ledgerEntries in sorted_ledger_dates:
-            for securityDict in ledgerEntries:
-                currentValue += securityDict["LTP"] * securityDict["Quantity"]
-        self._currentValue = currentValue
-        return currentValue
-    
-    @currentValue.setter
-    def currentValue(self, newValue):
-        self._currentValue = newValue
-        
-    def hasSecurity(self, securityName:str):
-        return securityName in self.securities.keys()
-    
-    def addSecurity(self, security:PortfolioSecurity=None):
-        self.securities[security.name] = security
-        self.currentValue += security.ltp*security.quantity
-        self.updateLedger(security=security)
-
-    def removeSecurity(self, security:PortfolioSecurity=None):
-        del self.securities[security.name]
-        self.currentValue -= security.ltp*security.quantity
-        self.updateLedger(security=security)
-
-    def updateLedger(self,security:PortfolioSecurity=None):
-        ledgerEntries = self.ledger.get(security.date) or []
-        runningLedger = {"ScanType": self.name, "Date": security.date} | security.description
-        ledgerEntries.append(runningLedger)
-        self.ledger[security.date] = ledgerEntries
-
-    def getDifference(self,x):
-        return x.iloc[-1] - x.iloc[0]
-
-    def differenceFromLastNTradingSession(self,df,n=1):
-        df['LTP'].rolling(window=n).apply(self.getDifference)
-
-
-class PortfolioCollection(SingletonMixin,PKScheduledTaskProgress, metaclass=SingletonType):
-    def __init__(self):
-        super(PortfolioCollection, self).__init__()
-        self._portfolios = {}
-        self._portfolios_df = None
-        self._portfoliosSummary_df = None
-        self.ledgerSummaryAsDataframeTaskId = 0
-        self.portfoliosAsDataframeTaskId = 0
-
-    def getLedgerSummaryAsDataframe(self,*args):
-        task = args[0]
-        taskId = task.taskId
-        if taskId > 0:
-            self.tasksDict[taskId] = task
-            self.ledgerSummaryAsDataframeTaskId = taskId
-        return self.ledgerSummaryAsDataframe
-    
-    def getPortfoliosAsDataframe(self,*args):
-        task = args[0]
-        taskId = task.taskId
-        if taskId > 0:
-            self.tasksDict[taskId] = task
-            self.portfoliosAsDataframeTaskId = taskId
-        return self.portfoliosAsDataframe
-    
-    @property
-    def ledgerSummaryAsDataframe(self):
-        task = None
-        if self._portfoliosSummary_df is not None:
-            if self.ledgerSummaryAsDataframeTaskId > 0:
-                task = self.tasksDict.get(self.ledgerSummaryAsDataframeTaskId)
-                task.total = len(self._portfolios.keys())
-                task.progress = task.total
-                self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
-                task.result = self._portfoliosSummary_df
-                task.resultsDict[task.taskId] = self._portfoliosSummary_df
-            return self._portfoliosSummary_df
-        portfolios_df = None
-        if len(self._portfolios) > 0:
-            for _, portfolio in self._portfolios.items():
-                portfolio_df = portfolio.descriptionAsDataframe
-                if portfolio_df is None:
-                    continue
-                if portfolios_df is None:
-                    portfolios_df = portfolio_df.tail(5).copy()
-                else:
-                    portfolios_df = pd.concat([portfolios_df,portfolio_df.tail(5)], axis=0)
-                if task is not None:
-                    task.progress = len(portfolios_df)
-                self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
-        self._portfoliosSummary_df = portfolios_df
-        if task is not None:
-            # Mark the progress finished
-            task.progress = task.total
-            self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
-            task.result = portfolios_df
-            task.resultsDict[task.taskId] = self.portfolios_df
-        return portfolios_df
-        
-    @property
-    def portfoliosAsDataframe(self):
-        task = None
-        if self._portfolios_df is not None:
-            if self.portfoliosAsDataframeTaskId > 0:
-                task = self.tasksDict.get(self.portfoliosAsDataframeTaskId)
-                task.total = len(self._portfolios.keys())
-                task.progress = task.total
-                self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
-                task.result = self._portfolios_df
-                task.resultsDict[task.taskId] = self._portfolios_df
-            return self._portfolios_df
-        portfolios_df = None
-        if len(self._portfolios) > 0:
-            for _, portfolio in self._portfolios.items():
-                portfolio_df = portfolio.descriptionAsDataframe
-                if portfolio_df is None:
-                    continue
-                if portfolios_df is None:
-                    portfolios_df = portfolio_df.copy()
-                else:
-                    portfolios_df = pd.concat([portfolios_df,portfolio_df], axis=0)
-                if task is not None:
-                    task.progress = len(portfolios_df)
-                self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
-        self._portfolios_df = portfolios_df
-        if task is not None:
-            # Mark the progress finished
-            task.progress = task.total
-            self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
-            task.result = portfolios_df
-            task.resultsDict[task.taskId] = self.portfolios_df
-        return portfolios_df
-
-    def addPortfolio(self,portfolio:Portfolio):
-        self._portfolios[portfolio.name] = portfolio
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import pandas as pd
+import numpy as np
+from PKDevTools.classes.PKDateUtilities import PKDateUtilities
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.Singleton import SingletonType, SingletonMixin
+from pkscreener.classes.PKScheduledTaskProgress import PKScheduledTaskProgress
+from pkscreener.classes.PKTask import PKTask
+
+class PortfolioSecurity:
+    def __init__(self, ticker):
+        self.name = ticker
+        self.ltp = 0
+        self.quantity = 0
+        self.date = None
+        self.growth = 0
+    
+    @property
+    def action(self):
+        return (colorText.GREEN + "[Buy]"+ colorText.END) if self.quantity > 0 else ((colorText.FAIL + "[Sell]"+ colorText.END) if self.quantity < 0 else (colorText.WARN + "[Hold]"+ colorText.END))
+    
+    @property
+    def investment(self):
+        return self.ltp * self.quantity
+    
+    @property
+    def description(self):
+        return {"Date": self.date or PKDateUtilities.currentDateTime().strftime("%Y-%m-%d"),
+                "Name": self.name, "LTP": self.ltp, "Quantity": self.quantity, 
+                "Action": self.action, "Investment": self.investment, "RunningTotal": 0, 
+                "Growth": self.growth, "Profits" : 0}
+
+class Portfolio(PKScheduledTaskProgress):
+    def __init__(self, name):
+        super(Portfolio, self).__init__()
+        self.name = name
+        self._initialValue = 0
+        self._currentValue = 0
+        self.ledger = {}
+        self.securities = {}
+    
+    @property
+    def descriptionAsDataframe(self):
+        portfolio_df = None
+        for date, ledgerEntries in self.ledger.items():
+            firstLedgerEntry = ledgerEntries[0]
+            if portfolio_df is None:
+                portfolio_df = pd.DataFrame(ledgerEntries,columns=firstLedgerEntry.keys())
+            else:
+                newEntries_df = pd.DataFrame(ledgerEntries,columns=firstLedgerEntry.keys())
+                portfolio_df = pd.concat([portfolio_df,newEntries_df], axis=0)
+        if portfolio_df is not None:
+            portfolio_df["RunningTotal"] = portfolio_df[['Investment']].cumsum()
+            portfolio_df["Profits"] = portfolio_df[['Growth']].cumsum()
+        return portfolio_df
+    
+    def updatePortfolioFromXRayDataFrame(self,df:pd.DataFrame, periods:list,task:PKTask=None):
+        if task is not None:
+            taskId = task.taskId
+            if taskId > 0:
+                self.tasksDict[taskId] = task
+        xray_df = df.copy()
+        df_grouped = xray_df.groupby("Stock")
+        periodCounter = -1
+        task.progress = 0
+        for period in periods:
+            periodCounter += 1
+            if f"LTP{period}" not in xray_df.columns:
+                continue
+            for stock, df_group in df_grouped:
+                df_group["LTP"] = df_group["LTP"].astype(float).fillna(0)
+                df_group[f"LTP{period}"] = df_group[f"LTP{period}"].astype(float).fillna(0)
+                df_group[f"Growth{period}"] = df_group[f"Growth{period}"].astype(float).fillna(0)
+                if df_group.iloc[0][f"LTP{period}"] == 0 or df_group.iloc[0][f"LTP"] == 0:
+                    continue
+                task.total = len(periods) * len(df_grouped)
+                task.progress += 1
+                self.updateProgress(task.taskId)
+                security = PortfolioSecurity(stock)
+                security.ltp = df_group.iloc[0]["LTP"] if not self.hasSecurity(stock) else df_group.iloc[0][f"LTP{period}"]
+                previousPeriod = periods[periodCounter-1]
+                try:
+                    priceRise = round(df_group.iloc[0][f"LTP{period}"] - df_group.iloc[0]["LTP" if periodCounter == 0 else f"LTP{previousPeriod}"],2)
+                    growth = df_group.iloc[0][f"Growth{period}"]
+                    security.date = df_group.iloc[0]["Date"] if periodCounter == 0 else PKDateUtilities.nextTradingDate(df_group.iloc[0]["Date"], days=period).strftime("%Y-%m-%d")
+                    if self.hasSecurity(stock):
+                        # This security was already added earlier and exists in the portfolio
+                        security.quantity = 1 if priceRise >= 0 else -1
+                        if priceRise < 0:
+                            security.growth = priceRise * abs(security.quantity)
+                            self.removeSecurity(security=security)
+                        else:
+                            security.quantity = 0 # This is not an actual buy
+                            security.growth = priceRise
+                            security.ltp = df_group.iloc[0][f"LTP{period}"]
+                            self.addSecurity(security=security)
+                    else:
+                        # This security was never added earlier. The very fact it exists under this
+                        # outcome dataframe, we need to take losses and then remove it from portfolio
+                        security.quantity = 1
+                        security.growth = 0 # First day of trade
+                        security.date = df_group.iloc[0]["Date"]
+                        security.ltp = df_group.iloc[0]["LTP"]
+                        self.addSecurity(security=security)
+                        if priceRise < 0:
+                            security.date = PKDateUtilities.nextTradingDate(df_group.iloc[0]["Date"], days=period).strftime("%Y-%m-%d")
+                            security.ltp = df_group.iloc[0][f"LTP{period}"]
+                            security.quantity = -1
+                            security.growth = priceRise * abs(security.quantity)
+                            self.removeSecurity(security=security)
+                except:
+                    pass
+                    continue
+        task.progress = task.total
+        self.updateProgress(task.taskId)
+
+    @property
+    def profit(self):
+        sorted_ledger_dates = sorted(self.ledger.items(), key=lambda kv: kv[0])
+        bought = 0
+        sold = 0
+        for date, ledgerEntries in sorted_ledger_dates:
+            for securityDict in ledgerEntries:
+                if securityDict["Quantity"] > 0 and date == securityDict["Date"]:
+                    bought += securityDict["LTP"] * securityDict["Quantity"]
+                elif securityDict["Quantity"] < 0 and date == securityDict["Date"]:
+                    sold += securityDict["LTP"] * securityDict["Quantity"]
+        return round(abs(sold) - bought,2) if (sold != 0 and bought != 0) else 0
+        
+    @property
+    def initialValue(self):
+        if self._initialValue != 0:
+            return self._initialValue
+        sorted_ledger_dates = sorted(self.ledger.items(), key=lambda kv: kv[0])
+        initialLedgerEntries = sorted_ledger_dates[1][0]
+        initialValue = 0
+        for securityDict in initialLedgerEntries:
+            initialValue += securityDict["LTP"] * securityDict["Quantity"]
+        self._initialValue = initialValue
+        return initialValue
+
+    @property
+    def currentValue(self):
+        if self._currentValue != 0:
+            return round(self._currentValue,2)
+        sorted_ledger_dates = sorted(self.ledger.items(), key=lambda kv: kv[0])
+        currentValue = 0
+        for date,ledgerEntries in sorted_ledger_dates:
+            for securityDict in ledgerEntries:
+                currentValue += securityDict["LTP"] * securityDict["Quantity"]
+        self._currentValue = currentValue
+        return currentValue
+    
+    @currentValue.setter
+    def currentValue(self, newValue):
+        self._currentValue = newValue
+        
+    def hasSecurity(self, securityName:str):
+        return securityName in self.securities.keys()
+    
+    def addSecurity(self, security:PortfolioSecurity=None):
+        self.securities[security.name] = security
+        self.currentValue += security.ltp*security.quantity
+        self.updateLedger(security=security)
+
+    def removeSecurity(self, security:PortfolioSecurity=None):
+        del self.securities[security.name]
+        self.currentValue -= security.ltp*security.quantity
+        self.updateLedger(security=security)
+
+    def updateLedger(self,security:PortfolioSecurity=None):
+        ledgerEntries = self.ledger.get(security.date) or []
+        runningLedger = {"ScanType": self.name, "Date": security.date} | security.description
+        ledgerEntries.append(runningLedger)
+        self.ledger[security.date] = ledgerEntries
+
+    def getDifference(self,x):
+        return x.iloc[-1] - x.iloc[0]
+
+    def differenceFromLastNTradingSession(self,df,n=1):
+        df['LTP'].rolling(window=n).apply(self.getDifference)
+
+
+class PortfolioCollection(SingletonMixin,PKScheduledTaskProgress, metaclass=SingletonType):
+    def __init__(self):
+        super(PortfolioCollection, self).__init__()
+        self._portfolios = {}
+        self._portfolios_df = None
+        self._portfoliosSummary_df = None
+        self.ledgerSummaryAsDataframeTaskId = 0
+        self.portfoliosAsDataframeTaskId = 0
+
+    def getLedgerSummaryAsDataframe(self,*args):
+        task = args[0]
+        taskId = task.taskId
+        if taskId > 0:
+            self.tasksDict[taskId] = task
+            self.ledgerSummaryAsDataframeTaskId = taskId
+        return self.ledgerSummaryAsDataframe
+    
+    def getPortfoliosAsDataframe(self,*args):
+        task = args[0]
+        taskId = task.taskId
+        if taskId > 0:
+            self.tasksDict[taskId] = task
+            self.portfoliosAsDataframeTaskId = taskId
+        return self.portfoliosAsDataframe
+    
+    @property
+    def ledgerSummaryAsDataframe(self):
+        task = None
+        if self._portfoliosSummary_df is not None:
+            if self.ledgerSummaryAsDataframeTaskId > 0:
+                task = self.tasksDict.get(self.ledgerSummaryAsDataframeTaskId)
+                task.total = len(self._portfolios.keys())
+                task.progress = task.total
+                self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
+                task.result = self._portfoliosSummary_df
+                task.resultsDict[task.taskId] = self._portfoliosSummary_df
+            return self._portfoliosSummary_df
+        portfolios_df = None
+        if len(self._portfolios) > 0:
+            for _, portfolio in self._portfolios.items():
+                portfolio_df = portfolio.descriptionAsDataframe
+                if portfolio_df is None:
+                    continue
+                if portfolios_df is None:
+                    portfolios_df = portfolio_df.tail(5).copy()
+                else:
+                    portfolios_df = pd.concat([portfolios_df,portfolio_df.tail(5)], axis=0)
+                if task is not None:
+                    task.progress = len(portfolios_df)
+                self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
+        self._portfoliosSummary_df = portfolios_df
+        if task is not None:
+            # Mark the progress finished
+            task.progress = task.total
+            self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
+            task.result = portfolios_df
+            task.resultsDict[task.taskId] = self.portfolios_df
+        return portfolios_df
+        
+    @property
+    def portfoliosAsDataframe(self):
+        task = None
+        if self._portfolios_df is not None:
+            if self.portfoliosAsDataframeTaskId > 0:
+                task = self.tasksDict.get(self.portfoliosAsDataframeTaskId)
+                task.total = len(self._portfolios.keys())
+                task.progress = task.total
+                self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
+                task.result = self._portfolios_df
+                task.resultsDict[task.taskId] = self._portfolios_df
+            return self._portfolios_df
+        portfolios_df = None
+        if len(self._portfolios) > 0:
+            for _, portfolio in self._portfolios.items():
+                portfolio_df = portfolio.descriptionAsDataframe
+                if portfolio_df is None:
+                    continue
+                if portfolios_df is None:
+                    portfolios_df = portfolio_df.copy()
+                else:
+                    portfolios_df = pd.concat([portfolios_df,portfolio_df], axis=0)
+                if task is not None:
+                    task.progress = len(portfolios_df)
+                self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
+        self._portfolios_df = portfolios_df
+        if task is not None:
+            # Mark the progress finished
+            task.progress = task.total
+            self.updateProgress(self.ledgerSummaryAsDataframeTaskId)
+            task.result = portfolios_df
+            task.resultsDict[task.taskId] = self.portfolios_df
+        return portfolios_df
+
+    def addPortfolio(self,portfolio:Portfolio):
+        self._portfolios[portfolio.name] = portfolio
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PortfolioXRay.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PortfolioXRay.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,1265 +1,1265 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import os
-import sys
-import numpy as np
-import pandas as pd
-from argparse import Namespace
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.PKDateUtilities import PKDateUtilities
-from pkscreener.classes import Utility
-from PKDevTools.classes.log import default_logger
-from pkscreener.classes.ConfigManager import parser, tools
-from pkscreener.classes.Portfolio import Portfolio, PortfolioCollection
-from pkscreener.classes.PKTask import PKTask
-from pkscreener.classes.PKScheduler import PKScheduler
-from PKDevTools.classes.OutputControls import OutputControls
-
-configManager = tools()
-configManager.getConfig(parser)
-
-def summariseAllStrategies(testing=False):
-    reports = getSavedBacktestReportNames(testing=testing)
-    df_all = None
-    counter = 0
-    for report in reports:
-        counter += 1
-        OutputControls().printOutput(f"Processing {counter} of {len(reports)}...")
-        df = bestStrategiesFromSummaryForReport(
-            f"PKScreener_{report}_Insights_DateSorted.html", summary=True,includeLargestDatasets=True
-        )
-        if df is not None:
-            df.insert(loc=0, column="Scanner", value=report)
-            if df_all is not None:
-                df_all = pd.concat([df_all, df], axis=0)
-            else:
-                df_all = df
-        sys.stdout.write("\x1b[1A")
-    if df_all is not None:
-        df_all = df_all.replace(np.nan, "-", regex=True)
-    return df_all
-
-def getSavedBacktestReportNames(testing=False):
-    indices = [1,5,8,11,12,14] if not testing else [1]
-    scanSkipIndices = [21, 22] if not testing else [1,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
-    indexWithSubindices = [6, 7] if not testing else [6]
-    subIndices = {6: [1, 2, 3, 4, 5, 6, 7], 7: [1, 2, 3, 4, 5, 6, 7]} if not testing else {6: [7]}
-    indexWithSubLevelindices = {6:[7],7:[6]}
-    subLevelIndices = {7: [1, 2, 3], 6: [1, 2, 3]} if not testing else {7: [1]}
-    reports = []
-    for index in indices:
-        scanTypeStartIndex = 1
-        scanTypeEndIndex = 25
-        reportName = f"B_{index}_"
-        while scanTypeStartIndex <= scanTypeEndIndex:
-            if scanTypeStartIndex not in scanSkipIndices:
-                reportName = f"{reportName}{scanTypeStartIndex}"
-                if scanTypeStartIndex in indexWithSubindices:
-                    for subIndex in subIndices[scanTypeStartIndex]:
-                        subReportName = f"{reportName}_{subIndex}"
-                        if subIndex in indexWithSubLevelindices[scanTypeStartIndex]:
-                            for subLevelIndex in subLevelIndices[subIndex]:
-                                subLevelReportName = f"{subReportName}_{subLevelIndex}"
-                                reports.append(subLevelReportName)
-                        else:
-                            reports.append(subReportName)
-                else:
-                    reports.append(reportName)
-            reportName = f"B_{index}_"
-            scanTypeStartIndex += 1
-    return reports
-
-
-def bestStrategiesFromSummaryForReport(reportName: None, summary=False,includeLargestDatasets=False):
-    dfs = []
-    insights = None
-    if "PKDevTools_Default_Log_Level" not in os.environ.keys():
-        if (("RUNNER" not in os.environ.keys())):
-            return None
-    if not configManager.showPastStrategyData:
-        return None
-    try:
-        dfs = pd.read_html(
-            "https://pkjmesra.github.io/PKScreener/Backtest-Reports/{0}".format(
-                reportName.replace("_X_", "_B_").replace("_G_", "_B_").replace("_S_", "_B_")
-            ),encoding="UTF-8", attrs = {'id': 'resultsTable'}
-        )
-    except Exception as e: # pragma: no cover
-        pass
-    if dfs is not None and len(dfs) > 0:
-        df = dfs[0]
-        if len(df) > 0:
-            periods = configManager.periodsRange
-            insights = cleanupInsightsSummary(df, periods)
-            # insights = insights.replace('', np.nan, regex=True)
-            # insights = insights.replace('-', np.nan, regex=True)
-            dfs = []
-            max_best_df = insights.copy()
-            max_datasets_df = insights.copy()
-            if includeLargestDatasets:
-                addLargeDatasetInsights(dfs, max_datasets_df)
-            
-            insights_list = []
-            dfs.append(max_best_df)
-            getMaxBestInsight(summary, dfs, periods, insights_list)
-            insights = pd.DataFrame(insights_list).drop_duplicates(ignore_index=True)
-            insights.dropna(axis=0, how="all", inplace=True)
-            insights = insights.replace(np.nan, "-", regex=True)
-    return insights
-
-def cleanupInsightsSummary(df, periods):
-    df = df.replace(" %", "", regex=True)
-    df = df.replace("-", np.nan, regex=True)
-    for period in periods:
-        df.rename(
-                    columns={
-                        f"{period}D-%": f"{period}Pd-%",
-                        f"{period}D-10k": f"{period}Pd-10k",
-                    },
-                    inplace=True,
-                )
-        castToFloat(df, period)
-    insights = df[df["ScanType"].astype(str).str.startswith("[SUM]")]
-    return insights
-
-def getMaxBestInsight(summary, dfs, periods, insights_list):
-    for dfInsights in dfs:
-        df = dfInsights.copy()
-        df.reset_index(drop = True, inplace=True)
-        strategy_percent = {}
-        strategy = {}
-        firstPeriod = True
-        rowIndex = 0
-        for prd in periods:
-            rowIndex += 1
-            try:
-                max_p = df[f"{prd}Pd-%"].max()
-                maxIndexPos = df[f"{prd}Pd-%"].idxmax()
-                bestScanFilter = str(
-                            df["ScanType"].iloc[maxIndexPos]).replace("[SUM]", "")
-                resultPoints = bestScanFilter.split("(")[-1]
-                strategy_percent[f"{prd}-Pd"] = f"{colorText.GREEN if max_p > 0 else (colorText.FAIL if max_p < 0 else colorText.WARN)}{max_p} %{colorText.END}{(' from ('+resultPoints) if (summary or firstPeriod) else ''}"
-                scanType = (bestScanFilter.split("(")[0] if not summary else bestScanFilter)
-                strategy[f"{prd}-Pd"] = scanType
-            except KeyError:
-                    max_p = df[rowIndex*2]
-                    bestScanFilter = str(df[0]).replace("[SUM]", "")
-                    resultPoints = bestScanFilter.split("(")[-1]
-                    strategy_percent[f"{prd}-Pd"] = f"{colorText.GREEN if max_p > 0 else (colorText.FAIL if max_p < 0 else colorText.WARN)}{max_p} %{colorText.END}{(' from ('+resultPoints) if (summary or firstPeriod) else ''}"
-                    scanType = (bestScanFilter.split("(")[0] if not summary else bestScanFilter)
-                    strategy[f"{prd}-Pd"] = scanType
-            except Exception:# pragma: no cover
-                # default_logger().debug(e, exc_info=True)
-                try:
-                    max_p = df[f"{prd}Pd-%"]
-                    bestScanFilter = str(df["ScanType"]).replace("[SUM]", "")
-                    resultPoints = bestScanFilter.split("(")[-1]
-                    strategy_percent[f"{prd}-Pd"] = f"{colorText.GREEN if max_p > 0 else (colorText.FAIL if max_p < 0 else colorText.WARN)}{max_p} %{colorText.END}{(' from ('+resultPoints) if (summary or firstPeriod) else ''}"
-                    scanType = (bestScanFilter.split("(")[0] if not summary else bestScanFilter)
-                    strategy[f"{prd}-Pd"] = scanType
-                except Exception as e:# pragma: no cover
-                    default_logger().debug(e, exc_info=True)
-                    pass
-                pass
-            if summary:
-                strategy[f"{prd}-Pd"] = strategy_percent[f"{prd}-Pd"].split("from")[0] + " " + strategy[f"{prd}-Pd"]
-            firstPeriod = False
-        insights_list.extend([strategy] if summary else [strategy, strategy_percent])
-
-def addLargeDatasetInsights(dfs, max_datasets_df):
-    max_datasets_df[["ScanTypeSplit", "DatasetSize"]] = max_datasets_df[
-                    "ScanType"
-                ].str.split("(", n=1, expand=True)
-    max_datasets_df["DatasetSize"] = max_datasets_df["DatasetSize"].str.replace(")", "")
-    try:
-        max_datasets_df["DatasetSize"] = (max_datasets_df["DatasetSize"].astype(float).fillna(0.0))
-    except Exception as e:# pragma: no cover
-        default_logger().debug(e, exc_info=True)
-        max_datasets_df.loc[:, "DatasetSize"] = max_datasets_df.loc[:, "DatasetSize"].apply(
-                        lambda x: x.split("(")[-1]
-                    )
-        max_datasets_df["DatasetSize"] = (max_datasets_df["DatasetSize"].astype(float).fillna(0.0))
-        pass
-    max_size = max_datasets_df["DatasetSize"].max()
-    max_datasets_df = max_datasets_df[(max_datasets_df["DatasetSize"] == max_size)].fillna(0.0)
-    for i in range(0, len(max_datasets_df)):
-        dfs.append(max_datasets_df.iloc[i])
-
-def castToFloat(df, prd):
-    if f"{prd}Pd-%" in df.columns:
-        df[f"{prd}Pd-%"] = (df[f"{prd}Pd-%"].astype(float).fillna(0.0))
-
-
-def xRaySummary(savedResults=None):
-    if savedResults is None or not isinstance(savedResults, pd.DataFrame) or savedResults.empty:
-        return savedResults
-    saveResults = savedResults.copy()
-    df_grouped = saveResults.groupby("ScanType")
-    periods = configManager.periodsRange
-    sum_list = []
-    sum_dict = {}
-    maxGrowth = -100
-    for scanType, df_group in df_grouped:
-        groupItems = len(df_group)
-        sum_dict = {}
-        sum_dict["ScanType"] = f"[SUM]{scanType.replace('(','[').replace(')',']')}  ({groupItems})"
-        sum_dict["Date"] = PKDateUtilities.currentDateTime().strftime("%Y-%m-%d")
-        for prd in periods:
-            if not f"{prd}Pd-%" in df_group.columns:
-                continue
-            prd_df = df_group[[f"{prd}Pd-%", f"{prd}Pd-10k"]]
-            prd_df.loc[:, f"{prd}Pd-10k"] = prd_df.loc[:, f"{prd}Pd-10k"].apply(
-                lambda x: Utility.tools.removeAllColorStyles(x)
-            )
-            prd_df = prd_df.replace("-", np.nan, regex=True)
-            prd_df = prd_df.replace("", np.nan, regex=True)
-            prd_df.dropna(axis=0, how="all", inplace=True)
-            prd_df[f"{prd}Pd-10k"] = prd_df[f"{prd}Pd-10k"].astype(float).fillna(0.0)
-            gain = round(
-                (prd_df[f"{prd}Pd-10k"].sum() - 10000 * len(prd_df))
-                * 100
-                / (10000 * len(prd_df)),
-                2,
-            )
-            sum_dict[f"{prd}Pd-%"] = gain
-            sum_dict[f"{prd}Pd-10k"] = round(
-                prd_df[f"{prd}Pd-10k"].sum() / len(prd_df), 2
-            )
-        sum_list.append(sum_dict)
-    df = pd.DataFrame(sum_list)
-    df = formatGridOutput(df, replacenan=False)
-    saveResults = pd.concat([saveResults, df], axis=0)
-    saveResults = saveResults.replace(np.nan, "-", regex=True)
-    return saveResults
-
-
-def performXRay(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        savedResults, userArgs, calcForDate, progressLabel = task.long_running_fn_args
-    else:
-        savedResults, userArgs, calcForDate, progressLabel = args[0],args[1],args[2],args[3]
-    df = None
-    if savedResults is not None and len(savedResults) > 0:
-        backtestPeriods = getbacktestPeriod(userArgs)
-        saveResults = cleanupData(savedResults)
-
-        days = 0
-        periods = configManager.periodsRange
-        # period = periods[days]
-        # requiredPeriods = []
-        # If the calcForDate is more than the backtestPeriods, we should be able to 
-        # still calculate the backtested returns for all 30 periods or periods more than
-        # the requested backtestPeriods
-        # backtestPeriods = getUpdatedBacktestPeriod(calcForDate, backtestPeriods, saveResults)
-        # while periods[days] <= backtestPeriods:
-        #     period = periods[days]
-        #     requiredPeriods.append(period)
-        #     days += 1
-        #     if days >= len(periods):
-        #         break
-        df = getBacktestDataFromCleanedData(userArgs, saveResults, df, periods,progressLabel)
-        if df is None:
-            return None
-        df = cleanFormattingForStatsData(calcForDate, saveResults, df)
-        # OutputControls().printOutput(f"All portfolios:\n{PortfolioCollection().portfoliosAsDataframe}")
-        # OutputControls().printOutput(f"All portfoliosSummary:\n{PortfolioCollection().ledgerSummaryAsDataframe}")
-    if task is not None:
-        if task.taskId > 0:
-            task.progressStatusDict[task.taskId] = {'progress': 0, 'total': 1}
-            task.resultsDict[task.taskId] = df
-        else:
-            task.result = df
-    return df
-
-def getUpdatedBacktestPeriod(calcForDate, backtestPeriods, saveResults):
-    targetDate = (
-            calcForDate if calcForDate is not None else saveResults["Date"].iloc[0]
-        )
-    today = PKDateUtilities.currentDateTime()
-    gap = PKDateUtilities.trading_days_between(
-            PKDateUtilities.dateFromYmdString(targetDate)
-            .replace(tzinfo=today.tzinfo)
-            .date(),
-            today.date(),
-        )
-    backtestPeriods = gap if gap > backtestPeriods else backtestPeriods
-    return backtestPeriods if backtestPeriods <= configManager.maxBacktestWindow else configManager.maxBacktestWindow
-
-def cleanFormattingForStatsData(calcForDate, saveResults, df):
-    if df is None or not isinstance(df, pd.DataFrame) or df.empty \
-        or saveResults is None or not isinstance(saveResults, pd.DataFrame) or saveResults.empty:
-        return df
-    df = df[
-            [
-                col
-                for col in df.columns
-                if ("ScanType" in col or "Pd-%" in col or "Pd-10k" in col)
-            ]
-        ]
-    df = df.replace(999999999, np.nan, regex=True)
-    df.dropna(axis=0, how="all", inplace=True)
-    df = formatGridOutput(df)
-    df.insert(
-            1,
-            "Date",
-            calcForDate if calcForDate is not None else saveResults["Date"].iloc[0],
-        )
-    
-    return df
-
-def getBacktestDataFromCleanedData(args, saveResults, df, periods,progressLabel:str=None):
-    '''
-    Important
-    ---------
-    You should have called `cleanupData` before calling this.
-    '''
-    for period in periods:
-        saveResults[f"LTP{period}"] = (
-                    saveResults[f"LTP{period}"].astype(float).fillna(0.0)
-                )
-        saveResults[f"Growth{period}"] = (
-                    saveResults[f"Growth{period}"].astype(float).fillna(0.0)
-                )
-
-    scanResults = statScanCalculations(args, saveResults, periods,progressLabel)
-
-    if df is None:
-        df = pd.DataFrame(scanResults)
-    else:
-        df1 = pd.DataFrame(scanResults)
-        df_target = df1[
-                    [col for col in df1.columns if ("Pd-%" in col or "Pd-10k" in col)]
-                ]
-        df = pd.concat([df, df_target], axis=1)
-    return df
-
-def statScanCalculationForNoFilter(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        userArgs, saveResults, period, scanResults = task.long_running_fn_args
-    else:
-        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
-    scanResults.append(
-                getCalculatedValues(saveResults, period, "NoFilter", userArgs,task)
-            )
-    if task is not None:
-        if task.taskId > 0:
-            task.resultsDict[task.taskId] = scanResults
-            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
-        else:
-            task.result = scanResults
-    return scanResults
-
-def statScanCalculationForPatterns(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        userArgs, saveResults, period, scanResults = task.long_running_fn_args
-    else:
-        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
-    df_grouped = saveResults.groupby("Pattern")
-    for pattern, df_group in df_grouped:
-        if pattern is None or len(pattern) == 0:
-            pattern = "No Pattern"
-        scanResults.append(
-                    getCalculatedValues(df_group, period, f"[P]{pattern}", userArgs,task)
-                )
-    if task is not None:
-        if task.taskId > 0:
-            task.resultsDict[task.taskId] = scanResults
-            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
-        else:
-            task.result = scanResults
-    return scanResults
-
-def ensureColumnsExist(saveResults):
-    columns = ['Stock', 'Date', 'Volume', 'Trend', 'MA-Signal', 'LTP', '52Wk H',
-               '52Wk L', '1-Pd', '2-Pd', '3-Pd', '4-Pd', '5-Pd', '10-Pd', '15-Pd',
-               '22-Pd', '30-Pd', 'Consol.', 'Breakout', 'RSI', 'Pattern', 'CCI',
-               'LTP1', 'Growth1', 'LTP2', 'Growth2', 'LTP3', 'Growth3', 'LTP4',
-               'Growth4', 'LTP5', 'Growth5', 'LTP10', 'Growth10', 'LTP15', 'Growth15',
-               'LTP22', 'Growth22', 'LTP30', 'Growth30']
-    if saveResults is None:
-        saveResults = pd.DataFrame(columns=columns)
-    else:
-        for col in columns:
-            if col not in saveResults.columns:
-                saveResults[col] = ""
-    return saveResults
-
-def cleanupData(savedResults):
-    saveResults = savedResults.copy()
-    saveResults = ensureColumnsExist(saveResults)
-    for col in saveResults.columns:
-        saveResults.loc[:, col] = saveResults.loc[:, col].apply(
-                lambda x: Utility.tools.removeAllColorStyles(x)
-            )
-
-    saveResults["LTP"] = saveResults["LTP"].astype(float).fillna(0.0)
-    saveResults["RSI"] = saveResults["RSI"].astype(float).fillna(0.0)
-    saveResults.loc[:, "Volume"] = saveResults.loc[:, "Volume"].apply(
-            lambda x: x.replace("x", "")
-        )
-    if f"Trend({configManager.daysToLookback}Prds)" not in saveResults.columns:
-        saveResults.rename(
-                columns={
-                    # "Consol.": f"Consol.({configManager.daysToLookback}Prds)",
-                    "Trend": f"Trend({configManager.daysToLookback}Prds)",
-                    "Breakout": f"Breakout({configManager.daysToLookback}Prds)",
-                },
-                inplace=True,
-            )
-    saveResults.loc[:, f"Consol."] = saveResults.loc[
-            :, f"Consol."
-        ].apply(lambda x: x.replace("Range:", "").replace("%", ""))
-    saveResults[["Breakout", "Resistance"]] = saveResults[
-            f"Breakout({configManager.daysToLookback}Prds)"
-        ].str.split(" R: ", n=1, expand=True)
-    saveResults.loc[:, "Breakout"] = saveResults.loc[:, "Breakout"].apply(
-            lambda x: x.replace("BO: ", "").replace(" ", "")
-        )
-    saveResults.loc[:, "Resistance"] = saveResults.loc[
-            :, "Resistance"
-        ].apply(lambda x: x.replace("(Potential)", "") if x is not None else x)
-    saveResults["Volume"] = saveResults["Volume"].astype(float).fillna(0.0)
-    saveResults[f"Consol."] = (
-            saveResults[f"Consol."].astype(float).fillna(0.0)
-        )
-    saveResults["Breakout"] = saveResults["Breakout"].astype(float).fillna(0.0)
-    saveResults["Resistance"] = saveResults["Resistance"].astype(float).fillna(0.0)
-    saveResults["52Wk H"] = saveResults["52Wk H"].astype(float).fillna(0.0)
-    saveResults["52Wk L"] = saveResults["52Wk L"].astype(float).fillna(0.0)
-    saveResults["CCI"] = saveResults["CCI"].astype(float).fillna(0.0)
-    return saveResults
-
-def getbacktestPeriod(args):
-    backtestPeriods = configManager.maxBacktestWindow  # Max backtest days
-    if args is None or ((not isinstance(args,int)) and (not isinstance(args,Namespace))):
-        return backtestPeriods
-    if args is not None and args.backtestdaysago is not None:
-        try:
-            backtestPeriods = int(args.backtestdaysago)
-        except Exception as e:# pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            pass
-    return backtestPeriods
-
-def statScanCalculations(userArgs, saveResults, periods,progressLabel:str=None):
-    scanResults = []
-    task1 = PKTask(f"[{len(saveResults)}] RSI Stats",long_running_fn=statScanCalculationForRSI)
-    task2 = PKTask(f"[{len(saveResults)}] Trend Stats",long_running_fn=statScanCalculationForTrend)
-    task3 = PKTask(f"[{len(saveResults)}] MA Stats",long_running_fn=statScanCalculationForMA)
-    task4 = PKTask(f"[{len(saveResults)}] Volume Stats",long_running_fn=statScanCalculationForVol)
-    task5 = PKTask(f"[{len(saveResults)}] Consolidation Stats",long_running_fn=statScanCalculationForConsol)
-    task6 = PKTask(f"[{len(saveResults)}] Breakout Stats",long_running_fn=statScanCalculationForBO)
-    task7 = PKTask(f"[{len(saveResults)}] 52Week Stats",long_running_fn=statScanCalculationFor52Wk)
-    task8 = PKTask(f"[{len(saveResults)}] CCI Stats",long_running_fn=statScanCalculationForCCI)
-    task9 = PKTask(f"[{len(saveResults)}] CCI Stats",long_running_fn=statScanCalculationForPatterns)
-    task10 = PKTask(f"[{len(saveResults)}] NoFilter Stats",long_running_fn=statScanCalculationForNoFilter)
-    tasksList=[task1,task2,task3,task4,task5,task6,task7,task8,task9,task10]
-    for task in tasksList:
-        task.long_running_fn_args = (userArgs, saveResults, periods, scanResults)
-    if configManager.enablePortfolioCalculations:
-        PKScheduler.scheduleTasks(tasksList,label=progressLabel,showProgressBars=True,timeout=600)
-    else:
-        for task in tasksList:
-            task.long_running_fn(*(task,))
-    for task in tasksList:
-        if task.result is not None and len(task.result) > 0:
-            scanResults.extend(task.result)
-    return scanResults
-
-def statScanCalculationForCCI(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        userArgs, saveResults, period, scanResults = task.long_running_fn_args
-    else:
-        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
-    scanResults.append(
-                getCalculatedValues(
-                    filterCCIBelowMinus100(saveResults), period, "[CCI]<=-100", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterCCIBelow0(saveResults), period, "[CCI]-100<C<0", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterCCI0To100(saveResults), period, "[CCI]0<=C<=100", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterCCI100To200(saveResults), period, "[CCI]100<C<=200", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterCCIAbove200(saveResults), period, "[CCI]>200", userArgs,task
-                )
-            )
-    if task is not None:
-        if task.taskId > 0:
-            task.resultsDict[task.taskId] = scanResults
-            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
-        else:
-            task.result = scanResults
-    return scanResults
-
-def statScanCalculationFor52Wk(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        userArgs, saveResults, period, scanResults = task.long_running_fn_args
-    else:
-        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
-    scanResults.append(
-                getCalculatedValues(
-                    filterLTPMoreOREqual52WkH(saveResults), period, "[52Wk]LTP>=H", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterLTPWithin90Percent52WkH(saveResults),
-                    period,
-                    "[52Wk]LTP>=.9*H",
-                    userArgs,
-                    task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterLTPLess90Percent52WkH(saveResults),
-                    period,
-                    "[52Wk]LTP<.9*H",
-                    userArgs,
-                    task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterLTPMore52WkL(saveResults), period, "[52Wk]LTP>L", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterLTPWithin90Percent52WkL(saveResults),
-                    period,
-                    "[52Wk]LTP>=1.1*L",
-                    userArgs,
-                    task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterLTPLess52WkL(saveResults), period, "[52Wk]LTP<=L", userArgs,task
-                )
-            )
-    if task is not None:
-        if task.taskId > 0:
-            task.resultsDict[task.taskId] = scanResults
-            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
-        else:
-            task.result = scanResults
-    return scanResults
-
-def statScanCalculationForBO(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        userArgs, saveResults, period, scanResults = task.long_running_fn_args
-    else:
-        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
-    scanResults.append(
-                getCalculatedValues(
-                    filterLTPLessThanBreakout(saveResults), period, "[BO]LTP<BO", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterLTPMoreOREqualBreakout(saveResults),
-                    period,
-                    "[BO]LTP>=BO",
-                    userArgs,
-                    task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterLTPLessThanResistance(saveResults), period, "[BO]LTP<R", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterLTPMoreOREqualResistance(saveResults),
-                    period,
-                    "[BO]LTP>=R",
-                    userArgs,
-                    task
-                )
-            )
-    if task is not None:
-        if task.taskId > 0:
-            task.resultsDict[task.taskId] = scanResults
-            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
-        else:
-            task.result = scanResults
-    return scanResults
-
-def statScanCalculationForConsol(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        userArgs, saveResults, period, scanResults = task.long_running_fn_args
-    else:
-        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
-    scanResults.append(
-                getCalculatedValues(
-                    filterConsolidating10Percent(saveResults), period, "Cons.<=10", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterConsolidatingMore10Percent(saveResults),
-                    period,
-                    "Cons.>10",
-                    userArgs,
-                    task
-                )
-            )
-    if task is not None:
-        if task.taskId > 0:
-            task.resultsDict[task.taskId] = scanResults
-            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
-        else:
-            task.result = scanResults
-    return scanResults
-
-def statScanCalculationForVol(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        userArgs, saveResults, period, scanResults = task.long_running_fn_args
-    else:
-        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
-    scanResults.append(
-                getCalculatedValues(
-                    filterVolumeLessThan25(saveResults), period, "Vol<2.5", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterVolumeMoreThan25(saveResults), period, "Vol>=2.5", userArgs,task
-                )
-            )
-    if task is not None:
-        if task.taskId > 0:
-            task.resultsDict[task.taskId] = scanResults
-            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
-        else:
-            task.result = scanResults
-    return scanResults
-
-def statScanCalculationForMA(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        userArgs, saveResults, period, scanResults = task.long_running_fn_args
-    else:
-        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
-    scanResults.append(
-                getCalculatedValues(
-                    filterMASignalBullish(saveResults), period, "[MA]Bull", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterMASignalBearish(saveResults), period, "[MA]Bear", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterMASignalNeutral(saveResults), period, "[MA]Neutral", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterMASignalBullCross(saveResults), period, "[MA]BullCross", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterMASignalBearCross(saveResults), period, "[MA]BearCross", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterMASignalSupport(saveResults), period, "[MA]Support", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterMASignalResist(saveResults), period, "[MA]Resist", userArgs,task
-                )
-            )
-    if task is not None:
-        if task.taskId > 0:
-            task.resultsDict[task.taskId] = scanResults
-            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
-        else:
-            task.result = scanResults
-    return scanResults
-
-def statScanCalculationForTrend(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        userArgs, saveResults, period, scanResults = task.long_running_fn_args
-    else:
-        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
-    scanResults.append(
-                getCalculatedValues(
-                    filterTrendStrongUp(saveResults), period, "[T]StrongUp", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterTrendWeakUp(saveResults), period, "[T]WeakUp", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterTrendUp(saveResults), period, "[T]TrendUp", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterTrendStrongDown(saveResults), period, "[T]StrongDown", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterTrendWeakDown(saveResults), period, "[T]WeakDown", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterTrendSideways(saveResults), period, "[T]Sideways", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterTrendDown(saveResults), period, "[T]TrendDown", userArgs,task
-                )
-            )
-    if task is not None:
-        if task.taskId > 0:
-            task.resultsDict[task.taskId] = scanResults
-            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
-        else:
-            task.result = scanResults
-    return scanResults
-
-def statScanCalculationForRSI(*args, **kwargs):
-    task = None
-    if isinstance(args[0], PKTask):
-        task = args[0]
-        userArgs, saveResults, period, scanResults = task.long_running_fn_args
-    else:
-        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
-    scanResults.append(
-                getCalculatedValues(
-                    filterRSIAbove50(saveResults), period, "[RSI]>=50", userArgs, task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterRSI50To67(saveResults), period, "[RSI]50<=RSI<=67", userArgs,task
-                )
-            )
-    scanResults.append(
-                getCalculatedValues(
-                    filterRSI68OrAbove(saveResults), period, "[RSI]>=68", userArgs,task
-                )
-            )
-    if task is not None:
-        if task.taskId > 0:
-            task.resultsDict[task.taskId] = scanResults
-            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
-        else:
-            task.result = scanResults
-    return scanResults
-
-
-def formatGridOutput(df,replacenan=True):
-    if replacenan:
-        df = df.replace(np.nan, "-", regex=True)
-    for col in df.columns:
-        try:
-            df[col] = df[col].astype(float).fillna(0)
-        except ValueError as e:
-            if len(str(e).split("-")) < 2:
-                # We want to allow value "-" in column values
-                # We don't want to allow '2024-12-03' or 'RSI >=50' or "Trends-50-to-60"
-                pass
-            else:
-                continue
-        except Exception as e:# pragma: no cover
-            default_logger().debug(f"For column:{col}:\n{e}", exc_info=True)
-            continue
-        maxGrowth = df[col].max()
-        if "Pd-%" in col:
-            df.loc[:, col] = df.loc[:, col].apply(
-                lambda x: x
-                if (str(x) == "-")
-                else (
-                    str(x).replace(
-                        str(x),
-                        (
-                            (
-                                (colorText.BOLD + colorText.WHITE)
-                                if x == maxGrowth
-                                else colorText.GREEN
-                            )
-                            if float(x) > 0
-                            else (colorText.FAIL if float(x) < 0 else colorText.WARN)
-                        )
-                        + str(float(x))
-                        + " %"
-                        + colorText.END,
-                    )
-                )
-            )
-        if "Pd-10k" in col:
-            df.loc[:, col] = df.loc[:, col].apply(
-                lambda x: x
-                if (str(x) == "-")
-                else (
-                    str(x).replace(
-                        str(x),
-                        (
-                            (
-                                (colorText.BOLD + colorText.WHITE)
-                                if x == maxGrowth
-                                else colorText.GREEN
-                            )
-                            if (float(x) > 10000)
-                            else (
-                                colorText.FAIL if float(x) < 10000 else colorText.WARN
-                            )
-                        )
-                        + str(x)
-                        + colorText.END,
-                    )
-                )
-            )
-    df = df.replace(np.nan, "-", regex=True)
-    df = df.replace(colorText.FAIL + "-100.0 %" + colorText.END, "-", regex=False)
-    df = df.replace(colorText.WARN + "0.0 %" + colorText.END, "-", regex=False)
-    df = df.replace(colorText.FAIL + "0.0" + colorText.END, "-", regex=False)
-    return df
-
-
-def getCalculatedValues(df, periods, key, userArgs=None, task=None):
-    collated_df = None
-    for period in periods:
-        ltpSum1ShareEach = round(df["LTP"].sum(), 2)
-        tdySum1ShareEach = round(df[f"LTP{period}"].sum(), 2)
-        growthSum1ShareEach = round(df[f"Growth{period}"].sum(), 2)
-        percentGrowth = 0
-        if ltpSum1ShareEach > 0:
-            percentGrowth = round(100 * growthSum1ShareEach / ltpSum1ShareEach, 2)
-        growth10k = round(10000 * (1 + 0.01 * percentGrowth), 2)
-        if configManager.enablePortfolioCalculations and userArgs.options.startswith("B"): # backtests
-            portfolio = Portfolio(name=key)
-            portfolio.updatePortfolioFromXRayDataFrame(df,configManager.periodsRange,task)
-            PortfolioCollection().addPortfolio(portfolio)
-        result_df = {
-            "ScanType": key, #if tdySum1ShareEach != 0 else 999999999,
-            f"{period}Pd-PFV": tdySum1ShareEach,
-            f"{period}Pd-%": percentGrowth if tdySum1ShareEach != 0 else 999999999,
-            f"{period}Pd-10k": growth10k if tdySum1ShareEach != 0 else 999999999,
-        }
-        if collated_df is None:
-            collated_df = result_df
-        collated_df = collated_df | result_df
-    # percentGrowth = colorText.GREEN if percentGrowth >=0 else colorText.FAIL + percentGrowth + colorText.END
-    # growth10k = colorText.GREEN if percentGrowth >=0 else colorText.FAIL + growth10k + colorText.END
-    # df_col = {'ScanType':key,
-    #     f'{period}Pd-PFV':tdySum1ShareEach,
-    #     f'{period}Pd-PFG':percentGrowth if tdySum1ShareEach != 0 else '-',
-    #     f'{period}Pd-Go10k':growth10k if tdySum1ShareEach != 0 else '-',
-    #     }
-
-    return collated_df  # , df_col
-
-
-def filterRSIAbove50(df):
-    if df is None:
-        return None
-    return df[df["RSI"] > 50].fillna(0.0)
-
-
-def filterRSI50To67(df):
-    if df is None:
-        return None
-    return df[(df["RSI"] >= 50) & (df["RSI"] <= 67)].fillna(0.0)
-
-
-def filterRSI68OrAbove(df):
-    if df is None:
-        return None
-    return df[df["RSI"] >= 68].fillna(0.0)
-
-
-def filterTrendStrongUp(df):
-    if df is None:
-        return None
-    return df[df[f"Trend({configManager.daysToLookback}Prds)"] == "Strong Up"].fillna(0.0)
-
-
-def filterTrendWeakUp(df):
-    if df is None:
-        return None
-    return df[df[f"Trend({configManager.daysToLookback}Prds)"] == "Weak Up"].fillna(0.0)
-
-
-def filterTrendWeakDown(df):
-    if df is None:
-        return None
-    return df[df[f"Trend({configManager.daysToLookback}Prds)"] == "Weak Down"].fillna(0.0)
-
-
-def filterTrendStrongDown(df):
-    if df is None:
-        return None
-    return df[df[f"Trend({configManager.daysToLookback}Prds)"] == "Strong Down"].fillna(0.0)
-
-
-def filterTrendUp(df):
-    if df is None:
-        return None
-    return df[df[f"Trend({configManager.daysToLookback}Prds)"].astype(str).str.endswith("Up")].fillna(0.0)
-
-
-def filterTrendSideways(df):
-    if df is None:
-        return None
-    return df[df[f"Trend({configManager.daysToLookback}Prds)"] == "Sideways"].fillna(0.0)
-
-
-def filterTrendDown(df):
-    if df is None:
-        return None
-    return df[df[f"Trend({configManager.daysToLookback}Prds)"].astype(str).str.endswith("Down")].fillna(0.0)
-
-
-def filterMASignalBullish(df):
-    if df is None:
-        return None
-    return df[df["MA-Signal"] == "Bullish"].fillna(0.0)
-
-
-def filterMASignalBearish(df):
-    if df is None:
-        return None
-    return df[df["MA-Signal"] == "Bearish"].fillna(0.0)
-
-
-def filterMASignalNeutral(df):
-    if df is None:
-        return None
-    return df[df["MA-Signal"] == "Neutral"].fillna(0.0)
-
-
-def filterMASignalBullCross(df):
-    if df is None:
-        return None
-    return df[df["MA-Signal"].astype(str).str.startswith("BullCross")].fillna(0.0)
-
-
-def filterMASignalBearCross(df):
-    if df is None:
-        return None
-    return df[df["MA-Signal"].astype(str).str.startswith("BearCross")].fillna(0.0)
-
-
-def filterMASignalSupport(df):
-    if df is None:
-        return None
-    return df[df["MA-Signal"].astype(str).str.endswith("Support")].fillna(0.0)
-
-
-def filterMASignalResist(df):
-    if df is None:
-        return None
-    return df[df["MA-Signal"].astype(str).str.endswith("Resist")].fillna(0.0)
-
-
-def filterVolumeLessThan25(df):
-    if df is None:
-        return None
-    return df[df["Volume"] < 2.5].fillna(0.0)
-
-
-def filterVolumeMoreThan25(df):
-    if df is None:
-        return None
-    return df[df["Volume"] >= 2.5].fillna(0.0)
-
-
-def filterConsolidating10Percent(df):
-    if df is None:
-        return None
-    return df[df[f"Consol."] <= 10].fillna(0.0)
-
-
-def filterConsolidatingMore10Percent(df):
-    if df is None:
-        return None
-    return df[df[f"Consol."] > 10].fillna(0.0)
-
-
-def filterLTPLessThanBreakout(df):
-    if df is None:
-        return None
-    return df[df["LTP"] < df["Breakout"]].fillna(0.0)
-
-
-def filterLTPMoreOREqualBreakout(df):
-    if df is None:
-        return None
-    return df[((df["Breakout"] > 0) & (df["LTP"] >= df["Breakout"]))].fillna(0.0)
-
-
-def filterLTPLessThanResistance(df):
-    if df is None:
-        return None
-    return df[df["LTP"] < df["Resistance"]].fillna(0.0)
-
-
-def filterLTPMoreOREqualResistance(df):
-    if df is None:
-        return None
-    return df[((df["Resistance"] > 0) & (df["LTP"] >= df["Resistance"]))].fillna(0.0)
-
-
-def filterLTPMoreOREqual52WkH(df):
-    if df is None:
-        return None
-    return df[df["LTP"] >= df["52Wk H"]].fillna(0.0)
-
-
-def filterLTPWithin90Percent52WkH(df):
-    if df is None:
-        return None
-    return df[(df["LTP"] >= 0.9 * df["52Wk H"]) & (df["LTP"] < df["52Wk H"])].fillna(
-        0.0
-    )
-
-
-def filterLTPLess90Percent52WkH(df):
-    if df is None:
-        return None
-    return df[df["LTP"] < 0.9 * df["52Wk H"]].fillna(0.0)
-
-
-def filterLTPMore52WkL(df):
-    if df is None:
-        return None
-    return df[((df["LTP"] > df["52Wk L"]) & (df["LTP"] < 1.1 * df["52Wk L"]))].fillna(
-        0.0
-    )
-
-
-def filterLTPWithin90Percent52WkL(df):
-    if df is None:
-        return None
-    return df[(df["LTP"] >= (1.1 * df["52Wk L"])) & (df["LTP"] > df["52Wk L"])].fillna(
-        0.0
-    )
-
-
-def filterLTPLess52WkL(df):
-    if df is None:
-        return None
-    return df[df["LTP"] <= df["52Wk L"]].fillna(0.0)
-
-
-def filterCCIBelowMinus100(df):
-    if df is None:
-        return None
-    return df[df["CCI"] <= -100].fillna(0.0)
-
-
-def filterCCIBelow0(df):
-    if df is None:
-        return None
-    return df[(df["CCI"] > -100) & (df["CCI"] < 0)].fillna(0.0)
-
-
-def filterCCI0To100(df):
-    if df is None:
-        return None
-    return df[(df["CCI"] >= 0) & (df["CCI"] <= 100)].fillna(0.0)
-
-
-def filterCCI100To200(df):
-    if df is None:
-        return None
-    return df[(df["CCI"] > 100) & (df["CCI"] <= 200)].fillna(0.0)
-
-
-def filterCCIAbove200(df):
-    if df is None:
-        return None
-    return df[(df["CCI"] > 200)].fillna(0.0)
-
-def returnNoFilter(df):
-    return df
-
-def filterPattern(df, pattern="[P]No Pattern"):
-    if df is None:
-        return None
-    match_df = None
-    df_grouped = df.groupby("Pattern")
-    for foundPattern, df_group in df_grouped:
-        if foundPattern is None or len(foundPattern) == 0:
-            foundPattern = "No Pattern"
-        if f"[P]{foundPattern}" == pattern:
-            match_df = df_group
-            break
-    return match_df
-
-def strategyDictionary():
-    """
-    Available Strategies:
-
-    RSI
-    ---
-    `RSI>=50`, `50<=RSI<=67` and `RSI>=68`
-
-    CCI
-    ---
-    `[CCI]<=-100`, `[CCI]-100<C<0`, `[CCI]0<=C<=100`, `[CCI]100<C<=200` and `[CCI]>200`
-
-    52Wk H/L
-    --------
-    `[52Wk]LTP>=H`, `[52Wk]LTP>=.9*H`, `[52Wk]LTP<.9*H`, `[52Wk]LTP>L`, `[52Wk]LTP>=1.1*L` and `[52Wk]LTP<=L`
-
-    Breakout
-    --------
-    `[BO]LTP<BO`, `[BO]LTP>=BO`, `[BO]LTP<R` and `[BO]LTP>=R`
-
-    Consolidation
-    -------------
-    `Cons.<=10` and Cons.>10
-
-    Volume
-    ------
-    `Vol<2.5` and `Vol>=2.5`
-
-    Moving Averages
-    ---------------
-    `[MA]Bull`, `[MA]Bear`, `[MA]Neutral`, `[MA]BullCross`, `[MA]BearCross`, `[MA]Support` and `[MA]Resist`
-
-    Trends
-    ------
-    `[T]StrongUp`, `[T]WeakUp`, `[T]TrendUp`, `[T]StrongDown`, `[T]WeakDown`, `[T]Sideways` and `[T]TrendDown`
-
-    NoFilter
-    --------
-    `NoFilter`
-
-    Patterns
-    --------
-    `[P]{patern_name}`. For example, `[P]No Pattern`
-    """
-    strategies = {}
-    # RSI
-    strategies["[RSI]>=50"] = filterRSIAbove50
-    strategies["[RSI]50<=RSI<=67"] = filterRSI50To67
-    strategies["[RSI]>=68"] = filterRSI68OrAbove
-    # CCI
-    strategies["[CCI]<=-100"] = filterCCIBelowMinus100
-    strategies["[CCI]-100<C<0"] = filterCCIBelow0
-    strategies["[CCI]0<=C<=100"] = filterCCI0To100
-    strategies["[CCI]100<C<=200"] = filterCCI100To200
-    strategies["[CCI]>200"] = filterCCIAbove200
-    # 52Wk H/L
-    strategies["[52Wk]LTP>=H"] = filterLTPMoreOREqual52WkH
-    strategies["[52Wk]LTP>=.9*H"] = filterLTPWithin90Percent52WkH
-    strategies["[52Wk]LTP<.9*H"] = filterLTPLess90Percent52WkH
-    strategies["[52Wk]LTP>L"] = filterLTPMore52WkL
-    strategies["[52Wk]LTP>=1.1*L"] = filterLTPWithin90Percent52WkL
-    strategies["[52Wk]LTP<=L"] = filterLTPLess52WkL
-    # Breakout
-    strategies["[BO]LTP<BO"] = filterLTPLessThanBreakout
-    strategies["[BO]LTP>=BO"] = filterLTPMoreOREqualBreakout
-    strategies["[BO]LTP<R"] = filterLTPLessThanResistance
-    strategies["[BO]LTP>=R"] = filterLTPMoreOREqualResistance
-    # Consolidation
-    strategies["Cons.<=10"] = filterConsolidating10Percent
-    strategies["Cons.>10"] = filterConsolidatingMore10Percent
-    # Volume
-    strategies["Vol<2.5"] = filterVolumeLessThan25
-    strategies["Vol>=2.5"] = filterVolumeMoreThan25
-    # MA
-    strategies["[MA]Bull"] = filterMASignalBullish
-    strategies["[MA]Bear"] = filterMASignalBearish
-    strategies["[MA]Neutral"] = filterMASignalNeutral
-    strategies["[MA]BullCross"] = filterMASignalBullCross
-    strategies["[MA]BearCross"] = filterMASignalBearCross
-    strategies["[MA]Support"] = filterMASignalSupport
-    strategies["[MA]Resist"] = filterMASignalResist
-    # Trends
-    strategies["[T]StrongUp"] = filterTrendStrongUp
-    strategies["[T]WeakUp"] = filterTrendWeakUp
-    strategies["[T]TrendUp"] = filterTrendUp
-    strategies["[T]StrongDown"] = filterTrendStrongDown
-    strategies["[T]WeakDown"] = filterTrendWeakDown
-    strategies["[T]Sideways"] = filterTrendSideways
-    strategies["[T]TrendDown"] = filterTrendDown
-    # NoFilter
-    strategies["NoFilter"] = returnNoFilter
-    # Pattern
-    strategies["[P]"] = filterPattern
-    return strategies
-
-def strategyForKey(key:str):
-    strategies = strategyDictionary()
-    if key in strategies.keys():
-        return strategies[key]
-    elif key.startswith("[P]"):
-        return strategies["[P]"]
-
-def strategyNames():
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import os
+import sys
+import numpy as np
+import pandas as pd
+from argparse import Namespace
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.PKDateUtilities import PKDateUtilities
+from pkscreener.classes import Utility
+from PKDevTools.classes.log import default_logger
+from pkscreener.classes.ConfigManager import parser, tools
+from pkscreener.classes.Portfolio import Portfolio, PortfolioCollection
+from pkscreener.classes.PKTask import PKTask
+from pkscreener.classes.PKScheduler import PKScheduler
+from PKDevTools.classes.OutputControls import OutputControls
+
+configManager = tools()
+configManager.getConfig(parser)
+
+def summariseAllStrategies(testing=False):
+    reports = getSavedBacktestReportNames(testing=testing)
+    df_all = None
+    counter = 0
+    for report in reports:
+        counter += 1
+        OutputControls().printOutput(f"Processing {counter} of {len(reports)}...")
+        df = bestStrategiesFromSummaryForReport(
+            f"PKScreener_{report}_Insights_DateSorted.html", summary=True,includeLargestDatasets=True
+        )
+        if df is not None:
+            df.insert(loc=0, column="Scanner", value=report)
+            if df_all is not None:
+                df_all = pd.concat([df_all, df], axis=0)
+            else:
+                df_all = df
+        sys.stdout.write("\x1b[1A")
+    if df_all is not None:
+        df_all = df_all.replace(np.nan, "-", regex=True)
+    return df_all
+
+def getSavedBacktestReportNames(testing=False):
+    indices = [1,5,8,11,12,14] if not testing else [1]
+    scanSkipIndices = [21, 22] if not testing else [1,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
+    indexWithSubindices = [6, 7] if not testing else [6]
+    subIndices = {6: [1, 2, 3, 4, 5, 6, 7], 7: [1, 2, 3, 4, 5, 6, 7]} if not testing else {6: [7]}
+    indexWithSubLevelindices = {6:[7],7:[6]}
+    subLevelIndices = {7: [1, 2, 3], 6: [1, 2, 3]} if not testing else {7: [1]}
+    reports = []
+    for index in indices:
+        scanTypeStartIndex = 1
+        scanTypeEndIndex = 25
+        reportName = f"B_{index}_"
+        while scanTypeStartIndex <= scanTypeEndIndex:
+            if scanTypeStartIndex not in scanSkipIndices:
+                reportName = f"{reportName}{scanTypeStartIndex}"
+                if scanTypeStartIndex in indexWithSubindices:
+                    for subIndex in subIndices[scanTypeStartIndex]:
+                        subReportName = f"{reportName}_{subIndex}"
+                        if subIndex in indexWithSubLevelindices[scanTypeStartIndex]:
+                            for subLevelIndex in subLevelIndices[subIndex]:
+                                subLevelReportName = f"{subReportName}_{subLevelIndex}"
+                                reports.append(subLevelReportName)
+                        else:
+                            reports.append(subReportName)
+                else:
+                    reports.append(reportName)
+            reportName = f"B_{index}_"
+            scanTypeStartIndex += 1
+    return reports
+
+
+def bestStrategiesFromSummaryForReport(reportName: None, summary=False,includeLargestDatasets=False):
+    dfs = []
+    insights = None
+    if "PKDevTools_Default_Log_Level" not in os.environ.keys():
+        if (("RUNNER" not in os.environ.keys())):
+            return None
+    if not configManager.showPastStrategyData:
+        return None
+    try:
+        dfs = pd.read_html(
+            "https://pkjmesra.github.io/PKScreener/Backtest-Reports/{0}".format(
+                reportName.replace("_X_", "_B_").replace("_G_", "_B_").replace("_S_", "_B_")
+            ),encoding="UTF-8", attrs = {'id': 'resultsTable'}
+        )
+    except Exception as e: # pragma: no cover
+        pass
+    if dfs is not None and len(dfs) > 0:
+        df = dfs[0]
+        if len(df) > 0:
+            periods = configManager.periodsRange
+            insights = cleanupInsightsSummary(df, periods)
+            # insights = insights.replace('', np.nan, regex=True)
+            # insights = insights.replace('-', np.nan, regex=True)
+            dfs = []
+            max_best_df = insights.copy()
+            max_datasets_df = insights.copy()
+            if includeLargestDatasets:
+                addLargeDatasetInsights(dfs, max_datasets_df)
+            
+            insights_list = []
+            dfs.append(max_best_df)
+            getMaxBestInsight(summary, dfs, periods, insights_list)
+            insights = pd.DataFrame(insights_list).drop_duplicates(ignore_index=True)
+            insights.dropna(axis=0, how="all", inplace=True)
+            insights = insights.replace(np.nan, "-", regex=True)
+    return insights
+
+def cleanupInsightsSummary(df, periods):
+    df = df.replace(" %", "", regex=True)
+    df = df.replace("-", np.nan, regex=True)
+    for period in periods:
+        df.rename(
+                    columns={
+                        f"{period}D-%": f"{period}Pd-%",
+                        f"{period}D-10k": f"{period}Pd-10k",
+                    },
+                    inplace=True,
+                )
+        castToFloat(df, period)
+    insights = df[df["ScanType"].astype(str).str.startswith("[SUM]")]
+    return insights
+
+def getMaxBestInsight(summary, dfs, periods, insights_list):
+    for dfInsights in dfs:
+        df = dfInsights.copy()
+        df.reset_index(drop = True, inplace=True)
+        strategy_percent = {}
+        strategy = {}
+        firstPeriod = True
+        rowIndex = 0
+        for prd in periods:
+            rowIndex += 1
+            try:
+                max_p = df[f"{prd}Pd-%"].max()
+                maxIndexPos = df[f"{prd}Pd-%"].idxmax()
+                bestScanFilter = str(
+                            df["ScanType"].iloc[maxIndexPos]).replace("[SUM]", "")
+                resultPoints = bestScanFilter.split("(")[-1]
+                strategy_percent[f"{prd}-Pd"] = f"{colorText.GREEN if max_p > 0 else (colorText.FAIL if max_p < 0 else colorText.WARN)}{max_p} %{colorText.END}{(' from ('+resultPoints) if (summary or firstPeriod) else ''}"
+                scanType = (bestScanFilter.split("(")[0] if not summary else bestScanFilter)
+                strategy[f"{prd}-Pd"] = scanType
+            except KeyError:
+                    max_p = df[rowIndex*2]
+                    bestScanFilter = str(df[0]).replace("[SUM]", "")
+                    resultPoints = bestScanFilter.split("(")[-1]
+                    strategy_percent[f"{prd}-Pd"] = f"{colorText.GREEN if max_p > 0 else (colorText.FAIL if max_p < 0 else colorText.WARN)}{max_p} %{colorText.END}{(' from ('+resultPoints) if (summary or firstPeriod) else ''}"
+                    scanType = (bestScanFilter.split("(")[0] if not summary else bestScanFilter)
+                    strategy[f"{prd}-Pd"] = scanType
+            except Exception:# pragma: no cover
+                # default_logger().debug(e, exc_info=True)
+                try:
+                    max_p = df[f"{prd}Pd-%"]
+                    bestScanFilter = str(df["ScanType"]).replace("[SUM]", "")
+                    resultPoints = bestScanFilter.split("(")[-1]
+                    strategy_percent[f"{prd}-Pd"] = f"{colorText.GREEN if max_p > 0 else (colorText.FAIL if max_p < 0 else colorText.WARN)}{max_p} %{colorText.END}{(' from ('+resultPoints) if (summary or firstPeriod) else ''}"
+                    scanType = (bestScanFilter.split("(")[0] if not summary else bestScanFilter)
+                    strategy[f"{prd}-Pd"] = scanType
+                except Exception as e:# pragma: no cover
+                    default_logger().debug(e, exc_info=True)
+                    pass
+                pass
+            if summary:
+                strategy[f"{prd}-Pd"] = strategy_percent[f"{prd}-Pd"].split("from")[0] + " " + strategy[f"{prd}-Pd"]
+            firstPeriod = False
+        insights_list.extend([strategy] if summary else [strategy, strategy_percent])
+
+def addLargeDatasetInsights(dfs, max_datasets_df):
+    max_datasets_df[["ScanTypeSplit", "DatasetSize"]] = max_datasets_df[
+                    "ScanType"
+                ].str.split("(", n=1, expand=True)
+    max_datasets_df["DatasetSize"] = max_datasets_df["DatasetSize"].str.replace(")", "")
+    try:
+        max_datasets_df["DatasetSize"] = (max_datasets_df["DatasetSize"].astype(float).fillna(0.0))
+    except Exception as e:# pragma: no cover
+        default_logger().debug(e, exc_info=True)
+        max_datasets_df.loc[:, "DatasetSize"] = max_datasets_df.loc[:, "DatasetSize"].apply(
+                        lambda x: x.split("(")[-1]
+                    )
+        max_datasets_df["DatasetSize"] = (max_datasets_df["DatasetSize"].astype(float).fillna(0.0))
+        pass
+    max_size = max_datasets_df["DatasetSize"].max()
+    max_datasets_df = max_datasets_df[(max_datasets_df["DatasetSize"] == max_size)].fillna(0.0)
+    for i in range(0, len(max_datasets_df)):
+        dfs.append(max_datasets_df.iloc[i])
+
+def castToFloat(df, prd):
+    if f"{prd}Pd-%" in df.columns:
+        df[f"{prd}Pd-%"] = (df[f"{prd}Pd-%"].astype(float).fillna(0.0))
+
+
+def xRaySummary(savedResults=None):
+    if savedResults is None or not isinstance(savedResults, pd.DataFrame) or savedResults.empty:
+        return savedResults
+    saveResults = savedResults.copy()
+    df_grouped = saveResults.groupby("ScanType")
+    periods = configManager.periodsRange
+    sum_list = []
+    sum_dict = {}
+    maxGrowth = -100
+    for scanType, df_group in df_grouped:
+        groupItems = len(df_group)
+        sum_dict = {}
+        sum_dict["ScanType"] = f"[SUM]{scanType.replace('(','[').replace(')',']')}  ({groupItems})"
+        sum_dict["Date"] = PKDateUtilities.currentDateTime().strftime("%Y-%m-%d")
+        for prd in periods:
+            if not f"{prd}Pd-%" in df_group.columns:
+                continue
+            prd_df = df_group[[f"{prd}Pd-%", f"{prd}Pd-10k"]]
+            prd_df.loc[:, f"{prd}Pd-10k"] = prd_df.loc[:, f"{prd}Pd-10k"].apply(
+                lambda x: Utility.tools.removeAllColorStyles(x)
+            )
+            prd_df = prd_df.replace("-", np.nan, regex=True)
+            prd_df = prd_df.replace("", np.nan, regex=True)
+            prd_df.dropna(axis=0, how="all", inplace=True)
+            prd_df[f"{prd}Pd-10k"] = prd_df[f"{prd}Pd-10k"].astype(float).fillna(0.0)
+            gain = round(
+                (prd_df[f"{prd}Pd-10k"].sum() - 10000 * len(prd_df))
+                * 100
+                / (10000 * len(prd_df)),
+                2,
+            )
+            sum_dict[f"{prd}Pd-%"] = gain
+            sum_dict[f"{prd}Pd-10k"] = round(
+                prd_df[f"{prd}Pd-10k"].sum() / len(prd_df), 2
+            )
+        sum_list.append(sum_dict)
+    df = pd.DataFrame(sum_list)
+    df = formatGridOutput(df, replacenan=False)
+    saveResults = pd.concat([saveResults, df], axis=0)
+    saveResults = saveResults.replace(np.nan, "-", regex=True)
+    return saveResults
+
+
+def performXRay(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        savedResults, userArgs, calcForDate, progressLabel = task.long_running_fn_args
+    else:
+        savedResults, userArgs, calcForDate, progressLabel = args[0],args[1],args[2],args[3]
+    df = None
+    if savedResults is not None and len(savedResults) > 0:
+        backtestPeriods = getbacktestPeriod(userArgs)
+        saveResults = cleanupData(savedResults)
+
+        days = 0
+        periods = configManager.periodsRange
+        # period = periods[days]
+        # requiredPeriods = []
+        # If the calcForDate is more than the backtestPeriods, we should be able to 
+        # still calculate the backtested returns for all 30 periods or periods more than
+        # the requested backtestPeriods
+        # backtestPeriods = getUpdatedBacktestPeriod(calcForDate, backtestPeriods, saveResults)
+        # while periods[days] <= backtestPeriods:
+        #     period = periods[days]
+        #     requiredPeriods.append(period)
+        #     days += 1
+        #     if days >= len(periods):
+        #         break
+        df = getBacktestDataFromCleanedData(userArgs, saveResults, df, periods,progressLabel)
+        if df is None:
+            return None
+        df = cleanFormattingForStatsData(calcForDate, saveResults, df)
+        # OutputControls().printOutput(f"All portfolios:\n{PortfolioCollection().portfoliosAsDataframe}")
+        # OutputControls().printOutput(f"All portfoliosSummary:\n{PortfolioCollection().ledgerSummaryAsDataframe}")
+    if task is not None:
+        if task.taskId > 0:
+            task.progressStatusDict[task.taskId] = {'progress': 0, 'total': 1}
+            task.resultsDict[task.taskId] = df
+        else:
+            task.result = df
+    return df
+
+def getUpdatedBacktestPeriod(calcForDate, backtestPeriods, saveResults):
+    targetDate = (
+            calcForDate if calcForDate is not None else saveResults["Date"].iloc[0]
+        )
+    today = PKDateUtilities.currentDateTime()
+    gap = PKDateUtilities.trading_days_between(
+            PKDateUtilities.dateFromYmdString(targetDate)
+            .replace(tzinfo=today.tzinfo)
+            .date(),
+            today.date(),
+        )
+    backtestPeriods = gap if gap > backtestPeriods else backtestPeriods
+    return backtestPeriods if backtestPeriods <= configManager.maxBacktestWindow else configManager.maxBacktestWindow
+
+def cleanFormattingForStatsData(calcForDate, saveResults, df):
+    if df is None or not isinstance(df, pd.DataFrame) or df.empty \
+        or saveResults is None or not isinstance(saveResults, pd.DataFrame) or saveResults.empty:
+        return df
+    df = df[
+            [
+                col
+                for col in df.columns
+                if ("ScanType" in col or "Pd-%" in col or "Pd-10k" in col)
+            ]
+        ]
+    df = df.replace(999999999, np.nan, regex=True)
+    df.dropna(axis=0, how="all", inplace=True)
+    df = formatGridOutput(df)
+    df.insert(
+            1,
+            "Date",
+            calcForDate if calcForDate is not None else saveResults["Date"].iloc[0],
+        )
+    
+    return df
+
+def getBacktestDataFromCleanedData(args, saveResults, df, periods,progressLabel:str=None):
+    '''
+    Important
+    ---------
+    You should have called `cleanupData` before calling this.
+    '''
+    for period in periods:
+        saveResults[f"LTP{period}"] = (
+                    saveResults[f"LTP{period}"].astype(float).fillna(0.0)
+                )
+        saveResults[f"Growth{period}"] = (
+                    saveResults[f"Growth{period}"].astype(float).fillna(0.0)
+                )
+
+    scanResults = statScanCalculations(args, saveResults, periods,progressLabel)
+
+    if df is None:
+        df = pd.DataFrame(scanResults)
+    else:
+        df1 = pd.DataFrame(scanResults)
+        df_target = df1[
+                    [col for col in df1.columns if ("Pd-%" in col or "Pd-10k" in col)]
+                ]
+        df = pd.concat([df, df_target], axis=1)
+    return df
+
+def statScanCalculationForNoFilter(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        userArgs, saveResults, period, scanResults = task.long_running_fn_args
+    else:
+        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
+    scanResults.append(
+                getCalculatedValues(saveResults, period, "NoFilter", userArgs,task)
+            )
+    if task is not None:
+        if task.taskId > 0:
+            task.resultsDict[task.taskId] = scanResults
+            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
+        else:
+            task.result = scanResults
+    return scanResults
+
+def statScanCalculationForPatterns(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        userArgs, saveResults, period, scanResults = task.long_running_fn_args
+    else:
+        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
+    df_grouped = saveResults.groupby("Pattern")
+    for pattern, df_group in df_grouped:
+        if pattern is None or len(pattern) == 0:
+            pattern = "No Pattern"
+        scanResults.append(
+                    getCalculatedValues(df_group, period, f"[P]{pattern}", userArgs,task)
+                )
+    if task is not None:
+        if task.taskId > 0:
+            task.resultsDict[task.taskId] = scanResults
+            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
+        else:
+            task.result = scanResults
+    return scanResults
+
+def ensureColumnsExist(saveResults):
+    columns = ['Stock', 'Date', 'Volume', 'Trend', 'MA-Signal', 'LTP', '52Wk H',
+               '52Wk L', '1-Pd', '2-Pd', '3-Pd', '4-Pd', '5-Pd', '10-Pd', '15-Pd',
+               '22-Pd', '30-Pd', 'Consol.', 'Breakout', 'RSI', 'Pattern', 'CCI',
+               'LTP1', 'Growth1', 'LTP2', 'Growth2', 'LTP3', 'Growth3', 'LTP4',
+               'Growth4', 'LTP5', 'Growth5', 'LTP10', 'Growth10', 'LTP15', 'Growth15',
+               'LTP22', 'Growth22', 'LTP30', 'Growth30']
+    if saveResults is None:
+        saveResults = pd.DataFrame(columns=columns)
+    else:
+        for col in columns:
+            if col not in saveResults.columns:
+                saveResults[col] = ""
+    return saveResults
+
+def cleanupData(savedResults):
+    saveResults = savedResults.copy()
+    saveResults = ensureColumnsExist(saveResults)
+    for col in saveResults.columns:
+        saveResults.loc[:, col] = saveResults.loc[:, col].apply(
+                lambda x: Utility.tools.removeAllColorStyles(x)
+            )
+
+    saveResults["LTP"] = saveResults["LTP"].astype(float).fillna(0.0)
+    saveResults["RSI"] = saveResults["RSI"].astype(float).fillna(0.0)
+    saveResults.loc[:, "Volume"] = saveResults.loc[:, "Volume"].apply(
+            lambda x: x.replace("x", "")
+        )
+    if f"Trend({configManager.daysToLookback}Prds)" not in saveResults.columns:
+        saveResults.rename(
+                columns={
+                    # "Consol.": f"Consol.({configManager.daysToLookback}Prds)",
+                    "Trend": f"Trend({configManager.daysToLookback}Prds)",
+                    "Breakout": f"Breakout({configManager.daysToLookback}Prds)",
+                },
+                inplace=True,
+            )
+    saveResults.loc[:, f"Consol."] = saveResults.loc[
+            :, f"Consol."
+        ].apply(lambda x: x.replace("Range:", "").replace("%", ""))
+    saveResults[["Breakout", "Resistance"]] = saveResults[
+            f"Breakout({configManager.daysToLookback}Prds)"
+        ].str.split(" R: ", n=1, expand=True)
+    saveResults.loc[:, "Breakout"] = saveResults.loc[:, "Breakout"].apply(
+            lambda x: x.replace("BO: ", "").replace(" ", "")
+        )
+    saveResults.loc[:, "Resistance"] = saveResults.loc[
+            :, "Resistance"
+        ].apply(lambda x: x.replace("(Potential)", "") if x is not None else x)
+    saveResults["Volume"] = saveResults["Volume"].astype(float).fillna(0.0)
+    saveResults[f"Consol."] = (
+            saveResults[f"Consol."].astype(float).fillna(0.0)
+        )
+    saveResults["Breakout"] = saveResults["Breakout"].astype(float).fillna(0.0)
+    saveResults["Resistance"] = saveResults["Resistance"].astype(float).fillna(0.0)
+    saveResults["52Wk H"] = saveResults["52Wk H"].astype(float).fillna(0.0)
+    saveResults["52Wk L"] = saveResults["52Wk L"].astype(float).fillna(0.0)
+    saveResults["CCI"] = saveResults["CCI"].astype(float).fillna(0.0)
+    return saveResults
+
+def getbacktestPeriod(args):
+    backtestPeriods = configManager.maxBacktestWindow  # Max backtest days
+    if args is None or ((not isinstance(args,int)) and (not isinstance(args,Namespace))):
+        return backtestPeriods
+    if args is not None and args.backtestdaysago is not None:
+        try:
+            backtestPeriods = int(args.backtestdaysago)
+        except Exception as e:# pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            pass
+    return backtestPeriods
+
+def statScanCalculations(userArgs, saveResults, periods,progressLabel:str=None):
+    scanResults = []
+    task1 = PKTask(f"[{len(saveResults)}] RSI Stats",long_running_fn=statScanCalculationForRSI)
+    task2 = PKTask(f"[{len(saveResults)}] Trend Stats",long_running_fn=statScanCalculationForTrend)
+    task3 = PKTask(f"[{len(saveResults)}] MA Stats",long_running_fn=statScanCalculationForMA)
+    task4 = PKTask(f"[{len(saveResults)}] Volume Stats",long_running_fn=statScanCalculationForVol)
+    task5 = PKTask(f"[{len(saveResults)}] Consolidation Stats",long_running_fn=statScanCalculationForConsol)
+    task6 = PKTask(f"[{len(saveResults)}] Breakout Stats",long_running_fn=statScanCalculationForBO)
+    task7 = PKTask(f"[{len(saveResults)}] 52Week Stats",long_running_fn=statScanCalculationFor52Wk)
+    task8 = PKTask(f"[{len(saveResults)}] CCI Stats",long_running_fn=statScanCalculationForCCI)
+    task9 = PKTask(f"[{len(saveResults)}] CCI Stats",long_running_fn=statScanCalculationForPatterns)
+    task10 = PKTask(f"[{len(saveResults)}] NoFilter Stats",long_running_fn=statScanCalculationForNoFilter)
+    tasksList=[task1,task2,task3,task4,task5,task6,task7,task8,task9,task10]
+    for task in tasksList:
+        task.long_running_fn_args = (userArgs, saveResults, periods, scanResults)
+    if configManager.enablePortfolioCalculations:
+        PKScheduler.scheduleTasks(tasksList,label=progressLabel,showProgressBars=True,timeout=600)
+    else:
+        for task in tasksList:
+            task.long_running_fn(*(task,))
+    for task in tasksList:
+        if task.result is not None and len(task.result) > 0:
+            scanResults.extend(task.result)
+    return scanResults
+
+def statScanCalculationForCCI(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        userArgs, saveResults, period, scanResults = task.long_running_fn_args
+    else:
+        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
+    scanResults.append(
+                getCalculatedValues(
+                    filterCCIBelowMinus100(saveResults), period, "[CCI]<=-100", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterCCIBelow0(saveResults), period, "[CCI]-100<C<0", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterCCI0To100(saveResults), period, "[CCI]0<=C<=100", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterCCI100To200(saveResults), period, "[CCI]100<C<=200", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterCCIAbove200(saveResults), period, "[CCI]>200", userArgs,task
+                )
+            )
+    if task is not None:
+        if task.taskId > 0:
+            task.resultsDict[task.taskId] = scanResults
+            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
+        else:
+            task.result = scanResults
+    return scanResults
+
+def statScanCalculationFor52Wk(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        userArgs, saveResults, period, scanResults = task.long_running_fn_args
+    else:
+        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
+    scanResults.append(
+                getCalculatedValues(
+                    filterLTPMoreOREqual52WkH(saveResults), period, "[52Wk]LTP>=H", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterLTPWithin90Percent52WkH(saveResults),
+                    period,
+                    "[52Wk]LTP>=.9*H",
+                    userArgs,
+                    task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterLTPLess90Percent52WkH(saveResults),
+                    period,
+                    "[52Wk]LTP<.9*H",
+                    userArgs,
+                    task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterLTPMore52WkL(saveResults), period, "[52Wk]LTP>L", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterLTPWithin90Percent52WkL(saveResults),
+                    period,
+                    "[52Wk]LTP>=1.1*L",
+                    userArgs,
+                    task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterLTPLess52WkL(saveResults), period, "[52Wk]LTP<=L", userArgs,task
+                )
+            )
+    if task is not None:
+        if task.taskId > 0:
+            task.resultsDict[task.taskId] = scanResults
+            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
+        else:
+            task.result = scanResults
+    return scanResults
+
+def statScanCalculationForBO(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        userArgs, saveResults, period, scanResults = task.long_running_fn_args
+    else:
+        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
+    scanResults.append(
+                getCalculatedValues(
+                    filterLTPLessThanBreakout(saveResults), period, "[BO]LTP<BO", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterLTPMoreOREqualBreakout(saveResults),
+                    period,
+                    "[BO]LTP>=BO",
+                    userArgs,
+                    task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterLTPLessThanResistance(saveResults), period, "[BO]LTP<R", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterLTPMoreOREqualResistance(saveResults),
+                    period,
+                    "[BO]LTP>=R",
+                    userArgs,
+                    task
+                )
+            )
+    if task is not None:
+        if task.taskId > 0:
+            task.resultsDict[task.taskId] = scanResults
+            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
+        else:
+            task.result = scanResults
+    return scanResults
+
+def statScanCalculationForConsol(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        userArgs, saveResults, period, scanResults = task.long_running_fn_args
+    else:
+        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
+    scanResults.append(
+                getCalculatedValues(
+                    filterConsolidating10Percent(saveResults), period, "Cons.<=10", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterConsolidatingMore10Percent(saveResults),
+                    period,
+                    "Cons.>10",
+                    userArgs,
+                    task
+                )
+            )
+    if task is not None:
+        if task.taskId > 0:
+            task.resultsDict[task.taskId] = scanResults
+            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
+        else:
+            task.result = scanResults
+    return scanResults
+
+def statScanCalculationForVol(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        userArgs, saveResults, period, scanResults = task.long_running_fn_args
+    else:
+        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
+    scanResults.append(
+                getCalculatedValues(
+                    filterVolumeLessThan25(saveResults), period, "Vol<2.5", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterVolumeMoreThan25(saveResults), period, "Vol>=2.5", userArgs,task
+                )
+            )
+    if task is not None:
+        if task.taskId > 0:
+            task.resultsDict[task.taskId] = scanResults
+            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
+        else:
+            task.result = scanResults
+    return scanResults
+
+def statScanCalculationForMA(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        userArgs, saveResults, period, scanResults = task.long_running_fn_args
+    else:
+        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
+    scanResults.append(
+                getCalculatedValues(
+                    filterMASignalBullish(saveResults), period, "[MA]Bull", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterMASignalBearish(saveResults), period, "[MA]Bear", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterMASignalNeutral(saveResults), period, "[MA]Neutral", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterMASignalBullCross(saveResults), period, "[MA]BullCross", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterMASignalBearCross(saveResults), period, "[MA]BearCross", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterMASignalSupport(saveResults), period, "[MA]Support", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterMASignalResist(saveResults), period, "[MA]Resist", userArgs,task
+                )
+            )
+    if task is not None:
+        if task.taskId > 0:
+            task.resultsDict[task.taskId] = scanResults
+            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
+        else:
+            task.result = scanResults
+    return scanResults
+
+def statScanCalculationForTrend(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        userArgs, saveResults, period, scanResults = task.long_running_fn_args
+    else:
+        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
+    scanResults.append(
+                getCalculatedValues(
+                    filterTrendStrongUp(saveResults), period, "[T]StrongUp", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterTrendWeakUp(saveResults), period, "[T]WeakUp", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterTrendUp(saveResults), period, "[T]TrendUp", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterTrendStrongDown(saveResults), period, "[T]StrongDown", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterTrendWeakDown(saveResults), period, "[T]WeakDown", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterTrendSideways(saveResults), period, "[T]Sideways", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterTrendDown(saveResults), period, "[T]TrendDown", userArgs,task
+                )
+            )
+    if task is not None:
+        if task.taskId > 0:
+            task.resultsDict[task.taskId] = scanResults
+            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
+        else:
+            task.result = scanResults
+    return scanResults
+
+def statScanCalculationForRSI(*args, **kwargs):
+    task = None
+    if isinstance(args[0], PKTask):
+        task = args[0]
+        userArgs, saveResults, period, scanResults = task.long_running_fn_args
+    else:
+        userArgs, saveResults, period, scanResults = args[0],args[1],args[2],args[3]
+    scanResults.append(
+                getCalculatedValues(
+                    filterRSIAbove50(saveResults), period, "[RSI]>=50", userArgs, task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterRSI50To67(saveResults), period, "[RSI]50<=RSI<=67", userArgs,task
+                )
+            )
+    scanResults.append(
+                getCalculatedValues(
+                    filterRSI68OrAbove(saveResults), period, "[RSI]>=68", userArgs,task
+                )
+            )
+    if task is not None:
+        if task.taskId > 0:
+            task.resultsDict[task.taskId] = scanResults
+            task.progressStatusDict[task.taskId] = {'progress': 1, 'total': 1}
+        else:
+            task.result = scanResults
+    return scanResults
+
+
+def formatGridOutput(df,replacenan=True):
+    if replacenan:
+        df = df.replace(np.nan, "-", regex=True)
+    for col in df.columns:
+        try:
+            df[col] = df[col].astype(float).fillna(0)
+        except ValueError as e:
+            if len(str(e).split("-")) < 2:
+                # We want to allow value "-" in column values
+                # We don't want to allow '2024-12-03' or 'RSI >=50' or "Trends-50-to-60"
+                pass
+            else:
+                continue
+        except Exception as e:# pragma: no cover
+            default_logger().debug(f"For column:{col}:\n{e}", exc_info=True)
+            continue
+        maxGrowth = df[col].max()
+        if "Pd-%" in col:
+            df.loc[:, col] = df.loc[:, col].apply(
+                lambda x: x
+                if (str(x) == "-")
+                else (
+                    str(x).replace(
+                        str(x),
+                        (
+                            (
+                                (colorText.BOLD + colorText.WHITE)
+                                if x == maxGrowth
+                                else colorText.GREEN
+                            )
+                            if float(x) > 0
+                            else (colorText.FAIL if float(x) < 0 else colorText.WARN)
+                        )
+                        + str(float(x))
+                        + " %"
+                        + colorText.END,
+                    )
+                )
+            )
+        if "Pd-10k" in col:
+            df.loc[:, col] = df.loc[:, col].apply(
+                lambda x: x
+                if (str(x) == "-")
+                else (
+                    str(x).replace(
+                        str(x),
+                        (
+                            (
+                                (colorText.BOLD + colorText.WHITE)
+                                if x == maxGrowth
+                                else colorText.GREEN
+                            )
+                            if (float(x) > 10000)
+                            else (
+                                colorText.FAIL if float(x) < 10000 else colorText.WARN
+                            )
+                        )
+                        + str(x)
+                        + colorText.END,
+                    )
+                )
+            )
+    df = df.replace(np.nan, "-", regex=True)
+    df = df.replace(colorText.FAIL + "-100.0 %" + colorText.END, "-", regex=False)
+    df = df.replace(colorText.WARN + "0.0 %" + colorText.END, "-", regex=False)
+    df = df.replace(colorText.FAIL + "0.0" + colorText.END, "-", regex=False)
+    return df
+
+
+def getCalculatedValues(df, periods, key, userArgs=None, task=None):
+    collated_df = None
+    for period in periods:
+        ltpSum1ShareEach = round(df["LTP"].sum(), 2)
+        tdySum1ShareEach = round(df[f"LTP{period}"].sum(), 2)
+        growthSum1ShareEach = round(df[f"Growth{period}"].sum(), 2)
+        percentGrowth = 0
+        if ltpSum1ShareEach > 0:
+            percentGrowth = round(100 * growthSum1ShareEach / ltpSum1ShareEach, 2)
+        growth10k = round(10000 * (1 + 0.01 * percentGrowth), 2)
+        if configManager.enablePortfolioCalculations and userArgs.options.startswith("B"): # backtests
+            portfolio = Portfolio(name=key)
+            portfolio.updatePortfolioFromXRayDataFrame(df,configManager.periodsRange,task)
+            PortfolioCollection().addPortfolio(portfolio)
+        result_df = {
+            "ScanType": key, #if tdySum1ShareEach != 0 else 999999999,
+            f"{period}Pd-PFV": tdySum1ShareEach,
+            f"{period}Pd-%": percentGrowth if tdySum1ShareEach != 0 else 999999999,
+            f"{period}Pd-10k": growth10k if tdySum1ShareEach != 0 else 999999999,
+        }
+        if collated_df is None:
+            collated_df = result_df
+        collated_df = collated_df | result_df
+    # percentGrowth = colorText.GREEN if percentGrowth >=0 else colorText.FAIL + percentGrowth + colorText.END
+    # growth10k = colorText.GREEN if percentGrowth >=0 else colorText.FAIL + growth10k + colorText.END
+    # df_col = {'ScanType':key,
+    #     f'{period}Pd-PFV':tdySum1ShareEach,
+    #     f'{period}Pd-PFG':percentGrowth if tdySum1ShareEach != 0 else '-',
+    #     f'{period}Pd-Go10k':growth10k if tdySum1ShareEach != 0 else '-',
+    #     }
+
+    return collated_df  # , df_col
+
+
+def filterRSIAbove50(df):
+    if df is None:
+        return None
+    return df[df["RSI"] > 50].fillna(0.0)
+
+
+def filterRSI50To67(df):
+    if df is None:
+        return None
+    return df[(df["RSI"] >= 50) & (df["RSI"] <= 67)].fillna(0.0)
+
+
+def filterRSI68OrAbove(df):
+    if df is None:
+        return None
+    return df[df["RSI"] >= 68].fillna(0.0)
+
+
+def filterTrendStrongUp(df):
+    if df is None:
+        return None
+    return df[df[f"Trend({configManager.daysToLookback}Prds)"] == "Strong Up"].fillna(0.0)
+
+
+def filterTrendWeakUp(df):
+    if df is None:
+        return None
+    return df[df[f"Trend({configManager.daysToLookback}Prds)"] == "Weak Up"].fillna(0.0)
+
+
+def filterTrendWeakDown(df):
+    if df is None:
+        return None
+    return df[df[f"Trend({configManager.daysToLookback}Prds)"] == "Weak Down"].fillna(0.0)
+
+
+def filterTrendStrongDown(df):
+    if df is None:
+        return None
+    return df[df[f"Trend({configManager.daysToLookback}Prds)"] == "Strong Down"].fillna(0.0)
+
+
+def filterTrendUp(df):
+    if df is None:
+        return None
+    return df[df[f"Trend({configManager.daysToLookback}Prds)"].astype(str).str.endswith("Up")].fillna(0.0)
+
+
+def filterTrendSideways(df):
+    if df is None:
+        return None
+    return df[df[f"Trend({configManager.daysToLookback}Prds)"] == "Sideways"].fillna(0.0)
+
+
+def filterTrendDown(df):
+    if df is None:
+        return None
+    return df[df[f"Trend({configManager.daysToLookback}Prds)"].astype(str).str.endswith("Down")].fillna(0.0)
+
+
+def filterMASignalBullish(df):
+    if df is None:
+        return None
+    return df[df["MA-Signal"] == "Bullish"].fillna(0.0)
+
+
+def filterMASignalBearish(df):
+    if df is None:
+        return None
+    return df[df["MA-Signal"] == "Bearish"].fillna(0.0)
+
+
+def filterMASignalNeutral(df):
+    if df is None:
+        return None
+    return df[df["MA-Signal"] == "Neutral"].fillna(0.0)
+
+
+def filterMASignalBullCross(df):
+    if df is None:
+        return None
+    return df[df["MA-Signal"].astype(str).str.startswith("BullCross")].fillna(0.0)
+
+
+def filterMASignalBearCross(df):
+    if df is None:
+        return None
+    return df[df["MA-Signal"].astype(str).str.startswith("BearCross")].fillna(0.0)
+
+
+def filterMASignalSupport(df):
+    if df is None:
+        return None
+    return df[df["MA-Signal"].astype(str).str.endswith("Support")].fillna(0.0)
+
+
+def filterMASignalResist(df):
+    if df is None:
+        return None
+    return df[df["MA-Signal"].astype(str).str.endswith("Resist")].fillna(0.0)
+
+
+def filterVolumeLessThan25(df):
+    if df is None:
+        return None
+    return df[df["Volume"] < 2.5].fillna(0.0)
+
+
+def filterVolumeMoreThan25(df):
+    if df is None:
+        return None
+    return df[df["Volume"] >= 2.5].fillna(0.0)
+
+
+def filterConsolidating10Percent(df):
+    if df is None:
+        return None
+    return df[df[f"Consol."] <= 10].fillna(0.0)
+
+
+def filterConsolidatingMore10Percent(df):
+    if df is None:
+        return None
+    return df[df[f"Consol."] > 10].fillna(0.0)
+
+
+def filterLTPLessThanBreakout(df):
+    if df is None:
+        return None
+    return df[df["LTP"] < df["Breakout"]].fillna(0.0)
+
+
+def filterLTPMoreOREqualBreakout(df):
+    if df is None:
+        return None
+    return df[((df["Breakout"] > 0) & (df["LTP"] >= df["Breakout"]))].fillna(0.0)
+
+
+def filterLTPLessThanResistance(df):
+    if df is None:
+        return None
+    return df[df["LTP"] < df["Resistance"]].fillna(0.0)
+
+
+def filterLTPMoreOREqualResistance(df):
+    if df is None:
+        return None
+    return df[((df["Resistance"] > 0) & (df["LTP"] >= df["Resistance"]))].fillna(0.0)
+
+
+def filterLTPMoreOREqual52WkH(df):
+    if df is None:
+        return None
+    return df[df["LTP"] >= df["52Wk H"]].fillna(0.0)
+
+
+def filterLTPWithin90Percent52WkH(df):
+    if df is None:
+        return None
+    return df[(df["LTP"] >= 0.9 * df["52Wk H"]) & (df["LTP"] < df["52Wk H"])].fillna(
+        0.0
+    )
+
+
+def filterLTPLess90Percent52WkH(df):
+    if df is None:
+        return None
+    return df[df["LTP"] < 0.9 * df["52Wk H"]].fillna(0.0)
+
+
+def filterLTPMore52WkL(df):
+    if df is None:
+        return None
+    return df[((df["LTP"] > df["52Wk L"]) & (df["LTP"] < 1.1 * df["52Wk L"]))].fillna(
+        0.0
+    )
+
+
+def filterLTPWithin90Percent52WkL(df):
+    if df is None:
+        return None
+    return df[(df["LTP"] >= (1.1 * df["52Wk L"])) & (df["LTP"] > df["52Wk L"])].fillna(
+        0.0
+    )
+
+
+def filterLTPLess52WkL(df):
+    if df is None:
+        return None
+    return df[df["LTP"] <= df["52Wk L"]].fillna(0.0)
+
+
+def filterCCIBelowMinus100(df):
+    if df is None:
+        return None
+    return df[df["CCI"] <= -100].fillna(0.0)
+
+
+def filterCCIBelow0(df):
+    if df is None:
+        return None
+    return df[(df["CCI"] > -100) & (df["CCI"] < 0)].fillna(0.0)
+
+
+def filterCCI0To100(df):
+    if df is None:
+        return None
+    return df[(df["CCI"] >= 0) & (df["CCI"] <= 100)].fillna(0.0)
+
+
+def filterCCI100To200(df):
+    if df is None:
+        return None
+    return df[(df["CCI"] > 100) & (df["CCI"] <= 200)].fillna(0.0)
+
+
+def filterCCIAbove200(df):
+    if df is None:
+        return None
+    return df[(df["CCI"] > 200)].fillna(0.0)
+
+def returnNoFilter(df):
+    return df
+
+def filterPattern(df, pattern="[P]No Pattern"):
+    if df is None:
+        return None
+    match_df = None
+    df_grouped = df.groupby("Pattern")
+    for foundPattern, df_group in df_grouped:
+        if foundPattern is None or len(foundPattern) == 0:
+            foundPattern = "No Pattern"
+        if f"[P]{foundPattern}" == pattern:
+            match_df = df_group
+            break
+    return match_df
+
+def strategyDictionary():
+    """
+    Available Strategies:
+
+    RSI
+    ---
+    `RSI>=50`, `50<=RSI<=67` and `RSI>=68`
+
+    CCI
+    ---
+    `[CCI]<=-100`, `[CCI]-100<C<0`, `[CCI]0<=C<=100`, `[CCI]100<C<=200` and `[CCI]>200`
+
+    52Wk H/L
+    --------
+    `[52Wk]LTP>=H`, `[52Wk]LTP>=.9*H`, `[52Wk]LTP<.9*H`, `[52Wk]LTP>L`, `[52Wk]LTP>=1.1*L` and `[52Wk]LTP<=L`
+
+    Breakout
+    --------
+    `[BO]LTP<BO`, `[BO]LTP>=BO`, `[BO]LTP<R` and `[BO]LTP>=R`
+
+    Consolidation
+    -------------
+    `Cons.<=10` and Cons.>10
+
+    Volume
+    ------
+    `Vol<2.5` and `Vol>=2.5`
+
+    Moving Averages
+    ---------------
+    `[MA]Bull`, `[MA]Bear`, `[MA]Neutral`, `[MA]BullCross`, `[MA]BearCross`, `[MA]Support` and `[MA]Resist`
+
+    Trends
+    ------
+    `[T]StrongUp`, `[T]WeakUp`, `[T]TrendUp`, `[T]StrongDown`, `[T]WeakDown`, `[T]Sideways` and `[T]TrendDown`
+
+    NoFilter
+    --------
+    `NoFilter`
+
+    Patterns
+    --------
+    `[P]{patern_name}`. For example, `[P]No Pattern`
+    """
+    strategies = {}
+    # RSI
+    strategies["[RSI]>=50"] = filterRSIAbove50
+    strategies["[RSI]50<=RSI<=67"] = filterRSI50To67
+    strategies["[RSI]>=68"] = filterRSI68OrAbove
+    # CCI
+    strategies["[CCI]<=-100"] = filterCCIBelowMinus100
+    strategies["[CCI]-100<C<0"] = filterCCIBelow0
+    strategies["[CCI]0<=C<=100"] = filterCCI0To100
+    strategies["[CCI]100<C<=200"] = filterCCI100To200
+    strategies["[CCI]>200"] = filterCCIAbove200
+    # 52Wk H/L
+    strategies["[52Wk]LTP>=H"] = filterLTPMoreOREqual52WkH
+    strategies["[52Wk]LTP>=.9*H"] = filterLTPWithin90Percent52WkH
+    strategies["[52Wk]LTP<.9*H"] = filterLTPLess90Percent52WkH
+    strategies["[52Wk]LTP>L"] = filterLTPMore52WkL
+    strategies["[52Wk]LTP>=1.1*L"] = filterLTPWithin90Percent52WkL
+    strategies["[52Wk]LTP<=L"] = filterLTPLess52WkL
+    # Breakout
+    strategies["[BO]LTP<BO"] = filterLTPLessThanBreakout
+    strategies["[BO]LTP>=BO"] = filterLTPMoreOREqualBreakout
+    strategies["[BO]LTP<R"] = filterLTPLessThanResistance
+    strategies["[BO]LTP>=R"] = filterLTPMoreOREqualResistance
+    # Consolidation
+    strategies["Cons.<=10"] = filterConsolidating10Percent
+    strategies["Cons.>10"] = filterConsolidatingMore10Percent
+    # Volume
+    strategies["Vol<2.5"] = filterVolumeLessThan25
+    strategies["Vol>=2.5"] = filterVolumeMoreThan25
+    # MA
+    strategies["[MA]Bull"] = filterMASignalBullish
+    strategies["[MA]Bear"] = filterMASignalBearish
+    strategies["[MA]Neutral"] = filterMASignalNeutral
+    strategies["[MA]BullCross"] = filterMASignalBullCross
+    strategies["[MA]BearCross"] = filterMASignalBearCross
+    strategies["[MA]Support"] = filterMASignalSupport
+    strategies["[MA]Resist"] = filterMASignalResist
+    # Trends
+    strategies["[T]StrongUp"] = filterTrendStrongUp
+    strategies["[T]WeakUp"] = filterTrendWeakUp
+    strategies["[T]TrendUp"] = filterTrendUp
+    strategies["[T]StrongDown"] = filterTrendStrongDown
+    strategies["[T]WeakDown"] = filterTrendWeakDown
+    strategies["[T]Sideways"] = filterTrendSideways
+    strategies["[T]TrendDown"] = filterTrendDown
+    # NoFilter
+    strategies["NoFilter"] = returnNoFilter
+    # Pattern
+    strategies["[P]"] = filterPattern
+    return strategies
+
+def strategyForKey(key:str):
+    strategies = strategyDictionary()
+    if key in strategies.keys():
+        return strategies[key]
+    elif key.startswith("[P]"):
+        return strategies["[P]"]
+
+def strategyNames():
     return strategyDictionary().keys()
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/StockScreener.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/StockScreener.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,1038 +1,1038 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import os
-import logging
-import sys
-import time
-import warnings
-
-import numpy as np
-
-warnings.simplefilter("ignore", DeprecationWarning)
-warnings.simplefilter("ignore", FutureWarning)
-import pandas as pd
-# from PKDevTools.classes.log import tracelog
-# from PKDevTools.classes.PKTimer import PKTimer
-from PKDevTools.classes import Archiver
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.Fetcher import StockDataEmptyException
-from PKDevTools.classes.SuppressOutput import SuppressOutput
-from PKDevTools.classes.PKDateUtilities import PKDateUtilities
-
-import pkscreener.classes.ScreeningStatistics as ScreeningStatistics
-from pkscreener import Imports
-from pkscreener.classes.CandlePatterns import CandlePatterns
-from PKDevTools.classes.OutputControls import OutputControls
-
-class StockScreener:
-    def __init__(self):
-        self.isTradingTime = PKDateUtilities.isTradingTime()
-        self.configManager = None
-
-    # @tracelog
-    def screenStocks(
-        self,
-        menuOption,
-        exchangeName,
-        executeOption,
-        reversalOption,
-        maLength,
-        daysForLowestVolume,
-        minRSI,
-        maxRSI,
-        respChartPattern,
-        insideBarToLookback,
-        totalSymbols,
-        shouldCache,
-        stock,
-        newlyListedOnly,
-        downloadOnly,
-        volumeRatio,
-        testbuild=False,
-        userArgs=None,
-        backtestDuration=0,
-        backtestPeriodToLookback=30,
-        logLevel=logging.NOTSET,
-        portfolio=False,
-        testData = None,
-        hostRef=None,
-    ):
-        assert (
-            hostRef is not None
-        ), "hostRef argument must not be None. It should be an instance of PKMultiProcessorClient"
-        configManager = hostRef.configManager
-        self.configManager = configManager
-        screeningDictionary, saveDictionary = self.initResultDictionaries()
-        fullData = None
-        processedData = None
-        fetcher = hostRef.fetcher
-        screener = hostRef.screener
-        candlePatterns = hostRef.candlePatterns
-        printCounter = userArgs.log if (userArgs is not None and userArgs.log is not None) else False
-        userArgsLog = printCounter
-        start_time = time.time()
-        try:
-            with hostRef.processingCounter.get_lock():
-                hostRef.processingCounter.value += 1
-
-            volumeRatio, period = self.determineBasicConfigs(stock, newlyListedOnly, volumeRatio, logLevel, hostRef, configManager, screener, userArgsLog)
-            # hostRef.default_logger.info(
-            #     f"For stock:{stock}, stock exists in objectDictionary:{hostRef.objectDictionaryPrimary.get(stock)}, cacheEnabled:{configManager.cacheEnabled}, isTradingTime:{self.isTradingTime}, downloadOnly:{downloadOnly}"
-            # )
-            data = None
-            data = self.getRelevantDataForStock(totalSymbols, shouldCache, stock, downloadOnly, printCounter, backtestDuration, hostRef,hostRef.objectDictionaryPrimary, configManager, fetcher, period,None, testData,exchangeName)
-            if not configManager.isIntradayConfig() and configManager.calculatersiintraday:
-                # Daily data is already available in "data" above.
-                # We need the intraday data for 1-d RSI values when config is not for intraday
-                intraday_data = self.getRelevantDataForStock(totalSymbols, shouldCache, stock, downloadOnly, printCounter, backtestDuration, hostRef, hostRef.objectDictionarySecondary, configManager, fetcher, "1d","1m", testData,exchangeName)
-                
-            if data is not None:
-                if len(data) == 0 or data.empty or len(data) < backtestDuration:
-                    raise StockDataEmptyException(f"Data length:{len(data)}")
-            else:
-                raise StockDataEmptyException(f"Data is None: {data}")
-            
-            bidGreaterThanAsk = False
-            bidAskRatio = 0
-            if executeOption == 29:
-                hostRef.intradayNSEFetcher.symbol = stock.upper()
-                priceData = hostRef.intradayNSEFetcher.price_order_info()
-                if priceData is not None:
-                    try:
-                        totalBid = priceData["BidQty"].iloc[0]
-                    except:
-                        totalBid = 0
-                        pass
-                    try:
-                        totalAsk = priceData["AskQty"].iloc[0]
-                    except:
-                        totalAsk = 0
-                        pass
-                    try:
-                        lwrCP = float(priceData["LwrCP"].iloc[0])
-                    except:
-                        lwrCP = 0
-                        pass
-                    try:
-                        uprCP = float(priceData["UprCP"].iloc[0])
-                    except:
-                        uprCP = 0
-                        pass
-                    try:
-                        vwap = float(priceData["VWAP"].iloc[0])
-                    except:
-                        vwap = 0
-                        pass
-                    try:
-                        dayVola = float(priceData["DayVola"].iloc[0])
-                    except:
-                        dayVola = 0
-                        pass
-                    try:
-                        delPercent = priceData["Del(%)"].iloc[0]
-                    except:
-                        delPercent = 0
-                        pass
-                    try:
-                        ltp = priceData["LTP"].iloc[0]
-                    except:
-                        ltp = 0
-                        pass
-                    
-                    bidAskSimulate = userArgs is not None and userArgs.simulate is not None and "BidAsk" in userArgs.simulate.keys()
-                    if (totalBid > totalAsk and \
-                        ltp < uprCP and \
-                        ltp > lwrCP) or bidAskSimulate:
-                        bidGreaterThanAsk = True
-                        bidAskRatio = round(totalBid/totalAsk,1) if totalAsk > 0 else (0 if not bidAskSimulate else 3)
-                        bidAskBuildupDict = {"BidQty":totalBid,"AskQty":totalAsk,"LwrCP":lwrCP,"UprCP":uprCP,"VWAP":vwap,"DayVola":dayVola,"Del(%)":delPercent}
-                        screeningDictionary.update(bidAskBuildupDict)
-                        saveDictionary.update(bidAskBuildupDict)
-                    else:
-                        raise ScreeningStatistics.EligibilityConditionNotMet("Bid/Ask Eligibility Not met.")
-                else:
-                    raise ScreeningStatistics.EligibilityConditionNotMet("Bid/Ask Eligibility Not met.")
-            # hostRef.default_logger.info(f"Will pre-process data:\n{data.tail(10)}")
-            fullData, processedData, data = self.getCleanedDataForDuration(backtestDuration, portfolio, screeningDictionary, saveDictionary, configManager, screener, data)
-            if "RUNNER" not in os.environ.keys() and backtestDuration == 0 and configManager.calculatersiintraday:
-                if (intraday_data is not None and not intraday_data.empty):
-                    intraday_fullData, intraday_processedData = screener.preprocessData(
-                        intraday_data, daysToLookback=configManager.effectiveDaysToLookback
-                    )
-                    # Match the index length and values length
-                    fullData = fullData.head(len(intraday_fullData))
-                    intraday_fullData = intraday_fullData.head(len(fullData))
-                    processedData = processedData.head(len(intraday_processedData))
-                    intraday_processedData = intraday_processedData.head(len(processedData))
-                    data = data.tail(len(intraday_data))
-                    intraday_data = intraday_data.tail(len(data))
-                    # Indexes won't match. Hence, we'd need to fallback on tolist
-                    processedData.insert(len(processedData.columns), "RSIi", intraday_processedData["RSI"].tolist())
-                    fullData.insert(len(fullData.columns), "RSIi", intraday_processedData["RSI"].tolist())
-                else:
-                    with SuppressOutput(suppress_stderr=(logLevel==logging.NOTSET), suppress_stdout=(not (printCounter or testbuild))):
-                        processedData.insert(len(processedData.columns), "RSIi", np.array(np.nan))
-                        fullData.insert(len(fullData.columns), "RSIi", np.array(np.nan))
-            else:
-                    with SuppressOutput(suppress_stderr=(logLevel==logging.NOTSET), suppress_stdout=(not (printCounter or testbuild))):
-                        processedData.insert(len(processedData.columns), "RSIi", np.array(np.nan))
-                        fullData.insert(len(fullData.columns), "RSIi", np.array(np.nan))
-
-            def returnLegibleData(exceptionMessage=None):
-                if backtestDuration == 0 or menuOption not in ["B"]:
-                    raise ScreeningStatistics.EligibilityConditionNotMet(exceptionMessage)
-                elif (backtestDuration > 0 and backtestDuration <= configManager.maxBacktestWindow):
-                    screener.validateMovingAverages(
-                        processedData, screeningDictionary, saveDictionary, maRange=1.25
-                    )
-                    screener.findTrend(
-                        processedData,
-                        screeningDictionary,
-                        saveDictionary,
-                        daysToLookback=configManager.daysToLookback,
-                        stockName=stock,
-                    )
-                    screener.find52WeekHighLow(
-                            fullData, saveDictionary, screeningDictionary
-                        )
-                    return (
-                            screeningDictionary,
-                            saveDictionary,
-                            data,
-                            stock,
-                            backtestDuration,
-                        )
-            if newlyListedOnly:
-                if not screener.validateNewlyListed(fullData, period):
-                    raise ScreeningStatistics.NotNewlyListed
-
-            if processedData.empty:
-                raise StockDataEmptyException("Empty processedData")
-            
-            with SuppressOutput(suppress_stderr=(logLevel==logging.NOTSET), suppress_stdout=(not (printCounter or testbuild))):
-                self.updateStock(stock, screeningDictionary, saveDictionary, executeOption, exchangeName)
-                
-                self.performBasicLTPChecks(executeOption, screeningDictionary, saveDictionary, fullData, configManager, screener, exchangeName)
-                hasMinVolumeRatio = self.performBasicVolumeChecks(executeOption, volumeRatio, screeningDictionary, saveDictionary, processedData, configManager, screener)
-                if bidGreaterThanAsk:
-                    if not hasMinVolumeRatio or bidAskRatio < 2:
-                        raise ScreeningStatistics.EligibilityConditionNotMet("Bid/Ask Eligibility Not met.")
-                isConfluence = False
-                isInsideBar = 0
-                isMaReversal = 0
-                isIpoBase = False
-                isMaSupport = False
-                isLorentzian = False
-                isVCP = False
-                isVSA = False
-                isNR = False
-                hasPsarRSIReversal = False
-                hasRisingRSIReversal = False
-                hasRSIMAReversal = False
-                isValidRsi = False
-                isBuyingTrendline = False
-                isMomentum = False
-                mfiStake = 0
-                fairValueDiff = 0
-                consolidationValue = 0
-                isBreaking = False
-                isValidCci = False
-                isVSA = False
-                isCandlePattern = False
-                isLowestVolume = False
-                hasBbandsSqz = False
-
-                isValidityCheckMet = self.performValidityCheckForExecuteOptions(executeOption,screener,fullData,screeningDictionary,saveDictionary,processedData,configManager,maLength)
-                if not isValidityCheckMet:
-                    return returnLegibleData("Validity Check not met!")
-                isShortTermBullish = (executeOption == 11 and isValidityCheckMet)
-                if newlyListedOnly:
-                    isIpoBase = screener.validateIpoBase(
-                        stock, fullData, screeningDictionary, saveDictionary
-                    )
-                if executeOption in [1,2]:
-                    isBreaking = screener.findBreakoutValue(
-                        processedData,
-                        screeningDictionary,
-                        saveDictionary,
-                        daysToLookback=configManager.daysToLookback,
-                        alreadyBrokenout=(executeOption == 2),
-                    )
-                    if executeOption == 1:
-                        isPotentialBreaking = screener.findPotentialBreakout(
-                            fullData,
-                            screeningDictionary,
-                            saveDictionary,
-                            daysToLookback=configManager.daysToLookback,
-                        )
-                        if not (isBreaking or isPotentialBreaking) or not hasMinVolumeRatio:
-                            return returnLegibleData(f"isBreaking:{isBreaking},isPotentialBreaking:{isPotentialBreaking},hasMinVolumeRatio:{hasMinVolumeRatio}")
-                    elif executeOption == 2:
-                        if not (isBreaking) or not hasMinVolumeRatio:
-                            return returnLegibleData(f"isBreaking:{isBreaking},hasMinVolumeRatio:{hasMinVolumeRatio}")
-                elif executeOption == 3:
-                    consolidationValue = screener.validateConsolidation(
-                        processedData,
-                        screeningDictionary,
-                        saveDictionary,
-                        percentage=configManager.consolidationPercentage,
-                    )
-                    if ((consolidationValue == 0 or consolidationValue > configManager.consolidationPercentage)):
-                        return returnLegibleData(f"consolidationValue:{consolidationValue}")
-                elif executeOption == 4:
-                    isLowestVolume = screener.validateLowestVolume(
-                        processedData, daysForLowestVolume
-                    )
-                    if not isLowestVolume:
-                        return returnLegibleData(f"isLowestVolume:{isLowestVolume}")
-                elif executeOption == 5:
-                    isValidRsi = screener.validateRSI(
-                        processedData, screeningDictionary, saveDictionary, minRSI, maxRSI
-                    )
-                    if not isValidRsi:
-                        return returnLegibleData(f"isValidRsi:{isValidRsi}")
-                elif executeOption == 6:
-                    if reversalOption == 10:
-                        hasRSIMAReversal = screener.findRSICrossingMA(processedData,
-                                                                      screeningDictionary,
-                                                                      saveDictionary,
-                                                                      lookFor=maLength) # 1 =Buy, 2 =Sell, 3 = Any
-                        if not hasRSIMAReversal:
-                            return returnLegibleData(f"hasRSIMAReversal:{hasRSIMAReversal}")
-                    elif reversalOption == 9:
-                        hasRisingRSIReversal = screener.findRisingRSI(processedData)
-                        if not hasRisingRSIReversal:
-                            return returnLegibleData(f"hasRisingRSIReversal:{hasRisingRSIReversal}")
-                    elif reversalOption == 8:
-                        hasPsarRSIReversal = screener.findPSARReversalWithRSI(
-                            processedData,
-                            screeningDictionary,
-                            saveDictionary
-                            # minRSI=maLength if maLength is not None else 40,
-                        )
-                        if not hasPsarRSIReversal:
-                            return returnLegibleData(f"hasPsarRSIReversal:{hasPsarRSIReversal}")
-                    elif reversalOption == 6:
-                        isNR = screener.validateNarrowRange(
-                            processedData,
-                            screeningDictionary,
-                            saveDictionary,
-                            nr=maLength if maLength is not None else 4,
-                        )
-                        if not isNR:
-                            return returnLegibleData(f"isNR:{isNR}")
-                    elif reversalOption == 5:
-                        isVSA = screener.validateVolumeSpreadAnalysis(
-                            processedData, screeningDictionary, saveDictionary
-                        )
-                        if not isVSA:
-                            return returnLegibleData(f"isVSA:{isVSA}")
-                    elif reversalOption == 4 and maLength is not None:
-                        isMaSupport = screener.findReversalMA(
-                            fullData, screeningDictionary, saveDictionary, maLength
-                        )
-                        if not isMaSupport:
-                            return returnLegibleData(f"isMaSupport:{isMaSupport}")
-                    elif reversalOption == 7:
-                        if sys.version_info >= (3, 11):
-                            isLorentzian = screener.validateLorentzian(
-                                fullData,
-                                screeningDictionary,
-                                saveDictionary,
-                                lookFor=maLength, # 1 =Buy, 2 =Sell, 3 = Any
-                            )
-                            if not isLorentzian:
-                                return returnLegibleData(f"isLorentzian:{isLorentzian}")
-                elif executeOption == 7:
-                    if respChartPattern == 3:
-                        isConfluence = screener.validateConfluence(
-                            stock,
-                            processedData,
-                            screeningDictionary,
-                            saveDictionary,
-                            percentage=insideBarToLookback,
-                            confFilter=(maLength if maLength > 0 else 3) # 1 = Conf up, 2 = Conf Down, 3 = all
-                        )
-                        if not isConfluence:
-                            return returnLegibleData(f"isConfluence:{isConfluence}")
-                    elif respChartPattern == 4:
-                        isVCP = screener.validateVCP(
-                            fullData, screeningDictionary, saveDictionary
-                        )
-                        if not isVCP:
-                            return returnLegibleData(f"isVCP:{isVCP}")
-                    elif respChartPattern == 5:
-                        if Imports["scipy"]:
-                            isBuyingTrendline = screener.findTrendlines(
-                                fullData, screeningDictionary, saveDictionary
-                            )
-                            if not isBuyingTrendline:
-                                return returnLegibleData(f"isBuyingTrendline:{isBuyingTrendline}")
-                    elif respChartPattern == 6:
-                        hasBbandsSqz = screener.findBbandsSqueeze(fullData, screeningDictionary, saveDictionary, filter=(maLength if maLength > 0 else 4))
-                        if not hasBbandsSqz:
-                            return returnLegibleData(f"hasBbandsSqz:{hasBbandsSqz}")
-                    elif respChartPattern == 7:
-                        isCandlePattern = candlePatterns.findPattern(
-                        processedData, screeningDictionary, saveDictionary)
-                        if not isCandlePattern:
-                            return returnLegibleData(f"isCandlePattern:{isCandlePattern}")
-                        
-                elif executeOption == 10:
-                    isPriceRisingByAtLeast2Percent = (
-                        screener.validatePriceRisingByAtLeast2Percent(
-                            processedData, screeningDictionary, saveDictionary
-                        )
-                    )
-                    if not isPriceRisingByAtLeast2Percent:
-                        return returnLegibleData(f"isPriceRisingByAtLeast2Percent:{isPriceRisingByAtLeast2Percent}")
-                # Must-run, but only at the end
-                try:
-                    if executeOption != 7 or (executeOption == 7 and respChartPattern != 7):
-                    # Only 'doji' and 'inside' is internally implemented by pandas_ta.
-                    # Otherwise, for the rest of the candle patterns, they also need
-                    # TA-Lib. So if TA-Lib is not available, it will throw exception
-                    # We can live with no-patterns if user has not installed ta-lib
-                    # yet. If ta-lib is available, PKTalib will load it automatically.
-                        isCandlePattern = candlePatterns.findPattern(
-                            processedData, screeningDictionary, saveDictionary
-                        )
-                except Exception as e:  # pragma: no cover
-                    hostRef.default_logger.debug(e, exc_info=True)
-                    screeningDictionary["Pattern"] = ""
-                    saveDictionary["Pattern"] = ""
-
-                try:
-                    currentTrend = screener.findTrend(
-                        processedData,
-                        screeningDictionary,
-                        saveDictionary,
-                        daysToLookback=configManager.daysToLookback,
-                        stockName=stock,
-                    )
-                    if backtestDuration == 0:
-                        if executeOption == 21 and reversalOption in [3,5,6,7,8,9]:
-                            # Find general trend
-                            _,mfiStake,fairValueDiff = screener.findUptrend(
-                                fullData,
-                                screeningDictionary,
-                                saveDictionary,
-                                testbuild,
-                                stock,
-                                onlyMF=(executeOption == 21 and reversalOption in [5,6]),
-                                hostData=data,
-                                exchangeName=exchangeName,
-                                refreshMFAndFV=(menuOption in ["X"])
-                            )
-                            hostRef.objectDictionaryPrimary[stock] = data.to_dict("split")
-                except np.RankWarning as e: # pragma: no cover 
-                    hostRef.default_logger.debug(e, exc_info=True)
-                    screeningDictionary["Trend"] = "Unknown"
-                    saveDictionary["Trend"] = "Unknown"
-                # CCI also uses "Trend" value from findTrend above.
-                # So it must only be called after findTrend
-                if executeOption == 8:
-                    isValidCci = screener.validateCCI(
-                        processedData, screeningDictionary, saveDictionary, minRSI, maxRSI
-                    )
-                    if not isValidCci:
-                        return returnLegibleData(f"isValidCci:{isValidCci}")
-
-                if not (isConfluence or isShortTermBullish or isMaSupport):
-                    isMaReversal = screener.validateMovingAverages(
-                        processedData, screeningDictionary, saveDictionary, maRange=1.25
-                    )
-                if executeOption == 6:
-                    if reversalOption == 1 and not (str(saveDictionary["Pattern"]).split(",")[0]
-                                                                    in CandlePatterns.reversalPatternsBullish
-                                                                    or isMaReversal > 0):
-                        return returnLegibleData(f"reversalOption:{reversalOption},isMaReversal:{isMaReversal},{CandlePatterns.reversalPatternsBullish}")
-                    elif reversalOption == 2 and not (str(saveDictionary["Pattern"]).split(",")[0]
-                                                                    in CandlePatterns.reversalPatternsBearish
-                                                                    or isMaReversal < 0):
-                        return returnLegibleData(f"reversalOption:{reversalOption},isMaReversal:{isMaReversal},{CandlePatterns.reversalPatternsBearish}")
-                # validateInsideBar needs "Trend" to be already defined
-                # ValidateInsideBar also needs "MA-Signal" to be setup
-                if executeOption == 7 and respChartPattern < 3:
-                    isInsideBar = screener.validateInsideBar(
-                                processedData,
-                                screeningDictionary,
-                                saveDictionary,
-                                chartPattern=respChartPattern,
-                                daysToLookback=insideBarToLookback,
-                            )
-                    if isInsideBar ==0:
-                        return returnLegibleData(f"isInsideBar:{isInsideBar}")
-
-                if not (isLorentzian or (isInsideBar !=0) or isBuyingTrendline or isIpoBase or isNR or isVCP or isVSA):
-                    isMomentum = screener.validateMomentum(
-                        processedData, screeningDictionary, saveDictionary
-                    )
-                    if executeOption == 6 and reversalOption ==3 and not isMomentum:
-                        return returnLegibleData(f"executeOption:{executeOption},reversalOption:{reversalOption},isMomentum:{isMomentum}")
-
-                with hostRef.processingResultsCounter.get_lock():
-                    # hostRef.default_logger.debug(f"ExecuteOption:{executeOption}:{reversalOption}:{respChartPattern}:{maLength}. Elapsed: {time.time() - start_time}")
-                    if (
-                        (executeOption == 0)
-                        or ((
-                            (
-                                (executeOption == 1 and (isBreaking or isPotentialBreaking))
-                                or (executeOption == 2 and isBreaking)
-                            )
-                            and hasMinVolumeRatio
-                        ))
-                        or ((
-                            (executeOption == 3)
-                            and (
-                                consolidationValue <= configManager.consolidationPercentage
-                                and consolidationValue != 0
-                            )
-                        ))
-                        or (executeOption == 4 and isLowestVolume)
-                        or (executeOption == 5 and isValidRsi)
-                        or ((executeOption == 6) and ((reversalOption == 1 and (
-                                                                    str(saveDictionary["Pattern"]).split(",")[0]
-                                                                    in CandlePatterns.reversalPatternsBullish
-                                                                    or isMaReversal > 0
-                                                                ))
-                                                                or (reversalOption == 2 and (
-                                                                    str(saveDictionary["Pattern"]).split(",")[0]
-                                                                    in CandlePatterns.reversalPatternsBearish
-                                                                    or isMaReversal < 0
-                                                                ))
-                                                                or (reversalOption == 3 and isMomentum)
-                                                                or (reversalOption == 4 and isMaSupport)
-                                                                or ((
-                                                                    reversalOption == 5
-                                                                    and isVSA
-                                                                    and saveDictionary["Pattern"]
-                                                                    in CandlePatterns.reversalPatternsBullish
-                                                                ))
-                                                                or (reversalOption == 6 and isNR)
-                                                                or (reversalOption == 7 and isLorentzian)
-                                                                or (reversalOption == 8 and hasPsarRSIReversal)
-                                                                or (reversalOption == 9 and hasRisingRSIReversal)
-                                                                or (reversalOption == 10 and hasRSIMAReversal)
-                                                                ))
-                        or ((executeOption == 7) and ((respChartPattern < 3 and isInsideBar > 0) 
-                                                                  or (isConfluence)
-                                                                  or (isIpoBase and newlyListedOnly and not respChartPattern < 3)
-                                                                  or (isVCP)
-                                                                  or (isBuyingTrendline))
-                                                                  or (respChartPattern == 6 and hasBbandsSqz)
-                                                                  or (respChartPattern == 7 and isCandlePattern))
-                        or (executeOption == 8 and isValidCci)
-                        or (executeOption == 9 and hasMinVolumeRatio)
-                        or (executeOption == 10 and isPriceRisingByAtLeast2Percent)
-                        or (executeOption == 11 and isShortTermBullish)
-                        or (executeOption in [12,13,14,15,16,17,18,19,20,23,24,25,27,28,30,31,32] and isValidityCheckMet)
-                        or (executeOption == 21 and (mfiStake > 0 and reversalOption in [3,5]))
-                        or (executeOption == 21 and (mfiStake < 0 and reversalOption in [6,7]))
-                        or (executeOption == 21 and (fairValueDiff > 0 and reversalOption in [8]))
-                        or (executeOption == 21 and (fairValueDiff < 0 and reversalOption in [9]))
-                        or (executeOption == 26)
-                        or (executeOption == 29) and bidGreaterThanAsk
-                    ):
-                        isNotMonitoringDashboard = userArgs.monitor is None or (userArgs.monitor is not None and "~" not in userArgs.monitor)
-                        # Now screen for common ones to improve performance
-                        if isNotMonitoringDashboard and not (executeOption == 6 and reversalOption == 7):
-                            if sys.version_info >= (3, 11):
-                                with SuppressOutput(suppress_stderr=True, suppress_stdout=True):
-                                    screener.validateLorentzian(
-                                        fullData,
-                                        screeningDictionary,
-                                        saveDictionary,
-                                        lookFor=maLength, # 1 =Buy, 2 =Sell, 3 = Any
-                                    )
-                        if isNotMonitoringDashboard and not (executeOption in [1,2]):
-                            screener.findBreakoutValue(
-                                processedData,
-                                screeningDictionary,
-                                saveDictionary,
-                                daysToLookback=configManager.daysToLookback,
-                                alreadyBrokenout=(executeOption == 2),
-                            )
-                        if isNotMonitoringDashboard and executeOption != 3:
-                            screener.validateConsolidation(
-                                processedData,
-                                screeningDictionary,
-                                saveDictionary,
-                                percentage=configManager.consolidationPercentage,
-                            )
-                        if executeOption != 5:
-                            screener.validateRSI(
-                                processedData, screeningDictionary, saveDictionary, minRSI, maxRSI
-                            )
-                        screener.find52WeekHighLow(
-                            fullData, saveDictionary, screeningDictionary
-                        )
-                        if isNotMonitoringDashboard and executeOption != 8:
-                            screener.validateCCI(
-                                processedData, screeningDictionary, saveDictionary, minRSI, maxRSI
-                            )
-                        if isNotMonitoringDashboard and executeOption != 21 and backtestDuration == 0:
-                            # We don't need to have MFI or fair value data for backtesting because those
-                            # are anyways only available for days in the past.
-                            # For executeOption 21, we'd have already got the mfiStake and fairValueDiff
-                            # Find general trend, MFI data and fairvalue only after the stocks are already screened
-                            screener.findUptrend(
-                                fullData,
-                                screeningDictionary,
-                                saveDictionary,
-                                testbuild,
-                                stock,
-                                onlyMF=(executeOption == 21 and reversalOption in [5,6]),
-                                hostData=data,
-                                exchangeName=exchangeName
-                            )
-                            hostRef.objectDictionaryPrimary[stock] = data.to_dict("split")
-
-                        hostRef.processingResultsCounter.value += 1
-                        return (
-                            screeningDictionary,
-                            saveDictionary,
-                            data,
-                            stock,
-                            backtestDuration,
-                        )
-
-        except KeyboardInterrupt: # pragma: no cover
-            # Capturing Ctr+C Here isn't a great idea
-            pass
-        except StockDataEmptyException as e: # pragma: no cover
-            if data is None or (data is not None and not data.isnull().values.all(axis=0)[0]):
-                hostRef.default_logger.debug(f"StockDataEmptyException:{stock}: {e}", exc_info=True)
-            pass
-        except ScreeningStatistics.EligibilityConditionNotMet as e:
-            if userArgsLog:
-                hostRef.default_logger.debug(f"EligibilityConditionNotMet:{stock}: {e}", exc_info=True)
-            pass
-        except ScreeningStatistics.NotNewlyListed as e: # pragma: no cover
-            if userArgsLog:
-                hostRef.default_logger.debug(f"NotNewlyListed:{stock}: {e}", exc_info=True)
-            pass
-        except ScreeningStatistics.NotAStageTwoStock as e: # pragma: no cover
-            if userArgsLog:
-                hostRef.default_logger.debug(f"NotAStageTwoStock:{stock}: {e}", exc_info=True)
-            pass
-        except ScreeningStatistics.NotEnoughVolumeAsPerConfig as e: # pragma: no cover 
-            if userArgsLog:
-                hostRef.default_logger.debug(f"NotEnoughVolumeAsPerConfig:{stock}: {e}", exc_info=True)
-            pass
-        except ScreeningStatistics.DownloadDataOnly as e: # pragma: no cover
-            if userArgsLog:
-                hostRef.default_logger.debug(f"DownloadDataOnly:{stock}: {e}", exc_info=True)
-            try:
-                data = hostRef.objectDictionaryPrimary.get(stock)
-                if data is not None:
-                    data = pd.DataFrame(data["data"], columns=data["columns"], index=data["index"])
-                    screener.getMutualFundStatus(stock, hostData=data, force=True, exchangeName=exchangeName)
-                    hostRef.objectDictionaryPrimary[stock] = data.to_dict("split")
-            except Exception as ex:
-                hostRef.default_logger.debug(f"MFIStatus: {stock}:\n{ex}", exc_info=True)
-                pass
-            try:
-                screener.getFairValue(stock,hostData=data, force=True,exchangeName=exchangeName)
-                hostRef.objectDictionaryPrimary[stock] = data.to_dict("split")
-            except Exception as ex:
-                hostRef.default_logger.debug(f"FairValue: {stock}:\n{ex}", exc_info=True)
-                pass
-            pass
-        except ScreeningStatistics.LTPNotInConfiguredRange as e: # pragma: no cover
-            if userArgsLog:
-                hostRef.default_logger.debug(f"LTPNotInConfiguredRange:{stock}: {e}", exc_info=True)
-            pass
-        except KeyError as e: # pragma: no cover
-            if userArgsLog:
-                hostRef.default_logger.debug(f"KeyError:{stock}: {e}", exc_info=True)
-            pass
-        except OSError as e: # pragma: no cover
-            if userArgsLog:
-                hostRef.default_logger.debug(f"OSError:{stock}: {e}", exc_info=True)
-            pass
-        except Exception as e:  # pragma: no cover
-            if userArgsLog:
-                hostRef.default_logger.debug(f"Exception:{stock}: {e}", exc_info=True)
-            if testbuild or printCounter:
-                # import traceback
-                # traceback.print_exc()
-                OutputControls().printOutput(e)
-                OutputControls().printOutput(
-                    colorText.FAIL
-                    + (
-                        "\n[+] Exception Occured while Screening %s! Skipping this stock.."
-                        % stock
-                    )
-                    + colorText.END
-                )
-        return None
-
-    def performValidityCheckForExecuteOptions(self,executeOption,screener,fullData,screeningDictionary,saveDictionary,processedData,configManager,buySellAll=3):
-        isValid = True
-        if executeOption not in [11,12,13,14,15,16,17,18,19,20,23,24,25,27,28,30,31,32]:
-            return True
-        if executeOption == 11:
-            isValid = screener.validateShortTermBullish(
-                fullData, screeningDictionary, saveDictionary
-            )
-        elif executeOption == 12:
-            isValid = (
-                screener.validate15MinutePriceVolumeBreakout(fullData)
-            )
-        elif executeOption == 13:
-            isValid = screener.findBullishIntradayRSIMACD(
-                fullData
-            )
-        elif executeOption == 14:
-            isValid = screener.findNR4Day(fullData)
-        elif executeOption == 15:
-            isValid = screener.find52WeekLowBreakout(fullData)
-        elif executeOption == 16:
-            isValid = screener.find10DaysLowBreakout(fullData)
-        elif executeOption == 17:
-            isValid = screener.find52WeekHighBreakout(fullData)
-        elif executeOption == 18:
-            isValid = screener.findAroonBullishCrossover(fullData)
-        elif executeOption == 19:
-            isValid = screener.validateMACDHistogramBelow0(fullData)
-        elif executeOption == 20:
-            isValid = screener.validateBullishForTomorrow(fullData)
-        elif executeOption == 23:
-            isValid = screener.findBreakingoutNow(processedData, fullData, saveDictionary, screeningDictionary)
-        elif executeOption == 24:
-            isValid = (
-                screener.validateHigherHighsHigherLowsHigherClose(fullData)
-            )
-        elif executeOption == 25:
-            isValid = screener.validateLowerHighsLowerLows(processedData)
-        elif executeOption == 27:
-            isValid = screener.findATRCross(processedData,saveDictionary, screeningDictionary)
-        elif executeOption == 28:
-            isValid = screener.findHigherBullishOpens(processedData)
-        elif executeOption == 30: # findBuySellSignalsFromATRTrailing # findATRTrailingStops
-            isValid = screener.findATRTrailingStops(fullData,sensitivity=configManager.atrTrailingStopSensitivity, atr_period=configManager.atrTrailingStopPeriod,ema_period=configManager.atrTrailingStopEMAPeriod,buySellAll=buySellAll,saveDict=saveDictionary,screenDict=screeningDictionary)
-        elif executeOption == 31: # findBuySellSignalsFromATRTrailing # findATRTrailingStops
-            isValid = screener.findHighMomentum(processedData)
-        return isValid        
-                    
-    def performBasicVolumeChecks(self, executeOption, volumeRatio, screeningDictionary, saveDictionary, processedData, configManager, screener):
-        minVolume = configManager.minVolume / (
-                    100 if configManager.isIntradayConfig() else 1
-                )
-        hasMinVolumeRatio, hasMinVolQty = screener.validateVolume(
-                    processedData,
-                    screeningDictionary,
-                    saveDictionary,
-                    volumeRatio=volumeRatio,
-                    minVolume=minVolume,
-                )
-        if (not hasMinVolQty and executeOption > 0) or (executeOption == 9 and not hasMinVolumeRatio):
-            raise ScreeningStatistics.NotEnoughVolumeAsPerConfig(f"hasMinVolQty:{hasMinVolQty},executeOption:{executeOption},hasMinVolumeRatio:{hasMinVolumeRatio}")
-        return hasMinVolumeRatio
-
-    def performBasicLTPChecks(self, executeOption, screeningDictionary, saveDictionary, fullData, configManager, screener,exchangeName):
-        isLtpValid, verifyStageTwo = screener.validateLTP(
-                    fullData,
-                    screeningDictionary,
-                    saveDictionary,
-                    minLTP=configManager.minLTP if exchangeName == "INDIA" else configManager.minLTP/80,
-                    maxLTP=configManager.maxLTP,
-                    minChange=configManager.minimumChangePercentage
-                )
-        if not isLtpValid:
-            raise ScreeningStatistics.LTPNotInConfiguredRange
-        if configManager.stageTwo and not verifyStageTwo and executeOption > 0:
-            raise ScreeningStatistics.NotAStageTwoStock
-
-    def updateStock(self, stock, screeningDictionary, saveDictionary, executeOption=0,exchangeName='INDIA'):
-        screeningDictionary["Stock"] = (
-                    colorText.WHITE
-                    + (
-                        f"\x1B]8;;https://in.tradingview.com/chart?symbol={'NSE' if exchangeName=='INDIA' else 'NASDAQ'}%3A{stock}\x1B\\{stock}\x1B]8;;\x1B\\"
-                    )
-                    + colorText.END
-                ) if executeOption != 26 else stock
-        saveDictionary["Stock"] = stock
-
-    def getCleanedDataForDuration(self, backtestDuration, portfolio, screeningDictionary, saveDictionary, configManager, screener, data):
-        fullData = None
-        processedData = None
-        if backtestDuration == 0:
-            fullData, processedData = screener.preprocessData(
-                    data, daysToLookback=configManager.effectiveDaysToLookback
-                )
-            if processedData.empty:
-                raise StockDataEmptyException(f"Empty processedData with data length ({len(data)})")
-            if portfolio:
-                data = data[::-1]
-                screener.validateLTPForPortfolioCalc(
-                        data, screeningDictionary, saveDictionary,requestedPeriod=backtestDuration
-                    )
-                data = data[::-1]
-        else:
-            if data is None or fullData is None or processedData is None:
-                    # data will have the oldest date at the top and the most recent
-                    # date will be at the bottom
-                    # We want to have the nth day treated as today when pre-processing where n = backtestDuration row from the bottom
-                inputData = data.head(len(data) - backtestDuration)
-                    # imputData will have the last row as the date for which the entire calculation
-                    # and prediction is being done
-                data = data.tail(
-                        backtestDuration + 1
-                    )  # .head(backtestPeriodToLookback+1)
-                    # Let's get today's data
-                if portfolio:
-                    screener.validateLTPForPortfolioCalc(
-                            data, screeningDictionary, saveDictionary,requestedPeriod=backtestDuration
-                        )
-                    # data has the last row from inputData at the top.
-                fullData, processedData = screener.preprocessData(
-                        inputData, daysToLookback=configManager.daysToLookback
-                    )
-                
-        return fullData,processedData,data
-
-    def getRelevantDataForStock(self, totalSymbols, shouldCache, stock, downloadOnly, printCounter, backtestDuration, hostRef,objectDictionary, configManager, fetcher, period, duration, testData=None,exchangeName="INDIA"):
-        hostData = objectDictionary.get(stock) if (objectDictionary is not None and len(objectDictionary) > 0) else None
-        data = None
-        hostDataLength = 0 if hostData is None else (0 if "data" not in hostData.keys() else len(hostData["data"]))
-        start = None
-        if (period == '1d' or configManager.duration[-1] == "m"):
-            if backtestDuration > 0: # We are backtesting
-                start = PKDateUtilities.nthPastTradingDateStringFromFutureDate(backtestDuration)
-                end = PKDateUtilities.nthPastTradingDateStringFromFutureDate(backtestDuration-1)
-            else:
-                # Since this is intraday data, we'd just need to start from the last trading session
-                start = PKDateUtilities.tradingDate().strftime("%Y-%m-%d")
-                end = PKDateUtilities.currentDateTime().strftime("%Y-%m-%d")
-        if (
-                not shouldCache
-                or (downloadOnly and hostData is None)
-                or (hostData is None and self.isTradingTime)
-                or hostData is None or hostDataLength == 0
-            ):
-            if testData is not None:
-                data = testData
-            else:
-                data = fetcher.fetchStockData(
-                        stock,
-                        period,
-                        configManager.duration if duration is None else duration,
-                        hostRef.proxyServer,
-                        hostRef.processingResultsCounter,
-                        hostRef.processingCounter,
-                        totalSymbols,
-                        start=start,
-                        end=start,
-                        exchangeSuffix=".NS" if exchangeName == "INDIA" else "",
-                        printCounter=printCounter
-                    )
-                if hostData is not None and data is not None:
-                    # During the market trading hours, we don't want to go for MFI/FV value fetching
-                    # So let's copy the old saved ones.
-                    try:
-                        data["MF"] = hostData["MF"]
-                        data["MF_Date"] = hostData["MF_Date"]
-                    except KeyError:
-                        pass
-                    try:
-                        data["FII"] = hostData["FII"]
-                        data["FII_Date"] = hostData["FII_Date"]
-                    except KeyError:
-                        pass
-                    try:
-                        data["FairValue"] = hostData["FairValue"]
-                    except KeyError:
-                        pass
-        else:
-            self.printProcessingCounter(totalSymbols, stock, printCounter, hostRef)
-            # data = hostData
-            try:
-                columns = hostData["columns"]
-                data = pd.DataFrame(
-                        hostData["data"], columns=columns, index=hostData["index"]
-                    )
-            except (ValueError, AssertionError) as e:
-                # 9 columns passed, passed data had 11 columns
-                # 10 columns passed, passed data had 11 columns
-                excLookingFor = " columns passed, passed data had "
-                if excLookingFor in str(e):
-                    e_diff = str(e).replace(excLookingFor,",").replace(" columns","").split(",")
-                    num_diff = int(e_diff[1]) - int(e_diff[0])
-                    while (num_diff > 0):
-                        columns.append(f"temp{num_diff}")
-                        num_diff -= 1
-                    data = pd.DataFrame(
-                            hostData["data"], columns=columns, index=hostData["index"]
-                        )
-                else:
-                    hostRef.default_logger.debug(e, exc_info=True)
-                pass
-
-        if ((shouldCache and not self.isTradingTime and (hostData is None  or hostDataLength == 0)) or downloadOnly) \
-            or (shouldCache and hostData is None):  # and backtestDuration == 0 # save only if we're NOT backtesting
-                if start is None and data is not None:
-                    objectDictionary[stock] = data.to_dict("split")
-                if downloadOnly:
-                    with hostRef.processingResultsCounter.get_lock():
-                        hostRef.processingResultsCounter.value += 1
-                    raise ScreeningStatistics.DownloadDataOnly
-                else:
-                    hostData = objectDictionary.get(stock)
-        return data
-
-    def determineBasicConfigs(self, stock, newlyListedOnly, volumeRatio, logLevel, hostRef, configManager, screener, userArgsLog):
-        if userArgsLog:
-            self.setupLoggers(hostRef, screener, logLevel, stock)
-        period = configManager.period
-        if volumeRatio <= 0:
-            volumeRatio = configManager.volumeRatio
-            # Data download adjustment for Newly Listed only feature
-        if newlyListedOnly:
-            if int(configManager.period[:-1]) > 250:
-                period = "250d"
-            else:
-                period = configManager.period
-        return volumeRatio,period
-
-    def printProcessingCounter(self, totalSymbols, stock, printCounter, hostRef):
-        if printCounter:
-            try:
-                OutputControls().printOutput(
-                            colorText.BOLD
-                            + colorText.GREEN
-                            + (
-                                "[%d%%] Screened %d, Found %d. Fetching data & Analyzing %s..."
-                                % (
-                                    int(
-                                        (hostRef.processingCounter.value / totalSymbols)
-                                        * 100
-                                    ),
-                                    hostRef.processingCounter.value,
-                                    hostRef.processingResultsCounter.value,
-                                    stock,
-                                )
-                            )
-                            + colorText.END,
-                            end="",
-                        )
-                OutputControls().printOutput(
-                            colorText.BOLD
-                            + colorText.GREEN
-                            + "=> Done!"
-                            + colorText.END,
-                            end="\r",
-                            flush=True,
-                        )
-            except ZeroDivisionError as e:
-                hostRef.default_logger.debug(e, exc_info=True)
-                pass
-            sys.stdout.write("\r\033[K")
-    
-    def setupLoggers(self, hostRef, screener, logLevel, stock):
-        # Set the loglevels for both the caller and screener
-        # Also add handlers that are specific to this sub-process which
-        # will continue with the screening. Each sub-process would have
-        # its own logger but going into the same file/console > to that
-        # of the parent logger.
-        # if hostRef.default_logger.level > 0:
-        #     return
-        # else:
-        # hostRef.default_logger.info(f"Beginning the stock screening for stock:{stock}")
-        # hostRef.default_logger.level = logLevel
-        screener.default_logger = hostRef.default_logger
-        # log_file_path = os.path.join(Archiver.get_user_outputs_dir(), "pkscreener-logs.txt")
-        # hostRef.default_logger.addHandlers(log_file_path=log_file_path, levelname=logLevel)
-        # screener.default_logger.addHandlers(log_file_path=log_file_path, levelname=logLevel)
-        # hostRef.default_logger.info(f"Beginning the stock screening for stock:{stock}")
-
-    def initResultDictionaries(self):
-        periods = self.configManager.periodsRange
-        columns = [
-            "Stock",
-            "LTP",
-            "%Chng",
-            "52Wk H",
-            "52Wk L",
-            "RSI",
-            "RSIi",
-            "Volume",
-            "22-Pd %",
-            "Consol.",
-            "Breakout",
-            "MA-Signal",
-            "Trend",
-            "Pattern",
-            "CCI",
-            "FairValue"
-        ]
-        screeningDictionary = {
-            "Stock": "",
-            "LTP": 0,
-            "%Chng": 0,
-            "52Wk H": 0,
-            "52Wk L": 0,
-            "RSI": 0,
-            "RSIi": 0,
-            "Volume": "",
-            "22-Pd %": "",
-            "Consol.": "Range:0%",
-            "Breakout": "BO: 0 R: 0",
-            "MA-Signal": "",
-            "Trend": "",
-            "Pattern": "",
-            "CCI": 0,
-            "FairValue": "-"
-        }
-        saveDictionary = {
-            "Stock": "",
-            "LTP": 0,
-            "%Chng": 0,
-            "52Wk H": 0,
-            "52Wk L": 0,
-            "RSI": 0,
-            "RSIi": 0,
-            "Volume": "",
-            "22-Pd %": "",
-            "Consol.": "Range:0%",
-            "Breakout": "BO: 0 R: 0",
-            "MA-Signal": "",
-            "Trend": "",
-            "Pattern": "",
-            "CCI": 0,
-            "FairValue": "-"
-        }
-        for prd in periods:
-            columns.append(f"LTP{prd}")
-            columns.append(f"Growth{prd}")
-            screeningDictionary[f"LTP{prd}"] = np.nan
-            saveDictionary[f"LTP{prd}"] = np.nan
-            screeningDictionary[f"Growth{prd}"] = np.nan
-            saveDictionary[f"Growth{prd}"] = np.nan
-
-        screenResults = pd.DataFrame(columns=columns)
-
-        return screeningDictionary, saveDictionary
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import os
+import logging
+import sys
+import time
+import warnings
+
+import numpy as np
+
+warnings.simplefilter("ignore", DeprecationWarning)
+warnings.simplefilter("ignore", FutureWarning)
+import pandas as pd
+# from PKDevTools.classes.log import tracelog
+# from PKDevTools.classes.PKTimer import PKTimer
+from PKDevTools.classes import Archiver
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.Fetcher import StockDataEmptyException
+from PKDevTools.classes.SuppressOutput import SuppressOutput
+from PKDevTools.classes.PKDateUtilities import PKDateUtilities
+
+import pkscreener.classes.ScreeningStatistics as ScreeningStatistics
+from pkscreener import Imports
+from pkscreener.classes.CandlePatterns import CandlePatterns
+from PKDevTools.classes.OutputControls import OutputControls
+
+class StockScreener:
+    def __init__(self):
+        self.isTradingTime = PKDateUtilities.isTradingTime()
+        self.configManager = None
+
+    # @tracelog
+    def screenStocks(
+        self,
+        menuOption,
+        exchangeName,
+        executeOption,
+        reversalOption,
+        maLength,
+        daysForLowestVolume,
+        minRSI,
+        maxRSI,
+        respChartPattern,
+        insideBarToLookback,
+        totalSymbols,
+        shouldCache,
+        stock,
+        newlyListedOnly,
+        downloadOnly,
+        volumeRatio,
+        testbuild=False,
+        userArgs=None,
+        backtestDuration=0,
+        backtestPeriodToLookback=30,
+        logLevel=logging.NOTSET,
+        portfolio=False,
+        testData = None,
+        hostRef=None,
+    ):
+        assert (
+            hostRef is not None
+        ), "hostRef argument must not be None. It should be an instance of PKMultiProcessorClient"
+        configManager = hostRef.configManager
+        self.configManager = configManager
+        screeningDictionary, saveDictionary = self.initResultDictionaries()
+        fullData = None
+        processedData = None
+        fetcher = hostRef.fetcher
+        screener = hostRef.screener
+        candlePatterns = hostRef.candlePatterns
+        printCounter = userArgs.log if (userArgs is not None and userArgs.log is not None) else False
+        userArgsLog = printCounter
+        start_time = time.time()
+        try:
+            with hostRef.processingCounter.get_lock():
+                hostRef.processingCounter.value += 1
+
+            volumeRatio, period = self.determineBasicConfigs(stock, newlyListedOnly, volumeRatio, logLevel, hostRef, configManager, screener, userArgsLog)
+            # hostRef.default_logger.info(
+            #     f"For stock:{stock}, stock exists in objectDictionary:{hostRef.objectDictionaryPrimary.get(stock)}, cacheEnabled:{configManager.cacheEnabled}, isTradingTime:{self.isTradingTime}, downloadOnly:{downloadOnly}"
+            # )
+            data = None
+            data = self.getRelevantDataForStock(totalSymbols, shouldCache, stock, downloadOnly, printCounter, backtestDuration, hostRef,hostRef.objectDictionaryPrimary, configManager, fetcher, period,None, testData,exchangeName)
+            if not configManager.isIntradayConfig() and configManager.calculatersiintraday:
+                # Daily data is already available in "data" above.
+                # We need the intraday data for 1-d RSI values when config is not for intraday
+                intraday_data = self.getRelevantDataForStock(totalSymbols, shouldCache, stock, downloadOnly, printCounter, backtestDuration, hostRef, hostRef.objectDictionarySecondary, configManager, fetcher, "1d","1m", testData,exchangeName)
+                
+            if data is not None:
+                if len(data) == 0 or data.empty or len(data) < backtestDuration:
+                    raise StockDataEmptyException(f"Data length:{len(data)}")
+            else:
+                raise StockDataEmptyException(f"Data is None: {data}")
+            
+            bidGreaterThanAsk = False
+            bidAskRatio = 0
+            if executeOption == 29:
+                hostRef.intradayNSEFetcher.symbol = stock.upper()
+                priceData = hostRef.intradayNSEFetcher.price_order_info()
+                if priceData is not None:
+                    try:
+                        totalBid = priceData["BidQty"].iloc[0]
+                    except:
+                        totalBid = 0
+                        pass
+                    try:
+                        totalAsk = priceData["AskQty"].iloc[0]
+                    except:
+                        totalAsk = 0
+                        pass
+                    try:
+                        lwrCP = float(priceData["LwrCP"].iloc[0])
+                    except:
+                        lwrCP = 0
+                        pass
+                    try:
+                        uprCP = float(priceData["UprCP"].iloc[0])
+                    except:
+                        uprCP = 0
+                        pass
+                    try:
+                        vwap = float(priceData["VWAP"].iloc[0])
+                    except:
+                        vwap = 0
+                        pass
+                    try:
+                        dayVola = float(priceData["DayVola"].iloc[0])
+                    except:
+                        dayVola = 0
+                        pass
+                    try:
+                        delPercent = priceData["Del(%)"].iloc[0]
+                    except:
+                        delPercent = 0
+                        pass
+                    try:
+                        ltp = priceData["LTP"].iloc[0]
+                    except:
+                        ltp = 0
+                        pass
+                    
+                    bidAskSimulate = userArgs is not None and userArgs.simulate is not None and "BidAsk" in userArgs.simulate.keys()
+                    if (totalBid > totalAsk and \
+                        ltp < uprCP and \
+                        ltp > lwrCP) or bidAskSimulate:
+                        bidGreaterThanAsk = True
+                        bidAskRatio = round(totalBid/totalAsk,1) if totalAsk > 0 else (0 if not bidAskSimulate else 3)
+                        bidAskBuildupDict = {"BidQty":totalBid,"AskQty":totalAsk,"LwrCP":lwrCP,"UprCP":uprCP,"VWAP":vwap,"DayVola":dayVola,"Del(%)":delPercent}
+                        screeningDictionary.update(bidAskBuildupDict)
+                        saveDictionary.update(bidAskBuildupDict)
+                    else:
+                        raise ScreeningStatistics.EligibilityConditionNotMet("Bid/Ask Eligibility Not met.")
+                else:
+                    raise ScreeningStatistics.EligibilityConditionNotMet("Bid/Ask Eligibility Not met.")
+            # hostRef.default_logger.info(f"Will pre-process data:\n{data.tail(10)}")
+            fullData, processedData, data = self.getCleanedDataForDuration(backtestDuration, portfolio, screeningDictionary, saveDictionary, configManager, screener, data)
+            if "RUNNER" not in os.environ.keys() and backtestDuration == 0 and configManager.calculatersiintraday:
+                if (intraday_data is not None and not intraday_data.empty):
+                    intraday_fullData, intraday_processedData = screener.preprocessData(
+                        intraday_data, daysToLookback=configManager.effectiveDaysToLookback
+                    )
+                    # Match the index length and values length
+                    fullData = fullData.head(len(intraday_fullData))
+                    intraday_fullData = intraday_fullData.head(len(fullData))
+                    processedData = processedData.head(len(intraday_processedData))
+                    intraday_processedData = intraday_processedData.head(len(processedData))
+                    data = data.tail(len(intraday_data))
+                    intraday_data = intraday_data.tail(len(data))
+                    # Indexes won't match. Hence, we'd need to fallback on tolist
+                    processedData.insert(len(processedData.columns), "RSIi", intraday_processedData["RSI"].tolist())
+                    fullData.insert(len(fullData.columns), "RSIi", intraday_processedData["RSI"].tolist())
+                else:
+                    with SuppressOutput(suppress_stderr=(logLevel==logging.NOTSET), suppress_stdout=(not (printCounter or testbuild))):
+                        processedData.insert(len(processedData.columns), "RSIi", np.array(np.nan))
+                        fullData.insert(len(fullData.columns), "RSIi", np.array(np.nan))
+            else:
+                    with SuppressOutput(suppress_stderr=(logLevel==logging.NOTSET), suppress_stdout=(not (printCounter or testbuild))):
+                        processedData.insert(len(processedData.columns), "RSIi", np.array(np.nan))
+                        fullData.insert(len(fullData.columns), "RSIi", np.array(np.nan))
+
+            def returnLegibleData(exceptionMessage=None):
+                if backtestDuration == 0 or menuOption not in ["B"]:
+                    raise ScreeningStatistics.EligibilityConditionNotMet(exceptionMessage)
+                elif (backtestDuration > 0 and backtestDuration <= configManager.maxBacktestWindow):
+                    screener.validateMovingAverages(
+                        processedData, screeningDictionary, saveDictionary, maRange=1.25
+                    )
+                    screener.findTrend(
+                        processedData,
+                        screeningDictionary,
+                        saveDictionary,
+                        daysToLookback=configManager.daysToLookback,
+                        stockName=stock,
+                    )
+                    screener.find52WeekHighLow(
+                            fullData, saveDictionary, screeningDictionary
+                        )
+                    return (
+                            screeningDictionary,
+                            saveDictionary,
+                            data,
+                            stock,
+                            backtestDuration,
+                        )
+            if newlyListedOnly:
+                if not screener.validateNewlyListed(fullData, period):
+                    raise ScreeningStatistics.NotNewlyListed
+
+            if processedData.empty:
+                raise StockDataEmptyException("Empty processedData")
+            
+            with SuppressOutput(suppress_stderr=(logLevel==logging.NOTSET), suppress_stdout=(not (printCounter or testbuild))):
+                self.updateStock(stock, screeningDictionary, saveDictionary, executeOption, exchangeName)
+                
+                self.performBasicLTPChecks(executeOption, screeningDictionary, saveDictionary, fullData, configManager, screener, exchangeName)
+                hasMinVolumeRatio = self.performBasicVolumeChecks(executeOption, volumeRatio, screeningDictionary, saveDictionary, processedData, configManager, screener)
+                if bidGreaterThanAsk:
+                    if not hasMinVolumeRatio or bidAskRatio < 2:
+                        raise ScreeningStatistics.EligibilityConditionNotMet("Bid/Ask Eligibility Not met.")
+                isConfluence = False
+                isInsideBar = 0
+                isMaReversal = 0
+                isIpoBase = False
+                isMaSupport = False
+                isLorentzian = False
+                isVCP = False
+                isVSA = False
+                isNR = False
+                hasPsarRSIReversal = False
+                hasRisingRSIReversal = False
+                hasRSIMAReversal = False
+                isValidRsi = False
+                isBuyingTrendline = False
+                isMomentum = False
+                mfiStake = 0
+                fairValueDiff = 0
+                consolidationValue = 0
+                isBreaking = False
+                isValidCci = False
+                isVSA = False
+                isCandlePattern = False
+                isLowestVolume = False
+                hasBbandsSqz = False
+
+                isValidityCheckMet = self.performValidityCheckForExecuteOptions(executeOption,screener,fullData,screeningDictionary,saveDictionary,processedData,configManager,maLength)
+                if not isValidityCheckMet:
+                    return returnLegibleData("Validity Check not met!")
+                isShortTermBullish = (executeOption == 11 and isValidityCheckMet)
+                if newlyListedOnly:
+                    isIpoBase = screener.validateIpoBase(
+                        stock, fullData, screeningDictionary, saveDictionary
+                    )
+                if executeOption in [1,2]:
+                    isBreaking = screener.findBreakoutValue(
+                        processedData,
+                        screeningDictionary,
+                        saveDictionary,
+                        daysToLookback=configManager.daysToLookback,
+                        alreadyBrokenout=(executeOption == 2),
+                    )
+                    if executeOption == 1:
+                        isPotentialBreaking = screener.findPotentialBreakout(
+                            fullData,
+                            screeningDictionary,
+                            saveDictionary,
+                            daysToLookback=configManager.daysToLookback,
+                        )
+                        if not (isBreaking or isPotentialBreaking) or not hasMinVolumeRatio:
+                            return returnLegibleData(f"isBreaking:{isBreaking},isPotentialBreaking:{isPotentialBreaking},hasMinVolumeRatio:{hasMinVolumeRatio}")
+                    elif executeOption == 2:
+                        if not (isBreaking) or not hasMinVolumeRatio:
+                            return returnLegibleData(f"isBreaking:{isBreaking},hasMinVolumeRatio:{hasMinVolumeRatio}")
+                elif executeOption == 3:
+                    consolidationValue = screener.validateConsolidation(
+                        processedData,
+                        screeningDictionary,
+                        saveDictionary,
+                        percentage=configManager.consolidationPercentage,
+                    )
+                    if ((consolidationValue == 0 or consolidationValue > configManager.consolidationPercentage)):
+                        return returnLegibleData(f"consolidationValue:{consolidationValue}")
+                elif executeOption == 4:
+                    isLowestVolume = screener.validateLowestVolume(
+                        processedData, daysForLowestVolume
+                    )
+                    if not isLowestVolume:
+                        return returnLegibleData(f"isLowestVolume:{isLowestVolume}")
+                elif executeOption == 5:
+                    isValidRsi = screener.validateRSI(
+                        processedData, screeningDictionary, saveDictionary, minRSI, maxRSI
+                    )
+                    if not isValidRsi:
+                        return returnLegibleData(f"isValidRsi:{isValidRsi}")
+                elif executeOption == 6:
+                    if reversalOption == 10:
+                        hasRSIMAReversal = screener.findRSICrossingMA(processedData,
+                                                                      screeningDictionary,
+                                                                      saveDictionary,
+                                                                      lookFor=maLength) # 1 =Buy, 2 =Sell, 3 = Any
+                        if not hasRSIMAReversal:
+                            return returnLegibleData(f"hasRSIMAReversal:{hasRSIMAReversal}")
+                    elif reversalOption == 9:
+                        hasRisingRSIReversal = screener.findRisingRSI(processedData)
+                        if not hasRisingRSIReversal:
+                            return returnLegibleData(f"hasRisingRSIReversal:{hasRisingRSIReversal}")
+                    elif reversalOption == 8:
+                        hasPsarRSIReversal = screener.findPSARReversalWithRSI(
+                            processedData,
+                            screeningDictionary,
+                            saveDictionary
+                            # minRSI=maLength if maLength is not None else 40,
+                        )
+                        if not hasPsarRSIReversal:
+                            return returnLegibleData(f"hasPsarRSIReversal:{hasPsarRSIReversal}")
+                    elif reversalOption == 6:
+                        isNR = screener.validateNarrowRange(
+                            processedData,
+                            screeningDictionary,
+                            saveDictionary,
+                            nr=maLength if maLength is not None else 4,
+                        )
+                        if not isNR:
+                            return returnLegibleData(f"isNR:{isNR}")
+                    elif reversalOption == 5:
+                        isVSA = screener.validateVolumeSpreadAnalysis(
+                            processedData, screeningDictionary, saveDictionary
+                        )
+                        if not isVSA:
+                            return returnLegibleData(f"isVSA:{isVSA}")
+                    elif reversalOption == 4 and maLength is not None:
+                        isMaSupport = screener.findReversalMA(
+                            fullData, screeningDictionary, saveDictionary, maLength
+                        )
+                        if not isMaSupport:
+                            return returnLegibleData(f"isMaSupport:{isMaSupport}")
+                    elif reversalOption == 7:
+                        if sys.version_info >= (3, 11):
+                            isLorentzian = screener.validateLorentzian(
+                                fullData,
+                                screeningDictionary,
+                                saveDictionary,
+                                lookFor=maLength, # 1 =Buy, 2 =Sell, 3 = Any
+                            )
+                            if not isLorentzian:
+                                return returnLegibleData(f"isLorentzian:{isLorentzian}")
+                elif executeOption == 7:
+                    if respChartPattern == 3:
+                        isConfluence = screener.validateConfluence(
+                            stock,
+                            processedData,
+                            screeningDictionary,
+                            saveDictionary,
+                            percentage=insideBarToLookback,
+                            confFilter=(maLength if maLength > 0 else 3) # 1 = Conf up, 2 = Conf Down, 3 = all
+                        )
+                        if not isConfluence:
+                            return returnLegibleData(f"isConfluence:{isConfluence}")
+                    elif respChartPattern == 4:
+                        isVCP = screener.validateVCP(
+                            fullData, screeningDictionary, saveDictionary
+                        )
+                        if not isVCP:
+                            return returnLegibleData(f"isVCP:{isVCP}")
+                    elif respChartPattern == 5:
+                        if Imports["scipy"]:
+                            isBuyingTrendline = screener.findTrendlines(
+                                fullData, screeningDictionary, saveDictionary
+                            )
+                            if not isBuyingTrendline:
+                                return returnLegibleData(f"isBuyingTrendline:{isBuyingTrendline}")
+                    elif respChartPattern == 6:
+                        hasBbandsSqz = screener.findBbandsSqueeze(fullData, screeningDictionary, saveDictionary, filter=(maLength if maLength > 0 else 4))
+                        if not hasBbandsSqz:
+                            return returnLegibleData(f"hasBbandsSqz:{hasBbandsSqz}")
+                    elif respChartPattern == 7:
+                        isCandlePattern = candlePatterns.findPattern(
+                        processedData, screeningDictionary, saveDictionary)
+                        if not isCandlePattern:
+                            return returnLegibleData(f"isCandlePattern:{isCandlePattern}")
+                        
+                elif executeOption == 10:
+                    isPriceRisingByAtLeast2Percent = (
+                        screener.validatePriceRisingByAtLeast2Percent(
+                            processedData, screeningDictionary, saveDictionary
+                        )
+                    )
+                    if not isPriceRisingByAtLeast2Percent:
+                        return returnLegibleData(f"isPriceRisingByAtLeast2Percent:{isPriceRisingByAtLeast2Percent}")
+                # Must-run, but only at the end
+                try:
+                    if executeOption != 7 or (executeOption == 7 and respChartPattern != 7):
+                    # Only 'doji' and 'inside' is internally implemented by pandas_ta.
+                    # Otherwise, for the rest of the candle patterns, they also need
+                    # TA-Lib. So if TA-Lib is not available, it will throw exception
+                    # We can live with no-patterns if user has not installed ta-lib
+                    # yet. If ta-lib is available, PKTalib will load it automatically.
+                        isCandlePattern = candlePatterns.findPattern(
+                            processedData, screeningDictionary, saveDictionary
+                        )
+                except Exception as e:  # pragma: no cover
+                    hostRef.default_logger.debug(e, exc_info=True)
+                    screeningDictionary["Pattern"] = ""
+                    saveDictionary["Pattern"] = ""
+
+                try:
+                    currentTrend = screener.findTrend(
+                        processedData,
+                        screeningDictionary,
+                        saveDictionary,
+                        daysToLookback=configManager.daysToLookback,
+                        stockName=stock,
+                    )
+                    if backtestDuration == 0:
+                        if executeOption == 21 and reversalOption in [3,5,6,7,8,9]:
+                            # Find general trend
+                            _,mfiStake,fairValueDiff = screener.findUptrend(
+                                fullData,
+                                screeningDictionary,
+                                saveDictionary,
+                                testbuild,
+                                stock,
+                                onlyMF=(executeOption == 21 and reversalOption in [5,6]),
+                                hostData=data,
+                                exchangeName=exchangeName,
+                                refreshMFAndFV=(menuOption in ["X"])
+                            )
+                            hostRef.objectDictionaryPrimary[stock] = data.to_dict("split")
+                except np.RankWarning as e: # pragma: no cover 
+                    hostRef.default_logger.debug(e, exc_info=True)
+                    screeningDictionary["Trend"] = "Unknown"
+                    saveDictionary["Trend"] = "Unknown"
+                # CCI also uses "Trend" value from findTrend above.
+                # So it must only be called after findTrend
+                if executeOption == 8:
+                    isValidCci = screener.validateCCI(
+                        processedData, screeningDictionary, saveDictionary, minRSI, maxRSI
+                    )
+                    if not isValidCci:
+                        return returnLegibleData(f"isValidCci:{isValidCci}")
+
+                if not (isConfluence or isShortTermBullish or isMaSupport):
+                    isMaReversal = screener.validateMovingAverages(
+                        processedData, screeningDictionary, saveDictionary, maRange=1.25
+                    )
+                if executeOption == 6:
+                    if reversalOption == 1 and not (str(saveDictionary["Pattern"]).split(",")[0]
+                                                                    in CandlePatterns.reversalPatternsBullish
+                                                                    or isMaReversal > 0):
+                        return returnLegibleData(f"reversalOption:{reversalOption},isMaReversal:{isMaReversal},{CandlePatterns.reversalPatternsBullish}")
+                    elif reversalOption == 2 and not (str(saveDictionary["Pattern"]).split(",")[0]
+                                                                    in CandlePatterns.reversalPatternsBearish
+                                                                    or isMaReversal < 0):
+                        return returnLegibleData(f"reversalOption:{reversalOption},isMaReversal:{isMaReversal},{CandlePatterns.reversalPatternsBearish}")
+                # validateInsideBar needs "Trend" to be already defined
+                # ValidateInsideBar also needs "MA-Signal" to be setup
+                if executeOption == 7 and respChartPattern < 3:
+                    isInsideBar = screener.validateInsideBar(
+                                processedData,
+                                screeningDictionary,
+                                saveDictionary,
+                                chartPattern=respChartPattern,
+                                daysToLookback=insideBarToLookback,
+                            )
+                    if isInsideBar ==0:
+                        return returnLegibleData(f"isInsideBar:{isInsideBar}")
+
+                if not (isLorentzian or (isInsideBar !=0) or isBuyingTrendline or isIpoBase or isNR or isVCP or isVSA):
+                    isMomentum = screener.validateMomentum(
+                        processedData, screeningDictionary, saveDictionary
+                    )
+                    if executeOption == 6 and reversalOption ==3 and not isMomentum:
+                        return returnLegibleData(f"executeOption:{executeOption},reversalOption:{reversalOption},isMomentum:{isMomentum}")
+
+                with hostRef.processingResultsCounter.get_lock():
+                    # hostRef.default_logger.debug(f"ExecuteOption:{executeOption}:{reversalOption}:{respChartPattern}:{maLength}. Elapsed: {time.time() - start_time}")
+                    if (
+                        (executeOption == 0)
+                        or ((
+                            (
+                                (executeOption == 1 and (isBreaking or isPotentialBreaking))
+                                or (executeOption == 2 and isBreaking)
+                            )
+                            and hasMinVolumeRatio
+                        ))
+                        or ((
+                            (executeOption == 3)
+                            and (
+                                consolidationValue <= configManager.consolidationPercentage
+                                and consolidationValue != 0
+                            )
+                        ))
+                        or (executeOption == 4 and isLowestVolume)
+                        or (executeOption == 5 and isValidRsi)
+                        or ((executeOption == 6) and ((reversalOption == 1 and (
+                                                                    str(saveDictionary["Pattern"]).split(",")[0]
+                                                                    in CandlePatterns.reversalPatternsBullish
+                                                                    or isMaReversal > 0
+                                                                ))
+                                                                or (reversalOption == 2 and (
+                                                                    str(saveDictionary["Pattern"]).split(",")[0]
+                                                                    in CandlePatterns.reversalPatternsBearish
+                                                                    or isMaReversal < 0
+                                                                ))
+                                                                or (reversalOption == 3 and isMomentum)
+                                                                or (reversalOption == 4 and isMaSupport)
+                                                                or ((
+                                                                    reversalOption == 5
+                                                                    and isVSA
+                                                                    and saveDictionary["Pattern"]
+                                                                    in CandlePatterns.reversalPatternsBullish
+                                                                ))
+                                                                or (reversalOption == 6 and isNR)
+                                                                or (reversalOption == 7 and isLorentzian)
+                                                                or (reversalOption == 8 and hasPsarRSIReversal)
+                                                                or (reversalOption == 9 and hasRisingRSIReversal)
+                                                                or (reversalOption == 10 and hasRSIMAReversal)
+                                                                ))
+                        or ((executeOption == 7) and ((respChartPattern < 3 and isInsideBar > 0) 
+                                                                  or (isConfluence)
+                                                                  or (isIpoBase and newlyListedOnly and not respChartPattern < 3)
+                                                                  or (isVCP)
+                                                                  or (isBuyingTrendline))
+                                                                  or (respChartPattern == 6 and hasBbandsSqz)
+                                                                  or (respChartPattern == 7 and isCandlePattern))
+                        or (executeOption == 8 and isValidCci)
+                        or (executeOption == 9 and hasMinVolumeRatio)
+                        or (executeOption == 10 and isPriceRisingByAtLeast2Percent)
+                        or (executeOption == 11 and isShortTermBullish)
+                        or (executeOption in [12,13,14,15,16,17,18,19,20,23,24,25,27,28,30,31,32] and isValidityCheckMet)
+                        or (executeOption == 21 and (mfiStake > 0 and reversalOption in [3,5]))
+                        or (executeOption == 21 and (mfiStake < 0 and reversalOption in [6,7]))
+                        or (executeOption == 21 and (fairValueDiff > 0 and reversalOption in [8]))
+                        or (executeOption == 21 and (fairValueDiff < 0 and reversalOption in [9]))
+                        or (executeOption == 26)
+                        or (executeOption == 29) and bidGreaterThanAsk
+                    ):
+                        isNotMonitoringDashboard = userArgs.monitor is None or (userArgs.monitor is not None and "~" not in userArgs.monitor)
+                        # Now screen for common ones to improve performance
+                        if isNotMonitoringDashboard and not (executeOption == 6 and reversalOption == 7):
+                            if sys.version_info >= (3, 11):
+                                with SuppressOutput(suppress_stderr=True, suppress_stdout=True):
+                                    screener.validateLorentzian(
+                                        fullData,
+                                        screeningDictionary,
+                                        saveDictionary,
+                                        lookFor=maLength, # 1 =Buy, 2 =Sell, 3 = Any
+                                    )
+                        if isNotMonitoringDashboard and not (executeOption in [1,2]):
+                            screener.findBreakoutValue(
+                                processedData,
+                                screeningDictionary,
+                                saveDictionary,
+                                daysToLookback=configManager.daysToLookback,
+                                alreadyBrokenout=(executeOption == 2),
+                            )
+                        if isNotMonitoringDashboard and executeOption != 3:
+                            screener.validateConsolidation(
+                                processedData,
+                                screeningDictionary,
+                                saveDictionary,
+                                percentage=configManager.consolidationPercentage,
+                            )
+                        if executeOption != 5:
+                            screener.validateRSI(
+                                processedData, screeningDictionary, saveDictionary, minRSI, maxRSI
+                            )
+                        screener.find52WeekHighLow(
+                            fullData, saveDictionary, screeningDictionary
+                        )
+                        if isNotMonitoringDashboard and executeOption != 8:
+                            screener.validateCCI(
+                                processedData, screeningDictionary, saveDictionary, minRSI, maxRSI
+                            )
+                        if isNotMonitoringDashboard and executeOption != 21 and backtestDuration == 0:
+                            # We don't need to have MFI or fair value data for backtesting because those
+                            # are anyways only available for days in the past.
+                            # For executeOption 21, we'd have already got the mfiStake and fairValueDiff
+                            # Find general trend, MFI data and fairvalue only after the stocks are already screened
+                            screener.findUptrend(
+                                fullData,
+                                screeningDictionary,
+                                saveDictionary,
+                                testbuild,
+                                stock,
+                                onlyMF=(executeOption == 21 and reversalOption in [5,6]),
+                                hostData=data,
+                                exchangeName=exchangeName
+                            )
+                            hostRef.objectDictionaryPrimary[stock] = data.to_dict("split")
+
+                        hostRef.processingResultsCounter.value += 1
+                        return (
+                            screeningDictionary,
+                            saveDictionary,
+                            data,
+                            stock,
+                            backtestDuration,
+                        )
+
+        except KeyboardInterrupt: # pragma: no cover
+            # Capturing Ctr+C Here isn't a great idea
+            pass
+        except StockDataEmptyException as e: # pragma: no cover
+            if data is None or (data is not None and not data.isnull().values.all(axis=0)[0]):
+                hostRef.default_logger.debug(f"StockDataEmptyException:{stock}: {e}", exc_info=True)
+            pass
+        except ScreeningStatistics.EligibilityConditionNotMet as e:
+            if userArgsLog:
+                hostRef.default_logger.debug(f"EligibilityConditionNotMet:{stock}: {e}", exc_info=True)
+            pass
+        except ScreeningStatistics.NotNewlyListed as e: # pragma: no cover
+            if userArgsLog:
+                hostRef.default_logger.debug(f"NotNewlyListed:{stock}: {e}", exc_info=True)
+            pass
+        except ScreeningStatistics.NotAStageTwoStock as e: # pragma: no cover
+            if userArgsLog:
+                hostRef.default_logger.debug(f"NotAStageTwoStock:{stock}: {e}", exc_info=True)
+            pass
+        except ScreeningStatistics.NotEnoughVolumeAsPerConfig as e: # pragma: no cover 
+            if userArgsLog:
+                hostRef.default_logger.debug(f"NotEnoughVolumeAsPerConfig:{stock}: {e}", exc_info=True)
+            pass
+        except ScreeningStatistics.DownloadDataOnly as e: # pragma: no cover
+            if userArgsLog:
+                hostRef.default_logger.debug(f"DownloadDataOnly:{stock}: {e}", exc_info=True)
+            try:
+                data = hostRef.objectDictionaryPrimary.get(stock)
+                if data is not None:
+                    data = pd.DataFrame(data["data"], columns=data["columns"], index=data["index"])
+                    screener.getMutualFundStatus(stock, hostData=data, force=True, exchangeName=exchangeName)
+                    hostRef.objectDictionaryPrimary[stock] = data.to_dict("split")
+            except Exception as ex:
+                hostRef.default_logger.debug(f"MFIStatus: {stock}:\n{ex}", exc_info=True)
+                pass
+            try:
+                screener.getFairValue(stock,hostData=data, force=True,exchangeName=exchangeName)
+                hostRef.objectDictionaryPrimary[stock] = data.to_dict("split")
+            except Exception as ex:
+                hostRef.default_logger.debug(f"FairValue: {stock}:\n{ex}", exc_info=True)
+                pass
+            pass
+        except ScreeningStatistics.LTPNotInConfiguredRange as e: # pragma: no cover
+            if userArgsLog:
+                hostRef.default_logger.debug(f"LTPNotInConfiguredRange:{stock}: {e}", exc_info=True)
+            pass
+        except KeyError as e: # pragma: no cover
+            if userArgsLog:
+                hostRef.default_logger.debug(f"KeyError:{stock}: {e}", exc_info=True)
+            pass
+        except OSError as e: # pragma: no cover
+            if userArgsLog:
+                hostRef.default_logger.debug(f"OSError:{stock}: {e}", exc_info=True)
+            pass
+        except Exception as e:  # pragma: no cover
+            if userArgsLog:
+                hostRef.default_logger.debug(f"Exception:{stock}: {e}", exc_info=True)
+            if testbuild or printCounter:
+                # import traceback
+                # traceback.print_exc()
+                OutputControls().printOutput(e)
+                OutputControls().printOutput(
+                    colorText.FAIL
+                    + (
+                        "\n[+] Exception Occured while Screening %s! Skipping this stock.."
+                        % stock
+                    )
+                    + colorText.END
+                )
+        return None
+
+    def performValidityCheckForExecuteOptions(self,executeOption,screener,fullData,screeningDictionary,saveDictionary,processedData,configManager,buySellAll=3):
+        isValid = True
+        if executeOption not in [11,12,13,14,15,16,17,18,19,20,23,24,25,27,28,30,31,32]:
+            return True
+        if executeOption == 11:
+            isValid = screener.validateShortTermBullish(
+                fullData, screeningDictionary, saveDictionary
+            )
+        elif executeOption == 12:
+            isValid = (
+                screener.validate15MinutePriceVolumeBreakout(fullData)
+            )
+        elif executeOption == 13:
+            isValid = screener.findBullishIntradayRSIMACD(
+                fullData
+            )
+        elif executeOption == 14:
+            isValid = screener.findNR4Day(fullData)
+        elif executeOption == 15:
+            isValid = screener.find52WeekLowBreakout(fullData)
+        elif executeOption == 16:
+            isValid = screener.find10DaysLowBreakout(fullData)
+        elif executeOption == 17:
+            isValid = screener.find52WeekHighBreakout(fullData)
+        elif executeOption == 18:
+            isValid = screener.findAroonBullishCrossover(fullData)
+        elif executeOption == 19:
+            isValid = screener.validateMACDHistogramBelow0(fullData)
+        elif executeOption == 20:
+            isValid = screener.validateBullishForTomorrow(fullData)
+        elif executeOption == 23:
+            isValid = screener.findBreakingoutNow(processedData, fullData, saveDictionary, screeningDictionary)
+        elif executeOption == 24:
+            isValid = (
+                screener.validateHigherHighsHigherLowsHigherClose(fullData)
+            )
+        elif executeOption == 25:
+            isValid = screener.validateLowerHighsLowerLows(processedData)
+        elif executeOption == 27:
+            isValid = screener.findATRCross(processedData,saveDictionary, screeningDictionary)
+        elif executeOption == 28:
+            isValid = screener.findHigherBullishOpens(processedData)
+        elif executeOption == 30: # findBuySellSignalsFromATRTrailing # findATRTrailingStops
+            isValid = screener.findATRTrailingStops(fullData,sensitivity=configManager.atrTrailingStopSensitivity, atr_period=configManager.atrTrailingStopPeriod,ema_period=configManager.atrTrailingStopEMAPeriod,buySellAll=buySellAll,saveDict=saveDictionary,screenDict=screeningDictionary)
+        elif executeOption == 31: # findBuySellSignalsFromATRTrailing # findATRTrailingStops
+            isValid = screener.findHighMomentum(processedData)
+        return isValid        
+                    
+    def performBasicVolumeChecks(self, executeOption, volumeRatio, screeningDictionary, saveDictionary, processedData, configManager, screener):
+        minVolume = configManager.minVolume / (
+                    100 if configManager.isIntradayConfig() else 1
+                )
+        hasMinVolumeRatio, hasMinVolQty = screener.validateVolume(
+                    processedData,
+                    screeningDictionary,
+                    saveDictionary,
+                    volumeRatio=volumeRatio,
+                    minVolume=minVolume,
+                )
+        if (not hasMinVolQty and executeOption > 0) or (executeOption == 9 and not hasMinVolumeRatio):
+            raise ScreeningStatistics.NotEnoughVolumeAsPerConfig(f"hasMinVolQty:{hasMinVolQty},executeOption:{executeOption},hasMinVolumeRatio:{hasMinVolumeRatio}")
+        return hasMinVolumeRatio
+
+    def performBasicLTPChecks(self, executeOption, screeningDictionary, saveDictionary, fullData, configManager, screener,exchangeName):
+        isLtpValid, verifyStageTwo = screener.validateLTP(
+                    fullData,
+                    screeningDictionary,
+                    saveDictionary,
+                    minLTP=configManager.minLTP if exchangeName == "INDIA" else configManager.minLTP/80,
+                    maxLTP=configManager.maxLTP,
+                    minChange=configManager.minimumChangePercentage
+                )
+        if not isLtpValid:
+            raise ScreeningStatistics.LTPNotInConfiguredRange
+        if configManager.stageTwo and not verifyStageTwo and executeOption > 0:
+            raise ScreeningStatistics.NotAStageTwoStock
+
+    def updateStock(self, stock, screeningDictionary, saveDictionary, executeOption=0,exchangeName='INDIA'):
+        screeningDictionary["Stock"] = (
+                    colorText.WHITE
+                    + (
+                        f"\x1B]8;;https://in.tradingview.com/chart?symbol={'NSE' if exchangeName=='INDIA' else 'NASDAQ'}%3A{stock}\x1B\\{stock}\x1B]8;;\x1B\\"
+                    )
+                    + colorText.END
+                ) if executeOption != 26 else stock
+        saveDictionary["Stock"] = stock
+
+    def getCleanedDataForDuration(self, backtestDuration, portfolio, screeningDictionary, saveDictionary, configManager, screener, data):
+        fullData = None
+        processedData = None
+        if backtestDuration == 0:
+            fullData, processedData = screener.preprocessData(
+                    data, daysToLookback=configManager.effectiveDaysToLookback
+                )
+            if processedData.empty:
+                raise StockDataEmptyException(f"Empty processedData with data length ({len(data)})")
+            if portfolio:
+                data = data[::-1]
+                screener.validateLTPForPortfolioCalc(
+                        data, screeningDictionary, saveDictionary,requestedPeriod=backtestDuration
+                    )
+                data = data[::-1]
+        else:
+            if data is None or fullData is None or processedData is None:
+                    # data will have the oldest date at the top and the most recent
+                    # date will be at the bottom
+                    # We want to have the nth day treated as today when pre-processing where n = backtestDuration row from the bottom
+                inputData = data.head(len(data) - backtestDuration)
+                    # imputData will have the last row as the date for which the entire calculation
+                    # and prediction is being done
+                data = data.tail(
+                        backtestDuration + 1
+                    )  # .head(backtestPeriodToLookback+1)
+                    # Let's get today's data
+                if portfolio:
+                    screener.validateLTPForPortfolioCalc(
+                            data, screeningDictionary, saveDictionary,requestedPeriod=backtestDuration
+                        )
+                    # data has the last row from inputData at the top.
+                fullData, processedData = screener.preprocessData(
+                        inputData, daysToLookback=configManager.daysToLookback
+                    )
+                
+        return fullData,processedData,data
+
+    def getRelevantDataForStock(self, totalSymbols, shouldCache, stock, downloadOnly, printCounter, backtestDuration, hostRef,objectDictionary, configManager, fetcher, period, duration, testData=None,exchangeName="INDIA"):
+        hostData = objectDictionary.get(stock) if (objectDictionary is not None and len(objectDictionary) > 0) else None
+        data = None
+        hostDataLength = 0 if hostData is None else (0 if "data" not in hostData.keys() else len(hostData["data"]))
+        start = None
+        if (period == '1d' or configManager.duration[-1] == "m"):
+            if backtestDuration > 0: # We are backtesting
+                start = PKDateUtilities.nthPastTradingDateStringFromFutureDate(backtestDuration)
+                end = PKDateUtilities.nthPastTradingDateStringFromFutureDate(backtestDuration-1)
+            else:
+                # Since this is intraday data, we'd just need to start from the last trading session
+                start = PKDateUtilities.tradingDate().strftime("%Y-%m-%d")
+                end = PKDateUtilities.currentDateTime().strftime("%Y-%m-%d")
+        if (
+                not shouldCache
+                or (downloadOnly and hostData is None)
+                or (hostData is None and self.isTradingTime)
+                or hostData is None or hostDataLength == 0
+            ):
+            if testData is not None:
+                data = testData
+            else:
+                data = fetcher.fetchStockData(
+                        stock,
+                        period,
+                        configManager.duration if duration is None else duration,
+                        hostRef.proxyServer,
+                        hostRef.processingResultsCounter,
+                        hostRef.processingCounter,
+                        totalSymbols,
+                        start=start,
+                        end=start,
+                        exchangeSuffix=".NS" if exchangeName == "INDIA" else "",
+                        printCounter=printCounter
+                    )
+                if hostData is not None and data is not None:
+                    # During the market trading hours, we don't want to go for MFI/FV value fetching
+                    # So let's copy the old saved ones.
+                    try:
+                        data["MF"] = hostData["MF"]
+                        data["MF_Date"] = hostData["MF_Date"]
+                    except KeyError:
+                        pass
+                    try:
+                        data["FII"] = hostData["FII"]
+                        data["FII_Date"] = hostData["FII_Date"]
+                    except KeyError:
+                        pass
+                    try:
+                        data["FairValue"] = hostData["FairValue"]
+                    except KeyError:
+                        pass
+        else:
+            self.printProcessingCounter(totalSymbols, stock, printCounter, hostRef)
+            # data = hostData
+            try:
+                columns = hostData["columns"]
+                data = pd.DataFrame(
+                        hostData["data"], columns=columns, index=hostData["index"]
+                    )
+            except (ValueError, AssertionError) as e:
+                # 9 columns passed, passed data had 11 columns
+                # 10 columns passed, passed data had 11 columns
+                excLookingFor = " columns passed, passed data had "
+                if excLookingFor in str(e):
+                    e_diff = str(e).replace(excLookingFor,",").replace(" columns","").split(",")
+                    num_diff = int(e_diff[1]) - int(e_diff[0])
+                    while (num_diff > 0):
+                        columns.append(f"temp{num_diff}")
+                        num_diff -= 1
+                    data = pd.DataFrame(
+                            hostData["data"], columns=columns, index=hostData["index"]
+                        )
+                else:
+                    hostRef.default_logger.debug(e, exc_info=True)
+                pass
+
+        if ((shouldCache and not self.isTradingTime and (hostData is None  or hostDataLength == 0)) or downloadOnly) \
+            or (shouldCache and hostData is None):  # and backtestDuration == 0 # save only if we're NOT backtesting
+                if start is None and data is not None:
+                    objectDictionary[stock] = data.to_dict("split")
+                if downloadOnly:
+                    with hostRef.processingResultsCounter.get_lock():
+                        hostRef.processingResultsCounter.value += 1
+                    raise ScreeningStatistics.DownloadDataOnly
+                else:
+                    hostData = objectDictionary.get(stock)
+        return data
+
+    def determineBasicConfigs(self, stock, newlyListedOnly, volumeRatio, logLevel, hostRef, configManager, screener, userArgsLog):
+        if userArgsLog:
+            self.setupLoggers(hostRef, screener, logLevel, stock)
+        period = configManager.period
+        if volumeRatio <= 0:
+            volumeRatio = configManager.volumeRatio
+            # Data download adjustment for Newly Listed only feature
+        if newlyListedOnly:
+            if int(configManager.period[:-1]) > 250:
+                period = "250d"
+            else:
+                period = configManager.period
+        return volumeRatio,period
+
+    def printProcessingCounter(self, totalSymbols, stock, printCounter, hostRef):
+        if printCounter:
+            try:
+                OutputControls().printOutput(
+                            colorText.BOLD
+                            + colorText.GREEN
+                            + (
+                                "[%d%%] Screened %d, Found %d. Fetching data & Analyzing %s..."
+                                % (
+                                    int(
+                                        (hostRef.processingCounter.value / totalSymbols)
+                                        * 100
+                                    ),
+                                    hostRef.processingCounter.value,
+                                    hostRef.processingResultsCounter.value,
+                                    stock,
+                                )
+                            )
+                            + colorText.END,
+                            end="",
+                        )
+                OutputControls().printOutput(
+                            colorText.BOLD
+                            + colorText.GREEN
+                            + "=> Done!"
+                            + colorText.END,
+                            end="\r",
+                            flush=True,
+                        )
+            except ZeroDivisionError as e:
+                hostRef.default_logger.debug(e, exc_info=True)
+                pass
+            sys.stdout.write("\r\033[K")
+    
+    def setupLoggers(self, hostRef, screener, logLevel, stock):
+        # Set the loglevels for both the caller and screener
+        # Also add handlers that are specific to this sub-process which
+        # will continue with the screening. Each sub-process would have
+        # its own logger but going into the same file/console > to that
+        # of the parent logger.
+        # if hostRef.default_logger.level > 0:
+        #     return
+        # else:
+        # hostRef.default_logger.info(f"Beginning the stock screening for stock:{stock}")
+        # hostRef.default_logger.level = logLevel
+        screener.default_logger = hostRef.default_logger
+        # log_file_path = os.path.join(Archiver.get_user_outputs_dir(), "pkscreener-logs.txt")
+        # hostRef.default_logger.addHandlers(log_file_path=log_file_path, levelname=logLevel)
+        # screener.default_logger.addHandlers(log_file_path=log_file_path, levelname=logLevel)
+        # hostRef.default_logger.info(f"Beginning the stock screening for stock:{stock}")
+
+    def initResultDictionaries(self):
+        periods = self.configManager.periodsRange
+        columns = [
+            "Stock",
+            "LTP",
+            "%Chng",
+            "52Wk H",
+            "52Wk L",
+            "RSI",
+            "RSIi",
+            "Volume",
+            "22-Pd %",
+            "Consol.",
+            "Breakout",
+            "MA-Signal",
+            "Trend",
+            "Pattern",
+            "CCI",
+            "FairValue"
+        ]
+        screeningDictionary = {
+            "Stock": "",
+            "LTP": 0,
+            "%Chng": 0,
+            "52Wk H": 0,
+            "52Wk L": 0,
+            "RSI": 0,
+            "RSIi": 0,
+            "Volume": "",
+            "22-Pd %": "",
+            "Consol.": "Range:0%",
+            "Breakout": "BO: 0 R: 0",
+            "MA-Signal": "",
+            "Trend": "",
+            "Pattern": "",
+            "CCI": 0,
+            "FairValue": "-"
+        }
+        saveDictionary = {
+            "Stock": "",
+            "LTP": 0,
+            "%Chng": 0,
+            "52Wk H": 0,
+            "52Wk L": 0,
+            "RSI": 0,
+            "RSIi": 0,
+            "Volume": "",
+            "22-Pd %": "",
+            "Consol.": "Range:0%",
+            "Breakout": "BO: 0 R: 0",
+            "MA-Signal": "",
+            "Trend": "",
+            "Pattern": "",
+            "CCI": 0,
+            "FairValue": "-"
+        }
+        for prd in periods:
+            columns.append(f"LTP{prd}")
+            columns.append(f"Growth{prd}")
+            screeningDictionary[f"LTP{prd}"] = np.nan
+            saveDictionary[f"LTP{prd}"] = np.nan
+            screeningDictionary[f"Growth{prd}"] = np.nan
+            saveDictionary[f"Growth{prd}"] = np.nan
+
+        screenResults = pd.DataFrame(columns=columns)
+
+        return screeningDictionary, saveDictionary
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/UserMenuChoicesHandler.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/UserMenuChoicesHandler.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,109 +1,109 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import sys
-from PKDevTools.classes.ColorText import colorText
-from PKDevTools.classes.OutputControls import OutputControls
-
-import pkscreener.classes.ConfigManager as ConfigManager
-import pkscreener.classes.Utility as Utility
-
-class UserMenuChoicesHandler:
-    configManager = ConfigManager.tools()
-    configManager.getConfig(ConfigManager.parser)
-
-    def getDownloadChoices(defaultAnswer=None):
-        global userPassedArgs
-        argsIntraday = userPassedArgs is not None and userPassedArgs.intraday is not None
-        intradayConfig = UserMenuChoicesHandler.configManager.isIntradayConfig()
-        intraday = intradayConfig or argsIntraday
-        exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday)
-        if exists:
-            shouldReplace = Utility.tools.promptFileExists(
-                cache_file=cache_file, defaultAnswer=defaultAnswer
-            )
-            if shouldReplace == "N":
-                OutputControls().printOutput(
-                    cache_file
-                    + colorText.END
-                    + " already exists. Exiting as user chose not to replace it!"
-                )
-                sys.exit(0)
-            else:
-                pattern = f"{'intraday_' if intraday else ''}stock_data_*.pkl"
-                UserMenuChoicesHandler.configManager.deleteFileWithPattern(pattern)
-        return "X", 12, 0, {"0": "X", "1": "12", "2": "0"}
-
-    def getTopLevelMenuChoices(startupoptions, testBuild, downloadOnly, defaultAnswer=None):
-        global selectedChoice, userPassedArgs
-        executeOption = None
-        menuOption = None
-        indexOption = None
-        options = []
-        if startupoptions is not None:
-            options = startupoptions.split(":")
-            menuOption = options[0] if len(options) >= 1 else None
-            indexOption = options[1] if len(options) >= 2 else None
-            executeOption = options[2] if len(options) >= 3 else None
-        if testBuild:
-            menuOption, indexOption, executeOption, selectedChoice = UserMenuChoicesHandler.getTestBuildChoices(
-                indexOption=indexOption,
-                executeOption=executeOption,
-                menuOption=menuOption,
-            )
-        elif downloadOnly:
-            menuOption, indexOption, executeOption, selectedChoice = UserMenuChoicesHandler.getDownloadChoices(
-                defaultAnswer=defaultAnswer
-            )
-            intraday = userPassedArgs.intraday or UserMenuChoicesHandler.configManager.isIntradayConfig()
-            filePrefix = "INTRADAY_" if intraday else ""
-            _, cache_file_name = Utility.tools.afterMarketStockDataExists(intraday)
-            Utility.tools.set_github_output(f"{filePrefix}DOWNLOAD_CACHE_FILE_NAME",cache_file_name)
-        return options, menuOption, indexOption, executeOption
-    
-    def getTestBuildChoices(indexOption=None, executeOption=None, menuOption=None):
-        if menuOption is not None:
-            return (
-                str(menuOption),
-                indexOption if indexOption is not None else 1,
-                executeOption if executeOption is not None else 0,
-                {
-                    "0": str(menuOption),
-                    "1": (str(indexOption) if indexOption is not None else 1),
-                    "2": (str(executeOption) if executeOption is not None else 0),
-                },
-            )
-        return "X", 1, 0, {"0": "X", "1": "1", "2": "0"}
-    
-    def handleExitRequest(executeOption):
-        if executeOption == "Z":
-            input(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] Press <Enter> to Exit!"
-                + colorText.END
-            )
-            sys.exit(0)
-    
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import sys
+from PKDevTools.classes.ColorText import colorText
+from PKDevTools.classes.OutputControls import OutputControls
+
+import pkscreener.classes.ConfigManager as ConfigManager
+import pkscreener.classes.Utility as Utility
+
+class UserMenuChoicesHandler:
+    configManager = ConfigManager.tools()
+    configManager.getConfig(ConfigManager.parser)
+
+    def getDownloadChoices(defaultAnswer=None):
+        global userPassedArgs
+        argsIntraday = userPassedArgs is not None and userPassedArgs.intraday is not None
+        intradayConfig = UserMenuChoicesHandler.configManager.isIntradayConfig()
+        intraday = intradayConfig or argsIntraday
+        exists, cache_file = Utility.tools.afterMarketStockDataExists(intraday)
+        if exists:
+            shouldReplace = Utility.tools.promptFileExists(
+                cache_file=cache_file, defaultAnswer=defaultAnswer
+            )
+            if shouldReplace == "N":
+                OutputControls().printOutput(
+                    cache_file
+                    + colorText.END
+                    + " already exists. Exiting as user chose not to replace it!"
+                )
+                sys.exit(0)
+            else:
+                pattern = f"{'intraday_' if intraday else ''}stock_data_*.pkl"
+                UserMenuChoicesHandler.configManager.deleteFileWithPattern(pattern)
+        return "X", 12, 0, {"0": "X", "1": "12", "2": "0"}
+
+    def getTopLevelMenuChoices(startupoptions, testBuild, downloadOnly, defaultAnswer=None):
+        global selectedChoice, userPassedArgs
+        executeOption = None
+        menuOption = None
+        indexOption = None
+        options = []
+        if startupoptions is not None:
+            options = startupoptions.split(":")
+            menuOption = options[0] if len(options) >= 1 else None
+            indexOption = options[1] if len(options) >= 2 else None
+            executeOption = options[2] if len(options) >= 3 else None
+        if testBuild:
+            menuOption, indexOption, executeOption, selectedChoice = UserMenuChoicesHandler.getTestBuildChoices(
+                indexOption=indexOption,
+                executeOption=executeOption,
+                menuOption=menuOption,
+            )
+        elif downloadOnly:
+            menuOption, indexOption, executeOption, selectedChoice = UserMenuChoicesHandler.getDownloadChoices(
+                defaultAnswer=defaultAnswer
+            )
+            intraday = userPassedArgs.intraday or UserMenuChoicesHandler.configManager.isIntradayConfig()
+            filePrefix = "INTRADAY_" if intraday else ""
+            _, cache_file_name = Utility.tools.afterMarketStockDataExists(intraday)
+            Utility.tools.set_github_output(f"{filePrefix}DOWNLOAD_CACHE_FILE_NAME",cache_file_name)
+        return options, menuOption, indexOption, executeOption
+    
+    def getTestBuildChoices(indexOption=None, executeOption=None, menuOption=None):
+        if menuOption is not None:
+            return (
+                str(menuOption),
+                indexOption if indexOption is not None else 1,
+                executeOption if executeOption is not None else 0,
+                {
+                    "0": str(menuOption),
+                    "1": (str(indexOption) if indexOption is not None else 1),
+                    "2": (str(executeOption) if executeOption is not None else 0),
+                },
+            )
+        return "X", 1, 0, {"0": "X", "1": "1", "2": "0"}
+    
+    def handleExitRequest(executeOption):
+        if executeOption == "Z":
+            input(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] Press <Enter> to Exit!"
+                + colorText.END
+            )
+            sys.exit(0)
+
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Utility.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Utility.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,1611 +1,1611 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import copy
-import datetime
-import glob
-import math
-import os
-import shutil
-import sys
-import textwrap
-import random
-
-os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
-os.environ["AUTOGRAPH_VERBOSITY"] = "0"
-
-import pickle
-import platform
-import tempfile
-import time
-
-import joblib
-import numpy as np
-import pytz
-from genericpath import isfile
-from PKDevTools.classes.log import default_logger
-from PKDevTools.classes.ColorText import colorText
-from pkscreener import Imports
-
-import warnings
-from time import sleep
-
-warnings.simplefilter("ignore", DeprecationWarning)
-warnings.simplefilter("ignore", FutureWarning)
-import pandas as pd
-from alive_progress import alive_bar
-from PIL import Image, ImageDraw, ImageFont
-from PKDevTools.classes import Archiver
-from PKDevTools.classes.PKDateUtilities import PKDateUtilities
-from PKDevTools.classes.Committer import Committer
-from PKDevTools.classes.SuppressOutput import SuppressOutput
-from PKDevTools.classes.FunctionTimeouts import exit_after
-from tabulate import tabulate
-
-import pkscreener.classes.ConfigManager as ConfigManager
-import pkscreener.classes.Fetcher as Fetcher
-from pkscreener.classes import VERSION, Changelog
-from pkscreener.classes.MenuOptions import menus
-from PKNSETools.PKNSEStockDataFetcher import nseStockDataFetcher
-from pkscreener.classes.PKTask import PKTask
-from pkscreener.classes.MarketStatus import MarketStatus
-from pkscreener.classes.PKScheduler import PKScheduler
-from PKDevTools.classes.OutputControls import OutputControls
-from PKDevTools.classes.Utils import random_user_agent
-
-from pkscreener.classes.ArtTexts import getArtText
-from PKDevTools.classes.NSEMarketStatus import NSEMarketStatus
-
-configManager = ConfigManager.tools()
-configManager.getConfig(ConfigManager.parser)
-nseFetcher = nseStockDataFetcher()
-fetcher = Fetcher.screenerStockDataFetcher()
-
-
-artText = f"{getArtText()}\nv{VERSION}"
-
-STD_ENCODING=sys.stdout.encoding if sys.stdout is not None else 'utf-8'
-
-def marketStatus():
-    # task = PKTask("Nifty 50 Market Status",MarketStatus().getMarketStatus)
-    lngStatus = MarketStatus().marketStatus
-    nseStatus = ""
-    next_bell = ""
-    try:
-        nseStatus = NSEMarketStatus({},None).status
-        next_bell = NSEMarketStatus({},None).getNextBell()
-    except:
-        pass
-    # scheduleTasks(tasksList=[task])
-    if lngStatus == "":
-        lngStatus = MarketStatus().getMarketStatus(exchangeSymbol="^IXIC" if configManager.defaultIndex == 15 else "^NSEI")
-    if "Close" in lngStatus and nseStatus == "Open":
-        lngStatus = lngStatus.replace("Closed","Open")
-    if len(next_bell) > 0 and next_bell not in lngStatus:
-        lngStatus = f"{lngStatus} | Next Bell: {colorText.WARN}{next_bell.replace('T',' ').split('+')[0]}{colorText.END}"
-    return (lngStatus +"\n") if lngStatus is not None else "\n"
-
-art = colorText.GREEN + f"{getArtText()}\nv{VERSION}" + colorText.END + f" | {marketStatus()}"
-
-lastScreened = os.path.join(
-    Archiver.get_user_outputs_dir(), "last_screened_results.pkl"
-)
-
-# Class for managing misc and utility methods
-
-class tools:
-    def clearScreen(userArgs=None,clearAlways=False,forceTop=False):
-        if "RUNNER" in os.environ.keys() or (userArgs is not None and userArgs.prodbuild):
-            if userArgs is not None and userArgs.v:
-                os.environ["RUNNER"]="LOCAL_RUN_SCANNER"
-            return
-        elif (userArgs is not None and userArgs.runintradayanalysis):
-            return
-        if clearAlways or OutputControls().enableMultipleLineOutput:
-            if platform.system() == "Windows":
-                try:
-                    os.system('color 0f') # sets the background to black with white forerground
-                except:
-                    pass
-                if clearAlways:
-                    os.system("cls")
-            elif "Darwin" in platform.system():
-                if clearAlways:
-                    os.system("clear")
-                # default_logger().debug("Darwin does not work for setting background")
-            else:
-                try:
-                    os.system('setterm -background black -foreground white -store')
-                except:
-                    pass
-                if clearAlways:
-                    os.system("clear")
-            OutputControls().moveCursorToStartPosition()
-        try:
-            forceTop = OutputControls().enableMultipleLineOutput
-            if forceTop and OutputControls().lines == 0:
-                OutputControls().lines = 9
-                OutputControls().moveCursorToStartPosition()
-                
-            if clearAlways or OutputControls().enableMultipleLineOutput:
-                art = colorText.GREEN + f"{getArtText()}\nv{VERSION}" + colorText.END + f" | {marketStatus()}"
-                OutputControls().printOutput(art.encode('utf-8').decode(STD_ENCODING), enableMultipleLineOutput=True)
-        except Exception as e:# pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            pass
-
-    # Print about developers and repository
-    def showDevInfo(defaultAnswer=None):
-        OutputControls().printOutput("\n" + Changelog.changelog())
-        devInfo = "\n[+] Developer: PK (PKScreener)"
-        versionInfo = "[+] Version: %s" % VERSION
-        homePage = "[+] Home Page: https://github.com/pkjmesra/PKScreener\n[+] Telegram Bot:@nse_pkscreener_bot\n[+] Channel:https://t.me/PKScreener\n[+] Discussions:https://t.me/PKScreeners"
-        issuesInfo = (
-            "[+] Read/Post Issues here: https://github.com/pkjmesra/PKScreener/issues"
-        )
-        communityInfo = "[+] Join Community Discussions: https://github.com/pkjmesra/PKScreener/discussions"
-        latestInfo = "[+] Download latest software from https://github.com/pkjmesra/PKScreener/releases/latest"
-        OutputControls().printOutput(colorText.BOLD + colorText.WARN + devInfo + colorText.END)
-        OutputControls().printOutput(colorText.BOLD + colorText.WARN + versionInfo + colorText.END)
-        OutputControls().printOutput(colorText.BOLD + homePage + colorText.END)
-        OutputControls().printOutput(colorText.BOLD + colorText.FAIL + issuesInfo + colorText.END)
-        OutputControls().printOutput(colorText.BOLD + colorText.GREEN + communityInfo + colorText.END)
-        OutputControls().printOutput(colorText.BOLD + colorText.BLUE + latestInfo + colorText.END)
-        if defaultAnswer is None:
-            input(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] Press <Enter> to continue!"
-                + colorText.END
-            )
-        return f"\n{Changelog.changelog()}\n\n{devInfo}\n{versionInfo}\n\n{homePage}\n{issuesInfo}\n{communityInfo}\n{latestInfo}"
-
-    # Save last screened result to pickle file
-    def setLastScreenedResults(df, df_save=None, choices=None):
-        try:
-            finalStocks = ""
-            outputFolder = os.path.join(os.getcwd(),'actions-data-scan')
-            if not os.path.isdir(outputFolder):
-                os.makedirs(os.path.dirname(os.path.join(os.getcwd(),f"actions-data-scan{os.sep}")), exist_ok=True)
-            fileName = os.path.join(outputFolder,f"{choices}.txt")
-            items = []
-            needsWriting = False
-            if os.path.isfile(fileName):
-                if df is not None and len(df) > 0:
-                    #File already exists. Let's combine because there are new stocks found
-                    with open(fileName, 'r') as fe:
-                        stocks = fe.read()
-                        items = stocks.replace("\n","").replace("\"","").split(",")
-                        stockList = sorted(list(filter(None,list(set(items)))))
-                        finalStocks = ",".join(stockList)
-            else:
-                needsWriting = True
-            if df is not None and len(df) > 0:
-                df.sort_values(by=["Stock"], ascending=True, inplace=True)
-                df.to_pickle(lastScreened)
-                if choices is not None and df_save is not None:
-                    df_s = df_save.copy()
-                    df_s.reset_index(inplace=True)
-                    newStocks = df_s["Stock"].to_json(orient='records', lines=True).replace("\n","").replace("\"","").split(",")
-                    items.extend(newStocks)
-                    stockList = sorted(list(filter(None,list(set(items)))))
-                    finalStocks = ",".join(stockList)
-                    needsWriting = True
-            if needsWriting:
-                with open(fileName, 'w') as f:
-                    f.write(finalStocks)
-        except IOError as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + f"{e}\n[+] Failed to save recently screened result table on disk! Skipping.."
-                + colorText.END
-            )
-        except Exception as e:# pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            pass
-
-    # Load last screened result to pickle file
-    def getLastScreenedResults(defaultAnswer=None):
-        try:
-            df = pd.read_pickle(lastScreened)
-            if df is not None and len(df) > 0:
-                OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.GREEN
-                    + "\n[+] Showing recently screened results..\n"
-                    + colorText.END
-                )
-                df.sort_values(by=["Volume"], ascending=False, inplace=True)
-                OutputControls().printOutput(
-                    colorText.miniTabulator().tabulate(
-                        df, headers="keys", tablefmt=colorText.No_Pad_GridFormat,
-                        maxcolwidths=tools.getMaxColumnWidths(df)
-                    ).encode("utf-8").decode(STD_ENCODING)
-                )
-                OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + "[+] Note: Trend calculation is based on number of recent days to screen as per your configuration."
-                    + colorText.END
-                )
-            else:
-                OutputControls().printOutput("Nothing to show here!")
-        except FileNotFoundError as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] Failed to load recently screened result table from disk! Skipping.."
-                + colorText.END
-            )
-        if defaultAnswer is None:
-            input(
-                colorText.BOLD
-                + colorText.GREEN
-                + "[+] Press <Enter> to continue.."
-                + colorText.END
-            )
-
-    def formattedBacktestOutput(outcome, pnlStats=False, htmlOutput=True):
-        if not pnlStats:
-            if htmlOutput:
-                if outcome >= 80:
-                    return f'{colorText.GREEN}{"%.2f%%" % outcome}{colorText.END}'
-                if outcome >= 60:
-                    return f'{colorText.WARN}{"%.2f%%" % outcome}{colorText.END}'
-                return f'{colorText.FAIL}{"%.2f%%" % outcome}{colorText.END}'
-            else:
-                return f'{colorText.GREEN}{"%.2f%%" % outcome}{colorText.END}'
-        else:
-            if outcome >= 0:
-                return f'{colorText.GREEN}{"%.2f%%" % outcome}{colorText.END}'
-            return f'{colorText.FAIL}{"%.2f%%" % outcome}{colorText.END}'
-
-    def getFormattedBacktestSummary(x, pnlStats=False, columnName=None):
-        if x is not None and "%" in str(x):
-            values = x.split("%")
-            if (
-                len(values) == 2
-                and columnName is not None
-                and ("-Pd" in columnName or "Overall" in columnName)
-            ):
-                return "{0}{1}".format(
-                    tools.formattedBacktestOutput(
-                        float(values[0]), pnlStats=pnlStats, htmlOutput=False
-                    ),
-                    values[1],
-                )
-        return x
-
-    def formatRatio(ratio, volumeRatio):
-        if ratio >= volumeRatio and ratio != np.nan and (not math.isinf(ratio)):
-            return colorText.BOLD + colorText.GREEN + str(ratio) + "x" + colorText.END
-        return colorText.BOLD + colorText.FAIL + (f"{ratio}x" if pd.notna(ratio) else "") + colorText.END
-
-    def addQuickWatermark(sourceImage:Image, xVertical=None, dataSrc="", dataSrcFontSize=10):
-        width, height = sourceImage.size
-        watermarkText = f" {datetime.date.today().year} pkjmesra | PKScreener"
-        message_length = len(watermarkText)
-        # load font (tweak ratio based on a particular font)
-        FONT_RATIO = 1.5
-        DIAGONAL_PERCENTAGE = .85
-        DATASRC_FONTSIZE = dataSrcFontSize
-        dataSrc = f"Src: {dataSrc}"
-        diagonal_length = int(math.sqrt((width**2) + (height**2)))
-        diagonal_to_use = diagonal_length * DIAGONAL_PERCENTAGE
-        height_to_use = height * DIAGONAL_PERCENTAGE
-        font_size = int(diagonal_to_use / (message_length / FONT_RATIO))
-        font_size_vertical = int(height_to_use / (message_length / FONT_RATIO))
-        fontPath = tools.setupReportFont()
-        font = ImageFont.truetype(fontPath, font_size)
-        font_vertical = ImageFont.truetype(fontPath, font_size_vertical)
-        #font = ImageFont.load_default() # fallback
-
-        # watermark
-        opacity = int(256 * .6)
-        mark_width, mark_height = font.getsize(watermarkText)
-        watermark = Image.new('RGBA', (mark_width, mark_height), (0, 0, 0, 0))
-        draw = ImageDraw.Draw(watermark)
-        draw.text((0, 0), text=watermarkText, font=font, fill=(128, 128, 128, opacity))
-        angle = math.degrees(math.atan(height/width))
-        watermark_diag = watermark.rotate(angle, expand=1)
-        
-        mark_width_ver, mark_height_ver = font_vertical.getsize(watermarkText)
-        watermark_ver = Image.new('RGBA', (mark_width_ver, mark_height_ver), (0, 0, 0, 0))
-        draw = ImageDraw.Draw(watermark_ver)
-        draw.text((0, 0), text=watermarkText, font=font_vertical, fill=(128, 128, 128, opacity))
-        watermark_vertical = watermark_ver.rotate(90, expand=1)
-
-        # merge
-        wx, wy = watermark_diag.size
-        px = int((width - wx)/2)
-        py = int((height - wy)/2)
-        wxv, wyv = watermark_vertical.size
-        pxv =  int((width - wxv)/12) if xVertical is None else xVertical
-        pyv= int((height - wyv)/2)
-        sourceImage.paste(watermark_diag, (px, py, px + wx, py + wy), watermark_diag)
-        sourceImage.paste(watermark_vertical, (pxv, pyv, pxv + wxv, pyv + wyv), watermark_vertical)
-        
-        # Draw the data sources
-        dataSrcFont = ImageFont.truetype(fontPath, DATASRC_FONTSIZE)
-        dataSrc_width, dataSrc_height = dataSrcFont.getsize_multiline(dataSrc)
-        draw = ImageDraw.Draw(sourceImage)
-        draw.text((width-dataSrc_width, height-dataSrc_height-2), text=dataSrc, font=dataSrcFont, fill=(128, 128, 128, opacity))
-        # sourceImage.show()
-        return sourceImage
-
-    def roundOff(value,places):
-        roundValue = value
-        try:
-            newValue = tools.removeAllColorStyles(str(roundValue))
-            newValue = newValue.replace("%","").replace("x","")
-            roundValue = round(float(newValue),places)
-            if places == 0:
-                roundValue = int(roundValue)
-            roundValue = str(value).replace(str(newValue),str(roundValue))
-        except:
-            pass
-        return roundValue
-    
-    def removeAllColorStyles(styledText):
-        styles = [
-            colorText.HEAD,
-            colorText.END,
-            colorText.BOLD,
-            colorText.UNDR,
-            colorText.BLUE,
-            colorText.GREEN,
-            colorText.WARN,
-            colorText.FAIL,
-            colorText.WHITE,
-        ]
-        cleanedUpStyledValue = str(styledText)
-        for style in styles:
-            cleanedUpStyledValue = cleanedUpStyledValue.replace(style, "")
-        return cleanedUpStyledValue
-
-    def getCellColors(cellStyledValue="", defaultCellFillColor="black"):
-        otherStyles = [colorText.HEAD, colorText.BOLD, colorText.UNDR]
-        mainStyles = [
-            colorText.BLUE,
-            colorText.GREEN,
-            colorText.WARN,
-            colorText.FAIL,
-            colorText.WHITE,
-        ]
-        colorsDict = {
-            colorText.BLUE: "blue",
-            colorText.GREEN: "darkgreen"
-            if defaultCellFillColor == "black"
-            else "lightgreen",
-            colorText.WARN: "darkorange"
-            if defaultCellFillColor == "black"
-            else "yellow",
-            colorText.FAIL: "red",
-            colorText.WHITE: "white" 
-            if defaultCellFillColor == "white"
-            else "black",
-        }
-        cleanedUpStyledValues = []
-        cellFillColors = []
-        cleanedUpStyledValue = cellStyledValue
-        prefix = ""
-        for style in otherStyles:
-            cleanedUpStyledValue = cleanedUpStyledValue.replace(style, "")
-        # Find how many different colors are used for the cell value
-        coloredStyledValues = cleanedUpStyledValue.split(colorText.END)
-        for cleanedUpStyledValue in coloredStyledValues:
-            cleanedUpStyledValue = cleanedUpStyledValue.replace(colorText.END,"")
-            if cleanedUpStyledValue.strip() in ["", ",","/"]:
-                if len(cleanedUpStyledValues) > 0:
-                    cleanedUpStyledValues[len(cleanedUpStyledValues)-1] = f"{cleanedUpStyledValues[len(cleanedUpStyledValues)-1]}{cleanedUpStyledValue}"
-                else:
-                    prefix = cleanedUpStyledValue
-            else:
-                for style in mainStyles:
-                    if style in cleanedUpStyledValue:
-                        cellFillColors.append(colorsDict[style])
-                        for style in mainStyles:
-                            cleanedUpStyledValue = cleanedUpStyledValue.replace(style, "")
-                        cleanedUpStyledValues.append(prefix + cleanedUpStyledValue)
-                        prefix = ""
-                
-        if len(cellFillColors) == 0:
-            cellFillColors = [defaultCellFillColor]
-        if len(cleanedUpStyledValues) == 0:
-            cleanedUpStyledValues = [cellStyledValue]
-        return cellFillColors, cleanedUpStyledValues
-
-    def tableToImage(
-        table,
-        styledTable,
-        filename,
-        label,
-        backtestSummary=None,
-        backtestDetail=None,
-        addendum=None,
-        addendumLabel=None,
-        summaryLabel = None,
-        detailLabel = None,
-        legendPrefixText = ""
-    ):
-        if "PKDevTools_Default_Log_Level" not in os.environ.keys():
-            if (("RUNNER" in os.environ.keys() and os.environ["RUNNER"] == "LOCAL_RUN_SCANNER")):
-                return
-        warnings.filterwarnings("ignore", category=DeprecationWarning)
-        ART_FONT_SIZE = 30
-        STD_FONT_SIZE = 60
-        # First 4 lines are headers. Last 1 line is bottom grid line
-        fontPath = tools.setupReportFont()
-        artfont = ImageFont.truetype(fontPath, ART_FONT_SIZE)
-        stdfont = ImageFont.truetype(fontPath, STD_FONT_SIZE)
-        
-        bgColor, gridColor, artColor, menuColor = tools.getDefaultColors()
-
-        dfs_to_print = [styledTable, backtestSummary, backtestDetail]
-        unstyled_dfs = [table, backtestSummary, backtestDetail]
-        reportTitle = f"[+] As of {PKDateUtilities.currentDateTime().strftime('%d-%m-%y %H.%M.%S')} IST > You chose {label}"
-        titleLabels = [
-            f"[+] Scan results for {label} :",
-            summaryLabel if summaryLabel is not None else "[+] For chosen scan, summary of correctness from past: [Example, 70% of (100) under 1-Pd, means out of 100 stocks that were in the scan result in the past, 70% of them gained next day.)",
-            detailLabel if detailLabel is not None else "[+] 1 to 30 period gain/loss % for matching stocks on respective date from earlier predictions:[Example, 5% under 1-Pd, means the stock price actually gained 5% the next day from given date.]",
-        ]
-
-        artfont_arttext_width, artfont_arttext_height = artfont.getsize_multiline(artText+ f" | {marketStatus()}")
-        stdFont_oneLinelabel_width, stdFont_oneLinelabel_height = stdfont.getsize_multiline(label)
-        stdFont_scanResulttext_width, stdFont_scanResulttext_height = stdfont.getsize_multiline(table) if len(table) > 0 else (0,0)
-        unstyled_backtestsummary = tools.removeAllColorStyles(backtestSummary)
-        unstyled_backtestDetail = tools.removeAllColorStyles(backtestDetail)
-        stdFont_backtestSummary_text_width,stdFont_backtestSummary_text_height= stdfont.getsize_multiline(unstyled_backtestsummary) if len(unstyled_backtestsummary) > 0 else (0,0)
-        stdFont_backtestDetail_text_width, stdFont_backtestDetail_text_height = stdfont.getsize_multiline(unstyled_backtestDetail) if len(unstyled_backtestDetail) > 0 else (0,0)
-        artfont_scanResultText_width, _ = artfont.getsize_multiline(table) if len(table) > 0 else (0,0)
-        artfont_backtestSummary_text_width, _ = artfont.getsize_multiline(backtestSummary) if (backtestSummary is not None and len(backtestSummary)) > 0 else (0,0)
-        stdfont_addendumtext_height = 0
-        stdfont_addendumtext_width = 0
-        if addendum is not None and len(addendum) > 0:
-            unstyled_addendum = tools.removeAllColorStyles(addendum)
-            stdfont_addendumtext_width , stdfont_addendumtext_height = stdfont.getsize_multiline(unstyled_addendum)
-            titleLabels.append(addendumLabel)
-            dfs_to_print.append(addendum)
-            unstyled_dfs.append(unstyled_addendum)
-
-        repoText = tools.getRepoHelpText(table,backtestSummary)
-        artfont_repotext_width, artfont_repotext_height = artfont.getsize_multiline(repoText)
-        legendText = legendPrefixText + tools.getLegendHelpText(table,backtestSummary)
-        _, artfont_legendtext_height = artfont.getsize_multiline(legendText)
-        column_separator = "|"
-        line_separator = "+"
-        stdfont_sep_width, _ = stdfont.getsize_multiline(column_separator)
-
-        startColValue = 100
-        xVertical = startColValue
-        rowPixelRunValue = 9
-        im_width = max(
-            artfont_arttext_width,
-            stdFont_oneLinelabel_width,
-            stdFont_scanResulttext_width,
-            stdFont_backtestSummary_text_width,
-            stdFont_backtestDetail_text_width,
-            artfont_repotext_width,
-            artfont_scanResultText_width,
-            artfont_backtestSummary_text_width,
-            stdfont_addendumtext_width
-        ) + int(startColValue * 2)
-        im_height = int(
-                    artfont_arttext_height # Always
-                    + 3*stdFont_oneLinelabel_height # Title label # Always
-                    + stdFont_scanResulttext_height + (stdFont_oneLinelabel_height if stdFont_scanResulttext_height > 0 else 0)
-                    + stdFont_backtestSummary_text_height + (stdFont_oneLinelabel_height if stdFont_backtestSummary_text_height > 0 else 0)
-                    + stdFont_backtestDetail_text_height + (stdFont_oneLinelabel_height if stdFont_backtestDetail_text_height > 0 else 0)
-                    + artfont_repotext_height # Always
-                    + artfont_legendtext_height # Always
-                    + stdfont_addendumtext_height + (stdFont_oneLinelabel_height if stdfont_addendumtext_height > 0 else 0)
-                )
-        im = Image.new("RGB",(im_width,im_height),bgColor)
-        draw = ImageDraw.Draw(im)
-        # artwork
-        draw.text((startColValue, rowPixelRunValue), artText+ f" | {tools.removeAllColorStyles(marketStatus())}", font=artfont, fill=artColor)
-        rowPixelRunValue += artfont_arttext_height + 1
-        # Report title
-        draw.text((startColValue, rowPixelRunValue), reportTitle, font=stdfont, fill=menuColor)
-        rowPixelRunValue += stdFont_oneLinelabel_height + 1
-        counter = -1
-        for df in dfs_to_print:
-            counter += 1
-            colPixelRunValue = startColValue
-            if df is None or len(df) == 0:
-                continue
-            # selected menu options and As of DateTime
-            draw.text(
-                (colPixelRunValue, rowPixelRunValue),
-                titleLabels[counter],
-                font=stdfont,
-                fill=menuColor,
-            )
-            rowPixelRunValue += stdFont_oneLinelabel_height
-            unstyledLines = unstyled_dfs[counter].splitlines()
-            lineNumber = 0
-            screenLines = df.splitlines()
-            for line in screenLines:
-                _, stdfont_line_height = stdfont.getsize_multiline(line)
-                # Print the row separators
-                if not (line.startswith(column_separator)):
-                    draw.text(
-                        (colPixelRunValue, rowPixelRunValue),
-                        line,
-                        font=stdfont,
-                        fill=gridColor,
-                    )
-                    rowPixelRunValue += stdfont_line_height + 1
-                else: # if (line.startswith(column_separator)):
-                    # Print the row contents
-                    columnNumber = 0
-                    valueScreenCols = line.split(column_separator)
-                    try:
-                        del valueScreenCols[0] # Remove the empty column header at the first position
-                        del valueScreenCols[-1] # Remove the empty column header at the last position
-                    except Exception as e:# pragma: no cover
-                        default_logger().debug(e, exc_info=True)
-                        draw.text(
-                            (colPixelRunValue, rowPixelRunValue),
-                            line,
-                            font=stdfont,
-                            fill=gridColor,
-                        )
-                        lineNumber = lineNumber - 1
-                        pass
-                    # Print each colored value of each cell as we go over each row
-                    for val in valueScreenCols:
-                        if lineNumber >= len(unstyledLines):
-                            continue
-                        # Draw the column separator first
-                        draw.text(
-                            (colPixelRunValue, rowPixelRunValue),
-                            column_separator,
-                            font=stdfont,
-                            fill=gridColor,
-                        )
-                        colPixelRunValue = colPixelRunValue + stdfont_sep_width
-                        unstyledLine = unstyledLines[lineNumber]
-                        cellStyles, cellCleanValues = tools.getCellColors(
-                            val, defaultCellFillColor=gridColor
-                        )
-                        valCounter = 0
-                        for style in cellStyles:
-                            cleanValue = cellCleanValues[valCounter]
-                            valCounter += 1
-                            if columnNumber == 0 and len(cleanValue.strip()) > 0:
-                                if column_separator in unstyledLine:
-                                    cleanValue = unstyledLine.split(column_separator)[1]
-                                if "\\" in cleanValue:
-                                    cleanValue = cleanValue.split("\\")[-1]
-                                # style = style if "%" in cleanValue else gridColor
-                            if bgColor == "white" and style == "yellow":
-                                # Yellow on a white background is difficult to read
-                                style = "blue"
-                            elif bgColor == "black" and style == "blue":
-                                # blue on a black background is difficult to read
-                                style = "yellow"
-                            col_width, _ = stdfont.getsize_multiline(cleanValue)
-                            draw.text(
-                                (colPixelRunValue, rowPixelRunValue),
-                                cleanValue,
-                                font=stdfont,
-                                fill=style,
-                            )
-                            colPixelRunValue = colPixelRunValue + col_width
-                            if columnNumber == 0:
-                                xVertical = int(columnNumber/2)
-
-                        columnNumber = columnNumber + 1
-                    if len(valueScreenCols) > 0:
-                        # Close the row with the separator
-                        draw.text(
-                            (colPixelRunValue, rowPixelRunValue),
-                            column_separator,
-                            font=stdfont,
-                            fill=gridColor,
-                        )
-                        colPixelRunValue = startColValue
-                    rowPixelRunValue +=  stdfont_line_height + 1
-                lineNumber = lineNumber + 1
-            rowPixelRunValue += stdFont_oneLinelabel_height
-        
-        # Repo text
-        draw.text(
-            (colPixelRunValue, rowPixelRunValue + 1),
-            repoText,
-            font=artfont,
-            fill=menuColor,
-        )
-        # Legend text
-        rowPixelRunValue += 2 * stdFont_oneLinelabel_height + 20
-        legendLines = legendText.splitlines()
-        legendSeperator = "***"
-        col_width_sep, _ = artfont.getsize_multiline(legendSeperator)
-        for line in legendLines:
-            colPixelRunValue = startColValue
-            _, artfont_line_height = artfont.getsize_multiline(line)
-            lineitems = line.split(legendSeperator)
-            red = True
-            for lineitem in lineitems:
-                if lineitem == "" or not red:
-                    draw.text(
-                        (colPixelRunValue, rowPixelRunValue),
-                        legendSeperator,
-                        font=artfont,
-                        fill=gridColor,
-                    )
-                    colPixelRunValue += col_width_sep + 1
-                style = "red" if not red else gridColor
-                red = not red
-                lineitem = lineitem.replace(": ","***: ")
-                draw.text(
-                    (colPixelRunValue, rowPixelRunValue),
-                    lineitem,
-                    font=artfont,
-                    fill=style,
-                )
-                col_width, _ = artfont.getsize_multiline(lineitem)
-                # Move to the next text in the same line
-                colPixelRunValue += col_width + 1
-                
-            # Let's go to the next line
-            rowPixelRunValue += artfont_line_height + 1
-
-        im = im.resize(im.size, Image.ANTIALIAS, reducing_gap=2)
-        im = tools.addQuickWatermark(im,xVertical,dataSrc="Yahoo; Morningstar, Inc; National Stock Exchange of India Ltd;",dataSrcFontSize=ART_FONT_SIZE)
-        im.save(filename, format="png", bitmap_format="png", optimize=True, quality=20)
-        # if 'RUNNER' not in os.environ.keys() and 'PKDevTools_Default_Log_Level' in os.environ.keys():
-        # im.show()
-
-    def wrapFitLegendText(table, backtestSummary, legendText):
-        wrapper = textwrap.TextWrapper(
-            width=2
-            * int(
-                len(table.split("\n")[0])
-                if len(table) > 0
-                else len(backtestSummary.split("\n")[0])
-            )
-        )
-        word_list = wrapper.wrap(text=legendText)
-        legendText_new = ""
-        for ii in word_list[:-1]:
-            legendText_new = legendText_new + ii + "\n"
-        legendText_new += word_list[-1]
-        legendText = legendText_new
-        return legendText
-
-    def getDefaultColors():
-        artColors = ["blue", "indigo", "green", "red", "yellow","orange","violet"]
-        bgColor = "white" if PKDateUtilities.currentDateTime().day % 2 == 0 else "black"
-        gridColor = "black" if bgColor == "white" else "white"
-        artColor = random.choice(artColors[3:]) if bgColor == "black" else random.choice(artColors[:3])
-        menuColor = "red"
-        return bgColor,gridColor,artColor,menuColor
-
-    def setupReportFont():
-        fontURL = "https://raw.githubusercontent.com/pkjmesra/pkscreener/main/pkscreener/courbd.ttf"
-        fontFile = fontURL.split("/")[-1]
-        bData, fontPath, _ = Archiver.findFile(fontFile)
-        if bData is None:
-            resp = fetcher.fetchURL(fontURL, stream=True)
-            with open(fontPath, "wb") as f:
-                for chunk in resp.iter_content(chunk_size=1024):
-                    if chunk:  # filter out keep-alive new chunks
-                        f.write(chunk)
-        return fontPath
-
-    def getLegendHelpText(table,backtestSummary):
-        legendText = "\n***1.Stock***: This is the NSE symbol/ticker for a company. Stocks that are NOT stage two, are coloured red.***2.Consol.***: It shows the price range in which stock is trading for the last 22 trading sessions(22 trading sessions per month)***3.Breakout(22Prds)***: The BO is Breakout level based on last 22 sessions. R is the resistance level (if available)."
-        legendText = f"{legendText} An investor should consider both BO & R level to analyse entry / exits in their trading lessons. If the BO value is green, it means the stock has already broken out (is above BO level). If BO is in red, it means the stock is yet to break out.***4.LTP***: This is the last/latest trading/closing price of the given stock on a given date at NSE. The LTP in green/red means the"
-        legendText = f"{legendText} stock price has increased / decreased since last trading session. (1.5%, 1.3%,1.8%) with LTP shows the stock price rose by 1.5%, 1.3% and 1.8% in the last 1, 2 and 3 trading sessions respectively.***5.%Chng***: This is the change(rise/fall in percentage) in closing/trading price from the previous trading session's closing price. Green means that price rose from the previous"
-        legendText = f"{legendText} trading session. Red means it fell.***6.Volume***: This shows the relative volume in the most recent trading day /today with respect to last 20 trading periods moving average of Volume. For example, 8.5x would mean today's volume so far is 8.5 times the average volume traded in the last 20 trading sessions. Volume in green means that volume for the date so far has been at"
-        legendText = f"{legendText} least 2.5 times more than the average volume of last 20 sessions. If the volume is in red, it means the given date's volume is less than 2.5 times the avg volume of the last 20 sessions.***7.MA-Signal***: It shows the price trend of the given stock by analyzing various 50-200 moving/exponential averages crossover strategies. Perform a Google search for the shown MA-Signals"
-        legendText = f"{legendText} to learn about them more. If it is in green, the signal is bullish. Red means bearish.***8.RSI-or-RSI/i***: Relative Strength Index is a momentum index which describes 14-period relative strength at the given price. Generally, below 30 is considered oversold and above 80 is considered overbought. When RSI/i has value, say, 80/41, it means that the daily RSI value is 80 while"
-        legendText = f"{legendText} the 1-minute intraday RSI is 41.***9.Trend(22Prds)***:  This describes the average trendline computed based on the last 22 trading sessions. Their strength is displayed depending on the steepness of the trendlines. (Strong / Weak) Up / Down shows how high/low the demand is respectively. A Sideways trend is the horizontal price movement that occurs when the forces of supply"
-        legendText = f"{legendText} and demand are nearly equal. T: or T: shows the general moving average uptrend/downtrend from a 200 day MA perspective"
-        legendText = f"{legendText} if the current 200DMA is more/less than the last 20/80/100 days' 200DMA. Similarly, t: or t: shows for 50DMA based on 9/14/20 days' 50DMA trend. MFI: or MFI: shows"
-        legendText = f"{legendText} if the overall top 5 mutual funds and top 5 institutional investors ownership went up or down on the closing of the last month.***10.Pattern***:This shows if the chart or the candle (from the candlestick chart) is"
-        legendText = f"{legendText} forming any known pattern in the recent timeframe or as per the selected screening options. Do a google search for the shown pattern names to learn.***11.CCI***: The Commodity Channel Index (CCI) is a technical indicator that measures the difference between the current price and the historical average price of the given stock. Generally below '- 100' is considered oversold"
-        legendText = f"{legendText} and above 100 is considered overbought. If the CCI is < '-100' or CCI is > 100 and the Trend(22Prds) is Strong/Weak Up, it is shown in green. Otherwise it's in red.***12.1-Pd/2-Pd-etc.***: 60.29% of (413) under 1-Pd in green shows that the given scan option was correct 60.23% of the times for 413 stocks that scanner found in the last 22 trading sessions under the same scan"
-        legendText = f"{legendText} options. Similarly, 61.69 % of (154) in green under 22-Pd, means we found that 61.56% of 154 stocks (~95 stocks) prices found under the same scan options increased in 22 trading periods. 57.87% of (2661) under 'Overall' means that over the last 22 trading sessions we found 2661 stock instances under the same scanning options (for example, Momentum Gainers), out of which 57.87%"
-        legendText = f"{legendText} of the stock prices increased in one or more of the last 1 or 2 or 3 or 4 or 5 or 10 or 22 or 22 trading sessions. If you want to see by what percent the prices increased, you should see the details.***13.1-to-30-period-gain/loss%***: 4.17% under 1-Pd in green in the gain/loss table/grid means the stock price increased by 4.17% in the next 1 trading session. If this is in"
-        legendText = f"{legendText} red, example, -5.67%, it means the price actually decreased by 5.67%. Gains are in green and losses are in red in this grid. The Date column has the date(s) on which that specific stock was found under the chosen scan options in the past 22 trading sessions.***14.52Wk-H/L***: These have 52 weeks high/low prices and will be shown in red, green or yellow based on how close the"
-        legendText = f"{legendText} price is to the 52 wk high/low value.If the 52 week high/low value is within 10% of LTP:Yellow, LTP is above 52 week high:Green. If the LTP is below 90% of 52 week high:Red.***15.1-Pd-%***: Shows the 1 period gain in percent from the given date. Similarly 2-Pd-%, 3-Pd-% etc shows 2 day, 3 days gain etc.***16.1-Pd-10k***: Shows 1 period/day portfolio value if you would"
-        legendText = f"{legendText} have invested 10,000 on the given date.***17.[T][_trend_]***: [T] is for Trends followed by the trend name in the filter.***18.[BO]***: This Shows the Breakout filter value from the backtest reports and will be available only if 'showpaststrategydata' configuration is turned on.***19.[P]***: [P] shows pattern name.***20.MFI***: Top 5 Mutual fund ownership and "
-        legendText = f"{legendText} top 5 Institutional investor ownership status as on the last day of the last month, based on analysis from Morningstar.***21.FairValue***: Morningstar Fair value of a given stock as of last trading day as determined by 3rd party analysis based on fundamentals.***22.MCapWt%***: This shows the market-cap weighted portfolio weight to consider investing.\n"
-        legendText = tools.wrapFitLegendText(table,backtestSummary, legendText)
-        # legendText = legendText.replace("***:", colorText.END + colorText.WHITE)
-        # legendText = legendText.replace("***", colorText.END + colorText.FAIL)
-        # return colorText.WHITE + legendText + colorText.END
-        return legendText
-
-    def getRepoHelpText(table,backtestSummary):
-        repoText = f"Source: https://GitHub.com/pkjmesra/pkscreener/  |  {datetime.date.today().year} pkjmesra | Telegram: https://t.me/PKScreener |"
-        disclaimer = f"The author is NOT a financial advisor and is NOT SEBI registered. This report is for learning/analysis purposes ONLY. Author assumes no responsibility or liability for any errors or omissions in this report or repository, or gain/loss bearing out of this analysis. The user MUST take advise ONLY from registered SEBI financial advisors only."
-        repoText = f"{repoText}\n{tools.wrapFitLegendText(table,backtestSummary,disclaimer)}"
-        repoText = f"{repoText}\n[+] Understanding this report:\n\n"
-        return repoText
-
-    def set_github_output(name, value):
-        if "GITHUB_OUTPUT" in os.environ.keys():
-            with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
-                print(f"{name}={value}", file=fh)
-
-    def afterMarketStockDataExists(intraday=False, forceLoad=False):
-        curr = PKDateUtilities.currentDateTime()
-        openTime = curr.replace(hour=9, minute=15)
-        cache_date = PKDateUtilities.previousTradingDate(PKDateUtilities.nextTradingDate(curr)) #curr  # for monday to friday
-        weekday = curr.weekday()
-        isTrading = PKDateUtilities.isTradingTime()
-        if (forceLoad and isTrading) or isTrading:
-            #curr = PKDateUtilities.tradingDate()
-            cache_date = PKDateUtilities.previousTradingDate(curr) #curr - datetime.timedelta(1)
-        # for monday to friday before 9:15 or between 9:15am to 3:30pm, we're backtesting
-        if curr < openTime:
-            cache_date = PKDateUtilities.previousTradingDate(curr) # curr - datetime.timedelta(1)
-        if weekday == 0 and curr < openTime:  # for monday before 9:15
-            cache_date = PKDateUtilities.previousTradingDate(curr) #curr - datetime.timedelta(3)
-        if weekday == 5 or weekday == 6:  # for saturday and sunday
-            cache_date = PKDateUtilities.previousTradingDate(curr) # curr - datetime.timedelta(days=weekday - 4)
-        cache_date = cache_date.strftime("%d%m%y")
-        pattern = f"{'intraday_' if intraday else ''}stock_data_"
-        cache_file = pattern + str(cache_date) + ".pkl"
-        exists = False
-        for f in glob.glob(f"{pattern}*.pkl", root_dir=Archiver.get_user_outputs_dir()):
-            if f.endswith(cache_file):
-                exists = True
-                break
-        return exists, cache_file
-
-    def saveStockData(stockDict, configManager, loadCount, intraday=False, downloadOnly=False, forceSave=False):
-        exists, fileName = tools.afterMarketStockDataExists(
-            configManager.isIntradayConfig() or intraday
-        )
-        outputFolder = Archiver.get_user_outputs_dir()
-        if downloadOnly:
-            outputFolder = outputFolder.replace("results","actions-data-download")
-            if not os.path.isdir(outputFolder):
-                os.makedirs(os.path.dirname(f"{outputFolder}{os.sep}"), exist_ok=True)
-            configManager.deleteFileWithPattern(rootDir=outputFolder)
-        cache_file = os.path.join(outputFolder, fileName)
-        if not os.path.exists(cache_file) or forceSave or (loadCount >= 0 and len(stockDict) > (loadCount + 1)):
-            try:
-                with open(cache_file, "wb") as f:
-                    pickle.dump(stockDict.copy(), f, protocol=pickle.HIGHEST_PROTOCOL)
-                    OutputControls().printOutput(colorText.BOLD + colorText.GREEN + "=> Done." + colorText.END)
-                if downloadOnly:
-                    OutputControls().printOutput(colorText.BOLD + colorText.GREEN + f"=> {cache_file}" + colorText.END)
-                    Committer.execOSCommand(f"git add {cache_file} -f >/dev/null 2>&1")
-                    if "RUNNER" not in os.environ.keys():
-                        copyFilePath = os.path.join(Archiver.get_user_outputs_dir(), f"copy_{fileName}")
-                        cacheFileSize = os.stat(cache_file).st_size if os.path.exists(cache_file) else 0
-                        if os.path.exists(cache_file) and cacheFileSize >= 1024*1024*50:
-                            shutil.copy(cache_file,copyFilePath) # copy is the saved source of truth
-            except pickle.PicklingError as e:  # pragma: no cover
-                default_logger().debug(e, exc_info=True)
-                OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + "=> Error while Caching Stock Data."
-                    + colorText.END
-                )
-            except Exception as e:  # pragma: no cover
-                default_logger().debug(e, exc_info=True)
-        else:
-            OutputControls().printOutput(
-                colorText.BOLD + colorText.GREEN + "=> Already Cached." + colorText.END
-            )
-            if downloadOnly:
-                OutputControls().printOutput(colorText.BOLD + colorText.GREEN + f"=> {cache_file}" + colorText.END)
-        return cache_file
-
-    def downloadLatestData(stockDict,configManager,stockCodes=[],exchangeSuffix=".NS",downloadOnly=False):
-        numStocksPerIteration = (int(len(stockCodes)/int(len(stockCodes)/10)) if len(stockCodes) >= 10 else len(stockCodes)) + 1
-        queueCounter = 0
-        iterations = int(len(stockCodes)/numStocksPerIteration) + 1
-        tasksList = []
-        while queueCounter < iterations:
-            stocks = []
-            if queueCounter < iterations:
-                stocks = stockCodes[numStocksPerIteration* queueCounter : numStocksPerIteration* (queueCounter + 1)]
-            else:
-                stocks = ["DUMMYStock"]#stockCodes[numStocksPerIteration* queueCounter :]
-            fn_args = (stocks, configManager.period, configManager.duration,exchangeSuffix)
-            task = PKTask(f"DataDownload-{queueCounter}",long_running_fn=fetcher.fetchStockDataWithArgs,long_running_fn_args=fn_args)
-            task.userData = stocks
-            if len(stocks) > 0:
-                tasksList.append(task)
-            queueCounter += 1
-        
-        processedStocks = []
-        if len(tasksList) > 0:
-            # Suppress any multiprocessing errors/warnings
-            with SuppressOutput(suppress_stderr=True, suppress_stdout=True):
-                PKScheduler.scheduleTasks(tasksList=tasksList, 
-                                        label=f"Downloading latest data [{configManager.period},{configManager.duration}] (Total={len(stockCodes)} records in {len(tasksList)} batches){'Be Patient!' if len(stockCodes)> 2000 else ''}",
-                                        timeout=(5+2.5*configManager.longTimeout*(4 if downloadOnly else 1)), # 5 sec additional time for multiprocessing setup
-                                        minAcceptableCompletionPercentage=(100 if downloadOnly else 100))
-            for task in tasksList:
-                if task.result is not None:
-                    for stock in task.userData:
-                        taskResult = task.result.get(f"{stock}{exchangeSuffix}")
-                        if taskResult is not None:
-                            stockDict[stock] = taskResult.to_dict("split")
-                            processedStocks.append(stock)
-        leftOutStocks = list(set(stockCodes)-set(processedStocks))
-        default_logger().debug(f"Attempted fresh download of {len(stockCodes)} stocks and downloaded {len(processedStocks)} stocks. {len(leftOutStocks)} stocks remaining.")
-        return stockDict, leftOutStocks
-
-    def loadStockData(
-        stockDict,
-        configManager,
-        downloadOnly=False,
-        defaultAnswer=None,
-        retrial=False,
-        forceLoad=False,
-        stockCodes=[],
-        exchangeSuffix=".NS",
-        isIntraday = False,
-        forceRedownload=False
-    ):
-        isIntraday = isIntraday or configManager.isIntradayConfig()
-        exists, cache_file = tools.afterMarketStockDataExists(
-            isIntraday, forceLoad=forceLoad
-        )
-        initialLoadCount = len(stockDict)
-        leftOutStocks = None
-        recentDownloadFromOriginAttempted = False
-        isTrading = PKDateUtilities.isTradingTime() and (PKDateUtilities.wasTradedOn() or not PKDateUtilities.isTodayHoliday()[0])
-        # stockCodes is not None mandates that we start our work based on the downloaded data from yesterday
-        if (stockCodes is not None and len(stockCodes) > 0) and (isTrading or downloadOnly):
-            recentDownloadFromOriginAttempted = True
-            stockDict, leftOutStocks = tools.downloadLatestData(stockDict,configManager,stockCodes,exchangeSuffix=exchangeSuffix,downloadOnly=downloadOnly)
-            if len(leftOutStocks) > int(len(stockCodes)*0.05):
-                # More than 5 % of stocks are still remaining
-                stockDict, _ = tools.downloadLatestData(stockDict,configManager,leftOutStocks,exchangeSuffix=exchangeSuffix,downloadOnly=downloadOnly)
-            # return stockDict
-        if downloadOnly or isTrading:
-            # We don't want to download from local stale pkl file or stale file at server
-            return stockDict
-        
-        default_logger().debug(
-            f"Stock data cache file:{cache_file} exists ->{str(exists)}"
-        )
-        stockDataLoaded = False
-        copyFilePath = os.path.join(Archiver.get_user_outputs_dir(), f"copy_{cache_file}")
-        srcFilePath = os.path.join(Archiver.get_user_outputs_dir(), cache_file)
-        if os.path.exists(copyFilePath):
-            shutil.copy(copyFilePath,srcFilePath) # copy is the saved source of truth
-        if os.path.exists(srcFilePath) and not forceRedownload:
-            stockDict, stockDataLoaded = tools.loadDataFromLocalPickle(stockDict,configManager, downloadOnly, defaultAnswer, exchangeSuffix, cache_file, isTrading)
-        if (
-            not stockDataLoaded
-            and ("1d" if isIntraday else ConfigManager.default_period)
-            == configManager.period
-            and ("1m" if isIntraday else ConfigManager.default_duration)
-            == configManager.duration
-        ) or forceRedownload:
-            stockDict, stockDataLoaded = tools.downloadSavedDataFromServer(stockDict,configManager, downloadOnly, defaultAnswer, retrial, forceLoad, stockCodes, exchangeSuffix, isIntraday, forceRedownload, cache_file, isTrading)
-        if not stockDataLoaded:
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] Cache unavailable on pkscreener server, Continuing.."
-                + colorText.END
-            )
-        if not stockDataLoaded and not recentDownloadFromOriginAttempted:
-            stockDict, _ = tools.downloadLatestData(stockDict,configManager,stockCodes,exchangeSuffix=exchangeSuffix,downloadOnly=downloadOnly)
-        # See if we need to save stock data
-        stockDataLoaded = stockDataLoaded or (len(stockDict) > 0 and (len(stockDict) != initialLoadCount))
-        if stockDataLoaded:
-            tools.saveStockData(stockDict,configManager,initialLoadCount,isIntraday,downloadOnly, forceSave=stockDataLoaded)
-        return stockDict
-
-    def loadDataFromLocalPickle(stockDict, configManager, downloadOnly, defaultAnswer, exchangeSuffix, cache_file, isTrading):
-        stockDataLoaded = False
-        srcFilePath = os.path.join(Archiver.get_user_outputs_dir(), cache_file)
-        with open(srcFilePath, "rb") as f:
-            try:
-                stockData = pickle.load(f)
-                if not downloadOnly:
-                    OutputControls().printOutput(
-                            colorText.BOLD
-                            + colorText.GREEN
-                            + f"[+] Automatically Using Cached Stock Data {'due to After-Market hours' if not PKDateUtilities.isTradingTime() else ''}!"
-                            + colorText.END
-                        )
-                if stockData is not None and len(stockData) > 0:
-                    multiIndex = stockData.keys()
-                    if isinstance(multiIndex, pd.MultiIndex):
-                            # If we requested for multiple stocks from yfinance
-                            # we'd have received a multiindex dataframe
-                        listStockCodes = multiIndex.get_level_values(0)
-                        listStockCodes = sorted(list(filter(None,list(set(listStockCodes)))))
-                        if len(listStockCodes) > 0 and len(exchangeSuffix) > 0 and exchangeSuffix in listStockCodes[0]:
-                            listStockCodes = [x.replace(exchangeSuffix,"") for x in listStockCodes]
-                    else:
-                        listStockCodes = list(stockData.keys())
-                        if len(listStockCodes) > 0 and len(exchangeSuffix) > 0 and exchangeSuffix in listStockCodes[0]:
-                            listStockCodes = [x.replace(exchangeSuffix,"") for x in listStockCodes]
-                    for stock in listStockCodes:
-                        df_or_dict = stockData.get(stock)
-                        df_or_dict = df_or_dict.to_dict("split") if isinstance(df_or_dict,pd.DataFrame) else df_or_dict
-                            # This will keep all the latest security data we downloaded
-                            # just now and also copy the additional data like, MF/FII,FairValue
-                            # etc. data, from yesterday's saved data.
-                        try:
-                            existingPreLoadedData = stockDict.get(stock)
-                            if existingPreLoadedData is not None:
-                                if isTrading:
-                                        # Only copy the MF/FII/FairValue data and leave the stock prices as is.
-                                    cols = ["MF", "FII","MF_Date","FII_Date","FairValue"]
-                                    for col in cols:
-                                        existingPreLoadedData[col] = df_or_dict.get(col)
-                                    stockDict[stock] = existingPreLoadedData
-                                else:
-                                    stockDict[stock] = df_or_dict | existingPreLoadedData
-                            else:
-                                if not isTrading:
-                                    stockDict[stock] = df_or_dict
-                        except:
-                                # Probably, the "stock" got removed from the latest download
-                                # and so, was not found in stockDict
-                            continue
-                    # if len(stockDict) > 0:
-                    #     stockDict = stockDict | stockData
-                    # else:
-                    #     stockDict = stockData
-                    stockDataLoaded = True
-            except pickle.UnpicklingError as e:
-                default_logger().debug(e, exc_info=True)
-                f.close()
-                OutputControls().printOutput(
-                        colorText.BOLD
-                        + colorText.FAIL
-                        + "[+] Error while Reading Stock Cache."
-                        + colorText.END
-                    )
-                if tools.promptFileExists(defaultAnswer=defaultAnswer) == "Y":
-                    configManager.deleteFileWithPattern()
-            except EOFError as e:  # pragma: no cover
-                default_logger().debug(e, exc_info=True)
-                f.close()
-                OutputControls().printOutput(
-                        colorText.BOLD
-                        + colorText.FAIL
-                        + "[+] Stock Cache Corrupted."
-                        + colorText.END
-                    )
-                if tools.promptFileExists(defaultAnswer=defaultAnswer) == "Y":
-                    configManager.deleteFileWithPattern()
-        return stockDict, stockDataLoaded
-
-    def downloadSavedDataFromServer(stockDict, configManager, downloadOnly, defaultAnswer, retrial, forceLoad, stockCodes, exchangeSuffix, isIntraday, forceRedownload, cache_file, isTrading):
-        stockDataLoaded = False
-        OutputControls().printOutput(
-                    colorText.BOLD
-                    + colorText.FAIL
-                    + "[+] Market Stock Data is not cached, or forced to redownload .."
-                    + colorText.END
-                )
-        OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.GREEN
-                + f"[+] Downloading {'Intraday' if configManager.isIntradayConfig() else 'Daily'} cache from server for faster processing, Please Wait.."
-                + colorText.END
-            )
-        cache_url = (
-                "https://raw.githubusercontent.com/pkjmesra/PKScreener/actions-data-download/actions-data-download/"
-                + cache_file  # .split(os.sep)[-1]
-            )
-        headers = {
-                    'authority': 'raw.githubusercontent.com',
-                    'accept': '*/*',
-                    'accept-language': 'en-US,en;q=0.9',
-                    'dnt': '1',
-                    'sec-ch-ua-mobile': '?0',
-                    # 'sec-ch-ua-platform': '"macOS"',
-                    'sec-fetch-dest': 'empty',
-                    'sec-fetch-mode': 'cors',
-                    'sec-fetch-site': 'cross-site',                  
-                    'origin': 'https://github.com',
-                    'referer': f'https://github.com/pkjmesra/PKScreener/blob/actions-data-download/actions-data-download/{cache_file}',
-                    'user-agent': f'{random_user_agent()}' 
-                    #'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36
-            }
-        resp = fetcher.fetchURL(cache_url, headers=headers, stream=True)
-        if resp is not None:
-            default_logger().debug(
-                    f"Stock data cache file:{cache_file} request status ->{resp.status_code}"
-                )
-        if resp is not None and resp.status_code == 200:
-            contentLength = resp.headers.get("content-length")
-            serverBytes = int(contentLength) if contentLength is not None else 0
-            KB = 1024
-            MB = KB * 1024
-            chunksize = MB if serverBytes >= MB else (KB if serverBytes >= KB else 1)
-            filesize = int( serverBytes / chunksize)
-            if filesize > 40 and chunksize == MB: # Saved data can't be in KBs. Something definitely went wrong. It should be upward of 40MB
-                bar, spinner = tools.getProgressbarStyle()
-                try:
-                    f = open(
-                            os.path.join(Archiver.get_user_outputs_dir(), cache_file),
-                            "w+b",
-                        )  # .split(os.sep)[-1]
-                    dl = 0
-                    with alive_bar(
-                            filesize, bar=bar, spinner=spinner, manual=True
-                        ) as progressbar:
-                        for data in resp.iter_content(chunk_size=chunksize):
-                            dl += 1
-                            f.write(data)
-                            progressbar(dl / filesize)
-                            if dl >= filesize:
-                                progressbar(1.0)
-                    f.close()
-                    with open(
-                            os.path.join(Archiver.get_user_outputs_dir(), cache_file),
-                            "rb",
-                        ) as f:
-                        stockData = pickle.load(f)
-                    if len(stockData) > 0:
-                        multiIndex = stockData.keys()
-                        if isinstance(multiIndex, pd.MultiIndex):
-                                # If we requested for multiple stocks from yfinance
-                                # we'd have received a multiindex dataframe
-                            listStockCodes = multiIndex.get_level_values(0)
-                            listStockCodes = sorted(list(filter(None,list(set(listStockCodes)))))
-                            if len(listStockCodes) > 0 and len(exchangeSuffix) > 0 and exchangeSuffix in listStockCodes[0]:
-                                listStockCodes = [x.replace(exchangeSuffix,"") for x in listStockCodes]
-                        else:
-                            listStockCodes = list(stockData.keys())
-                            if len(listStockCodes) > 0 and len(exchangeSuffix) > 0 and exchangeSuffix in listStockCodes[0]:
-                                listStockCodes = [x.replace(exchangeSuffix,"") for x in listStockCodes]
-                        for stock in listStockCodes:
-                            df_or_dict = stockData.get(stock)
-                            df_or_dict = df_or_dict.to_dict("split") if isinstance(df_or_dict,pd.DataFrame) else df_or_dict
-                                # This will keep all the latest security data we downloaded
-                                # just now and also copy the additional data like, MF/FII,FairValue
-                                # etc. data, from yesterday's saved data.
-                            try:
-                                existingPreLoadedData = stockDict.get(stock)
-                                if existingPreLoadedData is not None:
-                                    if isTrading:
-                                            # Only copy the MF/FII/FairValue data and leave the stock prices as is.
-                                        cols = ["MF", "FII","MF_Date","FII_Date","FairValue"]
-                                        for col in cols:
-                                            existingPreLoadedData[col] = df_or_dict.get(col)
-                                        stockDict[stock] = existingPreLoadedData
-                                    else:
-                                        stockDict[stock] = df_or_dict | existingPreLoadedData
-                                else:
-                                    if not isTrading:
-                                        stockDict[stock] = df_or_dict
-                            except:
-                                    # Probably, the "stock" got removed from the latest download
-                                    # and so, was not found in stockDict
-                                continue
-                        stockDataLoaded = True
-                        copyFilePath = os.path.join(Archiver.get_user_outputs_dir(), f"copy_{cache_file}")
-                        srcFilePath = os.path.join(Archiver.get_user_outputs_dir(), cache_file)
-                        if os.path.exists(copyFilePath) and os.path.exists(srcFilePath):
-                            shutil.copy(copyFilePath,srcFilePath) # copy is the saved source of truth
-                        if not os.path.exists(copyFilePath) and os.path.exists(srcFilePath): # Let's make a copy of the original one
-                            shutil.copy(srcFilePath,copyFilePath)
-                        # Remove the progress bar now!
-                        sys.stdout.write("\x1b[1A")  # cursor up one line
-                        sys.stdout.write("\x1b[2K")  # delete the last line
-                except Exception as e:  # pragma: no cover
-                    default_logger().debug(e, exc_info=True)
-                    f.close()
-                    OutputControls().printOutput("[!] Download Error - " + str(e))
-            else:
-                default_logger().debug(
-                        f"Stock data cache file:{cache_file} on server has length ->{filesize} {'Mb' if chunksize >= MB else ('Kb' if chunksize >= KB else 'bytes')}"
-                    )
-            if not retrial and not stockDataLoaded:
-                    # Don't try for more than once.
-                stockDict = tools.loadStockData(
-                        stockDict,
-                        configManager,
-                        downloadOnly,
-                        defaultAnswer,
-                        retrial=True,
-                        forceLoad=forceLoad,
-                        stockCodes=stockCodes,
-                        exchangeSuffix=exchangeSuffix,
-                        isIntraday = isIntraday,
-                        forceRedownload=forceRedownload
-                    )
-                
-        return stockDict,stockDataLoaded
-
-    # Save screened results to excel
-    def promptSaveResults(sheetName,df, defaultAnswer=None):
-        """
-        Tries to save the dataframe output into an excel file.
-
-        It will first try to save to the current-working-directory/results/
-
-        If it fails to save, it will then try to save to Desktop and then eventually into
-        a temporary directory.
-        """
-        isSaved = False
-        try:
-            if defaultAnswer is None:
-                response = str(
-                    input(
-                        colorText.BOLD
-                        + colorText.WARN
-                        + "[>] Do you want to save the results in excel file? [Y/N](Default:Y): "
-                    ) or "Y"
-                ).upper()
-            else:
-                response = defaultAnswer
-        except ValueError as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            response = "Y"
-        if response is not None and response.upper() != "N":
-            filename = (
-                "PKScreener-result_"
-                + PKDateUtilities.currentDateTime().strftime("%d-%m-%y_%H.%M.%S")
-                + ".xlsx"
-            )
-            desktop = os.path.expanduser("~/Desktop")
-            # # the above is valid on Windows (after 7) but if you want it in os normalized form:
-            desktop = os.path.normpath(os.path.expanduser("~/Desktop"))
-            filePath = ""
-            try:
-                filePath = os.path.join(Archiver.get_user_outputs_dir(), filename)
-                # Create a Pandas Excel writer using XlsxWriter as the engine.
-                writer = pd.ExcelWriter(filePath, engine='xlsxwriter') # openpyxl throws an error exporting % sign.
-                # Convert the dataframe to an XlsxWriter Excel object.
-                df.to_excel(writer, sheet_name=sheetName)
-                # Close the Pandas Excel writer and output the Excel file.
-                writer.close()
-                isSaved = True
-            except Exception as e:  # pragma: no cover
-                default_logger().debug(e, exc_info=True)
-                OutputControls().printOutput(
-                    colorText.FAIL
-                    + (
-                        "[+] Error saving file at %s"
-                        % filePath
-                    )
-                    + colorText.END
-                )
-                try:
-                    filePath = os.path.join(desktop, filename)
-                    # Create a Pandas Excel writer using XlsxWriter as the engine.
-                    writer = pd.ExcelWriter(filePath, engine='xlsxwriter') # openpyxl throws an error exporting % sign.
-                    # Convert the dataframe to an XlsxWriter Excel object.
-                    df.to_excel(writer, sheet_name=sheetName)
-                    # Close the Pandas Excel writer and output the Excel file.
-                    writer.close()
-                    isSaved = True
-                except Exception as ex:  # pragma: no cover
-                    default_logger().debug(ex, exc_info=True)
-                    OutputControls().printOutput(
-                        colorText.FAIL
-                        + (
-                            "[+] Error saving file at %s"
-                            % filePath
-                        )
-                        + colorText.END
-                    )
-                    filePath = os.path.join(tempfile.gettempdir(), filename)
-                    # Create a Pandas Excel writer using XlsxWriter as the engine.
-                    writer = pd.ExcelWriter(filePath, engine='xlsxwriter') # openpyxl throws an error exporting % sign.
-                    # Convert the dataframe to an XlsxWriter Excel object.
-                    df.to_excel(writer, sheet_name=sheetName)
-                    # Close the Pandas Excel writer and output the Excel file.
-                    writer.close()
-                    isSaved = True
-            OutputControls().printOutput(
-                colorText.BOLD
-                + (colorText.GREEN if isSaved else colorText.FAIL)
-                + (("[+] Results saved to %s" % filePath) if isSaved else "[+] Failed saving results into Excel file!")
-                + colorText.END
-            )
-            return filePath
-        return None
-
-    # Save screened results to excel
-    def promptFileExists(cache_file="stock_data_*.pkl", defaultAnswer=None):
-        try:
-            if defaultAnswer is None:
-                response = str(
-                    input(
-                        colorText.BOLD
-                        + colorText.WARN
-                        + "[>] "
-                        + cache_file
-                        + " already exists. Do you want to replace this? [Y/N] (Default: Y): "
-                ) or "Y").upper()
-            else:
-                response = defaultAnswer
-        except ValueError as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            pass
-        return "Y" if response != "N" else "N"
-
-    # Prompt for asking RSI
-    def promptRSIValues():
-        tools.clearScreen(forceTop=True)
-        try:
-            minRSI, maxRSI = int(
-                input(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + "\n[+] Enter Min RSI value (Default=55): "
-                    + colorText.END
-                ) or 55
-            ), int(
-                input(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + "[+] Enter Max RSI value (Default=68): "
-                    + colorText.END
-                ) or "68"
-            )
-            if (
-                (minRSI >= 0 and minRSI <= 100)
-                and (maxRSI >= 0 and maxRSI <= 100)
-                and (minRSI <= maxRSI)
-            ):
-                return (minRSI, maxRSI)
-            raise ValueError
-        except ValueError as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            return (0, 0)
-
-    # Prompt for asking CCI
-    def promptCCIValues(minCCI=None, maxCCI=None):
-        tools.clearScreen(forceTop=True)
-        if minCCI is not None and maxCCI is not None:
-            return minCCI, maxCCI
-        try:
-            minCCI, maxCCI = int(
-                input(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + "\n[+] Enter Min CCI value (Default=110): "
-                    + colorText.END
-                ) or "110"
-            ), int(
-                input(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + "[+] Enter Max CCI value (Default=300): "
-                    + colorText.END
-                ) or "300"
-            )
-            if minCCI <= maxCCI:
-                return (minCCI, maxCCI)
-            raise ValueError
-        except ValueError as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            return (-100, 100)
-
-    # Prompt for asking Volume ratio
-    def promptVolumeMultiplier(volumeRatio=None):
-        tools.clearScreen(forceTop=True)
-        if volumeRatio is not None:
-            return volumeRatio
-        try:
-            volumeRatio = float(
-                input(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + "\n[+] Enter Min Volume ratio value (Default = 2.5): "
-                    + colorText.END
-                ) or "2.5"
-            )
-            if volumeRatio > 0:
-                return volumeRatio
-            raise ValueError
-        except ValueError as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            return 2
-
-    def promptMenus(menu):
-        tools.clearScreen(forceTop=True)
-        m = menus()
-        m.level = menu.level if menu is not None else 0
-        return m.renderForMenu(menu)
-
-    def promptChartPatternSubMenu(menu,respChartPattern):
-        tools.clearScreen(forceTop=True)
-        m3 = menus()
-        m3.renderForMenu(menu,asList=True)
-        lMenu =  m3.find(str(respChartPattern))
-        maLength = tools.promptSubMenuOptions(lMenu)
-        return maLength
-    
-    # Prompt for submenu options
-    def promptSubMenuOptions(menu=None):
-        try:
-            tools.promptMenus(menu=menu)
-            resp = int(
-                input(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + """[+] Select Option:"""
-                    + colorText.END
-                ) or "1"
-            )
-            if resp >= 0 and resp <= 10:
-                return resp
-            raise ValueError
-        except ValueError as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            input(
-                colorText.BOLD
-                + colorText.FAIL
-                + "\n[+] Invalid Option Selected. Press <Enter> to try again..."
-                + colorText.END
-            )
-            return None
-
-    # Prompt for Reversal screening
-    def promptReversalScreening(menu=None):
-        try:
-            tools.promptMenus(menu=menu)
-            resp = int(
-                input(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + """[+] Select Option:"""
-                    + colorText.END
-                ) or "3"
-            )
-            if resp >= 0 and resp <= 10:
-                if resp == 4:
-                    try:
-                        defaultMALength = 9 if configManager.duration.endswith("m") else 50
-                        maLength = int(
-                            input(
-                                colorText.BOLD
-                                + colorText.WARN
-                                + f"\n[+] Enter MA Length (E.g. 9,10,20,50 or 200) (Default={defaultMALength}): "
-                                + colorText.END
-                            ) or str(defaultMALength)
-                        )
-                        return resp, maLength
-                    except ValueError as e:  # pragma: no cover
-                        default_logger().debug(e, exc_info=True)
-                        OutputControls().printOutput(
-                            colorText.BOLD
-                            + colorText.FAIL
-                            + "\n[!] Invalid Input! MA Length should be single integer value!\n"
-                            + colorText.END
-                        )
-                        raise ValueError
-                elif resp == 6:
-                    try:
-                        maLength = int(
-                            input(
-                                colorText.BOLD
-                                + colorText.WARN
-                                + "\n[+] Enter NR timeframe [Integer Number] (E.g. 4, 7, etc.) (Default=4): "
-                                + colorText.END
-                            ) or "4"
-                        )
-                        return resp, maLength
-                    except ValueError as e:  # pragma: no cover
-                        default_logger().debug(e, exc_info=True)
-                        OutputControls().printOutput(
-                            colorText.BOLD
-                            + colorText.FAIL
-                            + "\n[!] Invalid Input! NR timeframe should be single integer value!\n"
-                            + colorText.END
-                        )
-                        raise ValueError
-                elif resp in [7,10]:
-                    m3 = menus()
-                    m3.renderForMenu(menu,asList=True)
-                    lMenu =  m3.find(str(resp))
-                    return resp, tools.promptSubMenuOptions(lMenu)
-                return resp, None
-            raise ValueError
-        except ValueError as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            input(
-                colorText.BOLD
-                + colorText.FAIL
-                + "\n[+] Invalid Option Selected. Press <Enter> to try again..."
-                + colorText.END
-            )
-            return None, None
-
-    # Prompt for Reversal screening
-    def promptChartPatterns(menu=None):
-        try:
-            tools.promptMenus(menu=menu)
-            resp = int(
-                input(
-                    colorText.BOLD
-                    + colorText.WARN
-                    + """[+] Select Option:"""
-                    + colorText.END
-                ) or "3"
-            )
-            if resp == 1 or resp == 2:
-                candles = int(
-                    input(
-                        colorText.BOLD
-                        + colorText.WARN
-                        + "\n[+] How many candles (TimeFrame) to look back Inside Bar formation? (Default=3): "
-                        + colorText.END
-                    ) or "3"
-                )
-                return (resp, candles)
-            if resp == 3:
-                percent = float(
-                    input(
-                        colorText.BOLD
-                        + colorText.WARN
-                        + "\n[+] Enter Percentage within which all MA/EMAs should be (Ideal: 1-2%)? (Default=2): "
-                        + colorText.END
-                    ) or "2"
-                )
-                return (resp, percent / 100.0)
-            if resp >= 0 and resp <= 7:
-                return resp, 0
-            raise ValueError
-        except ValueError as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            input(
-                colorText.BOLD
-                + colorText.FAIL
-                + "\n[+] Invalid Option Selected. Press <Enter> to try again..."
-                + colorText.END
-            )
-            return (None, None)
-
-    def getProgressbarStyle():
-        bar = "smooth"
-        spinner = "waves"
-        if "Windows" in platform.platform():
-            bar = "classic2"
-            spinner = "dots_recur"
-        return bar, spinner
-
-    def getNiftyModel(retrial=False):
-        files = [
-            os.path.join(Archiver.get_user_outputs_dir(), "nifty_model_v2.h5"),
-            os.path.join(Archiver.get_user_outputs_dir(), "nifty_model_v2.pkl"),
-        ]
-        model = None
-        pkl = None
-        urls = [
-            "https://raw.githubusercontent.com/pkjmesra/PKScreener/main/pkscreener/ml/nifty_model_v2.h5",
-            "https://raw.githubusercontent.com/pkjmesra/PKScreener/main/pkscreener/ml/nifty_model_v2.pkl",
-        ]
-        if os.path.isfile(files[0]) and os.path.isfile(files[1]):
-            file_age = (time.time() - os.path.getmtime(files[0])) / 604800
-            if file_age > 1:
-                download = True
-                os.remove(files[0])
-                os.remove(files[1])
-            else:
-                download = False
-        else:
-            download = True
-        if download:
-            for file_url in urls:
-                resp = fetcher.fetchURL(file_url, stream=True)
-                if resp is not None and resp.status_code == 200:
-                    OutputControls().printOutput(
-                        colorText.BOLD
-                        + colorText.GREEN
-                        + "[+] Downloading AI model (v2) for Nifty predictions, Please Wait.."
-                        + colorText.END
-                    )
-                    try:
-                        chunksize = 1024 * 1024 * 1
-                        filesize = int(
-                            int(resp.headers.get("content-length")) / chunksize
-                        )
-                        filesize = 1 if not filesize else filesize
-                        bar, spinner = tools.getProgressbarStyle()
-                        f = open(
-                            os.path.join(
-                                Archiver.get_user_outputs_dir(), file_url.split("/")[-1]
-                            ),
-                            "wb",
-                        )
-                        dl = 0
-                        with alive_bar(
-                            filesize, bar=bar, spinner=spinner, manual=True
-                        ) as progressbar:
-                            for data in resp.iter_content(chunk_size=chunksize):
-                                dl += 1
-                                f.write(data)
-                                progressbar(dl / filesize)
-                                if dl >= filesize:
-                                    progressbar(1.0)
-                        f.close()
-                    except Exception as e:  # pragma: no cover
-                        default_logger().debug(e, exc_info=True)
-                        OutputControls().printOutput("[!] Download Error - " + str(e))
-            time.sleep(3)
-        try:
-            if os.path.isfile(files[0]) and os.path.isfile(files[1]):
-                pkl = joblib.load(files[1])
-                if Imports["keras"]:
-                    try:
-                        import keras
-                    except:
-                        OutputControls().printOutput("This installation might not work well, especially for NIFTY prediction. Please install 'keras' library on your machine!")
-                        OutputControls().printOutput(
-                                colorText.BOLD
-                                + colorText.FAIL
-                                + "[+] 'Keras' library is not installed. You may wish to follow instructions from\n[+] https://github.com/pkjmesra/PKScreener/"
-                                + colorText.END
-                            )
-                        pass
-                model = keras.models.load_model(files[0]) if Imports["keras"] else None
-        except Exception as e:  # pragma: no cover
-            default_logger().debug(e, exc_info=True)
-            os.remove(files[0])
-            os.remove(files[1])
-            if not retrial:
-                tools.getNiftyModel(retrial=True)
-        if model is None:
-            OutputControls().printOutput(
-                colorText.BOLD
-                + colorText.FAIL
-                + "[+] 'Keras' library is not installed. Prediction failed! You may wish to follow instructions from\n[+] https://github.com/pkjmesra/PKScreener/"
-                + colorText.END
-            )
-        return model, pkl
-
-    def getSigmoidConfidence(x):
-        out_min, out_max = 0, 100
-        if x > 0.5:
-            in_min = 0.50001
-            in_max = 1
-        else:
-            in_min = 0
-            in_max = 0.5
-        return round(
-            ((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min), 3
-        )
-
-    def alertSound(beeps=3, delay=0.2):
-        for i in range(beeps):
-            OutputControls().printOutput("\a")
-            sleep(delay)
-    
-    def getMaxColumnWidths(df):
-        columnWidths = [None]
-        addnlColumnWidths = [40 if (x in ["Trend(22Prds)"] or "-Pd" in x) else (20 if (x in ["Pattern"]) else None) for x in df.columns]
-        columnWidths.extend(addnlColumnWidths)
-        columnWidths = columnWidths[:-1]
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import copy
+import datetime
+import glob
+import math
+import os
+import shutil
+import sys
+import textwrap
+import random
+
+os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
+os.environ["AUTOGRAPH_VERBOSITY"] = "0"
+
+import pickle
+import platform
+import tempfile
+import time
+
+import joblib
+import numpy as np
+import pytz
+from genericpath import isfile
+from PKDevTools.classes.log import default_logger
+from PKDevTools.classes.ColorText import colorText
+from pkscreener import Imports
+
+import warnings
+from time import sleep
+
+warnings.simplefilter("ignore", DeprecationWarning)
+warnings.simplefilter("ignore", FutureWarning)
+import pandas as pd
+from alive_progress import alive_bar
+from PIL import Image, ImageDraw, ImageFont
+from PKDevTools.classes import Archiver
+from PKDevTools.classes.PKDateUtilities import PKDateUtilities
+from PKDevTools.classes.Committer import Committer
+from PKDevTools.classes.SuppressOutput import SuppressOutput
+from PKDevTools.classes.FunctionTimeouts import exit_after
+from tabulate import tabulate
+
+import pkscreener.classes.ConfigManager as ConfigManager
+import pkscreener.classes.Fetcher as Fetcher
+from pkscreener.classes import VERSION, Changelog
+from pkscreener.classes.MenuOptions import menus
+from PKNSETools.PKNSEStockDataFetcher import nseStockDataFetcher
+from pkscreener.classes.PKTask import PKTask
+from pkscreener.classes.MarketStatus import MarketStatus
+from pkscreener.classes.PKScheduler import PKScheduler
+from PKDevTools.classes.OutputControls import OutputControls
+from PKDevTools.classes.Utils import random_user_agent
+
+from pkscreener.classes.ArtTexts import getArtText
+from PKDevTools.classes.NSEMarketStatus import NSEMarketStatus
+
+configManager = ConfigManager.tools()
+configManager.getConfig(ConfigManager.parser)
+nseFetcher = nseStockDataFetcher()
+fetcher = Fetcher.screenerStockDataFetcher()
+
+
+artText = f"{getArtText()}\nv{VERSION}"
+
+STD_ENCODING=sys.stdout.encoding if sys.stdout is not None else 'utf-8'
+
+def marketStatus():
+    # task = PKTask("Nifty 50 Market Status",MarketStatus().getMarketStatus)
+    lngStatus = MarketStatus().marketStatus
+    nseStatus = ""
+    next_bell = ""
+    try:
+        nseStatus = NSEMarketStatus({},None).status
+        next_bell = NSEMarketStatus({},None).getNextBell()
+    except:
+        pass
+    # scheduleTasks(tasksList=[task])
+    if lngStatus == "":
+        lngStatus = MarketStatus().getMarketStatus(exchangeSymbol="^IXIC" if configManager.defaultIndex == 15 else "^NSEI")
+    if "Close" in lngStatus and nseStatus == "Open":
+        lngStatus = lngStatus.replace("Closed","Open")
+    if len(next_bell) > 0 and next_bell not in lngStatus:
+        lngStatus = f"{lngStatus} | Next Bell: {colorText.WARN}{next_bell.replace('T',' ').split('+')[0]}{colorText.END}"
+    return (lngStatus +"\n") if lngStatus is not None else "\n"
+
+art = colorText.GREEN + f"{getArtText()}\nv{VERSION}" + colorText.END + f" | {marketStatus()}"
+
+lastScreened = os.path.join(
+    Archiver.get_user_outputs_dir(), "last_screened_results.pkl"
+)
+
+# Class for managing misc and utility methods
+
+class tools:
+    def clearScreen(userArgs=None,clearAlways=False,forceTop=False):
+        if "RUNNER" in os.environ.keys() or (userArgs is not None and userArgs.prodbuild):
+            if userArgs is not None and userArgs.v:
+                os.environ["RUNNER"]="LOCAL_RUN_SCANNER"
+            return
+        elif (userArgs is not None and userArgs.runintradayanalysis):
+            return
+        if clearAlways or OutputControls().enableMultipleLineOutput:
+            if platform.system() == "Windows":
+                try:
+                    os.system('color 0f') # sets the background to black with white forerground
+                except:
+                    pass
+                if clearAlways:
+                    os.system("cls")
+            elif "Darwin" in platform.system():
+                if clearAlways:
+                    os.system("clear")
+                # default_logger().debug("Darwin does not work for setting background")
+            else:
+                try:
+                    os.system('setterm -background black -foreground white -store')
+                except:
+                    pass
+                if clearAlways:
+                    os.system("clear")
+            OutputControls().moveCursorToStartPosition()
+        try:
+            forceTop = OutputControls().enableMultipleLineOutput
+            if forceTop and OutputControls().lines == 0:
+                OutputControls().lines = 9
+                OutputControls().moveCursorToStartPosition()
+                
+            if clearAlways or OutputControls().enableMultipleLineOutput:
+                art = colorText.GREEN + f"{getArtText()}\nv{VERSION}" + colorText.END + f" | {marketStatus()}"
+                OutputControls().printOutput(art.encode('utf-8').decode(STD_ENCODING), enableMultipleLineOutput=True)
+        except Exception as e:# pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            pass
+
+    # Print about developers and repository
+    def showDevInfo(defaultAnswer=None):
+        OutputControls().printOutput("\n" + Changelog.changelog())
+        devInfo = "\n[+] Developer: PK (PKScreener)"
+        versionInfo = "[+] Version: %s" % VERSION
+        homePage = "[+] Home Page: https://github.com/pkjmesra/PKScreener\n[+] Telegram Bot:@nse_pkscreener_bot\n[+] Channel:https://t.me/PKScreener\n[+] Discussions:https://t.me/PKScreeners"
+        issuesInfo = (
+            "[+] Read/Post Issues here: https://github.com/pkjmesra/PKScreener/issues"
+        )
+        communityInfo = "[+] Join Community Discussions: https://github.com/pkjmesra/PKScreener/discussions"
+        latestInfo = "[+] Download latest software from https://github.com/pkjmesra/PKScreener/releases/latest"
+        OutputControls().printOutput(colorText.BOLD + colorText.WARN + devInfo + colorText.END)
+        OutputControls().printOutput(colorText.BOLD + colorText.WARN + versionInfo + colorText.END)
+        OutputControls().printOutput(colorText.BOLD + homePage + colorText.END)
+        OutputControls().printOutput(colorText.BOLD + colorText.FAIL + issuesInfo + colorText.END)
+        OutputControls().printOutput(colorText.BOLD + colorText.GREEN + communityInfo + colorText.END)
+        OutputControls().printOutput(colorText.BOLD + colorText.BLUE + latestInfo + colorText.END)
+        if defaultAnswer is None:
+            input(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] Press <Enter> to continue!"
+                + colorText.END
+            )
+        return f"\n{Changelog.changelog()}\n\n{devInfo}\n{versionInfo}\n\n{homePage}\n{issuesInfo}\n{communityInfo}\n{latestInfo}"
+
+    # Save last screened result to pickle file
+    def setLastScreenedResults(df, df_save=None, choices=None):
+        try:
+            finalStocks = ""
+            outputFolder = os.path.join(os.getcwd(),'actions-data-scan')
+            if not os.path.isdir(outputFolder):
+                os.makedirs(os.path.dirname(os.path.join(os.getcwd(),f"actions-data-scan{os.sep}")), exist_ok=True)
+            fileName = os.path.join(outputFolder,f"{choices}.txt")
+            items = []
+            needsWriting = False
+            if os.path.isfile(fileName):
+                if df is not None and len(df) > 0:
+                    #File already exists. Let's combine because there are new stocks found
+                    with open(fileName, 'r') as fe:
+                        stocks = fe.read()
+                        items = stocks.replace("\n","").replace("\"","").split(",")
+                        stockList = sorted(list(filter(None,list(set(items)))))
+                        finalStocks = ",".join(stockList)
+            else:
+                needsWriting = True
+            if df is not None and len(df) > 0:
+                df.sort_values(by=["Stock"], ascending=True, inplace=True)
+                df.to_pickle(lastScreened)
+                if choices is not None and df_save is not None:
+                    df_s = df_save.copy()
+                    df_s.reset_index(inplace=True)
+                    newStocks = df_s["Stock"].to_json(orient='records', lines=True).replace("\n","").replace("\"","").split(",")
+                    items.extend(newStocks)
+                    stockList = sorted(list(filter(None,list(set(items)))))
+                    finalStocks = ",".join(stockList)
+                    needsWriting = True
+            if needsWriting:
+                with open(fileName, 'w') as f:
+                    f.write(finalStocks)
+        except IOError as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + f"{e}\n[+] Failed to save recently screened result table on disk! Skipping.."
+                + colorText.END
+            )
+        except Exception as e:# pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            pass
+
+    # Load last screened result to pickle file
+    def getLastScreenedResults(defaultAnswer=None):
+        try:
+            df = pd.read_pickle(lastScreened)
+            if df is not None and len(df) > 0:
+                OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.GREEN
+                    + "\n[+] Showing recently screened results..\n"
+                    + colorText.END
+                )
+                df.sort_values(by=["Volume"], ascending=False, inplace=True)
+                OutputControls().printOutput(
+                    colorText.miniTabulator().tabulate(
+                        df, headers="keys", tablefmt=colorText.No_Pad_GridFormat,
+                        maxcolwidths=tools.getMaxColumnWidths(df)
+                    ).encode("utf-8").decode(STD_ENCODING)
+                )
+                OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + "[+] Note: Trend calculation is based on number of recent days to screen as per your configuration."
+                    + colorText.END
+                )
+            else:
+                OutputControls().printOutput("Nothing to show here!")
+        except FileNotFoundError as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] Failed to load recently screened result table from disk! Skipping.."
+                + colorText.END
+            )
+        if defaultAnswer is None:
+            input(
+                colorText.BOLD
+                + colorText.GREEN
+                + "[+] Press <Enter> to continue.."
+                + colorText.END
+            )
+
+    def formattedBacktestOutput(outcome, pnlStats=False, htmlOutput=True):
+        if not pnlStats:
+            if htmlOutput:
+                if outcome >= 80:
+                    return f'{colorText.GREEN}{"%.2f%%" % outcome}{colorText.END}'
+                if outcome >= 60:
+                    return f'{colorText.WARN}{"%.2f%%" % outcome}{colorText.END}'
+                return f'{colorText.FAIL}{"%.2f%%" % outcome}{colorText.END}'
+            else:
+                return f'{colorText.GREEN}{"%.2f%%" % outcome}{colorText.END}'
+        else:
+            if outcome >= 0:
+                return f'{colorText.GREEN}{"%.2f%%" % outcome}{colorText.END}'
+            return f'{colorText.FAIL}{"%.2f%%" % outcome}{colorText.END}'
+
+    def getFormattedBacktestSummary(x, pnlStats=False, columnName=None):
+        if x is not None and "%" in str(x):
+            values = x.split("%")
+            if (
+                len(values) == 2
+                and columnName is not None
+                and ("-Pd" in columnName or "Overall" in columnName)
+            ):
+                return "{0}{1}".format(
+                    tools.formattedBacktestOutput(
+                        float(values[0]), pnlStats=pnlStats, htmlOutput=False
+                    ),
+                    values[1],
+                )
+        return x
+
+    def formatRatio(ratio, volumeRatio):
+        if ratio >= volumeRatio and ratio != np.nan and (not math.isinf(ratio)):
+            return colorText.BOLD + colorText.GREEN + str(ratio) + "x" + colorText.END
+        return colorText.BOLD + colorText.FAIL + (f"{ratio}x" if pd.notna(ratio) else "") + colorText.END
+
+    def addQuickWatermark(sourceImage:Image, xVertical=None, dataSrc="", dataSrcFontSize=10):
+        width, height = sourceImage.size
+        watermarkText = f" {datetime.date.today().year} pkjmesra | PKScreener"
+        message_length = len(watermarkText)
+        # load font (tweak ratio based on a particular font)
+        FONT_RATIO = 1.5
+        DIAGONAL_PERCENTAGE = .85
+        DATASRC_FONTSIZE = dataSrcFontSize
+        dataSrc = f"Src: {dataSrc}"
+        diagonal_length = int(math.sqrt((width**2) + (height**2)))
+        diagonal_to_use = diagonal_length * DIAGONAL_PERCENTAGE
+        height_to_use = height * DIAGONAL_PERCENTAGE
+        font_size = int(diagonal_to_use / (message_length / FONT_RATIO))
+        font_size_vertical = int(height_to_use / (message_length / FONT_RATIO))
+        fontPath = tools.setupReportFont()
+        font = ImageFont.truetype(fontPath, font_size)
+        font_vertical = ImageFont.truetype(fontPath, font_size_vertical)
+        #font = ImageFont.load_default() # fallback
+
+        # watermark
+        opacity = int(256 * .6)
+        mark_width, mark_height = font.getsize(watermarkText)
+        watermark = Image.new('RGBA', (mark_width, mark_height), (0, 0, 0, 0))
+        draw = ImageDraw.Draw(watermark)
+        draw.text((0, 0), text=watermarkText, font=font, fill=(128, 128, 128, opacity))
+        angle = math.degrees(math.atan(height/width))
+        watermark_diag = watermark.rotate(angle, expand=1)
+        
+        mark_width_ver, mark_height_ver = font_vertical.getsize(watermarkText)
+        watermark_ver = Image.new('RGBA', (mark_width_ver, mark_height_ver), (0, 0, 0, 0))
+        draw = ImageDraw.Draw(watermark_ver)
+        draw.text((0, 0), text=watermarkText, font=font_vertical, fill=(128, 128, 128, opacity))
+        watermark_vertical = watermark_ver.rotate(90, expand=1)
+
+        # merge
+        wx, wy = watermark_diag.size
+        px = int((width - wx)/2)
+        py = int((height - wy)/2)
+        wxv, wyv = watermark_vertical.size
+        pxv =  int((width - wxv)/12) if xVertical is None else xVertical
+        pyv= int((height - wyv)/2)
+        sourceImage.paste(watermark_diag, (px, py, px + wx, py + wy), watermark_diag)
+        sourceImage.paste(watermark_vertical, (pxv, pyv, pxv + wxv, pyv + wyv), watermark_vertical)
+        
+        # Draw the data sources
+        dataSrcFont = ImageFont.truetype(fontPath, DATASRC_FONTSIZE)
+        dataSrc_width, dataSrc_height = dataSrcFont.getsize_multiline(dataSrc)
+        draw = ImageDraw.Draw(sourceImage)
+        draw.text((width-dataSrc_width, height-dataSrc_height-2), text=dataSrc, font=dataSrcFont, fill=(128, 128, 128, opacity))
+        # sourceImage.show()
+        return sourceImage
+
+    def roundOff(value,places):
+        roundValue = value
+        try:
+            newValue = tools.removeAllColorStyles(str(roundValue))
+            newValue = newValue.replace("%","").replace("x","")
+            roundValue = round(float(newValue),places)
+            if places == 0:
+                roundValue = int(roundValue)
+            roundValue = str(value).replace(str(newValue),str(roundValue))
+        except:
+            pass
+        return roundValue
+    
+    def removeAllColorStyles(styledText):
+        styles = [
+            colorText.HEAD,
+            colorText.END,
+            colorText.BOLD,
+            colorText.UNDR,
+            colorText.BLUE,
+            colorText.GREEN,
+            colorText.WARN,
+            colorText.FAIL,
+            colorText.WHITE,
+        ]
+        cleanedUpStyledValue = str(styledText)
+        for style in styles:
+            cleanedUpStyledValue = cleanedUpStyledValue.replace(style, "")
+        return cleanedUpStyledValue
+
+    def getCellColors(cellStyledValue="", defaultCellFillColor="black"):
+        otherStyles = [colorText.HEAD, colorText.BOLD, colorText.UNDR]
+        mainStyles = [
+            colorText.BLUE,
+            colorText.GREEN,
+            colorText.WARN,
+            colorText.FAIL,
+            colorText.WHITE,
+        ]
+        colorsDict = {
+            colorText.BLUE: "blue",
+            colorText.GREEN: "darkgreen"
+            if defaultCellFillColor == "black"
+            else "lightgreen",
+            colorText.WARN: "darkorange"
+            if defaultCellFillColor == "black"
+            else "yellow",
+            colorText.FAIL: "red",
+            colorText.WHITE: "white" 
+            if defaultCellFillColor == "white"
+            else "black",
+        }
+        cleanedUpStyledValues = []
+        cellFillColors = []
+        cleanedUpStyledValue = cellStyledValue
+        prefix = ""
+        for style in otherStyles:
+            cleanedUpStyledValue = cleanedUpStyledValue.replace(style, "")
+        # Find how many different colors are used for the cell value
+        coloredStyledValues = cleanedUpStyledValue.split(colorText.END)
+        for cleanedUpStyledValue in coloredStyledValues:
+            cleanedUpStyledValue = cleanedUpStyledValue.replace(colorText.END,"")
+            if cleanedUpStyledValue.strip() in ["", ",","/"]:
+                if len(cleanedUpStyledValues) > 0:
+                    cleanedUpStyledValues[len(cleanedUpStyledValues)-1] = f"{cleanedUpStyledValues[len(cleanedUpStyledValues)-1]}{cleanedUpStyledValue}"
+                else:
+                    prefix = cleanedUpStyledValue
+            else:
+                for style in mainStyles:
+                    if style in cleanedUpStyledValue:
+                        cellFillColors.append(colorsDict[style])
+                        for style in mainStyles:
+                            cleanedUpStyledValue = cleanedUpStyledValue.replace(style, "")
+                        cleanedUpStyledValues.append(prefix + cleanedUpStyledValue)
+                        prefix = ""
+                
+        if len(cellFillColors) == 0:
+            cellFillColors = [defaultCellFillColor]
+        if len(cleanedUpStyledValues) == 0:
+            cleanedUpStyledValues = [cellStyledValue]
+        return cellFillColors, cleanedUpStyledValues
+
+    def tableToImage(
+        table,
+        styledTable,
+        filename,
+        label,
+        backtestSummary=None,
+        backtestDetail=None,
+        addendum=None,
+        addendumLabel=None,
+        summaryLabel = None,
+        detailLabel = None,
+        legendPrefixText = ""
+    ):
+        if "PKDevTools_Default_Log_Level" not in os.environ.keys():
+            if (("RUNNER" in os.environ.keys() and os.environ["RUNNER"] == "LOCAL_RUN_SCANNER")):
+                return
+        warnings.filterwarnings("ignore", category=DeprecationWarning)
+        ART_FONT_SIZE = 30
+        STD_FONT_SIZE = 60
+        # First 4 lines are headers. Last 1 line is bottom grid line
+        fontPath = tools.setupReportFont()
+        artfont = ImageFont.truetype(fontPath, ART_FONT_SIZE)
+        stdfont = ImageFont.truetype(fontPath, STD_FONT_SIZE)
+        
+        bgColor, gridColor, artColor, menuColor = tools.getDefaultColors()
+
+        dfs_to_print = [styledTable, backtestSummary, backtestDetail]
+        unstyled_dfs = [table, backtestSummary, backtestDetail]
+        reportTitle = f"[+] As of {PKDateUtilities.currentDateTime().strftime('%d-%m-%y %H.%M.%S')} IST > You chose {label}"
+        titleLabels = [
+            f"[+] Scan results for {label} :",
+            summaryLabel if summaryLabel is not None else "[+] For chosen scan, summary of correctness from past: [Example, 70% of (100) under 1-Pd, means out of 100 stocks that were in the scan result in the past, 70% of them gained next day.)",
+            detailLabel if detailLabel is not None else "[+] 1 to 30 period gain/loss % for matching stocks on respective date from earlier predictions:[Example, 5% under 1-Pd, means the stock price actually gained 5% the next day from given date.]",
+        ]
+
+        artfont_arttext_width, artfont_arttext_height = artfont.getsize_multiline(artText+ f" | {marketStatus()}")
+        stdFont_oneLinelabel_width, stdFont_oneLinelabel_height = stdfont.getsize_multiline(label)
+        stdFont_scanResulttext_width, stdFont_scanResulttext_height = stdfont.getsize_multiline(table) if len(table) > 0 else (0,0)
+        unstyled_backtestsummary = tools.removeAllColorStyles(backtestSummary)
+        unstyled_backtestDetail = tools.removeAllColorStyles(backtestDetail)
+        stdFont_backtestSummary_text_width,stdFont_backtestSummary_text_height= stdfont.getsize_multiline(unstyled_backtestsummary) if len(unstyled_backtestsummary) > 0 else (0,0)
+        stdFont_backtestDetail_text_width, stdFont_backtestDetail_text_height = stdfont.getsize_multiline(unstyled_backtestDetail) if len(unstyled_backtestDetail) > 0 else (0,0)
+        artfont_scanResultText_width, _ = artfont.getsize_multiline(table) if len(table) > 0 else (0,0)
+        artfont_backtestSummary_text_width, _ = artfont.getsize_multiline(backtestSummary) if (backtestSummary is not None and len(backtestSummary)) > 0 else (0,0)
+        stdfont_addendumtext_height = 0
+        stdfont_addendumtext_width = 0
+        if addendum is not None and len(addendum) > 0:
+            unstyled_addendum = tools.removeAllColorStyles(addendum)
+            stdfont_addendumtext_width , stdfont_addendumtext_height = stdfont.getsize_multiline(unstyled_addendum)
+            titleLabels.append(addendumLabel)
+            dfs_to_print.append(addendum)
+            unstyled_dfs.append(unstyled_addendum)
+
+        repoText = tools.getRepoHelpText(table,backtestSummary)
+        artfont_repotext_width, artfont_repotext_height = artfont.getsize_multiline(repoText)
+        legendText = legendPrefixText + tools.getLegendHelpText(table,backtestSummary)
+        _, artfont_legendtext_height = artfont.getsize_multiline(legendText)
+        column_separator = "|"
+        line_separator = "+"
+        stdfont_sep_width, _ = stdfont.getsize_multiline(column_separator)
+
+        startColValue = 100
+        xVertical = startColValue
+        rowPixelRunValue = 9
+        im_width = max(
+            artfont_arttext_width,
+            stdFont_oneLinelabel_width,
+            stdFont_scanResulttext_width,
+            stdFont_backtestSummary_text_width,
+            stdFont_backtestDetail_text_width,
+            artfont_repotext_width,
+            artfont_scanResultText_width,
+            artfont_backtestSummary_text_width,
+            stdfont_addendumtext_width
+        ) + int(startColValue * 2)
+        im_height = int(
+                    artfont_arttext_height # Always
+                    + 3*stdFont_oneLinelabel_height # Title label # Always
+                    + stdFont_scanResulttext_height + (stdFont_oneLinelabel_height if stdFont_scanResulttext_height > 0 else 0)
+                    + stdFont_backtestSummary_text_height + (stdFont_oneLinelabel_height if stdFont_backtestSummary_text_height > 0 else 0)
+                    + stdFont_backtestDetail_text_height + (stdFont_oneLinelabel_height if stdFont_backtestDetail_text_height > 0 else 0)
+                    + artfont_repotext_height # Always
+                    + artfont_legendtext_height # Always
+                    + stdfont_addendumtext_height + (stdFont_oneLinelabel_height if stdfont_addendumtext_height > 0 else 0)
+                )
+        im = Image.new("RGB",(im_width,im_height),bgColor)
+        draw = ImageDraw.Draw(im)
+        # artwork
+        draw.text((startColValue, rowPixelRunValue), artText+ f" | {tools.removeAllColorStyles(marketStatus())}", font=artfont, fill=artColor)
+        rowPixelRunValue += artfont_arttext_height + 1
+        # Report title
+        draw.text((startColValue, rowPixelRunValue), reportTitle, font=stdfont, fill=menuColor)
+        rowPixelRunValue += stdFont_oneLinelabel_height + 1
+        counter = -1
+        for df in dfs_to_print:
+            counter += 1
+            colPixelRunValue = startColValue
+            if df is None or len(df) == 0:
+                continue
+            # selected menu options and As of DateTime
+            draw.text(
+                (colPixelRunValue, rowPixelRunValue),
+                titleLabels[counter],
+                font=stdfont,
+                fill=menuColor,
+            )
+            rowPixelRunValue += stdFont_oneLinelabel_height
+            unstyledLines = unstyled_dfs[counter].splitlines()
+            lineNumber = 0
+            screenLines = df.splitlines()
+            for line in screenLines:
+                _, stdfont_line_height = stdfont.getsize_multiline(line)
+                # Print the row separators
+                if not (line.startswith(column_separator)):
+                    draw.text(
+                        (colPixelRunValue, rowPixelRunValue),
+                        line,
+                        font=stdfont,
+                        fill=gridColor,
+                    )
+                    rowPixelRunValue += stdfont_line_height + 1
+                else: # if (line.startswith(column_separator)):
+                    # Print the row contents
+                    columnNumber = 0
+                    valueScreenCols = line.split(column_separator)
+                    try:
+                        del valueScreenCols[0] # Remove the empty column header at the first position
+                        del valueScreenCols[-1] # Remove the empty column header at the last position
+                    except Exception as e:# pragma: no cover
+                        default_logger().debug(e, exc_info=True)
+                        draw.text(
+                            (colPixelRunValue, rowPixelRunValue),
+                            line,
+                            font=stdfont,
+                            fill=gridColor,
+                        )
+                        lineNumber = lineNumber - 1
+                        pass
+                    # Print each colored value of each cell as we go over each row
+                    for val in valueScreenCols:
+                        if lineNumber >= len(unstyledLines):
+                            continue
+                        # Draw the column separator first
+                        draw.text(
+                            (colPixelRunValue, rowPixelRunValue),
+                            column_separator,
+                            font=stdfont,
+                            fill=gridColor,
+                        )
+                        colPixelRunValue = colPixelRunValue + stdfont_sep_width
+                        unstyledLine = unstyledLines[lineNumber]
+                        cellStyles, cellCleanValues = tools.getCellColors(
+                            val, defaultCellFillColor=gridColor
+                        )
+                        valCounter = 0
+                        for style in cellStyles:
+                            cleanValue = cellCleanValues[valCounter]
+                            valCounter += 1
+                            if columnNumber == 0 and len(cleanValue.strip()) > 0:
+                                if column_separator in unstyledLine:
+                                    cleanValue = unstyledLine.split(column_separator)[1]
+                                if "\\" in cleanValue:
+                                    cleanValue = cleanValue.split("\\")[-1]
+                                # style = style if "%" in cleanValue else gridColor
+                            if bgColor == "white" and style == "yellow":
+                                # Yellow on a white background is difficult to read
+                                style = "blue"
+                            elif bgColor == "black" and style == "blue":
+                                # blue on a black background is difficult to read
+                                style = "yellow"
+                            col_width, _ = stdfont.getsize_multiline(cleanValue)
+                            draw.text(
+                                (colPixelRunValue, rowPixelRunValue),
+                                cleanValue,
+                                font=stdfont,
+                                fill=style,
+                            )
+                            colPixelRunValue = colPixelRunValue + col_width
+                            if columnNumber == 0:
+                                xVertical = int(columnNumber/2)
+
+                        columnNumber = columnNumber + 1
+                    if len(valueScreenCols) > 0:
+                        # Close the row with the separator
+                        draw.text(
+                            (colPixelRunValue, rowPixelRunValue),
+                            column_separator,
+                            font=stdfont,
+                            fill=gridColor,
+                        )
+                        colPixelRunValue = startColValue
+                    rowPixelRunValue +=  stdfont_line_height + 1
+                lineNumber = lineNumber + 1
+            rowPixelRunValue += stdFont_oneLinelabel_height
+        
+        # Repo text
+        draw.text(
+            (colPixelRunValue, rowPixelRunValue + 1),
+            repoText,
+            font=artfont,
+            fill=menuColor,
+        )
+        # Legend text
+        rowPixelRunValue += 2 * stdFont_oneLinelabel_height + 20
+        legendLines = legendText.splitlines()
+        legendSeperator = "***"
+        col_width_sep, _ = artfont.getsize_multiline(legendSeperator)
+        for line in legendLines:
+            colPixelRunValue = startColValue
+            _, artfont_line_height = artfont.getsize_multiline(line)
+            lineitems = line.split(legendSeperator)
+            red = True
+            for lineitem in lineitems:
+                if lineitem == "" or not red:
+                    draw.text(
+                        (colPixelRunValue, rowPixelRunValue),
+                        legendSeperator,
+                        font=artfont,
+                        fill=gridColor,
+                    )
+                    colPixelRunValue += col_width_sep + 1
+                style = "red" if not red else gridColor
+                red = not red
+                lineitem = lineitem.replace(": ","***: ")
+                draw.text(
+                    (colPixelRunValue, rowPixelRunValue),
+                    lineitem,
+                    font=artfont,
+                    fill=style,
+                )
+                col_width, _ = artfont.getsize_multiline(lineitem)
+                # Move to the next text in the same line
+                colPixelRunValue += col_width + 1
+                
+            # Let's go to the next line
+            rowPixelRunValue += artfont_line_height + 1
+
+        im = im.resize(im.size, Image.ANTIALIAS, reducing_gap=2)
+        im = tools.addQuickWatermark(im,xVertical,dataSrc="Yahoo; Morningstar, Inc; National Stock Exchange of India Ltd;",dataSrcFontSize=ART_FONT_SIZE)
+        im.save(filename, format="png", bitmap_format="png", optimize=True, quality=20)
+        # if 'RUNNER' not in os.environ.keys() and 'PKDevTools_Default_Log_Level' in os.environ.keys():
+        # im.show()
+
+    def wrapFitLegendText(table, backtestSummary, legendText):
+        wrapper = textwrap.TextWrapper(
+            width=2
+            * int(
+                len(table.split("\n")[0])
+                if len(table) > 0
+                else len(backtestSummary.split("\n")[0])
+            )
+        )
+        word_list = wrapper.wrap(text=legendText)
+        legendText_new = ""
+        for ii in word_list[:-1]:
+            legendText_new = legendText_new + ii + "\n"
+        legendText_new += word_list[-1]
+        legendText = legendText_new
+        return legendText
+
+    def getDefaultColors():
+        artColors = ["blue", "indigo", "green", "red", "yellow","orange","violet"]
+        bgColor = "white" if PKDateUtilities.currentDateTime().day % 2 == 0 else "black"
+        gridColor = "black" if bgColor == "white" else "white"
+        artColor = random.choice(artColors[3:]) if bgColor == "black" else random.choice(artColors[:3])
+        menuColor = "red"
+        return bgColor,gridColor,artColor,menuColor
+
+    def setupReportFont():
+        fontURL = "https://raw.githubusercontent.com/pkjmesra/pkscreener/main/pkscreener/courbd.ttf"
+        fontFile = fontURL.split("/")[-1]
+        bData, fontPath, _ = Archiver.findFile(fontFile)
+        if bData is None:
+            resp = fetcher.fetchURL(fontURL, stream=True)
+            with open(fontPath, "wb") as f:
+                for chunk in resp.iter_content(chunk_size=1024):
+                    if chunk:  # filter out keep-alive new chunks
+                        f.write(chunk)
+        return fontPath
+
+    def getLegendHelpText(table,backtestSummary):
+        legendText = "\n***1.Stock***: This is the NSE symbol/ticker for a company. Stocks that are NOT stage two, are coloured red.***2.Consol.***: It shows the price range in which stock is trading for the last 22 trading sessions(22 trading sessions per month)***3.Breakout(22Prds)***: The BO is Breakout level based on last 22 sessions. R is the resistance level (if available)."
+        legendText = f"{legendText} An investor should consider both BO & R level to analyse entry / exits in their trading lessons. If the BO value is green, it means the stock has already broken out (is above BO level). If BO is in red, it means the stock is yet to break out.***4.LTP***: This is the last/latest trading/closing price of the given stock on a given date at NSE. The LTP in green/red means the"
+        legendText = f"{legendText} stock price has increased / decreased since last trading session. (1.5%, 1.3%,1.8%) with LTP shows the stock price rose by 1.5%, 1.3% and 1.8% in the last 1, 2 and 3 trading sessions respectively.***5.%Chng***: This is the change(rise/fall in percentage) in closing/trading price from the previous trading session's closing price. Green means that price rose from the previous"
+        legendText = f"{legendText} trading session. Red means it fell.***6.Volume***: This shows the relative volume in the most recent trading day /today with respect to last 20 trading periods moving average of Volume. For example, 8.5x would mean today's volume so far is 8.5 times the average volume traded in the last 20 trading sessions. Volume in green means that volume for the date so far has been at"
+        legendText = f"{legendText} least 2.5 times more than the average volume of last 20 sessions. If the volume is in red, it means the given date's volume is less than 2.5 times the avg volume of the last 20 sessions.***7.MA-Signal***: It shows the price trend of the given stock by analyzing various 50-200 moving/exponential averages crossover strategies. Perform a Google search for the shown MA-Signals"
+        legendText = f"{legendText} to learn about them more. If it is in green, the signal is bullish. Red means bearish.***8.RSI-or-RSI/i***: Relative Strength Index is a momentum index which describes 14-period relative strength at the given price. Generally, below 30 is considered oversold and above 80 is considered overbought. When RSI/i has value, say, 80/41, it means that the daily RSI value is 80 while"
+        legendText = f"{legendText} the 1-minute intraday RSI is 41.***9.Trend(22Prds)***:  This describes the average trendline computed based on the last 22 trading sessions. Their strength is displayed depending on the steepness of the trendlines. (Strong / Weak) Up / Down shows how high/low the demand is respectively. A Sideways trend is the horizontal price movement that occurs when the forces of supply"
+        legendText = f"{legendText} and demand are nearly equal. T: or T: shows the general moving average uptrend/downtrend from a 200 day MA perspective"
+        legendText = f"{legendText} if the current 200DMA is more/less than the last 20/80/100 days' 200DMA. Similarly, t: or t: shows for 50DMA based on 9/14/20 days' 50DMA trend. MFI: or MFI: shows"
+        legendText = f"{legendText} if the overall top 5 mutual funds and top 5 institutional investors ownership went up or down on the closing of the last month.***10.Pattern***:This shows if the chart or the candle (from the candlestick chart) is"
+        legendText = f"{legendText} forming any known pattern in the recent timeframe or as per the selected screening options. Do a google search for the shown pattern names to learn.***11.CCI***: The Commodity Channel Index (CCI) is a technical indicator that measures the difference between the current price and the historical average price of the given stock. Generally below '- 100' is considered oversold"
+        legendText = f"{legendText} and above 100 is considered overbought. If the CCI is < '-100' or CCI is > 100 and the Trend(22Prds) is Strong/Weak Up, it is shown in green. Otherwise it's in red.***12.1-Pd/2-Pd-etc.***: 60.29% of (413) under 1-Pd in green shows that the given scan option was correct 60.23% of the times for 413 stocks that scanner found in the last 22 trading sessions under the same scan"
+        legendText = f"{legendText} options. Similarly, 61.69 % of (154) in green under 22-Pd, means we found that 61.56% of 154 stocks (~95 stocks) prices found under the same scan options increased in 22 trading periods. 57.87% of (2661) under 'Overall' means that over the last 22 trading sessions we found 2661 stock instances under the same scanning options (for example, Momentum Gainers), out of which 57.87%"
+        legendText = f"{legendText} of the stock prices increased in one or more of the last 1 or 2 or 3 or 4 or 5 or 10 or 22 or 22 trading sessions. If you want to see by what percent the prices increased, you should see the details.***13.1-to-30-period-gain/loss%***: 4.17% under 1-Pd in green in the gain/loss table/grid means the stock price increased by 4.17% in the next 1 trading session. If this is in"
+        legendText = f"{legendText} red, example, -5.67%, it means the price actually decreased by 5.67%. Gains are in green and losses are in red in this grid. The Date column has the date(s) on which that specific stock was found under the chosen scan options in the past 22 trading sessions.***14.52Wk-H/L***: These have 52 weeks high/low prices and will be shown in red, green or yellow based on how close the"
+        legendText = f"{legendText} price is to the 52 wk high/low value.If the 52 week high/low value is within 10% of LTP:Yellow, LTP is above 52 week high:Green. If the LTP is below 90% of 52 week high:Red.***15.1-Pd-%***: Shows the 1 period gain in percent from the given date. Similarly 2-Pd-%, 3-Pd-% etc shows 2 day, 3 days gain etc.***16.1-Pd-10k***: Shows 1 period/day portfolio value if you would"
+        legendText = f"{legendText} have invested 10,000 on the given date.***17.[T][_trend_]***: [T] is for Trends followed by the trend name in the filter.***18.[BO]***: This Shows the Breakout filter value from the backtest reports and will be available only if 'showpaststrategydata' configuration is turned on.***19.[P]***: [P] shows pattern name.***20.MFI***: Top 5 Mutual fund ownership and "
+        legendText = f"{legendText} top 5 Institutional investor ownership status as on the last day of the last month, based on analysis from Morningstar.***21.FairValue***: Morningstar Fair value of a given stock as of last trading day as determined by 3rd party analysis based on fundamentals.***22.MCapWt%***: This shows the market-cap weighted portfolio weight to consider investing.\n"
+        legendText = tools.wrapFitLegendText(table,backtestSummary, legendText)
+        # legendText = legendText.replace("***:", colorText.END + colorText.WHITE)
+        # legendText = legendText.replace("***", colorText.END + colorText.FAIL)
+        # return colorText.WHITE + legendText + colorText.END
+        return legendText
+
+    def getRepoHelpText(table,backtestSummary):
+        repoText = f"Source: https://GitHub.com/pkjmesra/pkscreener/  |  {datetime.date.today().year} pkjmesra | Telegram: https://t.me/PKScreener |"
+        disclaimer = f"The author is NOT a financial advisor and is NOT SEBI registered. This report is for learning/analysis purposes ONLY. Author assumes no responsibility or liability for any errors or omissions in this report or repository, or gain/loss bearing out of this analysis. The user MUST take advise ONLY from registered SEBI financial advisors only."
+        repoText = f"{repoText}\n{tools.wrapFitLegendText(table,backtestSummary,disclaimer)}"
+        repoText = f"{repoText}\n[+] Understanding this report:\n\n"
+        return repoText
+
+    def set_github_output(name, value):
+        if "GITHUB_OUTPUT" in os.environ.keys():
+            with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
+                print(f"{name}={value}", file=fh)
+
+    def afterMarketStockDataExists(intraday=False, forceLoad=False):
+        curr = PKDateUtilities.currentDateTime()
+        openTime = curr.replace(hour=9, minute=15)
+        cache_date = PKDateUtilities.previousTradingDate(PKDateUtilities.nextTradingDate(curr)) #curr  # for monday to friday
+        weekday = curr.weekday()
+        isTrading = PKDateUtilities.isTradingTime()
+        if (forceLoad and isTrading) or isTrading:
+            #curr = PKDateUtilities.tradingDate()
+            cache_date = PKDateUtilities.previousTradingDate(curr) #curr - datetime.timedelta(1)
+        # for monday to friday before 9:15 or between 9:15am to 3:30pm, we're backtesting
+        if curr < openTime:
+            cache_date = PKDateUtilities.previousTradingDate(curr) # curr - datetime.timedelta(1)
+        if weekday == 0 and curr < openTime:  # for monday before 9:15
+            cache_date = PKDateUtilities.previousTradingDate(curr) #curr - datetime.timedelta(3)
+        if weekday == 5 or weekday == 6:  # for saturday and sunday
+            cache_date = PKDateUtilities.previousTradingDate(curr) # curr - datetime.timedelta(days=weekday - 4)
+        cache_date = cache_date.strftime("%d%m%y")
+        pattern = f"{'intraday_' if intraday else ''}stock_data_"
+        cache_file = pattern + str(cache_date) + ".pkl"
+        exists = False
+        for f in glob.glob(f"{pattern}*.pkl", root_dir=Archiver.get_user_outputs_dir()):
+            if f.endswith(cache_file):
+                exists = True
+                break
+        return exists, cache_file
+
+    def saveStockData(stockDict, configManager, loadCount, intraday=False, downloadOnly=False, forceSave=False):
+        exists, fileName = tools.afterMarketStockDataExists(
+            configManager.isIntradayConfig() or intraday
+        )
+        outputFolder = Archiver.get_user_outputs_dir()
+        if downloadOnly:
+            outputFolder = outputFolder.replace("results","actions-data-download")
+            if not os.path.isdir(outputFolder):
+                os.makedirs(os.path.dirname(f"{outputFolder}{os.sep}"), exist_ok=True)
+            configManager.deleteFileWithPattern(rootDir=outputFolder)
+        cache_file = os.path.join(outputFolder, fileName)
+        if not os.path.exists(cache_file) or forceSave or (loadCount >= 0 and len(stockDict) > (loadCount + 1)):
+            try:
+                with open(cache_file, "wb") as f:
+                    pickle.dump(stockDict.copy(), f, protocol=pickle.HIGHEST_PROTOCOL)
+                    OutputControls().printOutput(colorText.BOLD + colorText.GREEN + "=> Done." + colorText.END)
+                if downloadOnly:
+                    OutputControls().printOutput(colorText.BOLD + colorText.GREEN + f"=> {cache_file}" + colorText.END)
+                    Committer.execOSCommand(f"git add {cache_file} -f >/dev/null 2>&1")
+                    if "RUNNER" not in os.environ.keys():
+                        copyFilePath = os.path.join(Archiver.get_user_outputs_dir(), f"copy_{fileName}")
+                        cacheFileSize = os.stat(cache_file).st_size if os.path.exists(cache_file) else 0
+                        if os.path.exists(cache_file) and cacheFileSize >= 1024*1024*50:
+                            shutil.copy(cache_file,copyFilePath) # copy is the saved source of truth
+            except pickle.PicklingError as e:  # pragma: no cover
+                default_logger().debug(e, exc_info=True)
+                OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + "=> Error while Caching Stock Data."
+                    + colorText.END
+                )
+            except Exception as e:  # pragma: no cover
+                default_logger().debug(e, exc_info=True)
+        else:
+            OutputControls().printOutput(
+                colorText.BOLD + colorText.GREEN + "=> Already Cached." + colorText.END
+            )
+            if downloadOnly:
+                OutputControls().printOutput(colorText.BOLD + colorText.GREEN + f"=> {cache_file}" + colorText.END)
+        return cache_file
+
+    def downloadLatestData(stockDict,configManager,stockCodes=[],exchangeSuffix=".NS",downloadOnly=False):
+        numStocksPerIteration = (int(len(stockCodes)/int(len(stockCodes)/10)) if len(stockCodes) >= 10 else len(stockCodes)) + 1
+        queueCounter = 0
+        iterations = int(len(stockCodes)/numStocksPerIteration) + 1
+        tasksList = []
+        while queueCounter < iterations:
+            stocks = []
+            if queueCounter < iterations:
+                stocks = stockCodes[numStocksPerIteration* queueCounter : numStocksPerIteration* (queueCounter + 1)]
+            else:
+                stocks = ["DUMMYStock"]#stockCodes[numStocksPerIteration* queueCounter :]
+            fn_args = (stocks, configManager.period, configManager.duration,exchangeSuffix)
+            task = PKTask(f"DataDownload-{queueCounter}",long_running_fn=fetcher.fetchStockDataWithArgs,long_running_fn_args=fn_args)
+            task.userData = stocks
+            if len(stocks) > 0:
+                tasksList.append(task)
+            queueCounter += 1
+        
+        processedStocks = []
+        if len(tasksList) > 0:
+            # Suppress any multiprocessing errors/warnings
+            with SuppressOutput(suppress_stderr=True, suppress_stdout=True):
+                PKScheduler.scheduleTasks(tasksList=tasksList, 
+                                        label=f"Downloading latest data [{configManager.period},{configManager.duration}] (Total={len(stockCodes)} records in {len(tasksList)} batches){'Be Patient!' if len(stockCodes)> 2000 else ''}",
+                                        timeout=(5+2.5*configManager.longTimeout*(4 if downloadOnly else 1)), # 5 sec additional time for multiprocessing setup
+                                        minAcceptableCompletionPercentage=(100 if downloadOnly else 100))
+            for task in tasksList:
+                if task.result is not None:
+                    for stock in task.userData:
+                        taskResult = task.result.get(f"{stock}{exchangeSuffix}")
+                        if taskResult is not None:
+                            stockDict[stock] = taskResult.to_dict("split")
+                            processedStocks.append(stock)
+        leftOutStocks = list(set(stockCodes)-set(processedStocks))
+        default_logger().debug(f"Attempted fresh download of {len(stockCodes)} stocks and downloaded {len(processedStocks)} stocks. {len(leftOutStocks)} stocks remaining.")
+        return stockDict, leftOutStocks
+
+    def loadStockData(
+        stockDict,
+        configManager,
+        downloadOnly=False,
+        defaultAnswer=None,
+        retrial=False,
+        forceLoad=False,
+        stockCodes=[],
+        exchangeSuffix=".NS",
+        isIntraday = False,
+        forceRedownload=False
+    ):
+        isIntraday = isIntraday or configManager.isIntradayConfig()
+        exists, cache_file = tools.afterMarketStockDataExists(
+            isIntraday, forceLoad=forceLoad
+        )
+        initialLoadCount = len(stockDict)
+        leftOutStocks = None
+        recentDownloadFromOriginAttempted = False
+        isTrading = PKDateUtilities.isTradingTime() and (PKDateUtilities.wasTradedOn() or not PKDateUtilities.isTodayHoliday()[0])
+        # stockCodes is not None mandates that we start our work based on the downloaded data from yesterday
+        if (stockCodes is not None and len(stockCodes) > 0) and (isTrading or downloadOnly):
+            recentDownloadFromOriginAttempted = True
+            stockDict, leftOutStocks = tools.downloadLatestData(stockDict,configManager,stockCodes,exchangeSuffix=exchangeSuffix,downloadOnly=downloadOnly)
+            if len(leftOutStocks) > int(len(stockCodes)*0.05):
+                # More than 5 % of stocks are still remaining
+                stockDict, _ = tools.downloadLatestData(stockDict,configManager,leftOutStocks,exchangeSuffix=exchangeSuffix,downloadOnly=downloadOnly)
+            # return stockDict
+        if downloadOnly or isTrading:
+            # We don't want to download from local stale pkl file or stale file at server
+            return stockDict
+        
+        default_logger().debug(
+            f"Stock data cache file:{cache_file} exists ->{str(exists)}"
+        )
+        stockDataLoaded = False
+        copyFilePath = os.path.join(Archiver.get_user_outputs_dir(), f"copy_{cache_file}")
+        srcFilePath = os.path.join(Archiver.get_user_outputs_dir(), cache_file)
+        if os.path.exists(copyFilePath):
+            shutil.copy(copyFilePath,srcFilePath) # copy is the saved source of truth
+        if os.path.exists(srcFilePath) and not forceRedownload:
+            stockDict, stockDataLoaded = tools.loadDataFromLocalPickle(stockDict,configManager, downloadOnly, defaultAnswer, exchangeSuffix, cache_file, isTrading)
+        if (
+            not stockDataLoaded
+            and ("1d" if isIntraday else ConfigManager.default_period)
+            == configManager.period
+            and ("1m" if isIntraday else ConfigManager.default_duration)
+            == configManager.duration
+        ) or forceRedownload:
+            stockDict, stockDataLoaded = tools.downloadSavedDataFromServer(stockDict,configManager, downloadOnly, defaultAnswer, retrial, forceLoad, stockCodes, exchangeSuffix, isIntraday, forceRedownload, cache_file, isTrading)
+        if not stockDataLoaded:
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] Cache unavailable on pkscreener server, Continuing.."
+                + colorText.END
+            )
+        if not stockDataLoaded and not recentDownloadFromOriginAttempted:
+            stockDict, _ = tools.downloadLatestData(stockDict,configManager,stockCodes,exchangeSuffix=exchangeSuffix,downloadOnly=downloadOnly)
+        # See if we need to save stock data
+        stockDataLoaded = stockDataLoaded or (len(stockDict) > 0 and (len(stockDict) != initialLoadCount))
+        if stockDataLoaded:
+            tools.saveStockData(stockDict,configManager,initialLoadCount,isIntraday,downloadOnly, forceSave=stockDataLoaded)
+        return stockDict
+
+    def loadDataFromLocalPickle(stockDict, configManager, downloadOnly, defaultAnswer, exchangeSuffix, cache_file, isTrading):
+        stockDataLoaded = False
+        srcFilePath = os.path.join(Archiver.get_user_outputs_dir(), cache_file)
+        with open(srcFilePath, "rb") as f:
+            try:
+                stockData = pickle.load(f)
+                if not downloadOnly:
+                    OutputControls().printOutput(
+                            colorText.BOLD
+                            + colorText.GREEN
+                            + f"[+] Automatically Using Cached Stock Data {'due to After-Market hours' if not PKDateUtilities.isTradingTime() else ''}!"
+                            + colorText.END
+                        )
+                if stockData is not None and len(stockData) > 0:
+                    multiIndex = stockData.keys()
+                    if isinstance(multiIndex, pd.MultiIndex):
+                            # If we requested for multiple stocks from yfinance
+                            # we'd have received a multiindex dataframe
+                        listStockCodes = multiIndex.get_level_values(0)
+                        listStockCodes = sorted(list(filter(None,list(set(listStockCodes)))))
+                        if len(listStockCodes) > 0 and len(exchangeSuffix) > 0 and exchangeSuffix in listStockCodes[0]:
+                            listStockCodes = [x.replace(exchangeSuffix,"") for x in listStockCodes]
+                    else:
+                        listStockCodes = list(stockData.keys())
+                        if len(listStockCodes) > 0 and len(exchangeSuffix) > 0 and exchangeSuffix in listStockCodes[0]:
+                            listStockCodes = [x.replace(exchangeSuffix,"") for x in listStockCodes]
+                    for stock in listStockCodes:
+                        df_or_dict = stockData.get(stock)
+                        df_or_dict = df_or_dict.to_dict("split") if isinstance(df_or_dict,pd.DataFrame) else df_or_dict
+                            # This will keep all the latest security data we downloaded
+                            # just now and also copy the additional data like, MF/FII,FairValue
+                            # etc. data, from yesterday's saved data.
+                        try:
+                            existingPreLoadedData = stockDict.get(stock)
+                            if existingPreLoadedData is not None:
+                                if isTrading:
+                                        # Only copy the MF/FII/FairValue data and leave the stock prices as is.
+                                    cols = ["MF", "FII","MF_Date","FII_Date","FairValue"]
+                                    for col in cols:
+                                        existingPreLoadedData[col] = df_or_dict.get(col)
+                                    stockDict[stock] = existingPreLoadedData
+                                else:
+                                    stockDict[stock] = df_or_dict | existingPreLoadedData
+                            else:
+                                if not isTrading:
+                                    stockDict[stock] = df_or_dict
+                        except:
+                                # Probably, the "stock" got removed from the latest download
+                                # and so, was not found in stockDict
+                            continue
+                    # if len(stockDict) > 0:
+                    #     stockDict = stockDict | stockData
+                    # else:
+                    #     stockDict = stockData
+                    stockDataLoaded = True
+            except pickle.UnpicklingError as e:
+                default_logger().debug(e, exc_info=True)
+                f.close()
+                OutputControls().printOutput(
+                        colorText.BOLD
+                        + colorText.FAIL
+                        + "[+] Error while Reading Stock Cache."
+                        + colorText.END
+                    )
+                if tools.promptFileExists(defaultAnswer=defaultAnswer) == "Y":
+                    configManager.deleteFileWithPattern()
+            except EOFError as e:  # pragma: no cover
+                default_logger().debug(e, exc_info=True)
+                f.close()
+                OutputControls().printOutput(
+                        colorText.BOLD
+                        + colorText.FAIL
+                        + "[+] Stock Cache Corrupted."
+                        + colorText.END
+                    )
+                if tools.promptFileExists(defaultAnswer=defaultAnswer) == "Y":
+                    configManager.deleteFileWithPattern()
+        return stockDict, stockDataLoaded
+
+    def downloadSavedDataFromServer(stockDict, configManager, downloadOnly, defaultAnswer, retrial, forceLoad, stockCodes, exchangeSuffix, isIntraday, forceRedownload, cache_file, isTrading):
+        stockDataLoaded = False
+        OutputControls().printOutput(
+                    colorText.BOLD
+                    + colorText.FAIL
+                    + "[+] Market Stock Data is not cached, or forced to redownload .."
+                    + colorText.END
+                )
+        OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.GREEN
+                + f"[+] Downloading {'Intraday' if configManager.isIntradayConfig() else 'Daily'} cache from server for faster processing, Please Wait.."
+                + colorText.END
+            )
+        cache_url = (
+                "https://raw.githubusercontent.com/pkjmesra/PKScreener/actions-data-download/actions-data-download/"
+                + cache_file  # .split(os.sep)[-1]
+            )
+        headers = {
+                    'authority': 'raw.githubusercontent.com',
+                    'accept': '*/*',
+                    'accept-language': 'en-US,en;q=0.9',
+                    'dnt': '1',
+                    'sec-ch-ua-mobile': '?0',
+                    # 'sec-ch-ua-platform': '"macOS"',
+                    'sec-fetch-dest': 'empty',
+                    'sec-fetch-mode': 'cors',
+                    'sec-fetch-site': 'cross-site',                  
+                    'origin': 'https://github.com',
+                    'referer': f'https://github.com/pkjmesra/PKScreener/blob/actions-data-download/actions-data-download/{cache_file}',
+                    'user-agent': f'{random_user_agent()}' 
+                    #'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36
+            }
+        resp = fetcher.fetchURL(cache_url, headers=headers, stream=True)
+        if resp is not None:
+            default_logger().debug(
+                    f"Stock data cache file:{cache_file} request status ->{resp.status_code}"
+                )
+        if resp is not None and resp.status_code == 200:
+            contentLength = resp.headers.get("content-length")
+            serverBytes = int(contentLength) if contentLength is not None else 0
+            KB = 1024
+            MB = KB * 1024
+            chunksize = MB if serverBytes >= MB else (KB if serverBytes >= KB else 1)
+            filesize = int( serverBytes / chunksize)
+            if filesize > 40 and chunksize == MB: # Saved data can't be in KBs. Something definitely went wrong. It should be upward of 40MB
+                bar, spinner = tools.getProgressbarStyle()
+                try:
+                    f = open(
+                            os.path.join(Archiver.get_user_outputs_dir(), cache_file),
+                            "w+b",
+                        )  # .split(os.sep)[-1]
+                    dl = 0
+                    with alive_bar(
+                            filesize, bar=bar, spinner=spinner, manual=True
+                        ) as progressbar:
+                        for data in resp.iter_content(chunk_size=chunksize):
+                            dl += 1
+                            f.write(data)
+                            progressbar(dl / filesize)
+                            if dl >= filesize:
+                                progressbar(1.0)
+                    f.close()
+                    with open(
+                            os.path.join(Archiver.get_user_outputs_dir(), cache_file),
+                            "rb",
+                        ) as f:
+                        stockData = pickle.load(f)
+                    if len(stockData) > 0:
+                        multiIndex = stockData.keys()
+                        if isinstance(multiIndex, pd.MultiIndex):
+                                # If we requested for multiple stocks from yfinance
+                                # we'd have received a multiindex dataframe
+                            listStockCodes = multiIndex.get_level_values(0)
+                            listStockCodes = sorted(list(filter(None,list(set(listStockCodes)))))
+                            if len(listStockCodes) > 0 and len(exchangeSuffix) > 0 and exchangeSuffix in listStockCodes[0]:
+                                listStockCodes = [x.replace(exchangeSuffix,"") for x in listStockCodes]
+                        else:
+                            listStockCodes = list(stockData.keys())
+                            if len(listStockCodes) > 0 and len(exchangeSuffix) > 0 and exchangeSuffix in listStockCodes[0]:
+                                listStockCodes = [x.replace(exchangeSuffix,"") for x in listStockCodes]
+                        for stock in listStockCodes:
+                            df_or_dict = stockData.get(stock)
+                            df_or_dict = df_or_dict.to_dict("split") if isinstance(df_or_dict,pd.DataFrame) else df_or_dict
+                                # This will keep all the latest security data we downloaded
+                                # just now and also copy the additional data like, MF/FII,FairValue
+                                # etc. data, from yesterday's saved data.
+                            try:
+                                existingPreLoadedData = stockDict.get(stock)
+                                if existingPreLoadedData is not None:
+                                    if isTrading:
+                                            # Only copy the MF/FII/FairValue data and leave the stock prices as is.
+                                        cols = ["MF", "FII","MF_Date","FII_Date","FairValue"]
+                                        for col in cols:
+                                            existingPreLoadedData[col] = df_or_dict.get(col)
+                                        stockDict[stock] = existingPreLoadedData
+                                    else:
+                                        stockDict[stock] = df_or_dict | existingPreLoadedData
+                                else:
+                                    if not isTrading:
+                                        stockDict[stock] = df_or_dict
+                            except:
+                                    # Probably, the "stock" got removed from the latest download
+                                    # and so, was not found in stockDict
+                                continue
+                        stockDataLoaded = True
+                        copyFilePath = os.path.join(Archiver.get_user_outputs_dir(), f"copy_{cache_file}")
+                        srcFilePath = os.path.join(Archiver.get_user_outputs_dir(), cache_file)
+                        if os.path.exists(copyFilePath) and os.path.exists(srcFilePath):
+                            shutil.copy(copyFilePath,srcFilePath) # copy is the saved source of truth
+                        if not os.path.exists(copyFilePath) and os.path.exists(srcFilePath): # Let's make a copy of the original one
+                            shutil.copy(srcFilePath,copyFilePath)
+                        # Remove the progress bar now!
+                        sys.stdout.write("\x1b[1A")  # cursor up one line
+                        sys.stdout.write("\x1b[2K")  # delete the last line
+                except Exception as e:  # pragma: no cover
+                    default_logger().debug(e, exc_info=True)
+                    f.close()
+                    OutputControls().printOutput("[!] Download Error - " + str(e))
+            else:
+                default_logger().debug(
+                        f"Stock data cache file:{cache_file} on server has length ->{filesize} {'Mb' if chunksize >= MB else ('Kb' if chunksize >= KB else 'bytes')}"
+                    )
+            if not retrial and not stockDataLoaded:
+                    # Don't try for more than once.
+                stockDict = tools.loadStockData(
+                        stockDict,
+                        configManager,
+                        downloadOnly,
+                        defaultAnswer,
+                        retrial=True,
+                        forceLoad=forceLoad,
+                        stockCodes=stockCodes,
+                        exchangeSuffix=exchangeSuffix,
+                        isIntraday = isIntraday,
+                        forceRedownload=forceRedownload
+                    )
+                
+        return stockDict,stockDataLoaded
+
+    # Save screened results to excel
+    def promptSaveResults(sheetName,df, defaultAnswer=None):
+        """
+        Tries to save the dataframe output into an excel file.
+
+        It will first try to save to the current-working-directory/results/
+
+        If it fails to save, it will then try to save to Desktop and then eventually into
+        a temporary directory.
+        """
+        isSaved = False
+        try:
+            if defaultAnswer is None:
+                response = str(
+                    input(
+                        colorText.BOLD
+                        + colorText.WARN
+                        + "[>] Do you want to save the results in excel file? [Y/N](Default:Y): "
+                    ) or "Y"
+                ).upper()
+            else:
+                response = defaultAnswer
+        except ValueError as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            response = "Y"
+        if response is not None and response.upper() != "N":
+            filename = (
+                "PKScreener-result_"
+                + PKDateUtilities.currentDateTime().strftime("%d-%m-%y_%H.%M.%S")
+                + ".xlsx"
+            )
+            desktop = os.path.expanduser("~/Desktop")
+            # # the above is valid on Windows (after 7) but if you want it in os normalized form:
+            desktop = os.path.normpath(os.path.expanduser("~/Desktop"))
+            filePath = ""
+            try:
+                filePath = os.path.join(Archiver.get_user_outputs_dir(), filename)
+                # Create a Pandas Excel writer using XlsxWriter as the engine.
+                writer = pd.ExcelWriter(filePath, engine='xlsxwriter') # openpyxl throws an error exporting % sign.
+                # Convert the dataframe to an XlsxWriter Excel object.
+                df.to_excel(writer, sheet_name=sheetName)
+                # Close the Pandas Excel writer and output the Excel file.
+                writer.close()
+                isSaved = True
+            except Exception as e:  # pragma: no cover
+                default_logger().debug(e, exc_info=True)
+                OutputControls().printOutput(
+                    colorText.FAIL
+                    + (
+                        "[+] Error saving file at %s"
+                        % filePath
+                    )
+                    + colorText.END
+                )
+                try:
+                    filePath = os.path.join(desktop, filename)
+                    # Create a Pandas Excel writer using XlsxWriter as the engine.
+                    writer = pd.ExcelWriter(filePath, engine='xlsxwriter') # openpyxl throws an error exporting % sign.
+                    # Convert the dataframe to an XlsxWriter Excel object.
+                    df.to_excel(writer, sheet_name=sheetName)
+                    # Close the Pandas Excel writer and output the Excel file.
+                    writer.close()
+                    isSaved = True
+                except Exception as ex:  # pragma: no cover
+                    default_logger().debug(ex, exc_info=True)
+                    OutputControls().printOutput(
+                        colorText.FAIL
+                        + (
+                            "[+] Error saving file at %s"
+                            % filePath
+                        )
+                        + colorText.END
+                    )
+                    filePath = os.path.join(tempfile.gettempdir(), filename)
+                    # Create a Pandas Excel writer using XlsxWriter as the engine.
+                    writer = pd.ExcelWriter(filePath, engine='xlsxwriter') # openpyxl throws an error exporting % sign.
+                    # Convert the dataframe to an XlsxWriter Excel object.
+                    df.to_excel(writer, sheet_name=sheetName)
+                    # Close the Pandas Excel writer and output the Excel file.
+                    writer.close()
+                    isSaved = True
+            OutputControls().printOutput(
+                colorText.BOLD
+                + (colorText.GREEN if isSaved else colorText.FAIL)
+                + (("[+] Results saved to %s" % filePath) if isSaved else "[+] Failed saving results into Excel file!")
+                + colorText.END
+            )
+            return filePath
+        return None
+
+    # Save screened results to excel
+    def promptFileExists(cache_file="stock_data_*.pkl", defaultAnswer=None):
+        try:
+            if defaultAnswer is None:
+                response = str(
+                    input(
+                        colorText.BOLD
+                        + colorText.WARN
+                        + "[>] "
+                        + cache_file
+                        + " already exists. Do you want to replace this? [Y/N] (Default: Y): "
+                ) or "Y").upper()
+            else:
+                response = defaultAnswer
+        except ValueError as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            pass
+        return "Y" if response != "N" else "N"
+
+    # Prompt for asking RSI
+    def promptRSIValues():
+        tools.clearScreen(forceTop=True)
+        try:
+            minRSI, maxRSI = int(
+                input(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + "\n[+] Enter Min RSI value (Default=55): "
+                    + colorText.END
+                ) or 55
+            ), int(
+                input(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + "[+] Enter Max RSI value (Default=68): "
+                    + colorText.END
+                ) or "68"
+            )
+            if (
+                (minRSI >= 0 and minRSI <= 100)
+                and (maxRSI >= 0 and maxRSI <= 100)
+                and (minRSI <= maxRSI)
+            ):
+                return (minRSI, maxRSI)
+            raise ValueError
+        except ValueError as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            return (0, 0)
+
+    # Prompt for asking CCI
+    def promptCCIValues(minCCI=None, maxCCI=None):
+        tools.clearScreen(forceTop=True)
+        if minCCI is not None and maxCCI is not None:
+            return minCCI, maxCCI
+        try:
+            minCCI, maxCCI = int(
+                input(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + "\n[+] Enter Min CCI value (Default=110): "
+                    + colorText.END
+                ) or "110"
+            ), int(
+                input(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + "[+] Enter Max CCI value (Default=300): "
+                    + colorText.END
+                ) or "300"
+            )
+            if minCCI <= maxCCI:
+                return (minCCI, maxCCI)
+            raise ValueError
+        except ValueError as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            return (-100, 100)
+
+    # Prompt for asking Volume ratio
+    def promptVolumeMultiplier(volumeRatio=None):
+        tools.clearScreen(forceTop=True)
+        if volumeRatio is not None:
+            return volumeRatio
+        try:
+            volumeRatio = float(
+                input(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + "\n[+] Enter Min Volume ratio value (Default = 2.5): "
+                    + colorText.END
+                ) or "2.5"
+            )
+            if volumeRatio > 0:
+                return volumeRatio
+            raise ValueError
+        except ValueError as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            return 2
+
+    def promptMenus(menu):
+        tools.clearScreen(forceTop=True)
+        m = menus()
+        m.level = menu.level if menu is not None else 0
+        return m.renderForMenu(menu)
+
+    def promptChartPatternSubMenu(menu,respChartPattern):
+        tools.clearScreen(forceTop=True)
+        m3 = menus()
+        m3.renderForMenu(menu,asList=True)
+        lMenu =  m3.find(str(respChartPattern))
+        maLength = tools.promptSubMenuOptions(lMenu)
+        return maLength
+    
+    # Prompt for submenu options
+    def promptSubMenuOptions(menu=None):
+        try:
+            tools.promptMenus(menu=menu)
+            resp = int(
+                input(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + """[+] Select Option:"""
+                    + colorText.END
+                ) or "1"
+            )
+            if resp >= 0 and resp <= 10:
+                return resp
+            raise ValueError
+        except ValueError as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            input(
+                colorText.BOLD
+                + colorText.FAIL
+                + "\n[+] Invalid Option Selected. Press <Enter> to try again..."
+                + colorText.END
+            )
+            return None
+
+    # Prompt for Reversal screening
+    def promptReversalScreening(menu=None):
+        try:
+            tools.promptMenus(menu=menu)
+            resp = int(
+                input(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + """[+] Select Option:"""
+                    + colorText.END
+                ) or "3"
+            )
+            if resp >= 0 and resp <= 10:
+                if resp == 4:
+                    try:
+                        defaultMALength = 9 if configManager.duration.endswith("m") else 50
+                        maLength = int(
+                            input(
+                                colorText.BOLD
+                                + colorText.WARN
+                                + f"\n[+] Enter MA Length (E.g. 9,10,20,50 or 200) (Default={defaultMALength}): "
+                                + colorText.END
+                            ) or str(defaultMALength)
+                        )
+                        return resp, maLength
+                    except ValueError as e:  # pragma: no cover
+                        default_logger().debug(e, exc_info=True)
+                        OutputControls().printOutput(
+                            colorText.BOLD
+                            + colorText.FAIL
+                            + "\n[!] Invalid Input! MA Length should be single integer value!\n"
+                            + colorText.END
+                        )
+                        raise ValueError
+                elif resp == 6:
+                    try:
+                        maLength = int(
+                            input(
+                                colorText.BOLD
+                                + colorText.WARN
+                                + "\n[+] Enter NR timeframe [Integer Number] (E.g. 4, 7, etc.) (Default=4): "
+                                + colorText.END
+                            ) or "4"
+                        )
+                        return resp, maLength
+                    except ValueError as e:  # pragma: no cover
+                        default_logger().debug(e, exc_info=True)
+                        OutputControls().printOutput(
+                            colorText.BOLD
+                            + colorText.FAIL
+                            + "\n[!] Invalid Input! NR timeframe should be single integer value!\n"
+                            + colorText.END
+                        )
+                        raise ValueError
+                elif resp in [7,10]:
+                    m3 = menus()
+                    m3.renderForMenu(menu,asList=True)
+                    lMenu =  m3.find(str(resp))
+                    return resp, tools.promptSubMenuOptions(lMenu)
+                return resp, None
+            raise ValueError
+        except ValueError as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            input(
+                colorText.BOLD
+                + colorText.FAIL
+                + "\n[+] Invalid Option Selected. Press <Enter> to try again..."
+                + colorText.END
+            )
+            return None, None
+
+    # Prompt for Reversal screening
+    def promptChartPatterns(menu=None):
+        try:
+            tools.promptMenus(menu=menu)
+            resp = int(
+                input(
+                    colorText.BOLD
+                    + colorText.WARN
+                    + """[+] Select Option:"""
+                    + colorText.END
+                ) or "3"
+            )
+            if resp == 1 or resp == 2:
+                candles = int(
+                    input(
+                        colorText.BOLD
+                        + colorText.WARN
+                        + "\n[+] How many candles (TimeFrame) to look back Inside Bar formation? (Default=3): "
+                        + colorText.END
+                    ) or "3"
+                )
+                return (resp, candles)
+            if resp == 3:
+                percent = float(
+                    input(
+                        colorText.BOLD
+                        + colorText.WARN
+                        + "\n[+] Enter Percentage within which all MA/EMAs should be (Ideal: 1-2%)? (Default=2): "
+                        + colorText.END
+                    ) or "2"
+                )
+                return (resp, percent / 100.0)
+            if resp >= 0 and resp <= 7:
+                return resp, 0
+            raise ValueError
+        except ValueError as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            input(
+                colorText.BOLD
+                + colorText.FAIL
+                + "\n[+] Invalid Option Selected. Press <Enter> to try again..."
+                + colorText.END
+            )
+            return (None, None)
+
+    def getProgressbarStyle():
+        bar = "smooth"
+        spinner = "waves"
+        if "Windows" in platform.platform():
+            bar = "classic2"
+            spinner = "dots_recur"
+        return bar, spinner
+
+    def getNiftyModel(retrial=False):
+        files = [
+            os.path.join(Archiver.get_user_outputs_dir(), "nifty_model_v2.h5"),
+            os.path.join(Archiver.get_user_outputs_dir(), "nifty_model_v2.pkl"),
+        ]
+        model = None
+        pkl = None
+        urls = [
+            "https://raw.githubusercontent.com/pkjmesra/PKScreener/main/pkscreener/ml/nifty_model_v2.h5",
+            "https://raw.githubusercontent.com/pkjmesra/PKScreener/main/pkscreener/ml/nifty_model_v2.pkl",
+        ]
+        if os.path.isfile(files[0]) and os.path.isfile(files[1]):
+            file_age = (time.time() - os.path.getmtime(files[0])) / 604800
+            if file_age > 1:
+                download = True
+                os.remove(files[0])
+                os.remove(files[1])
+            else:
+                download = False
+        else:
+            download = True
+        if download:
+            for file_url in urls:
+                resp = fetcher.fetchURL(file_url, stream=True)
+                if resp is not None and resp.status_code == 200:
+                    OutputControls().printOutput(
+                        colorText.BOLD
+                        + colorText.GREEN
+                        + "[+] Downloading AI model (v2) for Nifty predictions, Please Wait.."
+                        + colorText.END
+                    )
+                    try:
+                        chunksize = 1024 * 1024 * 1
+                        filesize = int(
+                            int(resp.headers.get("content-length")) / chunksize
+                        )
+                        filesize = 1 if not filesize else filesize
+                        bar, spinner = tools.getProgressbarStyle()
+                        f = open(
+                            os.path.join(
+                                Archiver.get_user_outputs_dir(), file_url.split("/")[-1]
+                            ),
+                            "wb",
+                        )
+                        dl = 0
+                        with alive_bar(
+                            filesize, bar=bar, spinner=spinner, manual=True
+                        ) as progressbar:
+                            for data in resp.iter_content(chunk_size=chunksize):
+                                dl += 1
+                                f.write(data)
+                                progressbar(dl / filesize)
+                                if dl >= filesize:
+                                    progressbar(1.0)
+                        f.close()
+                    except Exception as e:  # pragma: no cover
+                        default_logger().debug(e, exc_info=True)
+                        OutputControls().printOutput("[!] Download Error - " + str(e))
+            time.sleep(3)
+        try:
+            if os.path.isfile(files[0]) and os.path.isfile(files[1]):
+                pkl = joblib.load(files[1])
+                if Imports["keras"]:
+                    try:
+                        import keras
+                    except:
+                        OutputControls().printOutput("This installation might not work well, especially for NIFTY prediction. Please install 'keras' library on your machine!")
+                        OutputControls().printOutput(
+                                colorText.BOLD
+                                + colorText.FAIL
+                                + "[+] 'Keras' library is not installed. You may wish to follow instructions from\n[+] https://github.com/pkjmesra/PKScreener/"
+                                + colorText.END
+                            )
+                        pass
+                model = keras.models.load_model(files[0]) if Imports["keras"] else None
+        except Exception as e:  # pragma: no cover
+            default_logger().debug(e, exc_info=True)
+            os.remove(files[0])
+            os.remove(files[1])
+            if not retrial:
+                tools.getNiftyModel(retrial=True)
+        if model is None:
+            OutputControls().printOutput(
+                colorText.BOLD
+                + colorText.FAIL
+                + "[+] 'Keras' library is not installed. Prediction failed! You may wish to follow instructions from\n[+] https://github.com/pkjmesra/PKScreener/"
+                + colorText.END
+            )
+        return model, pkl
+
+    def getSigmoidConfidence(x):
+        out_min, out_max = 0, 100
+        if x > 0.5:
+            in_min = 0.50001
+            in_max = 1
+        else:
+            in_min = 0
+            in_max = 0.5
+        return round(
+            ((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min), 3
+        )
+
+    def alertSound(beeps=3, delay=0.2):
+        for i in range(beeps):
+            OutputControls().printOutput("\a")
+            sleep(delay)
+    
+    def getMaxColumnWidths(df):
+        columnWidths = [None]
+        addnlColumnWidths = [40 if (x in ["Trend(22Prds)"] or "-Pd" in x) else (20 if (x in ["Pattern"]) else None) for x in df.columns]
+        columnWidths.extend(addnlColumnWidths)
+        columnWidths = columnWidths[:-1]
         return columnWidths
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/WorkflowManager.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/WorkflowManager.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,95 +1,95 @@
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-import os
-from PKDevTools.classes.Telegram import get_secrets
-from PKDevTools.classes.OutputControls import OutputControls
-
-import pkscreener.classes.ConfigManager as ConfigManager
-from pkscreener.classes.Fetcher import screenerStockDataFetcher
-
-configManager = ConfigManager.tools()
-
-
-def run_workflow(command, user, options, workflowType="B"):
-    owner = os.popen('git ls-remote --get-url origin | cut -d/ -f4').read().replace("\n","")
-    repo = os.popen('git ls-remote --get-url origin | cut -d/ -f5').read().replace(".git","").replace("\n","")
-    branch = "main"
-    if workflowType == "B":
-        workflow_name = "w13-workflow-backtest_generic.yml"
-        options = f'{options.replace("B:","")}:D:D:D:D:D'.replace("::",":")
-        data = (
-            '{"ref":"'
-            + branch
-            + '","inputs":{"user":"'
-            + f"{user}"
-            + '","params":"'
-            + f"{options}"
-            + '","name":"'
-            + f"{command}"
-            + '"}}'
-        )
-    elif workflowType == "X" or workflowType == "G":
-        workflow_name = "w8-workflow-alert-scan_generic.yml"
-        if user is None or len(user) == 0:
-            user = ""
-            data = (
-                '{"ref":"'
-                + branch
-                + '","inputs":{"user":"'
-                + f"{user}"
-                + '","params":"'
-                + f'-a Y -e -p -o {options.replace("_",":")}:D:D:D:D:D'.replace("::",":")
-                + '","ref":"main"}}'
-            )
-        else:
-            data = (
-                '{"ref":"'
-                + branch
-                + '","inputs":{"user":"'
-                + f"{user}"
-                + '","params":"'
-                + f'-a Y -e -p -u {user} -o {options.replace("_",":")}:D:D:D:D:D'.replace("::",":")
-                + '","ref":"main"}}'
-            )
-
-    _, _, _, ghp_token = get_secrets()
-    url = f"https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_name}/dispatches"
-
-    headers = {
-        "Accept": "application/vnd.github+json",
-        "Authorization": f"Bearer {ghp_token}",
-        "Content-Type": "application/json",
-    }
-
-    fetcher = screenerStockDataFetcher(configManager)
-    resp = fetcher.postURL(url, data=data, headers=headers)
-    if resp.status_code == 204:
-        OutputControls().printOutput(f"Workflow {workflow_name} Triggered!")
-    else:
-        OutputControls().printOutput(f"Something went wrong while triggering {workflow_name}")
-    return resp
-
-
-# resp = run_workflow("B_12_1","-1001785195297","B:12:1")
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+import os
+from PKDevTools.classes.Telegram import get_secrets
+from PKDevTools.classes.OutputControls import OutputControls
+
+import pkscreener.classes.ConfigManager as ConfigManager
+from pkscreener.classes.Fetcher import screenerStockDataFetcher
+
+configManager = ConfigManager.tools()
+
+
+def run_workflow(command, user, options, workflowType="B"):
+    owner = os.popen('git ls-remote --get-url origin | cut -d/ -f4').read().replace("\n","")
+    repo = os.popen('git ls-remote --get-url origin | cut -d/ -f5').read().replace(".git","").replace("\n","")
+    branch = "main"
+    if workflowType == "B":
+        workflow_name = "w13-workflow-backtest_generic.yml"
+        options = f'{options.replace("B:","")}:D:D:D:D:D'.replace("::",":")
+        data = (
+            '{"ref":"'
+            + branch
+            + '","inputs":{"user":"'
+            + f"{user}"
+            + '","params":"'
+            + f"{options}"
+            + '","name":"'
+            + f"{command}"
+            + '"}}'
+        )
+    elif workflowType == "X" or workflowType == "G":
+        workflow_name = "w8-workflow-alert-scan_generic.yml"
+        if user is None or len(user) == 0:
+            user = ""
+            data = (
+                '{"ref":"'
+                + branch
+                + '","inputs":{"user":"'
+                + f"{user}"
+                + '","params":"'
+                + f'-a Y -e -p -o {options.replace("_",":")}:D:D:D:D:D'.replace("::",":")
+                + '","ref":"main"}}'
+            )
+        else:
+            data = (
+                '{"ref":"'
+                + branch
+                + '","inputs":{"user":"'
+                + f"{user}"
+                + '","params":"'
+                + f'-a Y -e -p -u {user} -o {options.replace("_",":")}:D:D:D:D:D'.replace("::",":")
+                + '","ref":"main"}}'
+            )
+
+    _, _, _, ghp_token = get_secrets()
+    url = f"https://api.github.com/repos/{owner}/{repo}/actions/workflows/{workflow_name}/dispatches"
+
+    headers = {
+        "Accept": "application/vnd.github+json",
+        "Authorization": f"Bearer {ghp_token}",
+        "Content-Type": "application/json",
+    }
+
+    fetcher = screenerStockDataFetcher(configManager)
+    resp = fetcher.postURL(url, data=data, headers=headers)
+    if resp.status_code == 204:
+        OutputControls().printOutput(f"Workflow {workflow_name} Triggered!")
+    else:
+        OutputControls().printOutput(f"Something went wrong while triggering {workflow_name}")
+    return resp
+
+
+# resp = run_workflow("B_12_1","-1001785195297","B:12:1")
```

## Comparing `pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/keys.py` & `pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/keys.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,141 +1,141 @@
-#!/usr/bin/env python3
-"""
-    The MIT License (MIT)
-
-    Copyright (c) 2023 pkjmesra
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in all
-    copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-    SOFTWARE.
-
-"""
-# SOURCE: https://docs.python.org/2/library/curses.html
-# SOURCE: https://docs.python.org/3/howto/curses.html
-
-# For Windows: pip install windows-curses
-import curses
-window = curses.initscr() # Initialize the library. Returns a WindowObject which represents the whole screen.
-window.keypad(True) # Escape sequences generated by some keys (keypad, function keys) will be interpreted by curses.
-curses.cbreak() # Keys are read one by one. Also safer than curses.raw() because you can interrupt a running script with SIGINT (Ctrl + C).
-curses.noecho() # Prevent getch() keys from being visible when pressed. Echoing of input characters is turned off.
-
-# Initialize colors.
-curses.start_color() # Must be called if you want to use colors.
-curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
-curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLACK)
-curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)
-curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK)
-curses.init_pair(5, curses.COLOR_YELLOW, curses.COLOR_BLACK)
-curses.init_pair(6, curses.COLOR_BLUE, curses.COLOR_BLACK)
-curses.init_pair(7, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
-curses.init_pair(8, curses.COLOR_CYAN, curses.COLOR_BLACK)
-black = curses.color_pair(1)
-white = curses.color_pair(2)
-red = curses.color_pair(3)
-green = curses.color_pair(4)
-yellow = curses.color_pair(5)
-blue = curses.color_pair(6)
-magenta = curses.color_pair(7)
-cyan = curses.color_pair(8)
-
-# -----
-
-def draw_menu(menuItems, selectedIndex):
-    #  window.erase()
-    window.clear()
-
-    # Print a vertical menu.
-    line = 1
-    for i in range(len(menuItems)):
-        window.addstr(' ')
-        newLines = ""
-        menu = menuItems[i]
-        menuText = menu.keyTextLabel()
-        if line != menu.line:
-          window.addstr('\n')
-          line += 1
-        window.addstr(f"{menuText}\n", black if i == selectedIndex else white)
-        #   line += 1
-        line += 1
-
-    # # Print a dividing line.
-    # window.addstr(('-' * 80) + '\n')
-
-    # # Print a horizontal menu.
-    # for i in range(len(menuItems)):
-    #     window.addstr(' ')
-    #     window.addstr(menuItems[i], black if i == selectedIndex else white)
-
-    # window.addstr('\n')
-
-# -----
-
-def process_input(menuItems, selectedIndex):
-    userInput = window.getch()
-
-    if userInput == curses.KEY_LEFT or userInput == curses.KEY_UP:
-        # Loop around backwards.
-        selectedIndex = (selectedIndex - 1 + len(menuItems)) % len(menuItems)
-
-    elif userInput == curses.KEY_RIGHT or userInput == curses.KEY_DOWN:
-        # Loop around forwards.
-        selectedIndex = (selectedIndex + 1) % len(menuItems)
-
-    # If curses.nonl() is called, Enter key = \r else \n.
-    elif userInput == curses.KEY_ENTER or chr(userInput) in '\r\n':
-        # If the last option, exit, is selected.
-        if selectedIndex == len(menuItems) - 1:
-            wait_for_any_keypress()
-            curses.endwin() # De-initialize the library, and return terminal to normal status.    <-- Works without this on Windows, however in Linux you can't type in the terminal after exiting without this :P
-            exit(0)
-
-        window.addstr('\n Selected index: {}\n'.format(selectedIndex))
-        # wait_for_any_keypress()
-
-    else:
-        window.addstr("\n The pressed key '{}' {} is not associated with a menu function.\n".format(chr(userInput), userInput))
-        # wait_for_any_keypress()
-
-    return selectedIndex
-
-# -----
-
-def wait_for_any_keypress():
-    window.addstr('\n Press any key to continue . . . ')
-    window.getch()
-
-# -----
-
-def main():
-    selectedIndex = 0
-    while True:
-        draw_menu(MENU_ITEMS, selectedIndex)
-        selectedIndex = process_input(MENU_ITEMS, selectedIndex)
-
-from pkscreener.classes.MenuOptions import menus
-m = menus()
-
-MENU_ITEMS = m.renderForMenu(asList=True)
-#[
-#     ' Option 1 ',
-#     ' Option 2 ',
-#     ' Option 3 ',
-#     ' Exit ',
-# ]
-
-if __name__ == '__main__':
+#!/usr/bin/env python3
+"""
+    The MIT License (MIT)
+
+    Copyright (c) 2023 pkjmesra
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+
+"""
+# SOURCE: https://docs.python.org/2/library/curses.html
+# SOURCE: https://docs.python.org/3/howto/curses.html
+
+# For Windows: pip install windows-curses
+import curses
+window = curses.initscr() # Initialize the library. Returns a WindowObject which represents the whole screen.
+window.keypad(True) # Escape sequences generated by some keys (keypad, function keys) will be interpreted by curses.
+curses.cbreak() # Keys are read one by one. Also safer than curses.raw() because you can interrupt a running script with SIGINT (Ctrl + C).
+curses.noecho() # Prevent getch() keys from being visible when pressed. Echoing of input characters is turned off.
+
+# Initialize colors.
+curses.start_color() # Must be called if you want to use colors.
+curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
+curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLACK)
+curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)
+curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK)
+curses.init_pair(5, curses.COLOR_YELLOW, curses.COLOR_BLACK)
+curses.init_pair(6, curses.COLOR_BLUE, curses.COLOR_BLACK)
+curses.init_pair(7, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
+curses.init_pair(8, curses.COLOR_CYAN, curses.COLOR_BLACK)
+black = curses.color_pair(1)
+white = curses.color_pair(2)
+red = curses.color_pair(3)
+green = curses.color_pair(4)
+yellow = curses.color_pair(5)
+blue = curses.color_pair(6)
+magenta = curses.color_pair(7)
+cyan = curses.color_pair(8)
+
+# -----
+
+def draw_menu(menuItems, selectedIndex):
+    #  window.erase()
+    window.clear()
+
+    # Print a vertical menu.
+    line = 1
+    for i in range(len(menuItems)):
+        window.addstr(' ')
+        newLines = ""
+        menu = menuItems[i]
+        menuText = menu.keyTextLabel()
+        if line != menu.line:
+          window.addstr('\n')
+          line += 1
+        window.addstr(f"{menuText}\n", black if i == selectedIndex else white)
+        #   line += 1
+        line += 1
+
+    # # Print a dividing line.
+    # window.addstr(('-' * 80) + '\n')
+
+    # # Print a horizontal menu.
+    # for i in range(len(menuItems)):
+    #     window.addstr(' ')
+    #     window.addstr(menuItems[i], black if i == selectedIndex else white)
+
+    # window.addstr('\n')
+
+# -----
+
+def process_input(menuItems, selectedIndex):
+    userInput = window.getch()
+
+    if userInput == curses.KEY_LEFT or userInput == curses.KEY_UP:
+        # Loop around backwards.
+        selectedIndex = (selectedIndex - 1 + len(menuItems)) % len(menuItems)
+
+    elif userInput == curses.KEY_RIGHT or userInput == curses.KEY_DOWN:
+        # Loop around forwards.
+        selectedIndex = (selectedIndex + 1) % len(menuItems)
+
+    # If curses.nonl() is called, Enter key = \r else \n.
+    elif userInput == curses.KEY_ENTER or chr(userInput) in '\r\n':
+        # If the last option, exit, is selected.
+        if selectedIndex == len(menuItems) - 1:
+            wait_for_any_keypress()
+            curses.endwin() # De-initialize the library, and return terminal to normal status.    <-- Works without this on Windows, however in Linux you can't type in the terminal after exiting without this :P
+            exit(0)
+
+        window.addstr('\n Selected index: {}\n'.format(selectedIndex))
+        # wait_for_any_keypress()
+
+    else:
+        window.addstr("\n The pressed key '{}' {} is not associated with a menu function.\n".format(chr(userInput), userInput))
+        # wait_for_any_keypress()
+
+    return selectedIndex
+
+# -----
+
+def wait_for_any_keypress():
+    window.addstr('\n Press any key to continue . . . ')
+    window.getch()
+
+# -----
+
+def main():
+    selectedIndex = 0
+    while True:
+        draw_menu(MENU_ITEMS, selectedIndex)
+        selectedIndex = process_input(MENU_ITEMS, selectedIndex)
+
+from pkscreener.classes.MenuOptions import menus
+m = menus()
+
+MENU_ITEMS = m.renderForMenu(asList=True)
+#[
+#     ' Option 1 ',
+#     ' Option 2 ',
+#     ' Option 3 ',
+#     ' Exit ',
+# ]
+
+if __name__ == '__main__':
     main()
```

## Comparing `pkscreener-0.45.20240525.408.dist-info/LICENSE` & `pkscreener-0.45.20240525.409.dist-info/LICENSE-Others`

 * *Files 20% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-MIT License
-
-Copyright (c) 2023 pkjmesra
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
+MIT License
+
+Copyright (c) 2021 Pranjal Joshi
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
```

## Comparing `pkscreener-0.45.20240525.408.dist-info/METADATA` & `pkscreener-0.45.20240525.409.dist-info/METADATA`

 * *Files 14% similar despite different names*

```diff
@@ -1,328 +1,356 @@
-Metadata-Version: 2.1
-Name: pkscreener
-Version: 0.45.20240525.408
-Summary: A Python-based stock screener for NSE, India with alerts to Telegram Channel (pkscreener)
-Home-page: https://github.com/pkjmesra/pkscreener
-Download-URL: https://github.com/pkjmesra/pkscreener/archive/v0.45.20240525.408.zip
-Author: pkjmesra
-Author-email: pkjmesra@gmail.com
-License: OSI Approved (MIT)
-Keywords: NSE,Technical Indicators,Scanning,Stock Scanners
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Operating System :: Microsoft :: Windows
-Classifier: Operating System :: MacOS
-Classifier: Operating System :: POSIX :: Linux
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Description-Content-Type: text/markdown
-License-File: LICENSE
-License-File: LICENSE-Others
-
-![Title](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/title.png)
-
-# PKScreener
-
-[![MADE-IN-INDIA][MADE-IN-INDIA-badge]][MADE-IN-INDIA] [![Windows][Windows-badge]][Windows] [![Linux][Linux-badge]][Linux] [![Mac OS][Mac OS-badge]][Mac OS] [![GitHub release (latest by date)][GitHub release (latest by date)-badge]][GitHub release (latest by date)] [![CodeFactor][Codefactor-badge]][Codefactor] [![Downloads][Downloads-badge]][Downloads] ![latest download][Latest-Downloads-badge] ![github license][github-license] [![PyPI][pypi-badge]][pypi] [![is wheel][wheel-badge]][pypi] [![Coverage Status][Coverage-Status-badge]][Coverage-Status] [![codecov][codecov-badge]][codecov] [![Docker Status][Docker Status-badge]][Docker Status]
-[![Docker Pulls][Docker Pulls-badge]][Docker Status] 
-
-## What is PKScreener?
-| Telegram Alerts | Nifty AI Prediction | Scheduling Cron Jobs | On-Demand Telegram Bot | Backtesting / Growth of 10k|
-| :-------------: | :-----------------: | :------------------: | :--------------------: | ----------- |
-
-| Nifty screening | Volume scanners | Breakout detection | Consolidating stocks | Reversal Signals |
-| :-------------: | :-------------: | :----------------: | :------------------: | ---------------- |
-
-| Chart Patterns | CCI scanners | 2% scanners | Short-term bulls | NR4 / NR7 | Weekly Releases |
-| :------------: | :----------: | :---------: | :--------------: | :-------: | --------------- |
-
-| Fair Value | Mutual funds, FII data | TTM Squeeze | Golden Crossover | Death Crossover|
-| :-----------: | :-----------: | :--------: | :--------------: | ------------------- |
-
-| RSI screening | MACD scanners | IPO Stocks | Momentum Gainers | Watchlist screening |
-| :-----------: | :-----------: | :--------: | :--------------: | ------------------- |
-
-| Stock Performance | 52Wk H/L Breakouts | 10 days low breakouts | Aroon Crossover | Next Day Bullish Stocks|
-| :-----------: | :-----------: | :--------: | :--------------: | ------------------- |
-
-| Today's Breakouts | Breaking out now | Popular stocks by Mutual Funds / FIIs | Higher Highs | Lower Lows|
-| :-----------: | :-----------: | :--------: | :--------------: | ------------------- |
-
-| F&O Stocks screening | Live 5-EMA Index Scan | Logging | Telegram Channel | Early Breakouts |
-| :------------------: | :-------------------: | :-----: | :--------------: | --------------- |
-### A Python-based stock screener for NSE, India.
-
-**pkscreener** is an advanced stock screener to find potential breakout stocks from NSE and tell it's possible breakout values. It also helps to find the stocks which are consolidating and may breakout, or the particular chart patterns that you're looking specifically to make your decisions.
-pkscreener is totally customizable and it can screen stocks with the settings that you have provided.
-
-You can get daily scan results/alerts at scheduled times by subscribing to the following Telegram channel:
-|    Purpose     |                                                                                                                   Description/link                                                                                                                    | QR Code                                                                                                                                          |                                                                                                                                            |     |
-| :------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | ------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------ | --- |
-| Alerts Channel | https://t.me/PKScreener > You wil receive all the major alerts on this telegram channel. These alerts are sent for all major strategy scans daily around 9:30am-10:15am and then around 4pm. You will also receive the next day's market predictions. | <img src="https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/Telegram_Channel_Prod.jpg" alt="Telegram Channel" width="100"/> |                                                                                                                                            |     |
-|      |
-
-![telegram](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/telegram.png)
-
-## Receiving Scheduled Scan results
-If you would like to receive the scan results, please join the telegram channel and group above. 
-You may receive the following scan results:
-1. [![1. Next day Nifty/Market AI prediction](https://github.com/pkjmesra/PKScreener/actions/workflows/w4-workflow-prod-scans_1.yml/badge.svg)](https://github.com/pkjmesra/PKScreener/actions/workflows/w4-workflow-prod-scans_1.yml) by 4pm IST, Monday - Friday
-2. For all Nifty stocks at/by 9:45-10:15am and by 4pm IST, Monday - Friday
-
-   * Certain selected but configurable alerts for specific scan types
-
-## Receiving On-Demand Scan results
-You can now run the `pkscreenerbot` on your local machine or if it's running on the GitHub server under a GitHub Actions workflow, you can use the `pkscreener Bot`(@nse_pkscreener_bot on Telegram) to get on-demand scan results.
-
-![bot](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/bot.gif)
-
-## Scanners
-
-Screening options to choose from:
-* Artificial Intelligence v2 for Nifty 50 Prediction
-* Live Index Scan : 5 EMA for Intraday
-* Screen stocks by the stock names (NSE Stock Code)
-* Nifty 50
-* Nifty Next 50
-* Nifty 100
-* Nifty 200
-* Nifty 500
-* Nifty Smallcap 50
-* Nifty Smallcap 100
-* Nifty Smallcap 250
-* Nifty Midcap 50
-* Nifty Midcap 100
-* Nifty Midcap 150
-* Nifty (All Stocks)
-* Newly Listed (IPOs in last 2 Year)
-* F&O Stocks Only
-* NASDAQ
-
-Followin scanners are already implemented. Others are `In Progress`
-```
-0 > Full Screening (Shows Technical Parameters without any criterion)
-     1 > Probable Breakouts              	2 > Today's Breakouts
-     3 > Consolidating stocks            	4 > Lowest Volume in last 'N'-days (Early Breakout Detection)
-     5 > RSI screening                   	6 > Reversal Signals
-     7 > Stocks making Chart Patterns    	8 > CCI outside of the given range
-     9 > Volume gainers                  	10 > Closing at least 2% up since last 3 days
-    11 > Short term bullish stocks(Intraday)	12 > 15 Minute Price & Volume breakout(Intraday)
-    13 > Bullish RSI & MACD(Intraday)       	14 > NR4 Daily Today
-    15 > 52 week low breakout(today/1 wk)	16 > 10 days low breakout
-    17 > 52 week high breakout(today/1 wk)	18 > Bullish Aroon(14) Crossover
-    19 > MACD Histogram x below 0       	20 > Bullish for next day
-    21 > Most Popular Stocks            	22 > View Stock Performance         
-    23 > Breaking out now               	24 > Higher Highs,Lows & Close      
-    25 > Lower Highs,Lows (Watch for Reversal)            	
-```
-## Running Piped Scanners
-
-https://github.com/pkjmesra/PKScreener/assets/1358101/9e579371-1035-400a-9f65-139d8407f6c7
-
-
-## How to use on your own local Windows/Linux/Macbook laptop?
-
-# Using docker, running within docker container
-* Download and install docker desktop: https://docs.docker.com/get-docker/
-* After installation, launch/run docker desktop and if it asks, login using your docker credentials.
-* Launch any command line (for example, cmd on windows or terminal on Mac) and type `docker pull pkjmesra/pkscreener:latest`. Then type `docker run -it pkjmesra/pkscreener:latest`.  
-The option `-i` will open the `pkscreener` in interactive mode within docker. `-t` will allocate a pseudo terminal for you so you can begin to use `pkscreener`
-
-# Installing the latest version from PyPi.
-* Go ahead and install using `pip install pkscreener`
-* This should install all of the major dependencies, except maybe, TA-Lib.
-* This app can still run without TA-Lib, but if you need to install TA-Lib for technical indicators (which otherwise is used from `pandas_ta` in the absence of TA-Lib), you can do this: Head to `.github/dependencies/` under this repo. Download the respective TA-Lib file/whl file and install either from the .whl file or from source. Check out any of the workflow files for steps to install TA-Lib.
-
-For example:
-
-For `Windows`: See https://github.com/pkjmesra/PKScreener/blob/c1e94ba3137915cb781161fa2d5fb69129940fd3/.github/workflows/w1-workflow-build-matrix.yml#L91-L101 
-
-For `Mac`: Run `brew install ta-lib` assuming you have homebrew installed.
-
-For `Ubuntu/Linux`: See https://github.com/pkjmesra/PKScreener/blob/main/.github/workflows/w1-workflow-build-matrix.yml#L121-L132
-
-* Now launch your favorite command line CLI and issue `pkscreener`. This will launch the pkscreener executable.
-
-# Building from source repo
-* Install python 3.9 for your OS/CPU. Download the installer from https://www.python.org/downloads/release/python-3913/#Files
-* Just clone the repo with `git clone https://github.com/pkjmesra/PKScreener.git`
-* `cd PKScreener`
-* `pip install -r requirements.txt` .
-* (Optional) If you would like to have technical indicators evaluated using TA-Lib, go ahead and install TA-Lib as well. `pip3 install ta-lib`. Please review additional steps to buil TA-Lib in the workflow files meant for your OS under .github > workflows and follow the line numbers from the previous section.
-* `cd pkscreener`
-* Finally, from within the `pkscreener` directory, run `python pkscreenercli.py`. Or just type/run `pkscreener`. You are all set.
-
-# Running the executables
-* Download the suitable file according to your OS.
-* Linux & Mac users should make sure that the `pkscreenercli.bin or pkscreenercli.run` is having `execute` permission. (`chmod +x pkscreenercli.run`)
-
-* **Run** the file. Following window will appear.
-
-
-* **Configure** the parameters as per your requirement using `Option > E`.
-
-![config](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/config.png)
-
-* **Scanner Menus** the scanner menus for each level/sub-level
-  ![menulevel1](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/menu.png)
-  ![menulevel2](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/menu_level2.png)
-  ![menulevel3](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/menu_level3.png)
-
-
-* Following are the screenshots of screening and output results.
-
-![screening](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/screening.png)
-
-Results :
-
-![results](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/results.png)
-
-It also shows you how the chosen scan option has fared in the past. 1-Pd, 2-Pd means 1 day, 2 days from the date of scan in the past when those stocks came into the results of the chosen scan option.
-
-![results](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/result_analysis.png)
-* Once done, you can also save the results in an excel file.
-
-## Growth of 10k
-
-You can see the performance of your stocks and/or at portfolio level using "Growth of 10k".
-
-![G10k](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/G10k.png)
-
-It also summarises the Growth of 10k at portfolio level for the last quarter so that you know which filters worked best in the past:
-
-![G10k_Sum](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/G10k_Sum.png)
-
-## Backtests
-You can now use the *Backtests* menu to backtest any of the selected strategies. See https://pkjmesra.github.io/PKScreener/BacktestReports.html
-
-![backtest](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/backtest.png)
-
-* Once done, you can also view the output html file saved at the same location from where you launched the app.
-
-## Scanning as a scheduled job once or at regular intervals
-* Running it once with pre-defined inputs
-  You can also run it as a one time job in any scheduler with pre-defined options. For example `./pkscreenercli.py -a Y -o X:12:10 -e` (or `pkscreenercli.exe -a Y -o X:12:10 -e` if you're executing with the exe) will run the scanner for all Nifty stocks and find all stocks matching CCI filter, save the results in xlsx file and exit. `./pkscreenercli.py -a Y -o X:12:9:2.5 -e` will run the scanner (menu option `X`) for all Nifty stocks (menu option `12`) to find volume gainers (menu option `9`) with at least the volume multiplier of 2.5 (input variable `2.5`), save the results in xlsx file and exit (menu option `-e`). Passing in the `-p` option for example `pkscreenercli.py -a Y -p -o X:12:6:1 -e` will also silence all command line prints/outputs and just run silently for the given options, save results and exit. Try and see all options with `./pkscreenercli.py -h`.
-
-* Running it at regular intervals
-  If you want to runn it at regular intervals, you can just pass the interval in `-c` command line option. For example, `./pkscreenercli.py -a Y -o X:12:6:1 -c 180` will run it every `180` seconds with console outputs also being printed. If you'd just like it to run as a cron job without console outputs, you may also pass the `-p` parameter. For example, `./pkscreenercli.py -a Y -p -o X:12:6:1 -c 180`
-
-## Understanding the Result Table:
-
-The Result table contains a lot of different parameters which can be pretty overwhelming to the new users, so here's the description and significance of each parameter.
-
-| Sr  |       Parameter       | Description                                                                                                                                                                                                                  | Example                                                                                  |
-| :-: | :-------------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
-|  1  |       **Stock**       | This is a NSE scrip symbol. If your OS/Terminal supports unicode, You can directly open **[TradingView](https://in.tradingview.com/)** charts by pressing `Ctrl+Click` on the stock name.                                    | [TATAMOTORS](https://in.tradingview.com/chart?symbol=NSE%3ATATAMOTORS)                   |
-|  2  |   **Consolidating**   | It gives the price range in which stock is trading since last `N` days. `N` is configurable and can be modified by executing `Edit User Configuration` option.                                                               | If stock is trading between price 100-120 in last 30 days, Output will be `Range:20.0 %` |
-|  3  | **Breakout (N Days)** | This is pure magic! The `BO` is Breakout level in last N days while `R` is the next resistance level if available. Investor should consider both BO & R level to decide entry/exits in their trades.                         | `B:302, R:313`(Breakout level is 100 & Next resistance is 102)                           |
-|  4  |        **LTP**        | LTP is the Last Traded Price of an asset traded on NSE.                                                                                                                                                                      | `298.7` (Stock is trading at this price)                                                 |
-|  5  |      **Volume**       | Volume shows the relative volume of the recent candle with respect to 20 period MA of Volume. It could be `Unknown` for newly listed stocks.                                                                                 | if 20MA(Volume) is 1M and todays Volume is 2.8M, then `Volume = 2.8x`                    |
-|  6  |     **MA-Signal**     | It describes the price trend of an asset by analysing various 50-200 MA/EMA crossover strategies.                                                                                                                            | `200MA-Support`,`BullCross-50MA` etc                                                     |
-|  7  |        **RSI**        | For the momentum traders, it describes 14-period RSI for quick decision making about their trading plans                                                                                                                     | `0 to 100`                                                                               |
-|  8  |       **Trend**       | By using advance algorithms, the average trendlines are computed for `N` days and their strenght is displayed depending on steepness of trendlines. (This does NOT show any trendline on chart, it is calculated internally) | `Strong Up`, `Weak Down` etc.                                                            |
-|  9  |      **Pattern**      | If the chart or the candle itself forming any important pattern in the recent timeframe or as per the selected screening option, various important patterns will be indicated here.                                          | `Momentum Gainer`, `Inside Bar (N)`,`Bullish Engulfing` etc.                             |
-
-## Hack it your way:
-Feel free to Edit the parameters in the `pkscreener.ini` file which will be generated by the application.
-```
-[config]
-period = 1y
-daystolookback = 22
-duration = 1d
-minprice = 20.0
-maxprice = 50000.0
-volumeratio = 2.5
-consolidationpercentage = 10.0
-shuffle = y
-cachestockdata = y
-onlystagetwostocks = y
-useema = n
-showunknowntrends = y
-logsenabled = n
-generaltimeout = 2.0
-longtimeout = 4.0
-maxnetworkretrycount = 10
-backtestperiod = 60
-minimumvolume = 10000
-```
-Try to tweak this parameters as per your trading styles. For example, If you're comfortable with weekly charts, make `duration=5d` and so on. For intraday, you can set `period=1d and duration=5m` if you would like to calculate with 5minute candles. Set the duration to `15m` or whatever value you desire, but keep the period to `1d`. This tool, however, works best for short/mid term instead of intraday, but some scans like momentum/volume/NR4 etc can be used for screening stocks for intraday as well. You can use the toggle menu option `T` to toggle between long term and intraday config before you begin the scanners.
-
-## Creating your own Telegram channel to receive your own alerts:
-You can create your own telegram channel to receive alerts wherenevr you run it locally on your laptop either from a command line interface console or run it as a scheduler. Simply, go ahead and
-1. Create a bot for yourself, then a channel and get their IDs. Follow the steps in https://medium.com/codex/using-python-to-send-telegram-messages-in-3-simple-steps-419a8b5e5e2 and https://www.siteguarding.com/en/how-to-get-telegram-bot-api-token
-2. After you have created the bot using `botFather` and have received/verified your bot id/token and channel ID using `get id bot`, simply go to `pkscreener` folder in the source code directory and create a `.env.dev` file with the following (If you are instead using the .exe or .bin or .run file from release, just create this file in the same folder where the executable (.exe or .bin or .run) is placed.)
-```
-CHAT_ID=Your_Channel_Id_Here_Without_A_Hyphen_or_Minus_Sign
-TOKEN=Your_Bot_Token_Here
-chat_idADMIN=Your_Own_ID_Here
-```
-3. From now on, you will begin to receive your own alerts on your telegram channel.
-   ![alerts](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/alerts.png)
-
-## Troubleshooting and Logs:
-If you are having issues running the program, you can just launch a command line interface (On windows> Start > Run > cmd) and then launch PKScreener with a command line option of `-l`. For example, `python pkscreenercli.py -l`. This will show you the path where the program will save all the log outputs from this run. Copy that path and go ahead and run the application. Altenatively, you can just go ahead and modify the `logsEnabled` value to `y`, save & close it and then run `python pkscreenercli.py`.
-
-After you have finished the run, go to that copied path, zip the contents of the file `pkscreener-logs.txt` and create an issue at https://github.com/pkjmesra/PKScreener/issues. Please do not forget to attach the log files in the issue.
-
-## Contributing:
-* Please feel free to Suggest improvements bugs by creating an issue.
-* Please follow the [Guidelines for Contributing](https://github.com/pkjmesra/PKScreener/blob/main/CONTRIBUTING.md) while making a Pull Request.
-
-## Disclaimer:
-* DO NOT use the results provided by the software 'solely' to make your trading decisions.
-* Always backtest and analyze the stocks manually before you trade.
-* The Author(s), the software and any related/unrelated entity will not be held liable for your own investing decisions or losses. The authors or this softfware does not make any claim about the correctness of the results.
-* This screener began as a [fork](https://github.com/pranjal-joshi/Screeni-py) but has since added a lot of additional scanners, backtesting, Telegram bots, Alerts and a number of modifications and improvements.
-
-[MADE-IN-INDIA-badge]: https://img.shields.io/badge/MADE%20WITH%20%E2%9D%A4%20IN-INDIA-orange
-[MADE-IN-INDIA]: https://en.wikipedia.org/wiki/India
-[Windows-badge]: https://img.shields.io/badge/Windows-0078D6?logo=windows&logoColor=white
-[Windows]: https://github.com/pkjmesra/PKScreener/releases/download/0.45.20240525.407/pkscreenercli.exe
-[Linux-badge]: https://img.shields.io/badge/Linux-FCC624?logo=linux&logoColor=black
-[Linux]: https://github.com/pkjmesra/PKScreener/releases/download/0.45.20240525.407/pkscreenercli.bin
-[Mac OS-badge]: https://img.shields.io/badge/mac%20os-D3D3D3?logo=apple&logoColor=000000
-[Mac OS]: https://github.com/pkjmesra/PKScreener/releases/download/0.45.20240525.407/pkscreenercli.run
-[GitHub release (latest by date)-badge]: https://img.shields.io/github/v/release/pkjmesra/PKScreener
-[GitHub release (latest by date)]: https://github.com/pkjmesra/PKScreener/releases/latest
-[pypi-badge]: https://img.shields.io/pypi/v/pkscreener.svg?style=flat-square
-[pypi]: https://pypi.python.org/pypi/pkscreener
-[wheel-badge]: https://img.shields.io/pypi/wheel/pkscreener.svg?style=flat-square
-[GitHub all releases]: https://img.shields.io/github/downloads/pkjmesra/PKScreener/total?color=Green&label=Downloads&style=for-the-badge
-[License-badge]: https://img.shields.io/github/license/pkjmesra/PKScreener?style=for-the-badge
-[License]: https://github.com/pkjmesra/PKScreener/blob/main/LICENSE
-[Codefactor-badge]: https://www.codefactor.io/repository/github/pkjmesra/PKScreener/badge
-[Codefactor]: https://www.codefactor.io/repository/github/pkjmesra/PKScreener
-[PR-Guidelines-badge]: https://img.shields.io/badge/PULL%20REQUEST-GUIDELINES-red?style=for-the-badge
-[PR-Guidelines]: https://github.com/pkjmesra/PKScreener/blob/new-features/CONTRIBUTING.md
-[github-license]: https://img.shields.io/pypi/l/gspread?logo=github
-[Downloads-badge]: https://static.pepy.tech/personalized-badge/pkscreener?period=total&units=international_system&left_color=black&right_color=brightgreen&left_text=PyPi%20Downloads
-[Downloads]: https://pepy.tech/project/pkscreener
-[Latest-Downloads-badge]: https://img.shields.io/github/downloads-pre/pkjmesra/pkscreener/latest/total?logo=github
-[Coverage-Status-badge]: https://coveralls.io/repos/github/pkjmesra/PKScreener/badge.svg?branch=main
-[Coverage-Status]: https://coveralls.io/github/pkjmesra/PKScreener?branch=main
-[codecov-badge]: https://codecov.io/gh/pkjmesra/PKScreener/branch/main/graph/badge.svg
-[codecov]: https://codecov.io/gh/pkjmesra/PKScreener
-[Documentation-badge]: https://readthedocs.org/projects/pkscreener/badge/?version=latest
-[Documentation]: https://pkscreener.readthedocs.io/en/latest/?badge=latest
-[Docker Status-badge]: https://img.shields.io/docker/automated/pkjmesra/pkscreener.svg
-[Docker Status]: https://hub.docker.com/repository/docker/pkjmesra/pkscreener
-[Docker Pulls-badge]: https://img.shields.io/docker/pulls/pkjmesra/pkscreener.svg
-[Prod Scan Tests-badge]: https://github.com/pkjmesra/PKScreener/actions/workflows/w5-workflow-prod-scans_Tests.yml/badge.svg
-[Prod Scan Tests]: https://github.com/pkjmesra/PKScreener/actions/workflows/w5-workflow-prod-scans_Tests.yml
-[After Market-badge]: https://github.com/pkjmesra/PKScreener/actions/workflows/w9-workflow-download-data.yml/badge.svg
-[After Market]: https://github.com/pkjmesra/PKScreener/actions/workflows/w9-workflow-download-data.yml
-[New Features-badge]: https://github.com/pkjmesra/PKScreener/actions/workflows/w10-workflow-features-test.yml/badge.svg
-[New Features]: https://github.com/pkjmesra/PKScreener/actions/workflows/w10-workflow-features-test.yml
-[New Release-badge]: https://github.com/pkjmesra/PKScreener/actions/workflows/w1-workflow-build-matrix.yml/badge.svg
-[New Release]: https://github.com/pkjmesra/PKScreener/actions/workflows/w1-workflow-build-matrix.yml
-[Docker-Build-badge]: https://github.com/pkjmesra/PKScreener/actions/workflows/w15-docker-image.yml/badge.svg
-[Docker-Build]: https://github.com/pkjmesra/PKScreener/actions/workflows/w15-docker-image.yml
-
-<!-- [![Docker Build][Docker-Build-badge]][Docker-Build] [![PKScreener Test - New Features][New Features-badge]][New Features] [![w9. After-Market Data Gen][After Market-badge]][After Market] [![1. PKScreener Build - New Release][New Release-badge]][New Release] [![Documentation][Documentation-badge]][Documentation]
-
-[![GitHub all releases][GitHub all releases]](#) [![GitHub][License-badge]][License] [![BADGE][PR-Guidelines-badge]][PR-Guidelines]
- [![w5. Production Scan Tests On Dev][Prod Scan Tests-badge]][Prod Scan Tests] 
--->
-
-<!--      |                                                                                                                    Discussions []                                                                                                                     | https://t.me/PKScreeners > For any discussion related to PKScreener, you may like to join this related Telegram group                            | <img src="https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/PKScreeners_Group.jpg" alt="Telegram Group" width="100"/> | --> 
+Metadata-Version: 2.1
+Name: pkscreener
+Version: 0.45.20240525.409
+Summary: A Python-based stock screener for NSE, India with alerts to Telegram Channel (pkscreener)
+Home-page: https://github.com/pkjmesra/pkscreener
+Download-URL: https://github.com/pkjmesra/pkscreener/archive/v0.45.20240525.409.zip
+Author: pkjmesra
+Author-email: pkjmesra@gmail.com
+License: OSI Approved (MIT)
+Keywords: NSE,Technical Indicators,Scanning,Stock Scanners
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Operating System :: MacOS
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Description-Content-Type: text/markdown
+License-File: LICENSE
+License-File: LICENSE-Others
+Requires-Dist: advanced-ta
+Requires-Dist: alive-progress ==1.6.2
+Requires-Dist: bs4
+Requires-Dist: gspread
+Requires-Dist: gspread-pandas
+Requires-Dist: joblib
+Requires-Dist: keras
+Requires-Dist: lxml ==4.9.4
+Requires-Dist: numpy
+Requires-Dist: openpyxl
+Requires-Dist: pandas
+Requires-Dist: pandas-ta
+Requires-Dist: Pillow ==9.5.0
+Requires-Dist: PKDevTools
+Requires-Dist: PKNSETools
+Requires-Dist: Pyarrow
+Requires-Dist: pyppeteer
+Requires-Dist: pytz
+Requires-Dist: requests-cache
+Requires-Dist: rich
+Requires-Dist: scikit-learn
+Requires-Dist: scipy <=1.12.0
+Requires-Dist: tabulate
+Requires-Dist: tensorflow
+Requires-Dist: urllib3
+Requires-Dist: xlsxwriter
+Requires-Dist: yfinance
+Requires-Dist: windows-curses ; "windows" in sys_platform
+
+![Title](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/title.png)
+
+# PKScreener
+
+[![MADE-IN-INDIA][MADE-IN-INDIA-badge]][MADE-IN-INDIA] [![Windows][Windows-badge]][Windows] [![Linux][Linux-badge]][Linux] [![Mac OS][Mac OS-badge]][Mac OS] [![GitHub release (latest by date)][GitHub release (latest by date)-badge]][GitHub release (latest by date)] [![CodeFactor][Codefactor-badge]][Codefactor] [![Downloads][Downloads-badge]][Downloads] ![latest download][Latest-Downloads-badge] ![github license][github-license] [![PyPI][pypi-badge]][pypi] [![is wheel][wheel-badge]][pypi] [![Coverage Status][Coverage-Status-badge]][Coverage-Status] [![codecov][codecov-badge]][codecov] [![Docker Status][Docker Status-badge]][Docker Status]
+[![Docker Pulls][Docker Pulls-badge]][Docker Status] 
+
+## What is PKScreener?
+| Telegram Alerts | Nifty AI Prediction | Scheduling Cron Jobs | On-Demand Telegram Bot | Backtesting / Growth of 10k|
+| :-------------: | :-----------------: | :------------------: | :--------------------: | ----------- |
+
+| Nifty screening | Volume scanners | Breakout detection | Consolidating stocks | Reversal Signals |
+| :-------------: | :-------------: | :----------------: | :------------------: | ---------------- |
+
+| Chart Patterns | CCI scanners | 2% scanners | Short-term bulls | NR4 / NR7 | Weekly Releases |
+| :------------: | :----------: | :---------: | :--------------: | :-------: | --------------- |
+
+| Fair Value | Mutual funds, FII data | TTM Squeeze | Golden Crossover | Death Crossover|
+| :-----------: | :-----------: | :--------: | :--------------: | ------------------- |
+
+| RSI screening | MACD scanners | IPO Stocks | Momentum Gainers | Watchlist screening |
+| :-----------: | :-----------: | :--------: | :--------------: | ------------------- |
+
+| Stock Performance | 52Wk H/L Breakouts | 10 days low breakouts | Aroon Crossover | Next Day Bullish Stocks|
+| :-----------: | :-----------: | :--------: | :--------------: | ------------------- |
+
+| Today's Breakouts | Breaking out now | Popular stocks by Mutual Funds / FIIs | Higher Highs | Lower Lows|
+| :-----------: | :-----------: | :--------: | :--------------: | ------------------- |
+
+| F&O Stocks screening | Live 5-EMA Index Scan | Logging | Telegram Channel | Early Breakouts |
+| :------------------: | :-------------------: | :-----: | :--------------: | --------------- |
+### A Python-based stock screener for NSE, India.
+
+**pkscreener** is an advanced stock screener to find potential breakout stocks from NSE and tell it's possible breakout values. It also helps to find the stocks which are consolidating and may breakout, or the particular chart patterns that you're looking specifically to make your decisions.
+pkscreener is totally customizable and it can screen stocks with the settings that you have provided.
+
+You can get daily scan results/alerts at scheduled times by subscribing to the following Telegram channel:
+|    Purpose     |                                                                                                                   Description/link                                                                                                                    | QR Code                                                                                                                                          |                                                                                                                                            |     |
+| :------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | ------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------ | --- |
+| Alerts Channel | https://t.me/PKScreener > You wil receive all the major alerts on this telegram channel. These alerts are sent for all major strategy scans daily around 9:30am-10:15am and then around 4pm. You will also receive the next day's market predictions. | <img src="https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/Telegram_Channel_Prod.jpg" alt="Telegram Channel" width="100"/> |                                                                                                                                            |     |
+|      |
+
+![telegram](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/telegram.png)
+
+## Receiving Scheduled Scan results
+If you would like to receive the scan results, please join the telegram channel and group above. 
+You may receive the following scan results:
+1. [![1. Next day Nifty/Market AI prediction](https://github.com/pkjmesra/PKScreener/actions/workflows/w4-workflow-prod-scans_1.yml/badge.svg)](https://github.com/pkjmesra/PKScreener/actions/workflows/w4-workflow-prod-scans_1.yml) by 4pm IST, Monday - Friday
+2. For all Nifty stocks at/by 9:45-10:15am and by 4pm IST, Monday - Friday
+
+   * Certain selected but configurable alerts for specific scan types
+
+## Receiving On-Demand Scan results
+You can now run the `pkscreenerbot` on your local machine or if it's running on the GitHub server under a GitHub Actions workflow, you can use the `pkscreener Bot`(@nse_pkscreener_bot on Telegram) to get on-demand scan results.
+
+![bot](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/bot.gif)
+
+## Scanners
+
+Screening options to choose from:
+* Artificial Intelligence v2 for Nifty 50 Prediction
+* Live Index Scan : 5 EMA for Intraday
+* Screen stocks by the stock names (NSE Stock Code)
+* Nifty 50
+* Nifty Next 50
+* Nifty 100
+* Nifty 200
+* Nifty 500
+* Nifty Smallcap 50
+* Nifty Smallcap 100
+* Nifty Smallcap 250
+* Nifty Midcap 50
+* Nifty Midcap 100
+* Nifty Midcap 150
+* Nifty (All Stocks)
+* Newly Listed (IPOs in last 2 Year)
+* F&O Stocks Only
+* NASDAQ
+
+Followin scanners are already implemented. Others are `In Progress`
+```
+0 > Full Screening (Shows Technical Parameters without any criterion)
+     1 > Probable Breakouts              	2 > Today's Breakouts
+     3 > Consolidating stocks            	4 > Lowest Volume in last 'N'-days (Early Breakout Detection)
+     5 > RSI screening                   	6 > Reversal Signals
+     7 > Stocks making Chart Patterns    	8 > CCI outside of the given range
+     9 > Volume gainers                  	10 > Closing at least 2% up since last 3 days
+    11 > Short term bullish stocks(Intraday)	12 > 15 Minute Price & Volume breakout(Intraday)
+    13 > Bullish RSI & MACD(Intraday)       	14 > NR4 Daily Today
+    15 > 52 week low breakout(today/1 wk)	16 > 10 days low breakout
+    17 > 52 week high breakout(today/1 wk)	18 > Bullish Aroon(14) Crossover
+    19 > MACD Histogram x below 0       	20 > Bullish for next day
+    21 > Most Popular Stocks            	22 > View Stock Performance         
+    23 > Breaking out now               	24 > Higher Highs,Lows & Close      
+    25 > Lower Highs,Lows (Watch for Reversal)            	
+```
+## Running Piped Scanners
+
+https://github.com/pkjmesra/PKScreener/assets/1358101/9e579371-1035-400a-9f65-139d8407f6c7
+
+
+## How to use on your own local Windows/Linux/Macbook laptop?
+
+# Using docker, running within docker container
+* Download and install docker desktop: https://docs.docker.com/get-docker/
+* After installation, launch/run docker desktop and if it asks, login using your docker credentials.
+* Launch any command line (for example, cmd on windows or terminal on Mac) and type `docker pull pkjmesra/pkscreener:latest`. Then type `docker run -it pkjmesra/pkscreener:latest`.  
+The option `-i` will open the `pkscreener` in interactive mode within docker. `-t` will allocate a pseudo terminal for you so you can begin to use `pkscreener`
+
+# Installing the latest version from PyPi.
+* Go ahead and install using `pip install pkscreener`
+* This should install all of the major dependencies, except maybe, TA-Lib.
+* This app can still run without TA-Lib, but if you need to install TA-Lib for technical indicators (which otherwise is used from `pandas_ta` in the absence of TA-Lib), you can do this: Head to `.github/dependencies/` under this repo. Download the respective TA-Lib file/whl file and install either from the .whl file or from source. Check out any of the workflow files for steps to install TA-Lib.
+
+For example:
+
+For `Windows`: See https://github.com/pkjmesra/PKScreener/blob/c1e94ba3137915cb781161fa2d5fb69129940fd3/.github/workflows/w1-workflow-build-matrix.yml#L91-L101 
+
+For `Mac`: Run `brew install ta-lib` assuming you have homebrew installed.
+
+For `Ubuntu/Linux`: See https://github.com/pkjmesra/PKScreener/blob/main/.github/workflows/w1-workflow-build-matrix.yml#L121-L132
+
+* Now launch your favorite command line CLI and issue `pkscreener`. This will launch the pkscreener executable.
+
+# Building from source repo
+* Install python 3.9 for your OS/CPU. Download the installer from https://www.python.org/downloads/release/python-3913/#Files
+* Just clone the repo with `git clone https://github.com/pkjmesra/PKScreener.git`
+* `cd PKScreener`
+* `pip install -r requirements.txt` .
+* (Optional) If you would like to have technical indicators evaluated using TA-Lib, go ahead and install TA-Lib as well. `pip3 install ta-lib`. Please review additional steps to buil TA-Lib in the workflow files meant for your OS under .github > workflows and follow the line numbers from the previous section.
+* `cd pkscreener`
+* Finally, from within the `pkscreener` directory, run `python pkscreenercli.py`. Or just type/run `pkscreener`. You are all set.
+
+# Running the executables
+* Download the suitable file according to your OS.
+* Linux & Mac users should make sure that the `pkscreenercli.bin or pkscreenercli.run` is having `execute` permission. (`chmod +x pkscreenercli.run`)
+
+* **Run** the file. Following window will appear.
+
+
+* **Configure** the parameters as per your requirement using `Option > E`.
+
+![config](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/config.png)
+
+* **Scanner Menus** the scanner menus for each level/sub-level
+  ![menulevel1](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/menu.png)
+  ![menulevel2](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/menu_level2.png)
+  ![menulevel3](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/menu_level3.png)
+
+
+* Following are the screenshots of screening and output results.
+
+![screening](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/screening.png)
+
+Results :
+
+![results](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/results.png)
+
+It also shows you how the chosen scan option has fared in the past. 1-Pd, 2-Pd means 1 day, 2 days from the date of scan in the past when those stocks came into the results of the chosen scan option.
+
+![results](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/result_analysis.png)
+* Once done, you can also save the results in an excel file.
+
+## Growth of 10k
+
+You can see the performance of your stocks and/or at portfolio level using "Growth of 10k".
+
+![G10k](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/G10k.png)
+
+It also summarises the Growth of 10k at portfolio level for the last quarter so that you know which filters worked best in the past:
+
+![G10k_Sum](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/G10k_Sum.png)
+
+## Backtests
+You can now use the *Backtests* menu to backtest any of the selected strategies. See https://pkjmesra.github.io/PKScreener/BacktestReports.html
+
+![backtest](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/backtest.png)
+
+* Once done, you can also view the output html file saved at the same location from where you launched the app.
+
+## Scanning as a scheduled job once or at regular intervals
+* Running it once with pre-defined inputs
+  You can also run it as a one time job in any scheduler with pre-defined options. For example `./pkscreenercli.py -a Y -o X:12:10 -e` (or `pkscreenercli.exe -a Y -o X:12:10 -e` if you're executing with the exe) will run the scanner for all Nifty stocks and find all stocks matching CCI filter, save the results in xlsx file and exit. `./pkscreenercli.py -a Y -o X:12:9:2.5 -e` will run the scanner (menu option `X`) for all Nifty stocks (menu option `12`) to find volume gainers (menu option `9`) with at least the volume multiplier of 2.5 (input variable `2.5`), save the results in xlsx file and exit (menu option `-e`). Passing in the `-p` option for example `pkscreenercli.py -a Y -p -o X:12:6:1 -e` will also silence all command line prints/outputs and just run silently for the given options, save results and exit. Try and see all options with `./pkscreenercli.py -h`.
+
+* Running it at regular intervals
+  If you want to runn it at regular intervals, you can just pass the interval in `-c` command line option. For example, `./pkscreenercli.py -a Y -o X:12:6:1 -c 180` will run it every `180` seconds with console outputs also being printed. If you'd just like it to run as a cron job without console outputs, you may also pass the `-p` parameter. For example, `./pkscreenercli.py -a Y -p -o X:12:6:1 -c 180`
+
+## Understanding the Result Table:
+
+The Result table contains a lot of different parameters which can be pretty overwhelming to the new users, so here's the description and significance of each parameter.
+
+| Sr  |       Parameter       | Description                                                                                                                                                                                                                  | Example                                                                                  |
+| :-: | :-------------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
+|  1  |       **Stock**       | This is a NSE scrip symbol. If your OS/Terminal supports unicode, You can directly open **[TradingView](https://in.tradingview.com/)** charts by pressing `Ctrl+Click` on the stock name.                                    | [TATAMOTORS](https://in.tradingview.com/chart?symbol=NSE%3ATATAMOTORS)                   |
+|  2  |   **Consolidating**   | It gives the price range in which stock is trading since last `N` days. `N` is configurable and can be modified by executing `Edit User Configuration` option.                                                               | If stock is trading between price 100-120 in last 30 days, Output will be `Range:20.0 %` |
+|  3  | **Breakout (N Days)** | This is pure magic! The `BO` is Breakout level in last N days while `R` is the next resistance level if available. Investor should consider both BO & R level to decide entry/exits in their trades.                         | `B:302, R:313`(Breakout level is 100 & Next resistance is 102)                           |
+|  4  |        **LTP**        | LTP is the Last Traded Price of an asset traded on NSE.                                                                                                                                                                      | `298.7` (Stock is trading at this price)                                                 |
+|  5  |      **Volume**       | Volume shows the relative volume of the recent candle with respect to 20 period MA of Volume. It could be `Unknown` for newly listed stocks.                                                                                 | if 20MA(Volume) is 1M and todays Volume is 2.8M, then `Volume = 2.8x`                    |
+|  6  |     **MA-Signal**     | It describes the price trend of an asset by analysing various 50-200 MA/EMA crossover strategies.                                                                                                                            | `200MA-Support`,`BullCross-50MA` etc                                                     |
+|  7  |        **RSI**        | For the momentum traders, it describes 14-period RSI for quick decision making about their trading plans                                                                                                                     | `0 to 100`                                                                               |
+|  8  |       **Trend**       | By using advance algorithms, the average trendlines are computed for `N` days and their strenght is displayed depending on steepness of trendlines. (This does NOT show any trendline on chart, it is calculated internally) | `Strong Up`, `Weak Down` etc.                                                            |
+|  9  |      **Pattern**      | If the chart or the candle itself forming any important pattern in the recent timeframe or as per the selected screening option, various important patterns will be indicated here.                                          | `Momentum Gainer`, `Inside Bar (N)`,`Bullish Engulfing` etc.                             |
+
+## Hack it your way:
+Feel free to Edit the parameters in the `pkscreener.ini` file which will be generated by the application.
+```
+[config]
+period = 1y
+daystolookback = 22
+duration = 1d
+minprice = 20.0
+maxprice = 50000.0
+volumeratio = 2.5
+consolidationpercentage = 10.0
+shuffle = y
+cachestockdata = y
+onlystagetwostocks = y
+useema = n
+showunknowntrends = y
+logsenabled = n
+generaltimeout = 2.0
+longtimeout = 4.0
+maxnetworkretrycount = 10
+backtestperiod = 60
+minimumvolume = 10000
+```
+Try to tweak this parameters as per your trading styles. For example, If you're comfortable with weekly charts, make `duration=5d` and so on. For intraday, you can set `period=1d and duration=5m` if you would like to calculate with 5minute candles. Set the duration to `15m` or whatever value you desire, but keep the period to `1d`. This tool, however, works best for short/mid term instead of intraday, but some scans like momentum/volume/NR4 etc can be used for screening stocks for intraday as well. You can use the toggle menu option `T` to toggle between long term and intraday config before you begin the scanners.
+
+## Creating your own Telegram channel to receive your own alerts:
+You can create your own telegram channel to receive alerts wherenevr you run it locally on your laptop either from a command line interface console or run it as a scheduler. Simply, go ahead and
+1. Create a bot for yourself, then a channel and get their IDs. Follow the steps in https://medium.com/codex/using-python-to-send-telegram-messages-in-3-simple-steps-419a8b5e5e2 and https://www.siteguarding.com/en/how-to-get-telegram-bot-api-token
+2. After you have created the bot using `botFather` and have received/verified your bot id/token and channel ID using `get id bot`, simply go to `pkscreener` folder in the source code directory and create a `.env.dev` file with the following (If you are instead using the .exe or .bin or .run file from release, just create this file in the same folder where the executable (.exe or .bin or .run) is placed.)
+```
+CHAT_ID=Your_Channel_Id_Here_Without_A_Hyphen_or_Minus_Sign
+TOKEN=Your_Bot_Token_Here
+chat_idADMIN=Your_Own_ID_Here
+```
+3. From now on, you will begin to receive your own alerts on your telegram channel.
+   ![alerts](https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/alerts.png)
+
+## Troubleshooting and Logs:
+If you are having issues running the program, you can just launch a command line interface (On windows> Start > Run > cmd) and then launch PKScreener with a command line option of `-l`. For example, `python pkscreenercli.py -l`. This will show you the path where the program will save all the log outputs from this run. Copy that path and go ahead and run the application. Altenatively, you can just go ahead and modify the `logsEnabled` value to `y`, save & close it and then run `python pkscreenercli.py`.
+
+After you have finished the run, go to that copied path, zip the contents of the file `pkscreener-logs.txt` and create an issue at https://github.com/pkjmesra/PKScreener/issues. Please do not forget to attach the log files in the issue.
+
+## Contributing:
+* Please feel free to Suggest improvements bugs by creating an issue.
+* Please follow the [Guidelines for Contributing](https://github.com/pkjmesra/PKScreener/blob/main/CONTRIBUTING.md) while making a Pull Request.
+
+## Disclaimer:
+* DO NOT use the results provided by the software 'solely' to make your trading decisions.
+* Always backtest and analyze the stocks manually before you trade.
+* The Author(s), the software and any related/unrelated entity will not be held liable for your own investing decisions or losses. The authors or this softfware does not make any claim about the correctness of the results.
+* This screener began as a [fork](https://github.com/pranjal-joshi/Screeni-py) but has since added a lot of additional scanners, backtesting, Telegram bots, Alerts and a number of modifications and improvements.
+
+[MADE-IN-INDIA-badge]: https://img.shields.io/badge/MADE%20WITH%20%E2%9D%A4%20IN-INDIA-orange
+[MADE-IN-INDIA]: https://en.wikipedia.org/wiki/India
+[Windows-badge]: https://img.shields.io/badge/Windows-0078D6?logo=windows&logoColor=white
+[Windows]: https://github.com/pkjmesra/PKScreener/releases/download/0.45.20240525.408/pkscreenercli.exe
+[Linux-badge]: https://img.shields.io/badge/Linux-FCC624?logo=linux&logoColor=black
+[Linux]: https://github.com/pkjmesra/PKScreener/releases/download/0.45.20240525.408/pkscreenercli.bin
+[Mac OS-badge]: https://img.shields.io/badge/mac%20os-D3D3D3?logo=apple&logoColor=000000
+[Mac OS]: https://github.com/pkjmesra/PKScreener/releases/download/0.45.20240525.408/pkscreenercli.run
+[GitHub release (latest by date)-badge]: https://img.shields.io/github/v/release/pkjmesra/PKScreener
+[GitHub release (latest by date)]: https://github.com/pkjmesra/PKScreener/releases/latest
+[pypi-badge]: https://img.shields.io/pypi/v/pkscreener.svg?style=flat-square
+[pypi]: https://pypi.python.org/pypi/pkscreener
+[wheel-badge]: https://img.shields.io/pypi/wheel/pkscreener.svg?style=flat-square
+[GitHub all releases]: https://img.shields.io/github/downloads/pkjmesra/PKScreener/total?color=Green&label=Downloads&style=for-the-badge
+[License-badge]: https://img.shields.io/github/license/pkjmesra/PKScreener?style=for-the-badge
+[License]: https://github.com/pkjmesra/PKScreener/blob/main/LICENSE
+[Codefactor-badge]: https://www.codefactor.io/repository/github/pkjmesra/PKScreener/badge
+[Codefactor]: https://www.codefactor.io/repository/github/pkjmesra/PKScreener
+[PR-Guidelines-badge]: https://img.shields.io/badge/PULL%20REQUEST-GUIDELINES-red?style=for-the-badge
+[PR-Guidelines]: https://github.com/pkjmesra/PKScreener/blob/new-features/CONTRIBUTING.md
+[github-license]: https://img.shields.io/pypi/l/gspread?logo=github
+[Downloads-badge]: https://static.pepy.tech/personalized-badge/pkscreener?period=total&units=international_system&left_color=black&right_color=brightgreen&left_text=PyPi%20Downloads
+[Downloads]: https://pepy.tech/project/pkscreener
+[Latest-Downloads-badge]: https://img.shields.io/github/downloads-pre/pkjmesra/pkscreener/latest/total?logo=github
+[Coverage-Status-badge]: https://coveralls.io/repos/github/pkjmesra/PKScreener/badge.svg?branch=main
+[Coverage-Status]: https://coveralls.io/github/pkjmesra/PKScreener?branch=main
+[codecov-badge]: https://codecov.io/gh/pkjmesra/PKScreener/branch/main/graph/badge.svg
+[codecov]: https://codecov.io/gh/pkjmesra/PKScreener
+[Documentation-badge]: https://readthedocs.org/projects/pkscreener/badge/?version=latest
+[Documentation]: https://pkscreener.readthedocs.io/en/latest/?badge=latest
+[Docker Status-badge]: https://img.shields.io/docker/automated/pkjmesra/pkscreener.svg
+[Docker Status]: https://hub.docker.com/repository/docker/pkjmesra/pkscreener
+[Docker Pulls-badge]: https://img.shields.io/docker/pulls/pkjmesra/pkscreener.svg
+[Prod Scan Tests-badge]: https://github.com/pkjmesra/PKScreener/actions/workflows/w5-workflow-prod-scans_Tests.yml/badge.svg
+[Prod Scan Tests]: https://github.com/pkjmesra/PKScreener/actions/workflows/w5-workflow-prod-scans_Tests.yml
+[After Market-badge]: https://github.com/pkjmesra/PKScreener/actions/workflows/w9-workflow-download-data.yml/badge.svg
+[After Market]: https://github.com/pkjmesra/PKScreener/actions/workflows/w9-workflow-download-data.yml
+[New Features-badge]: https://github.com/pkjmesra/PKScreener/actions/workflows/w10-workflow-features-test.yml/badge.svg
+[New Features]: https://github.com/pkjmesra/PKScreener/actions/workflows/w10-workflow-features-test.yml
+[New Release-badge]: https://github.com/pkjmesra/PKScreener/actions/workflows/w1-workflow-build-matrix.yml/badge.svg
+[New Release]: https://github.com/pkjmesra/PKScreener/actions/workflows/w1-workflow-build-matrix.yml
+[Docker-Build-badge]: https://github.com/pkjmesra/PKScreener/actions/workflows/w15-docker-image.yml/badge.svg
+[Docker-Build]: https://github.com/pkjmesra/PKScreener/actions/workflows/w15-docker-image.yml
+
+<!-- [![Docker Build][Docker-Build-badge]][Docker-Build] [![PKScreener Test - New Features][New Features-badge]][New Features] [![w9. After-Market Data Gen][After Market-badge]][After Market] [![1. PKScreener Build - New Release][New Release-badge]][New Release] [![Documentation][Documentation-badge]][Documentation]
+
+[![GitHub all releases][GitHub all releases]](#) [![GitHub][License-badge]][License] [![BADGE][PR-Guidelines-badge]][PR-Guidelines]
+ [![w5. Production Scan Tests On Dev][Prod Scan Tests-badge]][Prod Scan Tests] 
+-->
+
+<!--      |                                                                                                                    Discussions []                                                                                                                     | https://t.me/PKScreeners > For any discussion related to PKScreener, you may like to join this related Telegram group                            | <img src="https://raw.githubusercontent.com/pkjmesra/PKScreener/main/screenshots/PKScreeners_Group.jpg" alt="Telegram Group" width="100"/> | -->
```

## Comparing `pkscreener-0.45.20240525.408.dist-info/RECORD` & `pkscreener-0.45.20240525.409.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/__init__.py,sha256=j-3j5qAOD6KptygTxNHLqfFbxeBGISq6RzxPloabnc4,1582
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/courbd.ttf,sha256=SKpnp-BRs7AZcdI83nencS3Q7xe0anbbP1YMOxLlEhU,791436
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/globals.py,sha256=aWZS9CLPGZCY7iyYQgJ3CXP5XT8cfWNlzcJdAWfHIEg,147505
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreener.ini,sha256=SDe9vJyDXYsj3niL8tWOS7ufh-xCcaveXJpRBxORe3w,1092
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreenerbot.py,sha256=Ra8VRP6VsVu4pQ6vXLE2RXjGCJHnw1TQOmVzo2-lZBs,54099
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/pkscreenercli.py,sha256=kak5lo4J8DPDqi2YXQn-pouGXsIB3q_m7MkQoXjfD48,34505
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ArtTexts.py,sha256=Ht0doXVJs6eJxLO8KdL3DQOoE6cduyh20jqydkpy5Qg,13324
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Backtest.py,sha256=-h9Tz1cBWaedFZG2vn3meUb7stfp7ObI_a_JsecdMq8,10156
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Barometer.py,sha256=Y27WUHMrOkQ5FsBIwgq1NrUfW4qpwr9-T63B1Ka5sGw,5641
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/CandlePatterns.py,sha256=CcHNok3tk8ge2vHIbD53cHd8M2ofgccyAh7XTgNuOu4,17333
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Changelog.py,sha256=-Xeq9VfMTVxk_s3bZXoNNo63RcxXJdVW659k8agM4CQ,1537
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ConfigManager.py,sha256=llFZ6H80g2prvDm75uqc_xZ1T9bXMl8Mb1vSwbB9ChE,34244
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Fetcher.py,sha256=hTRij5B57xUM3m-Gwh7RM1xGtcTYCgCu7eHvo14ONPQ,10305
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MarketMonitor.py,sha256=Pfmpg12HLuYcQjGVD-kajPg5qBjKiLi34UX-K4tLC-A,13457
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MarketStatus.py,sha256=JxEbScwI3-5mc4EwLmHNvWMcStTv8nddwi3hwks8vy4,3673
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/MenuOptions.py,sha256=oICs1M3LUIC7mpikISbpGO-WM21Gt1TcLFM1FqBIXTM,45614
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/OtaUpdater.py,sha256=_QO5LGoKXnlJWUCU7mXiGGH1pmfi2dhiMAwfUJaiPmY,12534
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKMarketOpenCloseAnalyser.py,sha256=S2EIqMn8-KSevo3rU6ehddcwmpJtPzgpgXzyd6d-cDU,24598
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScanRunner.py,sha256=oUwIN2OtrFYRRo7cqsC5RPo5G0qbm9UAUesXT58uYO8,22819
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScheduledTaskProgress.py,sha256=TWHygSiNMdr0zMpdnPUDvLRbcbHv0cLtFuiTnpsTI00,1623
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKScheduler.py,sha256=qIHEEvzec5sU-kHP7RQaoKy39cYiY1jtEgFB6Pnc9ng,8313
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKSpreadsheets.py,sha256=BIICJx79QjGFPrnmQ34357jOGp79vuiknx6A_kC9y8Y,8466
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PKTask.py,sha256=YPxzn0dA5ty7CtRFi1wQphC9vCdK8tB2_3DYHje9jgc,1907
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Pktalib.py,sha256=283tuMxsnGcNqTT3nYMVhV8XvAgxHzzD3P47VFjh5n0,18947
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Portfolio.py,sha256=bicRiUVqUcwGMOjJSi97PAdTUBgnos2mLOI1W_i3aX8,14177
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/PortfolioXRay.py,sha256=t_cmozhTh2EJhH14Jo32ZnGF3luAXoxseHIMo8FkKHc,49043
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/ScreeningStatistics.py,sha256=gpMtMGK2jnE3SUEKznln0S-ZVvNW1yrcSHMtemdXrso,157153
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/StockScreener.py,sha256=6jVi_C49itvYShuKvaOpBNx3BssUU7YFQ_WDhYDxPnY,56940
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/UserMenuChoicesHandler.py,sha256=KlTGur_ZJrEmUVRIGMHUK49LcqGxho9NKWmhFumV-HY,4993
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/Utility.py,sha256=J1KfF6At_W2xiXIpwsFvt3Hj0cQOUw62Fb6s15GZrt0,86151
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/WorkflowManager.py,sha256=U00RbhW78pnQYHGWpbQo0BXeLEFpXotz2cC2H1MNQME,3789
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/__init__.py,sha256=DAdsZmF3ke7JFku7yomxENThv2e7RHqFm7Km6uVzuVc,28
-pkscreener-0.45.20240525.408.data/purelib/pkscreener/classes/keys.py,sha256=-U5xboBz2z2_ljBJig5fRr63VF7q9CIDbGn-O9crWIc,5262
-pkscreener-0.45.20240525.408.dist-info/LICENSE,sha256=wrl88eUZgDW6osq1UZIU4s4uZCgqGcLa46dS_sMVLik,1086
-pkscreener-0.45.20240525.408.dist-info/LICENSE-Others,sha256=eOoTKIUFAEPyU7y_ckmzUnQQa4-q5d-aLDWZ8gpafc8,1091
-pkscreener-0.45.20240525.408.dist-info/METADATA,sha256=TbjHVUfOnY9MtSJMd5Lk3dvdFN-pir30dvPU1dM11Ls,27839
-pkscreener-0.45.20240525.408.dist-info/WHEEL,sha256=nSybvzWlmdJnHiUQSY-d7V1ycwEVUTqXiTvr2eshg44,102
-pkscreener-0.45.20240525.408.dist-info/entry_points.txt,sha256=Pm30xm4sU7YFtFJUC-Te8VlqOvYAvWKFFA5AfQE0xGY,120
-pkscreener-0.45.20240525.408.dist-info/top_level.txt,sha256=oIfcPPw58Q4KU-GDqp25dXbrtvxYXJBCo_em6i5aVvY,11
-pkscreener-0.45.20240525.408.dist-info/RECORD,,
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/__init__.py,sha256=6YOmC8GD2ORgyK0Vh5brdyZY_zvda9JBSsNj5Gbj-lU,1547
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/courbd.ttf,sha256=SKpnp-BRs7AZcdI83nencS3Q7xe0anbbP1YMOxLlEhU,791436
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/globals.py,sha256=L4cTZ_QfUfgaBLnzGeDE7CU8JasKLcWxq5fw9Rt-458,144558
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreener.ini,sha256=mJFUwaDwvLlow6DuSB0OfSzmpWVH5DlUxFvBGLKm1-0,1055
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreenerbot.py,sha256=VdXAEVoO9LJylzi39E8-6SfdTjdlD6kJlSfhp4VSgpE,52903
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/pkscreenercli.py,sha256=tmw9vf6Z2a4_b-FE9N8NmGTZ9lEHZHZoDP1gKhZO2ow,33692
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ArtTexts.py,sha256=oxG318Z_pu1YuPEAXkTDTEczYjcgWla9t7TiJ-kx3Nw,13194
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Backtest.py,sha256=eiol3Nndy4DxbpWX-ylYFGlMM0ulHSufX76SvoGsxT8,9908
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Barometer.py,sha256=6OBnpeWcZuxeY3PBbfmuyC8d0bmxZdya1PanQT7B9tU,5537
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/CandlePatterns.py,sha256=WLnJFzDZ0zXTTFG83PmLwlQfDZNRtpWlYfOTn4RGT0Y,16986
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Changelog.py,sha256=dPFVgC3kxvWv5g7w-J2-k7V0MKhevtuy3k1SoSo8q50,1494
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ConfigManager.py,sha256=Svmla_yZ6YSB6fRndSkcVh9Qd-rIcgvyCms8xZTEhm0,33644
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Fetcher.py,sha256=8WSElL7C_ZM-ufZCjGAohQHdcyW0UXbllUS9-jqQxnQ,10050
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MarketMonitor.py,sha256=y1iuUQbvvpPFhE4XUwWQZsmszEaMVsO536dwCjZp0Ps,13213
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MarketStatus.py,sha256=tJbRnnK2VGpXrmP8S7U-ysPZoDfmgvlc59o6-ijIbbw,3591
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/MenuOptions.py,sha256=PiFRamRXG0vGzxyX3JyKWnPhbK4cjibUdr3NlMz5rtA,44414
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/OtaUpdater.py,sha256=9r28X_3H6DwB3YJRRLdVHR2XL4kWX6uvvlupmhFzM74,12232
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKMarketOpenCloseAnalyser.py,sha256=916Fzd-iq7KvmCzI21t9T68WbqCxZ_IA34dVEY-um4Y,24198
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScanRunner.py,sha256=NN_TgcNh6SIl0_levGvkHaGVas_wsmXSlwkYhQEMG8M,22357
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScheduledTaskProgress.py,sha256=JldQVfTe-trKIWFfM0dbMONx3C2RLSXx1YueochZ85w,1588
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKScheduler.py,sha256=AOFLYSINJzTlRF4o2eW4ugX7-6hh8SVlbMzV80mHXcQ,8143
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKSpreadsheets.py,sha256=1I7YGGPPY879K5JeTZ_d1FNCpjloh6TZrx91JlwT20o,8298
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PKTask.py,sha256=4q87uD2cXvp0AbP6I73xPP39F0mfnpHQutsxxqpnxJM,1867
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Pktalib.py,sha256=tkn8MLOHd4Ae6h9Lfxtayjf0OACZrkS1UVqhcXENYWE,18470
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Portfolio.py,sha256=xvgjpLjnIvoTRLljOpohtWO5MjwilPDRdzRs60ntSuc,13876
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/PortfolioXRay.py,sha256=r_tJkf6hyRSO3UpjmxYXqAz668EczHNFWD71Gi4pTnQ,47779
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/ScreeningStatistics.py,sha256=-lFpmw_wVCuJ3hT0bXcNNoTWhiQfRMnn1Iha0ePfxVE,154008
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/StockScreener.py,sha256=GtKQGPxgG9Y_uKMpg24Gf8YTIPnb0Co1mT91bXLF3gI,55902
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/UserMenuChoicesHandler.py,sha256=PPyQ-wa4yvKqjxHedsUJOnJ6RdeMQMnN5ngyN7wVfIA,4885
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/Utility.py,sha256=WojRbWMmfzWY4Y4dvalxGR6v9B743lF8Clg9VFOSswM,84541
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/WorkflowManager.py,sha256=nZqKruMqcFcjjmf2yx4oYYH4cKgleGVwcxdkIKiMZ78,3694
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/__init__.py,sha256=iG1Vvdfm2Ih3t1hUkKIOOuPeZ4N-VeSR-qKC1qIBI3M,28
+pkscreener-0.45.20240525.409.data/purelib/pkscreener/classes/keys.py,sha256=AoPN4_25kNqOXHWPL9e-b9A4ua_zi6TVimYHu2xgcpA,5122
+pkscreener-0.45.20240525.409.dist-info/LICENSE,sha256=5kDneOnQ4s9IktVsbcPcs6o0GhW7Rw_ySDac6TA2Cw4,1065
+pkscreener-0.45.20240525.409.dist-info/LICENSE-Others,sha256=JzVWVNE6wcFa0cJcTQE98YwPYf1hMVSugQPmDxyjJVE,1070
+pkscreener-0.45.20240525.409.dist-info/METADATA,sha256=Wo7V7L0993an77nFpsyG59LaUQ2WLXktw-XDFCw0zsU,28250
+pkscreener-0.45.20240525.409.dist-info/WHEEL,sha256=eupBwbXGAhwNAPJSvj5BiShZwdZO8jnQ5yHfv-9aUGw,115
+pkscreener-0.45.20240525.409.dist-info/entry_points.txt,sha256=Pm30xm4sU7YFtFJUC-Te8VlqOvYAvWKFFA5AfQE0xGY,120
+pkscreener-0.45.20240525.409.dist-info/top_level.txt,sha256=oIfcPPw58Q4KU-GDqp25dXbrtvxYXJBCo_em6i5aVvY,11
+pkscreener-0.45.20240525.409.dist-info/RECORD,,
```

